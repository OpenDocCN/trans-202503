- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MAX-FLOW
    ALGORITHMS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">最大流算法</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Earlier chapters have demonstrated various ways to use graphs to model connectivity
    and transportation problems. This chapter considers the *overall capacity* of
    networks and how things can flow through them. Imagine we want to model the amount
    of water that can flow through a network of pipes. We can use edge weights to
    represent how much water can flow between any two nodes, allowing us to determine
    the maximum capacity of the entire network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章已经展示了如何利用图来建模连接性和交通问题。本章考虑了网络的*整体容量*以及流量如何在其中流动。假设我们想要模拟水流通过管道网络的情况。我们可以使用边的权重来表示任意两节点之间可以流过多少水，从而帮助我们确定整个网络的最大容量。
- en: The *maximum-flow problem* seeks to determine how much flow a graph can support
    when given edges with limited capacity. This phrasing is intentionally general.
    We could be modeling the flow of water through a pipe, the flow of people through
    a transportation network, or the flow of information through a social network.
    Each application brings its own terminologies, measurements, and units. However,
    they all boil down to the same fundamental question.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大流问题*旨在确定在给定有限容量的边时，图可以支持多少流量。这个表述是有意保持一般性的。我们可能在模拟水流通过管道、人员流动通过交通网络，或者信息流动通过社交网络。每个应用都带来了自己的术语、测量方法和单位。然而，它们都归结为一个基本问题。'
- en: In this chapter, we consider the task of computing the maximum flow on a directed,
    weighted graph, using the *Ford-Fulkerson* and *Edmonds-Karp* algorithms. Along
    the way, we show how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structures
    on which we’ve relied in previous chapters to account for dynamic usage of capacity
    through the edges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们考虑如何在有向带权图上计算最大流量，使用*Ford-Fulkerson*和*Edmonds-Karp*算法。在此过程中，我们展示如何扩展我们在前几章中使用的<code
    class="SANS_TheSansMonoCd_W5Regular_11">Graph</code>和<code class="SANS_TheSansMonoCd_W5Regular_11">Edge</code>数据结构，以支持边的容量的动态使用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Maximum-Flow Problem</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">最大流问题</samp>
- en: Given a graph with weighted edges that represent the directionality and capacity
    of flow between two adjacent nodes, how do we determine the maximal flow through
    the network? We call the node from which the flow originates the *source node*
    and label it *s*. We call the destination node of the flow the *sink node* and
    label it *t*. We use *capacity*(*u*, *v*) to indicate the capacity of an edge
    from *u* to *v*—that is, the maximum amount of flow an edge can support. We indicate
    the flow through that edge with *flow*(*u*, *v*). The total flow through the network
    is the amount of flow leaving the source (or, equivalently, the amount entering
    the sink).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个带权图，其中的边表示相邻节点之间流动的方向性和容量，我们如何确定网络中的最大流量？我们将流量起点的节点称为*源节点*并标记为*s*，将流量的目的地节点称为*汇节点*并标记为*t*。我们用*容量*（*u*,
    *v*）表示从*u*到*v*的边的容量——即该边能支持的最大流量。我们用*流量*（*u*, *v*）表示通过该边的流量。网络中的总流量是从源节点流出的流量（或者，等效地，进入汇节点的流量）。
- en: We can visualize the max-flow problem in the context of a wastewater processing
    system outside of a city. Imagine that wastewater flows from the city via a single
    source pipe and into the sewage treatment plant via a single sink pipe. In between
    the source and sink, the wastewater travels through pipes of various sizes, with
    its flow dividing and recombining at individual nodes. The capacity of the pipes
    dictates how much wastewater can flow through them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将最大流问题在城市外的废水处理系统中进行可视化。假设废水通过一条源管道从城市流出，再通过一条汇管道进入污水处理厂。在源和汇之间，废水通过不同大小的管道流动，其流量在各个节点之间分配和重新组合。管道的容量决定了可以通过的废水量。
- en: 'To model realistic behavior, the maximum-flow problem imposes several constraints.
    The first is that the source node (the city) only has flow out and the sink node
    (the sewage treatment plant) only has flow in. In mathematical terms:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟现实的行为，最大流问题施加了几个约束条件。第一个约束是源节点（城市）只有流出，而汇节点（污水处理厂）只有流入。从数学角度来看：
- en: '*capacity*(*u*, *s*) = 0 for every node *u*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*容量*（*u*, *s*）= 0 对于每个节点 *u*'
- en: '*capacity*(*t, v*) = 0 for every node *v*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点 *v*，*capacity*(*t, v*) = 0。
- en: This corresponds to the very reasonable constraints that no wastewater may flow
    back to the city through the source pipe, and nothing may flow out from the sewage
    treatment system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于一个非常合理的约束条件，即不能通过源管道将废水流回城市，也不能从污水处理系统流出任何东西。
- en: 'The second constraint is that the flow through an edge (pipe) cannot be less
    than zero nor can it be more than the edge’s capacity. In mathematical terms:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个约束是，通过一条边（管道）的流量不能小于零，也不能超过该边的容量。用数学术语表示：
- en: 0 ≤ *flow*(*u*, *v*) ≤ *capacity*(*u*, *v*) for any pair of nodes *u* and *v*
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意一对节点 *u* 和 *v*，*flow*(*u*, *v*) 的值必须满足 0 ≤ *flow*(*u*, *v*) ≤ *capacity*(*u*,
    *v*)。
- en: The upper bound translates to the physical constraints of the pipe. If we try
    to push too much water through a pipe, it will burst. Nobody wants that. The lower
    bound of zero indicates a directionality of the pipe, such as one-way valves to
    prevent flow back through the pipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上限转化为管道的物理约束。如果我们试图通过管道推送过多的水，它将爆裂。没有人希望发生这种情况。零的下限表示管道的方向性，例如单向阀门以防止水流反向流过管道。
- en: 'The final constraint is that for all nodes except the source and the sink,
    the amount of flow into the node must equal the amount of flow out. Mathematically,
    this means that for every node *u*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的约束是，对于除源点和汇点之外的所有节点，流入该节点的流量必须等于流出该节点的流量。在数学上，这意味着对于每个节点 *u*：
- en: ∑v *flow*(*v, u*) = ∑v *flow*(*u, v*)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ∑v *flow*(*v*, u*) = ∑v *flow*(*u*, v*)。
- en: This constraint prevents invalid situations at the node, where water is magically
    appearing or disappearing at the pipes’ junctions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束防止了节点处出现无效情况，例如水在管道交汇处神奇地出现或消失。
- en: Until the last few sections of this chapter, we impose an additional constraint
    that will help us reason about maximum-flow algorithms. We disallow *anti-parallel
    edges*, pairs of directed edges between the same nodes in opposite directions.
    In practical terms, this means that if there is an edge from node *u* to node
    *v*, we do not allow an edge from node *v* to node *u*. This restriction helps
    simplify the definition of a *residual network,* discussed in a later section.
    We will relax this restriction toward the end of the chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后几节之前，我们施加了一个额外的约束，这将帮助我们推理最大流算法。我们不允许 *反向边*，即在相反方向上连接相同节点的有向边。实际上，这意味着如果从节点
    *u* 到节点 *v* 有一条边，我们就不允许从节点 *v* 到节点 *u* 有一条边。这个限制有助于简化后面章节中讨论的 *残余网络* 的定义。我们将在本章末尾放宽这一限制。
- en: '[Figure 14-1](#fig14-1) is an example of the maximum-flow problem on a small
    graph. The edge weights in [Figure 14-1(a)](#fig14-1) represent capacity. To compute
    the total flow from a source of node 0 to a sink of node 3, we can add up the
    flow along each path. [Figure 14-1(b)](#fig14-1) shows a configuration with maximum
    flow. Along the top path, we can send 5 units of flow from node 0 to node 1\.
    The edge from node 1 to node 3 can take even more, but that does not help us.
    We cannot get more than 5 units of flow to node 1, so we cannot have more than
    5 units of flow out. Therefore, the maximal flow along the top path is 5.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-1](#fig14-1) 是一个关于小图的最大流问题示例。[图 14-1(a)](#fig14-1) 中的边权表示容量。为了计算从节点 0
    到节点 3 的源点到汇点的总流量，我们可以沿每条路径加总流量。[图 14-1(b)](#fig14-1) 展示了一个最大流配置。在顶部路径上，我们可以从节点
    0 向节点 1 发送 5 单位的流量。从节点 1 到节点 3 的边可以承载更多的流量，但这并不会帮助我们。我们无法将超过 5 单位的流量送到节点 1，因此我们无法让流量超过
    5 单位。因此，顶部路径的最大流为 5。'
- en: '![(A) shows a graph with four nodes and four edges. each edge is labeled with
    its capacity. Edge (0, 1) has capacity 5, edge (0, 2) has capacity 10, edge (1,
    3) has capacity 10, and edge (2, 3) has capacity 1\. (B) shows the same graph
    with edges labeled with their capacity and how much is used. Edge (0, 2) is labeled
    1 of 10.](../images/f14001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个有四个节点和四条边的图，每条边都标有其容量。边 (0, 1) 的容量为 5，边 (0, 2) 的容量为 10，边 (1, 3)
    的容量为 10，边 (2, 3) 的容量为 1。 (B) 显示了相同的图，并标注了每条边的容量及其使用情况。边 (0, 2) 被标记为 1/10。](../images/f14001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: A graph with capacities
    (a) and the maximum flow along the graph’s edges (b)</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-1：带有容量（a）的图和沿图边的最大流（b）</samp>
- en: Similarly, [Figure 14-1(a)](#fig14-1) shows a pair of restrictions along the
    graph’s bottom path. While the edge from node 0 to node 2 looks promising with
    its capacity of 10, we will not be able to push that amount *out* of node 2\.
    The edge (2, 3) presents a severe bottleneck with a capacity of 1\. Like a large
    water pipe that transitions to a small one, the combination of edges limits the
    overall capacity of the bottom path to 1 and the total flow in the network to
    6.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，[图14-1(a)](#fig14-1)显示了图中底部路径上的一对限制。虽然从节点0到节点2的边看起来很有前景，容量为10，但我们将无法将如此多的流量*从*节点2传出。边(2,
    3)成为一个严重的瓶颈，容量为1。就像一条大水管过渡到小水管一样，这些边的组合将底部路径的总容量限制为1，网络中的总流量限制为6。
- en: The maximum-flow problem gets significantly more complicated for larger graphs.
    Consider what happens in [Figure 14-2](#fig14-2) when we add a single new edge
    from node 2 to node 1 with capacity 7\. Perhaps upset by constant sewer backups,
    the government builds a new pipe from node 2 to node 1\. The edge (2, 1) presents
    an alternative path for the flow out of node 2\. Up to 7 units of flow can split
    off and take edge (2, 1), while 1 unit continues to use (2, 3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的图，最大流问题变得更加复杂。考虑在[图14-2](#fig14-2)中，当我们从节点2到节点1添加一条容量为7的新边时会发生什么。也许由于不断发生下水道倒灌，政府决定从节点2到节点1建造一条新管道。边(2,
    1)为节点2的流量提供了另一条路径。最多可以有7个单位的流量分流并通过边(2, 1)，同时1个单位继续通过(2, 3)。
- en: '![(A) shows a graph with four nodes and five edges. each edge is labeled with
    its capacity. (B) shows the same graph with edges labeled with their capacity
    and how much is used. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is using
    6 of 10 capacity, edge (1, 3) is using 10 of 10 capacity, edge (2, 1) is using
    5 of 7 capacity, and edge (2, 3) is using 1 of 1 capacity.](../images/f14002.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![(A)显示了一个包含四个节点和五条边的图，每条边上标有其容量。(B)显示了相同的图，并标出了边的容量和已使用的流量。边(0, 1)使用了5个单位的容量，边(0,
    2)使用了6个单位的容量，边(1, 3)使用了10个单位的容量，边(2, 1)使用了5个单位的容量，边(2, 3)使用了1个单位的容量。](../images/f14002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: A second example
    graph with capacities (a) and the maximum flow along those edges (b)</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-2：带容量的第二个示例图（a）及其沿这些边的最大流量（b）</samp>
- en: However, we need to ensure that the new path through node 1 can handle this
    additional flow. We already have 5 units of flow from node 0 to node 1\. Since
    the edge (1, 3) has capacity 10 and we are using 5, it has only 5 units of capacity
    remaining. Despite building a shiny new edge of capacity 7, we can send only 5
    more units of flow through our network.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要确保通过节点1的新路径能够处理这额外的流量。我们已经有5个单位的流量从节点0到节点1。由于边(1, 3)的容量是10，而我们已经使用了5个，所以它仅剩下5个单位的容量。尽管建立了一条容量为7的新边，但我们只能通过网络传送额外的5个单位流量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">应用场景</samp>
- en: The maximum-flow problem naturally mirrors a range of real-world phenomena,
    including the flow of liquid through pipes, people through a transportation network,
    or information through a social network.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最大流问题自然反映了一系列现实世界的现象，包括液体通过管道的流动、人们通过交通网络的流动，或者信息通过社交网络的流动。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Physical Pipelines</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">物理管道</samp>
- en: Much of the terminology of the maximum-flow problem stems from the physical
    phenomenon of substances flowing through pipes. The terms *source*, *sink*, *capacity*,
    and even *flow* mirror their physical counterparts. We can easily map these types
    of physical problems to their computational equivalent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最大流问题中的许多术语源于物质通过管道流动的物理现象。术语*源*、*汇*、*容量*，甚至*流量*都与它们的物理对应物相对应。我们可以轻松地将这些物理问题映射到它们的计算等效问题。
- en: While this chapter’s primary running example is the flow of water through a
    wastewater system, the pipeline analogy goes well beyond sewage or interior plumbing,
    allowing us to ask additional questions. Perhaps we are interested in the flow
    of maple syrup through a processing plant. Given a complex series of pipes and
    nodes, what is the capacity of the overall system? How much liquid can we send
    through it before risking catastrophic maple syrup processing failure? These initial
    questions provide the foundation for further analysis and optimization, including
    answering such follow-up questions as “Where are the bottlenecks in the current
    system?” or “Where should we expand capacity by adding another pipe?”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的主要示例是废水系统中的水流，管道类比的应用远超污水或室内管道，我们可以提出更多的问题。也许我们对枫糖浆在加工厂中的流动感兴趣。给定一系列复杂的管道和节点，整个系统的容量是多少？在不导致枫糖浆加工失败的情况下，我们可以通过它输送多少液体？这些初步问题为进一步的分析和优化奠定了基础，包括回答“当前系统中的瓶颈在哪里？”或“我们应该通过增加另一根管道来扩展容量吗？”等后续问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transportation Networks</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">交通网络</samp>
- en: Transportation networks are also fertile ground for maximum-flow analysis. Imagine
    that your favorite sporting team has a championship game in a faraway city. Many
    thousands of local fans want to fly there and attend what can only be called the
    most important game of the century. The airline can model this demand as a maximum-flow
    problem to determine how many fans can currently travel between the two cities.
    Edges are routes between pairs of cities with limited numbers of airline seats
    that constitute their capacity. The flow through an edge is the number of occupied
    seats. The local city is the source node from which fans are traveling for this
    occasion, while the host city is the sink node.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 交通网络也是进行最大流分析的肥沃土壤。想象一下，你最喜欢的体育队在远方城市举行冠军赛。成千上万的本地粉丝想飞到那里，参加这场无疑是本世纪最重要的比赛。航空公司可以将这种需求建模为最大流问题，以确定目前有多少粉丝能够在两座城市之间旅行。边是城市对之间的航线，每条航线有一定数量的座位，构成了其容量。流量是已经占用的座位数。本地城市是源节点，粉丝们从这里出发前往目的地，而东道城市是汇点节点。
- en: The airline can use this analysis to determine if they should add another flight.
    If the number of interested fans far exceeds the capacity of their flight schedule,
    there is more money to be made.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 航空公司可以通过此分析判断是否需要增加航班。如果有大量的粉丝需求远超现有航班的容量，那么就有更多的利润空间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Communication Networks</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">通信网络</samp>
- en: We can also use the maximum-flow problem to model information passing through
    a communication or social network. For example, imagine you want to influence
    another person’s decision by strategically passing information through your social
    network. Perhaps you are trying to convince the hiring manager at your favorite
    company that you would be an ideal successor to the previous CEO. In hopes of
    swaying their decision, you start to share stories of your amazing achievements,
    making you the source node and the hiring manager the sink node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用最大流问题来建模信息通过通信或社交网络的传递。例如，假设你想通过战略性地在社交网络中传递信息来影响另一个人的决定。也许你正在试图说服你最喜欢公司的招聘经理，你将是前任首席执行官的理想继任者。为了影响他们的决定，你开始分享自己令人惊叹的成就故事，使你成为源节点，而招聘经理则是汇点节点。
- en: Unfortunately, the members of your network have limited time and interest in
    passing such messages. This capacity varies between any two nodes. Maybe two friends
    meet for coffee each morning and one can pass volumes of information to the other.
    However, a strained relationship might have limited information transfer capacity.
    Modeling this situation as a maximum-flow problem can help you determine how much
    information you can realistically get to the sink node.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，网络中的成员在传递此类消息时有时间和兴趣的限制。这个容量在任意两个节点之间是不同的。也许两个朋友每天早上都一起喝咖啡，其中一个可以将大量的信息传递给另一个。然而，紧张的关系可能导致信息传递能力受限。将这种情况建模为最大流问题有助于你确定实际能够传递到汇点节点的信息量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Extending the Data Structures</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">扩展数据结构</samp>
- en: Before introducing our first algorithm, we need to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structures
    to fully model capacities and flows. While the edge weights of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    data structure cannot model both the capacity limit and how much is used, the
    max-flow problem requires graphs that capture both a *fixed total capacity* and
    a *dynamic flow amount*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍第一个算法之前，我们需要扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 数据结构，以便完整地表示容量和流量。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 数据结构中的边权无法同时表示容量限制和已使用的数量，而最大流问题需要能够捕捉到既有
    *固定总容量* 又有 *动态流量* 的图。
- en: In this section, we define two new data structures. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    class is based on our <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    class with additional support for representing the amount of capacity that is
    in use. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class is similarly based on the formulation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class, but with additional functionality to track dynamically changing flows through
    the graph.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们定义了两个新的数据结构。<samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    类基于我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> 类，并增加了支持表示已使用容量的功能。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> 类与 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    类的结构类似，但增加了跟踪图中动态变化流量的功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges with Capacity</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">带容量的边</samp>
- en: 'To model the max-flow problem, the graph’s edges need to be able to store two
    pieces of information: a fixed total capacity and a dynamic flow amount. We define
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> class that
    stores the following information:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建模最大流问题，图的边需要能够存储两个信息：固定的总容量和动态的流量。我们定义了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    类，用于存储以下信息：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s origin
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储边的起始节点索引
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s destination
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **存储边的目标节点索引
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">capacity</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the edge’s total capacity
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">capacity</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **存储边的总容量
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">used</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the amount of the edge’s capacity that is being used
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">used</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **存储边的已使用容量
- en: We replace the single weight value in an edge with the combination of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>.
    [Figure 14-3](#fig14-3) shows a visualization of these attributes in the context
    of flow, where <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp> is
    the width of the pipe and <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>
    is the amount occupied.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将边中的单一权重值替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> 的组合。 [图 14-3](#fig14-3)
    显示了在流量上下文中这些属性的可视化，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp>
    是管道的宽度，<samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> 是已占用的量。
- en: '![An edge represented as a pipe with its width equal to the total capacity
    and the used amount shaded.](../images/f14003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![一条边被表示为一根管道，宽度等于总容量，已使用的部分被阴影标示。](../images/f14003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The attributes
    of a</samp> <samp class="SANS_TheSansMonoCd_W7Italic">CapacityEdge</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">object</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-3：一个</samp> <samp class="SANS_TheSansMonoCd_W7Italic">CapacityEdge</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">对象的属性</samp>
- en: 'Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structures
    we defined in [Chapter 1](chapter1.xhtml) and have used throughout the book, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> objects provide both
    storage and functions to operate on that storage, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在[第1章](chapter1.xhtml)中定义并在全书中使用的<sup class="SANS_TheSansMonoCd_W5Regular_11">Edge</sup>数据结构不同，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>对象既提供存储功能，又提供操作这些存储的函数，如下所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The constructor initializes the object’s variables, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to indicate that the
    edges start without any flow ❶. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">adjust_used()</samp>
    function allows algorithms to modify the flow through the edge. It takes an adjustment
    amount and adds it to the amount being used. We can visualize the function as
    a faucet knob. If we turn it one way, by passing in a positive amount, the flow
    increases. If we turn it the other way, by passing in a negative amount, the flow
    decreases. Unlike a faucet, however, the function does not automatically “stop
    turning” when it has reached its limit. The code includes an additional check
    to ensure the used capacity falls within the limits specified by the edge ❷. Specifically,
    the flow through an edge can never be less than 0 nor more than the edge’s total
    capacity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化对象的变量，将<samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，表示边的初始流量为零❶。接下来，<samp class="SANS_TheSansMonoCd_W5Regular_11">adjust_used()</samp>函数允许算法修改流经该边的流量。它接受一个调整值，并将其添加到当前使用的流量中。我们可以将该函数形象化为水龙头的旋钮。如果我们将其旋转一侧，传入正值，流量增加；如果将其旋转到另一侧，传入负值，流量减少。然而，与水龙头不同的是，当流量达到上限时，函数不会自动“停止旋转”。代码中包含额外的检查，以确保使用的容量在边的规定限制范围内❷。具体而言，流经一条边的流量不能小于0，也不能大于该边的总容量。
- en: Pushing the faucet analogy further, we may wish for indicators on how much we
    can turn the faucet in each direction. We provide the function <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity_left()</samp>
    to indicate the unused capacity remaining on the edge (also called the *forward
    residual)*. This is the amount of additional flow we can add to an edge. Similarly,
    we provide the function <samp class="SANS_TheSansMonoCd_W5Regular_11">flow_used()</samp>
    for indicating the current capacity used (also called the *backward residual)*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步推展水龙头的类比，我们可能希望能够指示每个方向上可以旋转水龙头的程度。我们提供了函数<samp class="SANS_TheSansMonoCd_W5Regular_11">capacity_left()</samp>，以指示边上剩余的未使用容量（也称为*前向残余*）。这是我们可以在边上增加的额外流量。类似地，我们提供了函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">flow_used()</samp>，用于指示当前已使用的容量（也称为*反向残余*）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Residual Graphs</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">残余图</samp>
- en: Just as we needed to add functionality to track how much capacity is used within
    an edge, we must augment our graph representation to support storage of and computation
    on these dynamic edges. We also add auxiliary tracking information specific to
    the max-flow problem, namely the indices of the source and sink nodes. We call
    this augmented graph a *residual graph* because it tracks the residual (or remaining)
    capacity between pairs of nodes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们需要添加功能来追踪边中已使用的容量一样，我们还必须增强图的表示，以支持这些动态边的存储和计算。我们还添加了与最大流问题相关的辅助跟踪信息，即源节点和汇节点的索引。我们将这种增强的图称为*残余图*，因为它跟踪节点对之间的剩余（或剩余）容量。
- en: 'We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class that uses a more minimal adjacency list representation and contains the
    following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>类，它使用更简化的邻接表表示，并包含以下内容：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **（**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**）** 存储图中节点的总数。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">source_index</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores the index of the
    source node.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">source_index</samp> **（**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**）** 存储源节点的索引。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sink_index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the index of the sink node.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sink_index</samp> **（**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**）** **存储汇点节点的索引。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    a dictionary for each node containing the adjacent edge objects out of that node
    keyed by their destination node. To access the <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    from node <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> to node <samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[j][k]</samp>.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> **（**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**）** **存储一个字典，该字典包含每个节点的相邻边对象，按目标节点键控。要访问从节点<samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>到节点<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">edges[j][k]</samp>。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">all_neighbors</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores a set of all in-neighbor
    and out-neighbor indices for each node.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">all_neighbors</samp> **（**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**）** **存储每个节点的所有入邻居和出邻居索引的集合。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> representation
    differs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class
    in that we are no longer storing <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    objects. Instead, the same adjacency list information, including the use of a
    dictionary, is incorporated into the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    list. While this presents a more compact representation that is sufficient for
    max-flow algorithms, we lose the ability to easily store auxiliary data within
    the nodes that we used for other algorithms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>表示与<class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类的不同之处在于，我们不再存储<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>对象。相反，相同的邻接表信息，包括字典的使用，被合并到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>列表中。虽然这种方式呈现了一个更紧凑的表示方式，足以支持最大流算法，但我们失去了在节点中轻松存储辅助数据的能力，这在其他算法中曾被使用。
- en: Although we are working with directed graphs, the algorithms we introduce will
    need to scan over all neighboring nodes, including in-neighbors that are not included
    in a traditional adjacency list. To facilitate these computations, we store the
    additional list <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>.
    Restricting the connection between any two nodes to a single directed <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    (not allowing anti-parallel edges) makes reasoning about forward and backward
    flows easier. As we will see, this restriction does not diminish the representational
    power of the graph because we can transform a graph with anti-parallel edges into
    one without them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在处理有向图，我们介绍的算法仍需要扫描所有邻居节点，包括不包含在传统邻接表中的入邻居。为了方便这些计算，我们存储了额外的列表<samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>。将任意两个节点之间的连接限制为单一的有向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>（不允许反向平行边）使得前向和后向流的推理变得更加容易。如我们所见，这种限制并不减少图的表示能力，因为我们可以将一个带有反向平行边的图转化为一个没有这些边的图。
- en: 'To demonstrate how the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp> lists capture
    the structure of the graph, consider the example <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    shown in [Figure 14-4](#fig14-4), along with its two list data structures. The
    four-node graph is shown on the left, the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    list in the middle, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>
    list on the right. Node 1 has two outgoing edges (nodes 2 and 3) and thus two
    entries in its adjacency dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp>.
    Each entry in the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp>
    maps the neighbor’s index to the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    out of node 1\. Since node 1 also has an incoming edge from node 0, the set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors[1]</samp> contains three
    indices: 0, 2, and 3.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>
    列表如何捕获图的结构，考虑图 14-4 所示的例子 <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    以及其两个列表数据结构。左侧显示的是四节点图，中央是对应的 <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    列表，右侧是 <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp> 列表。节点
    1 有两条出边（节点 2 和节点 3），因此在其邻接字典 <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp>
    中有两个条目。字典 <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp> 中的每个条目将邻居的索引映射到对应的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>，即从节点 1 出发的边。由于节点
    1 还从节点 0 获得一条入边，因此集合 <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors[1]</samp>
    包含三个索引：0、2 和 3。
- en: '![A four-node graph, the edges array mapping each node to a dictionary of destinations,
    and the all_neighbors array mapping each node to a set of its neighbors.](../images/f14004.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![一个四节点图，edges 数组将每个节点映射到一个目标字典，all_neighbors 数组将每个节点映射到它的邻居集合。](../images/f14004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: A residual graph
    and its internal list data structures</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-4：一个残余图及其内部列表数据结构</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class
    provides functions for creating and operating on this type of graph:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> 类提供了用于创建和操作这种类型图的函数：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The constructor creates an empty graph by creating empty adjacency dictionaries
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>) and neighbor sets
    for all nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>).
    Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function
    mirrors the version from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class and allows us to access each edge. Much of the code for this function consists
    of bounds checking: the function raises an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    is not in the graph. If the edge is not in the graph, the function returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. If the nodes are valid and
    the edge is in the graph, the code returns the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>.
    The code relies on importing <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to
    support the type hints for multiple return types.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数通过为所有节点创建空的邻接字典（<samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>）和邻居集合（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>）来创建一个空图。接下来，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> 函数是从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    类中镜像出来的，允许我们访问每条边。这个函数的大部分代码用于边界检查：如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> 不在图中，函数会抛出 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>。如果边不在图中，函数返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。如果节点有效且边存在于图中，代码会返回对应的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>。这段代码依赖于从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> 库导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    来支持多种返回类型的类型提示。
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    is both using different structures to store the edges with capacities and adding
    more neighbor information to track incoming edges, the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    function needs to track this information accordingly. The code starts with the
    same index validity checking we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class ❶ and adds checks to ensure the structural constraints we put on the graphs
    in the max-flow problem ❷. These include checking that (1) there are no edges
    out of the sink, (2) there are no edges into the source, (3) the newly inserted
    edge is not the reverse of an existing edge, and (4) the capacity is greater than
    zero.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> 使用不同的结构来存储具有容量的边并添加更多的邻居信息来跟踪传入边，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> 函数需要相应地跟踪这些信息。代码首先进行与我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类中使用的相同的索引有效性检查 ❶，并添加检查以确保我们在最大流问题中对图的结构约束
    ❷。这些检查包括： (1) 确保汇节点没有出边，(2) 确保源节点没有入边，(3) 确保新插入的边不是现有边的反向，(4) 确保容量大于零。
- en: If all the checks pass, the code creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    and adds it to the dictionary in the corresponding entry of the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    list ❸. If an edge has already been inserted between these two nodes in the same
    direction, the code overwrites it. Finally, the code adds <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>’s list of all
    neighbors and adds <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>’s list of all
    neighbors ❹.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有检查都通过，代码会创建一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    并将其添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> 列表的相应条目中 ❸。如果在同一方向上这两个节点之间已经插入了边，代码会覆盖它。最后，代码将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> 添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    的所有邻居列表中，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> 添加到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> 的所有邻居列表中 ❹。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">compute_total_flow()</samp>
    function demonstrates how to use the values within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    to reason about its properties, computing the total flow from source to sink by
    summing up the flow along each edge leaving the source. Since all flow originates
    from a single source node, this is the total flow through the graph.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">compute_total_flow()</samp> 函数演示了如何使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> 中的值来推理其属性，通过对每条从源节点离开的边的流量求和来计算从源到汇的总流量。由于所有流量都来自单一源节点，因此这就是图中的总流量。
- en: The remaining functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class are closely tied to the operation of the Ford-Fulkerson algorithm; we’ll
    present them in context as we introduce the algorithm.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> 类中的其余函数与
    Ford-Fulkerson 算法的操作密切相关；我们将在介绍算法时结合上下文展示它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Ford-Fulkerson Algorithm</samp>
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Ford-Fulkerson 算法</samp>
- en: Mathematicians L.R. Ford Jr. and D.R. Fulkerson developed a general approach
    for finding the maximum flow through a graph by repeatedly finding underutilized
    paths from the source to the sink and increasing the flow along those paths. This
    approach relies upon the idea of an *augmenting* *path*, a route from the source
    node to the sink node along which the flow can be increased. Ford-Fulkerson is
    technically a general approach that encompasses a range of specific algorithms
    because the original paper does not specify which search algorithm to use to find
    the augmenting path. This section introduces an example implementation using depth-first
    search.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家 L.R. Ford Jr. 和 D.R. Fulkerson 开发了一种通用方法，通过反复找到源到汇之间的未充分利用的路径，并增加这些路径上的流量，从而找到图中的最大流。这种方法依赖于
    *增广* *路径* 的概念，即从源节点到汇节点的路径，沿着该路径可以增加流量。Ford-Fulkerson 技术上是一个通用方法，涵盖了一系列特定的算法，因为原始论文没有指定用哪种搜索算法来查找增广路径。本节介绍了一个使用深度优先搜索的示例实现。
- en: The general Ford-Fulkerson approach may fail to terminate in pathological cases
    where irrational numbers are used for the capacities. These cases can be avoided
    by limiting the precision of the capacities or, as we will see later in this chapter,
    by selecting augmenting paths with the fewest edges.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的Ford-Fulkerson方法可能会在容量使用无理数的病态情况下无法终止。这些情况可以通过限制容量的精度来避免，或者正如本章稍后所示，通过选择具有最少边的增广路径来避免。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Augmenting
    Paths</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义增广路径</samp>
- en: The simplest form of an augmenting path is a series of directed edges from source
    to sink whose current flow is less than the edges’ capacities. In this case, as
    illustrated in [Figure 14-5(a)](#fig14-5), we can just add flow along the path
    [0, 2, 3] to increase the total flow by 2 units. [Figure 14-5(b)](#fig14-5) shows
    the resulting total of 7 units of flow leaving the source and entering the sink.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 增广路径的最简单形式是从源点到汇点的一系列有向边，这些边的当前流量小于其容量。在这种情况下，如[图14-5(a)](#fig14-5)所示，我们可以沿路径[0,
    2, 3]添加流量，将总流量增加2个单位。[图14-5(b)](#fig14-5)展示了结果，总流量从源点离开并进入汇点，达到了7个单位。
- en: '![(A) shows a graph with four nodes and five edges. Each edge is labeled with
    its capacity and how much is used. Edge (0, 1) uses 5 of 5, edge (0, 2) uses 0
    of 10, edge (1, 2) is using 1 of 1, edge (1, 3) is using 4 of 10, and edge (2,
    3) is using 1 of 3\. (B) shows the same graph with the edges (0, 2) and (2, 3)
    bolded. The capacity used in each edge has been increased by 2\. Edge (0, 1) uses
    5 of 5, edge (0, 2) uses 2 of 10, edge (1, 2) is using 1 of 1, edge (1, 3) is
    using 4 of 10, and edge (2, 3) is using 3 of 3.](../images/f14005.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个包含四个节点和五条边的图。每条边标有其容量以及已使用的流量。边(0, 1)使用了5/5，边(0, 2)使用了0/10，边(1,
    2)使用了1/1，边(1, 3)使用了4/10，边(2, 3)使用了1/3。(B) 显示了相同的图，其中边(0, 2)和(2, 3)已加粗。每条边的已用容量增加了2。边(0,
    1)使用了5/5，边(0, 2)使用了2/10，边(1, 2)使用了1/1，边(1, 3)使用了4/10，边(2, 3)使用了3/3。](../images/f14005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: A capacity graph
    before (a) and after (b) adding flow</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-5：添加流量前后的容量图（a）和（b）</samp>
- en: Adding forward flow gets us only part of the way, however. [Figure 14-6](#fig14-6)
    shows a situation where there is no path from source to sink that has unused capacity.
    This graph is not at maximum flow, since the flow from node 1 to node 2 is siphoning
    off potential flow from node 1 to node 3\. Simultaneously, this flow is contributing
    to the edge from node 2 to node 3 being fully utilized and thus unable to accept
    any more flow from edge (0, 2).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅增加前向流量只能部分解决问题。[图14-6](#fig14-6)展示了这样一种情况：从源点到汇点没有未使用容量的路径。该图并未达到最大流量，因为从节点1到节点2的流量正在从节点1到节点3的潜在流量中抽取流量。同时，这种流量导致了从节点2到节点3的边被完全利用，从而无法接受来自边(0,
    2)的更多流量。
- en: '![a graph with four nodes and five edges. Each edge is labeled with its capacity
    and how much is used. Edge (0, 1) uses 5 of 5, edge (0, 2) uses 2 of 10, edge
    (1, 2) is using 1 of 1, edge (1, 3) is using 4 of 10, and edge (2, 3) is using
    3 of 3.](../images/f14006.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个节点和五条边的图。每条边标有其容量以及已使用的流量。边(0, 1)使用了5/5，边(0, 2)使用了2/10，边(1, 2)使用了1/1，边(1,
    3)使用了4/10，边(2, 3)使用了3/3。](../images/f14006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: A graph with no
    underutilized forward paths</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-6：没有低利用率前向路径的图</samp>
- en: We can increase the flow of the graph using the two steps shown in [Figure 14-7](#fig14-7).
    The 5 units of flow entering node 1 are initially partitioned into two streams,
    with 1 unit of flow going to node 2 and 4 units going to node 3\. We change this
    allocation to divert 1 additional unit of flow to node 3 as shown in [Figure 14-7(a)](#fig14-7).
    The total flow through the graph remains constant, but the flow through edge (2,
    3) now drops below capacity. Second, we increase the flow from node 0 through
    node 2 to node 3 as shown in [Figure 14-7(b)](#fig14-7), increasing the overall
    flow through the graph to 8 units.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[图14-7](#fig14-7)中展示的两个步骤来增加图的流量。进入节点1的5个单位流量最初被分成两个流，1个单位流量流向节点2，4个单位流量流向节点3。我们将这种分配更改为将1个额外的单位流量引导到节点3，如[图14-7(a)](#fig14-7)所示。图中的总流量保持不变，但边(2,
    3)上的流量现在降到容量以下。其次，我们增加了从节点0通过节点2到节点3的流量，如[图14-7(b)](#fig14-7)所示，将图的整体流量增加到8个单位。
- en: '![(A) shows the graph from Fig. 14-6 with the edges (1, 2), (1, 3), and (2,
    3) bolded. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is using 2 of 10
    capacity, edge (1, 2) is using 0 of 1 capacity, edge (1, 3) is using 5 of 10 capacity,
    and edge (2, 3) is using 2 of 3 capacity. (B) shows the same graph with edges
    (0, 2) and (2, 3) bolded. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is
    using 3 of 10 capacity, edge (1, 2) is using 0 of 1 capacity, edge (1, 3) is using
    5 of 10 capacity, and edge (2, 3) is using 3 of 3 capacity.](../images/f14007.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![（A）展示了图14-6中的图形，边（1, 2）、（1, 3）和（2, 3）加粗显示。边（0, 1）使用了5个单位的5容量，边（0, 2）使用了2个单位的10容量，边（1,
    2）使用了0个单位的1容量，边（1, 3）使用了5个单位的10容量，边（2, 3）使用了2个单位的3容量。（B）展示了加粗了边（0, 2）和（2, 3）的相同图形。边（0,
    1）使用了5个单位的5容量，边（0, 2）使用了3个单位的10容量，边（1, 2）使用了0个单位的1容量，边（1, 3）使用了5个单位的10容量，边（2,
    3）使用了3个单位的3容量。](../images/f14007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: Two steps for
    adding flow to the graph in [Figure 14-6](#fig14-6)</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-7：在[图14-6](#fig14-6)中添加流量的两步</samp>
- en: To reroute flow through the network, the algorithm also needs the ability to
    reduce flow through an edge by diverting it along another edge. We therefore define
    the *residual* along a directed edge (*u*, *v*) as follows. The forward residual
    is the unused capacity *capacity*(*u*, *v*) − *flow*(*u*, *v*) in the direction
    from node *u* to node *v*. This aligns how we normally think of additional capacity.
    The backward residual is the used capacity *flow*(*v*, *u*) in the direction opposite
    the edge—that is, from node *v* to node *u*. This corresponds to capacity that
    can be removed from the input of node *u*, allowing us to accept input from somewhere
    else.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新路由流量，算法还需要能够通过将流量转移到另一条边上来减少沿某条边的流量。因此，我们将沿有向边（*u*，*v*）的*残余*定义如下。向前残余是从节点*u*到节点*v*的未使用容量，即*capacity*（*u*，*v*）−*flow*（*u*，*v*）。这与我们通常所理解的额外容量一致。向后残余是沿着与边方向相反的方向，即从节点*v*到节点*u*的已使用容量*flow*（*v*，*u*）。这对应于可以从节点*u*的输入中移除的容量，允许我们接受来自其他地方的输入。
- en: We can push more flow through an underutilized directed edge or push flow back
    in the opposite direction of a directed edge. [Figure 14-8](#fig14-8) shows an
    example case of combining forward and backward residuals.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过低利用率的有向边传递更多流量，或者将流量推回有向边的相反方向。[图14-8](#fig14-8)展示了结合向前和向后残余的示例情况。
- en: '![the graph from Fig. 14-6 with the edges (0, 2), (1, 2), and (1, 3) bolded.
    Edge (0, 1) uses 5 of 5 capacity, edge (0, 2) uses 2 of 10 capacity, edge (1,
    2) is using 1 of 1 capacity, edge (1, 3) is using 4 of 10 capacity, and edge (2,
    3) is using 3 of 3 capacity](../images/f14008.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图14-6中的图形，边（0, 2）、（1, 2）和（1, 3）加粗显示。边（0, 1）使用了5个单位的5容量，边（0, 2）使用了2个单位的10容量，边（1,
    2）使用了1个单位的1容量，边（1, 3）使用了4个单位的10容量，边（2, 3）使用了3个单位的3容量](../images/f14008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: An augmenting
    path that includes reducing flow along an edge</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-8：包含沿边减少流量的增广路径</samp>
- en: 'The bolded edges indicate an undirected path from source to sink where we can
    modify the flows as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 加粗的边表示从源到汇的无向路径，我们可以按如下方式修改流量：
- en: Edge (0, 2) has a forward residual of 8, so we can add more units of flow down
    that edge to node 2.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边（0, 2）有一个向前残余值为8，因此我们可以通过该边向节点2添加更多单位的流量。
- en: Edge (1, 2) has a backward residual of 1, so we can turn down that flow by 1
    unit to allow node 2 to take more flow from another source (in this case, node
    0). Since node 2’s outgoing flow is capped at 3 units and we need to keep the
    flow out equal to the flow in, we need to reduce the incoming flow from node 1
    into node 2 in order to increase the flow from node 0 into node 2.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边（1, 2）有一个向后残余值为1，因此我们可以将该流量减少1个单位，以便允许节点2从另一个源（在本例中是节点0）接收更多流量。由于节点2的输出流量上限为3个单位，并且我们需要保持流入和流出相等，我们需要减少从节点1流入节点2的流量，以便增加从节点0流入节点2的流量。
- en: Edge (1, 3) has a forward residual of 6, so it can take extra output of node
    1 that is no longer traveling to node 2\. Again, we need to keep the flow into
    node 1 balanced with the flow out of node 1.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边（1, 3）有一个向前残余值为6，因此它可以接收节点1不再流向节点2的额外输出。同样，我们需要保持节点1的流入流量与流出流量平衡。
- en: The key to understanding the Ford-Fulkerson algorithm is that pushing flow through
    a backward edge is just reducing the flow leaving the origin node so that it can
    travel to a new destination. As we will see in the next section, our need to push
    flow in either direction means it no longer suffices to explore the edges out
    of each node’s (directed) adjacency list. We need to consider edges into and out
    of the node.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理解福特-福尔克森算法的关键在于，推动流量通过反向边实际上是减少从源节点流出的流量，使其能够流向新的目的地。正如我们将在下一节中看到的那样，我们需要在任一方向推动流量，这意味着仅仅探索每个节点（有向）邻接表中的边已经不再足够。我们需要考虑进出节点的边。
- en: We can visualize this algorithm in the context of a sewage engineer managing
    the wastewater system described previously. The engineer maximizes the total flow
    of wastewater by routing the flow through the optimal sets of pipes. The main
    constraint is the capacity of the pipes (edges) and the junction boxes (nodes).
    The last engineer, trying to show off, ignored the total capacity and pushed more
    flow than was viable. The overloaded pipe promptly burst, resulting in a geyser
    of wastewater that was discussed in the newspapers for weeks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个算法可视化为一个污水工程师管理之前描述的污水系统。该工程师通过将流量引导到最佳管道集来最大化总的污水流量。主要约束是管道（边）和接头箱（节点）的容量。最后一位工程师为了炫耀，忽略了总容量，推动了超过实际可行的流量。超负荷的管道迅速爆裂，导致了一个污水喷泉，这个事件在报纸上讨论了好几周。
- en: The new engineer tackles this problem by continuously finding a path from source
    to sink that can take more wastewater and sending as much wastewater through that
    path as possible (but no more). Sometimes this means pushing back against an existing
    flow, which is fine as long as that flow can be pushed through another junction
    (node) to the sink. Any wastewater flowing into a junction must also flow out.
    Otherwise, it risks bursting the junction box. The engineer keeps increasing the
    flow again and again until all the paths are fully saturated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 新的工程师通过不断寻找从源点到汇点的路径，来解决这个问题，直到该路径无法再承载更多污水，并且将尽可能多的污水通过该路径传输（但不超过）。有时这意味着要反向推动已有的流量，这没问题，只要这些流量能够通过另一个接头（节点）流向汇点。任何流入接头的污水也必须流出。否则，它有可能导致接头箱爆裂。工程师不断增加流量，直到所有路径都完全饱和。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding an Augmenting
    Path</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">寻找增广路径</samp>
- en: 'Before we can define a search algorithm, we need to formalize the computation
    of the residual along a path. Remember from the previous description that an augmenting
    path can contain a combination of forward residuals and backward residuals. We
    define a helper method within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class to simplify the logic of computing the residual (either forward or backward)
    between any two nodes on the path:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义搜索算法之前，我们需要形式化路径上剩余流量的计算。从前面的描述中我们可以记得，增广路径可以包含正向剩余流量和反向剩余流量的组合。我们在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> 类中定义了一个辅助方法，以简化计算路径上任意两节点之间剩余流量（无论是正向还是反向）的逻辑：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> function
    first checks whether the two nodes are connected at all ❶. If not, the edge is
    neither a forward nor a backward edge and has zero residual. If the edge (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>)
    is in the adjacency list of directed edges, then it is a forward edge ❷, and the
    function returns the capacity remaining (forward residual). Otherwise, the edge
    must exist in the opposite direction, so the code returns the flow used (backward
    residual).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> 函数首先检查两个节点是否连接
    ❶。如果没有连接，那么该边既不是正向边也不是反向边，剩余流量为零。如果边（<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>）在有向边的邻接表中，那么它是正向边 ❷，函数返回剩余容量（正向剩余流量）。否则，该边必定存在于相反方向，因此代码返回已使用的流量（反向剩余流量）。
- en: 'In this section, we use a modified depth-first search to check the graph for
    an augmenting path:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用修改后的深度优先搜索来检查图中是否存在增广路径：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code consists of a pair of functions. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting
    _path_dfs()</samp> function sets up the lists <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> for a depth-first
    search, as described in [Chapter 4](chapter4.xhtml). It then calls the recursive
    depth-first search function and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list that represents the augmenting path.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码由一对函数组成。首先，<samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_dfs()</samp>
    函数设置了用于深度优先搜索的列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>，如[第4章](chapter4.xhtml)中所描述。接着，它调用递归的深度优先搜索函数，并返回表示增广路径的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 列表。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">augmenting_path_dfs_recursive()</samp>
    function performs the recursive depth-first exploration. As with a standard depth-first
    search, it marks the current node as seen, then loops through the node’s neighbors.
    The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    over the residual graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>
    list to explore along both directions of the directed edges. When exploring the
    neighbors of the current node, the code checks both that the node has not been
    seen (as in standard depth-first search) and that the residual is nonzero ❶. This
    latter condition prevents the search from using edges that are already saturated.
    If the edge is viable and the node has not been seen, the search updates the tracking
    information and recursively explores that node.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">augmenting_path_dfs_recursive()</samp>
    函数执行递归的深度优先探索。与标准的深度优先搜索相同，它将当前节点标记为已访问，然后遍历该节点的邻居。代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历残余图的 <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp> 列表，沿着有向边的两个方向进行探索。在探索当前节点的邻居时，代码会检查该节点是否未被访问（如同标准的深度优先搜索）以及残余是否非零
    ❶。这个条件防止了搜索使用已经饱和的边。如果边是可行的并且该节点未被访问，搜索将更新跟踪信息，并递归地探索该节点。
- en: The code incorporates an optional early termination check ❷. It stops exploring
    new neighbors as soon as any path has been found from the source to the sink.
    By checking whether <samp class="SANS_TheSansMonoCd_W5Regular_11">last[g.sink_index]</samp>
    has been assigned, the code can skip the recursive exploration at both the node
    before the sink and earlier nodes along the path.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含一个可选的提前终止检查 ❷。它会在从源节点到汇节点找到路径时停止探索新的邻居。通过检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">last[g.sink_index]</samp>
    是否已被赋值，代码可以跳过在汇节点之前和路径上较早节点的递归探索。
- en: '[Figure 14-9](#fig14-9) shows the iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_dfs()</samp>
    on the graph from [Figure 14-6](#fig14-6). Each edge is labeled with the *X* of
    *Y*, where *X* is the flow used and *Y* is the edge’s total capacity. The shaded
    nodes have been seen, and the node enclosed in the dashed circle is the one on
    which the recursive function has just been called.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-9](#fig14-9) 显示了在[图14-6](#fig14-6)中的图上，<samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_dfs()</samp>
    的迭代过程。每条边都标记为 *X* / *Y*，其中 *X* 是已使用的流量，*Y* 是该边的总容量。已访问的节点为阴影标记，虚线圈中的节点是刚刚调用递归函数的节点。'
- en: '![In (A), node 0 is circled and last reads [–1, –1, –1, –1]. In (B), node 2
    is circled and last reads [–1, –1, 0, –1]. In (C), node 1 is circled and last
    reads [–1, 2, 0, –1]. In (D), no nodes are circled and last reads [–1, 2, 0, 1].](../images/f14009.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![在(A)中，节点0被圈出，last的值为[–1, –1, –1, –1]。在(B)中，节点2被圈出，last的值为[–1, –1, 0, –1]。在(C)中，节点1被圈出，last的值为[–1,
    2, 0, –1]。在(D)中，没有节点被圈出，last的值为[–1, 2, 0, 1]。](../images/f14009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: The steps of the
    search to find an augmenting path</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-9：查找增广路径的搜索步骤</samp>
- en: '[Figure 14-9(a)](#fig14-9) shows the state of the algorithm before the source
    node is visited. [Figure 14-9(b)](#fig14-9) shows the second step of the search:
    after visiting node 0, the algorithm finds two neighbors, nodes 1 and 2\. Only
    edge (0, 2) has unused capacity, so the search continues down that branch.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-9(a)](#fig14-9) 显示了源节点未被访问前算法的状态。[图14-9(b)](#fig14-9) 显示了搜索的第二步：在访问节点0后，算法找到了两个邻居节点1和2。只有边(0,
    2)的容量未使用，因此搜索继续沿该分支进行。'
- en: Since the algorithm considers both outgoing and incoming edges, it finds two
    options at node 2\. Both edges (1, 2) and (2, 3) are at capacity in their respective
    directions. However, edge (1, 2) is incoming to node 2 and thus has a backward
    residual of 1\. This edge provides us an opportunity to decrease the flow into
    node 2\. As shown in [Figure 14-9(c)](#fig14-9), the search follows this edge
    to explore node 1.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该算法考虑了出边和入边，它在节点 2 找到两个选项。边 (1, 2) 和 (2, 3) 在各自的方向上已满载。然而，边 (1, 2) 是从节点 2
    进入的，因此它有一个反向剩余值为 1。这条边为我们提供了一个减少流入节点 2 的机会。如图 [14-9(c)](#fig14-9) 所示，搜索沿这条边继续，探索节点
    1。
- en: While exploring node 1, the algorithm finds a path to the sink node with unused
    capacity. The code never visits the sink node, but rather returns as soon as any
    path is found. In this case, as shown in [Figure 14-9(d)](#fig14-9), the algorithm
    returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[-1, 2, 0, 1]</samp>, indicating the augmenting
    path.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索节点 1 时，算法找到了一条通向汇点节点的未使用容量的路径。代码不会访问汇点节点，而是一旦找到任何路径便返回。在此情况下，如图 [14-9(d)](#fig14-9)
    所示，算法返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 数组 <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1,
    2, 0, 1]</samp>，表示增广路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating a Path’s
    Capacity</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更新路径的容量</samp>
- en: 'After finding an augmenting path, the Ford-Fulkerson algorithm must determine
    how much additional flow it can push through the path, then update the path’s
    capacities to indicate the increased flow. To enable this, we add two functions
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>
    function traverses a path using the last pointers and computes the minimum residual
    of any edge along the path:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到增广路径后，Ford-Fulkerson 算法必须确定可以通过路径推送多少额外的流量，然后更新路径的容量以表示增加的流量。为此，我们向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> 类添加了两个函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>
    函数通过最后指针遍历路径，并计算路径上任何边的最小剩余值：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code starts by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_val</samp>
    to infinity (requiring the file to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    math</samp>) as an indicator that there is no minimum yet. It then uses a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to walk the chain of
    pointers backward from the sink until it reaches the source ❶. At each step, it
    considers the node preceding the current one and checks that it is not <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>,
    which would indicate a broken path. The code updates the minimum value using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> on the current edge
    and moves on to the previous node ❷. After examining all the edges along the path,
    the code returns the smallest residual it encountered.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先将 <samp class="SANS_TheSansMonoCd_W5Regular_11">min_val</samp> 设置为无穷大（这要求文件包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">import math</samp>），作为尚未找到最小值的标志。然后，它使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环从汇点反向遍历指针链，直到到达源节点
    ❶。在每一步，它考虑当前节点前面的节点，并检查它是否不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，如果是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，则表示路径断开。代码通过在当前边上使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> 更新最小值，并继续前进到前一个节点
    ❷。在检查完路径上的所有边后，代码返回它遇到的最小剩余值。
- en: If we apply <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>
    to the result shown in [Figure 14-6](#fig14-6), with a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array of <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1, 2, 0, 1]</samp>, we
    traverse the path shown in [Figure 14-8](#fig14-8). The minimum residual along
    this path is 1 along edge (1, 2).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对图 [14-6](#fig14-6) 中显示的结果应用 <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>，并且
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 数组为 <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1,
    2, 0, 1]</samp>，我们就可以遍历图 [14-8](#fig14-8) 中显示的路径。该路径上的最小剩余值是沿边 (1, 2) 的 1。
- en: 'Once we have determined how much additional flow we can push through a path,
    we update the path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>
    function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了可以通过路径推送多少额外的流量，我们就使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>
    函数来更新路径：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>
    function, the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>
    walks the last pointers backward from the sink node to the source node using a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop ❶. Again, it checks
    that the previous node indicates a valid path. If so, it checks the direction
    of the edge along the path before updating the amount used ❷. Forward edges appear
    in the adjacency list, and the code adds the new flow to the amount of capacity
    used. Backward edges are ones where the algorithm is pushing flow back. The edge
    direction is the opposite way, so the edge itself is not in the adjacency list.
    The code subtracts the new flow from the amount already in use.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与<samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>函数类似，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>函数的代码通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环从汇点向源点回溯最后的指针 ❶。同样，它会检查前一个节点是否表示一个有效路径。如果有效，它会检查路径上边的方向，然后更新已用量
    ❷。前向边在邻接表中出现，代码将新流量添加到已用容量上。反向边则是算法将流量回推的地方。边的方向是相反的，因此该边本身不在邻接表中。代码从已经使用的量中减去新流量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将所有部分组合在一起</samp>
- en: The Ford-Fulkerson algorithm using depth-first search consists of putting together
    the pieces we have introduced throughout the chapter. As shown in [Listing 14-1](#list14-1),
    the algorithm repeatedly searches for an augmenting path. When it finds one, it
    computes the minimum residual along that path and increases the flow accordingly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用深度优先搜索的福特-富尔克森算法由我们在整个章节中介绍的各个部分组成。如[清单 14-1](#list14-1)所示，算法反复搜索增广路径。当找到增广路径时，它计算路径上的最小剩余，并相应地增加流量。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: The Ford-Fulkerson
    algorithm using depth-first search</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 14-1：使用深度优先搜索的福特-富尔克森算法</samp>
- en: The code starts by creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    where the capacities are equal to the weights of the original graph ❶. This effectively
    copies the graph while also transforming the representation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过创建一个<samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>开始，其中容量等于原始图的权重
    ❶。这有效地复制了图形，同时也转变了表示方式。
- en: The main loop of the algorithm is relatively small and begins by using a Boolean
    <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> to track whether it
    found an augmenting path on the last iteration ❷. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> and the code
    searches for a new augmenting path ❸. The code checks that the returned path is
    valid ❹ and, if so, computes the minimum residual along the path using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp> function
    and updates the flow along the path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">update
    _along_path()</samp> function. If the code finds a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    value of –1 for the sink node, it knows there is no path from the source to the
    sink and can set <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. The function finishes
    by returning the residual graph.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的主循环相对较小，开始时使用一个布尔值<samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp>来跟踪上一次迭代是否找到了增广路径
    ❷。如果找到了，<samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp>将被设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，代码将继续搜索新的增广路径
    ❸。代码检查返回的路径是否有效 ❹，如果有效，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>函数计算路径上的最小剩余，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>函数更新路径上的流量。如果代码在汇点处发现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>值为-1，说明从源点到汇点没有路径，可以将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">done</samp>设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。该函数最后返回剩余图。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 14-10](#fig14-10) shows the Ford-Fulkerson algorithm running on an
    example graph, where each subfigure represents the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    after one iteration of the algorithm. Bolded arrows indicate the augmenting path
    found during each iteration, and the used portions of the capacities have been
    updated to fully use that augmenting path, as shown by the *X* of *Y* notation
    along each edge.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-10](#fig14-10)展示了Ford-Fulkerson算法在一个示例图上运行的情况，其中每个子图表示算法进行一次迭代后的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</sup>状态。加粗的箭头表示在每次迭代中找到的增广路径，并且已更新容量的使用部分，完全使用该增广路径，如每条边上的*X*和*Y*符号所示。'
- en: '![Each subfigure shows the same graph with 7 nodes and 10 edges. The graph
    in (A) has no edges using capacity. (B) shows the same graph with edges (0, 1),
    (1, 3), and (3, 6) bolded. All the edges use 2 of their capacity.](../images/f14010.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示相同的图，包含7个节点和10条边。图 (A) 中没有使用容量的边。图 (B) 显示相同的图，其中边(0, 1)、(1, 3)和(3,
    6)被加粗，所有边的容量都使用了2。](../images/f14010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: The steps of
    the Ford-Fulkerson algorithm with depth-first search on a graph with seven nodes</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-10：带有深度优先搜索的Ford-Fulkerson算法步骤，应用于包含七个节点的图</samp>
- en: '[Figure 14-10](#fig14-10) demonstrates how using depth-first search impacts
    the order in which the Ford-Fulkerson algorithm retrieves augmenting paths. For
    example, although there is a capacity-3 path along the bottom of the example graph
    via edges (0, 2), (2, 5), and (5, 6), the algorithm first fills in some smaller
    flows, such as the capacity-1 path in [Figure 14-10(c)](#fig14-10).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-10](#fig14-10)展示了使用深度优先搜索如何影响Ford-Fulkerson算法获取增广路径的顺序。例如，尽管在示例图底部通过边(0,
    2)、(2, 5)和(5, 6)存在一条容量为3的路径，但算法首先填充了一些较小的流量，例如[图 14-10(c)](#fig14-10)中的容量为1的路径。'
- en: '[Figure 14-10(e)](#fig14-10) shows an augmenting path that uses both forward
    and backward residuals. To increase the flow through edge (4, 6) into the sink,
    the algorithm redirects flow out of node 1 from edge (1, 3) to edge (1, 4). This
    gives node 4 an input of 2 units that the algorithm can pass along to the sink.
    However, it leaves node 3 short by 1 unit. The search offsets this loss of input
    at node 3 with an additional flow from the source through edge (0, 3).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-10(e)](#fig14-10)展示了一条使用正向和反向剩余流的增广路径。为了增加通过边(4, 6)到达汇点的流量，算法将流量从节点1的边(1,
    3)重定向到边(1, 4)。这给节点4提供了2个单位的输入，算法可以将其传递到汇点。然而，这使得节点3少了1个单位的流量。搜索通过从源点通过边(0, 3)的额外流量来弥补节点3的输入损失。'
- en: Once the algorithm has computed the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>,
    we can use that data structure to answer other questions. For example, we can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">compute _total_flow()</samp>
    function to compute the graph’s maximum flow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦算法计算出<sup class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</sup>，我们可以使用该数据结构来回答其他问题。例如，我们可以使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">compute _total_flow()</sup>函数来计算图的最大流量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Edmonds-Karp Algorithm</samp>
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">埃德蒙兹-卡普算法</samp>
- en: The computer scientist Yefim Dinitz (under the name E.A. Dinic) and the pair
    of computer scientists Jack Edmonds and Richard M. Karp independently published
    analyses of the Ford-Fulkerson algorithm that selected augmenting paths with the
    fewest number of edges. This approach, now called either the *Dinitz algorithm*
    or the *Edmonds-Karp algorithm*, makes use of this path selection to avoid the
    problematic behavior when using irrational edge capacities and thus bounds the
    number of iterations of the algorithm in all cases. This section shows how we
    can use breadth-first search to find such augmenting paths.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家耶菲姆·迪尼茨（以E.A. Dinic为名）和计算机科学家杰克·埃德蒙兹与理查德·M·卡普分别发表了关于Ford-Fulkerson算法的分析，这些分析选择了边数最少的增广路径。这个方法现在被称为*迪尼茨算法*或*埃德蒙兹-卡普算法*，它通过这种路径选择避免了在使用非理性边容量时的种种问题，从而在所有情况下限制了算法的迭代次数。本节将展示如何利用广度优先搜索来找到这样的增广路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: The majority of the Edmonds-Karp algorithm uses the functions introduced earlier
    for the Ford-Fulkerson algorithm, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>.
    All we need to change is the function for finding the augmenting paths and the
    outer function that calls it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Edmonds-Karp算法使用之前介绍的Ford-Fulkerson算法中的函数，如<samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>。我们需要更改的只是寻找增广路径的函数和调用它的外部函数。
- en: 'We use a modified version of breadth-first search to find the augmenting paths:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用改进版的广度优先搜索来寻找增广路径：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>
    function starts by setting up the standard breadth-first search data structures,
    including the list of whether each node has been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>),
    the list of previous nodes on the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    and the queue of nodes to explore (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>).
    The use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp> data
    structure requires an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    queue</samp> at the top of the file. The function then inserts the source node
    as the starting point ❶. The main <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop continues until either the pending queue is empty or the sink node has been
    seen ❷. As in the depth-first search code, this second check allows the search
    to terminate as soon as it finds *any* path from the source to the sink.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>函数首先设置标准的广度优先搜索数据结构，包括每个节点是否已被访问的列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>），路径上前一个节点的列表（<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>），以及待探索节点的队列（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>）。使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp>数据结构需要在文件顶部额外添加<samp
    class="SANS_TheSansMonoCd_W5Regular_11">import queue</samp>。然后，函数将源节点插入为起点❶。主<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环会继续，直到待处理队列为空或汇点节点已被访问❷。与深度优先搜索代码一样，这第二个检查使得搜索一旦找到*任何*从源点到汇点的路径就终止。
- en: When exploring the neighbors of the current node, the code checks both that
    the node has not been seen (as in standard breadth-first search) and that the
    residual is nonzero ❸. If the edge is viable and the node has not been seen, the
    search updates the tracking information and adds it to the queue ❹.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索当前节点的邻居时，代码检查该节点是否未被访问（如同标准的广度优先搜索）以及残量是否非零❸。如果该边是可行的且节点未被访问，搜索会更新追踪信息并将其添加到队列中❹。
- en: '[Figure 14-11](#fig14-11) shows the iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>
    on a graph with some of its capacity used. The shaded nodes have been seen, and
    the node enclosed in the dashed circle is the one the search has just *finished*
    processing.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-11](#fig14-11)展示了<samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>在一个部分容量已被使用的图上的迭代过程。阴影部分的节点表示已被访问，虚线框中的节点是搜索刚刚*处理完成*的节点。'
- en: '[Figure 14-11(a)](#fig14-11) shows the state of the algorithm before the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop starts, while [Figure
    14-11(b)](#fig14-11) shows the first step of the search. After visiting node 0,
    we find edges with unused capacity to two unvisited neighbors (nodes 1 and 3).
    Both neighbors are added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>
    queue.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-11(a)](#fig14-11)展示了<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环开始前算法的状态，而[图14-11(b)](#fig14-11)展示了搜索的第一步。访问节点0后，我们发现了两条未访问邻居节点（节点1和3）之间具有未使用容量的边。两邻居被加入到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>队列中。'
- en: The algorithm diverges from a standard breadth-first search in [Figure 14-11(c)](#fig14-11).
    Although node 2 is a neighbor of node 1, the edge (1, 2) is already full. We cannot
    send any more flow through that edge, so the algorithm rules out paths using that
    edge and keeps node 2 as unseen. It is not until [Figure 14-11(d)](#fig14-11)
    that it finds a viable route to node 2 (from node 3).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法在[图14-11(c)](#fig14-11)中与标准的广度优先搜索有所不同。尽管节点2是节点1的邻居，但边(1, 2)已经满了。我们无法通过该边再发送流量，因此算法排除了使用该边的路径，并将节点2保持为未访问状态。直到[图14-11(d)](#fig14-11)，它才找到一条通向节点2的可行路径（从节点3出发）。
- en: '![Each subfigure shows a six-node graph with eight edges. In (A), node 0 is
    shaded and no nodes are circled. In (B), node 0 is circled and nodes 0, 1, and
    3 are shaded.](../images/f14011.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图显示一个包含六个节点和八条边的图。在 (A) 中，节点 0 被阴影标记，且没有节点被圈出。在 (B) 中，节点 0 被圈出，节点 0、1
    和 3 被阴影标记。](../images/f14011.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: The steps of
    the search to find an augmenting path</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-11：搜索增广路径的步骤</samp>
- en: The search completes in [Figure 14-11(e)](#fig14-11) after finding a path to
    the sink node. At this point, it has found a viable path [0, 1, 4, 5] from the
    source to the sink and need not consider any other nodes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索在 [图 14-11(e)](#fig14-11) 中完成，找到通向汇节点的路径。此时，它已经找到了一个可行的路径 [0, 1, 4, 5] 从源节点到汇节点，无需考虑其他节点。
- en: 'The code for the top-level Edmonds-Karp algorithm is nearly identical to the
    depth-first search version of Ford-Fulkerson from [Listing 14-1](#list14-1):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级 Edmonds-Karp 算法的代码与 [清单 14-1](#list14-1) 中的 Ford-Fulkerson 深度优先搜索版本几乎相同：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The only significant change from [Listing 14-1](#list14-1) is the use of the
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>
    to conduct the search for an augmenting path ❶.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [清单 14-1](#list14-1) 中的代码唯一显著的不同是使用了函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>
    来进行增广路径的搜索 ❶。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 14-12](#fig14-12) shows an example of running the Edmonds-Karp algorithm
    on a graph with 8 nodes and 11 edges, where node 0 is the source node and node
    7 is the sink node. [Figure 14-12(a)](#fig14-12) represents the state of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> before the first
    iteration. None of the edges’ capacities are used. Each subsequent step of the
    algorithm is depicted *after* each augmenting path is updated; the bolded edges
    indicate the augmenting path used. For example, in [Figure 14-12(b)](#fig14-12),
    the edges (0, 1), (1, 2), and (2, 7) form the augmenting path. The minimum residual
    was 3, and the subfigure shows the amount of used capacity after 3 more units
    of flow were added to this path.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-12](#fig14-12) 显示了在一个包含 8 个节点和 11 条边的图上运行 Edmonds-Karp 算法的示例，其中节点 0 为源节点，节点
    7 为汇节点。 [图 14-12(a)](#fig14-12) 表示第一次迭代前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    状态。此时，所有边的容量都没有被使用。算法的每个后续步骤都显示在*每次*增广路径更新后；加粗的边表示所使用的增广路径。例如，在 [图 14-12(b)](#fig14-12)
    中，边 (0, 1)、(1, 2) 和 (2, 7) 形成增广路径。最小残余为 3，子图显示了在该路径上增加 3 个单位流量后的已使用容量。'
- en: '![Each subfigure shows the same graph with 8 nodes and 11 edges. The graph
    in (A) has no edges using capacity. (B) shows the same graph with edges (0, 1),
    (1, 2), and (2, 7) bolded. All the edges use 3 units of their capacity.](../images/f14012.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图显示相同的包含 8 个节点和 11 条边的图。图 (A) 没有边使用容量。(B) 显示相同的图，边 (0, 1)、(1, 2) 和 (2,
    7) 被加粗。所有边使用了 3 单位的容量。](../images/f14012.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: The steps of
    the Edmonds-Karp algorithm on a graph with eight nodes</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 14-12：在一个包含八个节点的图上执行 Edmonds-Karp
    算法的步骤</samp>
- en: '[Figure 14-12(f)](#fig14-12) shows a step where the algorithm uses the backward
    residual. After four rounds of following only forward edges, the search has hit
    a bottleneck and *reduces* the flow on the edge from node 5 to node 4 to free
    up more capacity. To understand how this helps, consider the flow from node 0
    to node 5\. Before the last step, it is already maxed out. The edge cannot handle
    more than 10 units of flow. However, that flow is not being used optimally. By
    reducing the flow from node 5 to node 4, we can send more of that flow through
    node 6 to the sink. This leaves node 4 with less incoming flow than outgoing flow.
    To fix this disparity, we need to push more flow through an alternate path. In
    this case, the extra unit of flow comes to node 4 through the path [0, 1, 2, 3,
    4].  ### <samp class="SANS_Futura_Std_Bold_B_11">Modeling Increasingly Complex
    Real-World Situations</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-12(f)](#fig14-12)展示了算法使用反向剩余流的步骤。在经过四轮仅沿前向边缘的搜索后，搜索遇到了瓶颈，并*减少*了从节点5到节点4的边的流量，以释放更多的容量。为了理解这种操作的帮助，考虑从节点0到节点5的流量。在最后一步之前，流量已经达到了最大值。该边无法处理超过10个单位的流量。然而，这个流量并未得到最优利用。通过减少从节点5到节点4的流量，我们可以将更多的流量通过节点6送往汇点。这使得节点4的流入流量低于流出流量。为了解决这种不平衡，我们需要通过替代路径推动更多的流量。在这种情况下，额外的单位流量通过路径[0,
    1, 2, 3, 4]到达节点4。### <samp class="SANS_Futura_Std_Bold_B_11">建模日益复杂的现实世界情况</samp>'
- en: Our maximum-flow algorithm placed restrictions on the structure of the graph
    to simplify reasoning about the algorithm. These constraints included limiting
    the graph to a single source and a single sink and prohibiting anti-parallel edges.
    This section examines how we can relax several of these limitations to model increasingly
    complex real-world situations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最大流算法对图的结构设置了限制，以简化对算法的推理。这些约束包括将图限制为单一源节点和单一汇点，并禁止反向平行边。本节将探讨如何放宽其中一些限制，以建模日益复杂的现实世界情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Sources</samp>
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">多个源</samp>
- en: Many real-world flow networks contain more than a single source node. For example,
    consider the more realistic view of the wastewater problem we have been using
    throughout this chapter. Rather than a single incoming pipe, it’s far more likely
    that the network will include pipes entering from each building connected to the
    system. Even if we model at the city level, we can expect new sources to join
    the network from the surrounding suburbs. [Figure 14-13(a)](#fig14-13) shows a
    network with three source nodes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界的流网络包含多个源节点。例如，考虑我们在本章中一直使用的废水问题的更现实的视角。与单一的进水管道相比，网络更有可能包括来自每个与系统连接的建筑物的管道。即使我们在城市层面建模，我们也可以预期新的源节点将来自周边郊区加入到网络中。[图14-13(a)](#fig14-13)显示了一个包含三个源节点的网络。
- en: '![(B) shows the graph from subfigure A with a new node (s’) inserted on the
    left and edges to the three s nodes in subfigure A’s graph.](../images/f14013.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![(B)显示了子图A的图，其中左侧插入了一个新节点(s'')，并与子图A图中的三个s节点建立了边连接。](../images/f14013.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-13: A flow graph
    with multiple sources (a) and the corresponding model with a single aggregate
    source (b)</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-13：具有多个源的流图（a）及其对应的模型，单一聚合源（b）</samp>
- en: Luckily, we can easily extend the flow network model by adding a new artificial
    source node *s*′ that effectively supplies each of the previous sources. The new
    source node is connected by directed edges to each of the previous source nodes.
    In turn, those previous sources now become internal nodes in our extended model,
    as shown in [Figure 14-13(b)](#fig14-13). The bolded arrows indicate new edges
    added from the new node to the previous source nodes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过添加一个新的人工源节点*s*′来轻松扩展流网络模型，该节点有效地为所有先前的源节点提供流量。新源节点通过有向边连接到每个先前的源节点。反过来，这些先前的源节点现在成为我们扩展模型中的内部节点，如[图14-13(b)](#fig14-13)所示。加粗的箭头表示从新节点到先前源节点添加的新边。
- en: Of course, our artificial source node does not exist in reality. A city’s storm
    drains are not fed by a secret super-drain. Instead, the aggregated source serves
    as a convenient mathematical abstraction that allows us to assign the source of
    all flow back to a single (virtual) node.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的人工源节点在现实中并不存在。城市的暴雨排水系统并不是由一个秘密的超级排水管道提供的。相反，聚合源作为一种方便的数学抽象，允许我们将所有流量的源归结为一个单一（虚拟）节点。
- en: Adding the new node and edges raises the question of how we choose the capacity
    of those new edges. If we set their capacity too low, these edges will serve as
    a bottleneck, preventing us from accurately modeling the problem. However, it
    doesn’t matter if we set the edge weights too high, because the bottleneck will
    then be the already-existing bottleneck in the original network. We can therefore
    use infinite capacities along those new edges to supply the previous sources with
    all the flow they can handle. In the context of the wastewater system, these would
    be gigantic pipes that vastly exceed the flow of anything the engineers could
    actually build.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新节点和边引发了一个问题，即我们如何选择这些新边的容量。如果我们将其容量设置得太低，这些边将成为瓶颈，导致无法准确建模问题。然而，如果我们将边的权重设置得过高也没关系，因为瓶颈将成为原始网络中已经存在的瓶颈。因此，我们可以在这些新边上使用无限容量，以便为之前的源提供它们可以处理的所有流量。在废水系统的背景下，这些边将是巨大的管道，远远超过任何工程师实际能够建造的流量。
- en: We create a helper function to augment an arbitrary graph with multiple sources
    to add the aggregate source, as shown in [Listing 14-2](#list14-2).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个辅助函数，用于将一个具有多个源的任意图增广，添加聚合源，如 [Listing 14-2](#list14-2) 所示。
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: Transforming
    a multi-source graph into one with a single source</samp>'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: 将多源图转换为单源图</samp>'
- en: The code inserts a new node into the graph ❶. For each of the previous sources,
    it then creates a new edge from the new source to the previous source with infinite
    capacity ❷. Finally, the code returns the index of the new source for us to use
    when calling the Ford-Fulkerson algorithm.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将一个新节点插入到图中 ❶。对于每个之前的源，代码会从新源到该源创建一个具有无限容量的新边 ❷。最后，代码返回新源的索引，以供我们在调用 Ford-Fulkerson
    算法时使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Sinks</samp>
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">多个汇点</samp>
- en: Just as many real-world problems have multiple sources, we often encounter networks
    with multiple sinks. Consider the interstate highway system, for example, where
    cars and trucks flow along the roads to numerous divergent destinations. [Figure
    14-14(a)](#fig14-14) shows a network with two sink nodes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多现实世界的问题有多个源一样，我们经常遇到具有多个汇点的网络。以洲际公路系统为例，汽车和卡车沿着道路流向多个不同的目的地。[Figure 14-14(a)](#fig14-14)
    显示了一个具有两个汇点节点的网络。
- en: We can adapt the approach we used for the multi-source problem to handle multiple
    sinks. We create a new aggregated sink *t*′ and create directed edges from each
    previous sink to the new aggregate, as shown in [Figure 14-14(b)](#fig14-14).
    The new node and edges are bolded. We assign each of these edges enough capacity
    so they cannot generate a new bottleneck.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将用于多源问题的方法适配到处理多个汇点的问题。我们创建一个新的聚合汇点 *t*′，并从每个之前的汇点到新聚合汇点创建有向边，如图 [Figure
    14-14(b)](#fig14-14) 所示。新节点和边被加粗显示。我们为这些边分配足够的容量，以确保它们不会产生新的瓶颈。
- en: '![(B) shows the graph from (A) with a new node (t’) inserted on the right and
    edges from the two t nodes in (A)’s graph.](../images/f14014.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![(B) 显示了图 (A) 中右侧插入的新节点 (t'')，以及从 (A) 中的两个 t 节点到新节点的边。](../images/f14014.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: A flow graph
    with multiple sinks (a) and the corresponding model with a single aggregate sink
    (b)</samp>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: 一个具有多个汇点的流量图（a），以及相应的具有单一聚合汇点的模型（b）</samp>'
- en: 'Again, we provide a helper function to augment a given graph with multiple
    sinks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们提供一个辅助函数，用于将给定图增广，添加多个汇点：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code follows the form of the <samp class="SANS_TheSansMonoCd_W5Regular_11">augment_multisource_graph()</samp>
    function in [Listing 14-2](#list14-2). It inserts a new sink node into the graph,
    creates edges with sufficient capacity to each of the old sinks, and returns the
    index of this new node.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遵循 <samp class="SANS_TheSansMonoCd_W5Regular_11">augment_multisource_graph()</samp>
    函数的形式，如 [Listing 14-2](#list14-2) 所示。它将一个新的汇点节点插入图中，创建与每个旧汇点之间具有足够容量的边，并返回这个新节点的索引。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anti-parallel Edges</samp>
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">反向边</samp>
- en: 'It is also unrealistic to prohibit anti-parallel edges in real-world use cases.
    Continuing with the example of the interstate highway system, nearly every highway
    is a two-way road: you can travel Route 90 from Cleveland to Buffalo or from Buffalo
    to Cleveland.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，禁止反向平行边也是不现实的。继续以州际高速公路系统为例，几乎每条高速公路都是双向道路：你可以从克利夫兰到布法罗，也可以从布法罗到克利夫兰。
- en: We can use another mathematical trick to support such real-world cases while
    maintaining the restriction that the graph must not have anti-parallel edges.
    When dealing with a loop with edges (*u*, *v*) with capacity *w*[1] and (*v*,
    *u*) with capacity *w*[2], as shown in [Figure 14-15(a)](#fig14-15), we can add
    a new node *x* and replace the edge (*u*, *v*) with the pair of edges (*u*, *x*)
    and (*x*, *v*), as shown in [Figure 14-15(b)](#fig14-15). If we use the same capacity
    *w*[1] of the previous edge (*u*, *v*) for both edges (*u*, *x*) and (*x*, *v*),
    the total flow allowed through the expanded path is the same (*w*[1]).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个数学技巧来支持这种实际案例，同时保持图中不允许有反向平行边的限制。当处理一个包含边(*u*, *v*)，容量为*w*[1]和边(*v*,
    *u*)，容量为*w*[2]的回路时，如[图14-15(a)](#fig14-15)所示，我们可以添加一个新节点*x*，并将边(*u*, *v*)替换为边对(*u*,
    *x*)和(*x*, *v*)，如[图14-15(b)](#fig14-15)所示。如果我们将先前边(*u*, *v*)的容量*w*[1]应用于边(*u*,
    *x*)和(*x*, *v*)，则扩展路径允许的总流量为相同的值（*w*[1]）。
- en: '![(B) shows the graph from (A) where a new node x has been inserted and the
    directed edge from (u, v) has been replaced with edges (u, x) and (x, v).](../images/f14015.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![（B）显示了（A）图中的图，其中插入了一个新节点x，并且从（u，v）到（u，x）和（x，v）的有向边替换了原边。](../images/f14015.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-15: A graph with
    a loop containing two edges (a) and its augmented version (b)</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图14-15：包含两个边的回路图（a）及其扩展版本（b）</samp>
- en: We could define a single preprocessing step that iterates over all edges in
    the graph and inserts extra nodes and edges where needed. If the original graph
    contains an edge (origin, destination) and the edge’s inverse (destination, origin),
    then we have anti-parallel edges and need to insert a single new node.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个单一的预处理步骤，遍历图中的所有边，并在需要时插入额外的节点和边。如果原始图包含一条边（起点，终点）及其反向边（终点，起点），那么我们就有反向平行边，需要插入一个新节点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: 'We can use the maximum-flow problem to answer a wide range of real-world analysis
    and optimization questions. Beyond simply finding the maximum flow from source
    to sink, the techniques for solving the maximum-flow problem provide crucial insights
    into the network itself: we can use the residual graph to find bottlenecks or
    discover which links have excess capacity. For example, suppose our analysis of
    a proposed wastewater processing system reveals that a pipe with capacity of 50
    gallons per minute will be used only for 10 gallons per minute due to restrictions
    elsewhere in the network. We now know this pipe presents a clear cost-saving opportunity.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用最大流问题来解答各种实际的分析和优化问题。除了单纯地从源点到汇点找到最大流量外，解决最大流问题的技巧还能为网络本身提供重要的见解：我们可以利用残差图来找到瓶颈，或者发现哪些链路存在过剩的容量。例如，假设我们对一个拟议的废水处理系统进行分析，结果显示，由于网络中的其他限制，一条容量为每分钟50加仑的管道只会使用每分钟10加仑。我们现在知道，这条管道是一个明显的节省成本的机会。
- en: The algorithmic approaches in this chapter also provide new ways of thinking
    about and working with graphs. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    data structure is an expansion on the standard edge that allows for tracking dynamic
    amounts, and the paths through a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    change as flow is applied. This is the first time we have seen an algorithm that
    needs to account for dynamic quantities related to edges.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的算法方法还提供了新的思路来思考和处理图。<samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    数据结构是标准边的扩展，它可以跟踪动态量，而在<sup class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</sup>中的路径会随着流量的应用而变化。这是我们第一次看到需要考虑与边相关的动态量的算法。
- en: As we will see in the next chapter, the maximum-flow algorithm has extensions
    to more general matching problems, including optimizing the connections between
    pairs of nodes. We will also see how these techniques can be applied to the more
    abstract problem of maximum-cardinality bipartite graph matching.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一章看到的，最大流算法有扩展到更一般的匹配问题，包括优化节点对之间的连接。我们还将看到这些技术如何应用于更抽象的最大基数二分图匹配问题。
