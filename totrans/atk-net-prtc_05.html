<html><head></head><body>
<h2 class="h2a" id="ch05"><span epub:type="pagebreak" id="page_79"/><strong><span class="big">5</span></strong><br/><strong>ANALYSIS FROM THE WIRE</strong></h2>&#13;
<p class="noindent_first">In <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>, I discussed how to capture network traffic for analysis. Now it’s time to put that knowledge to the test. In this chapter, we’ll examine how to analyze captured network protocol traffic from a chat application to understand the protocol in use. If you can determine which features a protocol supports, you can assess its security.</p>&#13;
<p class="indent">Analysis of an unknown protocol is typically incremental. You begin by capturing network traffic, and then analyze it to try to understand what each part of the traffic represents. Throughout this chapter, I’ll show you how to use Wireshark and some custom code to inspect an unknown network protocol. Our approach will include extracting structures and state information.</p>&#13;
<h3 class="h3" id="ch00lev1sec107"><span epub:type="pagebreak" id="page_80"/><strong>The Traffic-Producing Application: SuperFunkyChat</strong></h3>&#13;
<p class="noindent">The test subject for this chapter is a chat application I’ve written in C# called SuperFunkyChat, which will run on Windows, Linux, and macOS. Download the latest prebuild applications and source code from the GitHub page at <em><a href="https://github.com/tyranid/ExampleChatApplication/releases/">https://github.com/tyranid/ExampleChatApplication/releases/</a></em>; be sure to choose the release binaries appropriate for your platform. (If you’re using Mono, choose the .NET version, and so on.) The example client and server console applications for SuperFunkyChat are called ChatClient and ChatServer.</p>&#13;
<p class="indent">After you’ve downloaded the application, unpack the release files to a directory on your machine so you can run each application. For the sake of simplicity, all example command lines will use the Windows executable binaries. If you’re running under Mono, prefix the command with the path to the main <em>mono</em> binary. When running files for .NET Core, prefix the command with the <em>dotnet</em> binary. The files for .NET will have a <em>.dll</em> extension instead of <em>.exe</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec108"><strong><em>Starting the Server</em></strong></h4>&#13;
<p class="noindent">Start the server by running <em>ChatServer.exe</em> with no parameters. If successful, it should print some basic information, as shown in <a href="../Text/ch05.xhtml#ch5list1">Listing 5-1</a>.</p>&#13;
<pre>C:\SuperFunkyChat&gt; <span class="codestrong">ChatServer.exe</span><br/>ChatServer (c) 2017 James Forshaw<br/>WARNING: Don't use this for a real chat system!!!<br/>Running server on port 12345 Global Bind False</pre>&#13;
<p class="listing"><a id="ch5list1"/><em>Listing 5-1: Example output from running ChatServer</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Pay attention to the warning! This application has not been designed to be a secure chat system.</em></p>&#13;
</div>&#13;
<p class="indent">Notice in <a href="../Text/ch05.xhtml#ch5list1">Listing 5-1</a> that the final line prints the port the server is running on (12345 in this case) and whether the server has bound to all interfaces (global). You probably won’t need to change the port (<code>--port NUM</code>), but you might need to change whether the application is bound to all interfaces if you want clients and the server to exist on different computers. This is especially important on Windows. It’s not easy to capture traffic to the local loopback interface on Windows; if you encounter any difficulties, you may need to run the server on a separate computer or a virtual machine (VM). To bind to all interfaces, specify the <code>--global</code> parameter.</p>&#13;
<h4 class="h4" id="ch00lev1sec109"><strong><em>Starting Clients</em></strong></h4>&#13;
<p class="noindent">With the server running, we can start one or more clients. To start a client, run <em>ChatClient.exe</em> (see <a href="../Text/ch05.xhtml#ch5list2">Listing 5-2</a>), specify the username you want to use on the server (the username can be anything you like), and specify the server hostname (for example, <code>localhost</code>). When you run the client, you should see output similar to that shown in <a href="../Text/ch05.xhtml#ch5list2">Listing 5-2</a>. If you see any errors, make sure <span epub:type="pagebreak" id="page_81"/>you’ve set up the server correctly, including requiring binding to all interfaces or disabling the firewall on the server.</p>&#13;
<pre>C:\SuperFunkyChat&gt; <span class="codestrong">ChatClient.exe <span class="codeitalic">USERNAME HOSTNAME</span></span><br/>ChatClient (c) 2017 James Forshaw<br/>WARNING: Don't use this for a real chat system!!!<br/>Connecting to localhost:12345</pre>&#13;
<p class="listing"><a id="ch5list2"/><em>Listing 5-2: Example output from running ChatClient</em></p>&#13;
<p class="indent">As you start the client, look at the running server: you should see output on the console similar to <a href="../Text/ch05.xhtml#ch5list3">Listing 5-3</a>, indicating that the client has successfully sent a “Hello” packet.</p>&#13;
<pre>Connection from 127.0.0.1:49825<br/>Received packet ChatProtocol.HelloProtocolPacket<br/>Hello Packet for User: alice HostName: borax</pre>&#13;
<p class="listing"><a id="ch5list3"/><em>Listing 5-3: The server output when a client connects</em></p>&#13;
<h4 class="h4" id="ch00lev1sec110"><strong><em>Communicating Between Clients</em></strong></h4>&#13;
<p class="noindent">After you’ve completed the preceding steps successfully, you should be able to connect multiple clients so you can communicate between them. To send a message to all users with the ChatClient, enter the message on the command line and press ENTER.</p>&#13;
<p class="indent">The ChatClient also supports a few other commands, which all begin with a forward slash (<code>/</code>), as detailed in <a href="../Text/ch05.xhtml#ch5tab1">Table 5-1</a>.</p>&#13;
<p class="tabcap"><a id="ch5tab1"/><strong>Table 5-1:</strong> Commands for the ChatClient Application</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Command</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>/quit [message]</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Quit client with optional message</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>/msg user message</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Send a message to a specific user</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>/list</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">List other users on the system</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>/help</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Print help information</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You’re ready to generate traffic between the SuperFunkyChat clients and server. Let’s start our analysis by capturing and inspecting some traffic using Wireshark.</p>&#13;
<h3 class="h3" id="ch00lev1sec111"><strong>A Crash Course in Analysis with Wireshark</strong></h3>&#13;
<p class="noindent">In <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>, I introduced Wireshark but didn’t go into any detail on how to use Wireshark to analyze rather than simply capture traffic. Because Wireshark is a very powerful and comprehensive tool, I’ll only scratch the surface of its functionality here. When you first start Wireshark on Windows, you should see a window similar to the one shown in <a href="../Text/ch05.xhtml#ch5fig1">Figure 5-1</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_82"/><img alt="image" src="../Images/f05-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig1"/><em>Figure 5-1: The main Wireshark window on Windows</em></p>&#13;
<p class="indent">The main window allows you to choose the interface to capture traffic from. To ensure we capture only the traffic we want to analyze, we need to configure some options on the interface. Select <strong>Capture</strong> ▸ <strong>Options</strong> from the menu. <a href="../Text/ch05.xhtml#ch5fig2">Figure 5-2</a> shows the options dialog that opens.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig2"/><em>Figure 5-2: The Wireshark Capture Interfaces dialog</em></p>&#13;
<p class="indent">Select the network interface you want to capture traffic from, as shown at <span class="ent">➊</span>. Because we’re using Windows, choose <strong>Local Area Connection</strong>, which is our main Ethernet connection; we can’t easily capture from Localhost. Then set a capture filter <span class="ent">➋</span>. In this case, we specify the filter <strong>ip host 192.168.10.102</strong> to limit capture to traffic to or from the IP <span epub:type="pagebreak" id="page_83"/>address 192.168.10.102. (The IP address we’re using is the chat server’s address. Change the IP address as appropriate for your configuration.) Click the <strong>Start</strong> button to begin capturing traffic.</p>&#13;
<h4 class="h4" id="ch00lev1sec112"><strong><em>Generating Network Traffic and Capturing Packets</em></strong></h4>&#13;
<p class="noindent">The main approach to packet analysis is to generate as much traffic from the target application as possible to improve your chances of finding its various protocol structures. For example, <a href="../Text/ch05.xhtml#ch5list4">Listing 5-4</a> shows a single session with ChatClient for <code>alice</code>.</p>&#13;
<pre># alice - Session<br/>&gt; Hello There!<br/>&lt; bob: I've just joined from borax<br/>&lt; bob: How are you?<br/>&lt; bob: This is nice isn't it?<br/>&lt; bob: Woo<br/>&lt; Server: 'bob' has quit, they said 'I'm going away now!'<br/>&lt; bob: I've just joined from borax<br/>&lt; bob: Back again for another round.<br/>&lt; Server: 'bob' has quit, they said 'Nope!'<br/>&gt; /quit<br/>&lt; Server: Don't let the door hit you on the way out!</pre>&#13;
<p class="listing"><a id="ch5list4"/><em>Listing 5-4: Single ChatClient session for <code><span class="codeitalic">alice</code></span>.</em></p>&#13;
<p class="indent">And <a href="../Text/ch05.xhtml#ch5list5">Listing 5-5</a> and <a href="../Text/ch05.xhtml#ch5list6">Listing 5-6</a> show two sessions for <code>bob</code>.</p>&#13;
<pre># bob - Session 1<br/>&gt; How are you?<br/>&gt; This is nice isn't it?<br/>&gt; /list<br/>&lt; User List<br/>&lt; alice - borax<br/>&gt; /msg alice Woo<br/>&gt; /quit<br/>&lt; Server: Don't let the door hit you on the way out!</pre>&#13;
<p class="listing"><a id="ch5list5"/><em>Listing 5-5: First ChatClient session for <code><span class="codeitalic">bob</code></span></em></p>&#13;
<pre># bob - Session 2<br/>&gt; Back again for another round.<br/>&gt; /quit Nope!<br/>&lt; Server: Don't let the door hit you on the way out!</pre>&#13;
<p class="listing"><a id="ch5list6"/><em>Listing 5-6: Second ChatClient session for <code><span class="codeitalic">bob</code></span></em></p>&#13;
<p class="indent">We run two sessions for <code>bob</code> so we can capture any connection or disconnection events that might only occur between sessions. In each session, a right angle bracket (<code>&gt;</code>) indicates a command to enter into the ChatClient, and a left angle bracket (<code>&lt;</code>) indicates responses from the server being written to the <span epub:type="pagebreak" id="page_84"/>console. You can execute the commands to the client for each of these session captures to reproduce the rest of the results in this chapter for analysis.</p>&#13;
<p class="indent">Now turn to Wireshark. If you’ve configured Wireshark correctly and bound it to the correct interface, you should start seeing packets being captured, as shown in <a href="../Text/ch05.xhtml#ch5fig3">Figure 5-3</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig3"/><em>Figure 5-3: Captured traffic in Wireshark</em></p>&#13;
<p class="indent">After running the example sessions, stop the capture by clicking the <strong>Stop</strong> button (highlighted) and save the packets for later use if you want.</p>&#13;
<h4 class="h4" id="ch00lev1sec113"><strong><em>Basic Analysis</em></strong></h4>&#13;
<p class="noindent">Let’s look at the traffic we’ve captured. To get an overview of the communication that occurred during the capture period, choose among the options on the Statistics menu. For example, choose <strong>Statistics</strong> ▸ <strong>Conversations</strong>, and you should see a new window displaying high-level conversations such as TCP sessions, as shown in the Conversations window in <a href="../Text/ch05.xhtml#ch5fig4">Figure 5-4</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig4"/><em>Figure 5-4: The Wireshark Conversations window</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_85"/>The Conversations window shows three separate TCP conversations in the captured traffic. We know that the SuperFunkyChat client application uses port 12345, because we see three separate TCP sessions coming from port 12345. These sessions should correspond to the three client sessions shown in <a href="../Text/ch05.xhtml#ch5list4">Listing 5-4</a>, <a href="../Text/ch05.xhtml#ch5list5">Listing 5-5</a>, and <a href="../Text/ch05.xhtml#ch5list6">Listing 5-6</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec114"><strong><em>Reading the Contents of a TCP Session</em></strong></h4>&#13;
<p class="noindent">To view the captured traffic for a single conversation, select one of the conversations in the Conversations window and click the <strong>Follow Stream</strong> button. A new window displaying the contents of the stream as ASCII text should appear, as shown in <a href="../Text/ch05.xhtml#ch5fig5">Figure 5-5</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig5"/><em>Figure 5-5: Displaying the contents of a TCP session in Wireshark’s Follow TCP Stream view</em></p>&#13;
<p class="indent">Wireshark replaces data that can’t be represented as ASCII characters with a single dot character, but even with that character replacement, it’s clear that much of the data is being sent in plaintext. That said, the network protocol is clearly not exclusively a text-based protocol because the control information for the data is nonprintable characters. The only reason we’re seeing text is that SuperFunkyChat’s primary purpose is to send text messages.</p>&#13;
<p class="indent">Wireshark shows the inbound and outbound traffic in a session using different colors: pink for outbound traffic and blue for inbound. In a TCP session, outbound traffic is from the client that initiated the TCP session, and inbound traffic is from the TCP server. Because we’ve captured all traffic to the server, let’s look at another conversation. To change the conversation, change the Stream number <span class="ent">➊</span> in <a href="../Text/ch05.xhtml#ch5fig5">Figure 5-5</a> to 1. You should now see a different conversation, for example, like the one in <a href="../Text/ch05.xhtml#ch5fig6">Figure 5-6</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_86"/><img alt="image" src="../Images/f05-06.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig6"/><em>Figure 5-6: A second TCP session from a different client</em></p>&#13;
<p class="indent">Compare <a href="../Text/ch05.xhtml#ch5fig6">Figure 5-6</a> to <a href="../Text/ch05.xhtml#ch5fig5">Figure 5-5</a>; you’ll see the details of the two sessions are different. Some text sent by the client (in <a href="../Text/ch05.xhtml#ch5fig6">Figure 5-6</a>), such as “How are you?”, is shown as received by the server in <a href="../Text/ch05.xhtml#ch5fig5">Figure 5-5</a>. Next, we’ll try to determine what those binary parts of the protocol represent.</p>&#13;
<h3 class="h3" id="ch00lev1sec115"><strong>Identifying Packet Structure with Hex Dump</strong></h3>&#13;
<p class="noindent">At this point, we know that our subject protocol seems to be part binary and part text, which indicates that looking at just the printable text won’t be enough to determine all the various structures in the protocol.</p>&#13;
<p class="indent">To dig in, we first return to Wireshark’s Follow TCP Stream view, as shown in <a href="../Text/ch05.xhtml#ch5fig5">Figure 5-5</a>, and change the Show and save data as drop-down menu to the <strong>Hex Dump</strong> option. The stream should now look similar to <a href="../Text/ch05.xhtml#ch5fig7">Figure 5-7</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-07.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig7"/><em>Figure 5-7: The Hex Dump view of the stream</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>The Hex Dump view shows three columns of information. The column at the very left <span class="ent">➊</span> is the byte offset into the stream for a particular direction. For example, the byte at 0 is the first byte sent in that direction, the byte 4 is the fifth, and so on. The column in the center <span class="ent">➋</span> shows the bytes as a hex dump. The column at the right <span class="ent">➌</span> is the ASCII representation, which we saw previously in <a href="../Text/ch05.xhtml#ch5fig5">Figure 5-5</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec116"><strong><em>Viewing Individual Packets</em></strong></h4>&#13;
<p class="noindent">Notice how the blocks of bytes shown in the center column in <a href="../Text/ch05.xhtml#ch5fig7">Figure 5-7</a> vary in length. Compare this again to <a href="../Text/ch05.xhtml#ch5fig6">Figure 5-6</a>; you’ll see that other than being separated by direction, all data in <a href="../Text/ch05.xhtml#ch5fig6">Figure 5-6</a> appears as one contiguous block. In contrast, the data in <a href="../Text/ch05.xhtml#ch5fig7">Figure 5-7</a> might appear as just a few blocks of 4 bytes, then a block of 1 byte, and finally a much longer block containing the main group of text data.</p>&#13;
<p class="indent">What we’re seeing in Wireshark are individual packets: each block is a single TCP packet, or <em>segment</em>, containing perhaps only 4 bytes of data. TCP is a stream-based protocol, which means that there are no real boundaries between consecutive blocks of data when you’re reading and writing data to a TCP socket. However, from a physical perspective, there’s no such thing as a real stream-based network transport protocol. Instead, TCP sends individual packets consisting of a TCP header containing information, such as the source and destination port numbers as well as the data.</p>&#13;
<p class="indent">In fact, if we return to the main Wireshark window, we can find a packet to prove that Wireshark is displaying single TCP packets. Select <strong>Edit</strong> ▸ <strong>Find Packet</strong>, and an additional drop-down menu appears in the main window, as shown <a href="../Text/ch05.xhtml#ch5fig8">Figure 5-8</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-08.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig8"/><em>Figure 5-8: Finding a packet in Wireshark’s main window</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>We’ll find the first value shown in <a href="../Text/ch05.xhtml#ch5fig7">Figure 5-7</a>, the string <code>BINX</code>. To do this, fill in the Find options as shown in <a href="../Text/ch05.xhtml#ch5fig8">Figure 5-8</a>. The first selection box indicates where in the packet capture to search. Specify that you want to search in the Packet bytes <span class="ent">➊</span>. Leave the second selection box as Narrow &amp; Wide, which indicates that you want to search for both ASCII and Unicode strings. Also leave the Case sensitive box unchecked and specify that you want to look for a String value <span class="ent">➋</span> in the third drop-down menu. Then enter the string value we want to find, in this case the string <code>BINX</code> <span class="ent">➌</span>. Finally, click the <strong>Find</strong> button, and the main window should automatically scroll and highlight the first packet Wireshark finds that contains the <code>BINX</code> string <span class="ent">➍</span>. In the middle window at <span class="ent">➎</span>, you should see that the packet contains 4 bytes, and you can see the raw data in the bottom window, which shows that we’ve found the <code>BINX</code> string <span class="ent">➏</span>. We now know that the Hex Dump view Wireshark displays in <a href="../Text/ch05.xhtml#ch5fig8">Figure 5-8</a> represents packet boundaries because the <code>BINX</code> string is in a packet of its own.</p>&#13;
<h4 class="h4" id="ch00lev1sec117"><strong><em>Determining the Protocol Structure</em></strong></h4>&#13;
<p class="noindent">To simplify determining the protocol structure, it makes sense to look only at one direction of the network communication. For example, let’s just look at the outbound direction (from client to server) in Wireshark. Returning to the Follow TCP Stream view, select the <strong>Hex Dump</strong> option in the Show and save data as drop-down menu. Then select the traffic direction from the client to the server on port 12345 from the drop-down menu at <span class="ent">➊</span>, as shown in <a href="../Text/ch05.xhtml#ch5fig9">Figure 5-9</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-09.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig9"/><em>Figure 5-9: A hex dump showing only the outbound direction</em></p>&#13;
<p class="indent">Click the <strong>Save as . . .</strong> button to copy the outbound traffic hex dump to a text file to make it easier to inspect. <a href="../Text/ch05.xhtml#ch5list7">Listing 5-7</a> shows a small sample of that traffic saved as text.</p>&#13;
<pre>00000000  42 49 4e 58                                        BINX<span class="ent">➊</span><br/>00000004  00 00 00 0d                                        ....<span class="ent">➋</span><br/>00000008  00 00 03 55                                        ...U<span class="ent">➌</span><br/><span epub:type="pagebreak" id="page_89"/>0000000C  00                                                 .<span class="ent">➍</span><br/>0000000D  05 61 6c 69 63 65 04 4f  4e 59 58 00               .alice.O NYX.<span class="ent">➎</span><br/>00000019  00 00 00 14                                        ....<br/>0000001D  00 00 06 3f                                        ...?<br/>00000021  03                                                 .<br/>00000022  05 61 6c 69 63 65 0c 48  65 6c 6c 6f 20 54 68 65   .alice.H ello The<br/>00000032  72 65 21                                           re!<br/>--<span class="codeitalic">snip</span>--</pre>&#13;
<p class="listing"><a id="ch5list7"/><em>Listing 5-7: A snippet of outbound traffic</em></p>&#13;
<p class="indent">The outbound stream begins with the four characters <code>BINX</code> <span class="ent">➊</span>. These characters are never repeated in the rest of the data stream, and if you compare different sessions, you’ll always find the same four characters at the start of the stream. If I were unfamiliar with this protocol, my intuition at this point would be that this is a magic value sent from the client to the server to tell the server that it’s talking to a valid client rather than some other application that happens to have connected to the server’s TCP port.</p>&#13;
<p class="indent">Following the stream, we see that a sequence of four blocks is sent. The blocks at <span class="ent">➋</span> and <span class="ent">➌</span> are 4 bytes, the block at <span class="ent">➍</span> is 1 byte, and the block at <span class="ent">➎</span> is larger and contains mostly readable text. Let’s consider the first block of 4 bytes at <span class="ent">➋</span>. Might these represent a small number, say the integer value 0xD or 13 in decimal?</p>&#13;
<p class="indent">Recall the discussion of the Tag, Length, Value (TLV) pattern in <a href="../Text/ch03.xhtml#ch03">Chapter 3</a>. TLV is a very simple pattern in which each block of data is delimited by a value representing the length of the data that follows. This pattern is especially important for stream-based protocols, such as those running over TCP, because otherwise the application doesn’t know how much data it needs to read from a connection to process the protocol. If we assume that this first value is the length of the data, does this length match the length of the rest of the packet? Let’s find out.</p>&#13;
<p class="indent">Count the total bytes of the blocks at <span class="ent">➋</span>, <span class="ent">➌</span>, <span class="ent">➍</span>, and <span class="ent">➎</span>, which seem to be a single packet, and the result is 21 bytes, which is eight more than the value of 13 we were expecting (the integer value 0xD). The value of the length block might not be counting its own length. If we remove the length block (which is 4 bytes), the result is 17, which is 4 bytes more than the target length but getting closer. We also have the other unknown 4-byte block at <span class="ent">➌</span> following the potential length, but perhaps that’s not counted either. Of course, it’s easy to speculate, but facts are more important, so let’s do some testing.</p>&#13;
<h4 class="h4" id="ch00lev1sec118"><strong><em>Testing Our Assumptions</em></strong></h4>&#13;
<p class="noindent">At this point in such an analysis, I stop staring at a hex dump because it’s not the most efficient approach. One way to quickly test whether our assumptions are right is to export the data for the stream and write some simple code to parse the structure. Later in this chapter, we’ll write some code for Wireshark to do all of our testing within the GUI, but for now we’ll implement the code using Python on the command line.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>To get our data into Python, we could add support for reading Wireshark capture files, but for now we’ll just export the packet bytes to a file. To export the packets from the dialog shown in <a href="../Text/ch05.xhtml#ch5fig9">Figure 5-9</a>, follow these steps:</p>&#13;
<ol>&#13;
<li><p class="noindent">In the Show and save data as drop-down menu, choose the <strong>Raw</strong> option.</p></li>&#13;
<li><p class="noindent">Click <strong>Save As</strong> to export the outbound packets to a binary file called <em>bytes_outbound.bin</em>.</p></li>&#13;
</ol>&#13;
<p class="indent">We also want to export the inbound packets, so change to and select the inbound conversation. Then save the raw inbound bytes using the preceding steps, but name the file <em>bytes_inbound.bin</em>.</p>&#13;
<p class="indent">Now use the XXD tool (or a similar tool) on the command line to be sure that we’ve successfully dumped the data, as shown in <a href="../Text/ch05.xhtml#ch5list8">Listing 5-8</a>.</p>&#13;
<pre>$ <span class="codestrong">xxd bytes_outbound.bin</span><br/>00000000: 4249 4e58 0000 000f 0000 0473 0003 626f  BINX.......s..bo<br/>00000010: 6208 7573 6572 2d62 6f78 0000 0000 1200  b.user-box......<br/>00000020: 0005 8703 0362 6f62 0c48 6f77 2061 7265  .....bob.How are<br/>00000030: 2079 6f75 3f00 0000 1c00 0008 e303 0362   you?..........b<br/>00000040: 6f62 1654 6869 7320 6973 206e 6963 6520  ob.This is nice<br/>00000050: 6973 6e27 7420 6974 3f00 0000 0100 0000  isn't it?.......<br/>00000060: 0606 0000 0013 0000 0479 0505 616c 6963  .........y..alic<br/>00000070: 6500 0000 0303 626f 6203 576f 6f00 0000  e.....bob.Woo...<br/>00000080: 1500 0006 8d02 1349 276d 2067 6f69 6e67  .......I'm going<br/>00000090: 2061 7761 7920 6e6f 7721                  away now!</pre>&#13;
<p class="listing"><a id="ch5list8"/><em>Listing 5-8: The exported packet bytes</em></p>&#13;
<h4 class="h4" id="ch00lev1sec119"><strong><em>Dissecting the Protocol with Python</em></strong></h4>&#13;
<p class="noindent">Now we’ll write a simple Python script to dissect the protocol. Because we’re just extracting data from a file, we don’t need to write any network code; we just need to open the file and read the data. We’ll also need to read binary data from the file—specifically, a network byte order integer for the length and unknown 4-byte block.</p>&#13;
<h5 class="h5" id="ch00lev1sec120"><strong>Performing the Binary Conversion</strong></h5>&#13;
<p class="noindent">We can use the built-in Python struct library to do the binary conversions. The script should fail immediately if something doesn’t seem right, such as not being able to read all the data we expect from the file. For example, if the length is 100 bytes and we can read only 20 bytes, the read should fail. If no errors occur while parsing the file, we can be more confident that our analysis is correct. <a href="../Text/ch05.xhtml#ch5list9">Listing 5-9</a> shows the first implementation, written to work in both Python 2 and 3.</p>&#13;
<pre>   from struct import unpack<br/>   import sys<br/>   import os<br/><span epub:type="pagebreak" id="page_91"/><br/>   # Read fixed number of bytes<br/><span class="ent">➊</span> def read_bytes(f, l):<br/>       bytes = f.read(l)<br/>    <span class="ent">➋</span> if len(bytes) != l:<br/>           raise Exception("Not enough bytes in stream")<br/>       return bytes<br/><br/>   # Unpack a 4-byte network byte order integer<br/><span class="ent">➌</span> def read_int(f):<br/>       return unpack("!i", read_bytes(f, 4))[0]<br/><br/>   # Read a single byte<br/><span class="ent">➍</span> def read_byte(f):<br/>       return ord(read_bytes(f, 1))<br/><br/>   filename = sys.argv[1]<br/>   file_size = os.path.getsize(filename)<br/><br/>   f = open(filename, "rb")<br/><span class="ent">➎</span> print("Magic: %s" % read_bytes(f, 4))<br/><br/>   # Keep reading until we run out of file<br/><span class="ent">➏</span> while f.tell() &lt; file_size:<br/>       length = read_int(f)<br/>       unk1 = read_int(f)<br/>       unk2 = read_byte(f)<br/>       data = read_bytes(f, length - 1)<br/>       print("Len: %d, Unk1: %d, Unk2: %d, Data: %s"<br/>           % (length, unk1, unk2, data))</pre>&#13;
<p class="listing"><a id="ch5list9"/><em>Listing 5-9: An example Python script for parsing protocol data</em></p>&#13;
<p class="indent">Let’s break down the important parts of the script. First, we define some helper functions to read data from the file. The function <code>read_bytes()</code> <span class="ent">➊</span> reads a fixed number of bytes from the file specified as a parameter. If not enough bytes are in the file to satisfy the read, an exception is thrown to indicate an error <span class="ent">➋</span>. We also define a function <code>read_int()</code> <span class="ent">➌</span> to read a 4-byte integer from the file in network byte order where the most significant byte of the integer is first in the file, as well as define a function to read a single byte <span class="ent">➍</span>. In the main body of the script, we open a file passed on the command line and first read a 4-byte value <span class="ent">➎</span>, which we expect is the magic value <code>BINX</code>. Then the code enters a loop <span class="ent">➏</span> while there’s still data to read, reading out the length, the two unknown values, and finally the data and then printing the values to the console.</p>&#13;
<p class="indent">When you run the script in <a href="../Text/ch05.xhtml#ch5list9">Listing 5-9</a> and pass it the name of a binary file to open, all data from the file should be parsed and no errors generated if our analysis that the first 4-byte block was the length of the data sent on the network is correct. <a href="../Text/ch05.xhtml#ch5list10">Listing 5-10</a> shows example output in Python 3, which does a better job of displaying binary strings than Python 2.</p>&#13;
<pre><span epub:type="pagebreak" id="page_92"/><span class="codestrong">$ python3 read_protocol.py bytes_outbound.bin</span><br/>Magic: b'BINX'<br/>Len: 15, Unk1: 1139, Unk2: 0, Data: b'\x03bob\x08user-box\x00'<br/>Len: 18, Unk1: 1415, Unk2: 3, Data: b'\x03bob\x0cHow are you?'<br/>Len: 28, Unk1: 2275, Unk2: 3, Data: b"\x03bob\x16This is nice isn't it?"<br/>Len: 1, Unk1: 6, Unk2: 6, Data: b''<br/>Len: 19, Unk1: 1145, Unk2: 5, Data: b'\x05alice\x00\x00\x00\x03\x03bob\x03Woo'<br/>Len: 21, Unk1: 1677, Unk2: 2, Data: b"\x13I'm going away now!"</pre>&#13;
<p class="listing"><a id="ch5list10"/><em>Listing 5-10: Example output from running <a href="../Text/ch05.xhtml#ch5list9">Listing 5-9</a> against a binary file</em></p>&#13;
<h5 class="h5" id="ch00lev1sec121"><strong>Handling Inbound Data</strong></h5>&#13;
<p class="noindent">If you ran <a href="../Text/ch05.xhtml#ch5list9">Listing 5-9</a> against an exported inbound data set, you would immediately get an error because there’s no magic string <code>BINX</code> in the inbound protocol, as shown in <a href="../Text/ch05.xhtml#ch5list11">Listing 5-11</a>. Of course, this is what we would expect if there were a mistake in our analysis and the length field wasn’t quite as simple as we thought.</p>&#13;
<pre><span class="codestrong">$ python3 read_protocol.py bytes_inbound.bin</span><br/>Magic: b'\x00\x00\x00\x02'<br/>Length: 1, Unknown1: 16777216, Unknown2: 0, Data: b''<br/>Traceback (most recent call last):<br/>  File "read_protocol.py", line 31, in &lt;module&gt;<br/>    data = read_bytes(f, length - 1)<br/>  File "read_protocol.py", line 9, in read_bytes<br/>    raise Exception("Not enough bytes in stream")<br/>Exception: Not enough bytes in stream</pre>&#13;
<p class="listing"><em><a id="ch5list11"/>Listing 5-11 Error generated by <a href="../Text/ch05.xhtml#ch5list9">Listing 5-9</a> on inbound data</em></p>&#13;
<p class="indent">We can clear up this error by modifying the script slightly to include a check for the magic value and reset the file pointer if it’s not equal to the string <code>BINX</code>. Add the following line just after the file is opened in the original script to reset the file pointer to the start if the magic value is incorrect.</p>&#13;
<pre>if read_bytes(f, 4) != b'BINX': f.seek(0)</pre>&#13;
<p class="indent">Now, with this small modification, the script will execute successfully on the inbound data and result in the output shown in <a href="../Text/ch05.xhtml#ch5list12">Listing 5-12</a>.</p>&#13;
<pre><span class="codestrong">$ python3 read_protocol.py bytes_inbound.bin</span><br/>Len: 2, Unk1: 1, Unk2: 1, Data: b'\x00'<br/>Len: 36, Unk1: 3146, Unk2: 3, Data: b"\x03bob\x1eI've just joined from user-box"<br/>Len: 18, Unk1: 1415, Unk2: 3, Data: b'\x03bob\x0cHow are you?'</pre>&#13;
<p class="listing"><a id="ch5list12"/><em>Listing 5-12: Output of modified script on inbound data</em></p>&#13;
<h5 class="h5" id="ch00lev1sec122"><span epub:type="pagebreak" id="page_93"/><strong>Digging into the Unknown Parts of the Protocol</strong></h5>&#13;
<p class="noindent">We can use the output in <a href="../Text/ch05.xhtml#ch5list10">Listing 5-10</a> and <a href="../Text/ch05.xhtml#ch5list12">Listing 5-12</a> to start delving into the unknown parts of the protocol. First, consider the field labeled <code>Unk1</code>. The values it takes seem to be different for every packet, but the values are low, ranging from 1 to 3146.</p>&#13;
<p class="indent">But the most informative parts of the output are the following two entries, one from the outbound data and one from the inbound.</p>&#13;
<pre>OUTBOUND: Len: 1, Unk1: 6, Unk2: 6, Data: b''<br/>INBOUND:  Len: 2, Unk1: 1, Unk2: 1, Data: b'\x00'</pre>&#13;
<p class="indent">Notice that in both entries the value of <code>Unk1</code> is the same as <code>Unk2</code>. That could be a coincidence, but the fact that both entries have the same value might indicate something important. Also notice that in the second entry the length is <code>2</code>, which includes the <code>Unk2</code> value and a <code>0</code> data value, whereas the length of the first entry is only <code>1</code> with no trailing data after the <code>Unk2</code> value. Perhaps <code>Unk1</code> is directly related to the data in the packet? Let’s find out.</p>&#13;
<h5 class="h5" id="ch00lev1sec123"><strong>Calculating the Checksum</strong></h5>&#13;
<p class="noindent">It’s common to add a checksum to a network protocol. The canonical example of a checksum is just the sum of all the bytes in the data you want to check for errors. If we assume that the unknown value is a <em>simple</em> checksum, we can sum all the bytes in the example outbound and inbound packets I highlighted in the preceding section, resulting in the calculated sum shown in <a href="../Text/ch05.xhtml#ch5tab2">Table 5-2</a>.</p>&#13;
<p class="tabcap"><a id="ch5tab2"/><strong>Table 5-2:</strong> Testing Checksum for Example Packets</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Unknown value</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Data bytes</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Sum of data bytes</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">6</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">6</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">6</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">1</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">1, 0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">1</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Although <a href="../Text/ch05.xhtml#ch5tab2">Table 5-2</a> seems to confirm that the unknown value matches our expectation of a simple checksum for very simple packets, we still need to verify that the checksum works for larger and more complex packets. There are two easy ways to determine whether we’ve guessed correctly that the unknown value is a checksum over the data. One way is to send simple, incrementing messages from a client (like <em>A</em>, then <em>B</em>, then <em>C</em>, and so on), capture the data, and analyze it. If the checksum is a simple addition, the value should increment by 1 for each incrementing message. The alternative would be to add a function to calculate the checksum to see whether the checksum matches between what was captured on the network and our calculated value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>To test our assumptions, add the code in <a href="../Text/ch05.xhtml#ch5list13">Listing 5-13</a> to the script in Listing 5-7 and add a call to it after reading the data to calculate the checksum. Then just compare the value extracted from the network capture as <code>Unk1</code> and the calculated value to see whether our calculated checksum matches.</p>&#13;
<pre>def calc_chksum(unk2, data):<br/>    chksum = unk2<br/>    for i in range(len(data)):<br/>        chksum += ord(data[i:i+1])<br/>    return chksum</pre>&#13;
<p class="listing"><a id="ch5list13"/><em>Listing 5-13: Calculating the checksum of a packet</em></p>&#13;
<p class="indent">And it does! The numbers calculated match the value of <code>Unk1</code>. So, we’ve discovered the next part of the protocol structure.</p>&#13;
<h5 class="h5" id="ch00lev1sec124"><strong>Discovering a Tag Value</strong></h5>&#13;
<p class="noindent">Now we need to determine what <code>Unk2</code> might represent. Because the value of <code>Unk2</code> is considered part of the packet’s data, it’s presumably related to the meaning of what is being sent. However, as we saw at <span class="ent">➍</span> in <a href="../Text/ch05.xhtml#ch5list7">Listing 5-7</a>, the value of <code>Unk2</code> is being written to the network as a single byte value, which indicates that it’s actually separate from the data. Perhaps the value represents the Tag part of a TLV pattern, just as we suspect that Length is the Value part of that construction.</p>&#13;
<p class="indent">To determine whether <code>Unk2</code> is in fact the Tag value and a representation of how to interpret the rest of the data, we’ll exercise the ChatClient as much as possible, try all possible commands, and capture the results. We can then perform basic analysis comparing the value of <code>Unk2</code> when sending the same type of command to see whether the value of <code>Unk2</code> is always the same.</p>&#13;
<p class="indent">For example, consider the client sessions in <a href="../Text/ch05.xhtml#ch5list4">Listing 5-4</a>, <a href="../Text/ch05.xhtml#ch5list5">Listing 5-5</a>, and <a href="../Text/ch05.xhtml#ch5list6">Listing 5-6</a>. In the session in <a href="../Text/ch05.xhtml#ch5list5">Listing 5-5</a>, we sent two messages, one after another. We’ve already analyzed this session using our Python script in <a href="../Text/ch05.xhtml#ch5list10">Listing 5-10</a>. For simplicity, <a href="../Text/ch05.xhtml#ch5list14">Listing 5-14</a> shows only the first three capture packets (with the latest version of the script).</p>&#13;
<pre>Unk2: 0<span class="ent">➊</span>, Data: b'\x03bob\x08user-box\x00'<br/>Unk2: 3<span class="ent">➋</span>, Data: b'\x03bob\x0cHow are you?'<br/>Unk2: 3<span class="ent">➌</span>, Data: b"\x03bob\x16This is nice isn't it?"<br/>*SNIP*</pre>&#13;
<p class="listing"><a id="ch5list14"/><em>Listing 5-14: The first three packets from the session represented by <a href="../Text/ch05.xhtml#ch5list5">Listing 5-5</a></em></p>&#13;
<p class="indent">The first packet <span class="ent">➊</span> doesn’t correspond to anything we typed into the client session in <a href="../Text/ch05.xhtml#ch5list5">Listing 5-5</a>. The unknown value is <code>0</code>. The two messages we then sent in <a href="../Text/ch05.xhtml#ch5list5">Listing 5-5</a> are clearly visible as text in the <code>Data</code> part of the packets at <span class="ent">➋</span> and <span class="ent">➌</span>. The <code>Unk2</code> values for both of those messages is <code>3</code>, which is different from the first packet’s value of <code>0</code>. Based on this observation, we can assume that the value of <code>3</code> might represent a packet that is sending a message, and if that’s the case, we’d expect to find a value of <code>3</code> used in every <span epub:type="pagebreak" id="page_95"/>connection when sending a single value. In fact, if you now analyze a different session containing messages being sent, you’ll find the same value of <code>3</code> used whenever a message is sent.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At this stage in my analysis, I’d return to the various client sessions and try to correlate the action I performed in the client with the messages sent. Also, I’d correlate the messages I received from the server with the client’s output. Of course, this is easy when there’s likely to be a one-to-one match between the command we use in the client and the result on the network. However, more complex protocols and applications might not be that obvious, so you’ll have to do a lot of correlation and testing to try to discover all the possible values for particular parts of the protocol.</em></p>&#13;
</div>&#13;
<p class="indent">We can assume that <code>Unk2</code> represents the Tag part of the TLV structure. Through further analysis, we can infer the possible Tag values, as shown in <a href="../Text/ch05.xhtml#ch5tab3">Table 5-3</a>.</p>&#13;
<p class="tabcap"><a id="ch5tab3"/><strong>Table 5-3:</strong> Inferred Commands from Analysis of Captured Sessions</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Command number</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Direction</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Outbound</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sent when client connects to server.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">1</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Inbound</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sent from server after client sends command <code>'0'</code> to the server.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">2</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Both</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sent from client when <code>/quit</code> command is used. Sent by server in response.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">3</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Both</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sent from client with a message for all users. Sent from server with the message from all users.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">5</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Outbound</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sent from client when <code>/msg</code> command is used.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">6</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Outbound</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sent from client when <code>/list</code> command is used.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">7</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Inbound</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sent from server in response to <code>/list</code> command.</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>We’ve built a table of commands but we still don’t know how the data for each of these commands is represented. To further analyze that data, we’ll return to Wireshark and develop some code to dissect the protocol and display it in the GUI. It can be difficult to deal with simple binary files, and although we could use a tool to parse a capture file exported from Wireshark, it’s best to have Wireshark handle a lot of that work.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec125"><strong>Developing Wireshark Dissectors in Lua</strong></h3>&#13;
<p class="noindent">It’s easy to analyze a known protocol like HTTP with Wireshark because the software can extract all the necessary information. But custom protocols are a bit more challenging: to analyze them, we’ll have to manually extract all the relevant information from a byte representation of the network traffic.</p>&#13;
<p class="indent">Fortunately, you can use the Wireshark plug-in Protocol Dissectors to add additional protocol analysis to Wireshark. Doing so used to require <span epub:type="pagebreak" id="page_96"/>building a dissector in C to work with your particular version of Wireshark, but modern versions of Wireshark support the Lua scripting language. The scripts you write in Lua will also work with the tshark command line tool.</p>&#13;
<p class="indent">This section describes how to develop a simple Lua script dissector for the SuperFunkyChat protocol that we’ve been analyzing.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Details about developing in Lua and the Wireshark APIs are beyond the scope of this book. For more information on how to develop in Lua, visit its official website at <a href="https://www.lua.org/docs.html">https://www.lua.org/docs.html</a>. The Wireshark website, and especially the Wiki, are the best places to visit for various tutorials and example code</em> (<a href="https://wiki.wireshark.org/Lua/">https://wiki.wireshark.org/Lua/</a>).</p>&#13;
</div>&#13;
<p class="indent">Before developing the dissector, make sure your copy of Wireshark supports Lua by checking the About Wireshark dialog at <strong>Help</strong> ▸ <strong>About Wireshark</strong>. If you see the word <em>Lua</em> in the dialog, as shown in <a href="../Text/ch05.xhtml#ch5fig10">Figure 5-10</a>, you should be good to go.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-10.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig10"/><em>Figure 5-10: The Wireshark About dialog showing Lua support</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you run Wireshark as root on a Unix-like system, Wireshark will typically disable Lua support for security reasons, and you’ll need to configure Wireshark to run as a nonprivileged user to capture and run Lua scripts. See the Wireshark documentation for your operating system to find out how to do so securely.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>You can develop dissectors for almost any protocol that Wireshark will capture, including TCP and UDP. It’s much easier to develop dissectors for UDP protocols than it is for TCP, because each captured UDP packet typically has everything needed by the dissector. With TCP, you’ll need to deal with such problems as data that spans multiple packets (which is exactly why we needed to account for length block in our work on SuperFunkyChat using the Python script in <a href="../Text/ch05.xhtml#ch5list9">Listing 5-9</a>). Because UDP is easier to work with, we’ll focus on developing UDP dissectors.</p>&#13;
<p class="indent">Conveniently enough, SuperFunkyChat supports a UDP mode by passing the <code>--udp</code> command line parameter to the client when starting. Send this flag while capturing, and you should see packets similar to those shown in <a href="../Text/ch05.xhtml#ch5fig11">Figure 5-11</a>. (Notice that Wireshark mistakenly tries to dissect the traffic as an unrelated GVSP protocol, as displayed in the Protocol column <span class="ent">➊</span>. Implementing our own dissector will fix the mistaken protocol choice.)</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-11.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig11"/><em>Figure 5-11: Wireshark showing captured UDP traffic</em></p>&#13;
<p class="indent">One way to load Lua files is to put your scripts in the <em>%APPDATA%\Wireshark\plugins</em> directory on Windows and in the <em>~/.config/wireshark/plugins</em> directory on Linux and macOS. You can also load a Lua script by specifying it on the command line as follows, replacing the path information with the location of your script:</p>&#13;
<pre><span class="codestrong">wireshark -X lua_script:<span class="codeitalic">&lt;/path/to/script.lua&gt;</span></span></pre>&#13;
<p class="indent">If there’s an error in your script’s syntax, you should see a message dialog similar to <a href="../Text/ch05.xhtml#ch5fig12">Figure 5-12</a>. (Granted, this isn’t exactly the most efficient way to develop, but it’s fine as long as you’re just prototyping.)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_98"/><img alt="image" src="../Images/f05-12.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig12"/><em>Figure 5-12: The Wireshark Lua error dialog</em></p>&#13;
<h4 class="h4" id="ch00lev1sec126"><strong><em>Creating the Dissector</em></strong></h4>&#13;
<p class="noindent">To create a protocol dissector for the SuperFunkyChat protocol, first create the basic shell of the dissector and register it in Wireshark’s list of dissectors for UDP port 12345. Copy <a href="../Text/ch05.xhtml#ch5list15">Listing 5-15</a> into a file called <em>dissector.lua</em> and load it into Wireshark along with an appropriate packet capture of the UDP traffic. It should run without errors.</p>&#13;
<p class="literal"><span class="codeitalic">dissector.lua</span></p>&#13;
<pre>   -- Declare our chat protocol for dissection<br/><span class="ent">➊</span> chat_proto = Proto("chat","SuperFunkyChat Protocol")<br/>   -- Specify protocol fields<br/><span class="ent">➋</span> chat_proto.fields.chksum = ProtoField.uint32("chat.chksum", "Checksum",<br/>                                                base.HEX)<br/>   chat_proto.fields.command = ProtoField.uint8("chat.command", "Command")<br/>   chat_proto.fields.data = ProtoField.bytes("chat.data", "Data")<br/><br/>   -- Dissector function<br/>   -- buffer: The UDP packet data as a "Testy Virtual Buffer"<br/>   -- pinfo: Packet information<br/>   -- tree: Root of the UI tree<br/><span class="ent">➌</span> function chat_proto.dissector(buffer, pinfo, tree)<br/>       -- Set the name in the protocol column in the UI<br/>    <span class="ent">➍</span> pinfo.cols.protocol = "CHAT"<br/><br/>       -- Create sub tree which represents the entire buffer.<br/>    <span class="ent">➎</span> local subtree = tree:add(chat_proto, buffer(),<br/>                                "SuperFunkyChat Protocol Data")<br/>       subtree:add(chat_proto.fields.chksum, buffer(0, 4))<br/>       subtree:add(chat_proto.fields.command, buffer(4, 1))<br/>       subtree:add(chat_proto.fields.data, buffer(5))<br/>   end<br/><br/>   -- Get UDP dissector table and add for port 12345<br/><span class="ent">➏</span> udp_table = DissectorTable.get("udp.port")<br/>   udp_table:add(12345, chat_proto)</pre>&#13;
<p class="listing"><a id="ch5list15"/><em>Listing 5-15: A basic Lua Wireshark dissector</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>When the script initially loads, it creates a new instance of the <code>Proto</code> class <span class="ent">➊</span>, which represents an instance of a Wireshark protocol and assigns it the name <code>chat_proto</code>. Although you can build the dissected tree manually, I’ve chosen to define specific fields for the protocol at <span class="ent">➋</span> so the fields will be added to the display filter engine, and you’ll be able to set a display filter of <code>chat.command == 0</code> so Wireshark will only show packets with command <code>0</code>. (This technique is very useful for analysis because you can filter down to specific packets easily and analyze them separately.)</p>&#13;
<p class="indent">At <span class="ent">➌</span>, the script creates a <code>dissector()</code> function on the instance of the <code>Proto</code> class. This <code>dissector()</code> will be called to dissect a packet. The function takes three parameters:</p>&#13;
<p class="bullt">• A buffer containing the packet data that is an instance of something Wireshark calls a Testy Virtual Buffer (TVB).</p>&#13;
<p class="bull">• A packet information instance that represents the display information for the dissection.</p>&#13;
<p class="bullb">• The root tree object for the UI. You can attach subnodes to this tree to generate your display of the packet data.</p>&#13;
<p class="indent">At <span class="ent">➍</span>, we set the name of the protocol in the UI column (as shown in <a href="../Text/ch05.xhtml#ch5fig11">Figure 5-11</a>) to <code>CHAT</code>. Next, we build a tree of the protocol elements <span class="ent">➎</span> we’re dissecting. Because UDP doesn’t have an explicit length field, we don’t need to take that into account; we only need to extract the checksum field. We add to the subtree using the protocol fields and use the <code>buffer</code> parameter to create a range, which takes a start index into the buffer and an optional length. If no length is specified, the rest of the buffer is used.</p>&#13;
<p class="indent">Then we register the protocol dissector with Wireshark’s UDP dissector table. (Notice that the function we defined at <span class="ent">➌</span> hasn’t actually executed yet; we’ve simply defined it.) Finally, we get the UDP table and add our <code>chat_proto</code> object to the table with port 12345 <span class="ent">➏</span>. Now we’re ready to start the dissection.</p>&#13;
<h4 class="h4" id="ch00lev1sec127"><strong><em>The Lua Dissection</em></strong></h4>&#13;
<p class="noindent">Start Wireshark using the script in <a href="../Text/ch05.xhtml#ch5list15">Listing 5-15</a> (for example, using the <code>–X</code> parameter) and then load a packet capture of the UDP traffic. You should see that the dissector has loaded and dissected the packets, as shown in <a href="../Text/ch05.xhtml#ch5fig13">Figure 5-13</a>.</p>&#13;
<p class="indent">At <span class="ent">➊</span>, the Protocol column has changed to <code>CHAT</code>. This matches the first line of our dissector function in <a href="../Text/ch05.xhtml#ch5list15">Listing 5-15</a> and makes it easier to see that we’re dealing with the correct protocol. At <span class="ent">➋</span>, the resulting tree shows the different fields of the protocol with the checksum printed in hex, as we specified. If you click the Data field in the tree, the corresponding range of bytes should be highlighted in the raw packet display at the bottom of the window <span class="ent">➌</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_100"/><img alt="image" src="../Images/f05-13.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig13"/><em>Figure 5-13: Dissected SuperFunkyChat protocol traffic</em></p>&#13;
<h4 class="h4" id="ch00lev1sec128"><strong><em>Parsing a Message Packet</em></strong></h4>&#13;
<p class="noindent">Let’s augment the dissector to parse a particular packet. We’ll use command <code>3</code> as our example because we’ve determined that it marks the sending or receiving of a message. Because a received message should show the ID of the sender as well as the message text, this packet data should contain both components; this makes it a perfect example for our purposes.</p>&#13;
<p class="indent"><a href="../Text/ch05.xhtml#ch5list16">Listing 5-16</a> shows a snippet from <a href="../Text/ch05.xhtml#ch5list10">Listing 5-10</a> when we dumped the traffic using our Python script.</p>&#13;
<pre>b'\x03bob\x0cHow are you?'<br/>b"\x03bob\x16This is nice isn't it?"</pre>&#13;
<p class="listing"><a id="ch5list16"/><em>Listing 5-16: Example message data</em></p>&#13;
<p class="indent"><a href="../Text/ch05.xhtml#ch5list16">Listing 5-16</a> shows two examples of message packet data in a binary Python string format. The <code>\x<span class="codeitalic">XX</code></span> characters are actually nonprintable bytes, so <code>\x05</code> is really the byte 0x05 and <code>\x16</code> is 0x16 (or 22 in decimal). Two printable strings are in each packet shown in the listing: the first is a username (in this case <code>bob</code>), and the second is the message. Each string is prefixed by a nonprintable character. Very simple analysis (counting characters, in this case) indicates that the nonprintable character is the length of the string that follows the character. For example, with the username string, the nonprintable character represents 0x03, and the string <code>bob</code> is three characters in length.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>Let’s write a function to parse a single string from its binary representation. We’ll update <a href="../Text/ch05.xhtml#ch5list15">Listing 5-15</a> to add support for parsing the message command in <a href="../Text/ch05.xhtml#ch5list17">Listing 5-17</a>.</p>&#13;
<p class="literal"><span class="codeitalic">dissector_with</span><br/><span class="codeitalic">_commands.lua</span></p>&#13;
<pre>   -- Declare our chat protocol for dissection<br/>   chat_proto = Proto("chat","SuperFunkyChat Protocol")<br/>   -- Specify protocol fields<br/>   chat_proto.fields.chksum = ProtoField.uint32("chat.chksum", "Checksum",<br/>                                                base.HEX)<br/>   chat_proto.fields.command = ProtoField.uint8("chat.command", "Command")<br/>   chat_proto.fields.data = ProtoField.bytes("chat.data", "Data")<br/><br/>   -- buffer: A TVB containing packet data<br/>   -- start: The offset in the TVB to read the string from<br/>   -- returns The string and the total length used<br/><span class="ent">➊</span> function read_string(buffer, start)<br/>       local len = buffer(start, 1):uint()<br/>       local str = buffer(start + 1, len):string()<br/>       return str, (1 + len)<br/>   end<br/><br/>   -- Dissector function<br/>   -- buffer: The UDP packet data as a "Testy Virtual Buffer"<br/>   -- pinfo: Packet information<br/>   -- tree: Root of the UI tree<br/>   function chat_proto.dissector(buffer, pinfo, tree)<br/>       -- Set the name in the protocol column in the UI<br/>       pinfo.cols.protocol = "CHAT"<br/><br/>       -- Create sub tree which represents the entire buffer.<br/>       local subtree = tree:add(chat_proto,<br/>                                buffer(),<br/>                                "SuperFunkyChat Protocol Data")<br/>       subtree:add(chat_proto.fields.chksum, buffer(0, 4))<br/>       subtree:add(chat_proto.fields.command, buffer(4, 1))<br/><br/>       -- Get a TVB for the data component of the packet.<br/>    <span class="ent">➋</span> local data = buffer(5):tvb()<br/>       local datatree = subtree:add(chat_proto.fields.data, data())<br/><br/>       local MESSAGE_CMD = 3<br/>    <span class="ent">➌</span> local command = buffer(4, 1):uint()<br/>       if command == MESSAGE_CMD then<br/>           local curr_ofs = 0<br/>           local str, len = read_string(data, curr_ofs)<br/>        <span class="ent">➍</span> datatree:add(chat_proto, data(curr_ofs, len), "Username: " .. str)<br/>           curr_ofs = curr_ofs + len<br/>           str, len = read_string(data, curr_ofs)<br/>           datatree:add(chat_proto, data(curr_ofs, len), "Message: " .. str)<br/>       end<br/>   end<br/><span epub:type="pagebreak" id="page_102"/><br/>   -- Get UDP dissector table and add for port 12345<br/>   udp_table = DissectorTable.get("udp.port")<br/>   udp_table:add(12345, chat_proto)</pre>&#13;
<p class="listing"><a id="ch5list17"/><em>Listing 5-17: The updated dissector script used to parse the <code><span class="codeitalic">Message</code></span> command</em></p>&#13;
<p class="indent">In <a href="../Text/ch05.xhtml#ch5list17">Listing 5-17</a>, the added <code>read_string()</code> function <span class="ent">➊</span> takes a TVB object (<code>buffer</code>) and a starting offset (<code>start</code>), and it returns the length of the buffer and then the string.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>What if the string is longer than the range of a byte value? Ah, that’s one of the challenges of protocol analysis. Just because something looks simple doesn’t mean it actually is simple. We’ll ignore issues such as the length because this is only meant as an example, and ignoring length works for any examples we’ve captured.</em></p>&#13;
</div>&#13;
<p class="indent">With a function to parse the binary strings, we can now add the <code>Message</code> command to the dissection tree. The code begins by adding the original data tree and creates a new TVB object <span class="ent">➋</span> that only contains the packet’s data. It then extracts the command field as an integer and checks whether it’s our <code>Message</code> command <span class="ent">➌</span>. If it’s not, we leave the existing data tree, but if the field matches, we proceed to parse the two strings and add them to the data subtree <span class="ent">➍</span>. However, instead of defining specific fields, we can add text nodes by specifying only the proto object rather than a field object. If you now reload this file into Wireshark, you should see that the username and message strings are parsed, as shown in <a href="../Text/ch05.xhtml#ch5fig14">Figure 5-14</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f05-14.jpg"/></div>&#13;
<p class="figcap"><a id="ch5fig14"/><em>Figure 5-14: A parsed <code><span class="codeitalic">Message</code></span> command</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Because the parsed data ends up as filterable values, we can select a <code>Message</code> command by specifying <code>chat.command == 3</code> as a display filter, as shown at <span class="ent">➊</span> in <a href="../Text/ch05.xhtml#ch5fig14">Figure 5-14</a>. We can see that the username and message strings have been parsed correctly in the tree, as shown at <span class="ent">➋</span>.</p>&#13;
<p class="indent">That concludes our quick introduction to writing a Lua dissector for Wireshark. Obviously, there is still plenty you can do with this script, including adding support for more commands, but you have enough for prototyping.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Be sure to visit the Wireshark website for more on how to write parsers, including how to implement a TCP stream parser.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec129"><strong>Using a Proxy to Actively Analyze Traffic</strong></h3>&#13;
<p class="noindent">Using a tool such as Wireshark to passively capture network traffic for later analysis of network protocols has a number of advantages over active capture (as discussed in <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>). Passive capture doesn’t affect the network operation of the applications you’re trying to analyze and requires no modifications of the applications. On the other hand, passive capture doesn’t allow you to interact easily with live traffic, which means you can’t modify traffic easily on the fly to see how applications will respond.</p>&#13;
<p class="indent">In contrast, active capture allows you to manipulate live traffic but requires more setup than passive capture. It may require you to modify applications, or at the very least to redirect application traffic through a proxy. Your choice of approach will depend on your specific scenario, and you can certainly combine passive and active capture.</p>&#13;
<p class="indent">In <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>, I included some example scripts to demonstrate capturing traffic. You can combine these scripts with the Canape Core libraries to generate a number of proxies, which you might want to use instead of passive capture.</p>&#13;
<p class="indent">Now that you have a better understanding of passive capture, I’ll spend the rest of this chapter describing techniques for implementing a proxy for the SuperFunkyChat protocol and focus on how best to use active network capture.</p>&#13;
<h4 class="h4" id="ch00lev1sec130"><strong><em>Setting Up the Proxy</em></strong></h4>&#13;
<p class="noindent">To set up the proxy, we’ll begin by modifying one of the capture examples in <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>, specifically <a href="../Text/ch02.xhtml#ch2list4">Listing 2-4</a>, so we can use it for active network protocol analysis. To simplify the development process and configuration of the SuperFunkyChat application, we’ll use a port-forwarding proxy rather than something like SOCKS.</p>&#13;
<p class="indent">Copy <a href="../Text/ch05.xhtml#ch5list18">Listing 5-18</a> into the file <code>chapter5_proxy.csx</code> and run it using Canape Core by passing the script’s filename to the <em>CANAPE.Cli</em> executable.</p>&#13;
<p class="literal"><span epub:type="pagebreak" id="page_104"/><span class="codeitalic">chapter5</span><br/><span class="codeitalic">_proxy.csx</span></p>&#13;
<pre>   using static System.Console;<br/>   using static CANAPE.Cli.ConsoleUtils;<br/><br/>   var template = new FixedProxyTemplate();<br/>   // Local port of 4444, destination 127.0.0.1:12345<br/><span class="ent">➊</span> template.LocalPort = 4444;<br/>   template.Host = "127.0.0.1";<br/>   template.Port = 12345;<br/><br/>   var service = template.Create();<br/>   // Add an event handler to log a packet. Just print to console.<br/><span class="ent">➋</span> service.LogPacketEvent += (s,e) =&gt; WritePacket(e.Packet);<br/>   // Print to console when a connection is created or closed.<br/><span class="ent">➌</span> service.NewConnectionEvent += (s,e) =&gt;<br/>            WriteLine("New Connection: {0}", e.Description);<br/>   service.CloseConnectionEvent += (s,e) =&gt;<br/>            WriteLine("Closed Connection: {0}", e.Description);<br/>   service.Start();<br/><br/>   WriteLine("Created {0}", service);<br/>   WriteLine("Press Enter to exit...");<br/>   ReadLine();<br/>   service.Stop();</pre>&#13;
<p class="listing"><a id="ch5list18"/><em>Listing 5-18: The active analysis proxy</em></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we tell the proxy to listen locally on port 4444 and make a proxy connection to 127.0.0.1 port 12345. This should be fine for testing the chat application, but if you want to reuse the script for another application protocol, you’ll need to change the port and IP address as appropriate.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we make one of the major changes to the script in <a href="../Text/ch02.xhtml#ch02">Chapter 2</a>: we add an event handler that is called whenever a packet needs to be logged, which allows us to print the packet as soon it arrives. At <span class="ent">➌</span>, we add some event handlers to print when a new connection is created and then closed.</p>&#13;
<p class="indent">Next, we reconfigure the ChatClient application to communicate with local port 4444 instead of the original port 12345. In the case of ChatClient, we simply add the <code>--port NUM</code> parameter to the command line as shown here:</p>&#13;
<pre>ChatClient.exe --port 4444 user1 127.0.0.1</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Changing the destination in real-world applications may not be so simple. Review <a href="../Text/ch02.xhtml#ch02">Chapters 2</a> and <a href="../Text/ch04.xhtml#ch04">4</a> for ideas on how to redirect an arbitrary application into your proxy.</em></p>&#13;
</div>&#13;
<p class="indent">The client should successfully connect to the server via the proxy, and the proxy’s console should begin displaying packets, as shown in Listing 5-19.</p>&#13;
<pre>   CANAPE.Cli (c) 2017 James Forshaw, 2014 Context Information Security.<br/>   Created Listener (TCP 127.0.0.1:4444), Server (Fixed Proxy Server)<br/>   Press Enter to exit...<br/><span class="ent"><span epub:type="pagebreak" id="page_105"/>➊</span> New Connection: 127.0.0.1:50844 &lt;=&gt; 127.0.0.1:12345<br/>   Tag 'Out'<span class="ent">➋</span> – Network '127.0.0.1:50844 &lt;=&gt; 127.0.0.1:12345'<span class="ent">➌</span><br/>           : 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F - 0123456789ABCDEF<br/>   --------:-------------------------------------------------------------------<br/>   00000000: 42 49 4E 58 00 00 00 0E 00 00 04 16 00 05 75 73 - BINX..........us<br/>   00000010: 65 72 31 05 62 6F 72 61 78 00                   - er1.borax.<br/><br/>   Tag 'In'<span class="ent">➍</span> - Network '127.0.0.1:50844 &lt;=&gt; 127.0.0.1:12345'<br/>           : 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F - 0123456789ABCDEF<br/>   --------:-------------------------------------------------------------------<br/>   00000000: 00 00 00 02 00 00 00 01 01 00                   - ..........<br/><br/>   PM - Tag 'Out' - Network '127.0.0.1:50844 &lt;=&gt; 127.0.0.1:12345'<br/>           : 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F - 0123456789ABCDEF<br/>   --------:-------------------------------------------------------------------<br/><span class="ent">➎</span> 00000000: 00 00 00 0D                                    - ....<br/><br/>   Tag 'Out' - Network '127.0.0.1:50844 &lt;=&gt; 127.0.0.1:12345'<br/>           : 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F - 0123456789ABCDEF<br/>   --------:-------------------------------------------------------------------<br/>   00000000: 00 00 04 11 03 05 75 73 65 72 31 05 68 65 6C 6C - ......user1.hell<br/>   00000010: 6F                                              - o<br/><br/>   --<span class="codeitalic">snip</span>--<br/><span class="ent">➏</span> Closed Connection: 127.0.0.1:50844 &lt;=&gt; 127.0.0.1:12345</pre>&#13;
<p class="listing"><a id="ch5list19"/><em>Listing 5-19: Example output from proxy when a client connects</em></p>&#13;
<p class="indent">Output indicating that a new proxy connection has been made is shown at <span class="ent">➊</span>. Each packet is displayed with a header containing information about its direction (outbound or inbound), using the descriptive tags <code>Out</code> <span class="ent">➋</span> and <code>In</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">If your terminal supports 24-bit color, as do most Linux, macOS, and even Windows 10 terminals, you can enable color support in Canape Core using the <code>--color</code> parameter when starting a proxy script. The colors assigned to inbound packets are similar to those in Wireshark: pink for outbound and blue for inbound. The packet display also shows which proxy connection it came from <span class="ent">➌</span>, matching up with the output at <span class="ent">➊</span>. Multiple connections could occur at the same time, especially if you’re proxying a complex application.</p>&#13;
<p class="indent">Each packet is dumped in hex and ASCII format. As with capture in Wireshark, the traffic might be split between packets as in <span class="ent">➎</span>. However, unlike with Wireshark, when using a proxy, we don’t need to deal with network effects such as retransmitted packets or fragmentation: we simply access the raw TCP stream data after the operating system has dealt with all the network effects for us.</p>&#13;
<p class="indent">At <span class="ent">➏</span>, the proxy prints that the connection is closed.</p>&#13;
<h4 class="h4" id="ch00lev1sec131"><strong><em>Protocol Analysis Using a Proxy</em></strong></h4>&#13;
<p class="noindent">With our proxy set up, we can begin the basic analysis of the protocol. The packets shown in <a href="../Text/ch05.xhtml#ch5list19">Listing 5-19</a> are simply the raw data, but we should ideally write code to parse the traffic as we did with the Python script we wrote for <span epub:type="pagebreak" id="page_106"/>Wireshark. To that end, we’ll write a <code>Data Parser</code> class containing functions to read and write data to and from the network. Copy <a href="../Text/ch05.xhtml#ch5list20">Listing 5-20</a> into a new file in the same directory as you copied <em>chapter5_proxy.csx</em> in Listing 5-18 and call it <em>parser.csx</em>.</p>&#13;
<p class="literal"><span class="codeitalic">parser.csx</span></p>&#13;
<pre>using CANAPE.Net.Layers;<br/>using System.IO;<br/><br/>class Parser : DataParserNetworkLayer<br/>{<br/>    <span class="ent">➊</span> protected override bool NegotiateProtocol(<br/>           Stream serverStream, Stream clientStream)<br/>    {<br/>     <span class="ent">➋</span> var client = new DataReader(clientStream);<br/>        var server = new DataWriter(serverStream);<br/><br/>        // Read magic from client and write it to server.<br/>     <span class="ent">➌</span> uint magic = client.ReadUInt32();<br/>        Console.WriteLine("Magic: {0:X}", magic);<br/>        server.WriteUInt32(magic);<br/><br/>        // Return true to signal negotiation was successful.<br/>        return true;<br/>    }<br/>}</pre>&#13;
<p class="listing"><a id="ch5list20"/><em>Listing 5-20: A basic parser code for proxy</em></p>&#13;
<p class="indent">The negotiation method <span class="ent">➊</span> is called before any other communication takes place and is passed to two C# stream objects: one connected to the Chat Server and the other to the Chat Client. We can use this negotiation method to handle the magic value the protocol uses, but we could also use it for more complex tasks, such as enabling encryption if the protocol supports it.</p>&#13;
<p class="indent">The first task for the negotiation method is to read the magic value from the client and pass it to the server. To simply read and write the 4-byte magic value, we first wrap the streams in <code>DataReader</code> and <code>DataWriter</code> classes <span class="ent">➋</span>. We then read the magic value from the client, print it to the console, and write it to the server <span class="ent">➌</span>.</p>&#13;
<p class="indent">Add the line <code>#load "parser.csx"</code> to the very top of <em>chapter5_proxy.csx</em>. Now when the main <em>chapter5_proxy.csx</em> script is parsed, the <em>parser.csx</em> file is automatically included and parsed with the main script. Using this loading feature allows you to write each component of your parser in a separate file to make the task of writing a complex proxy manageable. Then add the line <code>template.AddLayer&lt;Parser&gt;();</code> just after <code>template.Port = 12345;</code> to add the parsing layer to every new connection. This addition will instantiate a new instance of the <code>Parser</code> class in <a href="../Text/ch05.xhtml#ch5list20">Listing 5-20</a> with every connection so you can store any state you need as members of the class. If you start the proxy script and connect a client through the proxy, only important protocol data is logged; you’ll no longer see the magic value (other than in the console output).</p>&#13;
<h4 class="h4" id="ch00lev1sec132"><span epub:type="pagebreak" id="page_107"/><strong><em>Adding Basic Protocol Parsing</em></strong></h4>&#13;
<p class="noindent">Now we’ll reframe the network protocol to ensure that each packet contains only the data for a single packet. We’ll do this by adding functions to read the length and checksum fields from the network and leave only the data. At the same time, we’ll rewrite the length and checksum when sending the data to the original recipient to keep the connection open.</p>&#13;
<p class="indent">By implementing this basic parsing and proxying of a client connection, all nonessential information, such as lengths and checksums, should be removed from the data. As an added bonus, if you modify data inside the proxy, the sent packet will have the correct checksum and length to match your modifications. Add <a href="../Text/ch05.xhtml#ch5list21">Listing 5-21</a> to the <code>Parser</code> class to implement these changes and restart the proxy.</p>&#13;
<pre><span class="ent">➊</span> int CalcChecksum(byte[] data) {<br/>       int chksum = 0;<br/>       foreach(byte b in data) {<br/>           chksum += b;<br/>       }<br/>       return chksum;<br/>   }<br/><br/><span class="ent">➋</span> DataFrame ReadData(DataReader reader) {<br/>       int length = reader.ReadInt32();<br/>       int chksum = reader.ReadInt32();<br/>       return reader.ReadBytes(length).ToDataFrame();<br/>   }<br/><br/><span class="ent">➌</span> void WriteData(DataFrame frame, DataWriter writer) {<br/>       byte[] data = frame.ToArray();<br/>       writer.WriteInt32(data.Length);<br/>       writer.WriteInt32(CalcChecksum(data));<br/>       writer.WriteBytes(data);<br/>   }<br/><br/><span class="ent">➍</span> protected override DataFrame ReadInbound(DataReader reader) {<br/>       return ReadData(reader);<br/>   }<br/><br/>   protected override void WriteOutbound(DataFrame frame, DataWriter writer) {<br/>       WriteData(frame, writer);<br/>   }<br/><br/>   protected override DataFrame ReadOutbound(DataReader reader) {<br/>       return ReadData(reader);<br/>   }<br/><br/>   protected override void WriteInbound(DataFrame frame, DataWriter writer) {<br/>       WriteData(frame, writer);<br/>   }</pre>&#13;
<p class="listing"><a id="ch5list21"/><em>Listing 5-21: Parser code for SuperFunkyChat protocol</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_108"/>Although the code is a bit verbose (blame C# for that), it should be fairly simple to understand. At <span class="ent">➊</span>, we implement the checksum calculator. We could check packets we read to verify their checksums, but we’ll only use this calculator to recalculate the checksum when sending the packet onward.</p>&#13;
<p class="indent">The <code>ReadData()</code> function at <span class="ent">➋</span> reads a packet from the network connection. It first reads a big endian 32-bit integer, which is the length, then the 32-bit checksum, and finally the data as bytes before calling a function to convert that byte array to a <code>DataFrame</code>. (A <code>DataFrame</code> is an object to contain network packets; you can convert a byte array or a string to a frame depending on what you need.)</p>&#13;
<p class="indent">The <code>WriteData()</code> function at <span class="ent">➌</span> does the reverse of <code>ReadData()</code>. It uses the <code>ToArray()</code> method on the incoming <code>DataFrame</code> to convert the packet to bytes for writing. Once we have the byte array, we can recalculate the checksum and the length, and then write it all back to the <code>DataWriter</code> class. At <span class="ent">➍</span>, we implement the various functions to read and write data from the inbound and outbound streams.</p>&#13;
<p class="indent">Put together all the different scripts for network proxy and parsing and start a client connection through the proxy, and all nonessential information, such as lengths and checksums, should be removed from the data. As an added bonus, if you modify data inside the proxy, the sent packet will have the correct checksum and length to match your modifications.</p>&#13;
<h4 class="h4" id="ch00lev1sec133"><strong><em>Changing Protocol Behavior</em></strong></h4>&#13;
<p class="noindent">Protocols often include a number of optional components, such as encryption or compression. Unfortunately, it’s not easy to determine how that encryption or compression is implemented without doing a lot of reverse engineering. For basic analysis, it would be nice to be able to simply remove the component. Also, if the encryption or compression is optional, the protocol will almost certainly indicate support for it while negotiating the initial connection. So, if we can modify the traffic, we might be able to change that support setting and disable that additional feature. Although this is a trivial example, it demonstrates the power of using a proxy instead of passive analysis with a tool like Wireshark. We can modify the connection to make analysis easier.</p>&#13;
<p class="indent">For example, consider the chat application. One of its optional features is XOR encryption (although see <a href="../Text/ch07.xhtml#ch07">Chapter 7</a> on why it’s not really encryption). To enable this feature, you would pass the <code>--xor</code> parameter to the client. <a href="../Text/ch05.xhtml#ch5list22">Listing 5-22</a> compares the first couple of packets for the connection without the XOR parameter and then with the XOR parameter.</p>&#13;
<pre>OUTBOUND XOR   :    00 05 75 73 65 72 32 04 4F 4E 59 58 <span class="codestrong">01</span>     - ..user2.ONYX.<br/>OUTBOUND NO XOR:    00 05 75 73 65 72 32 04 4F 4E 59 58 <span class="codestrong">00</span>     - ..user2.ONYX.<br/><br/>INBOUND XOR   :     01 <span class="codestrong">E7</span>                                      - ..<br/>INBOUND NO XOR:     01 <span class="codestrong">00</span>                                      - ..</pre>&#13;
<p class="listing"><a id="ch5list22"/><em>Listing 5-22: Example packets with and without XOR encryption enabled</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>I’ve highlighted in bold two differences in <a href="../Text/ch05.xhtml#ch5list22">Listing 5-22</a>. Let’s draw some conclusions from this example. In the outbound packet (which is command 0 based on the first byte), the final byte is a 1 when XOR is enabled but 0x00 when it’s not enabled. My guess would be that this flag indicates that the client supports XOR encryption. For inbound traffic, the final byte of the first packet (command 1 in this case) is 0xE7 when XOR is enabled and 0x00 when it’s not. My guess would be that this is a key for the XOR encryption.</p>&#13;
<p class="indent">In fact, if you look at the client console when you’re enabling XOR encryption, you’ll see the line <code>ReKeying connection to key 0xE7</code>, which indicates it is indeed the key. Although the negotiation is valid traffic, if you now try to send a message with the client through the proxy, the connection will no longer work and may even be disconnected. The connection stops working because the proxy will try to parse fields, such as the length of the packet, from the connection but will get invalid values. For example, when reading a length, such as 0x10, the proxy will instead read 0x10 XOR 0xE7, which is 0xF7. Because there are no 0xF7 bytes on the network connection, it will hang. The short explanation is that to continue the analysis in this situation, we need to do something about the XOR.</p>&#13;
<p class="indent">While implementing the code to de-XOR the traffic when we read it and re-XOR it again when we write it wouldn’t be especially difficult, it might not be so simple to do if this feature were implemented to support some proprietary compression scheme. Therefore, we’ll simply disable XOR encryption in our proxy irrespective of the client’s setting. To do so, we read the first packet in the connection and ensure that the final byte is set to 0. When we forward that packet onward, the server will not enable XOR and will return the value of 0 as the key. Because 0 is a NO-OP in XOR encryption (as in A XOR 0 = A), this technique will effectively disable the XOR.</p>&#13;
<p class="indent">Change the <code>ReadOutbound()</code> method in the parser to the code in Listing 5-23 to disable the XOR encryption.</p>&#13;
<pre>protected override DataFrame ReadOutbound(DataReader reader) {<br/>  DataFrame frame = ReadData(reader);<br/>  // Convert frame back to bytes.<br/>  byte[] data = frame.ToArray();<br/>  if (data[0] == 0) {<br/>    Console.WriteLine("Disabling XOR Encryption");<br/>    data[data.Length - 1] = 0;<br/>    frame = data.ToDataFrame();<br/>  }<br/>  return frame;<br/>}</pre>&#13;
<p class="listing"><a id="ch5list23"/><em>Listing 5-23: Disable XOR encryption</em></p>&#13;
<p class="indent">If you now create a connection through the proxy, you’ll find that regardless of whether the XOR setting is enabled or not, the client will not be able to enable XOR.</p>&#13;
<h3 class="h3" id="ch00lev1sec134"><span epub:type="pagebreak" id="page_110"/><strong>Final Words</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to perform basic protocol analysis on an unknown protocol using passive and active capture techniques. We started by doing basic protocol analysis using Wireshark to capture example traffic. Then, through manual inspection and a simple Python script, we were able to understand some parts of an example chat protocol.</p>&#13;
<p class="indent">We discovered in the initial analysis that we were able to implement a basic Lua dissector for Wireshark to extract protocol information and display it directly in the Wireshark GUI. Using Lua is ideal for prototyping protocol analysis tools in Wireshark.</p>&#13;
<p class="indent">Finally, we implemented a man-in-the-middle proxy to analyze the protocol. Proxying the traffic allows demonstration of a few new analysis techniques, such as modifying protocol traffic to disable protocol features (such as encryption) that might hinder the analysis of the protocol using purely passive techniques.</p>&#13;
<p class="indent">The technique you choose will depend on many factors, such as the difficulty of capturing the network traffic and the complexity of the protocol. You’ll want to apply the most appropriate combination of techniques to fully analyze an unknown protocol.</p>&#13;
</body></html>