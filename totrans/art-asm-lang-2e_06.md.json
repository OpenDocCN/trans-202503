["```\naLabel:\n```", "```\nprogram labelDemo;\n#include( \"stdlib.hhf\" );\n\nbegin labelDemo;\n\n    lbl1:\n\n        lea( ebx, lbl1 );\n        mov( &lbl2, eax );\n        stdout.put( \"&lbl1=$\", ebx, \" &lbl2=\", eax, nl );\n     lbl2:\n\nend labelDemo;\n```", "```\nprogram labelArrays;\n#include( \"stdlib.hhf\" );\n\nstatic\n    labels:dword[2] := [ &lbl1, &lbl2 ];\n\n    procedure hasLabels;\n    static\n        stmtLbls: dword[2] := [ &label1, &label2 ];\n\n    begin hasLabels;\n\n        label1:\n\n            stdout.put\n            (\n                \"stmtLbls[0]= $\", stmtLbls[0], nl,\n                \"stmtLbls[1]= $\", stmtLbls[4], nl\n            );\n\n        label2:\n\n    end hasLabels;\n\nbegin labelArrays;\n\n    hasLabels();\n    lbl1:\n\n        stdout.put( \"labels[0]= $\", labels[0], \" labels[1]=\", labels[4], nl );\n\n    lbl2:\n\nend labelArrays;\n```", "```\njmp *`label`*;\n     jmp( *`reg32`* );\n     jmp( *`mem32`* );\n```", "```\n<< statements >>\n          jmp laterInPgm;\n               .\n               .\n               .\nlaterInPgm:\n          << statements >>\n```", "```\nprogram regIndJmp;\n#include( \"stdlib.hhf\" );\n\nstatic\n    i:int32;\n\nbegin regIndJmp;\n\n    // Read an integer from the user and set ebx to\n    // denote the success or failure of the input.\n\n    try\n\n        stdout.put( \"Enter an integer value between 1 and 10: \" );\n        stdin.get( i );\n        mov( i, eax );\n        if( eax in 1..10 ) then\n\n            mov( &GoodInput, ebx );\n\n        else\n\n            mov( &valRange, ebx );\n\n        endif;\n\n      exception( ex.ConversionError )\n\n        mov( &convError, ebx );\n\n      exception( ex.ValueOutOfRange )\n\n        mov( &valRange, ebx );\n\n    endtry;\n\n    // Okay, transfer control to the appropriate\n    // section of the program that deals with\n    // the input.\n\n    jmp( ebx );\n\n    valRange:\n        stdout.put( \"You entered a value outside the range 1..10\" nl );\n        jmp Done;\n\n    convError:\n        stdout.put( \"Your input contained illegal characters\" nl );\n        jmp Done;\n\n    GoodInput:\n        stdout.put( \"You entered the value \", i, nl );\n\n    Done:\n\nend regIndJmp;\n```", "```\nprogram memIndJmp;\n#include( \"stdlib.hhf\" );\n\nstatic\n    LabelPtr:dword := &stmtLabel;\n\nbegin memIndJmp;\n\n    stdout.put( \"Before the JMP instruction\" nl );\n    jmp( LabelPtr );\n\n        stdout.put( \"This should not execute\" nl );\n\n    stmtLabel:\n\n        stdout.put( \"After the LabelPtr label in the program\" nl );\n\nend memIndJmp;\n```", "```\nj*`cc label`*;\n```", "```\njs ValueIsNegative;\n```", "```\ncmp( bx, cx );\n          jne SkipStmts;\n          inc( ax );\nSkipStmts:\n```", "```\nmov( 0, edi );\nRdLnLoop:\n          stdin.getc();              // Read a character into the al register.\n          mov( al, Input[ edi ] );   // Store away the character.\n          inc( edi );                // Move on to the next character.\n          cmp( al, stdio.cr );       // See if the user pressed Enter.\n          jne RdLnLoop;\n```", "```\njt( *`boolean_expression`* ) *`target_label`*;\njf( *`boolean_expression`* ) *`target_label`*;\n```", "```\nif( *`expression`* ) then\n          << statements >>\n     endif;\n```", "```\nif( (( x < y ) && ( z > t )) || ( a != b ) )\n          stmt1;\n```", "```\nmov( x, eax );\n          cmp( eax, y );\n          setl( bl );       // Store x<y in bl.\n          mov( z, eax );\n          cmp( eax, t );\n          setg( bh );       // Store z>t in bh.\n          and( bh, bl );    // Put (x<y) && (z>t) into bl.\n          mov( a, eax );\n          cmp( eax, b );\n          setne( bh );      // Store a != b into bh.\n          or( bh, bl );     // Put (x<y) && (z>t) || (a!=b) into bl\n          je SkipStmt1;     // Branch if result is false.\n\n     << Code for Stmt1 goes here. >>\n\nSkipStmt1:\n```", "```\nbl = x < y;\n          bh = z > t;\n          bl = bl && bh;\n          bh = a != b;\n          bl = bl || bh;\n          if( bl )\n               << Stmt1 >>;\n```", "```\nmov( a, eax );\n          cmp( eax, b );\n          jne DoStmt;\n          mov( x, eax );\n          cmp( eax, y );\n          jnl SkipStmt;\n          mov( z, eax );\n          cmp( eax, t );\n          jng SkipStmt;\nDoStmt:\n          << Place code for Stmt1 here. >>\nSkipStmt:\n```", "```\n<< Sequence of statements to test some condition >>\n          j*`cc`* ElseCode;\n    << Sequence of statements corresponding to the THEN block >>\n\n          jmp EndOfIf;\n\nElseCode:\n    << Sequence of statements corresponding to the ELSE block >>\n\nEndOfIf:\n```", "```\nif( a == b )\n          c = d;\n     else\n          b = b + 1;\n```", "```\nmov( a, eax );\n          cmp( eax, b );\n          jne ElsePart;\n          mov( d, c );\n          jmp EndOfIf;\n\nElseBlk:\n          inc( b );\n\nEndOfIf:\n```", "```\nif( (( x > y ) && ( z < t )) || ( a != b ) )\n          c = d;\n```", "```\nif( a != b ) c = d;\n     else if( x > y)\n          if( z < t )\n               c = d;\n```", "```\nif( *`expr1`* && *`expr2`* ) *`stmt`*;\n```", "```\nif( *`expr1`* ) if( *`expr2`* ) *`stmt`*;\n```", "```\nif( *`expr1`* || *`expr2`* ) *`stmt`*;\n```", "```\nif( *`expr1`* ) *`stmt`*;\nelse if( *`expr2`* ) *`stmt`*;\n```", "```\n// if( (( x > y ) && ( z < t )) || ( a != b ) )\n//      c = d;\n\n          mov( a, eax );\n          cmp( eax, b );\n          jne DoIF;\n          mov( x, eax );\n          cmp( eax, y );\n          jng EndOfIF;\n          mov( z, eax );\n          cmp( eax, t );\n          jnl EndOfIf;\nDoIf:\n          mov( d, eax );\n          mov( eax, c );\nEndOfIf:\n```", "```\n// if ((x > y) && (z < t)) or (a != b)  c = d;\n// Implemented as:\n// if (a != b) then goto DoIf;\n\n          mov( a, eax );\n          cmp( eax, b );\n          jne DoIf;\n\n// if not (x > t) then goto EndOfIf;\n\n          mov( x, eax );\n          cmp( eax, y );\n          jng EndOfIf;\n\n// if not (z < t) then goto EndOfIf;\n\n          mov( z, eax );\n          cmp( eax, t );\n          jnl EndOfIf;\n\n// then block:\n\nDoIf:\n          mov( d, eax );\n          mov( eax, c );\n\n// End of if statement\n\nEndOfIf:\n```", "```\n// if ( (( x > y ) && ( z < t )) || ( a != b ) )  c = d;\n// Test the boolean expression:\n\n          mov( a, eax );\n          cmp( eax, b );\n          jne DoIf;\n          mov( x, eax );\n          cmp( eax, y );\n          jng EndOfIf;\n          mov( z, eax );\n          cmp( eax, t );\n          jnl EndOfIf;\n\n// then block:\n\nDoIf:\n          mov( d, eax );\n          mov( eax, c );\n\n// End of if statement\n\nEndOfIf:\n```", "```\n// if( @c ) then inc( eax );  endif;\n\n          jnc SkipTheInc;\n\n               inc( eax );\n\n          SkipTheInc:\n\n// if( @ns ) then neg( eax ); endif;\n\n          js SkipTheNeg;\n\n               neg( eax );\n\n          SkipTheNeg:\n```", "```\n// if( eax ) then mov( false, eax );  endif;\n\n          test( eax, eax );\n          jz DontSetFalse;\n\n               mov( false, eax );\n\n          DontSetFalse:\n\n// if( al ) then mov( bl, cl );  endif;\n\n          test( al, al );\n          jz noMove;\n\n               mov( bl, cl );\n\n          noMove:\n```", "```\n// if( bool ) then mov( 0, al );  endif;\n\n          cmp( bool, false );\n          je SkipZeroAL;\n\n               mov( 0, al );\n\n          SkipZeroAL:\n```", "```\n// if( !bool ) then mov( 0, al );  endif;\n\n          cmp( bool, false );\n          jne SkipZeroAL;\n\n               mov( 0, al );\n\n          SkipZeroAL:\n```", "```\n// if( al == ch ) then inc( cl ); endif;\n\n          cmp( al, ch );\n          jne SkipIncCL;\n\n               inc( cl );\n\n          SkipIncCL:\n\n// if( ch >= 'a' ) then and( $5f, ch ); endif;\n\n          cmp( ch, 'a' );\n          jnae NotLowerCase\n\n               and( $5f, ch );\n\n          NotLowerCase:\n\n// if( (type int32 eax ) < −5 ) then mov( −5, eax );  endif;\n\n          cmp( eax, −5 );\n          jnl DontClipEAX;\n\n               mov( −5, eax );\n\n          DontClipEAX:\n\n// if( si <> di ) then inc( si );  endif;\n\n          cmp( si, di );\n          je DontIncSI;\n\n               inc( si );\n\n          DontIncSI:\n```", "```\n// if( eax in 1000..125_000 ) then sub( 1000, eax );  endif;\n\n          cmp( eax, 1000 );\n          jb DontSub1000;\n          cmp( eax, 125_000 );\n          ja DontSub1000;\n\n               sub( 1000, eax );\n\n          DontSub1000:\n\n// if( i32 in −5..5 ) then add( 5, i32 ); endif;\n\n          cmp( i32, −5 );\n          jl NoAdd5;\n          cmp( i32, 5 );\n          jg NoAdd5;\n\n               add(5, i32 );\n\n          NoAdd5:\n```", "```\n// if( eax not in 1000..125_000 ) then add( 1000, eax );  endif;\n\n          cmp( eax, 1000 );\n          jb Add1000;\n          cmp( eax, 125_000 );\n          jbe SkipAdd1000;\n\n               Add1000:\n               add( 1000, eax );\n\n          SkipAdd1000:\n\n// if( i32 not in −5..5 ) then mov( 0, i32 );  endif;\n\n          cmp( i32, −5 );\n          jl Zeroi32;\n          cmp( i32, 5 );\n          jle SkipZero;\n\n               Zeroi32:\n               mov( 0, i32 );\n\n          SkipZero:\n```", "```\n//     if( (( x < y ) && ( z > t )) || ( a != b ) )\n//         << Stmt1 >>;\n\n          mov( x, eax );\n          cmp( eax, y );\n          setl( bl );     // Store x<y in bl.\n          mov( z, eax );\n          cmp( eax, t );\n          setg( bh );     // Store z>t in bh.\n          and( bh, bl );  // Put (x<y) && (z>t) into bl.\n          mov( a, eax );\n          cmp( eax, b );\n          setne( bh );    // Store a != b into bh.\n          or( bh, bl );   // Put (x<y) && (z>t) || (a != b) into bl.\n          je SkipStmt1;   // Branch if result is false.\n\n     << Code for Stmt1 goes here. >>\n\nSkipStmt1:\n```", "```\n// if( (x<y) && (z>t) ) then ...\n\n          mov( x, eax );\n          cmp( eax, y );\n          jnl TestFails;\n          mov( z, eax );\n          cmp( eax, t );\n          jng TestFails;\n\n               << Code for THEN clause of IF statement >>\n\n          TestFails:\n```", "```\n// if( ch < 'A' || ch > 'Z' )\n//     then stdout.put( \"Not an uppercase char\" );\n// endif;\n\n          cmp( ch, 'A' );\n          jb ItsNotUC\n          cmp( ch, 'Z' );\n          jna ItWasUC;\n\n               ItsNotUC:\n               stdout.put( \"Not an uppercase char\" );\n\n          ItWasUC:\n```", "```\n// if( (( x < y ) && ( z > t )) || ( a != b ) ) << Stmt1 >>;\n\n          mov( a, eax );\n          cmp( eax, b );\n          jne DoStmt1;\n          mov( x, eax );\n          cmp( eax, y );\n          jnl SkipStmt1;\n          mov( z, eax );\n          cmp( eax, t );\njng SkipStmt1;\n\n               DoStmt1:\n               << Code for Stmt1 goes here. >>\n\n          SkipStmt1:\n```", "```\nif( ( x == y ) && ( ++z != 0 )) << Stmt >>;\n```", "```\nmov( x, eax );      // See if x == y.\n          cmp( eax, y );\n          sete( bl );\n          inc( z );           // ++z\n          cmp( z, 0 );        // See if incremented z is 0.\n          setne( bh );\n          and( bh, bl );      // Test x == y && ++z != 0.\n          jz SkipStmt;\n\n          << Code for Stmt goes here. >>\n\nSkipStmt:\n```", "```\nmov( x, eax );      // See if x == y.\n          cmp( eax, y );\n          jne SkipStmt;\n          inc( z );           // ++z\n          cmp( z, 0 );        // See if incremented z is 0.\n          je SkipStmt;\n\n          << Code for Stmt goes here. >>\n\nSkipStmt:\n```", "```\nif( Ptr != NULL && *Ptr == 'a' ) << Stmt >>;\n```", "```\n// Complete boolean evaluation:\n\n          mov( Ptr, eax );\n          test( eax, eax );    // Check to see if eax is 0 (NULL is 0).\n          setne( bl );\n          mov( [eax], al );    // Get *Ptr into al.\n          cmp( al, 'a' );\n          sete( bh );\n          and( bh, bl );\n          jz SkipStmt;\n\n          << Code for Stmt goes here. >>\n\nSkipStmt:\n```", "```\n// Short-circuit boolean evaluation\n\n          mov( Ptr, eax );     // See if Ptr contains NULL (0) and\n          test( eax, eax );    // immediately skip past Stmt if this\n          jz SkipStmt;         // is the case.\n\n          mov( [eax], al );    // If we get to this point, Ptr contains\n          cmp( al, 'a' );      // a non-NULL value, so see if it points\n          jne SkipStmt;        // at the character 'a'.\n\n          << Code for Stmt goes here. >>\n\nSkipStmt:\n```", "```\nif(( a == b ) && ( c < d )) ++i;\n```", "```\nmov( a, eax );\n          cmp( eax, b );\n          jne DontIncI;\n\n          mov( c, eax );\n          cmp( eax, d );\n          jnl DontIncI;\n\n               inc( i );\n\n          DontIncI:\n```", "```\nmov( c, eax );\n          cmp( eax, d );\n          jnl DontIncI;\n\n          mov( a, eax );\n          cmp( eax, b );\n          jne DontIncI;\n\n               inc( i );\n\n          DontIncI:\n```", "```\nif( (x % 10 = 0 ) && (x != y ) ++x;\n```", "```\nmov( x, eax );            // Compute X % 10.\n          cdq();                    // Must sign extend eax -> edx:eax.\n          imod( 10, edx:eax );      // Remember, remainder goes into edx.\n          test( edx, edx );         // See if edx is 0.\n          jnz SkipIf;\n\n          mov( x, eax );\n          cmp( eax, y );\n          je SkipIf;\n\n               inc( x );\n\n          SkipIf:\n```", "```\nmov( x, eax );\n          cmp( eax, y );\n          je SkipIf;\n\n          mov( x, eax );            // Compute X % 10.\n          cdq();                    // Must sign extend eax -> edx:eax.\n          imod( 10, edx:eax );      // Remember, remainder goes into edx.\n          test( edx, edx );         // See if edx is 0.\n          jnz SkipIf;\n\n               inc( x );\n\n          SkipIf:\n```", "```\nif( See_If_an_Error_Has_Occurred )\n     {\n          << Statements to execute if no error >>\n     }\n     else\n     {\n          << Error handling statements >>\n     }\n```", "```\ncmp( See_If_an_Error_Has_Occurred, true );\n     je HandleTheError;\n\n          << Statements to execute if no error >>\n          jmp EndOfIF;\n\n     HandleTheError:\n          << Error handling statements >>\n     EndOfIf:\n```", "```\ncmp( See_If_an_Error_Has_Occurred, true );\n     je HandleTheError;\n\n          << Statements to execute if no error >>\n\n     EndOfIf:\n```", "```\nHandleTheError:\n          << Error handling statements >>\n          jmp EndOfIf;\n```", "```\ntest( eax, eax );\n          jns ItsPositive;\n\n               neg( eax );\n\n          ItsPositive:\n```", "```\n// Set edx to $FFFF_FFFF if eax is negative, $0000_0000 if eax is\n// 0 or positive:\n\n          cdq();\n\n// If eax was negative, the following code inverts all the bits in eax;\n// otherwise it has no effect on eax.\n\n          xor( edx, eax );\n\n// If eax was negative, the following code adds 1 to eax; otherwise\n// it doesn't modify eax's value.\n\n          and( 1, edx );      // edx = 0 or 1 (1 if eax was negative).\n          add( edx, eax );\n```", "```\nswitch( *`reg32`* )\n          case( *`const1`* )\n               << Stmts1: code to execute if *`reg32`* equals *`const1`* >>\n\n          case( *`const2`* )\n               << Stmts2: code to execute if *`reg32`* equals *`const2`* >>\n            .\n            .\n            .\n          case( *`constn`* )\n               << Stmtsn: code to execute if *`reg32`* equals *`constn`* >>\n\n          default      // Note that the default section is optional.\n               << Stmts_default: code to execute if *`reg32`*\n                  does not equal any of the case values >>\n\n     endswitch;\n```", "```\nswitch( eax )\n          case(0) stdout.put(\"i=0\");\n          case(1) stdout.put(\"i=1\");\n          case(2) stdout.put(\"i=2\");\n     endswitch;\n\n     if( eax = 0 ) then\n          stdout.put(\"i=0\")\n     elseif( eax = 1 ) then\n          stdout.put(\"i=1\")\n     elseif( eax = 2 ) then\n          stdout.put(\"i=2\");\n     endif;\n```", "```\n// if..then..else..endif form:\n\n          mov( i, eax );\n          test( eax, eax );   // Check for 0.\n          jnz Not0;\n               stdout.put( \"i=0\" );\n               jmp EndCase;\n\n          Not0:\n          cmp( eax, 1 );\n          jne Not1;\n               stdou.put( \"i=1\" );\n               jmp EndCase;\n\n          Not1:\n          cmp( eax, 2 );\n          jne EndCase;\n               stdout.put( \"i=2\" );\n     EndCase:\n\n// Indirect Jump Version\n\nreadonly\n     JmpTbl:dword[3] := [ &Stmt0, &Stmt1, &Stmt2 ];\n           .\n           .\n           .\n     mov( i, eax );\n     jmp( JmpTbl[ eax*4 ] );\n\n          Stmt0:\n               stdout.put( \"i=0\" );\n               jmp EndCase;\n\n          Stmt1:\n               stdout.put( \"I=1\" );\n               jmp EndCase;\n\n          Stmt2:\n               stdout.put( \"I=2\" );\n\n     EndCase:\n```", "```\nreadonly\n     JmpTbl:dword[3] := [ &Stmt0, &Stmt1, &Stmt2 ];\n      .\n      .\n      .\n     mov( i, eax );\n     cmp( eax, 2 );          // Verify that i is in the range\n     ja EndCase;             // 0..2 before the indirect jmp.\n     jmp( JmpTbl[ eax*4 ] );\n\n          Stmt0:\n               stdout.put( \"i=0\" );\n               jmp EndCase;\n\n          Stmt1:\n               stdout.put( \"i=1\" );\n               jmp EndCase;\n\n          Stmt2:\n               stdout.put( \"i=2\" );\n\n     EndCase:\n```", "```\n// SWITCH statement specifying cases 5, 6, and 7:\n// WARNING: This code does *NOT* work. Keep reading to find out why.\n\n     mov( i, eax );\n     cmp( eax, 5 );\n     jb EndCase\n     cmp( eax, 7 );              // Verify that i is in the range\n     ja EndCase;                 // 5..7 before the indirect jmp.\n     jmp( JmpTbl[ eax*4 ] );\n\n          Stmt5:\n               stdout.put( \"i=5\" );\n               jmp EndCase;\n\n          Stmt6:\n               stdout.put( \"i=6\" );\n               jmp EndCase;\n\n          Stmt7:\n               stdout.put( \"i=7\" );\n\n     EndCase:\n```", "```\n// SWITCH statement specifying cases 5, 6, and 7:\n// WARNING: There is a better way to do this. Keep reading.\n\nreadonly\n     JmpTbl:dword[3] := [ &Stmt5, &Stmt6, &Stmt7 ];\n           .\n           .\n           .\n     mov( i, eax );\n     cmp( eax, 5 );\n     jb EndCase\n     cmp( eax, 7 );              // Verify that i is in the range\n     ja EndCase;                 // 5..7 before the indirect jmp.\n     sub( 5, eax );              // 5->0, 6->1, 7->2.\n     jmp( JmpTbl[ eax*4 ] );\n\n          Stmt5:\n               stdout.put( \"i=5\" );\n               jmp EndCase;\n\n          Stmt6:\n               stdout.put( \"i=6\" );\n               jmp EndCase;\n\n          Stmt7:\n               stdout.put( \"i=7\" );\n\n     EndCase:\n```", "```\n// SWITCH statement specifying cases 5, 6, and 7:\n\nreadonly\n     JmpTbl:dword[3] := [ &Stmt5, &Stmt6, &Stmt7 ];\n           .\n           .\n           .\n     mov( i, eax );\n     cmp( eax, 5 );\n     jb EndCase\n     cmp( eax, 7 );              // Verify that i is in the range\n     ja EndCase;                 // 5..7 before the indirect jmp.\n     jmp( JmpTbl[ eax*4 - 5*@size(dword)] );\n\n          Stmt5:\n               stdout.put( \"i=5\" );\n               jmp EndCase;\n\n          Stmt6:\n               stdout.put( \"i=6\" );\n               jmp EndCase;\n\n          Stmt7:\n               stdout.put( \"i=7\" );\n\n     EndCase:\n```", "```\nswitch( ebx )\n\n          case( 5 )  stdout.put( \"ebx=5\" );\n          case( 6 )  stdout.put( \"ebx=6\" );\n          case( 7 )  stdout.put( \"ebx=7\" );\n          default\n               stdout.put( \"ebx does not equal 5, 6, or 7\" );\n\n     endswitch;\n```", "```\n// SWITCH statement specifying cases 5, 6, and 7 with a DEFAULT clause:\n\nreadonly\n     JmpTbl:dword[3] := [ &Stmt5, &Stmt6, &Stmt7 ];\n           .\n           .\n           .\n     mov( i, eax );\n     cmp( eax, 5 );\n     jb DefaultCase;\n     cmp( eax, 7 );              // Verify that i is in the range\n     ja DefaultCase;             // 5..7 before the indirect jmp.\n     jmp( JmpTbl[ eax*4 - 5*@size(dword)] );\n\n          Stmt5:\n               stdout.put( \"i=5\" );\n               jmp EndCase;\n\n          Stmt6:\n               stdout.put( \"i=6\" );\n               jmp EndCase;\n\n          Stmt7:\n               stdout.put( \"i=7\" );\n               jmp EndCase;\n\n          DefaultCase:\n               stdout.put( \"i does not equal 5, 6, or 7\" );\n     EndCase:\n```", "```\nswitch( ebx )\n\n          case( 1 ) stdout.put( \"ebx = 1\" );\n          case( 2 ) stdout.put( \"ebx = 2\" );\n          case( 4 ) stdout.put( \"ebx = 4\" );\n          case( 8 ) stdout.put( \"ebx = 8\" );\n          default\n               stdout.put( \"ebx is not 1, 2, 4, or 8\" );\n\n     endswitch;\n```", "```\nreadonly\n     JmpTbl2: dword :=\n                    [\n                         &Case1, &Case2, &dfltCase, &Case4,\n                         &dfltCase, &dfltCase, &dfltCase, &Case8\n                    ];\n          .\n          .\n          .\n     cmp( ebx, 1 );\n     jb dfltCase;\n     cmp( ebx, 8 );\n     ja dfltCase;\n     jmp( JmpTbl2[ ebx*4 - 1*@size(dword) ] );\n\n          Case1:\n               stdout.put( \"ebx = 1\" );\n               jmp EndOfSwitch;\n\n          Case2:\n               stdout.put( \"ebx = 2\" );\n               jmp EndOfSwitch;\n\n          Case4:\n               stdout.put( \"ebx = 4\" );\n               jmp EndOfSwitch;\n\n          Case8:\n               stdout.put( \"ebx = 8\" );\n               jmp EndOfSwitch;\n\n          dfltCase:\n               stdout.put( \"ebx is not 1, 2, 4, or 8\" );\n\n     EndOfSwitch:\n```", "```\nswitch( ebx )\n\n          case( 1      ) << Stmt1 >>;\n          case( 100    ) << Stmt2 >>;\n          case( 1_000  ) << Stmt3 >>;\n          case( 10_000 ) << Stmt4 >>;\n          default << Stmt5 >>;\n\n     endswitch;\n```", "```\nswitch( eax )\n\n          case( 0   ) << Stmt0 >>;\n          case( 1   ) << Stmt1 >>;\n          case( 2   ) << Stmt2 >>;\n          case( 100 ) << Stmt3 >>;\n          default << Stmt4 >>;\n\n     endswitch;\n```", "```\ncmp( eax, 100 );\n          je DoStmt3;\n          cmp( eax, 2 );\n          ja TheDefaultCase;\n          jmp( JmpTbl[ eax*4 ]);\n          ...\n```", "```\nif( ebx = 100 ) then\n         << Stmt3 >>;\n     else\n          switch( eax )\n               case(0) << Stmt0 >>;\n               case(1) << Stmt1 >>;\n               case(2) << Stmt2 >>;\n               Otherwise << Stmt4 >>;\n          endswitch;\n     endif;\n```", "```\nswitch (i)\n     {\n          case 0: << Stmt1 >>;\n          case 1: << Stmt2 >>;\n          case 2: << Stmt3 >>;\n               break;\n          case 3: << Stmt4 >>;\n               break;\n          default: << Stmt5 >>;\n     }\n```", "```\nreadonly\n     JmpTbl: dword[4] := [ &case0, &case1, &case2, &case3 ];\n          .\n          .\n          .\n          mov( i, ebx );\n          cmp( ebx, 3 );\n          ja DefaultCase;\n          jmp( JmpTbl[ ebx*4 ]);\n\n               case0:\n                    Stmt1;\n\n               case1:\n                    Stmt2;\n\n               case2:\n                    Stmt3;\n                    jmp EndCase;    // Emitted for the break stmt.\n\n               case3:\n                    Stmt4;\n                    jmp EndCase;    // Emitted for the break stmt.\n\n               DefaultCase:\n                    Stmt5;\n\n          EndCase:\n```", "```\nprocedure StateMachine;\nstatic\n     State:byte := 0;\nbegin StateMachine;\n\n     cmp( State, 0 );\n     jne TryState1;\n\n          // State 0: Add ebx to eax and switch to State 1:\n\n          add( ebx, eax );\n          inc( State );\n          exit StateMachine;\n\n     TryState1:\n     cmp( State, 1 );\n     jne TryState2;\n\n          // State 1: Subtract ebx from eax and switch to State 2:\n\n          sub( ebx, eax );\n          inc( State );       // State 1 becomes State 2.\n          exit StateMachine;\n\n     TryState2:\n     cmp( State, 2 );\n     jne MustBeState3;\n\n          // If this is State 2, multiply ebx by eax and switch to State 3:\n\n          intmul( ebx, eax );\n          inc( State );       // State 2 becomes State 3.\n          exit StateMachine;\n\n     // If it isn't one of the above states, we must be in State 3,\n     // so divide eax by ebx and switch back to State 0.\n\n     MustBeState3:\n     push( edx );         // Preserve this 'cause it gets whacked by div.\n     xor( edx, edx );     // Zero extend eax into edx.\n     div( ebx, edx:eax);\n     pop( edx );          // Restore edx's value preserved above.\n     mov( 0, State );     // Reset the state back to 0.\n\nend StateMachine;\n```", "```\nprocedure StateMachine;\nstatic\n     State:dword := &State0;\nbegin StateMachine;\n\n     jmp( State );\n\n          // State 0: Add ebx to eax and switch to State 1:\n\n     State0:\n          add( ebx, eax );\n          mov( &State1, State );\n          exit StateMachine;\n\n     State1:\n\n          // State 1: Subtract ebx from eax and switch to State 2:\n\n          sub( ebx, eax );\n          mov( &State2, State );    // State 1 becomes State 2.\n          exit StateMachine;\n\n     State2:\n\n          // If this is State 2, multiply ebx by eax and switch to State 3:\n\n          intmul( ebx, eax );\n          mov( &State3, State );    // State 2 becomes State 3.\n          exit StateMachine;\n\n     // State 3: Divide eax by ebx and switch back to State 0.\n\n     State3:\n          push( edx );         // Preserve this 'cause it gets whacked by div.\n          xor( edx, edx );     // Zero extend eax into edx.\n          div( ebx, edx:eax);\n          pop( edx );            // Restore edx's value preserved above.\n          mov( &State0, State ); // Reset the state back to 0.\n\nend StateMachine;\n```", "```\nwhile( *`expression`* ) do *`statements`* endwhile;\n```", "```\nmov( 0, i );\n     while( i < 100 ) do\n\n          inc( i );\n\n     endwhile;\n```", "```\nmov( 0, i );\n     WhileLp:\n     if( i < 100 ) then\n\n          inc( i );\n          jmp WhileLp;\n\n     endif;\n```", "```\n<< Optional initialization code >>\n\n     UniqueLabel:\n     if( *`not_termination_condition`* ) then\n\n          << Loop body >>\n          jmp UniqueLabel;\n\n     endif;\n```", "```\nmov( 0, i );\n     WhileLp:\n          cmp( i, 100 );\n          jnl WhileDone;\n          inc( i );\n          jmp WhileLp;\n\n     WhileDone:\n```", "```\n<< Optional initialization code >>\n     repeat\n\n          << Loop body >>\n\n     until( *`termination_condition`* );\n```", "```\n<< Initialization code >>\n     *`SomeUniqueLabel`*:\n\n          << Loop body >>\n\n     if( *`not_the_termination_condition`* ) then jmp *`SomeUniqueLabel`*; endif;\n```", "```\nrepeat\n\n          stdout.put( \"Enter a number greater than 100: \" );\n          stdin.get( i );\n\n     until( i > 100 );\n\n// This translates to the following if/jmp code:\n\n     RepeatLabel:\n\n          stdout.put( \"Enter a number greater than 100: \" );\n          stdin.get( i );\n\n     if( i <= 100 ) then jmp RepeatLabel; endif;\n\n// It also translates into the following \"pure\" assembly code:\n\n     RepeatLabel:\n\n          stdout.put( \"Enter a number greater than 100: \" );\n          stdin.get( i );\n\n     cmp( i, 100 );\n     jng RepeatLabel;\n```", "```\nforever\n\n          << Loop body >>\n\n     endfor;\n```", "```\nforever\n\n          stdin.get( *`character`* );\n          breakif( *`character`* = '.' );\n          stdout.put( *`character`* );\n\n     endfor;\n```", "```\nforeverLabel:\n\n          stdin.get( *`character`* );\n          cmp( *`character`*, '.' );\n          je ForIsDone;\n          stdout.put( *`character`* );\n          jmp foreverLabel;\n\n     ForIsDone:\n```", "```\nfor( *`Initialization_Stmt`*; *`Termination_Expression`*; *`inc_Stmt`* ) do\n\n          << statements >>\n\n     endfor;\n```", "```\n*`Initialization_Stmt`*;\n     while( *`Termination_Expression`* ) do\n\n          << statements >>\n\n          *`inc_Stmt`*;\n\n     endwhile;\n```", "```\nfor( mov( 0, esi ); esi < 7; inc( esi )) do\n\n     stdout.put( \"Array Element = \", SomeArray[ esi*4 ], nl );\n\nendfor;\n```", "```\nmov( 0, esi );\n          while( esi < 7 ) do\n\n               stdout.put( \"Array Element = \", SomeArray[ esi*4 ], nl );\n\n               inc( esi );\n          endwhile;\n```", "```\nmov( 0, esi );\n          WhileLp:\n          cmp( esi, 7 );\n          jnl EndWhileLp;\n\n               stdout.put( \"Array Element = \", SomeArray[ esi*4 ], nl );\n\n               inc( esi );\n               jmp WhileLp;\n\n          EndWhileLp:\n```", "```\n// Breaking out of a FOREVER loop:\n\nforever\n     << stmts >>\n          // break;\n          jmp BreakFromForever;\n     << stmts >>\nendfor;\nBreakFromForever:\n\n// Breaking out of a FOR loop;\nfor( *`initStmt`*; *`expr`*; *`incStmt`* ) do\n     << stmts >>\n          // break;\n          jmp BrkFromFor;\n     << stmts >>\nendfor;\nBrkFromFor:\n\n// Breaking out of a WHILE loop:\n\nwhile( *`expr`* ) do\n     << stmts >>\n          // break;\n          jmp BrkFromWhile;\n     << stmts >>\nendwhile;\nBrkFromWhile:\n\n// Breaking out of a REPEAT..UNTIL loop:\n\nrepeat\n     << stmts >>\n          // 20break;\n          jmp BrkFromRpt;\n     << stmts >>\nuntil( *`expr`* );\nBrkFromRpt:\n```", "```\n// Conversion of forever loop with continue\n// to pure assembly:\nforever\n     << stmts >>\n     continue;\n     << stmts >>\nendfor;\n\n// Converted code:\n\nforeverLbl:\n     << stmts >>\n          // continue;\n          jmp foreverLbl;\n     << stmts >>\n     jmp foreverLbl;\n```", "```\n// Conversion of while loop with continue\n// into pure assembly:\n\nwhile( *`expr`* ) do\n     << stmts >>\n     continue;\n     << stmts >>\nendwhile;\n\n// Converted code:\n\nwhlLabel:\n<< Code to evaluate *`expr`* >>\nj*`cc`* EndOfWhile;         // Skip loop on *`expr`* failure.\n     << stmts >>\n          // continue;\n          jmp whlLabel; // Jump to start of loop on continue.\n     << stmts >>\n     jmp whlLabel;      // Repeat the code.\nEndOfwhile:\n```", "```\n// Conversion for a for loop with continue\n// into pure assembly:\n\nfor( *`initStmt`*; *`expr`*; *`incStmt`* ) do\n     << stmts >>\n     continue;\n     << stmts >>\nendfor;\n\n// Converted code:\n\n*`initStmt`*\nForLpLbl:\n<< Code to evaluate *`expr`* >>\nj*`cc`* EndOfFor;           // Branch if expression fails.\n     << stmts >>\n          // continue;\n          jmp ContFor;  // Branch to *`incStmt`* on continue.\n     << stmts >>\n\n     ContFor:\n     *`incStmt`*\n     jmp ForLpLbl;\nEndOfFor:\n```", "```\nrepeat\n     << stmts >>\n     continue;\n     << stmts >>\nuntil( *`expr`* );\n\n// Converted code:\n\nRptLpLbl:\n     << stmts >>\n          // continue;\n          jmp ContRpt;  // Continue branches to loop termination test.\n          << stmts >>\n     ContRpt:\n     << Code to test *`expr`* >>\n     j*`cc`* RptLpLbl;      // Jumps if expression evaluates false.\n```", "```\nmov( 8, cx );\n          loop1:\n               mov( 4, cx );\n               loop2:\n                    << stmts >>\n                    dec( cx );\n                    jnz loop2;\n               dec( cx );\n           jnz loop1;\n```", "```\nmov( 8, cx );\n          loop1:\n               push( cx );\n               mov( 4, cx );\n               loop2:\n                    << stmts >>\n                    dec( cx );\n                    jnz loop2;\n\n               pop( cx );\n               dec( cx );\n               jnz loop1;\n```", "```\nmov( 8, dx );\n          loop1:\n               mov( 4, cx );\n               loop2:\n                    << stmts >>\n                    dec( cx );\n                    jnz loop2;\n\n               dec( dx );\n               jnz loop1;\n```", "```\nrepeat..until loop:\n     Initialization code\n          Loop body\n     Test for termination\n     Code following the loop\n\nwhile loop:\n     Initialization code\n     Loop termination test\n          Loop body\n          Jump back to test\n     Code following the loop\n\nforever..endfor loop:\n     Initialization code\n          Loop body part one\n          Loop termination test\n          Loop body part two\n          Jump back to Loop body part one\n     Code following the loop\n```", "```\n// Example involving a WHILE loop:\n\n     mov( edi, esi );\n     sub( 20, esi );\n     while( esi <= edi ) do\n\n          << stmts >>\n          inc( esi );\n\n     endwhile;\n\n// Conversion of the code above into pure assembly language:\n\n     mov( edi, esi );\n     sub( 20, esi );\n     whlLbl:\n     cmp( esi, edi );\n     jnle EndOfWhile;\n\n          << stmts >>\n          inc( esi );\n          << stmts >>\n          jmp whlLbl;\n\n     EndOfWhile:\n\n// Example involving a REPEAT..UNTIL loop:\n\n     mov( edi, esi );\n     sub( 20, esi );\n     repeat\n\n          << stmts >>\n          inc( esi );\n\n     until( esi > edi );\n\n// Conversion of the REPEAT..UNTIL loop into pure assembly:\n\n     rptLabel:\n          << stmts >>\n          inc( esi );\n          cmp( esi, edi );\n          jng rptLabel;\n```", "```\nwhile( esi <= edi ) do\n          << stmts >>\n          inc( esi );\n     endwhile;\n```", "```\njmp WhlTest;\n     TopOfLoop:\n          << stmts >>\n          inc( esi );\n     WhlTest:\n          cmp( esi, edi );\n          jle TopOfLoop;\n```", "```\nfor( mov( 1, j ); j <= 8; inc( j ) ) do\n     << stmts >>\nendfor;\n\n// Conversion to pure assembly (as well as using a REPEAT..UNTIL form):\n\nmov( 1, j );\nForLp:\n     << stmts >>\n     inc( j );\n     cmp( j, 8 );\n     jnge ForLp;\n```", "```\nmov( 8, j );\nLoopLbl:\n     << stmts >>\n     dec( j );\n     jnz LoopLbl;\n```", "```\nmov( 7, j );\nLoopLbl:\n     << stmts >>\n     dec( j );\n     jns LoopLbl;\n```", "```\nfor( mov( 0, eax ); eax < n; inc( eax )) do\n\n          mov( eax, edx );\n          add( j, edx );\n          sub( 2, edx );\n          add( edx, k );\n\n     endfor;\n```", "```\nmov( j, ecx );\n     sub( 2, ecx );\n     for( mov( 0, eax ); eax < n; inc( eax )) do\n\n          mov( eax, edx );\n          add( ecx, edx );\n          add( edx, k );\n\n     endfor;\n```", "```\nmov( j, ecx );\n     sub( 2, ecx );\n     intmul( n, ecx );   // Compute n*(j-2) and add this into k outside\n     add( ecx, k );      // the loop.\n     for( mov( 0, eax ); eax < n; inc( eax )) do\n\n          add( eax, k );\n\n     endfor;\n```", "```\nfor i := 3 downto 0 do A[i] := 0;\n\n     mov( 3, i );\n     LoopLbl:\n          mov( i, ebx );\n          mov( 0, A[ ebx*4 ] );\n          dec( i );\n          jns LoopLbl;\n```", "```\nmov( 0, A[0] );\n     mov( 0, A[4] );\n     mov( 0, A[8] );\n     mov( 0, A[12] );\n```", "```\nfor i := 0 to 255 do csetVar[i] := {};\n```", "```\nmov( 0, i );\nFLp:\n\n     // Compute the index into the array (note that each element\n     // of a CSET array contains 16 bytes).\n\n     mov( i, ebx );\n     shl( 4, ebx );\n\n     // Set this element to the empty set (all 0 bits).\n\n     mov( 0, csetVar[ ebx ] );\n     mov( 0, csetVar[ ebx+4 ] );\n     mov( 0, csetVar[ ebx+8 ] );\n     mov( 0, csetVar[ ebx+12 ] );\n\n     inc( i );\n     cmp( i, 256 );\n     jb FLp;\n```", "```\nmov( 0, ebx );\nFLp:\n     mov( 0, csetVar[ ebx ]);\n     mov( 0, csetVar[ ebx+4 ] );\n     mov( 0, csetVar[ ebx+8 ] );\n     mov( 0, csetVar[ ebx+12 ] );\n\n     add( 16, ebx );\n     cmp( ebx, 256*16 );\n     jb FLp;\n```", "```\nif( #{ *`instructions`* }# ) then *`statements`* endif;\n```", "```\nwhile( #{ *`statements`* }# ) *`statements`* endwhile;\nrepeat *`statements`* until( #{ *`statements`* }# );\nbreakif( #{ *`statements`* }# );\nexitif( #{ *`statements`* }# );\ncontinueif( #{ *`statements`* }# );\n```", "```\nif( eax < ebx ) then inc( eax ); endif;\n\nif\n( #{\n     cmp( eax, ebx );\n     jnb false;\n}# ) then\n     inc( eax );\n\nendif;\n```", "```\ncmp( eax, ebx );\njnb falseLabel;\n     inc( eax );\nfalseLabel:\n```", "```\nif( eax >= j && eax <= k ) then sub( j, eax ); endif;\n```", "```\nif\n( #{\n     cmp( eax, j );\n     jnae false;\n     cmp( eax, k );\n     jnae false;\n}# ) then\n     sub( j, eax );\n\nendif;\n```", "```\n// if( ((eax > ebx) && (eax < ecx)) || (eax = edx)) then\n//     mov( ebx, eax );\n// endif;\n\nif\n( #{\n     cmp( eax, edx );\n     je true;\n     cmp( eax, ebx );\n     jng false;\n     cmp( eax, ecx );\n     jnb false;\n}# ) then\n     mov( ebx, eax );\n\nendif;\n```"]