<html><head></head><body>
<h2 class="h2" id="aft"><span epub:type="pagebreak" id="page_425"/>AFTERWORD: THINKING LOW-LEVEL, WRITING HIGH-LEVEL</h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">The goal of this book was to get you thinking at the machine level. One way to force yourself to write code at this level is to write your applications in assembly language. When you write code statement by statement in assembly language, you get a pretty good idea of the cost associated with each one.</p>&#13;
<p class="indent">Unfortunately, using assembly language isn’t a realistic solution for most applications. The disadvantages of assembly language have been well publicized (and exaggerated) over the past several decades, and as a result many people have decided assembly isn’t an option for them.</p>&#13;
<p class="indent">Unlike writing code in assembly language, writing code in a high-level language doesn’t force you to think at a high level of abstraction. There’s nothing preventing you from thinking in low-level terms while writing high-level code. This book has equipped you with the background knowledge you need to do just that. By learning how the computer represents data, you’ve learned how HLL data types translate to the machine level. <span epub:type="pagebreak" id="page_426"/>By learning how the CPU executes machine instructions, you’ve learned the costs of various operations in your HLL applications. And by learning about memory performance, you’ve learned how to organize your HLL variables and other data to maximize cache and memory access. There’s only one piece missing from this puzzle: “Exactly <em>how</em> does a particular compiler map HLL statements to the machine level?” That topic is sufficiently large that it deserves an entire book on its own. And that’s the purpose of the second volume in the <em>Write Great Code</em> series: <em>Thinking Low-Level, Writing High-Level</em>.</p>&#13;
<p class="indent"><em>WGC2</em> will pick up right where this book leaves off. It will teach you how each statement in a typical HLL maps to machine code, how you can choose between two or more high-level sequences to produce the best possible machine code, and how to analyze that machine code to determine its quality and that of the high-level code that produced it. And while doing all of this, it will give you a greater appreciation for how compilers work and encourage you to help them do their job better.</p>&#13;
<p class="indent">Congratulations on your progress thus far toward writing great code. See you in Volume 2.</p>&#13;
</body></html>