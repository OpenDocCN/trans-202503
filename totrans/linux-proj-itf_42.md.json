["```\n#include <dlfcn.h>\n\nvoid *`dlopen`(const char **libfilename*, int *flags*);\n```", "```\n#include <dlfcn.h>\n\nconst char **dlerror*(void);\n```", "```\n#include <dlfcn.h>\n\nvoid *`dlsym`(void **handle*, char **symbol*);\n```", "```\nint *ip;\n\nip = (int *) dlsym(symbol, \"myvar\");\nif (ip != NULL)\n    printf(\"Value is %d\\n\", *ip);\n```", "```\nint (*funcp)(int);              /* Pointer to a function taking an integer\n                                   argument and returning an integer */\n```", "```\nfuncp = dlsym(handle, symbol);\n```", "```\n*(void **) (&funcp) = dlsym(handle, symbol);\n```", "```\nres = (*funcp)(somearg);\n```", "```\n(void *) funcp = dlsym(handle, symbol);\n```", "```\nfuncp = (int (*) (int)) dlsym(handle, symbol);\n```", "```\n$ `./dynload ./libdemo.so.1 x1`\nCalled mod1-x1\n$ `LD_LIBRARY_PATH=. ./dynload libdemo.so.1 x1`\nCalled mod1-x1\n```", "```\n`shlibs/dynload.c`\n#include <dlfcn.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    void *libHandle;            /* Handle for shared library */\n    void (*funcp)(void);        /* Pointer to function with no arguments */\n    const char *err;\n\n    if (argc != 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s lib-path func-name\\n\", argv[0]);\n\n    /* Load the shared library and get a handle for later use */\n\n    libHandle = dlopen(argv[1], RTLD_LAZY);\n    if (libHandle == NULL)\n        fatal(\"dlopen: %s\", dlerror());\n\n    /* Search library for symbol named in argv[2] */\n\n    (void) dlerror();                           /* Clear dlerror() */\n    *(void **) (&funcp) = dlsym(libHandle, argv[2]);\n    err = dlerror();\n    if (err != NULL)\n        fatal(\"dlsym: %s\", err);\n\n    /* If the address returned by dlsym() is non-NULL, try calling it\n       as a function that takes no arguments */\n\n    if (funcp == NULL)\n        printf(\"%s is NULL\\n\", argv[2]);\n    else\n        (*funcp)();\n\n    dlclose(libHandle);                         /* Close the library */\n\n    exit(EXIT_SUCCESS);\n}\n\n      `shlibs/dynload.c`\n```", "```\n#include <dlfcn.h>\n\nint `dlclose`(void **handle*);\n```", "```\n#define _GNU_SOURCE\n#include <dlfcn.h>\n\nint `dladdr`(const void **addr*, Dl_info **info*);\n```", "```\ntypedef struct {\n    const char *dli_fname;          /* Pathname of shared library\n                                       containing 'addr' */\n    void       *dli_fbase;          /* Base address at which shared\n                                       library is loaded */\n    const char *dli_sname;          /* Name of nearest run-time symbol\n                                       with an address <= 'addr' */\n    void       *dli_saddr;          /* Actual value of the symbol\n                                       returned in 'dli_sname' */\n} Dl_info;\n```", "```\n$ `gcc -Wl,--export-dynamic main.c`     *(plus further options and arguments)*\n```", "```\n$ `gcc -export-dynamic main.c`\n```", "```\n    void\n    __attribute__ ((visibility(\"hidden\")))\n    func(void) {\n        /* Code */\n    }\n    ```", "```\n$ `gcc -Wl,--version-script,```", "```\n\nVersion scripts are commonly (but not universally) identified using the extension `.map`.\n\nThe following sections describe some uses of version scripts.\n\n### Controlling Symbol Visibility with Version Scripts\n\nOne use of version scripts is to control the visibility of symbols that might otherwise accidentally be made global (i.e., visible to applications linking against the library). As a simple example, suppose that we are building a shared library from the three source files `vis_comm.c`, `vis_f1.c`, and `vis_f2.c`, which respectively define the functions *vis_comm()*, *vis_f1()*, and *vis_f2()*. The *vis_comm()* function is called by *vis_f1()* and *vis_f2()*, but is not intended for direct use by applications linked against the library. Suppose we build the shared library in the usual way:\n\n```", "```\n\nIf we use the following *readelf* command to list the dynamic symbols exported by the library, we see the following:\n\n```", "```\n\nThis shared library exported three symbols: *vis_comm()*, *vis_f1()*, and *vis_f2()*. However, we would like to ensure that only the symbols *vis_f1()* and *vis_f2()* are exported by the library. We can achieve this result using the following version script:\n\n```", "```\n\nThe identifier *VER_1* is an example of a *version tag*. As we’ll see in the discussion of symbol versioning in [Symbol Versioning](ch42.html#symbol_versioning \"Symbol Versioning\"), a version script may contain multiple *version nodes*, each grouped within braces (`{}`) and prefixed with a unique version tag. If we are using a version script only for the purpose of controlling symbol visibility, then the version tag is redundant; nevertheless, older versions of *ld* required it. Modern versions of *ld* allow the version tag to be omitted; in this case, the version node is said to have an anonymous version tag, and no other version nodes may be present in the script.\n\nWithin the version node, the `global` keyword begins a semicolon-separated list of symbols that are made visible outside the library. The local keyword begins a list of symbols that are to be hidden from the outside world. The asterisk (*) here illustrates the fact that we can use wildcard patterns in these symbol specifications. The wildcard characters are the same as those used for shell filename matching—for example, `*` and `?`. (See the *glob(7)* manual page for further details.) In this example, using an asterisk for the `local` specification says that everything that wasn’t explicitly declared `global` is hidden. If we did not say this, then *vis_comm()* would still be visible, since the default is to make C global symbols visible outside the shared library.\n\nWe can then build our shared library using the version script as follows:\n\n```", "```\n\nUsing *readelf* once more shows that *vis_comm()* is no longer externally visible:\n\n```", "```\n\n### Symbol Versioning\n\nSymbol versioning allows a single shared library to provide multiple versions of the same function. Each program uses the version of the function that was current when the program was (statically) linked against the shared library. As a result, we can make an incompatible change to a shared library without needing to increase the library’s major version number. Carried to an extreme, symbol versioning can replace the traditional shared library major and minor versioning scheme. Symbol versioning is used in this manner in *glibc* 2.1 and later, so that all versions of *glibc* from 2.0 onward are supported within a single major library version (`libc.so.6`).\n\nWe demonstrate the use of symbol versioning with a simple example. We begin by creating the first version of a shared library using a version script:\n\n```", "```\n\n### Note\n\nWithin a version script, the hash character (`#`) starts a comment.\n\n(To keep the example simple, we avoid the use of explicit library sonames and library major version numbers.)\n\nAt this stage, our version script, `sv_v1.map`, serves only to control the visibility of the shared library’s symbols; *xyz()* is exported, but all other symbols (of which there are none in this small example) are hidden. Next, we create a program, *p1*, which makes use of this library:\n\n```", "```\n\nWhen we run this program, we see the expected result:\n\n```", "```\n\nNow, suppose that we want to modify the definition of *xyz()* within our library, while still ensuring that program *p1* continues to use the old version of this function. To do this, we must define two versions of *xyz()* within our library:\n\n```", "```\n\nOur two versions of *xyz()* are provided by the functions *xyz_old()* and *xyz_new()*. The *xyz_old()* function corresponds to our original definition of *xyz()*, which is the one that should continue to be used by program *p1*. The *xyz_new()* function provides the definition of *xyz()* to be used by programs linking against the new version of the library.\n\nThe two `.symver` assembler directives are the glue that ties these two functions to different version tags in the modified version script (shown in a moment) that we use to create the new version of the shared library. The first of these directives says that *xyz_old()* is the implementation of *xyz()* to be used for applications linked against version tag *VER_1* (i.e., program *p1* in our example), and that *xyz_new()* is the implementation of *xyz()* to be used by applications linked against version tag *VER_2*.\n\nThe use of `@@` rather than `@` in the second `.symver` directive indicates that this is the default definition of *xyz()* to which applications should bind when statically linked against this shared library. Exactly one of the `.symver` directives for a symbol should be marked using `@@`.\n\nThe corresponding version script for our modified library is as follows:\n\n```", "```\n\nThis version script provides a new version tag, *VER_2*, which depends on the tag *VER_1*. This dependency is indicated by the following line:\n\n```", "```\n\nVersion tag dependencies indicate the relationships between successive library versions. Semantically, the only effect of version tag dependencies on Linux is that a version node inherits `global` and `local` specifications from the version node upon which it depends.\n\nDependencies can be chained, so that we could have another version node tagged *VER_3*, which depended on *VER_2*, and so on.\n\nThe version tag names have no meanings in themselves. Their relationship with one another is determined only by the specified version dependencies, and we chose the names *VER_1* and *VER_2* merely to be suggestive of these relationships. To assist maintenance, recommended practice is to use version tags that include the package name and a version number. For example, *glibc* uses version tags with names such as *GLIBC_2.0*, *GLIBC_2.1*, and so on.\n\nThe *VER_2* version tag also specifies that the new function *pqr()* is to be exported by the library and bound to the *VER_2* version tag. If we didn’t declare *pqr()* in this manner, then the `local` specification that *VER_2* version tag inherited from the *VER_1* version tag would make *pqr()* invisible outside the library. Note also that if we omitted the `local` specification altogether, then the symbols *xyz_old()* and *xyz_new()* would also be exported by the library (which is typically not what we want).\n\nWe now build the new version of our library in the usual way:\n\n```", "```\n\nNow we can create a new program, *p2*, which uses the new definition of *xyz()*, while program *p1* uses the old version of *xyz()*.\n\n```", "```\n\nThe version tag dependencies of an executable are recorded at static link time. We can use *objdump -t* to display the symbol tables of each executable, thus showing the different version tag dependencies of each program:\n\n```", "```\n\nWe can also use *readelf -s* to obtain similar information.\n\n### Note\n\nFurther information about symbol versioning can be found using the command *info ld scripts version* and at [http://people.redhat.com/drepper/symbol-versioning](http://people.redhat.com/drepper/symbol-versioning).\n\n## Initialization and Finalization Functions\n\nIt is possible to define one or more functions that are executed automatically when a shared library is loaded and unloaded. This allows us to perform initialization and finalization actions when working with shared libraries. Initialization and finalization functions are executed regardless of whether the library is loaded automatically or loaded explicitly using the *dlopen* interface ([Dynamically Loaded Libraries](ch42.html#dynamically_loaded_libraries \"Dynamically Loaded Libraries\")).\n\nInitialization and finalization functions are defined using the *gcc* `constructor` and `destructor` attributes. Each function that is to be executed when the library is loaded should be defined as follows:\n\n```", "```\n\nUnload functions are similarly defined:\n\n```", "```\n\nThe function names *some_name_load()* and *some_name_unload()* can be replaced by any desired names.\n\n### Note\n\nIt is also possible to use the *gcc* `constructor` and `destructor` attributes to create initialization and finalization functions in a main program.\n\n#### The *_init()* and *_fini()* functions\n\nAn older technique for shared library initialization and finalization is to create two functions, *_init()* and *_fini()*, as part of the library. The *void _init(void)* function contains code that is to executed when the library is first loaded by a process. The *void _fini(void)* function contains code that is to be executed when the library is unloaded.\n\nIf we create *_init()* and *_fini()* functions, then we must specify the *gcc -nostartfiles* option when building the shared library, in order to prevent the linker from including default versions of these functions. (Using the *-Wl,-init* and *-Wl,-fini* linker options, we can choose alternative names for these two functions if desired.)\n\nUse of *_init()* and *_fini()* is now considered obsolete in favor of the *gcc* `constructor` and `destructor` attributes, which, among other advantages, allow us to define multiple initialization and finalization functions.\n\n## Preloading Shared Libraries\n\nFor testing purposes, it can sometimes be useful to selectively override functions (and other symbols) that would normally be found by the dynamic linker using the rules described in [Finding Shared Libraries at Run Time](ch41.html#finding_shared_libraries_at_run_time \"Finding Shared Libraries at Run Time\"). To do this, we can define the environment variable `LD_PRELOAD` as a string consisting of space-separated or colon-separated names of shared libraries that should be loaded before any other shared libraries. Since these libraries are loaded first, any functions they define will automatically be used if required by the executable, thus overriding any other functions of the same name that the dynamic linker would otherwise have searched for. For example, suppose that we have a program that calls functions *x1()* and *x2()*, defined in our *libdemo* library. When we run this program, we see the following output:\n\n```", "```\n\n(In this example, we assume that the shared library is in one of the standard directories, and thus we don’t need to use the `LD_LIBRARY_PATH` environment variable.)\n\nWe could selectively override the function *x1()* by creating another shared library, `libalt.so`, which contains a different definition of *x1()*. Preloading this library when running the program would result in the following:\n\n```", "```\n\nHere, we see that the version of *x1()* defined in `libalt.so` is invoked, but that the call to *x2()*, for which no definition is provided in `libalt.so`, results in the invocation of the *x2()* function defined in `libdemo.so`.\n\nThe `LD_PRELOAD` environment variable controls preloading on a per-process basis. Alternatively, the file `/etc/ld.so.preload`, which lists libraries separated by white space, can be used to perform the same task on a system-wide basis. (Libraries specified by `LD_PRELOAD` are loaded before those specified in `/etc/ld.so.preload`.)\n\nFor security reasons, set-user-ID and set-group-ID programs ignore `LD_PRELOAD`.\n\n## Monitoring the Dynamic Linker: `LD_DEBUG`\n\nSometimes, it is useful to monitor the operation of the dynamic linker in order to know, for example, where it is searching for libraries. We can use the `LD_DEBUG` environment variable to do this. By setting this variable to one (or more) of a set of standard keywords, we can obtain various kinds of tracing information from the dynamic linker.\n\nIf we assign the value *help* to `LD_DEBUG`, the dynamic linker displays help information about `LD_DEBUG`, and the specified command is *not* executed:\n\n```", "```\n\nThe following example shows an abridged version of the output provided when we request tracing of information about library searches:\n\n```"]