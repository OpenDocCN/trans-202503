<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label="61"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch4">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BLOCK CIPHERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">During the Cold War, the United States and the Soviets developed their own ciphers. The US government created the Data Encryption Standard (DES), which was adopted as a federal standard from 1979 to 2005, while the KGB developed GOST 28147-89, an algorithm kept secret until 1990 and still used today. In 2000, the US-based National Institute of Standards and Technology (NIST) selected the successor to DES, the Advanced Encryption Standard (AES), an algorithm developed in Belgium and now found in most electronic devices. AES, DES, and GOST 28147-89 are all <i>block ciphers</i>, a type of cipher that combines a core algorithm working on blocks of data with a <i>mode of operation</i>, or a technique to process sequences of data blocks.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label="62"/>This chapter reviews the core algorithms that underlie block ciphers, discusses their modes of operation, and explains how they all work together. It also discusses how AES works and concludes with coverage of a classic attack tool from the 1970s, the meet-in-the-middle attack, and a favorite attack technique of the 2000s—padding oracles.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-29"/><samp class="SANS_Futura_Std_Bold_B_11">What Is a Block Cipher?</samp></h3>&#13;
<p class="TNI">A block cipher consists of an encryption algorithm and a decryption algorithm:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The <i>encryption algorithm</i> (<b>E</b>) takes a key, <i>K</i>, and a plaintext block, <i>P</i>, and produces a ciphertext block, <i>C</i>. We write an encryption operation as <i>C</i> = <b>E</b>(<i>K</i>, <i>P</i>).</li>&#13;
<li class="BL">The <i>decryption algorithm</i> (<b>D</b>) is the inverse of the encryption algorithm and decrypts a message to the original plaintext, <i>P</i>. We write this operation as <i>P</i> = <b>D</b>(<i>K</i>, <i>C</i>).</li>&#13;
</ul>&#13;
<p class="TX">Since they’re the inverse of each other, the encryption and decryption algorithms usually involve similar operations.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-46"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Goals</samp></h4>&#13;
<p class="TNI">If you’ve followed earlier discussions about encryption, randomness, and indistinguishability, the definition of a secure block cipher will come as no surprise. We’ll continue to define security as random-looking-ness, so to speak.</p>&#13;
<p class="TX">For a block cipher to be secure, it should be a <i>pseudorandom permutation (PRP)</i>, meaning that as long as the key is secret, an attacker shouldn’t be able to compute an output of the block cipher from any input. That is, as long as <i>K</i> is secret and random from an attacker’s perspective, they should have no clue what <b>E</b>(<i>K</i>, <i>P</i>) looks like, for any given <i>P</i>.</p>&#13;
<p class="TX">More generally, attackers should be unable to discover any <i>pattern</i> in the input/output values of a block cipher. In other words, it should be impossible to tell a block cipher from a truly random permutation, given black-box access to the encryption and decryption functions for some fixed and unknown key. By the same token, attackers should be unable to recover a secure block cipher’s secret key; otherwise, they could use that key to tell the block cipher from a random permutation. This implies that attackers can’t predict the plaintext that corresponds to a given ciphertext the block cipher produces.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Block Size</samp></h4>&#13;
<p class="TNI">Two values characterize a block cipher: the block size and the key size. Security depends on both values. Most block ciphers have either 64-bit or 128-bit blocks—DES’s blocks have 64 (2<sup>6</sup>) bits, and AES’s blocks have 128 (2<sup>7</sup>) bits. In computing, lengths that are generally measured as powers <span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>of two simplify data processing, storage, and addressing. But why 2<sup>6</sup> and 2<sup>7</sup> and not 2<sup>4</sup> or 2<sup>16</sup> bits?</p>&#13;
<p class="TX">It’s important that a block cipher’s blocks aren’t too large in order to minimize both the length of ciphertext and the memory footprint. Block ciphers first transform their input data into a sequence of blocks, which means that to encrypt a 16-bit message when blocks are 128 bits, you need to convert the message into a 128-bit block for the block cipher to process it and return a 128-bit ciphertext. The wider the blocks, the longer this overhead. To process a 128-bit block, you need at least 128 bits of memory. Blocks of 64, 128, or even 512 bits are short enough to fit in the registers of most CPUs or to implement using dedicated hardware circuits, allowing for efficient implementations in most cases. But larger blocks (for example, several kilobytes long) can have a noticeable impact on the cost and performance of implementations.</p>&#13;
<p class="TX">When ciphertexts’ length or memory footprint is critical, you may have to use 64-bit blocks because these produce shorter ciphertexts and consume less memory. Otherwise, 128-bit or larger blocks are better, mainly because modern CPUs can often process 128-bit blocks more efficiently than 64-bit ones and they’re more secure (see the “Sweet32” attack, at <i><a href="https://sweet32.info">https://<wbr/>sweet32<wbr/>.info</a></i>). In particular, CPUs can leverage instructions to efficiently process one or more 128-bit blocks in parallel—for example, the Advanced Vector Extensions (AVX) family of instructions in Intel CPUs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-48"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Codebook Attack</samp></h4>&#13;
<p class="TNI">While blocks shouldn’t be too large, they also shouldn’t be too small; otherwise, they may be susceptible to <i>codebook attacks</i>, which are attacks against block ciphers that are efficient only when using smaller blocks. With 16-bit blocks, the codebook attack works like this:</p>&#13;
<p class="NLF">  1.  Get the 65,536 (2<sup>16</sup>) ciphertexts corresponding to each 16-bit plaintext block.</p>&#13;
<p class="NL">  2.  Build a lookup table—the <i>codebook</i>—mapping each ciphertext block to its corresponding plaintext block.</p>&#13;
<p class="NLL">  3.  To decrypt an unknown ciphertext block, look up its corresponding plaintext block in the table.</p>&#13;
<p class="TX">When using 16-bit blocks, the lookup table needs only 2<sup>16</sup> × 16 = 2<sup>20</sup> bits of memory, or 128 kilobytes. With 32-bit blocks, memory needs to grow to 16 gigabytes, which is still manageable. But with 64-bit blocks, you’d have to store 2<sup>70</sup> bits (a zettabit, or 128 exabytes), so forget about it. Codebook attacks are therefore not an issue for larger blocks of 128 bits or more.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H1" id="sec5"><span id="h1-30"/><samp class="SANS_Futura_Std_Bold_B_11">How to Construct Block Ciphers</samp></h3>&#13;
<p class="TNI">There exist hundreds of block ciphers but only a handful of techniques to construct one. In practice, a block cipher isn’t a gigantic algorithm but a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/>repetition of <i>rounds</i>, a short sequence of operations that’s weak on its own but strong in number. There are two main techniques to construct a round: substitution–permutation networks (as in AES) and Feistel schemes (as in DES). In this section, you’ll look at these techniques after viewing an attack that works when all rounds are identical to each other.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-49"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Block Cipher’s Rounds</samp></h4>&#13;
<p class="TNI">Computing a block cipher boils down to computing a sequence of rounds<i>.</i> In a block cipher, a round is a basic transformation that’s simple to specify and to implement and is iterated several times to form the block cipher’s algorithm. This construction, consisting of a small component repeated many times, is simpler to implement and to analyze than a construction that consists of a single huge algorithm.</p>&#13;
<p class="TX">For example, a block cipher with three rounds encrypts a plaintext by computing <i>C</i> = <b>R</b><sub>3</sub>(<b>R</b><sub>2</sub>(<b>R</b><sub>1</sub>(<i>P</i>))), where the rounds are <b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>, and <b>R</b><sub>3</sub>, and <i>P</i> is a plaintext. Each round should also have an inverse so it’s possible for a recipient to compute back to plaintext. Specifically, <i>P</i> = <b>iR</b><sub>1</sub>(<b>iR</b><sub>2</sub>(<b>iR</b><sub>3</sub>(<i>C</i>))), where <b>iR</b><sub>1</sub> is the inverse of <b>R</b><sub>1</sub>, and so on.</p>&#13;
<p class="TX">The round functions—<b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>, and so forth—are usually identical algorithms, but they are parameterized by a value we call the <i>round key</i>. Two round functions with two distinct round keys will behave differently and will therefore produce distinct outputs if fed with the same input.</p>&#13;
<p class="TX">We derive round keys from the main key, <i>K</i>, using a <i>key schedule</i> algorithm. For example, <b>R</b><sub>1</sub> takes the round key <i>K</i><sub>1</sub>, <b>R</b><sub>2</sub> takes the round key <i>K</i><sub>2</sub>, and so on.</p>&#13;
<p class="TX">Round keys should be different from each other in every round. For that matter, not all round keys should be equal to the key <i>K</i>; otherwise, all the rounds would be identical, and the block cipher would be less secure, as I’ll describe next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Slide Attack</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">and Round Keys</samp></h4>&#13;
<p class="TNI">In a block cipher, no round should be identical to another round in order to avoid a <i>slide attack</i>. As <a href="chapter4.xhtml#fig4-1">Figure 4-1</a> shows, slide attacks look for two plaintext/ciphertext pairs (<i>P</i><sub>1</sub>, <i>C</i><sub>1</sub>) and (<i>P</i><sub>2</sub>, <i>C</i><sub>2</sub>), where <i>P</i><sub>2</sub> = <b>R</b>(<i>P</i><sub>1</sub>) if <b>R</b> is the cipher’s round. When rounds are identical, the relation between the two plaintexts, <i>P</i><sub>2</sub> = <b>R</b>(<i>P</i><sub>1</sub>), implies the relation <i>C</i><sub>2</sub> = <b>R</b>(<i>C</i><sub>1</sub>) between their respective ciphertexts. <a href="chapter4.xhtml#fig4-1">Figure 4-1</a> shows three rounds, but the relation <i>C</i><sub>2</sub> = <b>R</b>(<i>C</i><sub>1</sub>) will hold no matter the number of rounds, be it 3, 10, or 100. The problem is that knowing the input and output of a single round often helps recover the key. (For details, read the 1999 paper “Advanced Slide Attacks” by Alex Biryukov and David Wagner, available at <i><a href="https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf">https://<wbr/>www<wbr/>.iacr<wbr/>.org<wbr/>/archive<wbr/>/eurocrypt2000<wbr/>/1807<wbr/>/18070595<wbr/>-new<wbr/>.pdf</a></i>.)</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/>&#13;
<figure class="IMG"><img id="fig4-1" class="img7" src="../images/fig4-1.jpg" alt="" width="984" height="275"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The principle of the slide attack against block ciphers with identical rounds</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Using different round keys as parameters ensures that the rounds will behave differently and thus foil slide attacks.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>One potential byproduct and benefit of using round keys is protection against</i> <span class="note_Italic">side-channel attacks</span><i>, or attacks that exploit information leaked from the implementation of a cipher (for example, electromagnetic emanations). If the transformation from the main key,</i> <span class="note_Italic">K</span><i>, to a round key,</i> <span class="note_Italic">K</span><sub>i</sub><i>, isn’t invertible, then if an attacker finds</i> <span class="note_Italic">K</span><sub>i</sub><i>, they can’t use that key to find</i> <span class="note_Italic">K</span><i>. Unfortunately, few block ciphers have a one-way key schedule. The key schedule of AES allows attackers to compute</i> <span class="note_Italic">K</span> <i>from any round key,</i> <span class="note_Italic">K</span><sub>i</sub><i>, for example.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-51"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Substitution–Permutation Networks</samp></h4>&#13;
<p class="TNI">If you’ve read textbooks about cryptography, you’ve likely come across confusion and diffusion. <i>Confusion</i> means that the input (plaintext and encryption key) undergoes complex transformations, and <i>diffusion</i> means that these transformations depend equally on all bits of the input. At a high level, confusion is about depth, whereas diffusion is about breadth. In the design of a block cipher, confusion and diffusion take the form of substitution and permutation operations, which we combine within substitution–permutation networks (SPNs).</p>&#13;
<p class="TX">Substitution often appears in the form of <i>S-boxes</i>, or <i>substitution boxes</i>, which are small lookup tables that transform chunks of 4 or 8 bits. For example, the first of the eight S-boxes of the block cipher Serpent is composed of the 16 elements (3 8 f 1 a 6 5 b e d 4 2 7 0 9 c), where each element represents a 4-bit nibble. This particular S-box maps the 4-bit nibble 0000 to 3 (0011), the 4-bit nibble 0101 (5 in decimal) to 6 (0110), and so on.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>S-boxes must be carefully chosen to be cryptographically strong: they should be as nonlinear as possible (inputs and outputs should be related with complex equations) and have no statistical bias (meaning, for example, that flipping an input bit should potentially affect any of the output bits).</i></p>&#13;
<p class="TX">The permutation in a substitution–permutation network can be as simple as changing the order of the bits, which is easy to implement but doesn’t mix up the bits very much. Instead of a reordering of the bits, some ciphers use basic linear algebra and matrix multiplications to mix up the bits: they perform a series of multiplication operations with fixed values (the matrix’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/>coefficients) and then add the results. Such operations can quickly create dependencies between all the bits within a cipher and thus ensure strong diffusion. For example, the block cipher FOX transforms a 4-byte vector (<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>) to (<i>a</i><span class="symbol">′</span>, <i>b</i><span class="symbol">′</span>, <i>c</i><span class="symbol">′</span>, <i>d</i><span class="symbol">′</span>), which we define as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg66-1.jpg" alt="" width="1386" height="236"/></figure>&#13;
<p class="TX">In these equations, we interpret the numbers 2 and 253 as binary polynomials rather than integers; hence, we define additions and multiplications a bit differently than what we’re used to. For example, instead of having 2 + 2 = 4, we have 2 + 2 = 0. Regardless, each byte in the initial state affects all 4 bytes in the final state.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Feistel Schemes</samp></h4>&#13;
<p class="TNI">In the 1970s, IBM engineer Horst Feistel designed a block cipher, Lucifer, that works as follows:</p>&#13;
<p class="NLF">  1.  Split the 64-bit block into two 32-bit halves, <i>L</i> and <i>R</i>.</p>&#13;
<p class="NL">  2.  Set <i>L</i> to <i>L</i> <span class="symbol">⊕</span> <b>F</b>(<i>R</i>), where <b>F</b> is a substitution–permutation round.</p>&#13;
<p class="NL">  3.  Swap the values of <i>L</i> and <i>R</i>.</p>&#13;
<p class="NL">  4.  Go to step 2 and repeat 15 times.</p>&#13;
<p class="NLL">  5.  Merge <i>L</i> and <i>R</i> into the 64-bit output block.</p>&#13;
<p class="TX">This construction is a <i>Feistel scheme</i>, as <a href="chapter4.xhtml#fig4-2">Figure 4-2</a> shows. The left side is the scheme as just described; the right side is a functionally equivalent representation where, instead of swapping <i>L</i> and <i>R</i>, rounds alternate the operations <i>L</i> = <i>L</i> <span class="symbol">⊕</span> <b>F</b>(<i>R</i>) and <i>R</i> = <i>R</i> <span class="symbol">⊕</span> <b>F</b>(<i>L</i>).</p>&#13;
<figure class="IMG"><img id="fig4-2" class="img5" src="../images/fig4-2.jpg" alt="" width="520" height="447"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The Feistel scheme block cipher construction in two equivalent forms</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">I’ve omitted the keys from <a href="chapter4.xhtml#fig4-2">Figure 4-2</a> to simplify the diagrams, but note that the first <b>F</b> takes a round key, <i>K</i><sub>1</sub>, and the second <b>F</b> takes another round <span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/>key, <i>K</i><sub>2</sub>. In DES, the <b>F</b> functions take a 48-bit round key, which it derives from the 56-bit key, <i>K</i>.</p>&#13;
<p class="TX">In a Feistel scheme, the <b>F</b> function can be either a pseudorandom permutation (PRP) or a pseudorandom function (PRF). A PRP yields distinct outputs for any two distinct inputs, whereas a PRF will have values <i>X</i> and <i>Y</i> for which <b>F</b>(<i>X</i>) = <b>F</b>(<i>Y</i>). But in a Feistel scheme, that difference doesn’t matter as long as <b>F</b> is cryptographically strong.</p>&#13;
<p class="TX">How many rounds should there be in a Feistel scheme? Well, DES performs 16 rounds, whereas GOST 28147-89 performs 32 rounds. If the <b>F</b> function is as strong as possible, four rounds are sufficient in theory, but real ciphers use more rounds to defend against potential weaknesses in <b>F</b>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H1" id="sec10"><span id="h1-31"/><samp class="SANS_Futura_Std_Bold_B_11">The Advanced Encryption Standard</samp></h3>&#13;
<p class="TNI">AES is the most-used cipher in the world. Prior to the adoption of AES, the standard cipher in use was DES, with its ridiculous 56-bit security, as well as the upgraded version of DES known as Triple DES, or 3DES. Although 3DES provides a higher level of security (112-bit security), it’s inefficient because the key needs to be 168 bits long to get 112-bit security, and it’s slow in software (DES was created to be fast in integrated circuits, not on mainstream CPUs). AES fixes both issues.</p>&#13;
<p class="TX">NIST standardized AES in 2000 as a replacement for DES, at which point it became the world’s de facto encryption standard. Most commercial encryption products today support AES, and the NSA has approved it for protecting top-secret information. (Some countries do prefer to use their own ciphers, largely because they don’t want to use a US standard, but AES is actually more Belgian than it is American.)</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>AES went by the name</i> <span class="note_Italic">Rijndael</span> <i>(a portmanteau for its inventors’ names, Rijmen and Daemen, pronounced like “rain-dull”) when it was one of the 15 candidates in the AES competition, the process held by NIST from 1997 to 2000 to specify “an unclassified, publicly disclosed encryption algorithm capable of protecting sensitive government information well into the next century,” as stated in the 1997 announcement of the competition in the</i> Federal Register. <i>The AES competition was a kind of “Got Talent” competition for cryptographers, where anyone could participate by submitting a cipher or breaking other contestants’ ciphers.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-53"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Internals</samp></h4>&#13;
<p class="TNI">AES processes blocks of 128 bits using a secret key of 128, 192, or 256 bits, with the 128-bit key being the most common because it makes encryption slightly faster and because the difference between 128- and 256-bit security is meaningless for most applications.</p>&#13;
<p class="TX">Whereas some ciphers work with individual bits or 64-bit words, AES manipulates <i>bytes</i>. It views a 16-byte plaintext as a two-dimensional array of bytes (<i>s</i> = <i>s</i><sub>0</sub>, <i>s</i><sub>1</sub>, . . . , <i>s</i><sub>15</sub>), as <a href="chapter4.xhtml#fig4-3">Figure 4-3</a> illustrates. (We use the letter <i>s</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label="68"/>because this array is the <i>internal state</i>, or just <i>state</i>.) AES transforms the bytes, columns, and rows of this array to produce a final value that is the ciphertext.</p>&#13;
<figure class="IMG"><img id="fig4-3" class="img5" src="../images/fig4-3.jpg" alt="" width="413" height="413"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The internal state of AES as a 4×4 array of 16 bytes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To transform its state, AES uses an SPN structure as in <a href="chapter4.xhtml#fig4-4">Figure 4-4</a>, with 10 rounds for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.</p>&#13;
<figure class="IMG"><img id="fig4-4" class="img5" src="../images/fig4-4.jpg" alt="" width="534" height="1001"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The internal operations of AES</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter4.xhtml#fig4-4">Figure 4-4</a> shows the four building blocks of an AES round (note that all but the last round are a sequence of SubBytes, ShiftRows, MixColumns, and AddRoundKey):</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label="69"/><b>AddRoundKey </b>XORs a round key to the internal state.</p>&#13;
<p class="RunInPara"><b>SubBytes </b>Replaces each byte (<i>s</i><sub>0</sub>, <i>s</i><sub>1</sub> . . . , <i>s</i><sub>15</sub>) with another byte according to an S-box. In this example, the S-box is a lookup table of 256 elements.</p>&#13;
<p class="RunInPara"><b>ShiftRows </b>Shifts the <i>i</i>th row of <i>i</i> positions, for <i>i</i> ranging from 0 to 3 (see <a href="chapter4.xhtml#fig4-5">Figure 4-5</a>).</p>&#13;
<p class="RunInPara"><b>MixColumns </b>Applies the same linear transformation to each of the four columns of the state (that is, each group of cells with the same shade of gray, as on the left side of <a href="chapter4.xhtml#fig4-5">Figure 4-5</a>).</p>&#13;
<figure class="IMG"><img id="fig4-5" class="img7" src="../images/fig4-5.jpg" alt="" width="957" height="413"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: ShiftRows rotates bytes within each row of the internal state.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Remember that in an SPN, the <i>S</i> stands for substitution and the <i>P</i> for permutation. Here, the substitution layer is SubBytes, and the permutation layer is the combination of ShiftRows and MixColumns.</p>&#13;
<p class="TX">The key schedule function KeyExpansion, as <a href="chapter4.xhtml#fig4-4">Figure 4-4</a> shows, is the AES key schedule algorithm. This expansion creates 11 round keys (<i>K</i><sub>0</sub>, <i>K</i><sub>1</sub>, . . . , <i>K</i><sub>10</sub>) of 16 bytes each from the 16-byte key, using the same S-box as SubBytes and a combination of XORs. One important property of KeyExpansion is that given any round key, <i>K</i><span class="ePub-I-SUB">i</span>, an attacker can determine all other round keys as well as the main key, <i>K</i>, by reversing the algorithm. The ability to get the key from any round key reduces the cipher’s resistance to side-channel attacks, where an attacker may easily recover a round key.</p>&#13;
<p class="TX">Without these operations, AES would be totally insecure. Each operation contributes to AES’s security in a specific way:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Without KeyExpansion, all rounds would use the same key, <i>K</i>, and AES would be vulnerable to slide attacks.</li>&#13;
<li class="BL">Without AddRoundKey, encryption wouldn’t depend on the key; hence, anyone could decrypt any ciphertext without the key.</li>&#13;
<li class="BL">SubBytes brings nonlinear operations, which add cryptographic strength. Without it, AES would just be a large system of linear equations that can be solved using high school algebra (namely, Gaussian elimination).</li>&#13;
<li class="BL">Without ShiftRows, changes in a given column would never affect the other columns, meaning you could break AES by building four 2<sup>32</sup>-element codebooks for each column. (Remember that in a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label="70"/>secure block cipher, flipping a bit in the input should affect all the output bits.)</li>&#13;
<li class="BL">Without MixColumns, changes in a byte wouldn’t affect any other bytes of the state. A chosen-plaintext attacker could then decrypt any ciphertext after storing 16 lookup tables of 256 bytes each that hold the encrypted values of each possible value of a byte.</li>&#13;
</ul>&#13;
<p class="TX">Notice in <a href="chapter4.xhtml#fig4-4">Figure 4-4</a> that the last round of AES doesn’t include the MixColumns operation. That operation is omitted to save useless computation: because MixColumns is linear, you could cancel its effect in the very last round by combining bits in a way that doesn’t depend on their value or the key. However, we can’t invert SubBytes without the state’s value being known prior to AddRoundKey.</p>&#13;
<p class="TX">To decrypt a ciphertext, AES unwinds each operation by taking its inverse function: the inverse lookup table of SubBytes reverses the SubBytes transformation, ShiftRow shifts in the opposite direction, MixColumns’s inverse is applied (as in the matrix inverse of the matrix encoding its operation), and AddRoundKey’s XOR is unchanged because the inverse of an XOR is another XOR.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-54"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES in Action</samp></h4>&#13;
<p class="TNI">As an exercise, you can use Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">cryptography</samp> library to encrypt and decrypt a block of data with AES, as in <a href="chapter4.xhtml#Lis4-1">Listing 4-1</a>.</p>&#13;
<span id="Lis4-1"/><pre><code>from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes&#13;
from os import urandom&#13;
&#13;
BLOCK_SIZE = 16&#13;
KEY_SIZE = 16&#13;
&#13;
# Pick a random 16-byte key using Python's crypto PRNG.&#13;
k = urandom(KEY_SIZE)&#13;
print(f"k = {k.hex()}")&#13;
&#13;
# Create an instance of AES-128.&#13;
aes = Cipher(algorithms.AES(k), modes.ECB())&#13;
aes_ecb_encryptor = aes.encryptor()&#13;
&#13;
# Set plaintext p to the all-zero string.&#13;
p = bytes([0x00] * BLOCK_SIZE)&#13;
&#13;
# Encrypt plaintext p to ciphertext c.&#13;
c = aes_ecb_encryptor.update(p) + aes_ecb_encryptor.finalize()&#13;
print(f"enc({p.hex()}) = {c.hex()}")&#13;
&#13;
# Decrypt ciphertext c to plaintext p.&#13;
aes_ecb_decryptor = aes.decryptor()&#13;
p = aes_ecb_decryptor.update(c) + aes_ecb_decryptor.finalize()&#13;
print(f"dec({c.hex()}) = {p.hex()}")</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: AES encryption and decryption of a block in Python</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label="71"/>Running this script produces something like the following output:</p>&#13;
<pre><code>$ <b>./aes_block.py</b>&#13;
k = 2c6202f9a582668aa96d511862d8a279&#13;
enc(00000000000000000000000000000000) = 12b620bb5eddcde9a07523e59292a6d7&#13;
dec(12b620bb5eddcde9a07523e59292a6d7) = 00000000000000000000000000000000</code></pre>&#13;
<p class="TX">You’ll get different results because the key is randomized at every new execution.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H1" id="sec13"><span id="h1-32"/><samp class="SANS_Futura_Std_Bold_B_11">How to Implement AES</samp></h3>&#13;
<p class="TNI">Real AES software works differently than the algorithm in <a href="chapter4.xhtml#fig4-4">Figure 4-4</a>. You won’t find production-level AES code calling a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubBytes()</samp> function, then a <samp class="SANS_TheSansMonoCd_W5Regular_11">ShiftRows()</samp> function, and then a <samp class="SANS_TheSansMonoCd_W5Regular_11">MixColumns()</samp> function because that would be inefficient. Instead, fast AES software uses table-based implementations and native instructions.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-55"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Table-Based Implementations</samp></h4>&#13;
<p class="TNI">Table-based implementations of AES replace the sequence SubBytes-ShiftRows-MixColumns with a combination of XORs and lookups in tables hardcoded into the program and loaded in memory at execution time. This is possible because MixColumns is equivalent to XORing four 32-bit values, where each depends on a single byte from the state and on SubBytes. Thus, you can build four tables with 256 entries each, one for each byte value, and implement the sequence SubBytes-MixColumns by looking up four 32-bit values and XORing them together.</p>&#13;
<p class="TX">For example, the table-based C implementation in the OpenSSL toolkit looks like <a href="chapter4.xhtml#Lis4-2">Listing 4-2</a>.</p>&#13;
<span id="Lis4-2"/><pre><code>  /* Round 1: */&#13;
  t0 = Te0[s0 &gt;&gt; 24] ^ Te1[(s1 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s2 &gt;&gt; 8) &amp; 0xff] ^ Te3[s3 &amp; 0xff] ^ rk[4];&#13;
  t1 = Te0[s1 &gt;&gt; 24] ^ Te1[(s2 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s3 &gt;&gt; 8) &amp; 0xff] ^ Te3[s0 &amp; 0xff] ^ rk[5];&#13;
  t2 = Te0[s2 &gt;&gt; 24] ^ Te1[(s3 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s0 &gt;&gt; 8) &amp; 0xff] ^ Te3[s1 &amp; 0xff] ^ rk[6];&#13;
  t3 = Te0[s3 &gt;&gt; 24] ^ Te1[(s0 &gt;&gt; 16) &amp; 0xff] ^ Te2[(s1 &gt;&gt; 8) &amp; 0xff] ^ Te3[s2 &amp; 0xff] ^ rk[7];&#13;
  /* Round 2: */&#13;
  s0 = Te0[t0 &gt;&gt; 24] ^ Te1[(t1 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t2 &gt;&gt; 8) &amp; 0xff] ^ Te3[t3 &amp; 0xff] ^ rk[8];&#13;
  s1 = Te0[t1 &gt;&gt; 24] ^ Te1[(t2 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t3 &gt;&gt; 8) &amp; 0xff] ^ Te3[t0 &amp; 0xff] ^ rk[9];&#13;
  s2 = Te0[t2 &gt;&gt; 24] ^ Te1[(t3 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t0 &gt;&gt; 8) &amp; 0xff] ^ Te3[t1 &amp; 0xff] ^ rk[10];&#13;
  s3 = Te0[t3 &gt;&gt; 24] ^ Te1[(t0 &gt;&gt; 16) &amp; 0xff] ^ Te2[(t1 &gt;&gt; 8) &amp; 0xff] ^ Te3[t2 &amp; 0xff] ^ rk[11];&#13;
<var>--snip--</var></code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: An excerpt of the table-based C implementation of AES in OpenSSL</samp></p>&#13;
<p class="TX">A basic table-based implementation of AES encryption needs four 4KB’s worth of tables because each table stores 256 32-bit values, which occupy 256 × 32 = 8,192 bits, or 1KB. Decryption requires another four tables and thus 4KB more. But there are tricks to reduce the storage from 4KB to 1, or even less.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label="72"/>Alas, table-based implementations are vulnerable to <i>cache-timing attacks</i>, which exploit timing variations when a program reads or writes elements in cache memory. Access time varies depending on the relative position in cache memory of the accessed elements. Timings thus leak information about the accessed element, which in turn leaks information on the secrets involved.</p>&#13;
<p class="TX">Cache-timing attacks are difficult to avoid. One obvious solution would be to ditch lookup tables altogether by writing a program whose execution time doesn’t depend on its inputs, but that’s almost impossible to do and still retain the same speed, so chip manufacturers have opted for a radical solution: instead of relying on potentially vulnerable software, they rely on <i>hardware</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Native Instructions</samp></h4>&#13;
<p class="TNI">AES native instructions (AES-NI) solve the problem of cache-timing attacks on AES software implementations. To understand how AES-NI works, think about the way software runs on hardware: to run a program, a microprocessor translates binary code into a series of instructions that integrated circuit components execute. For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">MUL</samp> assembly instruction between two 32-bit values will activate the transistors implementing a 32-bit multiplier in the microprocessor. To implement a crypto algorithm, we usually express a combination of basic operations—additions, multiplications, XORs, and so on—and the microprocessor activates its adders, multipliers, and XOR circuits in the prescribed order.</p>&#13;
<p class="TX">AES native instructions take this to a whole new level by providing developers with dedicated assembly instructions that compute AES. Instead of coding an AES round as a sequence of assembly instructions, when using AES-NI, you just call the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">AESENC</samp>, and the chip computes the round for you. Native instructions allow you to tell the processor to run an AES round instead of requiring you to program rounds as a combination of basic operations.</p>&#13;
<p class="TX">A typical assembly implementation of AES using native instructions looks like <a href="chapter4.xhtml#Lis4-3">Listing 4-3</a>.</p>&#13;
<span id="Lis4-3"/><pre><code>PXOR       %xmm5,  %xmm0&#13;
AESENC     %xmm6,  %xmm0&#13;
AESENC     %xmm7,  %xmm0&#13;
AESENC     %xmm8,  %xmm0&#13;
AESENC     %xmm9,  %xmm0&#13;
AESENC     %xmm10, %xmm0&#13;
AESENC     %xmm11, %xmm0&#13;
AESENC     %xmm12, %xmm0&#13;
AESENC     %xmm13, %xmm0&#13;
AESENC     %xmm14, %xmm0&#13;
AESENCLAST %xmm15, %xmm0</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: An implementation of AES-128 using AES native instructions</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label="73"/>This code encrypts the 128-bit plaintext initially in the register <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>, assuming that registers <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm5</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm15</samp> hold the precomputed round keys, with each instruction writing its result into <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>. The initial <samp class="SANS_TheSansMonoCd_W5Regular_11">PXOR</samp> instruction XORs the first round key prior to computing the first round, and the final <samp class="SANS_TheSansMonoCd_W5Regular_11">AESENCLAST</samp> instruction performs the last round slightly differently from the others (MixColumns is omitted).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT0"><i>AES is about 10 times faster on platforms that implement native instructions, which, as I write this, include virtually all laptop, desktop, and server microprocessors, as well as most mobile phones and tablets. Although Intel originally proposed AES instructions in 2008, they’re also available in AMD processors, and most architectures other than x86 also have equivalent instructions implementing AES in hardware. For example, the Armv8 instruction set contains the instructions <samp class="SANS_TheSansMonoCd_W5Regular_11"><i>AESSE</i></samp> (which calculates SubBytes and ShiftRows) and <samp class="SANS_TheSansMonoCd_W5Regular_11"><i>AESMS</i></samp> (which calculates MixColumns).</i></p>&#13;
<p class="NoteContinued"><i>On Intel’s Ice Lake microarchitecture, the <samp class="SANS_TheSansMonoCd_W5Regular_11"><i>AESENC</i></samp> instruction has a latency of three cycles with a reciprocal throughput of half a cycle, meaning that a call to <samp class="SANS_TheSansMonoCd_W5Regular_11"><i>AESENC</i></samp> takes three cycles to complete, and we can make two new calls to the instruction in each cycle. In fact, the internal structure of the micro-operations performing the <samp class="SANS_TheSansMonoCd_W5Regular_11"><i>AESENC</i></samp> operation means that a new instruction computation can start before the previous one has finished. What’s more, the Ice Lake architecture uses a vectorized version of AES instructions, enabling several to be initiated at the same time. For more details, see the article “Making AES Great Again” by Nir Drucker, Shay Gueron, and Vlad Krasnov, available at</i> <span class="note_LinkURL"><a href="https://eprint.iacr.org/2018/392">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2018<wbr/>/392</a></span><i>.</i></p>&#13;
<p class="NoteContinued"><i>To encrypt a series of blocks one after the other, it takes 3 × 10 = 30 cycles to complete the 10 rounds, or 30 / 16 = 1.875 cycles per byte. At a frequency of 2 GHz (2 × 10</i><i><sup>9</sup></i> <i>cycles per second), this gives a theoretical maximum throughput of around 1GBps. If you can process blocks in parallel, then you don’t need one complete <samp class="SANS_TheSansMonoCd_W5Regular_11"><i>AESENC</i></samp> call before starting another. In this case, you can make two <samp class="SANS_TheSansMonoCd_W5Regular_11"><i>AESENC</i></samp> calls per cycle and obtain two results per cycle, offering a much higher theoretical throughput (up to more than 10GBps, at 2 GHz), depending on the data size and mode of operation.</i></p>&#13;
</blockquote>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-57"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Security</samp></h4>&#13;
<p class="TNI">AES is as secure as a block cipher can be, and it will never be broken. Fundamentally, AES is secure because all output bits depend on all input bits in some complex, pseudorandom way. To achieve this, the designers of AES carefully chose each component for a particular reason—MixColumns for its maximal diffusion properties and SubBytes for its optimal nonlinearity. This composition protects AES against whole classes of cryptanalytic attacks.</p>&#13;
<p class="TX">But there’s no proof that AES is immune to all possible attacks. For one thing, we don’t know what all possible attacks are, and we don’t always know how to prove that a cipher is secure against a given attack. The only way to really gain confidence in the security of AES is to crowdsource attacks: have many skilled people attempt to break AES and, ideally, fail to do so.</p>&#13;
<p class="TX">After more than 15 years and hundreds of research publications, we’ve only scratched the surface of the theoretical security of AES. In 2011, cryptanalysts found a way to recover an AES-128 key by performing about <span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label="74"/>2<sup>126</sup> operations instead of 2<sup>128</sup>, a speedup of a factor of 4. But this “attack” requires a high number of plaintext–ciphertext pairs—about 2<sup>88</sup> bits’ worth. It’s a nice finding but not one you need to worry about.</p>&#13;
<p class="TX">You should care about a million things when implementing and deploying crypto, but AES security is not one of them. The biggest threat to block ciphers isn’t in their core algorithms but in their modes of operation. If you’ve chosen an incorrect mode or misused the right one, even a strong cipher like AES won’t save you.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H1" id="sec17"><span id="h1-33"/><samp class="SANS_Futura_Std_Bold_B_11">Modes of Operation</samp></h3>&#13;
<p class="TNI">In <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, I explained how encryption schemes combine a permutation with a mode of operation to handle messages of any length. In this section, I’ll cover the main modes of operations that block ciphers use, their security and functional properties, and how (not) to use them. I’ll begin with the dumbest one: electronic codebook.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-58"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Electronic Codebook Mode</samp></h4>&#13;
<p class="TNI">The simplest of the block cipher encryption modes is electronic codebook (ECB), which is barely a mode of operation at all. ECB takes plaintext blocks <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, . . . , <i>P</i><span class="ePub-I-SUB">N</span> and processes each independently by computing <i>C</i><sub>1</sub> = <b>E</b>(<i>K</i>, <i>P</i><sub>1</sub>), <i>C</i><sub>2</sub> = <b>E</b>(<i>K</i>, <i>P</i><sub>2</sub>), and so on, as <a href="chapter4.xhtml#fig4-6">Figure 4-6</a> shows. It’s a simple operation but also an insecure one—ECB is insecure, and you shouldn’t use it.</p>&#13;
<figure class="IMG"><img id="fig4-6" class="img5" src="../images/fig4-6.jpg" alt="" width="425" height="344"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: ECB mode</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Marsh Ray, a cryptographer at Microsoft, once said, “Everybody knows ECB mode is bad because we can see the penguin.” He was referring to a famous illustration of ECB’s insecurity that uses an image of Linux’s mascot, Tux, as in <a href="chapter4.xhtml#fig4-7">Figure 4-7</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label="75"/>&#13;
<figure class="IMG"><img id="fig4-7" class="img7" src="../images/fig4-7.jpg" alt="" width="1012" height="598"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: The original image (left) and the ECB-encrypted image (right)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The original image of Tux is on the left, and the ECB-encrypted image that uses AES (though the underlying cipher doesn’t matter) is on the right. It’s easy to see the penguin’s shape in the encrypted version because ECB encrypted all the blocks of one shade of gray in the original image to the same new shade of gray in the new image; in other words, ECB encryption gives you the same image with different colors.</p>&#13;
<p class="TX">The Python program in <a href="chapter4.xhtml#Lis4-4">Listing 4-4</a> also shows ECB’s insecurity. It picks a pseudorandom key and encrypts a 32-byte message <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> containing two blocks of null bytes. Notice that encryption yields two identical blocks and that repeating encryption with the same key and the same plaintext yields the same two blocks again.</p>&#13;
<span id="Lis4-4"/><pre><code>#!/usr/bin/env python&#13;
&#13;
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes&#13;
from os import urandom&#13;
&#13;
BLOCK_SIZE = 16&#13;
KEY_SIZE = 16&#13;
&#13;
# The blocks() function splits a data string into space-separated blocks.&#13;
def blocks(data):&#13;
    split = [data[i:i+BLOCK_SIZE].hex() for i in range(0, len(data), BLOCK_SIZE)]&#13;
    return ' '.join(split)&#13;
k = urandom(KEY_SIZE)&#13;
print(f"k = {k.hex()}")&#13;
&#13;
# Create an instance of AES-128 to encrypt and decrypt.&#13;
aes = Cipher(algorithms.AES(k), modes.ECB())&#13;
aes_ecb_encryptor = aes.encryptor()&#13;
&#13;
# Set plaintext p as two blocks of zeros.&#13;
p = bytes([0x00] * 2 * BLOCK_SIZE)&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label="76"/># Encrypt plaintext p to ciphertext c.&#13;
c = aes_ecb_encryptor.update(p) + aes_ecb_encryptor.finalize()&#13;
print(f"enc({blocks(p)}) = {blocks(c)}")</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Using AES in ECB mode in Python</samp></p>&#13;
<p class="TX">Running this script gives ciphertext blocks like this example:</p>&#13;
<pre><code>$ <b>./aes_ecb.py</b>&#13;
k = 50a0ebeff8001250e87d31d72a86e46d&#13;
enc(00000000000000000000000000000000 00000000000000000000000000000000) =&#13;
5eb4b7af094ef7aca472bbd3cd72f1ed 5eb4b7af094ef7aca472bbd3cd72f1ed</code></pre>&#13;
<p class="TX">When using the ECB mode, identical ciphertext blocks reveal identical plaintext blocks to an attacker, whether those are blocks within a single ciphertext or across different ciphertexts. This shows that block ciphers in ECB mode aren’t semantically secure.</p>&#13;
<p class="TX">Another problem with ECB is that it takes only complete blocks of data, so if blocks were 16 bytes, as in AES, you could encrypt only chunks of 16 bytes, 32 bytes, 48 bytes, or any other multiple of 16 bytes. There are a few ways to deal with this, as you’ll see with the next mode, CBC. (I won’t tell you how these tricks work with ECB because you shouldn’t use ECB in the first place.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cipher Block Chaining Mode</samp></h4>&#13;
<p class="TNI">Cipher block chaining (CBC) is like ECB but with a small twist that makes a big difference: instead of encrypting the <i>i</i>th block, <i>P</i><span class="ePub-I-SUB">i</span>, as <i>C</i><span class="ePub-I-SUB">i</span> = <b>E</b>(<i>K</i>, <i>P</i><span class="ePub-I-SUB">i</span>), CBC sets <i>C</i><span class="ePub-I-SUB">i</span> = <b>E</b>(<i>K</i>, <i>P</i><span class="ePub-I-SUB">i</span> <span class="symbol">⊕</span> <i>C</i><span class="ePub-I-SUB">i</span> <sub>− 1</sub>), where <i>C</i><span class="ePub-I-SUB">i</span> <sub>− 1</sub> is the previous ciphertext block—thereby <i>chaining</i> the blocks <i>C</i><span class="ePub-I-SUB">i</span> <sub>− 1</sub> and <i>C</i><span class="ePub-I-SUB">i</span>. When encrypting the first block, <i>P</i><sub>1</sub>, there is no previous ciphertext block to use, so CBC takes a random initial value (IV), as <a href="chapter4.xhtml#fig4-8">Figure 4-8</a> illustrates.</p>&#13;
<figure class="IMG"><img id="fig4-8" class="img5" src="../images/fig4-8.jpg" alt="" width="554" height="343"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: CBC mode</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">CBC mode makes each ciphertext block dependent on all the previous blocks and ensures that identical plaintext blocks won’t be identical ciphertext blocks. The random initial value guarantees that two identical plaintexts will encrypt to distinct ciphertexts when calling the cipher twice with two distinct initial values.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label="77"/><a href="chapter4.xhtml#Lis4-5">Listing 4-5</a> illustrates these two benefits. This program takes an all-zero, 32-byte message (like the one in <a href="chapter4.xhtml#Lis4-4">Listing 4-4</a>), encrypts it twice with CBC, and shows the two ciphertexts. The bolded line <samp class="SANS_TheSansMonoCd_W5Regular_11">iv = urandom(BLOCK _SIZE)</samp> picks a new random IV for each new encryption.</p>&#13;
<span id="Lis4-5"/><pre><code>#!/usr/bin/env python&#13;
&#13;
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes&#13;
from os import urandom&#13;
&#13;
BLOCK_SIZE = 16&#13;
KEY_SIZE = 16&#13;
&#13;
# The blocks() function splits a data string into space-separated blocks.&#13;
def blocks(data):&#13;
    split = [data[i:i+BLOCK_SIZE].hex() for i in range(0, len(data), BLOCK_SIZE)]&#13;
    return ' '.join(split)&#13;
&#13;
# Pick a random key.&#13;
k = urandom(KEY_SIZE)&#13;
print(f"k  = {k.hex()}")&#13;
&#13;
# Pick a random IV.&#13;
<b>iv = urandom(BLOCK_SIZE)</b>&#13;
print(f"iv = {iv.hex()}")&#13;
&#13;
# Pick an instance of AES in CBC mode.&#13;
aes_cbc_encryptor = Cipher(algorithms.AES(k), modes.CBC(iv)).encryptor()&#13;
&#13;
# Set plaintext p as two blocks of zeros.&#13;
p = bytes([0x00] * 2 * BLOCK_SIZE)&#13;
&#13;
c = aes_cbc_encryptor.update(p) + aes_cbc_encryptor.finalize()&#13;
print(f"enc({blocks(p)}) = {blocks(c)}")&#13;
&#13;
# Now with a different IV and the same key&#13;
<b>iv = urandom(BLOCK_SIZE)</b>&#13;
print(f"iv = {iv.hex()}")&#13;
&#13;
aes_cbc_encryptor = Cipher(algorithms.AES(k), modes.CBC(iv)).encryptor()&#13;
c = aes_cbc_encryptor.update(p) + aes_cbc_encryptor.finalize()&#13;
print(f"enc({blocks(p)}) = {blocks(c)}")</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Using AES in CBC mode</samp></p>&#13;
<p class="TX">The two plaintexts are the same (two all-zero blocks), but the encrypted blocks should be distinct, as in this example execution:</p>&#13;
<pre><code>$ <b>./aes_cbc.py</b>&#13;
k = 9cf0d31ad2df24f3cbbefc1e6933c872&#13;
iv = 0a75c4283b4539c094fc262aff0d17af&#13;
enc(00000000000000000000000000000000 00000000000000000000000000000000) =&#13;
370404dcab6e9ecbc3d24ca5573d2920 3b9e5d70e597db225609541f6ae9804a&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label="78"/>iv = a6016a6698c3996be13e8739d9e793e2&#13;
enc(00000000000000000000000000000000 00000000000000000000000000000000) =&#13;
655e1bb3e74ee8cf9ec1540afd8b2204 b59db5ac28de43b25612dfd6f031087a</code></pre>&#13;
<p class="TX">Alas, we often use CBC with a constant IV instead of a random one, which exposes identical plaintexts and plaintexts that start with identical blocks. For example, say CBC encrypts the two-block plaintext <i>P</i><sub>1</sub> || <i>P</i><sub>2</sub> to the two-block ciphertext <i>C</i><sub>1</sub> || <i>C</i><sub>2</sub>. If CBC encrypts <i>P</i><sub>1</sub> || <i>P</i><sub>2</sub><span class="symbol">′</span> with the same IV, where <i>P</i><sub>2</sub><span class="symbol">′</span> is some block distinct from <i>P</i><sub>2</sub>, then the ciphertext will look like <i>C</i><sub>1</sub> || <i>C</i><sub>2</sub><span class="symbol">′</span>, with <i>C</i><sub>2</sub><span class="symbol">′</span> different from <i>C</i><sub>2</sub> but with the same first block <i>C</i><sub>1</sub>. Thus, an attacker can guess that the first block is the same for both plaintexts, even though they see only the ciphertexts.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In CBC mode, decryption needs to know the IV used to encrypt, so the IV is sent along with the ciphertext, in the clear.</i></p>&#13;
<p class="TX">With CBC, decryption can be much faster than encryption due to parallelism. While encryption of a new block, <i>P</i><span class="ePub-I-SUB">i</span>, needs to wait for the previous block, <i>C</i><span class="ePub-I-SUB">i</span> <sub>− 1</sub>, decryption of a block computes <i>P</i><span class="ePub-I-SUB">i</span> = <b>D</b>(<i>K</i>, <i>C</i><span class="ePub-I-SUB">i</span>) <span class="symbol">⊕</span> <i>C</i><span class="ePub-I-SUB">i</span> <sub>− 1</sub>, where there’s no need for the previous plaintext block, <i>P</i><span class="ePub-I-SUB">i</span> <sub>− 1</sub>. This means you can decrypt all blocks in parallel simultaneously, as long as you know the previous ciphertext block, which you usually will.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h4 class="H2" id="sec20"><span id="h2-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Message Encryption in CBC Mode</samp></h4>&#13;
<p class="TNI">Let’s circle back to the block termination issue and look at how to process a plaintext whose length is not a multiple of the block length. For example, how would you encrypt an 18-byte plaintext with AES-CBC when blocks are 16 bytes? What do you do with the 2 bytes left? You’ll look at two widely used techniques to deal with this problem. The first one, padding, makes the ciphertext a bit longer than the plaintext, while the second one, <i>ciphertext stealing</i>, produces a ciphertext of the same length as the plaintext.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Message Padding</samp></h5>&#13;
<p class="TNI">Padding is a technique that allows you to encrypt a message of any length, even one smaller than a single block. The PKCS#7 standard and RFC 5652 specify padding for block ciphers, which we use almost everywhere we use CBC.</p>&#13;
<p class="TX">We use padding to expand a message to fill a complete block by adding extra bytes to the plaintext. Here are the rules for padding 16-byte blocks:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If there’s 1 byte left—for example, if the plaintext is 1 byte, 17 bytes, or 33 bytes long—pad the message with 15 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0f</samp> (15 in decimal).</li>&#13;
<li class="BL">If there are 2 bytes left, pad the message with 14 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0e</samp> (14 in decimal).</li>&#13;
<li class="BL">If there are 3 bytes left, pad the message with 13 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0d</samp> (13 in decimal).</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label="79"/>If there are 15 plaintext bytes and a single byte missing to fill a block, padding adds a single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. If the plaintext is already a multiple of 16, the block length, add 16 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> (16 in decimal). The trick generalizes to any block length up to 255 bytes (for larger blocks, a byte is too small to encode values greater than 255).</p>&#13;
<p class="TX">Decryption of a padded message works like this:</p>&#13;
<p class="NLF">  1.  Decrypt all the blocks as with unpadded CBC.</p>&#13;
<p class="NLL">  2.  Make sure that the last bytes of the last block conform to the padding rule: that they finish with at least one <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte, at least two <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes, or at least three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> bytes, and so on. If the padding isn’t valid—for example, if the last bytes are <samp class="SANS_TheSansMonoCd_W5Regular_11">01 02 03</samp>—the message is rejected. Otherwise, decryption strips the padding bytes and returns the plaintext bytes left.</p>&#13;
<p class="TX">One downside of padding is that it makes ciphertext longer by at least 1 byte and at most a block.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ciphertext Stealing</samp></h5>&#13;
<p class="TNI">Ciphertext stealing is another trick we use to encrypt a message whose length isn’t a multiple of the block size. Ciphertext stealing is more complex and less popular than padding, but it offers a few benefits:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Plaintexts can be of any <i>bit</i> length, not just bytes. You can, for example, encrypt a message of 131 bits.</li>&#13;
<li class="BL">Ciphertexts are exactly the same length as plaintexts.</li>&#13;
<li class="BL">Ciphertext stealing is not vulnerable to padding oracle attacks, powerful attacks that sometimes work against CBC with padding (as you’ll see in “<span class="listbullet_Xref">Padding Oracle Attacks</span>” on <a href="#sec26">page 83</a>).</li>&#13;
</ul>&#13;
<p class="TX">In CBC mode, ciphertext stealing extends the last incomplete plaintext block with bits from the previous ciphertext block and then encrypts the resulting block. The last, incomplete ciphertext block is made up of the first bits from the previous ciphertext block—that is, the bits that haven’t been appended to the last plaintext block.</p>&#13;
<p class="TX">In <a href="chapter4.xhtml#fig4-9">Figure 4-9</a>, we have three blocks, where the last block, <i>P</i><sub>3</sub>, is incomplete (represented by a zero). If <i>P</i><sub>3</sub> is 3 bytes, we XOR it with the last 12 bits from the previous ciphertext block <b>E</b>(<i>K</i>, <i>P</i><sub>2</sub>) and return the encrypted result as <i>C</i><sub>2</sub>. The last ciphertext block, <i>C</i><sub>3</sub>, then consists of the first 4 bytes of <b>E</b>(<i>K</i>, <i>P</i><sub>2</sub>). Decryption is simply the inverse of this operation.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label="80"/>&#13;
<figure class="IMG"><img id="fig4-9" class="img5" src="../images/fig4-9.jpg" alt="" width="552" height="496"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: Ciphertext stealing for CBC-mode encryption</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">There aren’t any major problems with ciphertext stealing, but it’s inelegant and hard to get right, especially when NIST’s standard specifies three different ways to implement it (see Special Publication 800-38A).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2" id="sec23"><span id="h2-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Counter Mode</samp></h4>&#13;
<p class="TNI">To avoid the troubles and retain the benefits of ciphertext stealing, use counter mode (CTR). CTR is hardly a block cipher mode: it turns a block cipher into a stream cipher that just takes bits in and spits bits out and doesn’t embarrass itself with the notion of blocks. (I’ll discuss stream ciphers in detail in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>.)</p>&#13;
<p class="TX">In CTR mode (see <a href="chapter4.xhtml#fig4-10">Figure 4-10</a>), the block cipher algorithm won’t transform plaintext data. Instead, it encrypts blocks composed of a counter and a nonce. A <i>counter</i> is an integer that is incremented for each block. No two blocks should use the same counter within a message, but different messages can use the same sequence of counter values (1, 2, 3, . . .). A <i>nonce</i> is a number we use only once. It’s the same for all blocks in a single message, but no two messages should use the same nonce.</p>&#13;
<figure class="IMG"><img id="fig4-10" class="img5" src="../images/fig4-10.jpg" alt="" width="567" height="373"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: CTR mode</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter4.xhtml#fig4-10">Figure 4-10</a> shows that in CTR mode, encryption XORs the plaintext and the stream taken from “encrypting” the nonce, <i>N</i>, and counter, <i>Ctr</i>. Decryption is the same, so you need only the encryption algorithm for both encryption and decryption. The Python script in <a href="chapter4.xhtml#Lis4-6">Listing 4-6</a> gives you a hands-on example.</p>&#13;
<span id="Lis4-6"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label="81"/>#!/usr/bin/env python&#13;
&#13;
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes&#13;
from os import urandom&#13;
&#13;
BLOCK_SIZE = 16&#13;
KEY_SIZE = 16&#13;
&#13;
# Pick a random key.&#13;
k = urandom(KEY_SIZE)&#13;
print(f"k  = {k.hex()}")&#13;
&#13;
# And a random nonce&#13;
# (careful with random nonces, see discussion below).&#13;
n = urandom(BLOCK_SIZE)&#13;
print(f"nonce  = {n.hex()}")&#13;
&#13;
# Create a 7-byte plaintext p.&#13;
p = bytes([0x00] * 7)&#13;
&#13;
# Encrypt the plaintext p with AES-CTR.&#13;
aes_ctr_encryptor = Cipher(algorithms.AES(k), modes.CTR(n)).encryptor()&#13;
&#13;
c = aes_ctr_encryptor.update(p) + aes_ctr_encryptor.finalize()&#13;
print(f"enc({p.hex()}) = {c.hex()}")&#13;
&#13;
# Decrypt the ciphertext c.&#13;
aes_ctr_decryptor = Cipher(algorithms.AES(k), modes.CTR(n)).decryptor()&#13;
p = aes_ctr_decryptor.update(c) + aes_ctr_decryptor.finalize()&#13;
print(f"dec({c.hex()}) = {p.hex()}")&#13;
&#13;
# Decrypt the ciphertext c using the encryption function.&#13;
aes_ctr_encryptor = Cipher(algorithms.AES(k), modes.CTR(n)).encryptor()&#13;
p = aes_ctr_encryptor.update(c) + aes_ctr_encryptor.finalize()&#13;
print(f"enc({c.hex()}) = {p.hex()}")</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using AES in CTR mode</samp></p>&#13;
<p class="TX">The example execution encrypts a 4-byte plaintext and gets a 4-byte ciphertext. It then decrypts that ciphertext using the encryption function:</p>&#13;
<pre><code>$ <b>./aes_ctr.py</b>&#13;
k = 130a1aa77fa58335272156421cb2a3ea&#13;
enc(00010203) = b23d284e&#13;
enc(b23d284e) = 00010203</code></pre>&#13;
<p class="TX">As with the initial value in CBC, the encrypter supplies CTR’s nonce and sends it with the ciphertext in the clear. But unlike CBC’s initial value, CTR’s nonce doesn’t need to be random; it simply needs to be unique. A nonce should be unique for the same reason that we shouldn’t reuse a one-time pad: when calling the pseudorandom stream, <i>S</i>, if you encrypt <i>P</i><sub>1</sub> to <i>C</i><sub>1</sub> = <i>P</i><sub>1</sub> <span class="symbol">⊕</span> <i>S</i> and <i>P</i><sub>2</sub> to <i>C</i><sub>2</sub> = <i>P</i><sub>2</sub> <span class="symbol">⊕</span> <i>S</i> using the same nonce, then <i>C</i><sub>1</sub> <span class="symbol">⊕</span> <i>C</i><sub>2</sub> reveals <i>P</i><sub>1</sub> <span class="symbol">⊕</span> <i>P</i><sub>2</sub>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label="82"/>A random nonce will do the trick only if it’s long enough; for example, if the nonce is <i>n</i> bits, chances are that after 2<i><sup>n</sup></i><sup>/2</sup> encryptions and as many nonces, you’ll run into duplicates. Sixty-four bits are insufficient for a random nonce, since you can expect a repetition after approximately 2<sup>32</sup> nonces, which is an unacceptably low number.</p>&#13;
<p class="TX">The counter is guaranteed unique if it’s incremented for every new plaintext, and if it’s long enough—for example, a 64-bit counter.</p>&#13;
<p class="TX">One particular benefit to CTR is that it can be faster than any other mode. Not only is it parallelizable, but you can also start encrypting even before knowing the message by picking a nonce and computing the stream that you’ll later XOR with the plaintext.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Depending on the CTR version we implement, we may either concatenate the nonce the API uses as an argument to a counter (as in <a href="chapter4.xhtml#fig4-10">Figure 4-10</a>) or directly consider a counter as wide as a block.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H1" id="sec24"><span id="h1-34"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">There are two must-know attacks on block ciphers: meet-in-the-middle attacks, a technique discovered in the 1970s but still used in many cryptanalytic attacks (not to be confused with man-in-the-middle attacks), and padding oracle attacks, a class of attacks discovered in 2002 by academic cryptographers, then mostly ignored, and finally rediscovered a decade later along with several vulnerable applications.</p>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-62"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Meet-in-the-Middle Attacks</samp></h4>&#13;
<p class="TNI">The 3DES block cipher is an upgraded version of the 1970s standard DES that takes a key of 56 × 3 = 168 bits (an improvement on DES’s 56-bit key). But the security level of 3DES is 112 bits instead of 168 bits because of the <i>meet-in-the-middle (MitM)</i> attack.</p>&#13;
<p class="TX"><a href="chapter4.xhtml#fig4-11">Figure 4-11</a> shows that 3DES encrypts a block using the DES encryption and decryption functions: first encryption with a key, <i>K</i><sub>1</sub>; then decryption with a key, <i>K</i><sub>2</sub>; and finally encryption with another key, <i>K</i><sub>3</sub>. If <i>K</i><sub>1</sub> = <i>K</i><sub>2</sub>, the first two calls cancel themselves out, and 3DES boils down to a single DES with key <i>K</i><sub>3</sub>. 3DES does encrypt-decrypt-encrypt rather than encrypting thrice to allow systems to emulate DES when necessary using the new 3DES interface.</p>&#13;
<figure class="IMG"><img id="fig4-11" class="img7" src="../images/fig4-11.jpg" alt="" width="813" height="264"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: The 3DES block cipher construction</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label="83"/>Why use triple DES and not just double DES—that is, why encrypt a plaintext <i>P</i> to <b>E</b>(<i>K</i><sub>2</sub>, <b>E</b>(<i>K</i><sub>1</sub>, <i>P</i>))? It turns out that the MitM attack makes double DES only as secure as single DES. <a href="chapter4.xhtml#fig4-12">Figure 4-12</a> shows the MitM attack in action.</p>&#13;
<figure class="IMG"><img id="fig4-12" class="img7" src="../images/fig4-12.jpg" alt="" width="725" height="264"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The MitM attack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The MitM attack works as follows to attack double DES:</p>&#13;
<p class="NLF">  1.  Say you have <i>P</i> and <i>C</i> = <b>E</b>(<i>K</i><sub>2</sub>, <b>E</b>(<i>K</i><sub>1</sub>, <i>P</i>)) with two unknown 56-bit keys, <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub>. (DES takes 56-bit keys, so double DES takes 112 key bits in total.) You build a key-value table with 2<sup>56</sup> entries of <b>E</b>(<i>K</i><sub>1</sub>, <i>P</i>), where <b>E</b> is the DES encryption function and <i>K</i><sub>1</sub> is the value stored.</p>&#13;
<p class="NL">  2.  For all 2<sup>56</sup> values of <i>K</i><sub>2</sub>, compute <b>D</b>(<i>K</i><sub>2</sub>, <i>C</i>) and check whether the resulting value appears in the table as an index (thus as a middle value, represented by a question mark in <a href="chapter4.xhtml#fig4-12">Figure 4-12</a>).</p>&#13;
<p class="NLL">  3.  If you find a middle value as an index of the table, fetch the corresponding <i>K</i><sub>1</sub> from the table and verify that the (<i>K</i><sub>1</sub>, <i>K</i><sub>2</sub>) found is the right one by using other pairs of <i>P</i> and <i>C</i>. Encrypt <i>P</i> using <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub> and then check that the ciphertext obtained is the given <i>C</i>.</p>&#13;
<p class="TX">This method recovers <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub> by performing about 2<sup>57</sup> instead of 2<sup>112</sup> operations: step 1 encrypts 2<sup>56</sup> blocks, and then step 2 decrypts at most 2<sup>56</sup> blocks, for 2<sup>56</sup> + 2<sup>56</sup> = 2<sup>57</sup> operations in total. You also need to store 2<sup>56</sup> elements of 15 bytes each, or about 1 exabyte. That’s a lot, but there’s a trick that allows you to run the same attack with only negligible memory (as you’ll see in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>).</p>&#13;
<p class="TX">You can apply the MitM attack to 3DES in almost the same way you would to double DES, except that the third stage will go through all 2<sup>112</sup> values of <i>K</i><sub>2</sub> and <i>K</i><sub>3</sub>. The whole attack thus succeeds after performing about 2<sup>112</sup> operations, meaning that 3DES gets only 112-bit security despite having 168 bits of key material.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2" id="sec26"><span id="h2-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Padding Oracle Attacks</samp></h4>&#13;
<p class="TNI">We conclude this chapter with one of the simplest and yet most devastating attacks of the 2000s: the padding oracle attack. Remember that padding fills the plaintext with extra bytes to fill a block. A plaintext of 111 bytes, for example, is a sequence of six 16-byte blocks followed by 15 bytes. In this case, forming a complete block padding adds a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. For a 110-byte plaintext, padding adds 2 <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes. For a 109-byte plaintext, it adds 3 <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> bytes, and so on, up to the case where we add 16 <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> bytes, where the hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> is equal to 16.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label="84"/>A <i>padding oracle</i> is a system that behaves differently depending on whether the padding in a CBC-encrypted ciphertext is valid. You can see it as a black box or an API that returns either a <i>success</i> or an <i>error</i> value. You can, for example, obtain a padding oracle in a service on a remote host that sends error messages when it receives malformed ciphertexts. Given such an oracle, padding oracle attacks record which inputs have a valid padding and which don’t and then exploit this information to decrypt chosen ciphertext values.</p>&#13;
<p class="TX">Say you want to decrypt a ciphertext block <i>C</i><sub>2</sub>. I’ll call <i>X</i> the value you’re looking for, namely, <b>D</b>(<i>K</i>, <i>C</i><sub>2</sub>), and <i>P</i><sub>2</sub> the block obtained after decrypting in CBC mode (see <a href="chapter4.xhtml#fig4-13">Figure 4-13</a>). If you pick a random block <i>C</i><sub>1</sub> and send the two-block ciphertext <i>C</i><sub>1</sub> || <i>C</i><sub>2</sub> to the oracle, decryption will succeed only if <i>C</i><sub>1</sub> <span class="symbol">⊕</span> <i>X = P</i><sub>2</sub> ends with valid padding—a single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte, two <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes, or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> bytes, and so on.</p>&#13;
<figure class="IMG"><img id="fig4-13" class="img5" src="../images/fig4-13.jpg" alt="" width="371" height="383"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-13: Padding oracle attacks recover</samp> <samp class="SANS_Futura_Std_Book_11">X</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">by choosing</samp> <samp class="SANS_Futura_Std_Book_11">C</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and checking the validity of padding.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Based on this observation, padding oracle attacks on CBC encryption can decrypt a block <i>C</i><sub>2</sub> like this (bytes are denoted in array notation: <i>C</i><sub>1</sub>[0] is <i>C</i><sub>1</sub>’s first byte, <i>C</i><sub>1</sub>[1] its second byte, and so on up to <i>C</i><sub>1</sub>[15], <i>C</i><sub>1</sub>’s last byte):</p>&#13;
<p class="NLF">  1.  Pick a random block <i>C</i><sub>1</sub> and vary its last byte until the padding oracle accepts the ciphertext as valid. Usually, in a valid ciphertext, <i>C</i><sub>1</sub>[15] <span class="symbol">⊕</span> <i>X</i>[15] = <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, so you’ll find <i>X</i>[15] after trying around 128 values of <i>C</i><sub>1</sub>[15].</p>&#13;
<p class="NL">  2.  Find the value <i>X</i>[14] by setting <i>C</i><sub>1</sub>[15] to <i>X</i>[15] <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> and searching for the <i>C</i><sub>1</sub>[14] that gives correct padding. When the oracle accepts the ciphertext as valid, it means you’ve found <i>C</i><sub>1</sub>[14] such that <i>C</i><sub>1</sub>[14] <span class="symbol">⊕</span> <i>X</i>[14] = <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>.</p>&#13;
<p class="NLL">  3.  Repeat steps 1 and 2 for all 16 bytes.</p>&#13;
<p class="TX">The attack needs on average 128 queries to the oracle for each of the 16 bytes, which is about 2,000 queries in total. (Note that each query must use the same initial value.)</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label="85"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In practice, implementing a padding oracle attack is a bit more complicated than what I’ve described because you have to deal with wrong guesses at step 1. A ciphertext may have valid padding not because</i> <span class="note_Italic">P</span><span class="ePub-I-SUB">2</span> <i>ends with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> but because it ends with two <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> bytes. You can manage this by testing the validity of ciphertexts where more bytes are modified.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H1" id="sec27"><span id="h1-35"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">There’s a lot to say about block ciphers, be it in how algorithms work or in how they can be attacked. For instance, Feistel networks and SPNs aren’t the only ways to build a block cipher. The block ciphers IDEA and FOX use the Lai–Massey construction, and Threefish uses ARX networks, a combination of addition, word rotations, and XORs.</p>&#13;
<p class="TX">There are also many more modes than ECB, CBC, and CTR. Some modes are folklore techniques that nobody uses, like CFB and OFB, while others are for specific applications, like XTS for tweakable encryption or GCM for authenticated encryption.</p>&#13;
<p class="TX">I’ve discussed Rijndael, the AES winner, but there were 14 other algorithms in the race: CAST-256, CRYPTON, DEAL, DFC, E2, FROG, HPC, LOKI97, Magenta, MARS, RC6, SAFER+, Serpent, and Twofish. I recommend looking them up to see how they work, how they were designed, how they have been attacked, and how fast they are. It’s also worth checking out the NSA’s designs (Skipjack and, more recently, SIMON and SPECK) and more recent “lightweight” block ciphers such as GIFT, KATAN, PRESENT, or PRINCE.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>