<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">MAX-FLOW ALGORITHMS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Earlier chapters have demonstrated various ways to use graphs to model connectivity and transportation problems. This chapter considers the <i>overall capacity</i> of networks and how things can flow through them. Imagine we want to model the amount of water that can flow through a network of pipes. We can use edge weights to represent how much water can flow between any two nodes, allowing us to determine the maximum capacity of the entire network.</p>&#13;
<p class="TX">The <i>maximum-flow problem</i> seeks to determine how much flow a graph can support when given edges with limited capacity. This phrasing is intentionally general. We could be modeling the flow of water through a pipe, the flow of people through a transportation network, or the flow of information through a social network. Each application brings its own terminologies, measurements, and units. However, they all boil down to the same fundamental question.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label="230"/>In this chapter, we consider the task of computing the maximum flow on a directed, weighted graph, using the <i>Ford-Fulkerson</i> and <i>Edmonds-Karp</i> algorithms. Along the way, we show how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structures on which we’ve relied in previous chapters to account for dynamic usage of capacity through the edges.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-184"/><samp class="SANS_Futura_Std_Bold_B_11">The Maximum-Flow Problem</samp></h3>&#13;
<p class="TNI1">Given a graph with weighted edges that represent the directionality and capacity of flow between two adjacent nodes, how do we determine the maximal flow through the network? We call the node from which the flow originates the <i>source node</i> and label it <i>s</i>. We call the destination node of the flow the <i>sink node</i> and label it <i>t</i>. We use <i>capacity</i>(<i>u</i>, <i>v</i>) to indicate the capacity of an edge from <i>u</i> to <i>v</i>—that is, the maximum amount of flow an edge can support. We indicate the flow through that edge with <i>flow</i>(<i>u</i>, <i>v</i>). The total flow through the network is the amount of flow leaving the source (or, equivalently, the amount entering the sink).</p>&#13;
<p class="TX">We can visualize the max-flow problem in the context of a wastewater processing system outside of a city. Imagine that wastewater flows from the city via a single source pipe and into the sewage treatment plant via a single sink pipe. In between the source and sink, the wastewater travels through pipes of various sizes, with its flow dividing and recombining at individual nodes. The capacity of the pipes dictates how much wastewater can flow through them.</p>&#13;
<p class="TX">To model realistic behavior, the maximum-flow problem imposes several constraints. The first is that the source node (the city) only has flow out and the sink node (the sewage treatment plant) only has flow in. In mathematical terms:</p>&#13;
<p class="EQ"><i>capacity</i>(<i>u</i>, <i>s</i>) = 0 for every node <i>u</i></p>&#13;
<p class="EQ"><i>capacity</i>(<i>t, v</i>) = 0 for every node <i>v</i></p>&#13;
<p class="BodyContinued">This corresponds to the very reasonable constraints that no wastewater may flow back to the city through the source pipe, and nothing may flow out from the sewage treatment system.</p>&#13;
<p class="TX">The second constraint is that the flow through an edge (pipe) cannot be less than zero nor can it be more than the edge’s capacity. In mathematical terms:</p>&#13;
<p class="EQ">0 ≤ <i>flow</i>(<i>u</i>, <i>v</i>) ≤ <i>capacity</i>(<i>u</i>, <i>v</i>) for any pair of nodes <i>u</i> and <i>v</i></p>&#13;
<p class="BodyContinued">The upper bound translates to the physical constraints of the pipe. If we try to push too much water through a pipe, it will burst. Nobody wants that. The lower bound of zero indicates a directionality of the pipe, such as one-way valves to prevent flow back through the pipe.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label="231"/>The final constraint is that for all nodes except the source and the sink, the amount of flow into the node must equal the amount of flow out. Mathematically, this means that for every node <i>u</i>:</p>&#13;
<p class="EQ">∑<span class="ePub-I-SUB">v</span> <i>flow</i>(<i>v, u</i>) = ∑<span class="ePub-I-SUB">v</span> <i>flow</i>(<i>u, v</i>)</p>&#13;
<p class="BodyContinued">This constraint prevents invalid situations at the node, where water is magically appearing or disappearing at the pipes’ junctions.</p>&#13;
<p class="TX">Until the last few sections of this chapter, we impose an additional constraint that will help us reason about maximum-flow algorithms. We disallow <i>anti-parallel edges</i>, pairs of directed edges between the same nodes in opposite directions. In practical terms, this means that if there is an edge from node <i>u</i> to node <i>v</i>, we do not allow an edge from node <i>v</i> to node <i>u</i>. This restriction helps simplify the definition of a <i>residual network,</i> discussed in a later section. We will relax this restriction toward the end of the chapter.</p>&#13;
<p class="TX"><a href="#fig14-1">Figure 14-1</a> is an example of the maximum-flow problem on a small graph. The edge weights in <a href="#fig14-1">Figure 14-1(a)</a> represent capacity. To compute the total flow from a source of node 0 to a sink of node 3, we can add up the flow along each path. <a href="#fig14-1">Figure 14-1(b)</a> shows a configuration with maximum flow. Along the top path, we can send 5 units of flow from node 0 to node 1. The edge from node 1 to node 3 can take even more, but that does not help us. We cannot get more than 5 units of flow to node 1, so we cannot have more than 5 units of flow out. Therefore, the maximal flow along the top path is 5.</p>&#13;
<figure class="IMG"><img id="fig14-1" class="img100" src="../images/f14001.jpg" alt="(A) shows a graph with four nodes and four edges. each edge is labeled with its capacity. Edge (0, 1) has capacity 5, edge (0, 2) has capacity 10, edge (1, 3) has capacity 10, and edge (2, 3) has capacity 1. (B) shows the same graph with edges labeled with their capacity and how much is used. Edge (0, 2) is labeled 1 of 10." width="1335" height="353"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: A graph with capacities (a) and the maximum flow along the graph’s edges (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Similarly, <a href="#fig14-1">Figure 14-1(a)</a> shows a pair of restrictions along the graph’s bottom path. While the edge from node 0 to node 2 looks promising with its capacity of 10, we will not be able to push that amount <i>out</i> of node 2. The edge (2, 3) presents a severe bottleneck with a capacity of 1. Like a large water pipe that transitions to a small one, the combination of edges limits the overall capacity of the bottom path to 1 and the total flow in the network to 6.</p>&#13;
<p class="TX">The maximum-flow problem gets significantly more complicated for larger graphs. Consider what happens in <a href="#fig14-2">Figure 14-2</a> when we add a single new edge from node 2 to node 1 with capacity 7. Perhaps upset by constant sewer backups, the government builds a new pipe from node 2 to node 1. The edge (2, 1) presents an alternative path for the flow out of node 2. Up to 7 units of flow can split off and take edge (2, 1), while 1 unit continues to use (2, 3).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label="232"/>&#13;
<figure class="IMG"><img id="fig14-2" class="img100" src="../images/f14002.jpg" alt="(A) shows a graph with four nodes and five edges. each edge is labeled with its capacity. (B) shows the same graph with edges labeled with their capacity and how much is used. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is using 6 of 10 capacity, edge (1, 3) is using 10 of 10 capacity, edge (2, 1) is using 5 of 7 capacity, and edge (2, 3) is using 1 of 1 capacity." width="1395" height="363"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: A second example graph with capacities (a) and the maximum flow along those edges (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">However, we need to ensure that the new path through node 1 can handle this additional flow. We already have 5 units of flow from node 0 to node 1. Since the edge (1, 3) has capacity 10 and we are using 5, it has only 5 units of capacity remaining. Despite building a shiny new edge of capacity 7, we can send only 5 more units of flow through our network.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-185"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">The maximum-flow problem naturally mirrors a range of real-world phenomena, including the flow of liquid through pipes, people through a transportation network, or information through a social network.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-186"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Physical Pipelines</samp></h4>&#13;
<p class="TNI1">Much of the terminology of the maximum-flow problem stems from the physical phenomenon of substances flowing through pipes. The terms <i>source</i>, <i>sink</i>, <i>capacity</i>, and even <i>flow</i> mirror their physical counterparts. We can easily map these types of physical problems to their computational equivalent.</p>&#13;
<p class="TX">While this chapter’s primary running example is the flow of water through a wastewater system, the pipeline analogy goes well beyond sewage or interior plumbing, allowing us to ask additional questions. Perhaps we are interested in the flow of maple syrup through a processing plant. Given a complex series of pipes and nodes, what is the capacity of the overall system? How much liquid can we send through it before risking catastrophic maple syrup processing failure? These initial questions provide the foundation for further analysis and optimization, including answering such follow-up questions as “Where are the bottlenecks in the current system?” or “Where should we expand capacity by adding another pipe?”</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-187"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transportation Networks</samp></h4>&#13;
<p class="TNI1">Transportation networks are also fertile ground for maximum-flow analysis. Imagine that your favorite sporting team has a championship game in a faraway city. Many thousands of local fans want to fly there and attend what can only be called the most important game of the century. The airline can model this demand as a maximum-flow problem to determine how many fans can currently travel between the two cities. Edges are routes between pairs of cities with limited numbers of airline seats that constitute their <span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/>capacity. The flow through an edge is the number of occupied seats. The local city is the source node from which fans are traveling for this occasion, while the host city is the sink node.</p>&#13;
<p class="TX">The airline can use this analysis to determine if they should add another flight. If the number of interested fans far exceeds the capacity of their flight schedule, there is more money to be made.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-188"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Communication Networks</samp></h4>&#13;
<p class="TNI1">We can also use the maximum-flow problem to model information passing through a communication or social network. For example, imagine you want to influence another person’s decision by strategically passing information through your social network. Perhaps you are trying to convince the hiring manager at your favorite company that you would be an ideal successor to the previous CEO. In hopes of swaying their decision, you start to share stories of your amazing achievements, making you the source node and the hiring manager the sink node.</p>&#13;
<p class="TX">Unfortunately, the members of your network have limited time and interest in passing such messages. This capacity varies between any two nodes. Maybe two friends meet for coffee each morning and one can pass volumes of information to the other. However, a strained relationship might have limited information transfer capacity. Modeling this situation as a maximum-flow problem can help you determine how much information you can realistically get to the sink node.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-189"/><samp class="SANS_Futura_Std_Bold_B_11">Extending the Data Structures</samp></h3>&#13;
<p class="TNI1">Before introducing our first algorithm, we need to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structures to fully model capacities and flows. While the edge weights of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure cannot model both the capacity limit and how much is used, the max-flow problem requires graphs that capture both a <i>fixed total capacity</i> and a <i>dynamic flow amount</i>.</p>&#13;
<p class="TX">In this section, we define two new data structures. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> class is based on our <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class with additional support for representing the amount of capacity that is in use. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class is similarly based on the formulation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class, but with additional functionality to track dynamically changing flows through the graph.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-190"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges with Capacity</samp></h4>&#13;
<p class="TNI1">To model the max-flow problem, the graph’s edges need to be able to store two pieces of information: a fixed total capacity and a dynamic flow amount. We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> class that stores the following information:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the node index of the edge’s origin</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the node index of the edge’s destination</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">capacity</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp><b>) </b>Stores the edge’s total capacity</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">used</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp><b>) </b>Stores the amount of the edge’s capacity that is being used</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label="234"/>We replace the single weight value in an edge with the combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>. <a href="#fig14-3">Figure 14-3</a> shows a visualization of these attributes in the context of flow, where <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp> is the width of the pipe and <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> is the amount occupied.</p>&#13;
<figure class="IMG"><img id="fig14-3" class="img100" src="../images/f14003.jpg" alt="An edge represented as a pipe with its width equal to the total capacity and the used amount shaded." width="1191" height="335"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The attributes of a</samp> <samp class="SANS_TheSansMonoCd_W7Italic">CapacityEdge</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">object</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structures we defined in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> and have used throughout the book, <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> objects provide both storage and functions to operate on that storage, as shown here:</p>&#13;
<pre><code>class CapacityEdge: &#13;
    def __init__(self, from_node: int, to_node: int, capacity: float):&#13;
        self.from_node: int = from_node&#13;
        self.to_node: int = to_node&#13;
        self.capacity: float = capacity&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> self.used: float = 0.0&#13;
&#13;
    def adjust_used(self, amount: float): &#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if self.used + amount &lt; 0.0 or self.used + amount &gt; self.capacity:&#13;
            raise Exception("Capacity Error")&#13;
        self.used += amount&#13;
&#13;
    def capacity_left(self) -&gt; float: &#13;
        return self.capacity - self.used&#13;
&#13;
    def flow_used(self) -&gt; float: &#13;
        return self.used&#13;
</code></pre>&#13;
<p class="TX">The constructor initializes the object’s variables, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to indicate that the edges start without any flow <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">adjust_used()</samp> function allows algorithms to modify the flow through the edge. It takes an adjustment amount and adds it to the amount being used. We can visualize the function as a faucet knob. If we turn it one way, by passing in a positive amount, the flow increases. If we turn it the other way, by passing in a negative amount, the flow decreases. Unlike a faucet, however, the function does not automatically “stop turning” when it has reached its limit. The code includes an additional check to ensure the used capacity falls within the limits specified by the edge <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. Specifically, the flow through an edge can never be less than 0 nor more than the edge’s total capacity.</p>&#13;
<p class="TX">Pushing the faucet analogy further, we may wish for indicators on how much we can turn the faucet in each direction. We provide the function <span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label="235"/><samp class="SANS_TheSansMonoCd_W5Regular_11">capacity_left()</samp> to indicate the unused capacity remaining on the edge (also called the <i>forward residual)</i>. This is the amount of additional flow we can add to an edge. Similarly, we provide the function <samp class="SANS_TheSansMonoCd_W5Regular_11">flow_used()</samp> for indicating the current capacity used (also called the <i>backward residual)</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-191"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Residual Graphs</samp></h4>&#13;
<p class="TNI1">Just as we needed to add functionality to track how much capacity is used within an edge, we must augment our graph representation to support storage of and computation on these dynamic edges. We also add auxiliary tracking information specific to the max-flow problem, namely the indices of the source and sink nodes. We call this augmented graph a <i>residual graph</i> because it tracks the residual (or remaining) capacity between pairs of nodes.</p>&#13;
<p class="TX">We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class that uses a more minimal adjacency list representation and contains the following:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the total number of nodes in the graph.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">source_index</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the index of the source node.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">sink_index</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the index of the sink node.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Stores a dictionary for each node containing the adjacent edge objects out of that node keyed by their destination node. To access the <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> from node <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> to node <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[j][k]</samp>.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">all_neighbors</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Stores a set of all in-neighbor and out-neighbor indices for each node.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> representation differs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class in that we are no longer storing <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects. Instead, the same adjacency list information, including the use of a dictionary, is incorporated into the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> list. While this presents a more compact representation that is sufficient for max-flow algorithms, we lose the ability to easily store auxiliary data within the nodes that we used for other algorithms.</p>&#13;
<p class="TX">Although we are working with directed graphs, the algorithms we introduce will need to scan over all neighboring nodes, including in-neighbors that are not included in a traditional adjacency list. To facilitate these computations, we store the additional list <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>. Restricting the connection between any two nodes to a single directed <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> (not allowing anti-parallel edges) makes reasoning about forward and backward flows easier. As we will see, this restriction does not diminish the representational power of the graph because we can transform a graph with anti-parallel edges into one without them.</p>&#13;
<p class="TX">To demonstrate how the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp> lists capture the structure of the graph, consider the example <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> shown in <a href="#fig14-4">Figure 14-4</a>, along with its two list data structures. The four-node graph is shown on the left, the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> list in the middle, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp> list on the right. Node 1 has two outgoing edges (nodes 2 and 3) and thus two entries in its adjacency dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp>. Each entry in the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp> maps the neighbor’s index to the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> out of node 1. Since node 1 also has an incoming edge from node 0, the set <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors[1]</samp> contains three indices: 0, 2, and 3.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_236" aria-label="236"/>&#13;
<figure class="IMG"><img id="fig14-4" class="img80" src="../images/f14004.jpg" alt="A four-node graph, the edges array mapping each node to a dictionary of destinations, and the all_neighbors array mapping each node to a set of its neighbors." width="1103" height="463"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: A residual graph and its internal list data structures</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class provides functions for creating and operating on this type of graph:</p>&#13;
<pre><code>class ResidualGraph: &#13;
    def __init__(self, num_nodes: int, source_index: int, sink_index: int):&#13;
        self.num_nodes: int = num_nodes&#13;
        self.source_index: int = source_index&#13;
        self.sink_index: int = sink_index&#13;
        self.edges: list = [{} for _ in range(num_nodes)]&#13;
        self.all_neighbors: list = [set() for _ in range(num_nodes)]&#13;
&#13;
    def get_edge(self, from_node: int, to_node: int) -&gt; Union[CapacityEdge,&#13;
                                                              None]: &#13;
        if from_node &lt; 0 or from_node &gt;= self.num_nodes:&#13;
            raise IndexError&#13;
        if to_node &lt; 0 or to_node &gt;= self.num_nodes:&#13;
            raise IndexError&#13;
        if to_node in self.edges[from_node]:&#13;
            return self.edges[from_node][to_node]&#13;
        return None&#13;
&#13;
    def insert_edge(self, from_node: int, to_node: int, capacity: float): &#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if from_node &lt; 0 or from_node &gt;= self.num_nodes:&#13;
            raise IndexError&#13;
        if to_node &lt; 0 or to_node &gt;= self.num_nodes:&#13;
            raise IndexError&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if from_node == self.sink_index:&#13;
            raise ValueError("Tried to insert edge FROM sink node.")&#13;
        if to_node == self.source_index:&#13;
            raise ValueError("Tried to insert edge TO source node.")&#13;
        if from_node in self.edges[to_node]:&#13;
            raise ValueError(f"Tried to insert edge {from_node}-&gt;{to_node}, "&#13;
                             f"edge {to_node}-&gt;{from_node} already exists.")&#13;
        if capacity &lt;= 0:&#13;
            raise ValueError(f"Tried to insert capacity {capacity}")&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> self.edges[from_node][to_node] = CapacityEdge(from_node, to_node,&#13;
                                                      capacity)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_237" aria-label="237"/>&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> self.all_neighbors[from_node].add(to_node)&#13;
        self.all_neighbors[to_node].add(from_node)&#13;
&#13;
    def compute_total_flow(self) -&gt; float: &#13;
        total_flow: float = 0.0&#13;
        for to_node in self.edges[self.source_index]:&#13;
            total_flow += self.edges[self.source_index][to_node].flow_used()&#13;
        return total_flow&#13;
</code></pre>&#13;
<p class="TX">The constructor creates an empty graph by creating empty adjacency dictionaries (<samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>) and neighbor sets for all nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>). Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function mirrors the version from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class and allows us to access each edge. Much of the code for this function consists of bounds checking: the function raises an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp> if <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> is not in the graph. If the edge is not in the graph, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. If the nodes are valid and the edge is in the graph, the code returns the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>. The code relies on importing <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to support the type hints for multiple return types.</p>&#13;
<p class="TX">Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> is both using different structures to store the edges with capacities and adding more neighbor information to track incoming edges, the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function needs to track this information accordingly. The code starts with the same index validity checking we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> and adds checks to ensure the structural constraints we put on the graphs in the max-flow problem <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. These include checking that (1) there are no edges out of the sink, (2) there are no edges into the source, (3) the newly inserted edge is not the reverse of an existing edge, and (4) the capacity is greater than zero.</p>&#13;
<p class="TX">If all the checks pass, the code creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> and adds it to the dictionary in the corresponding entry of the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> list <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. If an edge has already been inserted between these two nodes in the same direction, the code overwrites it. Finally, the code adds <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>’s list of all neighbors and adds <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>’s list of all neighbors <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">compute_total_flow()</samp> function demonstrates how to use the values within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> to reason about its properties, computing the total flow from source to sink by summing up the flow along each edge leaving the source. Since all flow originates from a single source node, this is the total flow through the graph.</p>&#13;
<p class="TX">The remaining functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class are closely tied to the operation of the Ford-Fulkerson algorithm; we’ll present them in context as we introduce the algorithm.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h-192"/><samp class="SANS_Futura_Std_Bold_B_11">The Ford-Fulkerson Algorithm</samp></h3>&#13;
<p class="TNI1">Mathematicians L.R. Ford Jr. and D.R. Fulkerson developed a general approach for finding the maximum flow through a graph by repeatedly finding underutilized paths from the source to the sink and increasing the flow along those paths. This approach relies upon the idea of an <i>augmenting</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label="238"/><i>path</i>, a route from the source node to the sink node along which the flow can be increased. Ford-Fulkerson is technically a general approach that encompasses a range of specific algorithms because the original paper does not specify which search algorithm to use to find the augmenting path. This section introduces an example implementation using depth-first search.</p>&#13;
<p class="TX">The general Ford-Fulkerson approach may fail to terminate in pathological cases where irrational numbers are used for the capacities. These cases can be avoided by limiting the precision of the capacities or, as we will see later in this chapter, by selecting augmenting paths with the fewest edges.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-193"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Augmenting Paths</samp></h4>&#13;
<p class="TNI1">The simplest form of an augmenting path is a series of directed edges from source to sink whose current flow is less than the edges’ capacities. In this case, as illustrated in <a href="#fig14-5">Figure 14-5(a)</a>, we can just add flow along the path [0, 2, 3] to increase the total flow by 2 units. <a href="#fig14-5">Figure 14-5(b)</a> shows the resulting total of 7 units of flow leaving the source and entering the sink.</p>&#13;
<figure class="IMG"><img id="fig14-5" class="img100" src="../images/f14005.jpg" alt="(A) shows a graph with four nodes and five edges. Each edge is labeled with its capacity and how much is used. Edge (0, 1) uses 5 of 5, edge (0, 2) uses 0 of 10, edge (1, 2) is using 1 of 1, edge (1, 3) is using 4 of 10, and edge (2, 3) is using 1 of 3. (B) shows the same graph with the edges (0, 2) and (2, 3) bolded. The capacity used in each edge has been increased by 2. Edge (0, 1) uses 5 of 5, edge (0, 2) uses 2 of 10, edge (1, 2) is using 1 of 1, edge (1, 3) is using 4 of 10, and edge (2, 3) is using 3 of 3." width="1616" height="446"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: A capacity graph before (a) and after (b) adding flow</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Adding forward flow gets us only part of the way, however. <a href="#fig14-6">Figure 14-6</a> shows a situation where there is no path from source to sink that has unused capacity. This graph is not at maximum flow, since the flow from node 1 to node 2 is siphoning off potential flow from node 1 to node 3. Simultaneously, this flow is contributing to the edge from node 2 to node 3 being fully utilized and thus unable to accept any more flow from edge (0, 2).</p>&#13;
<figure class="IMG"><img id="fig14-6" class="img50" src="../images/f14006.jpg" alt="a graph with four nodes and five edges. Each edge is labeled with its capacity and how much is used. Edge (0, 1) uses 5 of 5, edge (0, 2) uses 2 of 10, edge (1, 2) is using 1 of 1, edge (1, 3) is using 4 of 10, and edge (2, 3) is using 3 of 3." width="711" height="377"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: A graph with no underutilized forward paths</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label="239"/>We can increase the flow of the graph using the two steps shown in <a href="#fig14-7">Figure 14-7</a>. The 5 units of flow entering node 1 are initially partitioned into two streams, with 1 unit of flow going to node 2 and 4 units going to node 3. We change this allocation to divert 1 additional unit of flow to node 3 as shown in <a href="#fig14-7">Figure 14-7(a)</a>. The total flow through the graph remains constant, but the flow through edge (2, 3) now drops below capacity. Second, we increase the flow from node 0 through node 2 to node 3 as shown in <a href="#fig14-7">Figure 14-7(b)</a>, increasing the overall flow through the graph to 8 units.</p>&#13;
<figure class="IMG"><img id="fig14-7" class="img100" src="../images/f14007.jpg" alt="(A) shows the graph from Fig. 14-6 with the edges (1, 2), (1, 3), and (2, 3) bolded. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is using 2 of 10 capacity, edge (1, 2) is using 0 of 1 capacity, edge (1, 3) is using 5 of 10 capacity, and edge (2, 3) is using 2 of 3 capacity. (B) shows the same graph with edges (0, 2) and (2, 3) bolded. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is using 3 of 10 capacity, edge (1, 2) is using 0 of 1 capacity, edge (1, 3) is using 5 of 10 capacity, and edge (2, 3) is using 3 of 3 capacity." width="1603" height="446"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: Two steps for adding flow to the graph in <a href="#fig14-6">Figure 14-6</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To reroute flow through the network, the algorithm also needs the ability to reduce flow through an edge by diverting it along another edge. We therefore define the <i>residual</i> along a directed edge (<i>u</i>, <i>v</i>) as follows. The forward residual is the unused capacity <i>capacity</i>(<i>u</i>, <i>v</i>) − <i>flow</i>(<i>u</i>, <i>v</i>) in the direction from node <i>u</i> to node <i>v</i>. This aligns how we normally think of additional capacity. The backward residual is the used capacity <i>flow</i>(<i>v</i>, <i>u</i>) in the direction opposite the edge—that is, from node <i>v</i> to node <i>u</i>. This corresponds to capacity that can be removed from the input of node <i>u</i>, allowing us to accept input from somewhere else.</p>&#13;
<p class="TX">We can push more flow through an underutilized directed edge or push flow back in the opposite direction of a directed edge. <a href="#fig14-8">Figure 14-8</a> shows an example case of combining forward and backward residuals.</p>&#13;
<figure class="IMG"><img id="fig14-8" class="img50" src="../images/f14008.jpg" alt="the graph from Fig. 14-6 with the edges (0, 2), (1, 2), and (1, 3) bolded. Edge (0, 1) uses 5 of 5 capacity, edge (0, 2) uses 2 of 10 capacity, edge (1, 2) is using 1 of 1 capacity, edge (1, 3) is using 4 of 10 capacity, and edge (2, 3) is using 3 of 3 capacity" width="724" height="377"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: An augmenting path that includes reducing flow along an edge</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label="240"/>The bolded edges indicate an undirected path from source to sink where we can modify the flows as follows:</p>&#13;
<ul class="BL">&#13;
<li class="BL">Edge (0, 2) has a forward residual of 8, so we can add more units of flow down that edge to node 2.</li>&#13;
<li class="BL">Edge (1, 2) has a backward residual of 1, so we can turn down that flow by 1 unit to allow node 2 to take more flow from another source (in this case, node 0). Since node 2’s outgoing flow is capped at 3 units and we need to keep the flow out equal to the flow in, we need to reduce the incoming flow from node 1 into node 2 in order to increase the flow from node 0 into node 2.</li>&#13;
<li class="BL">Edge (1, 3) has a forward residual of 6, so it can take extra output of node 1 that is no longer traveling to node 2. Again, we need to keep the flow into node 1 balanced with the flow out of node 1.</li>&#13;
</ul>&#13;
<p class="TX">The key to understanding the Ford-Fulkerson algorithm is that pushing flow through a backward edge is just reducing the flow leaving the origin node so that it can travel to a new destination. As we will see in the next section, our need to push flow in either direction means it no longer suffices to explore the edges out of each node’s (directed) adjacency list. We need to consider edges into and out of the node.</p>&#13;
<p class="TX">We can visualize this algorithm in the context of a sewage engineer managing the wastewater system described previously. The engineer maximizes the total flow of wastewater by routing the flow through the optimal sets of pipes. The main constraint is the capacity of the pipes (edges) and the junction boxes (nodes). The last engineer, trying to show off, ignored the total capacity and pushed more flow than was viable. The overloaded pipe promptly burst, resulting in a geyser of wastewater that was discussed in the newspapers for weeks.</p>&#13;
<p class="TX">The new engineer tackles this problem by continuously finding a path from source to sink that can take more wastewater and sending as much wastewater through that path as possible (but no more). Sometimes this means pushing back against an existing flow, which is fine as long as that flow can be pushed through another junction (node) to the sink. Any wastewater flowing into a junction must also flow out. Otherwise, it risks bursting the junction box. The engineer keeps increasing the flow again and again until all the paths are fully saturated.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-194"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding an Augmenting Path</samp></h4>&#13;
<p class="TNI1">Before we can define a search algorithm, we need to formalize the computation of the residual along a path. Remember from the previous description that an augmenting path can contain a combination of forward residuals and backward residuals. We define a helper method within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class to simplify the logic of computing the residual (either forward or backward) between any two nodes on the path:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label="241"/>def get_residual(self, from_node: int, to_node: int) -&gt; float: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if to_node not in self.all_neighbors[from_node]:&#13;
        return 0&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if to_node in self.edges[from_node]:&#13;
        return self.edges[from_node][to_node].capacity_left()&#13;
    else:&#13;
        return self.edges[to_node][from_node].flow_used()&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> function first checks whether the two nodes are connected at all <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If not, the edge is neither a forward nor a backward edge and has zero residual. If the edge (<samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>) is in the adjacency list of directed edges, then it is a forward edge <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>, and the function returns the capacity remaining (forward residual). Otherwise, the edge must exist in the opposite direction, so the code returns the flow used (backward residual).</p>&#13;
<p class="TX">In this section, we use a modified depth-first search to check the graph for an augmenting path:</p>&#13;
<pre><code>def find_augmenting_path_dfs(g: ResidualGraph) -&gt; list: &#13;
    seen: list = [False] * g.num_nodes&#13;
    last: list = [-1] * g.num_nodes&#13;
    augmenting_path_dfs_recursive(g, g.source_index, seen, last)&#13;
    return last&#13;
&#13;
def augmenting_path_dfs_recursive(g: ResidualGraph, current: int,&#13;
                                  seen: list, last: list): &#13;
    seen[current] = True&#13;
    for n in g.all_neighbors[current]:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if not seen[n] and g.get_residual(current, n) &gt; 0:&#13;
            last[n] = current&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if last[g.sink_index] != -1:&#13;
                return&#13;
            augmenting_path_dfs_recursive(g, n, seen, last)&#13;
</code></pre>&#13;
<p class="TX">This code consists of a pair of functions. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting _path_dfs()</samp> function sets up the lists <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> for a depth-first search, as described in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. It then calls the recursive depth-first search function and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list that represents the augmenting path.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">augmenting_path_dfs_recursive()</samp> function performs the recursive depth-first exploration. As with a standard depth-first search, it marks the current node as seen, then loops through the node’s neighbors. The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop over the residual graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp> list to explore along both directions of the directed edges. When exploring the neighbors of the current node, the code checks both that the node has not been seen (as in standard depth-first search) and that the residual is nonzero <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. This latter condition prevents the search from using edges that are already saturated. If the edge is viable and the node has not been seen, the search updates the tracking information and recursively explores that node.</p>&#13;
<p class="TX">The code incorporates an optional early termination check <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. It stops exploring new neighbors as soon as any path has been found from <span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label="242"/>the source to the sink. By checking whether <samp class="SANS_TheSansMonoCd_W5Regular_11">last[g.sink_index]</samp> has been assigned, the code can skip the recursive exploration at both the node before the sink and earlier nodes along the path.</p>&#13;
<p class="TX"><a href="#fig14-9">Figure 14-9</a> shows the iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_dfs()</samp> on the graph from <a href="#fig14-6">Figure 14-6</a>. Each edge is labeled with the <i>X</i> of <i>Y</i>, where <i>X</i> is the flow used and <i>Y</i> is the edge’s total capacity. The shaded nodes have been seen, and the node enclosed in the dashed circle is the one on which the recursive function has just been called.</p>&#13;
<figure class="IMG"><img id="fig14-9" class="img100" src="../images/f14009.jpg" alt="In (A), node 0 is circled and last reads [–1, –1, –1, –1]. In (B), node 2 is circled and last reads [–1, –1, 0, –1]. In (C), node 1 is circled and last reads [–1, 2, 0, –1]. In (D), no nodes are circled and last reads [–1, 2, 0, 1]." width="1545" height="1288"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: The steps of the search to find an augmenting path</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="#fig14-9">Figure 14-9(a)</a> shows the state of the algorithm before the source node is visited. <a href="#fig14-9">Figure 14-9(b)</a> shows the second step of the search: after visiting node 0, the algorithm finds two neighbors, nodes 1 and 2. Only edge (0, 2) has unused capacity, so the search continues down that branch.</p>&#13;
<p class="TX">Since the algorithm considers both outgoing and incoming edges, it finds two options at node 2. Both edges (1, 2) and (2, 3) are at capacity in their respective directions. However, edge (1, 2) is incoming to node 2 and thus has a backward residual of 1. This edge provides us an opportunity to decrease the flow into node 2. As shown in <a href="#fig14-9">Figure 14-9(c)</a>, the search follows this edge to explore node 1.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label="243"/>While exploring node 1, the algorithm finds a path to the sink node with unused capacity. The code never visits the sink node, but rather returns as soon as any path is found. In this case, as shown in <a href="#fig14-9">Figure 14-9(d)</a>, the algorithm returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array of <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1, 2, 0, 1]</samp>, indicating the augmenting path.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-195"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating a Path’s Capacity</samp></h4>&#13;
<p class="TNI1">After finding an augmenting path, the Ford-Fulkerson algorithm must determine how much additional flow it can push through the path, then update the path’s capacities to indicate the increased flow. To enable this, we add two functions to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class. The <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp> function traverses a path using the last pointers and computes the minimum residual of any edge along the path:</p>&#13;
<pre><code>def min_residual_on_path(self, last: list) -&gt; float: &#13;
    min_val: float = math.inf&#13;
&#13;
    current: int = self.sink_index&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> while current != self.source_index:&#13;
        prev: int = last[current]&#13;
        if prev == -1:&#13;
            raise ValueError&#13;
        min_val = min(min_val, self.get_residual(prev, current))&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> current = prev&#13;
    return min_val&#13;
</code></pre>&#13;
<p class="TX">The code starts by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_val</samp> to infinity (requiring the file to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import math</samp>) as an indicator that there is no minimum yet. It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to walk the chain of pointers backward from the sink until it reaches the source <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. At each step, it considers the node preceding the current one and checks that it is not <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, which would indicate a broken path. The code updates the minimum value using <samp class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> on the current edge and moves on to the previous node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. After examining all the edges along the path, the code returns the smallest residual it encountered.</p>&#13;
<p class="TX">If we apply <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp> to the result shown in <a href="#fig14-6">Figure 14-6</a>, with a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array of <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1, 2, 0, 1]</samp>, we traverse the path shown in <a href="#fig14-8">Figure 14-8</a>. The minimum residual along this path is 1 along edge (1, 2).</p>&#13;
<p class="TX">Once we have determined how much additional flow we can push through a path, we update the path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp> function:</p>&#13;
<pre><code>def update_along_path(self, last: list, amount: float): &#13;
    current: int = self.sink_index&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> while current != self.source_index:&#13;
        prev: int = last[current]&#13;
        if prev == -1:&#13;
            raise ValueError&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if current in self.edges[prev]:&#13;
            self.edges[prev][current].adjust_used(amount)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label="244"/>&#13;
        else:&#13;
            self.edges[current][prev].adjust_used(-amount)&#13;
        current = prev&#13;
</code></pre>&#13;
<p class="TX">Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp> function, the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp> walks the last pointers backward from the sink node to the source node using a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Again, it checks that the previous node indicates a valid path. If so, it checks the direction of the edge along the path before updating the amount used <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. Forward edges appear in the adjacency list, and the code adds the new flow to the amount of capacity used. Backward edges are ones where the algorithm is pushing flow back. The edge direction is the opposite way, so the edge itself is not in the adjacency list. The code subtracts the new flow from the amount already in use.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-196"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp></h4>&#13;
<p class="TNI1">The Ford-Fulkerson algorithm using depth-first search consists of putting together the pieces we have introduced throughout the chapter. As shown in <a href="#list14-1">Listing 14-1</a>, the algorithm repeatedly searches for an augmenting path. When it finds one, it computes the minimum residual along that path and increases the flow accordingly.</p>&#13;
<span id="list14-1"/>&#13;
<pre><code>def ford_fulkerson(g: Graph, source: int, sink: int) -&gt; ResidualGraph: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> residual: ResidualGraph = ResidualGraph(g.num_nodes, source, sink)&#13;
    for node in g.nodes:&#13;
        for edge in node.edges.values():&#13;
            residual.insert_edge(edge.from_node, edge.to_node, edge.weight)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> done = False&#13;
    while not done:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> last: list = find_augmenting_path_dfs(residual)&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if last[sink] &gt; -1:&#13;
            min_value: float = residual.min_residual_on_path(last)&#13;
            residual.update_along_path(last, min_value)&#13;
        else:&#13;
            done = True&#13;
&#13;
    return residual&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: The Ford-Fulkerson algorithm using depth-first search</samp></p>&#13;
<p class="TX">The code starts by creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> where the capacities are equal to the weights of the original graph <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. This effectively copies the graph while also transforming the representation.</p>&#13;
<p class="TX">The main loop of the algorithm is relatively small and begins by using a Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> to track whether it found an augmenting path on the last iteration <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> and the code searches for a new augmenting path <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. The code checks that the returned path is valid <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> and, if so, computes the minimum residual along the path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp> function and updates the flow along the path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">update _along_path()</samp> function. If the code finds a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> value of –1 for the sink node, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label="245"/>it knows there is no path from the source to the sink and can set <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. The function finishes by returning the residual graph.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h-197"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig14-10">Figure 14-10</a> shows the Ford-Fulkerson algorithm running on an example graph, where each subfigure represents the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> after one iteration of the algorithm. Bolded arrows indicate the augmenting path found during each iteration, and the used portions of the capacities have been updated to fully use that augmenting path, as shown by the <i>X</i> of <i>Y</i> notation along each edge.</p>&#13;
<figure class="IMG"><img id="fig14-10" class="img100" src="../images/f14010.jpg" alt="Each subfigure shows the same graph with 7 nodes and 10 edges. The graph in (A) has no edges using capacity. (B) shows the same graph with edges (0, 1), (1, 3), and (3, 6) bolded. All the edges use 2 of their capacity." width="1634" height="1674"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: The steps of the Ford-Fulkerson algorithm with depth-first search on a graph with seven nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label="246"/><a href="#fig14-10">Figure 14-10</a> demonstrates how using depth-first search impacts the order in which the Ford-Fulkerson algorithm retrieves augmenting paths. For example, although there is a capacity-3 path along the bottom of the example graph via edges (0, 2), (2, 5), and (5, 6), the algorithm first fills in some smaller flows, such as the capacity-1 path in <a href="#fig14-10">Figure 14-10(c)</a>.</p>&#13;
<p class="TX"><a href="#fig14-10">Figure 14-10(e)</a> shows an augmenting path that uses both forward and backward residuals. To increase the flow through edge (4, 6) into the sink, the algorithm redirects flow out of node 1 from edge (1, 3) to edge (1, 4). This gives node 4 an input of 2 units that the algorithm can pass along to the sink. However, it leaves node 3 short by 1 unit. The search offsets this loss of input at node 3 with an additional flow from the source through edge (0, 3).</p>&#13;
<p class="TX">Once the algorithm has computed the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>, we can use that data structure to answer other questions. For example, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">compute _total_flow()</samp> function to compute the graph’s maximum flow.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-198"/><samp class="SANS_Futura_Std_Bold_B_11">The Edmonds-Karp Algorithm</samp></h3>&#13;
<p class="TNI1">The computer scientist Yefim Dinitz (under the name E.A. Dinic) and the pair of computer scientists Jack Edmonds and Richard M. Karp independently published analyses of the Ford-Fulkerson algorithm that selected augmenting paths with the fewest number of edges. This approach, now called either the <i>Dinitz algorithm</i> or the <i>Edmonds-Karp algorithm</i>, makes use of this path selection to avoid the problematic behavior when using irrational edge capacities and thus bounds the number of iterations of the algorithm in all cases. This section shows how we can use breadth-first search to find such augmenting paths.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h-199"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The majority of the Edmonds-Karp algorithm uses the functions introduced earlier for the Ford-Fulkerson algorithm, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>. All we need to change is the function for finding the augmenting paths and the outer function that calls it.</p>&#13;
<p class="TX">We use a modified version of breadth-first search to find the augmenting paths:</p>&#13;
<pre><code>def find_augmenting_path_bfs(g: ResidualGraph) -&gt; list: &#13;
    seen: list = [False] * g.num_nodes&#13;
    last: list = [-1] * g.num_nodes&#13;
    pending: queue.Queue = queue.Queue()<span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label="247"/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> seen[g.source_index] = True&#13;
    pending.put(g.source_index)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> while not pending.empty() and not seen[g.sink_index]:&#13;
        current: int = pending.get()&#13;
        for n in g.all_neighbors[current]:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if not seen[n] and g.get_residual(current, n) &gt; 0:&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> pending.put(n)&#13;
                seen[n] = True&#13;
                last[n] = current&#13;
&#13;
    return last&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp> function starts by setting up the standard breadth-first search data structures, including the list of whether each node has been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>), the list of previous nodes on the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), and the queue of nodes to explore (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>). The use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp> data structure requires an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">import queue</samp> at the top of the file. The function then inserts the source node as the starting point <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. The main <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop continues until either the pending queue is empty or the sink node has been seen <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. As in the depth-first search code, this second check allows the search to terminate as soon as it finds <i>any</i> path from the source to the sink.</p>&#13;
<p class="TX">When exploring the neighbors of the current node, the code checks both that the node has not been seen (as in standard breadth-first search) and that the residual is nonzero <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. If the edge is viable and the node has not been seen, the search updates the tracking information and adds it to the queue <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX"><a href="#fig14-11">Figure 14-11</a> shows the iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp> on a graph with some of its capacity used. The shaded nodes have been seen, and the node enclosed in the dashed circle is the one the search has just <i>finished</i> processing.</p>&#13;
<p class="TX"><a href="#fig14-11">Figure 14-11(a)</a> shows the state of the algorithm before the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop starts, while <a href="#fig14-11">Figure 14-11(b)</a> shows the first step of the search. After visiting node 0, we find edges with unused capacity to two unvisited neighbors (nodes 1 and 3). Both neighbors are added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> queue.</p>&#13;
<p class="TX">The algorithm diverges from a standard breadth-first search in <a href="#fig14-11">Figure 14-11(c)</a>. Although node 2 is a neighbor of node 1, the edge (1, 2) is already full. We cannot send any more flow through that edge, so the algorithm rules out paths using that edge and keeps node 2 as unseen. It is not until <a href="#fig14-11">Figure 14-11(d)</a> that it finds a viable route to node 2 (from node 3).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label="248"/>&#13;
<figure class="IMG"><img id="fig14-11" class="img100" src="../images/f14011.jpg" alt="Each subfigure shows a six-node graph with eight edges. In (A), node 0 is shaded and no nodes are circled. In (B), node 0 is circled and nodes 0, 1, and 3 are shaded." width="1662" height="1803"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: The steps of the search to find an augmenting path</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label="249"/>The search completes in <a href="#fig14-11">Figure 14-11(e)</a> after finding a path to the sink node. At this point, it has found a viable path [0, 1, 4, 5] from the source to the sink and need not consider any other nodes.</p>&#13;
<p class="TX">The code for the top-level Edmonds-Karp algorithm is nearly identical to the depth-first search version of Ford-Fulkerson from <a href="#list14-1">Listing 14-1</a>:</p>&#13;
<pre><code>def edmonds_karp(g: Graph, source: int, sink: int) -&gt; ResidualGraph: &#13;
    residual: ResidualGraph = ResidualGraph(g.num_nodes, source, sink)&#13;
    for node in g.nodes:&#13;
        for edge in node.edges.values():&#13;
            residual.insert_edge(edge.from_node, edge.to_node, edge.weight)&#13;
&#13;
    done = False&#13;
    while not done:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> last: list = find_augmenting_path_bfs(residual)&#13;
        if last[sink] &gt; -1:&#13;
            min_value: float = residual.min_residual_on_path(last)&#13;
            residual.update_along_path(last, min_value)&#13;
        else:&#13;
            done = True&#13;
    return residual&#13;
</code></pre>&#13;
<p class="TX">The only significant change from <a href="#list14-1">Listing 14-1</a> is the use of the function <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp> to conduct the search for an augmenting path <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2"><span id="sec17"/><span id="h-200"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig14-12">Figure 14-12</a> shows an example of running the Edmonds-Karp algorithm on a graph with 8 nodes and 11 edges, where node 0 is the source node and node 7 is the sink node. <a href="#fig14-12">Figure 14-12(a)</a> represents the state of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> before the first iteration. None of the edges’ capacities are used. Each subsequent step of the algorithm is depicted <i>after</i> each augmenting path is updated; the bolded edges indicate the augmenting path used. For example, in <a href="#fig14-12">Figure 14-12(b)</a>, the edges (0, 1), (1, 2), and (2, 7) form the augmenting path. The minimum residual was 3, and the subfigure shows the amount of used capacity after 3 more units of flow were added to this path.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label="250"/>&#13;
<figure class="IMG"><img id="fig14-12" class="img100" src="../images/f14012.jpg" alt="Each subfigure shows the same graph with 8 nodes and 11 edges. The graph in (A) has no edges using capacity. (B) shows the same graph with edges (0, 1), (1, 2), and (2, 7) bolded. All the edges use 3 units of their capacity." width="1632" height="1650"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: The steps of the Edmonds-Karp algorithm on a graph with eight nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="#fig14-12">Figure 14-12(f)</a> shows a step where the algorithm uses the backward residual. After four rounds of following only forward edges, the search has hit a bottleneck and <i>reduces</i> the flow on the edge from node 5 to node 4 to free up more capacity. To understand how this helps, consider the flow from node 0 to node 5. Before the last step, it is already maxed out. The edge cannot handle more than 10 units of flow. However, that flow is not being used optimally. By reducing the flow from node 5 to node 4, we can send more of that flow through node 6 to the sink. This leaves node 4 with less incoming flow than outgoing flow. To fix this disparity, we need to push more flow through an alternate path. In this case, the extra unit of flow comes to node 4 through the path [0, 1, 2, 3, 4].</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label="251"/>&#13;
<h3 class="H1" id="sec18"><span id="h-201"/><samp class="SANS_Futura_Std_Bold_B_11">Modeling Increasingly Complex Real-World Situations</samp></h3>&#13;
<p class="TNI1">Our maximum-flow algorithm placed restrictions on the structure of the graph to simplify reasoning about the algorithm. These constraints included limiting the graph to a single source and a single sink and prohibiting anti-parallel edges. This section examines how we can relax several of these limitations to model increasingly complex real-world situations.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h-202"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Sources</samp></h4>&#13;
<p class="TNI1">Many real-world flow networks contain more than a single source node. For example, consider the more realistic view of the wastewater problem we have been using throughout this chapter. Rather than a single incoming pipe, it’s far more likely that the network will include pipes entering from each building connected to the system. Even if we model at the city level, we can expect new sources to join the network from the surrounding suburbs. <a href="#fig14-13">Figure 14-13(a)</a> shows a network with three source nodes.</p>&#13;
<figure class="IMG"><img id="fig14-13" class="img60" src="../images/f14013.jpg" alt="(B) shows the graph from subfigure A with a new node (s’) inserted on the left and edges to the three s nodes in subfigure A’s graph." width="933" height="980"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-13: A flow graph with multiple sources (a) and the corresponding model with a single aggregate source (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Luckily, we can easily extend the flow network model by adding a new artificial source node <i>s</i><span class="symbol">′</span> that effectively supplies each of the previous sources. The new source node is connected by directed edges to each of the previous source nodes. In turn, those previous sources now become internal nodes in our extended model, as shown in <a href="#fig14-13">Figure 14-13(b)</a>. The bolded arrows indicate new edges added from the new node to the previous source nodes.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label="252"/>Of course, our artificial source node does not exist in reality. A city’s storm drains are not fed by a secret super-drain. Instead, the aggregated source serves as a convenient mathematical abstraction that allows us to assign the source of all flow back to a single (virtual) node.</p>&#13;
<p class="TX">Adding the new node and edges raises the question of how we choose the capacity of those new edges. If we set their capacity too low, these edges will serve as a bottleneck, preventing us from accurately modeling the problem. However, it doesn’t matter if we set the edge weights too high, because the bottleneck will then be the already-existing bottleneck in the original network. We can therefore use infinite capacities along those new edges to supply the previous sources with all the flow they can handle. In the context of the wastewater system, these would be gigantic pipes that vastly exceed the flow of anything the engineers could actually build.</p>&#13;
<p class="TX">We create a helper function to augment an arbitrary graph with multiple sources to add the aggregate source, as shown in <a href="#list14-2">Listing 14-2</a>.</p>&#13;
<span id="list14-2"/>&#13;
<pre><code>def augment_multisource_graph(g: Graph, sources: list) -&gt; int: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> new_source: Node = g.insert_node()&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> for old_source in sources:&#13;
        g.insert_edge(new_source.index, old_source, math.inf)&#13;
    return new_source.index&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: Transforming a multi-source graph into one with a single source</samp></p>&#13;
<p class="TX">The code inserts a new node into the graph <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. For each of the previous sources, it then creates a new edge from the new source to the previous source with infinite capacity <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. Finally, the code returns the index of the new source for us to use when calling the Ford-Fulkerson algorithm.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h-203"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Sinks</samp></h4>&#13;
<p class="TNI1">Just as many real-world problems have multiple sources, we often encounter networks with multiple sinks. Consider the interstate highway system, for example, where cars and trucks flow along the roads to numerous divergent destinations. <a href="#fig14-14">Figure 14-14(a)</a> shows a network with two sink nodes.</p>&#13;
<p class="TX">We can adapt the approach we used for the multi-source problem to handle multiple sinks. We create a new aggregated sink <i>t</i><span class="symbol">′</span> and create directed edges from each previous sink to the new aggregate, as shown in <a href="#fig14-14">Figure 14-14(b)</a>. The new node and edges are bolded. We assign each of these edges enough capacity so they cannot generate a new bottleneck.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_253" aria-label="253"/>&#13;
<figure class="IMG"><img id="fig14-14" class="img60" src="../images/f14014.jpg" alt="(B) shows the graph from (A) with a new node (t’) inserted on the right and edges from the two t nodes in (A)’s graph." width="939" height="1007"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: A flow graph with multiple sinks (a) and the corresponding model with a single aggregate sink (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Again, we provide a helper function to augment a given graph with multiple sinks:</p>&#13;
<pre><code>def augment_multisink_graph(g: Graph, sinks: list) -&gt; int: &#13;
    new_sink: Node = g.insert_node()&#13;
&#13;
    for old_sink in sinks:&#13;
        g.insert_edge(old_sink, new_sink.index, math.inf)&#13;
    return new_sink.index&#13;
</code></pre>&#13;
<p class="TX">The code follows the form of the <samp class="SANS_TheSansMonoCd_W5Regular_11">augment_multisource_graph()</samp> function in <a href="#list14-2">Listing 14-2</a>. It inserts a new sink node into the graph, creates edges with sufficient capacity to each of the old sinks, and returns the index of this new node.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h-204"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anti-parallel Edges</samp></h4>&#13;
<p class="TNI1">It is also unrealistic to prohibit anti-parallel edges in real-world use cases. Continuing with the example of the interstate highway system, nearly every highway is a two-way road: you can travel Route 90 from Cleveland to Buffalo or from Buffalo to Cleveland.</p>&#13;
<p class="TX">We can use another mathematical trick to support such real-world cases while maintaining the restriction that the graph must not have anti-parallel edges. When dealing with a loop with edges (<i>u</i>, <i>v</i>) with capacity <i>w</i><sub>1</sub> and (<i>v</i>, <i>u</i>) with capacity <i>w</i><sub>2</sub>, as shown in <a href="#fig14-15">Figure 14-15(a)</a>, we can add a new node <i>x</i> and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_254" aria-label="254"/>replace the edge (<i>u</i>, <i>v</i>) with the pair of edges (<i>u</i>, <i>x</i>) and (<i>x</i>, <i>v</i>), as shown in <a href="#fig14-15">Figure 14-15(b)</a>. If we use the same capacity <i>w</i><sub>1</sub> of the previous edge (<i>u</i>, <i>v</i>) for both edges (<i>u</i>, <i>x</i>) and (<i>x</i>, <i>v</i>), the total flow allowed through the expanded path is the same (<i>w</i><sub>1</sub>).</p>&#13;
<figure class="IMG"><img id="fig14-15" class="img100" src="../images/f14015.jpg" alt="(B) shows the graph from (A) where a new node x has been inserted and the directed edge from (u, v) has been replaced with edges (u, x) and (x, v)." width="1677" height="483"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-15: A graph with a loop containing two edges (a) and its augmented version (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We could define a single preprocessing step that iterates over all edges in the graph and inserts extra nodes and edges where needed. If the original graph contains an edge (origin, destination) and the edge’s inverse (destination, origin), then we have anti-parallel edges and need to insert a single new node.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h-205"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">We can use the maximum-flow problem to answer a wide range of real-world analysis and optimization questions. Beyond simply finding the maximum flow from source to sink, the techniques for solving the maximum-flow problem provide crucial insights into the network itself: we can use the residual graph to find bottlenecks or discover which links have excess capacity. For example, suppose our analysis of a proposed wastewater processing system reveals that a pipe with capacity of 50 gallons per minute will be used only for 10 gallons per minute due to restrictions elsewhere in the network. We now know this pipe presents a clear cost-saving opportunity.</p>&#13;
<p class="TX">The algorithmic approaches in this chapter also provide new ways of thinking about and working with graphs. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> data structure is an expansion on the standard edge that allows for tracking dynamic amounts, and the paths through a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> change as flow is applied. This is the first time we have seen an algorithm that needs to account for dynamic quantities related to edges.</p>&#13;
<p class="TX">As we will see in the next chapter, the maximum-flow algorithm has extensions to more general matching problems, including optimizing the connections between pairs of nodes. We will also see how these techniques can be applied to the more abstract problem of maximum-cardinality bipartite graph matching.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>