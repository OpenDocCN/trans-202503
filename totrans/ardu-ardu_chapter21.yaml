- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">21</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RETRIEVE
    THE CURRENT TIME FROM AN INTERNET TIME SERVER</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: When building projects that rely on keeping track of the current time (such
    as for logging data, creating planned events, or just making your own clocks),
    it’s common to use a real-time clock IC. For increased time and date accuracy,
    however, you can use an ESP32 Arduino-compatible board to retrieve the current
    time and date from an internet time server. Using the ESP32 also saves you the
    cost of an RTC IC or module and a separate Arduino or compatible board when building
    a new project and allows you to set your required time zone in the code, rather
    than in a separate interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn about the Network Time Protocol (NTP), install
    and test the NTP client library for Arduino, and extract the time and date components
    for your own projects. You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a compact clock with an OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a dual-time clock that displays time at home and at another location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a giant, super-bright digital clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Network Time Protocol</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally standardized in the mid-1980s, NTP is a method of synchronizing connected
    computers to the Coordinated Universal Time (formally known as Greenwich Mean
    Time, or GMT). The NTP allows for an accuracy of 1 millisecond or better. In general
    use, the margin of error is around 100 milliseconds, but a difference of one-10th
    of a second is easily accurate enough for timing-related Arduino projects.
  prefs: []
  type: TYPE_NORMAL
- en: You can retrieve the time from the NTP server either in the usual 24-hour time
    and standard date format or in the format of *epoch time*. This is the number
    of seconds since January 1, 1970, from which you can make your own calculations
    to determine the current date and time. Some people use epoch time to calculate
    their own types of time, such as metric time.
  prefs: []
  type: TYPE_NORMAL
- en: There are many NTP servers available around the world, each with its own address.
    Generally, the one closest to your location should have the fastest connection
    to your project, but you might want to use a different server depending on your
    internet routing. Check [*https://<wbr>www<wbr>.pool<wbr>.ntp<wbr>.org<wbr>/zone<wbr>/@*](https://www.pool.ntp.org/zone/@)
    to find the server address most appropriate for you and then use that to replace
    my default NTP server in the code for this chapter’s projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to know your *time zone offset*: the number of hours before
    or after GMT, or in more contemporary parlance, the Coordinated Universal Time.
    This is based on the values listed at [*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/List<wbr>_of<wbr>_UTC<wbr>_offsets*](https://en.wikipedia.org/wiki/List_of_UTC_offsets).
    For example, if you live in London, set your offset to 0, as your time zone falls
    in the value of UTC (or GMT) 0\. If you live in Los Angeles, California, the time
    zone is UTC −8\. This means you’d use a value of −28,800, as LA is 8 hours behind
    UTC, multiplied by 3,600 to convert to seconds. Finally, the update interval value
    of 60,000 is the update interval in milliseconds. This is set to a default that
    equates to one minute, as you don’t need to update the time more than once a second.'
  prefs: []
  type: TYPE_NORMAL
- en: To prepare to build the projects in this chapter, download and install the NTP
    Client library for Arduino directly from my GitHub page. Visit [*https://<wbr>github<wbr>.com<wbr>/taranais<wbr>/NTPClient*](https://github.com/taranais/NTPClient)
    and click **Code** in the center of the screen. A small menu should appear, as
    shown in [Figure 21-1](chapter21.xhtml#fig21-1). Click **Download ZIP** to download
    the library ZIP file to your PC. If the Arduino IDE ever prompts you to update
    this library, don’t—use the first version you already installed.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE NTP CLIENT LIBRARY GITHUB PAGE](../images/fig21-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-1: Downloading the
    NTP Client library</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Arduino IDE and install the library by selecting **Sketch** ![](../images/arr.png)
    **Include Library** ![](../images/arr.png) **Add .ZIP Library.** Once the library
    installs, restart the Arduino IDE to continue.
  prefs: []
  type: TYPE_NORMAL
- en: You’re ready to start using internet time in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #61: Retrieving the Time and
    Date</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project serves as a framework for retrieving the time and date from an
    NTP server and then extracting the elements of date and time (hours, minutes,
    and so on) so you can use them in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: The project uses the Serial Monitor to display the time and date, so for hardware,
    you’ll need only the ESP32 dev board and matching USB cable as used in previous
    chapters. If you haven’t already, turn to [Chapter 19](chapter19.xhtml) and follow
    “Configuring the Arduino IDE for the ESP32” through “Testing the ESP32” to install
    the required board profiles for the Arduino IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the Project #61 sketch, adding your Wi-Fi network credentials
    in the SSID and password fields near the top of the sketch (as originally explained
    for Project #55 in [Chapter 19](chapter19.xhtml)). Once the sketch has uploaded,
    the ESP32 should attempt to connect to your Wi-Fi network and then retrieve and
    display the time and date information in the Serial Monitor, as shown in [Figure
    21-2](chapter21.xhtml#fig21-2).'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OUTPUT FROM PROJECT #61](../images/fig21-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-2: Example output
    from Project #61</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, the sketch includes the required libraries for Wi-Fi and the NTP client
    and creates an instance of the timer server <samp class="SANS_TheSansMonoCd_W5Regular_11">ntp</samp>
    ❶. Next, it stores the name and password of the Wi-Fi network for use by the Wi-Fi
    library ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">NTPClient timeClient()</samp>
    function accepts the NTP server address to use, the required time zone offset,
    and the update interval. As mentioned in the previous section, try the default
    time server address supplied in the code or find one closer to your location.
    For the time zone offset, replace the value in the code with the offset appropriate
    for your location.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, various
    string variables are declared for storing time and date information, followed
    by a force update of the time client ❸ to get the latest time and date from the
    server. The next three functions demonstrate how to retrieve the time and date
    information in different formats and display their values on the Serial Monitor.
    The first is <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getEpochTime()</samp>,
    which retrieves the epoch time. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getFormattedDate()</samp>
    shows the entire time and date in the previously set time zone with the date in
    *yyyy*-*mm*-*dd* format, followed by the letter *T* (for “time”) and then the
    current time in 24-hour time. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getFormattedTime()</samp>
    shows the current time in *hh*:*mm*:*ss* format.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the sketch demonstrates how to extract individual pieces of time and date
    information. The <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getDay()</samp>
    function returns an integer between 0 and 6 that represents the day of the week,
    from Sunday through Saturday, respectively. This is used in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function ❹ to determine the current day and display the name in the Serial Monitor.
    The sketch displays the individual values for hours, minutes, and seconds with
    the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getHours()</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getMinutes()</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getSeconds()</samp>,
    which all return their respective values as integers. The code also includes a
    test for values less than 10 for minutes and seconds to add a 0 if necessary for
    the proper time format. This is so that you don’t end up with a time display of
    9:5:00 for five minutes past 9 AM, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the day, month, and year is a little different. The sketch first retrieves
    the entire time and date using <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.getFormattedDate()</samp>❺
    and then stores the values for the date, month, and year in string variables using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.substring</samp> functions. For
    example, the year falls within the first four characters of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">dateString</samp>,
    so the function <samp class="SANS_TheSansMonoCd_W5Regular_11">dateString.substring(0,4)</samp>
    will return those first four characters. Finally, there’s a delay of 1 second
    before the process repeats.
  prefs: []
  type: TYPE_NORMAL
- en: If your project loses its connection to your Wi-Fi network, the time will stay
    the same and not update until the ESP32 can reconnect to the NTP server, at which
    point the time and date will automatically update.
  prefs: []
  type: TYPE_NORMAL
- en: The following projects use this sketch as a framework for retrieving the time
    and date and displaying the results on different devices.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #62: Displaying the Time and
    Date on an OLED</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project demonstrates how to display the time and date from an NTP server
    on the inexpensive OLED display you first used in [Chapter 10](chapter10.xhtml).
    You could modify this project to control other types of displays, such as LCDs
    or even Nixie tubes, if so inclined.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: An ESP32 Arduino-compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 128 × 32 pixel, 0.91-inch OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is your first time using the OLED display, please turn to [Chapter 10](chapter10.xhtml)
    and follow the instructions in “Graphic OLED Displays” on page 149 to the point
    where you have tested the OLED and then assemble the circuit as shown in [Figure
    21-3](chapter21.xhtml#fig21-3).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Although your OLED might be marked as a 5 V device, the specified model also
    works on 3.3 V without a level converter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #62](../images/fig21-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-3: The schematic
    for Project #62</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the Project #62 sketch, updating your Wi-Fi network details
    as appropriate. The OLED should display a message telling you the ESP32 is attempting
    to connect to Wi-Fi, as shown in [Figure 21-4](chapter21.xhtml#fig21-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE OLED DISPLAY DURING THE INITIAL CONNECTION TO WI-FI: “CONNECTING TO WI-FI…”](../images/fig21-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-4: The project connecting
    to Wi-Fi</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has connected to the NTP server, the OLED should display the
    current time and date, along with the day of the week, as shown in [Figure 21-5](chapter21.xhtml#fig21-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #62: “10:49:09 MON 09/01/2023”](../images/fig21-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-5: Example output
    from Project #62</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The sketch includes and initializes the libraries required for Wi-Fi, the NTP
    client, the I²C bus, and the OLED. Set the fields for your Wi-Fi network details,
    as usual.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then initiates an instance of the NTP client and sets up the pool
    server, time zone offset, and update intervals ❶. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, it starts the I²C bus, OLED display library, and Serial Monitor
    for debugging and then initializes the Wi-Fi. The next block of code causes the
    “Connecting …” message to appear on the OLED during the connection process ❷.
    The sketch then starts the NTP client library.
  prefs: []
  type: TYPE_NORMAL
- en: The code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>
    aims to assemble the time information and display it on the top line of the OLED
    and then assemble the date information and display it on the bottom line. This
    starts by retrieving the time ❸ and then adding a 0 to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED1</samp>,
    which will contain the time data for hours, minutes, and seconds if the individual
    piece of data is below 10\. The hour, minute, and second values are then added
    into their respective string variables, which are finally concatenated into one
    string for display ❹.
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the date string ❺, the code retrieves the day of week and places
    it inside the string <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED2</samp>,
    which it uses to display the entire date via the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function. Next, it retrieves the day, month, and year and adds that data to the
    main date string, including with separators for a neat display ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the sketch sends the two lines of data, <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED2</samp>, to the OLED for
    display ❼. As demonstrated in the code, you must add the suffix <samp class="SANS_TheSansMonoCd_W5Regular_11">.c_str</samp>
    to the variable name to tell the OLED library to convert the variable from a string
    to usable data.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the hardware for this project assembled. In the next project, you’ll use
    it to make a dual-zone clock that takes advantage of the offset function in the
    NTP library.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #63: Displaying Two Time Zones
    on an OLED</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project shows you how to display the time in two zones simultaneously on
    the OLED display used in the previous project. This might be useful if you’re
    a HAM radio operator or if you often communicate with friends, family, or colleagues
    in different time zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required hardware and assembly are the same as Project #62\. Once the hardware
    is ready, enter and upload the Project #63 sketch. Don’t forget to add your Wi-Fi
    network credentials into this sketch. After the ESP32 connects to the Wi-Fi network,
    the OLED should display the “home zone” time for the east coast of Australia (where
    I live) and display the “away zone” time for San Francisco in the United States
    (the home of No Starch Press), as shown in [Figure 21-6](chapter21.xhtml#fig21-6).'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #63: “HOME 11:25:11 SFO 17:25:11”](../images/fig21-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-6: Example display
    for Project #63</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn to change the time zones, let’s take a closer look at the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This sketch is similar to the one for Project #62, in that it also assembles
    two lines of data to display on the OLED. To create a dual-zone clock, the code
    begins by setting the time zone offset for the first zone ❶. The example home
    time zone in the sketch is for Brisbane, which is UTC +10, so the offset value
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.setTimeOffset()</samp>
    function is 36,000 (3,600 multiplied by +10 hours), but you can change this to
    match whichever time zone you like. Following this, the sketch retrieves the time
    data and assembles it into the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED1</samp>
    ❷, preceding it with the label <samp class="SANS_TheSansMonoCd_W5Regular_11">Home</samp>.
    The sketch then blanks out the string variables used to temporarily hold retrieved
    time data for reuse ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: The same process repeats for a second time zone. I’ve used the example of San
    Francisco, which is UTC –8, meaning that the offset value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeClient.setTimeOffset()</samp>
    function is –28,800 (3,600 multiplied by –8 hours). The sketch retrieves and assembles
    the time date into the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">OLED2</samp>
    ❹, starting with a label for the away zone <samp class="SANS_TheSansMonoCd_W5Regular_11">SFO</samp>.
    Finally, it sends the two strings of data to the OLED for display ❺, followed
    by a short delay before the entire process repeats.
  prefs: []
  type: TYPE_NORMAL
- en: For a challenge, you might try modifying this project to scroll through various
    time zones at the press of a button.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #64: Building a Giant Digital
    Clock</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter’s final project, let’s have some fun and build a giant digital
    clock using the seven-segment LED modules from Project #27 in [Chapter 8](chapter8.xhtml).
    Once assembled, you could use this project to keep time in your workshop as an
    example of your prowess.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t already have the seven-segment LED modules set up, revisit Project
    #27 and build the four required display boards. (For a challenge, you might make
    six boards so you can display seconds in addition to minutes and hours.) Apart
    from the display boards, wiring, and 9 V DC 1A power supply covered in that project,
    you will only need the ESP32 board used in this chapter and the usual jumper wires
    and USB cable.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The TPIC6B595 shift register ICs used in the LED display boards are both 3.3
    V and 5 V tolerant, so you don’t need to connect a level shifter between them
    and the ESP32 board.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have connected the four display boards, upload the Project #64 sketch.
    Using the connections diagrammed in [Figure 21-7](chapter21.xhtml#fig21-7), connect
    the ESP32 to the first display board (the one on the left of the figure).'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE CONNECTION DETAILS BETWEEN THE ESP32 AND THE FIRST DISPLAY BOARD](../images/fig21-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-7: The connection
    layout between the ESP32 and first display board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the power to the first display board. The ESP32 should connect to the
    Wi-Fi network and retrieve the time. Stand back to see all four digits light up
    with the current time, as shown in [Figure 21-8](chapter21.xhtml#fig21-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![PROJECT #64 IN OPERATION, SHOWING 21.15H](../images/fig21-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 21-8: Project #64 in
    action</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works in the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The operations in this sketch should be familiar to you at this point. The code
    includes the required libraries and Wi-Fi network details. It then creates an
    instance of the NTP client with the pool server, time zone offset, and update
    interval details. For easy reference, the sketch defines the pin numbers used
    for the outputs to the shift registers on the display boards ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The array <samp class="SANS_TheSansMonoCd_W5Regular_11">digits[]</samp> holds
    the 10 bytes of data used to define how a digit is displayed on the LED boards,
    where each bit represents one of the seven segments used to comprise a digit.
    The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">sendNumbers()</samp>
    function accepts an array of four integers to display on the four LED boards,
    as well as another integer that, if used, turns on the decimal point on the matching
    LED board.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the code
    initializes the required digital pins, sets up the Serial Monitor for debugging,
    and starts the Wi-Fi connection and the NTP client ❷. The code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp> updates the NTP client for the latest time information ❸ and then
    retrieves and stores the hours and minutes in variables. The time must be broken
    down into single digits before it’s sent to the LED boards, so the use of modulo
    and division ❹ on the hours and minutes values returns the first and second digits,
    which are then stored in the array <samp class="SANS_TheSansMonoCd_W5Regular_11">numbers[]</samp>.
    Finally, the sketch sends those digits to the display using <samp class="SANS_TheSansMonoCd_W5Regular_11">sendNumbers()</samp>,
    with the decimal point placed at the second digit as separator between hours and
    minutes ❺.
  prefs: []
  type: TYPE_NORMAL
- en: For a final challenge, you can try altering the code in any of the projects
    in this chapter to use 12-hour time rather than 24-hour time. To do so, you must
    subtract 12 from any hour value that is 13 or more before displaying that hour.
    You could, of course, also add a test for AM and PM.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to harness accurate time and date information
    from the internet and show that information using various display types. Armed
    with these skills, you might try building additional clocks with various displays
    as practice for other projects that require the time and date.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers another way to use the ESP32, demonstrating how to capture
    data from the dev board into the Google Sheets app for analysis.
  prefs: []
  type: TYPE_NORMAL
