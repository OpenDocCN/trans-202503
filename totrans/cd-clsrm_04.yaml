- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Computational Thinking Gamified and Unplugged
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算思维的游戏化和断开连接模式
- en: In this chapter, we’ll look at some of the more discrete elements of computer
    programs. This information includes coding concepts, such as variables; control
    structures; functions; and computational thinking concepts, such as algorithms,
    modeling, and abstraction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将研究计算机程序中的一些更为离散的元素。这些信息包括编码概念，如变量；控制结构；函数；以及计算思维概念，如算法、建模和抽象。
- en: A common lament among K–8 teachers now tasked with teaching computer science
    concepts in addition to their other subjects is that they don’t know how to teach
    these seemingly technical concepts. But as we’ll see, they’re concepts we’re already
    using in our daily lives. Recognizing that fact turns each concept into a tool
    we can integrate with existing classroom topics to enhance our teaching practice.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在许多K–8年级的教师除了教授其他学科外，还需要教授计算机科学概念，他们常常感叹自己不知道如何教授这些看似技术性的概念。但正如我们将看到的，这些概念其实是我们日常生活中已经在使用的。认识到这一点会将每个概念转化为一种工具，我们可以将其与现有的课堂主题结合，以增强我们的教学实践。
- en: 'Throughout this chapter, you’ll learn about ways to teach these concepts in
    class without the use of computers. Computers are powerful tools for learning,
    but they’re also isolating: students quietly turn away from each other while they’re
    plugged into screens that put them through rote learning exercises. There is a
    time and place for such deep, sustained focus. But here you’ll learn about group
    activities, games, and creative projects that will exercise your students’ computational
    thinking muscles without screen time.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在不使用计算机的情况下，在课堂上教授这些概念。计算机是强大的学习工具，但它们也让人孤立：学生们在沉浸于屏幕中进行死记硬背的学习时，安静地远离彼此。虽然有时需要这种深度、持续的专注，但在这里，你将学习到小组活动、游戏和创造性项目，这些活动能够在不使用屏幕时间的情况下锻炼学生的计算思维能力。
- en: Variables
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: Let’s begin with the most elementary programming unit, the *variable*, a label—preferably
    one intuitive to other humans—that identifies a piece of data. As we learned in
    the previous chapter, in low-level programming languages, variables are coupled
    to specific storage locations in the computer. In high-level programming languages,
    we don’t need to worry about memory allocation; instead, we only need to understand
    a variable as a name identifier given to a piece of information known as its *value*.
    Variables can point to different kinds of data as values, such as integers, strings,
    Booleans, and lists; because variables don’t actually hold data, but rather point
    to a location in the computer’s memory, we can reuse a single variable throughout
    a software application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基础的编程单元——*变量*开始，它是一个标签——最好是对其他人直观易懂的标签——用来标识一块数据。正如我们在上一章所学到的，在低级编程语言中，变量与计算机中的特定存储位置相连接。而在高级编程语言中，我们不需要担心内存分配；相反，我们只需将变量理解为赋予一块信息的名称标识，这块信息被称为它的*值*。变量可以指向不同类型的数据作为值，例如整数、字符串、布尔值和列表；因为变量实际上并不保存数据，而是指向计算机内存中的某个位置，所以我们可以在整个软件应用中重复使用同一个变量。
- en: A popular way to explain variables to students with a real-world example is
    to have them think of each variable in a program as a container in a series of
    named containers, such as labeled folders in a filing cabinet. To see this concept
    in action, try taking your students to the library. The shelves are like memory
    in a computer, and each one can only hold so many books or so much data. The labels
    are like the memory addresses in the computer. What is the book variable value
    for the address 343.73099 Les? 793.93 Coo? With a little forethought, you can
    construct a fun adventure using the Dewey Decimal System classifications, pretending
    they’re memory addresses in a huge computer that is the library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 向学生解释变量的一种常见方式是通过现实生活中的例子，让他们将程序中的每个变量看作一系列命名容器中的一个，例如文件柜中的标签文件夹。为了让这个概念更加生动，可以尝试带学生去图书馆。书架就像计算机中的内存，每个书架只能容纳一定数量的书籍或数据。标签就像计算机中的内存地址。地址343.73099
    Les的书本变量值是什么？793.93 Coo呢？通过一些前期思考，你可以构建一个有趣的冒险故事，利用杜威十进制分类系统，假装它们是图书馆这个巨大计算机中的内存地址。
- en: As their name suggests, a key feature of variables is that their contents can
    vary. For example, a string variable named currentPresidentOfTheUnitedStates might
    at one time contain the value George Washington and later contain the value Abraham
    Lincoln. An integer variable named currentYear might increment by one each time
    the date equals the first second of January 1\. A Boolean variable named stopLightGreen
    will switch between true and false as the light changes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，变量的一个关键特征是其内容可以变化。例如，一个字符串变量currentPresidentOfTheUnitedStates可能在某个时候包含值George
    Washington，而后来可能包含值Abraham Lincoln。一个整数变量currentYear可能在每次日期等于1月1日的第一秒时递增1。一个布尔变量stopLightGreen将在红绿灯变化时在true和false之间切换。
- en: Variables can also point to lists of values. Many programming languages allow
    you to store an *array*, or list of items, in a variable. Think of an array as
    a list of variables where each variable is identified by its location in the array.
    For example, the array of foodGroups[] might contain ['vegetables', 'fruits',
    'grains', 'meats', 'dairy']. The first element in an array is identified with
    a 0 instead of a 1—a fact that often trips up novice programmers and leads to
    many software bugs. So when we reference foodGroups[0], we get vegetables, and
    foodGroups[4] would return dairy. We can also have arrays of arrays, making them
    more complex. Table 4-1 shows a possible two-dimensional array of this food groups
    example.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以指向值的列表。许多编程语言允许你在变量中存储一个*数组*，即一系列项的列表。可以把数组想象成一个变量列表，其中每个变量通过其在数组中的位置来标识。例如，foodGroups[]数组可能包含['蔬菜',
    '水果', '谷物', '肉类', '乳制品']。数组中的第一个元素是通过0来标识的，而不是1——这一点常常让初学者困惑，导致很多软件错误。所以当我们引用foodGroups[0]时，我们得到的是蔬菜，而foodGroups[4]会返回乳制品。我们还可以拥有数组的数组，使其更加复杂。表4-1展示了这个食品组示例可能的二维数组。
- en: '**Table 4-1:** Two-Dimensional Food Groups Array'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-1：** 二维食品组数组'
- en: '| Vegetables | Fruits | Grains | Meats | Dairy |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 蔬菜 | 水果 | 谷物 | 肉类 | 乳制品 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Celery | Apples | Barley | Beef | Cheese |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 芹菜 | 苹果 | 大麦 | 牛肉 | 奶酪 |'
- en: '| Peas | Bananas | Oats | Chicken | Milk |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 豌豆 | 香蕉 | 燕麦 | 鸡肉 | 牛奶 |'
- en: '| Spinach | Oranges | Wheat | Pork | Yogurt |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 菠菜 | 橙子 | 小麦 | 猪肉 | 酸奶 |'
- en: Not including the table headers as part of this array of arrays, foodGroups[0][0]
    would return Celery, foodGroups[2][1] Oats, and foodGroups[4][2] Yogurt. Returning
    to the library, you can use the bookshelves to explain arrays and arrays of arrays.
    For example, the reference shelves might include labels like ['001-372', '373–803',
    '803–979'], and each of these labels references an array of books within these
    addresses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不包括表头作为数组的数组的一部分，foodGroups[0][0]将返回芹菜，foodGroups[2][1]返回燕麦，而foodGroups[4][2]返回酸奶。回到书架上，你可以使用书架来解释数组和数组的数组。例如，参考书架可能包含像['001-372',
    '373–803', '803–979']这样的标签，每个标签引用这些地址内的一系列书籍。
- en: 'Changing a single variable can have dramatic effects. A single character, or
    *char* data type variable, labeled currentVowel used to represent the second letter
    in the string ''b_t'' could generate words with very different meanings, such
    as ''bat'', ''bet'', ''bit'', ''bot'',  or ''but''. Here’s another example: as
    the floating-point variable representing parts per million (PPM) of carbon dioxide
    (CO2) molecules in the atmosphere—named cO2PPM—increases, solar radiation is captured
    as thermal radiation on planet Earth, and the average planetary temperature increases.
    When we model these subjects into programming code, we find that changing a single
    variable in a computational process can produce wildly different outputs.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 改变一个变量可能会产生戏剧性的效果。一个单一的字符，或者*字符型*数据类型变量，标记为currentVowel，用来表示字符串'b_t'中的第二个字母，可能会生成具有完全不同意义的单词，如'bat'、'bet'、'bit'、'bot'或'but'。这里还有一个例子：作为表示大气中二氧化碳（CO2）分子每百万分之一（PPM）的浮动变量——命名为cO2PPM——当它增加时，太阳辐射会作为热辐射被地球捕捉，导致行星的平均温度升高。当我们将这些主题转化为编程代码时，我们会发现，改变计算过程中的一个变量可以产生完全不同的输出。
- en: As you might have realized, and as your students will hopefully recognize, we’re
    already working with variables in our day-to-day academic lives. Identifying the
    variables in a range of academic contexts can formalize how we think about them.
    In the next section, we’ll explore how to formally manipulate variables using
    logical controls.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经意识到的，并且希望你的学生也能认识到，我们在日常学术生活中已经在使用变量。识别各种学术情境中的变量可以帮助我们更正式地思考它们。在接下来的部分中，我们将探讨如何通过逻辑控制正式操作变量。
- en: Control Structures
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制结构
- en: Variables are the most basic elements of our computational world. Once we define
    these elements, we can then start making decisions based on their values through
    *control structures*. Control structures are conditional statements that evaluate
    variables and decide what to do based on the values of those variables. There
    are also control structures that iteratively perform computational tasks, looping
    over conditional statements and evaluations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是我们计算世界中最基本的元素。一旦我们定义了这些元素，就可以开始根据它们的值做出决策，使用 *控制结构*。控制结构是评估变量并根据这些变量的值决定接下来的操作的条件语句。还有一些控制结构能够迭代地执行计算任务，循环评估条件语句。
- en: As noted in “Programming is Communication” on [page 19](CitC_c02.xhtml#_idTextAnchor029)
    communicating with a computer is like communicating with a very literal person.
    The control structures explained in the following subsections are formal, whereas
    natural language is messy. If we hold students’ use of natural language to formal
    standards, we can cultivate in them a more precise use of language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在《编程是沟通》中提到的，[第 19 页](CitC_c02.xhtml#_idTextAnchor029)，与计算机的沟通就像是与一个非常字面化的人沟通。接下来的各个小节中解释的控制结构是正式的，而自然语言则是混乱的。如果我们将学生使用自然语言的标准提高到正式的标准，就能够培养他们更精确的语言使用。
- en: Boolean Conditions
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔条件
- en: Programming control structures rely heavily on *Boolean conditions* to direct
    their flow. These statements evaluate to true or false and chain together with
    any number of andand oroperators. When Boolean conditions are connected with and,
    *all* the conditions must evaluate to true to satisfy the if statement. For example,
    if an organism eats other organisms and it has a spinal cord and it feeds its
    young with milk and it lays eggs and it has a beak, then it’s a platypus. When
    Boolean conditions are connected with or, *any* condition evaluating to true will
    satisfy the if statement. For example, if an organism nurses its young or it possesses
    a neocortex or it has fur or it has three middle ear bones, then it’s a mammal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编程控制结构在很大程度上依赖于 *布尔条件* 来引导程序的流程。这些语句的结果为真或假，并通过任何数量的 and 和 or 运算符连接。当布尔条件通过
    and 连接时，*所有* 条件必须为真，才能满足 if 语句。例如，如果一个生物吃其他生物，且它有脊髓，且它用乳汁喂养幼崽，且它下蛋，且它有喙，那么它就是鸭嘴兽。当布尔条件通过
    or 连接时，*任何* 条件为真都会满足 if 语句。例如，如果一个生物哺育幼崽，或者它拥有新皮层，或者它有毛发，或者它有三块中耳骨，那么它就是哺乳动物。
- en: if-then and else
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if-then 和 else
- en: 'A clerk evaluating a voter registration form in the United States must consider
    two variables: the applicant’s birth date and citizenship. If the birth date is
    equal to or greater than today’s date minus 18 years and they’re a US citizen,
    then the applicant will be registered to vote. This is an example of an if-then
    control statement, which works like this: if the Boolean conditions are true,
    then take this action. Likewise, there is also the if-then-else statement: if
    the conditions are true, then take this action; elsetake a different action. Although
    unstated in the voter registration example, the else flow path would be to deny
    the application, and the applicant would remain unregistered to vote.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国，一名工作人员在评估选民登记表时必须考虑两个变量：申请人的出生日期和国籍。如果出生日期等于或大于今天日期减去 18 年，并且他们是美国公民，那么申请人将被注册为选民。这是一个
    if-then 控制语句的示例，其工作原理如下：如果布尔条件为真，则执行此操作。同样，还有 if-then-else 语句：如果条件为真，则执行此操作；否则执行不同的操作。尽管在选民登记的示例中没有明确说明，但
    else 流程路径应该是拒绝申请，申请人将无法注册为选民。
- en: Between the if and else statements can come any number of else if conditions.
    Each evaluates a condition before moving on to the else statement. For example,
    if the birthDate check failed but the citizenship check passed, we might follow
    the if with else if USCitizen == true then deny the application and ask the applicant
    to reapply later when they’re old enough. Listing 4-3 shows an example of checking
    these conditions in JavaScript, a programming language for adding dynamic features
    to websites (you’ll learn to execute these features from your web browser in the
    next chapter).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 if 和 else 语句之间可以有任意数量的 else if 条件。每个条件在进入 else 语句之前都会进行判断。例如，如果出生日期检查失败，但公民身份检查通过，那么我们可能会跟随
    if 语句加上 else if USCitizen == true 来拒绝申请，并要求申请人等到足够年龄时再重新申请。清单 4-3 展示了在 JavaScript
    中检查这些条件的示例，JavaScript 是一种用于为网站添加动态功能的编程语言（你将在下一章学习如何通过浏览器执行这些功能）。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-3: Checking whether an applicant can register to vote'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-3：检查申请人是否可以注册投票
- en: In this very basic example that doesn’t account for leap years, time zones,
    or daylight saving time, the birthDate is set to the first day of the year 2000
    and USCitizen is set to true. We then calculate the difference between the birthDate
    and today into diffDays, and check whether the user is older than 567,648,000,000
    milliseconds in the first if statement, which is the number of milliseconds in
    18 years. If they’re not, we check whether USCitizen is true and tell them to
    come back later in the else if statement; finally, we tell them they’re ineligible
    if neither old enough or a US citizen in the else statement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常基础的示例中，我们没有考虑闰年、时区或夏令时，`birthDate`被设置为2000年第一天，`USCitizen`设置为`true`。然后，我们计算`birthDate`和今天之间的天数差，并在第一个`if`语句中检查用户是否已满567,648,000,000毫秒（18年的毫秒数）。如果没有，我们检查`USCitizen`是否为`true`，并在`else
    if`语句中提示他们稍后再来；最后，在`else`语句中告诉他们如果既不够年龄又不是美国公民，则不符合资格。
- en: 'Once students understand Boolean conditions and if-then control structures
    in programming flow, you can add the next powerful level of control: iteration
    through loops.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦学生理解了布尔条件和编程流程中的`if-then`控制结构，接下来就可以引入下一个强大的控制级别：通过循环进行迭代。
- en: Loops
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: One of the central concepts in computer science is *iteration*, where a set
    of programming instructions are executed repeatedly for a specified number of
    times or until a condition is met. We iterate over various things in our daily
    lives often without realizing it. We iterate over the days of the week to keep
    track of our schedules. We iterate over our future bills and paychecks to manage
    our finances. In programming, we emulate these iterative processes in controls
    called *loops*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的一个核心概念是*迭代*，即一组编程指令会根据指定的次数或直到满足某个条件时反复执行。我们在日常生活中经常无意识地进行迭代。我们迭代一周的每一天来跟踪日程安排。我们迭代未来的账单和薪水单来管理财务。在编程中，我们通过称为*循环*的控制结构来模拟这些迭代过程。
- en: In a while loop, we iterate over a process until a condition is met. For example,
    we might say that while a student hasn’t completed their in-class assignment,
    they don’t get screen time. In this case, we check for the condition (have they
    not completed their in-class assignment) and then perform the action (deny screen
    time). In a do-while *loop*, we perform an action and *then* check for the condition;
    for example, do add one milligram to the balance scale while the object we’re
    measuring is on the lower plate. In this situation, we first perform the action
    and then check for the condition before continuing, because we want to see how
    our action affects the condition.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们会不断地执行某个过程，直到满足某个条件。例如，我们可能会说，在学生完成课堂作业之前，他们不能获得屏幕时间。在这种情况下，我们检查条件（他们是否完成了课堂作业），然后执行相应的操作（拒绝屏幕时间）。在`do-while`*循环*中，我们先执行某个操作，然后*再*检查条件；例如，假设在测量物体时，我们先将一毫克添加到天平上，接着检查物体是否仍在天平的下盘。在这种情况下，我们先执行操作，再检查条件，以便了解我们的操作对条件的影响。
- en: 'The while loop performs an action until a condition is met. But sometimes,
    we need to iterate a specific number of times. In that case, we use a for loop.
    In some programming languages, a for loop takes three arguments, or inputs: a
    starting value, a condition, and an operation to perform on the starting value
    on each iteration. We can use these three arguments to iterate a set number of
    times. The second line of code in Listing 4-4 shows what this looks like in JavaScript.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会不断执行操作，直到满足某个条件。但有时，我们需要执行特定次数的迭代。在这种情况下，我们使用`for`循环。在一些编程语言中，`for`循环需要三个参数或输入：一个起始值、一个条件和在每次迭代中对起始值执行的操作。我们可以使用这三个参数来执行固定次数的迭代。列表4-4中的第二行代码展示了在JavaScript中如何实现这一点。'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-4: A for loop counting to 10'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：一个计数到10的`for`循环
- en: Note the line that reads for (var i=0; i<10; i=i+1). The var i=0 portion sets
    the variable i equal to 0\. The second part, i<10, has the loop execute while
    i is less than 10\. Finally, the i=i+1 part instructs the computer to add one
    to i each iteration so this loop executes 10 times. Between the opening and closing
    curly brackets are the instructions we want to execute. In this case, we’re adding
    one to x each iteration so x will equal 10 when the loop finishes processing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这一行代码：`for (var i=0; i<10; i=i+1)`。`var i=0`部分将变量`i`的值设为0。第二部分`i<10`表示循环在`i`小于10时继续执行。最后，`i=i+1`部分指示计算机在每次迭代时将`i`增加1，因此这个循环会执行10次。大括号之间是我们要执行的指令。在这个例子中，我们在每次迭代时将`x`加1，直到循环执行完毕时，`x`的值为10。
- en: Alternatively, the foreach control will iterate over each element in a list
    or array. As an example, foreach color in ["Red","Orange","Yellow","Green","Blue","Indigo","Violet"],
    append the first letter to a string. This statement will iterate over the sequence
    and output the mnemonic “ROYGBIV.” Listing 4-5 shows executable JavaScript code
    for this operation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，foreach 控制结构将遍历列表或数组中的每个元素。例如，foreach color in ["Red","Orange","Yellow","Green","Blue","Indigo","Violet"]，将第一个字母附加到一个字符串中。这个语句将遍历序列并输出助记符“ROYGBIV”。列表
    4-5 显示了此操作的可执行 JavaScript 代码。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-5: A foreach loop that constructs “ROYGBIV”'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-5: 构建“ROYGBIV”的 foreach 循环'
- en: Loops can lead to interesting errors. Consider a sheet of paper that reads “What’s
    an infinite loop? (Answer on back)” on one side and “What’s an infinite loop?
    (Answer on back)” on the other. A human gets the joke instantly, but a computer
    will flip the sheet of paper over and over indefinitely. In programming, we must
    make sure our loops end at some point. We must make certain our while condition
    will be met and that the list in our foreach doesn’t grow as we iterate over it.
    For example, if we set x equal to 1, and while x doesn’t equal 4, add two to x,
    then x will iterate from one to three to five without ever satisfying the condition—meaning
    it will run forever. If we have a foreach loop that runs foreach egg in our basket,
    and in each iteration we add one egg to the basket, the eggs in our basket will
    grow indefinitely and the loop will never terminate, as in Listing 4-6.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 循环可能会导致有趣的错误。考虑一张纸，一面写着“什么是无限循环？（答案在背面）”，另一面也写着“什么是无限循环？（答案在背面）”。人类立刻就能明白这个笑话，但计算机会不停地翻转这张纸，永远都停不下来。在编程中，我们必须确保我们的循环在某个时刻结束。我们必须确保我们的
    while 条件会被满足，并且在我们遍历 foreach 时，列表不会随着循环的进行而增长。例如，如果我们把 x 设置为 1，并且在 x 不等于 4 时每次加
    2，那么 x 将从 1 迭代到 3、5，而永远不会满足条件——意味着它将永远运行下去。如果我们有一个 foreach 循环，循环遍历我们的篮子里的每个蛋，并且每次迭代都往篮子里加一个蛋，那么篮子里的蛋将无限增长，循环永远不会结束，就像列表
    4-6 所示。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-6: A foreach loop that will never terminate'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-6: 一个永远不会终止的 foreach 循环'
- en: In this code is an array basket that contains a single "egg" string. The for
    loop starts at zero and iterates as long as i is less than basket.length, which
    is a count of the number of values stored in basket. With one string stored, this
    value is 1. Inside the loop, the basket.push() function adds another "egg" string
    variable to the array, making the length 2, 3, 4, and so on, meaning i will always
    be less than basket.length. This code will execute indefinitely or at least until
    the computer runs out of memory locations in which to store all these "egg" strings
    and crashes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，有一个数组篮子，其中包含一个“egg”字符串。for 循环从零开始，只要 i 小于 basket.length（即 basket 中存储的值的数量），循环就会继续。由于只有一个字符串存储，这个值为
    1。在循环内部，basket.push() 函数会向数组中添加另一个“egg”字符串变量，导致数组长度变为 2、3、4，依此类推，这意味着 i 将始终小于
    basket.length。这段代码将无限执行，或者至少会执行到计算机的内存耗尽，无法再存储所有这些“egg”字符串并崩溃为止。
- en: With variables, conditional statements, and loops now under our belt, we can
    start combining these elements into more complex, formal processes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在掌握了变量、条件语句和循环，我们可以开始将这些元素结合成更复杂、更正式的流程。
- en: Algorithms and Functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法和函数
- en: Familiar with the concept of variables, your students can start identifying
    the basic units of information they want to work with. Armed with programming
    controls, students can direct the flows of logic based on those variables. Now
    they’re ready to begin learning how to intentionally combine these concepts into
    computational constructs that will achieve their goals.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了变量的概念后，你的学生可以开始识别他们想要处理的基本信息单元。掌握了编程控制结构后，学生们可以根据这些变量来引导逻辑流程。现在，他们已经准备好开始学习如何有意地将这些概念结合成能够实现他们目标的计算构造。
- en: Algorithms
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'As we noted in Chapter 1, an *algorithm* is a set of rules specifying how to
    solve a problem. The word “algorithm” can be intimidating. It sounds highly technical
    but is actually a simple concept. Like with variables and logical controls, your
    students are already working with algorithms when they follow any kind of instructions.
    For example, following this algorithm will produce the first line of stitches
    needed to crochet a cute Yoda doll: **Rnd 1**: ch2, work 6 sc into first ch—6st'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在第 1 章中提到的，*算法*是一组规定如何解决问题的规则。“算法”一词可能让人感到害怕。它听起来非常技术性，但实际上是一个简单的概念。就像变量和逻辑控制一样，当你的学生遵循任何形式的指令时，他们实际上已经在使用算法。例如，遵循这个算法将产生钩织一个可爱尤达玩偶所需的第一行针法：**Rnd
    1**: ch2，向第一个 ch 中钩入 6 个 sc—6st'
- en: This instruction is cryptic, just like a line from a computer program if you’re
    not familiar with the notation. It instructs the crafter to execute two chain
    stitches and then work six double crochets into it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令就像计算机程序中的一行代码一样，若你不熟悉符号，它是难以理解的。它指示工匠执行两个链针，然后将六个双钩针织入其中。
- en: Following the algorithm in Figure 4-3 will produce the distinctive opening notes
    of Beethoven’s Symphony No. 5.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图4-3中的算法，可以演奏出贝多芬第五交响曲的独特开头音符。
- en: '![](image/CitC04_04_beethovensyphony5.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](image/CitC04_04_beethovensyphony5.png)'
- en: 'Figure 4-3: The opening of Beethoven’s Symphony No. 5'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3：贝多芬第五交响曲的开头
- en: If you know how to read music, you might hear the notes in your head when you
    read this notation. But unless you’re a true virtuoso, you’d have a hard time
    playing these notes on every kind of musical instrument. The algorithms in the
    Yoda crochet instructions and the opening notes of Beethoven's Symphony No. 5
    require certain levels of expertise and knowledge to understand and implement.
    Without understanding crochet notation or being able to read sheet music, you
    couldn’t understand these commands, let alone execute them. Similarly, your students’
    lives are filled with algorithms that require some expertise to execute. The schedules
    they follow, the tests they take, and the rules of conduct they emulate are all
    algorithms for which they should find pride in being able to follow. Hopefully,
    appreciating the many complex algorithms your students are already successfully
    navigating in their daily lives will demystify the challenge of constructing new
    algorithms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你懂得读乐谱，你可能会在脑海中听到这些音符的旋律。但除非你是一个真正的演奏大师，否则在各种乐器上演奏这些音符会很困难。尤达钩织指令中的算法和贝多芬第五交响曲的开头音符需要一定的专业知识和技能才能理解和实施。如果你不了解钩织符号或无法读懂乐谱，你就无法理解这些指令，更不用说执行它们了。同样，你的学生的生活中充满了需要一些专业技能才能执行的算法。他们遵循的时间表、参加的考试、模仿的行为规范，都是他们应当为能够遵循的算法感到自豪的内容。希望通过理解你学生们在日常生活中已经成功应对的那些复杂算法，能够揭开构建新算法的神秘面纱。
- en: Simple algorithms can provide us with powerful solutions. We can solve mazes
    that have all their walls connected to an outer boundary with a simple algorithm
    of following either the right or left wall. If your students can memorize 10 short
    algorithms then with a little practice they can solve a Rubik’s Cube in less than
    five minutes. Students familiar with various sorting algorithms and their relative
    efficiencies will have an easier time organizing index cards, file folders, books,
    and other collections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的算法可以为我们提供强大的解决方案。我们可以通过简单的算法，沿着右墙或左墙走，解决那些所有墙壁都与外部边界连接的迷宫。如果你的学生能记住10个简短的算法，那么通过一些练习，他们可以在不到五分钟的时间内解开魔方。熟悉各种排序算法及其相对效率的学生，将更容易整理索引卡、文件夹、书籍和其他物品。
- en: Algorithms are powerful tools for documenting solutions to complex problems
    so that others may solve them, and in computing they become even more powerful
    when we can automate and abstract them away into functions that are more convenient
    and easier to work with.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是记录复杂问题解决方案的强大工具，使他人能够解决这些问题，在计算机中，当我们能够将算法自动化并抽象成更方便、更易操作的函数时，它们的威力更为强大。
- en: Functions
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: As we learned in the previous chapter, a computer system is filled with computational
    solutions that have been layered on top of one another over decades, like geological
    strata over eons of time. If we had to expose ourselves to all these algorithms
    every time we wanted to write a program, we would be overwhelmed. Even working
    in a single program, if we had to read past the detailed algorithms needed to
    generate random numbers, round decimals, concatenate strings, or sort arrays,
    we would spend all our time sifting through code rather than writing it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，计算机系统充满了经过数十年积累的计算解决方案，就像是时间流逝中的地质层。如果每次想写程序时都必须接触到所有这些算法，我们会感到不堪重负。即使在单一程序中，如果我们需要阅读生成随机数、四舍五入小数、连接字符串或排序数组所需的详细算法，我们将把所有时间都花在浏览代码上，而不是编写它。
- en: For these reasons, in software development we use *functions* to hold algorithms.
    A function *encapsulates* the algorithm. In other words, it conceptually wraps
    up many lines of instructions into a process you can simply invoke by name—like
    clicking an icon that represents a program. For example, the algorithm to generate
    pseudorandom numbers might be 5 to 30 lines of mathematically dense code, but
    in a function, we only need to call random(). Encapsulating the code also makes
    it reusable. We can call random()repeatedly in our code, and if we find a bug
    in the function or a way to enhance it, we need only edit the one function to
    improve it everywhere.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，在软件开发中我们使用*函数*来封装算法。一个函数*封装*了算法。换句话说，它将多行指令概念上打包成一个可以通过名称简单调用的过程——就像点击一个代表程序的图标。例如，生成伪随机数的算法可能需要5到30行数学密集型的代码，但在函数中，我们只需要调用
    random()。封装代码还使得它具有可重用性。我们可以在代码中多次调用 random()，如果我们在函数中发现了一个 bug 或者改进方法，只需编辑这个函数，就能在所有地方都得到改进。
- en: The function also abstracts away the complexity of the algorithm. We don’t need
    to know what’s inside the function. We only need to know what arguments to give
    it and what outputs we should expect. If I can set a start and end range for my
    random number as random(1,20), I can expect to get the same results as a 20-sided
    dice roll without needing to know anything about how that number was produced.
    The function is a black box that takes inputs and gives us outputs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数还抽象了算法的复杂性。我们不需要知道函数内部的实现细节，只需要知道应该给它什么参数以及期望的输出是什么。如果我可以将随机数的起始和结束范围设置为
    random(1,20)，我可以期望得到与20面骰子投掷相同的结果，而不需要知道这个数字是如何产生的。这个函数就像一个黑盒，接受输入并给出输出。
- en: Once your students are comfortable with algorithms and functions, they’re ready
    to take everything we’ve covered in this chapter and blend it together in a complex
    ecosystem of interacting variables, conditional logic, and encapsulated functions,
    also known as games!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦学生们对算法和函数有了足够的理解，他们就可以将本章所学的内容结合起来，形成一个复杂的生态系统，其中包含相互作用的变量、条件逻辑和封装的函数，这也就是我们所说的游戏！
- en: Bringing It All Together with Game-Based Learning
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容与基于游戏的学习结合起来
- en: Many activities in this chapter introduced computational concepts to your students.
    Exercises like the Parts of Speech Games, Gamebooks, the PB&J Algorithm Game,
    and the Guess the Function Game are all meant to be playful ways of engaging complex
    subjects. These are also examples of *game-based learning*, a kind of instruction
    growing in popularity that combines naturally engaging play with serious instruction
    to encourage students to more fully explore the subject matter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多活动都向学生介绍了计算概念。像词性游戏、游戏书、PB&J算法游戏和猜函数游戏等练习，都是以有趣的方式让学生接触复杂的学科。这些也是*基于游戏的学习*的例子，这种教学方式结合了自然吸引人的游戏性和严肃的教学内容，鼓励学生更全面地探索学科内容。
- en: It’s important to note that game-based learning is different from *gamified
    learning*, which uses points, badges, and rewards in the classroom to motivate
    students the same way an addictive video game keeps players clicking buttons for
    little rewards. The former is intended to facilitate deep engagement with a complex
    subject; the latter is associated with Pavlovian conditioning. An example of gamified
    learning would be giving a student a badge for doing well on a timed test. An
    example of game-based learning would be having students play a game about the
    Electoral College where they work as two teams competing to get 538 votes across
    a map of the United States. The former rewards students for exhibiting a desired
    behavior, whereas the latter immerses them in the subject matter for a deeper
    understanding.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，基于游戏的学习与*游戏化学习*不同，后者在课堂上使用积分、徽章和奖励来激励学生，就像上瘾的视频游戏通过小奖励让玩家不停地点击按钮一样。前者旨在促进对复杂主题的深入参与；后者则与巴甫洛夫式条件反射相关。一个游戏化学习的例子是，在限时测试中表现出色的学生可以获得徽章。一个基于游戏的学习的例子是让学生们玩一个关于选举团的游戏，在游戏中他们以两个团队的形式竞争，以在美国地图上获得538票。前者奖励学生展现出期望的行为，而后者则让学生沉浸于学科内容中，以便获得更深入的理解。
- en: Games are valuable learning tools because of the way they engage their players.
    Game designers often refer to the *magic circle*, the state of mind a player enters
    when playing a game where they forget about the outside world and are totally
    immersed in the game’s microworld. In education and in programming, there is a
    related psychological concept of *flow* where the student or programmer forgets
    themselves and completely engages the task at hand. The magic circle is a safe
    space where students can play and experiment within an artificial world without
    consequences. It’s also a space that promotes flow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏是非常有价值的学习工具，因为它们能够有效地吸引玩家。游戏设计师常提到*魔法圈*，指的是玩家在游戏中进入的心理状态，在这个状态下，玩家会忘记外部世界，完全沉浸在游戏的小世界中。在教育和编程中，也有一个相关的心理概念叫做*心流*，在这种状态下，学生或程序员忘记了自己，完全投入到眼前的任务中。魔法圈是一个安全的空间，学生可以在这个人工世界中自由地玩耍和实验而不会有任何后果。它也是一个促进心流的空间。
- en: Games are also especially effective in engaging students in computational thinking
    because games are computational artifacts. Games are filled with variables. They
    have conditional logic in player choices. Each game round is a loop of players
    executing their turns. The rule book is an algorithm where we conceptualize many
    of the rules into functions. Board games are like software but run on human brainpower.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏在吸引学生进行计算思维方面尤其有效，因为游戏本身就是计算工件。游戏充满了变量，玩家的选择中包含条件逻辑。每一轮游戏都是一个玩家执行自己回合的循环。规则书就是一个算法，我们将许多规则概念化成函数。棋盘游戏就像软件，但它们依赖于人类的大脑来运行。
- en: Consider the following example. Figure 4-6 shows a 7 × 9 version of the ancient
    Indian board game *Snakes and Ladders*, also known as *Chutes and Ladders* in
    the West. In this game, players take turns rolling a six-sided die and moving
    that many squares. If they land on a square at the bottom of ladder, they slide
    up to the top of that ladder. If they land on a square with the head of a snake,
    they slide down to the square at the end of the snake’s tail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下示例为例。图 4-6 展示了一个 7 × 9 版本的古印度棋盘游戏*蛇和梯子*，在西方也称为*滑梯和蛇*。在这个游戏中，玩家轮流掷一个六面骰子，并按骰子的点数移动格子。如果他们落在梯子底部的格子上，他们会滑到梯子的顶部。如果他们落在蛇头所在的格子上，他们会滑到蛇尾的末端。
- en: Because the game is simple and we don’t need to factor in player choices, it’s
    very easy to model in programming code. Listing 4-7 shows all the JavaScript code
    needed to emulate a game of *Snakes and Ladders*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个游戏简单，而且我们不需要考虑玩家的选择，因此它在编程代码中非常容易建模。列表 4-7 展示了模拟*蛇和梯子*游戏所需的所有 JavaScript
    代码。
- en: '![](image/CitC04_06_SnakesAndLadders.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](image/CitC04_06_SnakesAndLadders.png)'
- en: 'Figure 4-6: Snakes and Ladders board game'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6：蛇和梯子棋盘游戏
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-7: Snakes and Ladders code'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-7：蛇和梯子代码
- en: This code example illustrates how the logical structure and algorithms of games
    can translate to programming logic. The players and their scores are stored in
    an array data type. The game executes as long as there is no winner. Each player
    takes a turn where a random number is assigned to their current score, which is
    then subjected to conditional logic that checks for snakes and ladders. Finally,
    once a player’s score is equal to or greater than 63, we set the winner variable,
    and the program tells us the winner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例展示了游戏的逻辑结构和算法如何转化为编程逻辑。玩家和他们的得分被存储在一个数组数据类型中。只要没有赢家，游戏就会继续进行。每个玩家轮流出场，随机生成一个数字加到他们当前的得分上，然后进行条件判断，检查是否有蛇或梯子。最后，一旦玩家的得分等于或超过63，我们设置赢家变量，并且程序会告诉我们谁是赢家。
- en: 'The act of translating *Snakes and Ladders* into a formal algorithm reveals
    insights into the game. Seeing the game translated into just 35 lines of code
    illustrates its simplicity. The fact that we didn’t need to code any player input
    emphasizes the lack of player agency: the game outcome is entirely out of the
    players’ hands. In fact, this is by design. *Snakes and Ladders* was invented
    to teach children the concept of karma and accepting one’s fate. In the Western
    world, we use *Chutes and Ladders* as an early childhood exercise in following
    rules and learning basic arithmetic. By writing the game as code, we’re extending
    the game’s use in the classroom to older students and giving them a fresh look
    at a nostalgic activity. The code is an isomorph of the board game, a concept
    touched on in Chapter 2 where the same logic is presented in a different way.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将*蛇梯棋*转化为正式的算法揭示了对这个游戏的深刻见解。看到游戏被翻译成仅35行代码，展现了它的简洁性。我们没有为玩家输入编写代码，这强调了玩家缺乏能动性：游戏结果完全不在玩家的控制之中。事实上，这是设计使然。*蛇梯棋*最初是为了教孩子们因果报应和接受命运的概念而发明的。在西方世界，我们通过*滑梯和梯子*作为幼儿早期学习规则和基础算术的活动。通过将游戏写成代码，我们将其在课堂上的应用扩展到更高年级的学生，并让他们以新的视角重新审视这一怀旧的活动。代码是这款桌游的同构体，这一概念在第二章中有涉及，在那里，相同的逻辑以不同的方式呈现。
- en: Children tend to get bored with *Chutes and Ladders* quickly. They rapidly recognize
    the lack of agency the game provides and how they have no control over the outcome.
    The game becomes a tedious chore where players execute the algorithm again and
    again waiting to see the random outcome. That makes this coding exercise also
    perfect for illustrating the power of automation. Once translated into a syntactically
    correct program, a 10- to 20-minute board game would execute in milliseconds.
    In a sense, automating the game makes it obsolete, but there is also a new opportunity
    here. Students can now review the gameplay algorithm and find ways to make it
    more fun.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子们往往很快就会对*滑梯和梯子*感到厌烦。他们迅速意识到游戏缺乏能动性，并且对游戏结果毫无控制力。游戏变成了一项繁琐的任务，玩家一次又一次地执行相同的算法，只是等待随机结果。这使得这个编码练习也非常适合展示自动化的力量。一旦转换为语法正确的程序，一个10到20分钟的桌游将会在毫秒内执行。从某种意义上说，自动化使得游戏变得过时，但也带来了新的机会。学生们现在可以回顾游戏的算法，寻找让它更有趣的方式。
- en: Refactor Your Gameplay
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构你的游戏玩法
- en: Playing games and analyzing them as computational artifacts helps us understand
    them more deeply. If you can explain the game to our dense, overly literal friend
    the computer, then you know it completely. Once you know it completely, you can
    take ownership of it, enhance it, and make it your own.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并将其作为计算制品进行分析，帮助我们更深入地理解它们。如果你能将游戏解释给我们那位过于字面、迟钝的朋友——计算机，那么你就完全掌握了它。一旦你完全掌握了它，你就能接管它、提升它，并使其成为你自己的。
- en: The same is true of software code. When a programmer encounters new code, they
    must take the time to get familiar with its organization and flow. After taking
    ownership of a codebase, a programmer might take time to *refactor* that code,
    which is the art—not science—of reorganizing the code to potentially make it more
    reusable, efficient, intuitive, or elegant.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 软件代码也是如此。当程序员遇到新代码时，他们必须花时间熟悉其结构和流程。在掌握了代码库之后，程序员可能会花时间*重构*这段代码，这是一种艺术——而非科学——通过重新组织代码使其更具可重用性、高效性、直观性或优雅性。
- en: Board games are great laboratories to experiment with refactoring. *Snakes and
    Ladders* loses its engagement as the players catch on to the fact that the game’s
    outcome is out of their hands. So let’s change that. Instead of having players
    roll a die to move each turn, they each roll 10 dice at the start of the game.
    Then they “program” their token with these values, lining up the dice in a stack
    of moves to most optimally navigate the snakes and ladders. The player who can
    reach the end in the fewest steps is the winner. Thus, with a minor rule change,
    we’ve transformed a game with a purely random output to one with much deeper strategy
    requiring computational thinking.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面游戏是实验重构的良好实验场。*蛇梯棋*失去吸引力，因为玩家意识到游戏的结果完全不在自己控制之中。所以我们来改变这一点。游戏开始时，每个玩家将掷10个骰子，而不是每回合掷一个骰子。然后，他们用这些骰子值“编程”自己的棋子，把骰子按顺序排成一堆最优的移动顺序，以便更好地穿越蛇和梯子。第一个以最少步数到达终点的玩家获胜。通过一个小小的规则变化，我们将一个完全随机输出的游戏转变为一个需要计算思维、包含更深策略的游戏。
- en: When questioning and modifying the rules of existing games, challenge your students
    to identify the variables, logical flows, and algorithms in the rules and game
    mechanics. When isolated and articulated, these elements become parts they can
    use to modify other games or even assemble their own. This is just like computer
    programming. Coders always start out working with artifacts others have created.
    They might include a high-level coding language, software framework, or existing
    application, so the coder must learn about the environment in which they’re developing,
    adapt to it, and make it their own. Once your students are comfortable experimenting
    with the rules of existing games, it’s time to see how they do crafting games
    from scratch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在质疑和修改现有游戏规则时，挑战你的学生识别规则和游戏机制中的变量、逻辑流程和算法。当这些元素被孤立并阐明时，它们就成为学生可以用来修改其他游戏甚至自己设计游戏的组成部分。这就像计算机编程一样。程序员总是从使用别人创建的工具开始。他们可能会使用高级编程语言、软件框架或现有应用程序，因此程序员必须了解他们所开发的环境，适应它，并使其成为自己的。一旦学生们能够自如地尝试修改现有游戏的规则，就可以看看他们如何从零开始制作游戏。
- en: Modeling with Games
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏建模
- en: Many popular board games are effective for the way their mechanics model real-world
    elements. From schooling and professional choices, to mortgages, raising children,
    and retirement, Hasbro’s *Game of Life* models the economic life span of an average
    US citizen. The cooperative game *Pandemic* models global disease outbreaks for
    specialists to mitigate. The board game *Evolution* models how species adapt to
    environmental changes through natural selection. With the proper variables and
    algorithms, games can serve as valuable computational models for students to play
    with.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的桌面游戏之所以有效，是因为它们的机制能够模拟现实世界的元素。从学校教育和职业选择，到抵押贷款、抚养孩子和退休，哈斯布罗公司的*人生游戏*模拟了美国普通公民的经济生命周期。合作游戏*大流行*模拟了全球疾病爆发，供专家减轻影响。桌面游戏*进化*模拟了物种如何通过自然选择适应环境变化。通过适当的变量和算法，游戏可以作为有价值的计算模型供学生们进行探索。
- en: Having students model topics from class in games provides an avenue for project-based
    learning. A student modeling the life of a piece of legislation in a game, where
    each player represents a branch of government, will have a more precise and intimate
    understanding of the process than a student who only reads the algorithm in a
    textbook. A student tracing the energy stored in gasoline back to its ancient
    origin in the sun through a conceptual maze of electrons, photons, and nuclear
    fusions in a game they design will have detailed knowledge beyond their peers
    who solely followed a diagram in a book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让学生通过游戏来建模课堂上的主题，为基于项目的学习提供了一个途径。学生通过游戏建模一项立法的生命周期，其中每个玩家代表政府的一个分支，比仅仅阅读教科书中的算法的学生会更精确、更加深入地理解这个过程。学生通过他们设计的游戏追溯汽油中储存的能量，追溯到太阳中的古老起源，穿过电子、光子和核聚变的概念迷宫，他们将比仅仅跟随书中图表的同龄人拥有更为详细的知识。
- en: Likewise, modeling aspects of the real world in a game, and highlighting the
    ways in which that modeling is computational thinking, will give students a strong
    grasp of computer science concepts. Seeing the board and playing pieces as tracking
    variables, the rules as the software algorithm, and the players as testing the
    execution of that algorithm as they process it in play will all solidify these
    concepts in the student’s head. The skills learned in modeling for games are directly
    transferable to computational tasks in computer science and will prepare students
    for working with the rules in computers and software development environments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在游戏中模拟现实世界的各个方面，并突出这种模拟是如何体现计算思维的，将帮助学生牢牢掌握计算机科学的概念。将棋盘和棋子视为跟踪变量，将规则视为软件算法，将玩家视为在游戏中执行并处理该算法的测试者，这些都能帮助学生在脑海中巩固这些概念。游戏中的建模技能可以直接转移到计算机科学中的计算任务，并为学生在计算机和软件开发环境中使用规则做好准备。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the basic logical elements that make up an
    algorithm. We covered the variables our algorithms process and their inputs and
    outputs. We covered the control structures that direct the flow of our algorithms,
    and we covered the functions that encapsulate complex algorithms and make them
    easier to work with.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了构成算法的基本逻辑元素。我们讨论了算法处理的变量及其输入输出。我们讨论了指导算法流程的控制结构，以及封装复杂算法并使其易于操作的函数。
- en: Throughout this chapter, we explored sample exercises to engage in with each
    of these concepts. None of these exercises required us to get anywhere near a
    computer, and many focused on how we’re already using these concepts in our daily
    lives. Because we’re already using the elements of computational thinking in our
    routines, we only need to draw attention to these elements to make our students
    aware.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了一些示例练习，帮助学生理解这些概念。这些练习都不需要我们接触电脑，而且许多练习关注我们在日常生活中如何已经在使用这些概念。因为我们在日常生活中已经在使用计算思维的元素，所以我们只需要强调这些元素，让学生们意识到它们的存在。
- en: In board games, we explored a medium that brings together variables, controls,
    algorithms, and modeling into an experience where students can feel safe to experiment
    with topics in class while also engaging with them more formally. As students
    refactor the existing rules of games, they make these games their own—just as
    a computer programmer uses existing code and modifies it to meet their requirements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在棋盘游戏中，我们探索了一种将变量、控制、算法和建模结合在一起的媒介，让学生们能够在课堂上安全地实验相关主题，同时也能更正式地参与其中。当学生们重构游戏的现有规则时，他们使这些游戏成为自己的——就像计算机程序员使用现有代码并对其进行修改以满足需求一样。
- en: In the next chapter, we’ll learn about a tool any student with a web browser
    can use to start instantly exploring and experimenting with existing code. As
    with board games, they’ll learn about web applications by editing the logic of
    existing applications in a safe and experimental environment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习一个任何拥有网页浏览器的学生都可以使用的工具，帮助他们立即开始探索和实验现有的代码。与棋盘游戏类似，学生们将通过在安全且具有实验性的环境中编辑现有应用程序的逻辑，来学习网页应用程序。
