<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 40: The Run Up to 1.0</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c2f206e1-36e8-4f89-b533-508263d6ec16" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_319" title="319"/>40</span><br/>
<span class="ChapterTitle">The Run Up to 1.0</span></h1>
</header>
<figure class="graphic">
<img alt="g40001" src="image_fi/502680c40/g40001.png"/></figure>

<p class="ChapterIntro"><span class="dropCap">N</span>early a year passed between the initial launch of the SDK in November of 2007 and the release of 1.0, which was launched with the G1 phone nearly a year later. So what was happening during that whole time?</p>
<p>First of all, it wasn’t actually as long as you’d think.</p>
<p>Some software products can ship quickly, depending on the situation. If you are simply updating some code on a web page, you can release it immediately. And if there’s a bug in that release, you can ship again as soon as you’ve fixed it. But if you are shipping a product that is not as easy to distribute to your users as simply updating a website, you’ll want to do some amount of testing and stabilization before releasing it. You don’t want to make your users go through some arduous update just to discover a horrible bug and make them update again. Now you’re looking at some number of weeks<sup class="FootnoteReference"><a href="#c40-footnote-1" id="c40-footnoteref-1">1</a></sup> at least. Shipping hardware, like the G1, in addition to the software it depends on, involves even more time.</p>
<p>The Android SDK was just software, and the team could have kept updating it with bug fixes (as they did continuously during the beta period prior to 1.0) until they declared it “done.” But that release needed to work well on the G1, which involved different constraints entirely. Phones go through <span epub:type="pagebreak" id="Page_320" title="320"/>rigorous compliance testing by carriers, which meant that the team needed to be done far sooner than they would have for just another release of the SDK. Romain talked about it: “Pencils down was a month before the launch in stores. But before that was like three months of carrier testing.” So for G1 availability in mid-October, the team had to be effectively finished with platform development (apart from fixing critical bugs that came up during this final testing period) in June of 2008—only seven months after the initial SDK launch.</p>
<p>Many things needed to be fixed during those seven months, including smoothing out the rough edges of the public API, critical performance work, and bugs, bugs, bugs.</p>
<h2 id="h1-502680c40-0001">The Cost of Compatibility</h2>
<p class="BodyFirst">The public APIs needed to be polished before the release. The SDK was beta; developers were encouraged to write apps for it, but the APIs (method names, classes, and so on) were not final. Once 1.0 was launched, however, that was it; those APIs were set in stone and couldn’t change. Changing APIs between releases meant that applications using those APIs would mysteriously crash on user devices. </p>
<p>This compatibility dynamic is especially true on a platform like Android, where there is no way to force developers to update their apps, or to get users to install those updates. Suppose a developer wrote and uploaded an app to the Play Store 10 years ago. Somewhere, someone is using that application happily. Then that user upgrades their phone to a newer release. If that newer release changes any of the APIs that that old application uses, it might not work correctly, or it might even crash, which is obviously not something that Google wants. So the old APIs stick around and are supported for way . . . too . . . long.</p>
<p>The trick, then, for developers on the Android team, is to be very sure about any new API, because the team will have to live with it forever. Of course, there will always be mistakes or things you would have done differently in hindsight.<sup class="FootnoteReference"><a href="#c40-footnote-2" id="c40-footnoteref-2">2</a></sup> <span epub:type="pagebreak" id="Page_321" title="321"/>Ficus Kirkpatrick observed, “You can try to design something perfect. Then while you’re busy polishing it in the lab, somebody’s going to come out with something and make you irrelevant.”</p>
<p>The team worked to make the APIs something that they were happy with and willing to live with for, basically, ever. Some of the pre-1.0 changes, like method or class names, were minor. But some APIs were completely removed, because they just weren’t something that the platform wanted to support for all eternity.</p>
<p>Romain Guy said, “A lot of the time during 2008 I spent cleaning up the APIs and removing as much as possible from the framework before we shipped.” For example, he removed PageTurner, a class that implemented a cool paper-tearing effect. It was originally written for an earlier version of the Calculator application to show a fun animation when clearing the display. But the design of Calculator had changed, and it no longer used that animation. It was such a specific kind of effect that it was too niche to live in the public API, so that class was deleted.</p>
<figure>
<img alt="" class="" src="image_fi/502680c40/f40001.png"/>
<figcaption><p>The paper-tearing effect for the calculator app was cool, but not generally useful. It was removed from the platform APIs before 1.0.</p></figcaption>
</figure>
<p>Jeff Sharkey, who was an external developer at that time, commented on the API churn during this phase of the project: “Portions of the Android SDK were pretty turbulent through the various preview releases before the 1.0 release<span epub:type="pagebreak" id="Page_322" title="322"/>. UI components were being added, removed, and reskinned<sup class="FootnoteReference"><a href="#c40-footnote-3" id="c40-footnoteref-3">3</a></sup> at every snapshot. Entire features were gutted.”</p>
<p>This is not to say that bad APIs didn’t sneak their way in and stick around past 1.0 (see the earlier footnote comment about “building future regret”). One example is ZoomButton, a utility class for interpreting a long-press as multiple click events, sent to another piece of logic that handled zooming. ZoomButton didn’t actually do any zooming itself. In fact, it didn’t really do anything except reinterpret one type of input (long-press) as another (multiple clicks). But unfortunately, it stuck around past 1.0 and only got deprecated<sup class="FootnoteReference"><a href="#c40-footnote-4" id="c40-footnoteref-4">4</a></sup> years later, in the Oreo release.</p>
<h2 id="h1-502680c40-0002">Performance</h2>
<p class="BodyFirst">Another critical area of work during this phase was performance. Even though hardware at that time had come a long way since earlier mobile device generations, making it possible for smartphones to exist, the CPUs were still incredibly limited. Also, everything that happens on a phone uses battery and shortens the time until the user needs to recharge their device. So it was important for the platform and application engineers to do everything possible to make things run faster, smoother, and more efficiently. For example, Romain Guy, along with others on the UI toolkit team, spent much of this time optimizing animations and drawing logic to avoid doing unnecessary work.</p>
<h2 id="h1-502680c40-0003">Bugs, Bugs, Bugs</h2>
<p class="BodyFirst">The hardware for the G1 was finally starting to become available for wider internal use around the time of the SDK launch, so the team could finally <span epub:type="pagebreak" id="Page_323" title="323"/>start testing their code on real hardware. Once the devices were available in quantity, everyone could also dogfood the G1 as their daily phone, which generated many bugs that needed to be fixed before 1.0.</p>
<p>Romain said, “What happened during that time? Tons of debugging.”</p>
<h2 id="h1-502680c40-0004">Easter Eggs</h2>
<p class="BodyFirst">One of the things that didn’t make it into 1.0 was an Easter egg<sup class="FootnoteReference"><a href="#c40-footnote-5" id="c40-footnoteref-5">5</a></sup> listing the names of everyone who worked on the release, reminiscent of the classic Macintosh team signatures that decorated the inside of that computer case. Romain Guy implemented the feature, but it never shipped.</p>
<p>“You can register an intent for what’s called a ‘secret code’ in the Dialer. When you dial like *#*#, a number, *#*#, it’s basically a system command. Sometimes your ISP might ask you to type something like that to ask you to do something. </p>
<p>“Launcher registered one of those codes. If you entered it, launcher would be woken up and would find, in one of its icons I had hidden in the metadata, the list of the people on the team who had worked on Android 1.0. It would bring up a UI to just scroll the list of names. The code to do that was written inside a comment, in the Java sources. So the code was kind of hidden. </p>
<p>“We turned it into a feature. We started gathering even more people, including contractors. We added more and more. It was canned because someone was afraid that we would have forgotten about someone.</p>
<p>“So it was a cool little Easter egg that got productized to death.”</p>
<p>Recent releases of Android have Easter eggs, most of them implemented by Dan Sandler on the system UI team. This Android tradition started several releases after 1.0, maybe when the team had time to breathe and think about something non-critical. Or maybe just when someone with Dan’s level of art skills, humor, and coding speed could make it happen. Long-pressing on the build information in the system settings will bring up . . . something. Sometimes it’s just a pretty visual, sometimes it’s a simple game or application. But it’s never a list of people working on the product because that would be too complicated.</p>
<h2 id="h1-502680c40-0005"><span epub:type="pagebreak" id="Page_324" title="324"/>Apps</h2>
<p class="BodyFirst">The team also spent some time in the run up to 1.0, especially toward the end when only critical bug fixes were allowed, writing applications. Mike Cleron said, “That’s where most of my app-writing career happened. Kicking the tires on the framework.”</p>
<p>Mike and Romain, both passionate landscape photographers, worked on photography applications. Writing real-world apps not only provides more functionality for users, it also helps platform developers understand the platform from an app developer’s point of view, which feeds into better APIs and functionality in future versions. And, of course, it also helps find bugs that can then be fixed.</p>
</section>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c40-footnoteref-1" id="c40-footnote-1">1.</a></sup>  Or longer, depending on the size of the product and the context in which the software is used. Software for a nuclear power plant, for example, should probably undergo more thorough testing than, say, a dating app.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c40-footnoteref-2" id="c40-footnote-2">2.</a></sup>  Developing APIs is the process of building future regret. Even if it looks good now, you would probably do it differently in a few years given changing requirements and future developments. But you do the best you can and move on, because shipping anything is better than not shipping perfection.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c40-footnoteref-3" id="c40-footnote-3">3.</a></sup>  Reskinning refers to changing the look of the UI in more of a visual than functional way. For example, the buttons and the other UI elements might get a new color or look, but still be the same size and do the same thing. It’s the device equivalent of giving the house a fresh coat of paint; there might be broken doors, leaky faucets, and a trashed kitchen on the inside, but it looks new and fresh on the outside.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c40-footnoteref-4" id="c40-footnote-4">4.</a></sup>  Deprecation is as close as Android comes to removing APIs. It’s a means of marking an API as “you shouldn’t use this” without actually removing it. Developers that use it will see warnings in their code when they build their applications, but applications that use it despite those warnings will continue to work.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c40-footnoteref-5" id="c40-footnote-5">5.</a></sup>  Easter eggs are hidden features in applications that are placed there for the joy of the users who discover them and the delight of the developers who hid them.</p></aside>
</section>
</body>
</html>