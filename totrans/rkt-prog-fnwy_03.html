<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_40"/><span epub:type="pagebreak" id="page_41"/><span class="big">3</span><br/>FUNCTION FUNDAMENTALS</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">In the last chapter, we introduced you to Racket’s basic numerical operations. In this chapter, we’ll explore the core ideas that form the subject of functional programming.</p>&#13;
<h3 class="h3" id="ch00lev1sec_18">What Is a Function?</h3>&#13;
<p class="noindent">A <em>function</em> can be thought of as a box with the following characteristics: if you push an object in one side, an object (possibly the same, or not) comes out the other side; and for any given input item, the same output item comes out. This last characteristic means that if you put a triangle in one side and a star comes out the other, the next time you put a triangle in, you will also get a star out (see <a href="ch03.xhtml#ch3fig1">Figure 3-1</a>). Unfortunately, Racket doesn’t have any built-in functions that take geometric shapes as input, so we’ll need to settle for more-mundane objects like numbers or strings.</p>&#13;
<div class="image"><img alt="Image" src="../images/03fig01.jpg"/></div>&#13;
<p class="figcap" id="ch3fig1"><em>Figure 3-1: How a function works</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_17"><span epub:type="pagebreak" id="page_42"/><strong><em>Lambda Functions</em></strong></h4>&#13;
<p class="noindent">In its most basic form, a function in Racket is something produced by a <em>lambda expression</em>, designated by the Greek letter <em>λ</em>. This comes from a mathematical discipline called lambda calculus, an arcane world we won’t explore here. Instead, we’ll focus on practical applications of lambda expressions. Lambda functions are intended for short simple functions that are immediately applied, and hence, don’t need a name (they’re anonymous). For example, Racket has a built-in function called <code>add1</code> that simply adds 1 to its argument. A Racket lambda expression that does the same thing looks like this:</p>&#13;
<pre>(lambda (x) (+ 1 x))</pre>&#13;
<p class="indent">Racket lets you abbreviate <code>lambda</code> with the Greek symbol <em>λ</em>, and we’ll frequently designate it this way. You can enter <em>λ</em> in DrRacket by selecting it from the Insert menu or using the keyboard shortcut CTRL-\. We could rewrite the code above to look like this:</p>&#13;
<pre>(λ (x) (+ 1 x))</pre>&#13;
<p class="indent">To see a lambda expression in action, enter the following in the interactions pane:</p>&#13;
<pre>&gt; <span class="codestrong1">((λ (x y) (+ (* 2 x) y)) 4 5)</span>&#13;
13</pre>&#13;
<p class="indent">Notice that instead of a function name as the first element of the list, we have the actual function. Here 4 and 5 get passed to the lambda function for evaluation.</p>&#13;
<p class="indent">An equivalent way of performing the above computation is with a <code>let</code> form.</p>&#13;
<pre>&gt; <span class="codestrong1">(let ([x 4]&#13;
        [y 5])&#13;
    (+ (* 2 x) y))</span>&#13;
13</pre>&#13;
<p class="indent">This form makes the assignment to variables <code>x</code> and <code>y</code> more obvious.</p>&#13;
<p class="indent">We can use lambda expressions in a more conventional way by assigning them to an identifier (a named function).</p>&#13;
<pre>&gt; <span class="codestrong1">(define foo (λ (x y) (+ (* 2 x) y)))</span>&#13;
&gt; <span class="codestrong1">(foo 4 5)</span>&#13;
13</pre>&#13;
<p class="indent">Racket also allows you to define functions using this shortcut:</p>&#13;
<pre>&gt; <span class="codestrong1">(define (foo x y) (+ (* 2 x) y))</span>&#13;
&gt; <span class="codestrong1">(foo 4 5)</span>&#13;
13</pre>&#13;
<p class="indent">These two forms of function definition are entirely equivalent.</p>&#13;
<h4 class="h4" id="ch00lev2sec_18"><span epub:type="pagebreak" id="page_43"/><strong><em>Higher-Order Functions</em></strong></h4>&#13;
<p class="noindent">Racket is a functional programming language. <em>Functional programming</em> is a programming paradigm that emphasizes a declarative style of programming without side effects. A <em>side effect</em> is something that changes the state of the programming environment, like assigning a value to a global variable.</p>&#13;
<p class="indent">Lambda values are especially powerful because they can be passed as values to other functions. Functions that take other functions as values (or return a function as a value) are known as <em>higher-order functions</em>. In this section, we’ll explore some of the most commonly used higher-order functions.</p>&#13;
<h5 class="h5" id="ch00lev3sec_31"><strong>The map Function</strong></h5>&#13;
<p class="noindent">One of the most straightforward higher-order functions is the <code>map</code> function, which takes a function as its first argument and a list as its second argument, and then applies the function to each element of the list. Here’s an example of the <code>map</code> function:</p>&#13;
<pre>&gt; <span class="codestrong1">(map (λ (x) (+ 1 x)) '(1 2 3))</span>&#13;
'(2 3 4)</pre>&#13;
<p class="indent">You can also pass a named function into <code>map</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(define my-add1 (λ (x) (+ 1 x)))</span>&#13;
&gt; <span class="codestrong1">(map my-add1 '(1 2 3)) ; this works too</span>&#13;
'(2 3 4)</pre>&#13;
<p class="indent">In the first example above, we take our increment function and pass it into <code>map</code> as a value. The <code>map</code> function then applies it to each element in the list ’<code>(1 2 3)</code>.</p>&#13;
<p class="indent">It turns out that <code>map</code> is quite versatile. It can take as many lists as the function will accept as arguments. The effect is sort of like a zipper, where the list arguments are fed to the function in parallel, and the resulting values is a single list, formed by applying the function to the elements from each list. The example below shows <code>map</code> being used to add the corresponding elements of two equally sized lists together:</p>&#13;
<pre>&gt; <span class="codestrong1">(map + '(1 2 3) '(2 3 4))</span>&#13;
'(3 5 7)</pre>&#13;
<p class="indent">As you can see, the two lists were combined by adding the corresponding elements together.</p>&#13;
<h5 class="h5" id="ch00lev3sec_32"><strong>The apply Function</strong></h5>&#13;
<p class="noindent">The <code>map</code> function lets you apply a function to each item in a list individually. But sometimes, we want to apply all the elements of a list as arguments in a single function call. For example, Racket arithmetical operators can take multiple numeric arguments:</p>&#13;
<pre>&gt; <span class="codestrong1">(+ 1 2 3 4)</span>&#13;
10</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_44"/>But if we try to pass in a list as an argument, we’ll get an error:</p>&#13;
<pre>&gt; <span class="codestrong1">(+ '(1 2 3 4))</span>&#13;
. . +: contract violation&#13;
  expected: number?&#13;
  given: '(1 2 3 4)</pre>&#13;
<p class="indent">The <code>+</code> operator is only expecting numeric arguments. But not to worry. There’s a simple solution: the <code>apply</code> function:</p>&#13;
<pre>&gt; <span class="codestrong1">(apply + '(1 2 3 4))</span>&#13;
10</pre>&#13;
<p class="indent">The <code>apply</code> function takes a function and a list as its arguments. It then <em>applies</em> the function to values in the list as if they were arguments to the function.</p>&#13;
<h5 class="h5" id="ch00lev3sec_33"><strong>The foldr and foldl Functions</strong></h5>&#13;
<p class="noindent">Yet another way to add the elements of a list together is with the <code>foldr</code> function. The <code>foldr</code> function takes a function, an initial argument, and a list:</p>&#13;
<pre>&gt; <span class="codestrong1">(foldr + 0 '(1 2 3 4))</span>&#13;
10</pre>&#13;
<p class="indent">Even though <code>foldr</code> produced the same result as <code>apply</code> here, behind the scenes it worked very differently. This is how <code>foldr</code> added the list together: 1 + (2 + (3 + (4 + 0))). The function “folds” the list together by performing its operation in a right-associative fashion (hence the <code>r</code> in <code>foldr</code>).</p>&#13;
<p class="indent">Closely associated with <code>foldr</code> is <code>foldl</code>. The action of <code>foldl</code> is slightly different from what you might expect. Observe the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(foldl cons '() '(1 2 3 4))</span>&#13;
'(4 3 2 1)&#13;
&#13;
&gt; <span class="codestrong1">(foldr cons '() '(1 2 3 4))</span>&#13;
'(1 2 3 4)</pre>&#13;
<p class="indent">One might have expected <code>foldl</code> to produce ’<code>(1 2 3 4)</code>, but actually <code>foldl</code> performs the computation <code>(cons 4 (cons 3 (cons 2 (cons 1</code> ’<code>()))))</code>. The list arguments are processed from left to right, but the two arguments fed to <code>cons</code> are reversed—for example, we have <code>(cons 1</code> ’<code>())</code> and not <code>(cons</code> ’<code>() 1)</code>.</p>&#13;
<h5 class="h5" id="ch00lev3sec_34"><strong>The compose Function</strong></h5>&#13;
<p class="noindent">Functions can be combined together, or <em>composed</em>, by passing the output of one function to the input of another. In math, if we have <em>f</em> (<em>x</em>) and <em>g</em>(<em>x</em>), they can be composed to make <em>h</em>(<em>x</em>) = <em>f</em> (<em>g</em>(<em>x</em>)) (in mathematics text this is sometimes designated with a special composition operator as <em>h</em>(<em>x</em>) = (<em>f</em> ∘ <em>g</em>)(<em>x</em>). We can do this in Racket using the <code>compose</code> function, which takes two or more functions and returns a new composed function. This new function works a bit like a pipeline. For example, if we want to increment a number by 1 and <span epub:type="pagebreak" id="page_45"/>square the result (that is, for any <em>n</em> compute (<em>n</em> + 1)<sup>2</sup>), we could use following function:</p>&#13;
<pre>(define (n+1_squared n) (sqr (add1 n)))</pre>&#13;
<p class="indent">But <code>compose</code> allows this to be expressed a bit more succinctly:</p><pre>&gt; <span class="codestrong1">(define n+1_squared (compose sqr add1))</span>&#13;
&gt; <span class="codestrong1">(n+1_squared 4)</span>&#13;
25</pre>&#13;
<p class="indent">Even simpler . . .</p>&#13;
<pre>&gt; <span class="codestrong1">((compose sqr add1) 4)</span>&#13;
25</pre>&#13;
<p class="indent">Please note that <code>add1</code> is performed first and then <code>sqr</code>. Functions are composed from right to left—that is, the rightmost function is applied first.</p>&#13;
<h5 class="h5" id="ch00lev3sec_35"><strong>The filter Function</strong></h5>&#13;
<p class="noindent">Our final example is <code>filter</code>. This function takes a predicate (a function that returns a Boolean value) and a list. The returned value is a list such that only elements of the original list that satisfy the predicate are included. Here’s how we’d use <code>filter</code> to return the even elements of a list:</p>&#13;
<pre>&gt; <span class="codestrong1">(filter even? '(1 2 3 4 5 6))</span>&#13;
'(2 4 6)</pre>&#13;
<p class="indent">The <code>filter</code> function allows you to filter out items in the original list that won’t be needed.</p>&#13;
<p class="indent">As you’ve seen throughout this section, our description of a function as a box is apt since it is in reality a value that can be passed to other functions just like a number, a string, or a list.</p>&#13;
<h4 class="h4" id="ch00lev2sec_19"><strong><em>Lexical Scoping</em></strong></h4>&#13;
<p class="noindent">Racket is a lexically scoped language. The Racket Documentation provides the following definition for <em>lexical scoping</em>:</p>&#13;
<div class="bq5">&#13;
<p class="noindent">Racket is a lexically scoped language, which means that whenever an identifier is used as an expression, something in the textual environment of the expression determines the identifier’s binding.</p></div>&#13;
<p class="noindent">What’s important about this definition is the term <em>textual environment</em>. A textual environment is one of two things: the <em>global environment</em>, or forms where identifiers are bound. As we’ve already seen, identifiers are bound in the global environment (sometimes referred to as the top level) with <code>define</code>. For example</p>&#13;
<pre>&gt; <span class="codestrong1">(define ten 10)</span>&#13;
&gt; ten&#13;
10</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_46"/>The values of identifiers bound in the global environment are available everywhere. For this reason, they should be used sparingly. Global definitions should normally be reserved for function definitions and constant values. This, however, is not an edict, as there are other legitimate uses for global variables.</p>&#13;
<p class="indent">Identifiers bound within a form will <em>normally</em> not be defined outside of the form environment (but see <a href="ch03.xhtml#ch00lev1sec_21">“Time for Some Closure” on page 58</a> for an intriguing exception to this rule).</p>&#13;
<p class="indent">Let’s look at a few examples.</p>&#13;
<p class="indent">Previously we explored the lambda expression <code>((</code>λ <code>(x y) (+ (* 2 x) y)) 4 5)</code>. Within this expression, the identifiers <code>x</code> and <code>y</code> are bound to 4 and 5. Once the lambda expression has returned a value, the identifiers are no longer defined.</p>&#13;
<p class="indent">Here again is the equivalent <code>let</code> expression.</p>&#13;
<pre>(let ([x 4]&#13;
      [y 5])&#13;
  (+ (* 2 x) y))</pre>&#13;
<p class="indent">You might imagine that the following would work as well:</p>&#13;
<pre>(let ([x 4]&#13;
      [y 5]&#13;
      [z (* 2 x)])&#13;
  (+ z y))</pre>&#13;
<p class="indent">But this fails to work. From a syntactic standpoint there’s no way to convert this back to an equivalent lambda expression. And although the identifier <code>x</code> is bound in the list of binding expressions, the value of <code>x</code> is only available inside the body of the <code>let</code> expression.</p>&#13;
<p class="indent">There is, however, an alternative definition of <code>let</code> called <code>let*</code>. In this case the following would work.</p>&#13;
<pre>&gt; <span class="codestrong1">(let* ([x 4]&#13;
         [y 5]&#13;
         [z (* 2 x)])&#13;
    (+ z y))</span>&#13;
13</pre>&#13;
<p class="indent">The difference is that with <code>let*</code> the value of an identifier is available immediately after it’s bound, whereas with <code>let</code> the identifier values are only available after <em>all</em> the identifiers are bound.</p>&#13;
<p class="indent">Here’s another slight variation where <code>let</code> <em>does</em> work.</p>&#13;
<pre>&gt; <span class="codestrong1">(let ([x 4]&#13;
        [y 5])&#13;
    (let ([z (* 2 x)])&#13;
      (+ z y)))</span>&#13;
13</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>In this case the second <code>let</code> is within the lexical environment of the first <code>let</code> (but as we’ve seen, <code>let*</code> more efficiently encodes this type of nested construct). Hence <code>x</code> is available for use in the expression <code>(* 2 x)</code>.</p>&#13;
<h3 class="h3" id="ch00lev1sec_19">Conditional Expressions: It’s All About Choices</h3>&#13;
<p class="noindent">The ability of a computer to alter its execution path based on an input is an essential component of its architecture. Without this a computer cannot compute. In most programming languages this capability takes the form of something called a <em>conditional expression</em>, and in Racket it’s expressed (in its most general form) as a <code>cond</code> expression.</p>&#13;
<p class="indent">Suppose you’re given the task to write a function that returns a value that indicates whether a number is divisible by 3 only, divisible by 5 only, or divisible by both. One way to accomplish this is with the following code.</p>&#13;
<pre>(define (div-3-5 n)&#13;
  (let ([div3 (= 0 (remainder n 3))]&#13;
        [div5 (= 0 (remainder n 5))])&#13;
    (cond [(and div3 div5) 'div-by-both]&#13;
          [div3 'div-by-3]&#13;
          [div5 'div-by-5]&#13;
          [else 'div-by-neither])))</pre>&#13;
<p class="indent">The <code>cond</code> form contains a list of expressions. For each of these expressions, the first element contains some type of test, which if it evaluates to true, evaluates the second element and returns its value. Note that in this example the test for divisibility by 3 and 5 must come first. Here are trial runs:</p>&#13;
<pre>&gt; <span class="codestrong1">(div-3-5 10)</span>&#13;
'div-by-5&#13;
&#13;
&gt; <span class="codestrong1">(div-3-5 6)</span>&#13;
'div-by-3&#13;
&#13;
&gt; <span class="codestrong1">(div-3-5 15)</span>&#13;
'div-by-both&#13;
&#13;
&gt; <span class="codestrong1">(div-3-5 11)</span>&#13;
'div-by-neither</pre>&#13;
<p class="indent">A simplified version of <code>cond</code> is the <code>if</code> form. This form consists of a single test (the first subexpression) that returns its second argument (after it’s evaluated) if the test evaluates to true; otherwise it evaluates and returns the third argument. This example simply tests whether a number is even or odd.</p>&#13;
<pre>(define (parity n)&#13;
  (if (= 0 (remainder n 2)) 'even 'odd))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_48"/>If we run some tests:</p>&#13;
<pre>&gt; <span class="codestrong1">(parity 5)</span>&#13;
'odd&#13;
&gt; <span class="codestrong1">(parity 4)</span>&#13;
'even</pre>&#13;
<p class="indent">Both <code>cond</code> and <code>if</code> are expressions that return values. There are occasions where one simply wants to conditionally execute some sequence of steps if a condition is true or false. This usually involves cases where some side effect like printing a value is desired and returning a result is not required. For this purpose, Racket provides <code>when</code> and <code>unless</code>. If the conditional expression evaluates to true, <code>when</code> evaluates all the expressions in its body; otherwise it does nothing.</p>&#13;
<pre>&gt; <span class="codestrong1">(when (&gt; 5 4)&#13;
    (displayln 'a)&#13;
    (displayln 'b))</span>&#13;
a&#13;
b&#13;
&#13;
&gt; <span class="codestrong1">(when (&lt; 5 4) ; doesn't generate output&#13;
    (displayln 'a)&#13;
    (displayln 'b))</span></pre>&#13;
<p class="indent">The <code>unless</code> form behaves in exactly the same way as <code>when</code>; the difference is that <code>unless</code> evaluates its body if the conditional expression is not true.</p>&#13;
<pre>&gt; <span class="codestrong1">(unless (&gt; 5 4) ; doesn't generate output&#13;
    (displayln 'a)&#13;
    (displayln 'b))</span>&#13;
    &#13;
&gt; <span class="codestrong1">(unless (&lt; 5 4)&#13;
    (displayln 'a)&#13;
    (displayln 'b))</span>&#13;
a&#13;
b</pre>&#13;
<h3 class="h3" id="ch00lev1sec_20">I’m Feeling a Bit Loopy!</h3>&#13;
<p class="noindent">Loops (or iteration) are the bread and butter of any programming language. With the discussion of loops, invariably the topic of <em>mutability</em> comes up. Mutability of course implies change. Examples of mutability are assigning values to variables (or worse, changing a value embedded in a data structure such as a vector). A function is said to be <em>pure</em> if no mutations (or side effects, like printing out a value or writing to a file—also forms of mutation) occur within the body of a function. Mutations are generally to be avoided if possible. Some languages, such as Haskell, go out of their way to avoid <span epub:type="pagebreak" id="page_49"/>this type of mischief. A Haskell programmer would rather walk barefoot through a bed of glowing, hot coals than write an impure function.</p>&#13;
<p class="indent">There are many good reasons to prefer pure functions, such as something called referential transparency (this mouthful simply means the ability to reason about the behavior of your program). We won’t be quite so persnickety and will make judicious use of mutation and impure functions where necessary.</p>&#13;
<p class="indent">Suppose you’re given the task of defining a function to add the first <em>n</em> positive integers. If you’re familiar with a language like Python (an excellent language in its own right), you might implement it as follows.</p>&#13;
<pre>def sum(n):&#13;
    s = 0&#13;
    while n &gt; 0:&#13;
     <span class="ent">➊</span> s = s + n&#13;
     <span class="ent">➋</span> n = n - 1&#13;
    return s</pre>&#13;
<p class="indent">This is a perfectly good function (and a fairly benign example of using mutable variables) to generate the desired sum, but notice both the variables <code>s</code> and <code>n</code> are modified <span class="ent">➊</span> <span class="ent">➋</span>. While there’s nothing inherently wrong with this, these assignments make the implementation of the function <code>sum</code> impure.</p>&#13;
<h4 class="h4" id="ch00lev2sec_20"><strong><em>Purity</em></strong></h4>&#13;
<p class="noindent">Before we get down and dirty, let’s begin by seeing how we can implement looping using only pure functions. <em>Recursion</em> is the custom when it comes to looping or iteration in Racket (and all functional programming languages). A recursive function is just a function defined in terms of itself. Here’s a pure (and simple) recursive program to return the sum of the first <em>n</em> positive integers.</p>&#13;
<pre> (define (sum n)&#13;
<span class="ent">➊</span> (if (= 0 n) 0&#13;
    <span class="ent">➋</span> (+ n (sum (- n 1)))))</pre>&#13;
<p class="indent">As you can see, we first test whether <code>n</code> has reached 0 <span class="ent">➊</span>, and if so we simply return the value 0. Otherwise, we take the current value of <code>n</code> and <em>recursively</em> add to it the <code>sum</code> of all the numbers less than <code>n</code> <span class="ent">➋</span>. For the mathematically inclined, this is somewhat reminiscent of how a proof by mathematical induction works where we have a base case <span class="ent">➊</span> and the inductive part of the proof <span class="ent">➋</span>.</p>&#13;
<p class="indent">Let’s test it out.</p>&#13;
<pre>&gt; <span class="codestrong1">(sum 100)</span>&#13;
5050</pre>&#13;
<p class="indent">There’s a potential problem with the example we have just seen. The problem is that every time a recursive call is made, Racket must keep track of <span epub:type="pagebreak" id="page_50"/>where it is in the code so that it can return to the proper place. Let’s take a deeper look at this function.</p>&#13;
<pre>(define (sum n)&#13;
  (if (= 0 n) 0&#13;
   <span class="ent">➊</span> (+ n (sum (- n 1)))))</pre>&#13;
<p class="indent">When the recursive call to <code>sum</code> is made <span class="ent">➊</span>, there’s still an addition remaining to be done after the recursive call returns. The system must then remember where it was when the recursive call was made so that it can pick up where it left off when the recursive call returns. This isn’t a problem for functions that don’t have to nest very deeply, but for large depths of recursion, the computer can run out of space and fail in a dramatic fashion.</p>&#13;
<p class="indent">Racket (and virtually all Scheme variants) implement something called <em>tail call optimization</em> (the Racket community says this is simply the proper way to handle tail calls rather than an optimization, but <em>tail call optimization</em> is generally used elsewhere). What this means is that if a recursive call is the very last call being made, there’s no need to remember where to return to since there are no further computations to be made within the function. Such functions in effect behave as a simple iterative loop. This is a basic paradigm for performing looping computations in the Lisp family of languages. You do, however, have to construct your functions in such a way as to take advantage of this feature. We can rewrite the summing function as follows.</p>&#13;
<pre>(define (sum n)&#13;
  (define (s n acc)&#13;
 <span class="ent">➊</span> (if (= 0 n) acc&#13;
     <span class="ent">➋</span> (s (- n 1) (+ acc n))))&#13;
  (s n 0))</pre>&#13;
<p class="indent">Notice that <code>sum</code> now has a local function called <code>s</code> that takes an additional argument called <code>acc</code>. Also notice that <code>s</code> calls itself recursively <span class="ent">➋</span>, but it’s the last call in the local function; hence tail call optimization takes place. This all works because <code>acc</code> accumulates the sum and passes it along as it goes. When it reaches the final nested call <span class="ent">➊</span>, the accumulated value is returned.</p>&#13;
<p class="indent">Another way to do this is with a named <code>let</code> form as shown here.</p>&#13;
<pre>(define (sum n)&#13;
  (let loop ([n n] [acc 0])&#13;
    (if (= 0 n) acc&#13;
        (loop (- n 1) (+ acc n)))))</pre>&#13;
<p class="indent">The named <code>let</code> form, similar to the normal <code>let</code>, has a section where local variables are initialized. The expression <code>[n n]</code> may at first appear puzzling, but what it means is that the first <code>n</code>, which is local to the <code>let</code>, is initialized with the <code>n</code> that the <code>sum</code> function is called with. Unlike <code>define</code>, which simply binds an identifier with a function body, the named <code>let</code> binds the identifier (in this case <code>loop</code>), evaluates the body, and returns the value resulting from calling the function with the initialized parameter list. In this example the <span epub:type="pagebreak" id="page_51"/>function is called recursively (which is the normal use case for a named <code>let</code>) as indicated by the last line in the code. This is a simple illustration of a side-effect-free looping construct favored by the Lisp community.</p>&#13;
<h4 class="h4" id="ch00lev2sec_21"><strong><em>The Power of the Dark Side</em></strong></h4>&#13;
<p class="noindent">Purity is good, as far as it goes. The problem is that staying pure takes a lot of work (especially in real life). It’s time to take a closer look at the dreaded <code>set!</code> form. Note that an exclamation point at the end of any built-in Racket identifier is likely there as a warning that it’s going to do something impure, like modify the program state in some fashion. A programming style that uses statements to change a program’s state is said to use <em>imperative programming</em>. In any case, <code>set!</code> reassigns a value to a previously bound identifier. Let’s revisit the Python <code>sum</code> function we saw a bit earlier. The equivalent Racket version is given below.</p>&#13;
<pre>(define (sum n)&#13;
  (let ([s 0])   ; initialize s to zero&#13;
    (do ()       ; an optional initializer statement can go here&#13;
      ((&lt; n 1))  ; do until this becomes true&#13;
      (set! s (+ s n))&#13;
      (set! n (- n 1)))&#13;
    s))</pre>&#13;
<p class="indent">Racket doesn’t actually have a <code>while</code> statement (this has to do with the expectation within the Lisp community that recursion <em>should</em> be the go-to method for recursion). The Racket <code>do</code> form functions as a <code>do-until</code>.</p>&#13;
<p class="indent">If you’re familiar with the C family of programming languages, then you will see that the full form of the <code>do</code> statement actually functions much like the C <code>for</code> statement. One way to sum the first <em>n</em> integers in C would be as follows:</p>&#13;
<pre><span class="codestrong1">int</span> sum(<span class="codestrong1">int</span> n)&#13;
{&#13;
  <span class="codestrong1">int</span> s = 0;&#13;
  <span class="codestrong1">for</span> (i=1; i&lt;= n; i++) <span class="codeitalic1">// initialize i=1, set i = i+1 at each iteration</span>&#13;
                        <span class="codeitalic1">// do while i&lt;= n</span>&#13;
  {&#13;
      s = s + i;&#13;
  }&#13;
  <span class="codestrong1">return s;</span>             <span class="codeitalic1">// return s</span>&#13;
}</pre>&#13;
<p class="indent">Here’s the Racket equivalent:</p>&#13;
<pre> (define (sum n)&#13;
<span class="ent">➊</span> (let ([s 0])&#13;
  <span class="ent">➋</span> (do ([i 1 (add1 i)])   ; initialize i=1, set i = i+1 at each iteration&#13;
    <span epub:type="pagebreak" id="page_52"/><span class="ent">➌</span> ((&gt; i n) s)          ; do until i&gt;n, then return s&#13;
    <span class="ent">➍</span> (set! s (+ s i)))))</pre>&#13;
<p class="indent">In the above code we first initialize the local variable <code>s</code> (which holds our sum) to 0 <span class="ent">➊</span>. The first argument to <code>do</code> <span class="ent">➋</span> initializes <code>i</code> (<code>i</code> is local to the <code>do</code> form) to 1 and specifies that <code>i</code> is to be incremented by 1 at each iteration of the loop. The second argument <span class="ent">➌</span> tests whether <code>i</code> has reached the target value and if so returns the current value of <code>s</code>. The last line <span class="ent">➍</span> is where the sum is actually computed by increasing the value of <code>s</code> with the current value of <code>i</code> via the <code>set!</code> statement.</p>&#13;
<p class="indent">The value of forms such as <code>do</code> with the <code>set!</code> statement is that many algorithms are naturally stated in a step-by-step fashion with variables mutated by equivalents to the <code>set!</code> statement. This helps to avoid the mental gymnastics needed to convert such constructs to pure recursive functions.</p>&#13;
<p class="indent">In the next section, we examine the <code>for</code> family of looping variants. Here we will see that Racket’s <code>for</code> form provides a great deal of flexibility in how to manage loops.</p>&#13;
<h4 class="h4" id="ch00lev2sec_22"><strong><em>The for Family</em></strong></h4>&#13;
<p class="noindent">Racket provides the <code>for</code> form along with a large family of <code>for</code> variants that should satisfy most of your iteration needs.</p>&#13;
<h5 class="h5" id="ch00lev3sec_36"><strong>A Stream of Values</strong></h5>&#13;
<p class="noindent">Before we dive into <code>for</code>, let’s take a look at a couple of Racket forms that are often used in conjunction with <code>for</code>: <code>in-range</code> and <code>in-naturals</code>. These functions return something we haven’t seen before called a <em>stream</em>. A stream is an object that’s sort of like a list, but whereas a list returns all its values at once, a stream only returns a value when requested. This is basically a form of <em>lazy evaluation</em>, where a value is not provided until asked for. For example, <code>(in-range 10)</code> will return a stream of 10 values starting with 0 and ending with 9. Here are some examples of <code>in-range</code> in action.</p>&#13;
<pre>&gt; <span class="codestrong1">(define digits (in-range 10))</span>&#13;
&gt; <span class="codestrong1">(stream-first digits)</span>&#13;
0&#13;
&#13;
&gt; <span class="codestrong1">(stream-first (stream-rest digits))</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">(stream-ref digits 5)</span>&#13;
5</pre>&#13;
<p class="indent">In the code above, <code>(in-range 10)</code> defines a sequence of values 0, 1, . . . , 9, but <code>digits</code> doesn’t actually contain these digits. It basically just contains a specification that will allow it to return the numbers at some later time. When <code>(stream-first digits)</code> is executed, <code>digits</code> gives the first available value, which in this case is the number 0. Then <code>(stream-rest digits)</code> returns the <span epub:type="pagebreak" id="page_53"/>stream containing the digits after the first, so that <code>(stream-first (stream-rest digits))</code> returns the number 1. Finally, <code>stream-ref</code> returns the <em>i</em>-th value in the stream, which in this case is 5.</p>&#13;
<p class="indent">The function <code>in-naturals</code> works like <code>in-range</code>, but instead of returning a specific number of values, <code>in-naturals</code> returns an infinite number of values.</p>&#13;
<pre>&gt; <span class="codestrong1">(define naturals (in-naturals))</span>&#13;
&gt; <span class="codestrong1">(stream-first naturals)</span>&#13;
0&#13;
&#13;
&gt; <span class="codestrong1">(stream-first (stream-rest naturals))</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">(stream-ref naturals 1000)</span>&#13;
1000</pre>&#13;
<p class="indent">How the stream concept is useful will become clearer as we see it used within some <code>for</code> examples. We’ll also met some useful additional arguments for <code>in-range</code>.</p>&#13;
<h5 class="h5" id="ch00lev3sec_37"><strong>for in the Flesh</strong></h5>&#13;
<p class="noindent">Here’s an example of <code>for</code> in its most basic form. The goal is to print each character of the string “Hello” on a separate line.</p>&#13;
<pre>&gt; <span class="codestrong1">(let* ([h "Hello"]&#13;
      <span class="ent">➊</span> [l (string-length h)])&#13;
   <span class="ent">➋</span> (for ([i (in-range l)])&#13;
     <span class="ent">➌</span> (display (string-ref h i))&#13;
      (newline)))</span>&#13;
H&#13;
e&#13;
l&#13;
l&#13;
o</pre>&#13;
<p class="indent">We capture the <code>string-length</code> <span class="ent">➊</span> and use this length with the <code>in-range</code> function <span class="ent">➋</span>. <code>for</code> then uses the resulting stream of values to populate the identifier <code>i</code>, which is used in the body of the <code>for</code> form to extract and display the characters <span class="ent">➌</span>. In the prior section it was pointed out that <code>in-range</code> produces a sequence of values, but it turns out that in the context of a <code>for</code> statement, a positive integer can also produce a stream as the following example illustrates.</p>&#13;
<pre>&gt; <span class="codestrong1">(for ([i 5]) (display i))</span>&#13;
01234</pre>&#13;
<p class="indent">The <code>for</code> form is quite forgiving when it comes to the type of arguments that it accepts. It turns out that there’s a much simpler way to achieve our goal.</p>&#13;
<pre><span epub:type="pagebreak" id="page_54"/>&gt; <span class="codestrong1">(for ([c "Hello"])&#13;
    (display c)&#13;
    (newline))</span>&#13;
H&#13;
e&#13;
l&#13;
l&#13;
o</pre>&#13;
<p class="indent">Instead of a stream of indexes, we have simply provided the string itself. As we’ll see, <code>for</code> will accept many built-in data types that consist of multiple values, like lists, vectors, and sets. These data types can also be converted to streams (for example, by <code>in-list</code>, <code>in-vector</code>, and so on), which in some cases can provide better performance when used with <code>for</code>. All expressions that provide values to the identifier that <code>for</code> uses to iterate over are called <em>sequence expressions</em>.</p>&#13;
<p class="indent">It’s time to see how we can make use of the mysterious <code>in-naturals</code> form introduced above.</p>&#13;
<pre>&gt; <span class="codestrong1">(define (list-chars str)&#13;
    (for ([c str]&#13;
          [i (in-naturals)])&#13;
      (printf "~a: ~a\n" i c)))</span>&#13;
      &#13;
&gt; <span class="codestrong1">(list-chars "Hello")</span>&#13;
0: H&#13;
1: e&#13;
2: l&#13;
3: l&#13;
4: o</pre>&#13;
<p class="indent">The <code>for</code> form inside the <code>list-chars</code> function now has <em>two</em> sequence expressions. Such sequence expressions are evaluated in parallel until one of the expressions runs out of values. That is why the <code>for</code> expression eventually terminates, even though <code>in-naturals</code> provides an infinite number of values.</p>&#13;
<p class="indent">There is, in fact, a version of <code>for</code> that <em>does not</em> evaluate its sequence expressions in parallel: it’s called <code>for*</code>. This version of <code>for</code> evaluates its sequence expressions in a nested fashion as the following example illustrates.</p>&#13;
<pre><span epub:type="pagebreak" id="page_55"/>&gt; <span class="codestrong1">(for* ([i (in-range 2 7 4)]&#13;
         [j (in-range 1 4)])&#13;
    (display (list i j (* i j)))&#13;
    (newline))</span>&#13;
(2 1 2)&#13;
(2 2 4)&#13;
(2 3 6)&#13;
(6 1 6)&#13;
(6 2 12)&#13;
(6 3 18)</pre>&#13;
<p class="indent">In this example we also illustrate the additional optional arguments that <code>in-range</code> can take. The sequence expression <code>(in-range 2 7 4)</code> will result in a stream that starts with the number 2, and increment that value by 4 with each iteration. The iteration will stop once the streamed value reaches one less than 7. So in this expression, <code>i</code> is bound to 2 and 6. The expression <code>(in-range 1 4)</code> does not specify a step value, so the default step size of 1 is used. This results in <code>j</code> being bound to 1, 2, and 3.</p>&#13;
<p class="indent">Ultimately, <code>for*</code> takes every possible combination of <code>i</code> values and <code>j</code> values to form the output shown.</p>&#13;
<h5 class="h5" id="ch00lev3sec_38">Can You <em>Comprehend</em> This?</h5>&#13;
<p class="noindent">There is a type of notation in mathematics called set-builder notation. An example of set-builder notation is the expression {<em>x</em><sup>2</sup> ∣ <em>x</em> ∈ ℕ, <em>x</em> ≤ 10}. This is just the set of squares of all the natural numbers between 0 and 10. Racket provides a natural (pun intended) extension of this idea in the form of something called a <em>list comprehension</em>. A direct translation of that mathematical expression in Racket would appear as follows.</p>&#13;
<pre>&gt; <span class="codestrong1">(for/list ([x (in-naturals)] #:break (&gt; x 10)) (sqr x))</span>&#13;
'(0 1 4 9 16 25 36 49 64 81 100)</pre>&#13;
<p class="indent">The <code>#:break</code> keyword is used to terminate the stream generated by <code>in-naturals</code> once all the desired values have been produced. Another way to do this, without having to resort to using <code>#:break</code>, would be with <code>in-range</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">(for/list ([x (in-range 11)]) (sqr x))</span>&#13;
'(0 1 4 9 16 25 36 49 64 81 100)</pre>&#13;
<p class="indent">If you only wanted the squares of even numbers, you could do it this way:</p>&#13;
<pre>&gt; <span class="codestrong1">(for/list ([x (in-range 11)] #:when (even? x)) (sqr x))</span>&#13;
'(0 4 16 36 64 100)</pre>&#13;
<p class="indent">This time the <code>#:when</code> keyword was brought into play to provide a condition to filter the values used to generate the list.</p>&#13;
<p class="indent">An important difference of <code>for/list</code> over <code>for</code> is that <code>for/list</code> does not produce any side effects and is therefore a pure form, whereas <code>for</code> is expressly for the purpose of producing side effects.</p>&#13;
<h5 class="h5" id="ch00lev3sec_39"><strong>More Fun with for</strong></h5>&#13;
<p class="noindent">Both <code>for</code> and <code>for/list</code> share the same keyword parameters. Suppose we wanted to print a list of squares, but don’t particularly like the number 5. Here’s how it could be done.</p>&#13;
<pre><span epub:type="pagebreak" id="page_56"/>&gt; <span class="codestrong1">(for ([n (in-range 1 10)] #:unless (= n 5))&#13;
    (printf "~a: ~a\n" n (sqr n)))</span>&#13;
1: 1&#13;
2: 4&#13;
3: 9&#13;
4: 16&#13;
6: 36&#13;
7: 49&#13;
8: 64&#13;
9: 81</pre>&#13;
<p class="indent">By using <code>#:unless</code> we’ve produced an output for all values, 1 ≤ <em>n</em> &lt; 10, unless <em>n</em> = 5.</p>&#13;
<p class="indent">Sometimes it’s desirable to test a list of values to see if they all meet some particular criteria. Mathematicians use a fancy notation to designate this called the universal quantifier, which looks like this ∀ and means “for all.” An example is the expression ∀x ∈ {2, 4, 6}, <em>x</em> mod 2 = 0, which is literally interpreted as “for all <em>x</em> in the set {2, 4, 6}, the remainder of <em>x</em> after dividing by 2 is 0." This just says that the numbers 2, 4, and 6 are even. The Racket version of “for all” is <code>for/and</code>.</p>&#13;
<p class="indent">Feed the <code>for/and</code> form a list of values and a Boolean expression to evaluate the values. If each value evaluates to true, the entire <code>for/and</code> expression returns true; otherwise it returns false. Let’s have a go at it.</p>&#13;
<pre>&gt; <span class="codestrong1">(for/and ([x '(2 4 6)]) (even? x))</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(for/and ([x '(2 4 5 6)]) (even? x))</span> &#13;
#f</pre>&#13;
<p class="indent">Like <code>for</code>, <code>for/and</code> can handle multiple sequence expressions. In this case, the values in each sequence are compared in parallel.</p>&#13;
<pre>&gt; <span class="codestrong1">(for/and ([x '(2 4 5 6)]&#13;
            [y #(3 5 9 8)])&#13;
    (&lt; x y))</span> &#13;
#t&#13;
&gt; <span class="codestrong1">(for/and ([x '(2 6 5 6)]&#13;
            [y #(3 5 9 8)])&#13;
    (&lt; x y))</span> &#13;
#f</pre>&#13;
<p class="indent">Closely related to <code>for/and</code> is <code>for/or</code>. Not to be outdone, mathematicians have a notation for this as well: it’s called the existential quantifier, ∃. For example, they express the fact that there <em>exists</em> a number in the set {2, 7, 4, 6} greater than 5 with the expression ∃<em>x</em> ∈ {2, 7, 4, 6}, <em>x</em> &gt; 5.</p>&#13;
<pre><span epub:type="pagebreak" id="page_57"/>&gt; <span class="codestrong1">(for/or ([x '(2 7 4 6)]) (&gt; x 5))</span> &#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(for/or ([x '(2 1 4 5)]) (&gt; x 5))</span> &#13;
#f</pre>&#13;
<p class="indent">Suppose now that you not only want to know whether a list contains a value that meets a certain criterion, but you want to extract the first value that meets the criterion. This is a job for <code>for/first</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(for/first ([x '(2 1 4 6 7 1)] #:when (&gt; x 5)) x)</span>&#13;
6&#13;
&#13;
&gt; <span class="codestrong1">(for/first ([x '(2 1 4 5 2)] #:when (&gt; x 5)) x)</span>&#13;
#f</pre>&#13;
<p class="indent">The last example demonstrates that if there is no value that meets the criterion, <code>for/first</code> returns false.</p>&#13;
<p class="indent">Correspondingly, if you want the last value, you can use <code>for/last</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(for/last ([x '(2 1 4 6 7 1)] #:when (&gt; x 5)) x)</span>&#13;
7</pre>&#13;
<p class="indent">The <code>for</code> family of functions is fertile ground for exploring parallels between mathematical notation and Racket forms. Here is yet another example. To indicate the sum of the squares of the integers from 1 to 10, the following notation would be employed:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0057-01.jpg"/></div>&#13;
<p class="noindent">The equivalent Racket expression is:</p>&#13;
<pre>&gt; <span class="codestrong1">(for/sum ([i (in-range 1 11)]) (sqr i))</span>&#13;
385</pre>&#13;
<p class="indent">The equivalent mathematical expression for products is</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0057-02.jpg"/></div>&#13;
<p class="noindent">which in Racket becomes</p>&#13;
<pre>&gt; <span class="codestrong1">(for/product ([i (in-range 1 11)]) (sqr i))</span>&#13;
13168189440000</pre>&#13;
<p class="indent">Most of the <code>for</code> forms discussed above come in a starred version (for example <code>for*/list</code>, <code>for*/and</code>, <code>for*/or</code>, and so on). Each of these works by evaluating their sequence expressions in a nested fashion as described for <code>for*</code>.</p>&#13;
<h3 class="h3" id="ch00lev1sec_21"><span epub:type="pagebreak" id="page_58"/>Time for Some Closure</h3>&#13;
<p class="noindent">Suppose you had $100 in the bank and wanted to explore the effects of compounding with various interest rates. If you’re not familiar with how compound interest works (and you very well should be), it works as follows: if you have <em>n</em><sub>0</sub> in a bank account that pays <em>i</em> periodic interest, at the end of the period you would have this:</p>&#13;
<p class="center"><em>n</em><sub>1</sub> = <em>n</em><sub>0</sub> + <em>n</em><sub>0</sub><em>i</em> = <em>n</em><sub>0</sub>(1 + <em>i</em>)</p>&#13;
<p class="noindent">Using your $100 deposit as an example, if your bank pays 4 percent (<em>i</em> = 0<em>.</em>04) interest per period (good luck getting that rate at a bank nowadays), you would have the following at the end of the period:</p>&#13;
<p class="center">100 + 100 · 4% = 100(1 + 0.04) = 104</p>&#13;
<p class="indent">One way to do this is to create a function that automatically updates the balance after applying the interest rate. A clever way to compute this in Racket is with something called a <em>closure</em>, which we use in the following function:</p>&#13;
<pre>(define (make-comp bal int)&#13;
  (let ([rate (add1 (/ int 100.0))])&#13;
 <span class="ent">➊</span> (λ () (set! bal (* bal rate))  (round bal))))</pre>&#13;
<p class="indent">Notice that this function actually returns another function—the lambda expression (λ . . . ) <span class="ent">➊</span>—and that the lambda expression contains variables from the defining scope. We shall explain how this works shortly.</p>&#13;
<p class="indent">In the code above, we’ve defined a function called <code>make-comp</code> which takes two arguments: the starting balance and the interest rate percentage. The <code>rate</code> variable is initialized to (1 + <em>i</em>). Rather than return a number, this function actually returns another function. The returned function is designed in such a way that every time it’s called (without arguments) it updates the balance by applying the interest and returns the new balance. You might think that once <code>make-comp</code> returns the lambda expression, the variables <code>bal</code> and <code>rate</code> would be undefined, but not so with closures. The lambda expression is said to <em>capture</em> the variables <code>bal</code> and <code>rate</code>, which are available within the lexical environment where the lambda expression is defined. The fact that the returned function contains the variables <code>bal</code> and <code>rate</code> (which are defined outside of the function) is what makes it a closure.</p>&#13;
<p class="indent">Let’s try this out and see what happens.</p>&#13;
<pre>&gt; <span class="codestrong1">(define bal (make-comp 100 4))</span>&#13;
&#13;
&gt; <span class="codestrong1">(bal)</span>&#13;
104.0&#13;
&#13;
&gt; <span class="codestrong1">(bal)</span>&#13;
108.0&#13;
&#13;
&gt; <span class="codestrong1">(bal)</span>&#13;
112.0&#13;
&#13;
&gt; <span class="codestrong1">(bal)</span>&#13;
117.0</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>As you can see, the balance is updated appropriately.</p>&#13;
<p class="indent">Another use for closures is in a technique called <em>memoization</em>. What this means is that we store prior computed values and if a value has already been computed, return the remembered value; otherwise go ahead and compute the value and save it for when it’s needed again. This is valuable in scenarios where a function may be called repeatedly with arguments that have already been computed.</p>&#13;
<p class="indent">To facilitate this capability, something called a <em>hash table</em> or dictionary is typically used. A hash table is a mutable set of key-value pairs. A hash table is constructed with the function <code>make-hash</code>. Items can be stored to the hash table via <code>hash-set!</code> and retrieved from the table with <code>hash-ref</code>. We test whether the table already contains a key with <code>hash-has-key?</code>.</p>&#13;
<p class="indent">The standard definition for the factorial function is <em>n</em>! = <em>n</em>(<em>n -</em> 1)!. The obvious way to implement this in Racket is with the following.</p>&#13;
<pre>(define (fact n)&#13;
  (if ( = 0 n) 1&#13;
      (* n (fact (- n 1)))))</pre>&#13;
<p class="indent">This works, but every time you call <code>(fact 100)</code>, Racket has to perform 100 computations. With memoization, executing <code>(fact 100)</code> still requires 100 computations <em>the first time</em>. But the next time you call <code>(fact 100)</code> (or call <code>fact</code> for any value less than 100), Racket only has to look up the value in the hash table, which happens in a single step. Here’s the implementation.</p>&#13;
<pre>(define fact&#13;
  (let ([h (make-hash)]) ; hash table to contain memoized values&#13;
 <span class="ent">➊</span> (define (fact n)&#13;
      (cond [(= n 0) 1]&#13;
         <span class="ent">➋</span> [(hash-has-key? h n) (hash-ref h n)]&#13;
             [else&#13;
             <span class="ent">➌</span> (let ([f (* n (fact (- n 1)))]) &#13;
               <span class="ent">➍</span> (hash-set! h n f)&#13;
                f)]))&#13;
 <span class="ent">➎</span> fact))</pre>&#13;
<p class="indent">It’s important to note that the outer <code>fact</code> function actually returns the inner <code>fact</code> function <span class="ent">➊</span>. This is ultimately what gets executed when we call <code>fact 100</code>. It’s this inner <code>fact</code> function, which captures the hash table, that constitutes the closure. First, it checks to see whether the argument to <code>fact</code> is one that is already computed <span class="ent">➋</span> and if so, returns the saved value. We still have to compute the value if it hasn’t been computed yet <span class="ent">➌</span>, but then we save <span epub:type="pagebreak" id="page_60"/>it in case it’s needed later <span class="ent">➍</span>. The local <code>fact</code> function is returned as the value of the global <code>fact</code> function (sorry about using the same name twice).</p>&#13;
<h3 class="h3" id="ch00lev1sec_22">Applications</h3>&#13;
<p class="noindent">Having introduced the basic programming constructs available in Racket, let’s take a look at some applications spanning computer science, mathematics, and recreational puzzles.</p>&#13;
<h4 class="h4" id="ch00lev2sec_23"><strong><em>I Don’t Have a Queue</em></strong></h4>&#13;
<p class="noindent">In this section we touch on Racket’s <em>object-oriented programming</em> capability. Objects are like a deluxe version of the structures we met in <a href="ch01.xhtml">Chapter 1</a>.</p>&#13;
<p class="indent">Imagine early morning at a small-town bank with a single teller. The bank has just opened, and the teller is still trying to get set up, but a customer, Tom, has already arrived and is waiting at the window. Shortly, two other customers show up: Dick and Harry. The teller finally waits on Tom, then Dick and Harry in that order. This situation is a classic example of a <em>queue</em>. Formally, a queue is a first-in, first-out (FIFO) data structure. Racket comes with a built-in queue (several, in fact), but let’s explore building one from scratch.</p>&#13;
<p class="indent">We can model a queue with a list. For example the line of folks waiting to see the teller can be represented by a single list: <code>(define q (list</code> ’<code>tom</code> ’<code>dick</code> ’<code>harry))</code>. But there’s a problem. It’s clearly easy to remove Tom from the head of the list and get the remainder of the list by using <code>car</code> (or <code>first</code>) and <code>cdr</code> (or <code>rest</code>):</p>&#13;
<pre>&gt; <span class="codestrong1">(car q)</span>&#13;
'tom&#13;
&#13;
&gt; <span class="codestrong1">(set! q (cdr q))</span>&#13;
&gt; <span class="codestrong1">q</span>&#13;
'(dick harry)</pre>&#13;
<p class="indent">But what happens when Sue comes along? We could do the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(set! q (append q (list 'sue)))</span>&#13;
&gt; <span class="codestrong1">q</span>&#13;
'(dick harry sue)</pre>&#13;
<p class="indent">But consider what happens if the list is very long, say 10,000 elements. The <code>append</code> function will create an entire new list containing all the elements from q and the one additional value ’<code>sue</code>. One way to do this efficiently is to maintain a pointer to the last element in the list and instead of creating a new list change the <code>cdr</code> of the last node of the list to point to the list <code>(list</code> ’<code>sue)</code> (see <a href="ch03.xhtml#ch3fig2">Figure 3-2</a>). About now alarm bells should be going off in your head. You should have an uneasy feeling that modifying a list structure is somehow wrong. And you’d be right. It’s not even possible to do this with the normal <span epub:type="pagebreak" id="page_61"/>Racket list structure since the <code>car</code> and <code>cdr</code> cells in a list pair are immutable and cannot be changed.</p>&#13;
<div class="image"><img alt="Image" src="../images/03fig02.jpg"/></div>&#13;
<p class="figcap" id="ch3fig2"><em>Figure 3-2: Mutable list</em></p>&#13;
<p class="indent">The traditional version of Scheme allow the elements of a cons node to be modified via <code>set-car!</code> and <code>set-cdr!</code> methods. Since these aren’t defined in Racket, Racket guarantees that any identifier bound to a Racket list will have the same value for the life of the program.</p>&#13;
<p class="indent">There are still valid reasons why this capability may be needed. As we’ve seen, this functionality is needed for queues to ensure efficient operation. To accommodate this need, Racket provides a mutable cons cell that can be created with the <code>mcons</code> function. Each component of the mutable cons cell can be modified with <code>set-mcar!</code> and <code>set-mcdr!</code>. The functions <code>mcar</code> and <code>mcdr</code> are the corresponding accessor functions.</p>&#13;
<p class="indent">The reason modifying a list structure is bad is because if some other identifier is bound to the list, it will now have the modified list as its value, and maybe that’s not what was intended. Observe the following.</p>&#13;
<pre>&gt; <span class="codestrong1">(define a (mcons 'apple 'orange))</span>&#13;
&gt; <span class="codestrong1">(define b a)</span>&#13;
&gt; <span class="codestrong1">a</span>&#13;
(mcons 'apple 'orange)&#13;
&gt; <span class="codestrong1">b</span>&#13;
(mcons 'apple 'orange)&#13;
&#13;
&gt; <span class="codestrong1">(set-mcdr! a 'banana)</span>&#13;
&gt; <span class="codestrong1">a</span>&#13;
(mcons 'apple 'banana)&#13;
&gt; <span class="codestrong1">b</span>&#13;
(mcons 'apple 'banana)</pre>&#13;
<p class="indent">Although we only <em>seemed</em> to be changing the value of <code>a</code>, we also changed the value of <code>b</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_62"/>To avoid this potentially disastrous situation, we’ll <em>encapsulate</em> the list in such a way that the list itself is not accessible, but we’ll still be able to remove elements from the front of the list and add elements to the end of the list to implement our queue. Encapsulation is a fundamental component of object-oriented programming. We’ll dive right in by creating a class that contains all the functionality we need to implement our queue:</p>&#13;
<pre><span class="ent">➊</span> (define queue%&#13;
  &#13;
  <span class="ent">➋</span> (class object%&#13;
    &#13;
    <span class="ent">➌</span> (init [queue-list '()])&#13;
 &#13;
    <span class="ent">➍</span> (define head '{})&#13;
       (define tail '{}) &#13;
 &#13;
    <span class="ent">➎</span> (super-new) &#13;
 &#13;
    <span class="ent">➏</span> (define/public (enqueue val)&#13;
         (let ([t (mcons val '())])&#13;
           (if (null? head)&#13;
               (begin&#13;
                 (set! head t)&#13;
                 (set! tail t))&#13;
               (begin&#13;
                 (set-mcdr! tail t)&#13;
                 (set! tail t)))))&#13;
 &#13;
    <span class="ent">➐</span> (define/public (dequeue)&#13;
         (if (null? head) (error "Queue is empty.")&#13;
             (let ([val (mcar head)])&#13;
            <span class="ent">➑</span> (set! head (mcdr head))&#13;
               (when (null? head) (set! tail '()))&#13;
               val)))&#13;
&#13;
      (define/public (print-queue)&#13;
        (define (prt rest)&#13;
          (if (null? rest)&#13;
              (newline)&#13;
              (let ([h (mcar rest)]&#13;
                    [t (mcdr rest)])&#13;
                (printf "~a " h)&#13;
                (prt t))))&#13;
         (prt head))&#13;
    &#13;
    <span class="ent">➒</span> (for ([v queue-list]) (enqueue v))))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>Our class name is <code>queue%</code> (note that, by convention, Racket class names end with <code>%</code>). We begin with the class definition <span class="ent">➊</span>. All classes must inherit from some parent class. In this case we’re using the built-in class <code>object%</code> <span class="ent">➋</span>. Once we’ve specified the class name and parent class, we specify the initialization parameters for the class <span class="ent">➌</span>. This class takes a single, optional list argument. If supplied, this list is used to initialize the queue <span class="ent">➒</span>. Our class uses <code>head</code> and <code>tail</code> pointer identifiers, which we have to define <span class="ent">➍</span>. Within the body of a class, <code>define</code> statements are not accessible from outside the class. This means that there is no way for the values of <code>head</code> or <code>tail</code> to be bound to an identifier outside of the class.</p>&#13;
<p class="indent">After a required call to the super class (in this case <code>object%</code>) <span class="ent">➎</span>, we get into the real meat of this class: its methods. First we define a <em>public</em> class method called <code>enqueue</code> <span class="ent">➏</span>. Public methods are accessible from outside the class. This method takes a single value, which is added to the end of the queue in a manner similar to our apple and banana example. If the queue is empty, then it initializes the <code>head</code> and <code>tail</code> identifiers with the mutable cons cell <code>t</code>.</p>&#13;
<p class="indent">The <code>dequeue</code> method <span class="ent">➐</span> returns the value at the head of the queue, but generates an error if the queue is empty. The <code>head</code> pointer is updated to point to the next value in the queue <span class="ent">➑</span>.</p>&#13;
<p class="indent">To see all the values in the queue, we’ve also defined the method <code>print-queue</code>.</p>&#13;
<p class="indent">Let’s see it in action.</p>&#13;
<pre>&gt; <span class="codestrong1">(define queue (new queue% [queue-list '(tom dick harry)]))</span>&#13;
&#13;
&gt; <span class="codestrong1">(send queue dequeue)</span>&#13;
'tom&#13;
&#13;
&gt; <span class="codestrong1">(send queue enqueue 'sue)</span>&#13;
&gt; <span class="codestrong1">(send queue print-queue)</span>&#13;
dick harry sue &#13;
&#13;
&gt; <span class="codestrong1">(send queue dequeue)</span>&#13;
'dick&#13;
&#13;
&gt; <span class="codestrong1">(send queue dequeue)</span>&#13;
'harry&#13;
&#13;
&gt; <span class="codestrong1">(send queue dequeue)</span>&#13;
'sue&#13;
&#13;
&gt; <span class="codestrong1">(send queue dequeue)</span>&#13;
. . Queue is empty.</pre>&#13;
<p class="indent">Class objects are created with the <code>new</code> form. This form includes the class name and any parameters defined by the <code>init</code> form in the class definition (see the class definition code <span class="ent">➌</span>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>Unlike normal Racket functions and methods, an object method must be invoked with a <code>send</code> form. The <code>send</code> identifier is followed by the object name (<code>queue</code>), the method name, and any arguments for the method.</p>&#13;
<p class="indent">This example was just meant to expose the basics of Racket’s object-oriented capabilities, but we’ll be seeing much more of Racket’s object prowess in the remainder of the text.</p>&#13;
<h4 class="h4" id="ch00lev2sec_24"><strong><em>The Tower of Hanoi</em></strong></h4>&#13;
<p class="noindent">The Tower of Hanoi is a puzzle that consists of three pegs embedded in a board, along with eight circular discs, each with a hole in the center. No two discs are the same size, and they are arranged on one of the pegs so that the largest is on the bottom and the rest are arranged such that a smaller disc is always immediately above a larger disc (See <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>).</p>&#13;
<div class="image"><img alt="Image" src="../images/03fig03.jpg"/></div>&#13;
<p class="figcap" id="ch3fig3"><em>Figure 3-3: The Tower of Hanoi</em></p>&#13;
<p class="indent">W. W. Rouse Ball tells the following entertaining story about how this puzzle came about (see [<strong>3</strong>] and [<strong>8</strong>]).</p>&#13;
<div class="bq5">&#13;
<p class="noindent">In the great temple at Benares beneath the dome which marks the center of the world, rests a brass plate in which are fixed three diamond needles, each a cubit high and as thick as the body of a bee. On one of these needles, at the creation, God placed sixty-four disks of pure gold, the largest disc resting on the brass plate and the others getting smaller and smaller up to the top one. This is the tower of Brahma. Day and night unceasingly, the priest on duty transfers the disks from one diamond needle to another, according to the fixed and immutable laws of Brahmah, which require that the priest must move only one disk at a time, and he must place these discs on needles so that there never is a smaller disc below a larger one. When all the sixty-four discs shall have been thus transferred from the needle on which, at the creation, God placed them, to one of the other needles, tower, temple, and Brahmans alike will crumble into dust, and with a thunderclap the world will vanish.</p></div>&#13;
<p class="noindent">This would take 2<sup>64</sup> <em>-</em> 1 moves. Let’s see how much time we have left until the world comes to an end. We assume one move can be made each second.</p>&#13;
<pre>&gt; <span class="codestrong1">(define moves (- (expt 2 64) 1))</span>&#13;
&gt; <span class="codestrong1">moves</span>&#13;
18446744073709551615&#13;
&#13;
&gt; <span class="codestrong1">(define seconds-in-a-year (* 60 60 24 365.25))</span>&#13;
&gt; <span class="codestrong1">seconds-in-a-year</span>&#13;
31557600.0&#13;
&#13;
&gt; <span class="codestrong1">(/ moves seconds-in-a-year)</span>&#13;
584542046090.6263</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_65"/>This last number is about 5<em>.</em>84 × 10<sup>11</sup> years. The universe is currently estimated to be a shade under 14 × 10<sup>9</sup> years old. If the priests started moving disks at the beginning of the universe, there would be about 570 billion years left, so you probably have at least enough time to finish reading this book.</p>&#13;
<p class="indent">As interesting as this is, our main objective is to use Racket to show how to actually perform the moves. We’ll of course begin with a more modest number of disks, so let’s start with just one disk. We’ll number the pegs 0, 1, and 2. Suppose our goal is to move the disks from peg 0 to peg 2. With only one disk, we just move the disk from peg 0 to peg 2. If we have <em>n</em> &gt; 1 disks, we designate the peg we’re moving all the disks from as <em>f</em>, the peg we are moving to as <em>t</em> and the remaining peg we designate as <em>u</em>. The steps to solve the puzzle can be stated thusly:</p>&#13;
<ol>&#13;
<li class="noindent">Move <em>n -</em> 1    disks from <em>f</em>  to <em>u</em>.</li>&#13;
<li class="noindent">Move a single disk from <em>f</em>  to <em>t</em>.</li>&#13;
<li class="noindent">Move <em>n -</em> 1  disks from <em>u</em>  to <em>t</em>.</li>&#13;
</ol>&#13;
<p class="noindent">While simple, this process is sufficient to solve the puzzle. Steps 1 and 3 imply the use of recursion. Here is the Racket code that implements these steps.</p>&#13;
<pre><span class="ent">➊</span> (define (hanoi n f t)&#13;
  <span class="ent">➋</span> (if (= 1 n) (list (list f t))        ; only a single disk to move&#13;
      <span class="ent">➌</span> (let* ([u (- 3 (+ f t))]         ; determine unused peg&#13;
             <span class="ent">➍</span> [m1 (hanoi (sub1 n) f u)] ; move n-1 disks from f to u&#13;
             <span class="ent">➎</span> [m2 (list f t)]           ; move single disk from f to t&#13;
             <span class="ent">➏</span> [m3 (hanoi (sub1 n) u t)]); move disks from u to t&#13;
        <span class="ent">➐</span> (append m1 (cons m2 m3)))))</pre>&#13;
<p class="indent">We pass <code>hanoi</code> the number of disks, the peg to move them from, and the peg to move to. Then we compute the moves required to implement steps one <span class="ent">➌</span>, two <span class="ent">➍</span>, and three <span class="ent">➎</span>. Can you see why the <code>let</code> expression <span class="ent">➌</span> determines the unused peg? (Hint: think of the possible combinations. For example if <em>f</em> = 1 and <em>t</em> = 2, the <code>let</code> expression <span class="ent">➌</span> would give <em>u</em> = 3 <em>-</em> (1 + 2) = 0, the unused peg number.) The <code>hanoi</code> function returns a list of moves <span class="ent">➏</span>. Each element of the list is a list of two elements that designate the peg to move from and the peg to move to. Here’s an example of the output for three disks:</p>&#13;
<pre>&gt; <span class="codestrong1">(hanoi 3 0 2)</span>&#13;
'((0 2) (0 1) (2 1) (0 2) (1 0) (1 2) (0 2))</pre>&#13;
<p class="noindent">Note that we have 2<sup>3</sup> <em>-</em> 1 = 7 moves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_66"/>As can be seen from the comments in the code, the <code>hanoi</code> function is essentially a direct translation of the three-step solution process given earlier. Further, it provides a practical application of recursion where the function calls itself with a simpler version of the problem.</p>&#13;
<h4 class="h4" id="ch00lev2sec_25"><strong><em>Fibonacci and Friends</em></strong></h4>&#13;
<p class="noindent">The <em>Fibonacci sequence</em> of numbers is defined as</p>&#13;
<p class="center">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . .</p>&#13;
<p class="noindent">where the next term in the sequence is always the sum of the two preceding terms. In some cases the initial zero is not considered part of the sequence. This sequence has a ton of interesting properties. We will only touch on a few of them here.</p>&#13;
<h5 class="h5" id="ch00lev3sec_40"><strong>Some Interesting Properties</strong></h5>&#13;
<p class="noindent">One interesting property of the Fibonacci sequence is that it’s always possible to create a rectangle tiled with squares whose sides have lengths generated by the sequence, as seen in <a href="ch03.xhtml#ch3fig4">Figure 3-4</a>. We’ll see how to generate this tiling in <a href="ch04.xhtml">Chapter 4</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/03fig04.jpg"/></div>&#13;
<p class="figcap" id="ch3fig4"><em>Figure 3-4: Fibonacci tiling</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>Johannes Kepler pointed out that the ratio of consecutive Fibonacci numbers approaches a particular number, designated by <em>ϕ</em>, which is known as the <em>golden ratio</em>:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p067.jpg"/></div>&#13;
<p class="indent">If you’re not familiar with that lim <em>n</em> →<em>∞</em> business, it just means this is what you get when <em>n</em> gets bigger and bigger.</p>&#13;
<p class="indent">The number <em>ϕ</em> has many interesting properties as well. One example is the <em>golden spiral</em>. A golden spiral is a logarithmic spiral whose growth factor is <em>ϕ</em>, which means that it gets wider (or further from its origin) by a factor of <em>ϕ</em> for every quarter-turn. A golden spiral with initial radius 1 has the following polar equation:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p067_1.jpg"/></div>&#13;
<p class="indent">A plot of the golden spiral is shown in <a href="ch03.xhtml#ch3fig5">Figure 3-5</a>. We’ll show how this plot was produced in <a href="ch04.xhtml">Chapter 4</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/03fig05.jpg"/></div>&#13;
<p class="figcap" id="ch3fig5"><em>Figure 3-5: The golden spiral</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/><a href="ch03.xhtml#ch3fig6">Figure 3-6</a> illustrates an approximation of the golden spiral created by drawing circular arcs connecting the opposite corners of squares in the Fibonacci tiling (in <a href="ch04.xhtml">Chapter 4</a> we’ll see how to superimpose this spiral onto a Fibonacci tiling).</p>&#13;
<div class="image"><img alt="Image" src="../images/03fig06.jpg"/></div>&#13;
<p class="figcap" id="ch3fig6"><em>Figure 3-6: A golden spiral approximation</em></p>&#13;
<p class="indent">While these two versions of the golden spiral appear quite similar, mathematically they’re quite different. This has to do with a concept called <em>curvature</em>. This has a precise mathematical definition, but for now, just think of it as the curviness of the path. The tighter the curve, the larger the curviness. The path described by Equation (3.1) has continuous curvature, while the Fibonacci spiral has discontinuous curvature. <a href="ch03.xhtml#ch3fig7">Figure 3-7</a> demonstrates the distinct difference in curvature these two paths possess.</p>&#13;
<p class="indent">We will make use of these properties in the following sections and in <a href="ch04.xhtml">Chapter 4</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_69"/><img alt="Image" src="../images/03fig07.jpg"/></div>&#13;
<p class="figcap" id="ch3fig7"><em>Figure 3-7: Curvature: golden vs. Fibonacci</em></p>&#13;
<h5 class="h5" id="ch00lev3sec_41"><strong>Computing the Sequence</strong></h5>&#13;
<p class="noindent">Mathematically the sequence <em>F</em><sub><em>n</em></sub> of Fibonacci numbers is defined by the recurrence relation:</p>&#13;
<p class="center"><em>F</em><sub>n</sub> = <em>F</em><sub>n-1</sub> + <em>F</em><sub>n-2</sub></p>&#13;
<p class="indent">In this section we’ll explore three different methods of computing this sequence.</p>&#13;
<p class="indent"><strong>1. The No-brainer Approach.</strong> With the recurrence relation definition for the Fibonacci sequence, our first version practically writes itself. It’s literally an exact translation from the definition to a Racket function.</p>&#13;
<pre>(define (F n)&#13;
  (if (&lt;= n 1) n&#13;
    (+ (F (- n 1)) (F (- n 2)))))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>This code has the virtue of being extremely clear and simple. The only problem with this code is that it’s terribly inefficient. The two nested calls cause the same value to be computed over and over. The end result is that the amount of computation grows exponentially with the size of <em>n</em>.</p>&#13;
<p class="indent"><strong>2. Efficiency Is King.</strong> Here we explore an ingenious method presented in the computer science classic <em>Structure and Interpretation of Computer Programs</em> [<strong>2</strong>]. The idea is to use a pair of integers initialized such that <em>a</em> = <em>F</em><sub>1</sub> = 1 and <em>b</em> = <em>F</em><sub>0</sub> = 0, and repeatedly apply the transformations:</p>&#13;
<p class="center1">     <em>a ← a + b</em></p>&#13;
<p class="center2"><em>b ← a</em></p>&#13;
<p class="indent">It can be shown that after applying these transformations <em>n</em> times, we’ll have <em>a</em> = <em>F</em><sub><em>n</em>+1</sub> and <em>b</em> = <em>F</em><sub><em>n</em></sub>. The proof is not difficult, and I’ve left it as an exercise for you. Here’s the code to implement this solution:</p>&#13;
<pre>(define (F n)&#13;
  (define (f a b c)&#13;
    (if (= c 0) b&#13;
        (f (+ a b) a (- c 1))))&#13;
  (f 1 0 n))</pre>&#13;
<p class="indent">Due to tail call optimization, <code>f</code> recursively calls itself without the need to keep track of a continuation point. This works as an iterative process and only grows linearly with the size of <em>n</em>.</p>&#13;
<p class="indent"><strong>3. Memory Serves.</strong> In this version we use the memoization technique introduced in <a href="ch03.xhtml#ch00lev1sec_21">“Time for Some Closure” on page 58</a>. To facilitate this, the code below uses a <em>hash table</em>. Recall that a hash table is a mutable set of key-value pairs, and it’s constructed with the function <code>make-hash</code>. Items can be stored to the hash table via <code>hash-set!</code> and retrieved from the table with <code>hash-ref</code>. We test whether the table already contains a key with <code>hash-has-key?</code>.</p>&#13;
<pre>(define F&#13;
  (let ([f (make-hash)]) ; hash table to contain memoized F values&#13;
    (define (fib n)&#13;
      (cond [(&lt;= n 1) n]&#13;
            [(hash-has-key? f n) (hash-ref f n)]&#13;
            [else&#13;
              (let ([fn (+ (fib (- n 1)) (fib (- n 2)))])&#13;
                (hash-set! f n fn)&#13;
                fn)]))&#13;
    fib))</pre>&#13;
<p class="indent">This code should be fairly easy to decipher. It’s a straightforward application of memoization as seen in the <code>fact</code> example presented earlier.</p>&#13;
<p class="indent"><strong>And the Winner Is?</strong> It depends. You should definitely never use the first approach. Here’s something to consider when comparing the second and the third: the second approach <em>always</em> requires <em>n</em> computations every time <code>F</code> is called for <em>n</em>. The third approach also requires <em>n</em> computations <em>the first time</em> <span epub:type="pagebreak" id="page_71"/><code>F</code> is called for <em>n</em>. If you call it a second (or subsequent) time for <em>n</em> (or for any number less than <em>n</em>), it returns almost instantly since it simply has to look up the value in the hash table. There’s a small space penalty for the third approach, but it’s likely to be insignificant in most cases.</p>&#13;
<p class="indent"><strong>Binet’s Formula.</strong> Before we leave the fascinating world of Fibonacci numbers and how to compute them, let’s take a look at <em>Binet’s Formula</em>:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0071-01.jpg"/></div>&#13;
<p class="noindent">In this formula, the following is true:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0071-02.jpg"/></div>&#13;
<p class="noindent">This formula provides us with yet another way of computing <em>F</em><sub><em>n</em></sub>. The following applies to all <em>n</em>:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0071-03.jpg"/></div>&#13;
<p class="noindent">So the number <em>F</em><sub><em>n</em></sub> is the closest integer to <img alt="Image" src="../images/p071.jpg"/> Therefore, if we round to the nearest integer, <em>F</em><sub><em>n</em></sub> can be computed by the following:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0071-05.jpg"/></div>&#13;
<p class="noindent">The square brackets are used to designate the rounding function. In Racket, this becomes:</p>&#13;
<pre>(define (F n)&#13;
  (let* ([phi (/ (add1 (sqrt 5)) 2)]&#13;
         [phi^n (expt phi n)])&#13;
    (round (/ phi^n (sqrt 5)))))</pre>&#13;
<p class="indent">While Binet’s formula is quite fast (since it does not require looping or recursion), the downside is that it only gives an approximate answer, where the other versions give an exact value.</p>&#13;
<p class="indent"><strong>Continued Fractions.</strong> The expression below is an example of a <em>continued fraction</em>. In this case, the fractional portion is repeated indefinitely. As we shall see, continued fractions have a surprising relationship to the Fibonacci sequence.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0071-06.jpg"/></div>&#13;
<p class="noindent">Since the fraction does repeat infinitely, we may make the following substitution.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0072-01.jpg"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_72"/>This substitution simplifies to the quadratic equation:</p>&#13;
<p class="center"><em>f<sup>2</sup> - f</em> - 1 = 0</p>&#13;
<p class="noindent">That equation has a couple of solutions. This is true:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0072-02.jpg"/></div>&#13;
<p class="noindent">Or, these are true:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0072-03.jpg"/></div>&#13;
<p class="noindent">The question remains: which of these is the right value for <em>f</em>? Since <em>ψ</em> is negative, the answer must be <em>ϕ</em>. Thus . . .</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0072-04.jpg"/></div>&#13;
<p class="indent">Bet you didn’t see that coming.</p>&#13;
<h4 class="h4" id="ch00lev2sec_26"><strong><em>The Insurance Salesman Problem</em></strong></h4>&#13;
<p class="noindent">This problem is adapted from Flannery’s <em>In Code</em> [<strong>7</strong>]. It’s an example of a problem that could be solved by hand, but we can take advantage of Racket to do some of the tedious calculations. The problem is stated as follows.</p>&#13;
<p class="indent">A door-to-door insurance salesman stops at a woman’s house and the following dialog ensues:</p>&#13;
<div class="bq5">&#13;
<p class="noindent5">Salesman: How many children do you have?</p>&#13;
<p class="noindent5">Woman: Three.</p>&#13;
<p class="noindent5">Salesman: And what are their ages?</p>&#13;
<p class="noindent5">Woman: Take a guess.</p>&#13;
<p class="noindent5">Salesman: How about a hint?</p>&#13;
<p class="noindent5">Woman: Okay, the product of their ages is 36 and all the ages are whole numbers.</p>&#13;
<p class="noindent5">Salesman: That’s not much to go on. Can you give me another hint?</p>&#13;
<p class="noindent5">Woman: The sum of their ages is equal to the number on the house next door.</p>&#13;
<p class="noindent5">The salesman immediately runs off, jumps over the fence, looks at the number on the house next door, scratches his head, and goes back to the woman.</p>&#13;
<p class="noindent5">Salesman: Could you give me just one more hint?</p>&#13;
<p class="noindent5">Woman: The oldest one plays the piano.</p>&#13;
<p class="noindent5"><span epub:type="pagebreak" id="page_73"/>The salesman thinks for a bit, does some calculations, and figures out the children’s ages. What are they?</p>&#13;
</div>&#13;
<p class="indent">At first blush, the hints seem a bit incongruous. Let’s take them one at a time. First, we know that the product of the three ages is 36. Here is a program that generates all the unique combinations of three positive integers that have a product of 36.</p>&#13;
<pre>   #lang racket&#13;
   (require math/number-theory)&#13;
&#13;
<span class="ent">➊</span> (define triples '())&#13;
   (define (gen-triples d1)&#13;
  <span class="ent">➋</span> (let* ([q (/ 36 d1)]&#13;
            [divs (divisors q)])&#13;
     <span class="ent">➌</span> (define (try-div divs)&#13;
          (when (not (null? divs))&#13;
        <span class="ent">➍</span> (let* ([d2 (car divs)] [d3 (/ q d2)])&#13;
          <span class="ent">➎</span> (when (&lt;= d3 d2 d1)&#13;
            <span class="ent">➏</span> (set! triples (cons (list d3 d2 d1) triples)))&#13;
            (try-div (cdr divs)))))&#13;
      (try-div divs)))&#13;
&#13;
<span class="ent">➐</span> (for ([d (divisors 36)]) (gen-triples d))&#13;
&#13;
   triples</pre>&#13;
<p class="indent">While this code will not win any awards for efficiency, it is relatively simple and it gets the job done. We first define the variable <code>triples</code> which will contain the list of generated triples <span class="ent">➊</span>. The processing actually begins when we call <code>gen-triples</code> <span class="ent">➐</span> for each divisor of 36 (provided by the <code>divisors</code> function defined in the <em>math/number-theory</em> library). This function then defines the quotient <code>q</code> <span class="ent">➋</span> of the divisor <code>d1</code> into 36. Following this we generate a list of divisors of <code>q</code> (<code>divs</code>, which of course also divide 36). We now come to the function <code>try-div</code> <span class="ent">➌</span>, which does the bulk of the work. Then we get the first divisor (<code>d2</code>) of <code>q</code> <span class="ent">➍</span> and generate the third divisor (<code>d3</code>) by dividing <code>q</code> by <code>d2</code>. These divisors (<code>d1</code>, <code>d2</code>, and <code>d3</code>) are tested to see whether a satisfactory triple is formed (that is to ensure uniqueness, we make sure that they form an ordered sequence <span class="ent">➎</span>) . If so, it’s added to the list of triples <span class="ent">➏</span>. Testing other divisors resumes on the following line. Running this program produces the following sets of triples: {1, 1, 36}, {1, 2, 18}, {1, 3, 12}, {1, 4, 9}, {2, 2, 9}, {1, 6, 6}, {2, 3, 6}, {3, 3, 4}.</p>&#13;
<p class="indent">This alone, of course, does not allow the salesman to determine the ages of the children. The second hint is that the sum of the ages equals the number on the house next door. Again we make use of Racket to generate the required sums.</p>&#13;
<pre>(for ([triple triples]) (printf "~a: ~a\n" triple (apply + triple)))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_74"/>From this, we have the following.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0074.jpg"/></div>&#13;
<p class="indent">After looking at the number of the house next door, the salesman still does not know the ages. This means the ages must have been one of the two sets of numbers that sum to 13 (otherwise he would have known which set to select). Since the woman said “The oldest <em>one</em> plays the piano,” the only possibility is the set of ages <em>{</em>2, 2, 9<em>}</em>, since the set <em>{</em>1, 6, 6<em>}</em> would imply <em>two</em> oldest.</p>&#13;
<h3 class="h3" id="ch00lev1sec_23">Summary</h3>&#13;
<p class="noindent">In this chapter, we introduced Racket’s basic programming constructs and applied them to a variety of problem domains. So far our explorations have been confined to getting output in a textual form. Next, we will see how to add some bling to our applications by generating some graphical output.</p>&#13;
</body></html>