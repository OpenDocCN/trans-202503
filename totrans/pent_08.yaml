- en: Chapter 5. Information Gathering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we begin the information-gathering phase of penetration testing.
    The goal of this phase is to learn as much about our clients as we can. Does the
    CEO reveal way too much on Twitter? Is the system administrator writing to archived
    listservs, asking about how to secure a Drupal install? What software are their
    web servers running? Are the Internet-facing systems listening on more ports than
    they should? Or, if this is an internal penetration test, what is the IP address
    of the domain controller?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also start to interact with our target systems, learning as much as we
    can about them without actively attacking them. We’ll use the knowledge gained
    in this phase to move on to the threat-modeling phase where we think like attackers
    and develop plans of attack based on the information we’ve gathered. Based on
    the information we uncover, we’ll actively search for and verify vulnerabilities
    using vulnerability-scanning techniques, which are covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Open Source Intelligence Gathering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can learn a good deal about our client’s organization and infrastructure
    before we send a single packet their way, but information gathering can still
    be a bit of a moving target. It isn’t feasible to study the online life of every
    employee, and given a large amount of gathered information, it can be difficult
    to discern important data from noise. If the CEO tweets frequently about a favorite
    sports team, that team’s name may be the basis for her webmail password, but it
    could just as easily be entirely irrelevant. Other times it will be easier to
    pick up on something crucial. For instance, if your client has online job postings
    for a system administrator who is an expert in certain software, chances are those
    platforms are deployed in the client’s infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to intelligence gained from covert sources such as dumpster diving,
    dumping website databases, and social engineering, *open source intelligence*
    (or *OSINT*) is gathered from legal sources like public records and social media.
    The success of a pentest often depends on the results of the information-gathering
    phase, so in this section, we will look at a few tools to obtain interesting information
    from these public sources.
  prefs: []
  type: TYPE_NORMAL
- en: Netcraft
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes the information that web servers and web-hosting companies gather
    and make publicly available can tell you a lot about a website. For instance,
    a company called Netcraft logs the uptime and makes queries about the underlying
    software. (This information is made publicly available at *[http://www.netcraft.com/](http://www.netcraft.com/)*.)
    Netcraft also provides other services, and their antiphishing offerings are of
    particular interest to information security.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 5-1](ch05.xhtml#netcraftapostrophes_results_for_bulbsecu
    "Figure 5-1. Netcraft’s results for bulbsecurity.com") shows the result when we
    query *[http://www.netcraft.com/](http://www.netcraft.com/)* for *[http://www.bulbsecurity.com](http://www.bulbsecurity.com)*.
    As you can see, *bulbsecurity.com* was first seen in March 2012\. It was registered
    through GoDaddy, has an IP address of 50.63.212.1, and is running Linux with an
    Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this information, when pentesting *bulbsecurity.com*, we could start
    by ruling out vulnerabilities that affect only Microsoft IIS servers. Or, if we
    wanted to try social engineering to get credentials to the website, we could write
    an email that appears to be from GoDaddy, asking the administrator to log in and
    check some security settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Netcraft’s results for bulbsecurity.com](httpatomoreillycomsourcenostarchimages2030306.png.jpg)Figure 5-1. Netcraft’s
    results for bulbsecurity.com'
  prefs: []
  type: TYPE_NORMAL
- en: Whois Lookups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All domain registrars keep records of the domains they host. These records contain
    information about the owner, including contact information. For example, if we
    run the Whois command line tool on our Kali machine to query for information about
    *bulbsecurity.com*, as shown in [Example 5-1](ch05.xhtml#whois_information_for_bulbsecuritydotcom
    "Example 5-1. Whois information for bulbsecurity.com"), we see that I used private
    registration, so we won’t learn much.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1. Whois information for bulbsecurity.com
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This site has private registration, so both the registrant ❶ and technical contact
    ❷ are domains by proxy. Domains by proxy offer private registration, hiding your
    personal details in the Whois information for the domains you own. However, we
    do see the domain servers ❸ for *bulbsecurity.com*.
  prefs: []
  type: TYPE_NORMAL
- en: Running Whois queries against other domains will show more interesting results.
    For example, if you do a Whois lookup on *georgiaweidman.com*, you might get an
    interesting blast from the past, including my college phone number.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Reconnaissance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use Domain Name System (DNS) servers to learn more about a domain.
    DNS servers translate the human-readable URL *[www.bulbsecurity.com](http://www.bulbsecurity.com)*
    into an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Nslookup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For example, we could use a command line tool such as Nslookup, as shown in
    [Example 5-2](ch05.xhtml#nslookup_information_for_wwwdotbulbsecur "Example 5-2. Nslookup
    information for www.bulbsecurity.com").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2. Nslookup information for www.bulbsecurity.com
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Nslookup returned the IP address of *[www.bulbsecurity.com](http://www.bulbsecurity.com)*,
    as you can see at ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We can also tell Nslookup to find the mail servers for the same website by looking
    for MX records (DNS speak for email), as shown in [Example 5-3](ch05.xhtml#nslookup_information_for_bulbsecuritydot
    "Example 5-3. Nslookup information for bulbsecurity.com’s mail servers").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3. Nslookup information for bulbsecurity.com’s mail servers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Nslookup says *bulbsecurity.com* is using Google Mail for its email servers,
    which is correct because I use Google Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Host
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another utility for DNS queries is Host. We can ask Host for the name-servers
    for a domain with the command `host -t ns` *`domain`*. A good example for domain
    queries is *zoneedit.com*, a domain set up to demonstrate zone transfer vulnerabilities,
    as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This output shows us all the DNS servers for *zoneedit.com*. Naturally, because
    I mentioned that this domain was set up to demonstrate zone transfers, that’s
    what we are going to do next.
  prefs: []
  type: TYPE_NORMAL
- en: Zone Transfers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: DNS zone transfers allow name servers to replicate all the entries about a domain.
    When setting up DNS servers, you typically have a primary name server and a backup
    server. What better way to populate all the entries in the secondary DNS server
    than to query the primary server for all of its entries?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many system administrators set up DNS zone transfers insecurely,
    so that anyone can transfer the DNS records for a domain. *zoneedit.com* is an
    example of such a domain, and we can use the `host` command to download all of
    its DNS records. Use the `-l` option to specify the domain to transfer, and choose
    one of the name servers from the previous command, as shown in [Example 5-4](ch05.xhtml#zone_transfer_of_zoneeditdotcom
    "Example 5-4. Zone transfer of zoneedit.com").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4. Zone transfer of zoneedit.com
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are pages and pages of DNS entries for *zoneedit.com*, which gives us
    a good idea of where to start in looking for vulnerabilities for our pentest.
    For example, *mail2.zoneedit.com* is probably a mail server, so we should look
    for potentially vulnerable software running on typical email ports such as 25
    (Simple Mail Transfer Protocol) and 110 (POP3). If we can find a webmail server,
    any usernames we find may lead us in the right direction so that we can guess
    passwords and gain access to sensitive company emails.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Email Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: External penetration tests often find fewer services exposed than internal ones
    do. A good security practice is to expose only those services that must be accessed
    remotely, like web servers, mail servers, VPN servers, and maybe SSH or FTP, and
    only those services that are mission critical. Services like these are common
    attack surfaces, and unless employees use two-factor authentication, accessing
    company webmail can be simple if an attacker can guess valid credentials.
  prefs: []
  type: TYPE_NORMAL
- en: One excellent way to find usernames is by looking for email addresses on the
    Internet. You might be surprised to find corporate email addresses publicly listed
    on parent-teacher association contact info, sports team rosters, and, of course,
    social media.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a Python tool called theHarvester to quickly scour thousands of
    search engine results for possible email addresses. theHarvester can automate
    searching Google, Bing, PGP, LinkedIn, and others for email addresses. For example,
    in [Example 5-5](ch05.xhtml#running_theharvester_against_bulbsecurit "Example 5-5. Running
    theHarvester against bulbsecurity.com"), we’ll look at the first 500 results in
    all search engines for *bulbsecurity.com*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5. Running theHarvester against bulbsecurity.com
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There’s not too much to be found for *bulbsecurity.com*, but theHarvester does
    find my email address, *georgia@bulbsecurity.com*, and the website, *[www.bulbsecurity.com](http://www.bulbsecurity.com)*,
    as well as other websites I share virtual hosting with. You may find more results
    if you run theHarvester against your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Maltego
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Paterva’s Maltego is a data-mining tool designed to visualize open source intelligence
    gathering. Maltego has both a commercial and a free community edition. The free
    Kali Linux version, which we’ll use in this book, limits the results it returns,
    but we can still use it to gather a good deal of interesting information very
    quickly. (The paid version offers more results and functionality. To use Maltego
    on your pentests, you will need a paid license.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feel free to use Maltego to study other Internet footprints, including your
    own, your company’s, your high school arch nemesis’s, and so on. Maltego uses
    information publicly available on the Internet, so it is perfectly legal to do
    reconnaissance on any entity.
  prefs: []
  type: TYPE_NORMAL
- en: To run Maltego, enter **`maltego`** at the command line. The Maltego GUI should
    launch. You will be prompted to create a free account at the Paterva website and
    log in. Once logged in, choose **Open a blank graph and let me play around**,
    and then click **Finish**, as shown in [Figure 5-2](ch05.xhtml#opening_a_new_maltego_graph
    "Figure 5-2. Opening a new Maltego graph").
  prefs: []
  type: TYPE_NORMAL
- en: '![Opening a new Maltego graph](httpatomoreillycomsourcenostarchimages2030308.png.jpg)Figure 5-2. Opening
    a new Maltego graph'
  prefs: []
  type: TYPE_NORMAL
- en: Now select the **Palette** option from the left-hand border. As you can see,
    we can gather information about all sorts of entities.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the *bulbsecurity.com* domain, as shown in [Figure 5-3](ch05.xhtml#adding_an_entity_to_the_graph
    "Figure 5-3. Adding an entity to the graph"). Expand the Infrastructure option
    from the Palette (on the left of the Maltego window) and drag a Domain entity
    from the Palette onto the new graph. By default, the domain is *paterva.com*.
    To change it to *bulbsecurity.com*, either double-click the text or change the
    text field at the right side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an entity to the graph](httpatomoreillycomsourcenostarchimages2030310.png.jpg)Figure 5-3. Adding
    an entity to the graph'
  prefs: []
  type: TYPE_NORMAL
- en: Once the domain is set, you can run transforms (Maltego-speak for queries) on
    it, instructing Maltego to search for interesting information. Let’s start with
    a couple of simple transforms, which you can view by right-clicking the domain
    icon and choosing **Run Transform**, as shown in [Figure 5-4](ch05.xhtml#maltego_transforms
    "Figure 5-4. Maltego transforms").
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, we can see all the transforms available for a domain entity.
    As you work with different entities, different transform options will be available.
    Let’s find the MX records for the *bulbsecurity.com* domain and, thus, where the
    mail servers are. Under **All Transforms**, choose the **To DNS Name – MX (mail
    server)** transform.
  prefs: []
  type: TYPE_NORMAL
- en: As expected from our previous research, Maltego returns Google Mail servers,
    indicating that *bulbsecurity.com* uses Google Apps for email. We can run the
    simple **To Website [Quick lookup]** transform to get the website address of *bulbsecurity.com*.
    See [Figure 5-5](ch05.xhtml#transform_results "Figure 5-5. Transform results")
    for the results from both this and the previous transform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Maltego transforms](httpatomoreillycomsourcenostarchimages2030312.png.jpg)Figure 5-4. Maltego
    transforms![Transform results](httpatomoreillycomsourcenostarchimages2030314.png.jpg)Figure 5-5. Transform
    results'
  prefs: []
  type: TYPE_NORMAL
- en: Maltego correctly finds *[www.bulbsecurity.com](http://www.bulbsecurity.com)*.
    Attacking the Google Mail servers will likely be out of the scope of any pentest,
    but more infor-mation on the *[www.bulbsecurity.com](http://www.bulbsecurity.com)*
    website would certainly be useful. We can run transforms on any entity on the
    graph, so select the website *[www.bulbsecurity.com](http://www.bulbsecurity.com)*
    to gather data on it. For instance, we can run the transform **ToServerTechnologiesWebsite**
    to see what software *[www.bulbsecurity.com](http://www.bulbsecurity.com)* is
    running, as shown in [Figure 5-6](ch05.xhtml#wwwdotbulbsecuritydotcom_software
    "Figure 5-6. www.bulbsecurity.com software").
  prefs: []
  type: TYPE_NORMAL
- en: '![www.bulbsecurity.com software](httpatomoreillycomsourcenostarchimages2030316.png.jpg)Figure 5-6. [www.bulbsecurity.com](http://www.bulbsecurity.com)
    software'
  prefs: []
  type: TYPE_NORMAL
- en: Maltego finds that *[www.bulbsecurity.com](http://www.bulbsecurity.com)* is
    an Apache web server with PHP, Flash, and so on, along with a WordPress install.
    WordPress, a commonly used blogging platform, has a long history of security issues
    (like a lot of software). We’ll look at exploiting website vulnerabilities in
    [Chapter 14](ch14.xhtml "Chapter 14. Web Application Testing"). (Let’s hope I
    am keeping my WordPress blog up to date, or else I might wake up to find my site
    defaced one day. How embarrassing!)
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional information and tutorials about Maltego at *[http://www.paterva.com/](http://www.paterva.com/)*.
    Spend some time using Maltego transforms to find interesting information about
    your organization. In skilled hands, Maltego can turn hours of reconnaissance
    work into minutes with the same quality results.
  prefs: []
  type: TYPE_NORMAL
- en: Port Scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you start a pentest, the potential scope is practically limitless. The
    client could be running any number of programs with security issues: They could
    have misconfiguration issues in their infrastructure that could lead to compromise;
    weak or default passwords could give up the keys to the kingdom on otherwise secure
    systems; and so on. Pentests often narrow your scope to a particular IP range
    and nothing more, and you won’t help your client by developing a working exploit
    for the latest and greatest server-side vulnerability if they don’t use the vulnerable
    software. We need to find out which systems are active and which software we can
    talk to.'
  prefs: []
  type: TYPE_NORMAL
- en: Manual Port Scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For example, in the previous chapter we saw that exploiting the MS08-067 vulnerability
    can be an easy win for attackers and pentesters alike. To use this exploit, we
    need to find a Windows 2000, XP, or 2003 box with an SMB server that is missing
    the MS08-067 Microsoft patch available on the network. We can get a good idea
    about the network-based attack surface by mapping the network range and querying
    systems for listening ports.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this manually by connecting to ports with a tool such as telnet or
    Netcat and recording the results. Let’s use Netcat to connect to the Windows XP
    machine on port 25, the default port for the Simple Mail Transfer Protocol (SMTP).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As it turns out, the Windows XP box is running an SMTP server on port 25 ❶.
    After we connected, the SMTP server announced itself as `SLMail -version 5.5.0.4433`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, keep in mind that admins can change banners like this to say anything,
    even sending attackers and pentesters on a wild goose chase, studying vulnerabilities
    for a product that is not deployed. In most cases, however, versions in software
    banners will be fairly accurate, and just connecting to the port and viewing the
    banner provides a starting point for our pentesting research. Searching the Web
    for information about `SLMail version 5.5.0.4433` may yield some interesting results.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, connecting to every possible TCP and UDP port on just one
    machine and noting the results can be time consuming. Luckily, computers are excellent
    at repetitive tasks like this, and we can use port-scanning tools such as Nmap
    to find listening ports for us.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything we have done so far in this chapter is completely legal. But once
    we start actively querying systems, we are moving into murky legal territory.
    Attempting to break into computers without permission is, of course, illegal in
    many countries. Though stealthy scan traffic may go unnoticed, you should practice
    the skills we study in the rest of this chapter (and the rest of this book) only
    on your target virtual machines or other systems you own or have written permission
    to test (known in the trade as a get-out-of-jail-free card).
  prefs: []
  type: TYPE_NORMAL
- en: Port Scanning with Nmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nmap is an industry standard for port scanning. Entire books have been written
    just about using Nmap, and the manual page may seem a bit daunting. We will cover
    the basics of port scanning here and come back to the tool in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Firewalls with intrusion-detection and prevention systems have made great strides
    in detecting and blocking scan traffic, so you might run an Nmap scan and receive
    no results at all. Though you could be hired to perform an external pentest against
    a network range with no live hosts, it’s more likely that you’re being blocked
    by a firewall. On the other hand, your Nmap results might instead say that every
    host is alive, and will be listening on every port if your scan is detected.
  prefs: []
  type: TYPE_NORMAL
- en: A SYN Scan
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start by running a SYN scan against our target machines. A *SYN scan*
    is a TCP scan that does not finish the TCP handshake. A TCP connection starts
    with a three-way handshake: SYN ▸ SYN-ACK ▸ ACK, as shown in [Figure 5-7](ch05.xhtml#tcp_three-way_handshake
    "Figure 5-7. TCP three-way handshake").'
  prefs: []
  type: TYPE_NORMAL
- en: '![TCP three-way handshake](httpatomoreillycomsourcenostarchimages2030318.png.jpg)Figure 5-7. TCP
    three-way handshake'
  prefs: []
  type: TYPE_NORMAL
- en: In a SYN scan, Nmap sends the SYN and waits for the SYN-ACK if the port is open
    but never sends the ACK to complete the connection. If the SYN packet receives
    no SYN-ACK response, the port is not available; either it’s closed or the connection
    is being filtered. This way, Nmap finds out if a port is open without ever fully
    connecting to the target machine. The syntax for a SYN scan is the `-sS` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, as you can see in [Example 5-6](ch05.xhtml#running_an_nmap_syn_scan "Example 5-6. Running
    an Nmap SYN scan"), we specify the IP address(s) or range to scan. Finally, we
    use the `-o` option to output our Nmap results to a file. The `-oA` option tells
    Nmap to log our results in all formats: *.nmap*, *.gnmap* (greppable Nmap), and
    XML. Nmap format, like the output that Nmap prints to the screen in [Example 5-6](ch05.xhtml#running_an_nmap_syn_scan
    "Example 5-6. Running an Nmap SYN scan"), is nicely formatted and easy to read.
    Greppable Nmap (as the name implies) is formatted to be used with the `grep` utility
    to search for specific information. XML format is a standard used to import Nmap
    results into other tools. [Example 5-6](ch05.xhtml#running_an_nmap_syn_scan "Example 5-6. Running
    an Nmap SYN scan") shows the results of the SYN scan.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good idea to take good notes of everything we do on our pentest.
    Tools such as Dradis are designed specifically to track pentest data, but as long
    as you have notes of everything you did when you get to the reporting phase, you
    will be okay. I personally am more of a pen-and-paper user, or at best, a creating-a-long-Word-document-with-all-of-my-results
    type. The methods used for tracking results vary from pentester to pentester.
    Outputting your Nmap results to files is a good way to make sure you have a record
    of your scan. Also, you can use the Linux command script to record everything
    printed to your terminal—another good way to keep track of everything you have
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6. Running an Nmap SYN scan
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Nmap returns a handful of ports on the Windows XP and Linux
    boxes. We will see as we move through the next few chapters that nearly all of
    these ports contain vulnerabilities. Hopefully, that won’t be the case on your
    pentests, but in an attempt to introduce you to many types of vulnerabilities
    you will encounter in the field, our pentesting lab has been condensed into these
    three machines.
  prefs: []
  type: TYPE_NORMAL
- en: That said, just because a port is open does not mean that vulnerabilities are
    present. Rather it leaves us with the possibility that vulnerable software might
    be running on these ports. Our Windows 7 machine is listening only on port 80
    ❶, the traditional port for HTTP web servers, and port 139 for remote procedure
    call. There may be exploitable software listening on ports that are not allowed
    through the Windows firewall, and there may be vulnerable software running locally
    on the machine, but at the moment we can’t attempt to exploit anything directly
    over the network except the web server.
  prefs: []
  type: TYPE_NORMAL
- en: This basic Nmap scan has already helped us focus our pentesting efforts. Both
    the Windows XP and Linux targets are running FTP servers ❷, web servers ❸, and
    SMB servers ❹. The Windows XP machine is also running a mail server that has opened
    several ports ❺ and a MySQL server ❻.
  prefs: []
  type: TYPE_NORMAL
- en: A Version Scan
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our SYN scan was stealthy, but it didn’t tell us much about the software that
    is actually running on the listening ports. Compared to the detailed version information
    we got by connecting to port 25 with Netcat, the SYN scan’s results are a bit
    lackluster. We can use a full TCP scan (`nmap -sT`) or go a step further and use
    Nmap’s version scan (`nmap -sV`) to get more data. With the version scan shown
    in [Example 5-7](ch05.xhtml#running_an_nmap_version_scan "Example 5-7. Running
    an Nmap version scan"), Nmap completes the connection and then attempts to determine
    what software is running and, if possible, the version, using techniques such
    as banner grabbing.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7. Running an Nmap version scan
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This time we gained much more information about our Windows XP and Linux targets.
    For example, we knew there was an FTP server on the Linux box, but now we have
    reasonable assurance that the FTP server is Very Secure FTP version 2.3.4 ❶. We’ll
    use this output to search for potential vulnerabilities in the next chapter. As
    for our Windows 7 system, we found out only that it’s running Microsoft IIS 7.5,
    a fairly up-to-date version. It’s possible to install IIS 8 on Windows 7, but
    it’s not officially supported. The version itself would not raise any red flags
    to me. We will find that the application installed on this IIS server is the real
    issue in [Chapter 14](ch14.xhtml "Chapter 14. Web Application Testing").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that Nmap may report the wrong version in some cases (for instance,
    if the software has been updated, but the welcome banner is not edited as part
    of the patch), but at the very least, its version scan gave us a good place to
    begin further research.
  prefs: []
  type: TYPE_NORMAL
- en: UDP Scans
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both Nmap’s SYN and version scans are TCP scans that do not query UDP ports.
    Because UDP is connectionless, the scanning logic is a bit different. In a UDP
    scan (`-sU`), Nmap sends a UDP packet to a port. Depending on the port, the packet
    sent is protocol specific. If it receives a response, the port is considered open.
    If the port is closed, Nmap will receive an ICMP Port Unreachable message. If
    Nmap receives no response whatsoever, then either the port is open and the program
    listening does not respond to Nmap’s query, or the traffic is being filtered.
    Thus, Nmap is not always able to distinguish between an open UDP port and one
    that is filtered by a firewall. See [Example 5-8](ch05.xhtml#running_a_udp_scan
    "Example 5-8. Running a UDP scan") for a UDP scan example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8. Running a UDP scan
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For example, on the Windows XP system, the TFTP port (UDP 69) may be open or
    filtered ❶. On the Linux target, Nmap was able to glean that the Network File
    System port is listening ❷. Because only two TCP ports responded on the Windows
    7 box, it’s fair to assume that a firewall is in place, in this case the built-in
    Windows firewall. Likewise, the Windows firewall is filtering all traffic except
    to one UDP port. (If the Windows firewall were not in place, our UDP scan might
    give us more information.)
  prefs: []
  type: TYPE_NORMAL
- en: Scanning a Specific Port
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, Nmap scans only the 1,000 ports it considers the most “interesting,”
    not the 65,535 possible TCP or UDP ports. The default Nmap scan will catch common
    running services, but in some cases it will miss a listening port or two. To scan
    specific ports, use the `-p` flag with Nmap. For example, to scan port 3232 on
    the Windows XP target, see [Example 5-9](ch05.xhtml#running_an_nmap_scan_on_a_specific_port
    "Example 5-9. Running an Nmap scan on a specific port").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9. Running an Nmap scan on a specific port
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, when we tell Nmap to scan 3232, it returns `open`, which shows
    that this port is worth checking out, in addition to the default Nmap scanned
    ports. However, if we try to probe the port a bit more aggressively with a version
    scan (see [Example 5-10](ch05.xhtml#running_a_version_scan_against_a_specifi "Example 5-10. Running
    a version scan against a specific port")), the service listening on the port crashes,
    as shown in [Figure 5-8](ch05.xhtml#zervit_server_crashes_when_scanned_by_nm "Figure 5-8. The
    Zervit server crashes when scanned by Nmap.").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good rule of thumb is to specify ports 1 through 65535 on your pentests, just
    to make sure there’s nothing listening on those other “uninteresting” ports.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10. Running a version scan against a specific port
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![The Zervit server crashes when scanned by Nmap.](httpatomoreillycomsourcenostarchimages2030320.png.jpg)Figure 5-8. The
    Zervit server crashes when scanned by Nmap.'
  prefs: []
  type: TYPE_NORMAL
- en: In the process of crashing the listening service, Nmap can’t figure out what
    software is running as noted at ❶, but it does manage to get a fingerprint of
    the service. Based on the HTML tags in the fingerprint at ❷, this service appears
    to be a web server. According to the `Server:` field, it is something called Zervit
    0.4 ❸.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have crashed the service, and we may never see it again on
    our pentest, so any potential vulnerabilities may be a moot point. Of course,
    in our lab we can just switch over to our Windows XP target and restart the Zervit
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though hopefully you won’t make any services crash on your pentests, there is
    always a possibility that you will run into a particularly sensitive service that
    was not coded to accept anything other than expected input, such that even seemingly
    benign traffic like an Nmap scan causes it to crash. SCADA systems are particularly
    notorious for this sort of behavior. You always want to explain this to your client.
    When working with computers, there are no guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to the Nmap tool in the next chapter when we use the Nmap Scripting
    Engine (NSE) to learn detailed vulnerability information about our target systems
    before beginning exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ve managed to cover a lot of ground very quickly just by
    using publicly available sources and port scanners. We used tools such as theHarvester
    and Maltego to scour the Internet for information such as email addresses and
    websites. We used the Nmap port scanner to find out which ports are listening
    on our target virtual machines. Based on the output we’ve discovered, we can now
    do some research on known vulnerabilities as we start to think like attackers
    and actively seek exploitable vulnerabilities in the systems. In the next chapter,
    we’ll cover the vulnerability analysis phase of penetration testing.
  prefs: []
  type: TYPE_NORMAL
