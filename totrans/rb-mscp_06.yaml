- en: Chapter 6. Method Lookup and Constant Lookup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。方法查找与常量查找
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Inside of Ruby, modules are classes.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在Ruby内部，模块是类。*'
- en: As we saw in [Chapter 5](ch05.html "Chapter 5. Objects and Classes"), classes
    play an important role in Ruby, holding method definitions and constant values,
    among other things. We also learned how Ruby implements inheritance using the
    `super` pointer in each `RClass` structure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](ch05.html "第5章。对象和类")中看到的，类在Ruby中扮演着重要角色，保存方法定义和常量值等内容。我们还学习了Ruby是如何通过每个`RClass`结构中的`super`指针实现继承的。
- en: In fact, as your program grows, you might imagine it organized by class and
    superclass, creating a kind of giant tree structure. At the base is the `Object`
    class (or, actually, the internal `BasicObject` class). This class is Ruby’s default
    superclass, and all of your classes appear somewhere higher up in the tree, branching
    out in different directions. In this chapter we’ll study how Ruby uses this superclass
    tree to look up methods. When you write code that calls a method, Ruby looks through
    this tree in a very precise manner. We’ll step through a concrete example to see
    the method lookup process in action.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，随着程序的增长，你可以想象它是按类和父类组织的，形成一种巨大的树形结构。底部是`Object`类（或者，实际上是内部的`BasicObject`类）。这个类是Ruby的默认父类，你所有的类都会出现在树的某个更高的地方，向不同的方向分支。在本章中，我们将学习Ruby是如何利用这个父类树来查找方法的。当你编写调用方法的代码时，Ruby会以非常精确的方式在这棵树中查找。我们将通过一个具体的例子来演示方法查找过程。
- en: Later in this chapter we’ll learn another way to visualize your Ruby code. Every
    time you create a new class or module, Ruby adds a new scope to a different tree,
    a tree based on the syntactical structure of your program. The trunk of this tree
    is the top-level scope, or the beginning of your Ruby code file where you start
    typing. As you define more and more highly nested modules and classes, this tree
    would grow higher and higher as well. We’ll learn how this syntax, or namespace,
    tree allows Ruby to find constant definitions, just as the superclass tree allows
    Ruby to find methods.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将学习另一种方式来可视化你的Ruby代码。每次你创建一个新的类或模块时，Ruby会向一个不同的树中添加一个新的作用域，这棵树是基于你程序的语法结构的。这棵树的主干是顶级作用域，也就是你开始编写Ruby代码文件的地方。随着你定义越来越多的嵌套模块和类，这棵树也会不断变得更高。我们将学习如何通过这个语法或命名空间树，Ruby能够找到常量定义，就像父类树帮助Ruby找到方法一样。
- en: But before we get to method and constant lookup, let’s get started with a look
    at Ruby modules. What are modules? How are they different from classes? What happens
    when you include a module into a class?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入方法和常量查找之前，让我们先来看一下Ruby模块。什么是模块？它们与类有何不同？当你将模块包含进类时会发生什么？
- en: Roadmap
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[How Ruby Implements Modules](ch06.html#how_ruby_implements_modules "How Ruby
    Implements Modules")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby是如何实现模块的](ch06.html#how_ruby_implements_modules "Ruby是如何实现模块的")'
- en: '[Modules Are Classes](ch06.html#modules_are_classes "Modules Are Classes")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模块是类](ch06.html#modules_are_classes "模块是类")'
- en: '[Including a Module into a Class](ch06.html#including_a_module_into_a_class
    "Including a Module into a Class")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将模块包含进类中](ch06.html#including_a_module_into_a_class "将模块包含进类中")'
- en: '[Ruby’s Method Lookup Algorithm](ch06.html#rubyapostrophes_method_lookup_algorithm
    "Ruby’s Method Lookup Algorithm")'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby的方法查找算法](ch06.html#rubyapostrophes_method_lookup_algorithm "Ruby的方法查找算法")'
- en: '[A Method Lookup Example](ch06.html#method_lookup_example "A Method Lookup
    Example")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方法查找示例](ch06.html#method_lookup_example "方法查找示例")'
- en: '[The Method Lookup Algorithm in Action](ch06.html#method_lookup_algorithm_in_action
    "The Method Lookup Algorithm in Action")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方法查找算法实践](ch06.html#method_lookup_algorithm_in_action "方法查找算法实践")'
- en: '[Multiple Inheritance in Ruby](ch06.html#multiple_inheritance_in_ruby "Multiple
    Inheritance in Ruby")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby中的多重继承](ch06.html#multiple_inheritance_in_ruby "Ruby中的多重继承")'
- en: '[The Global Method Cache](ch06.html#global_method_cache "The Global Method
    Cache")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[全局方法缓存](ch06.html#global_method_cache "全局方法缓存")'
- en: '[The Inline Method Cache](ch06.html#inline_method_cache "The Inline Method
    Cache")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内联方法缓存](ch06.html#inline_method_cache "内联方法缓存")'
- en: '[Clearing Ruby’s Method Caches](ch06.html#clearing_rubyapostrophes_method_caches
    "Clearing Ruby’s Method Caches")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[清除Ruby的方法缓存](ch06.html#clearing_rubyapostrophes_method_caches "清除Ruby的方法缓存")'
- en: '[Including Two Modules into One Class](ch06.html#including_two_modules_into_one_class
    "Including Two Modules into One Class")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将两个模块包含进一个类中](ch06.html#including_two_modules_into_one_class "将两个模块包含进一个类中")'
- en: '[Including One Module into Another](ch06.html#including_one_module_into_another
    "Including One Module into Another")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将一个模块包含到另一个模块中](ch06.html#including_one_module_into_another "将一个模块包含到另一个模块中")'
- en: '[A Module#prepend Example](ch06.html#modulehashprepend_example "A Module#prepend
    Example")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Module#prepend 示例](ch06.html#modulehashprepend_example "Module#prepend 示例")'
- en: '[How Ruby Implements Module#prepend](ch06.html#how_ruby_implements_modulehashprepend
    "How Ruby Implements Module#prepend")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何 Ruby 实现 Module#prepend](ch06.html#how_ruby_implements_modulehashprepend
    "如何 Ruby 实现 Module#prepend")'
- en: '**[Experiment 6-1: Modifying a Module After Including It](ch06.html#experiment_6-1_modifying_a_module_after
    "Experiment 6-1: Modifying a Module After Including It")**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 6-1：在包含模块后修改模块](ch06.html#experiment_6-1_modifying_a_module_after "实验
    6-1：在包含模块后修改模块")**'
- en: '[Classes See Methods Added to a Module Later](ch06.html#classes_see_methods_added_to_a_module_la
    "Classes See Methods Added to a Module Later")'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类看到后来添加到模块中的方法](ch06.html#classes_see_methods_added_to_a_module_la "类看到后来添加到模块中的方法")'
- en: '[Classes Don’t See Submodules Included Later](ch06.html#classes_donapostrophet_see_submodules_in
    "Classes Don’t See Submodules Included Later")'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类看不见后加入的子模块](ch06.html#classes_donapostrophet_see_submodules_in "类看不见后加入的子模块")'
- en: '[Included Classes Share the Method Table with the Original Module](ch06.html#included_classes_share_the_method_table
    "Included Classes Share the Method Table with the Original Module")'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[包含的类与原始模块共享方法表](ch06.html#included_classes_share_the_method_table "包含的类与原始模块共享方法表")'
- en: '[A Close Look at How Ruby Copies Modules](ch06.html#close_look_at_how_ruby_copies_modules
    "A Close Look at How Ruby Copies Modules")'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[深入了解 Ruby 如何复制模块](ch06.html#close_look_at_how_ruby_copies_modules "深入了解 Ruby
    如何复制模块")'
- en: '[Constant Lookup](ch06.html#constant_lookup "Constant Lookup")'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[常量查找](ch06.html#constant_lookup "常量查找")'
- en: '[Finding a Constant in a Superclass](ch06.html#finding_a_constant_in_a_superclass
    "Finding a Constant in a Superclass")'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在超类中查找常量](ch06.html#finding_a_constant_in_a_superclass "在超类中查找常量")'
- en: '[How Does Ruby Find a Constant in the Parent Namespace?](ch06.html#how_does_ruby_find_a_constant_in_the_par
    "How Does Ruby Find a Constant in the Parent Namespace?")'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何在父命名空间中查找常量？](ch06.html#how_does_ruby_find_a_constant_in_the_par "Ruby
    如何在父命名空间中查找常量？")'
- en: '[Lexical Scope in Ruby](ch06.html#lexical_scope_in_ruby "Lexical Scope in Ruby")'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 中的词法作用域](ch06.html#lexical_scope_in_ruby "Ruby 中的词法作用域")'
- en: '[Creating a Constant for a New Class or Module](ch06.html#creating_a_constant_for_a_new_class_or_m
    "Creating a Constant for a New Class or Module")'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为新类或模块创建常量](ch06.html#creating_a_constant_for_a_new_class_or_m "为新类或模块创建常量")'
- en: '[Finding a Constant in the Parent Namespace Using Lexical Scope](ch06.html#finding_a_constant_in_the_parent_namespa
    "Finding a Constant in the Parent Namespace Using Lexical Scope")'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用词法作用域在父命名空间中查找常量](ch06.html#finding_a_constant_in_the_parent_namespa "使用词法作用域在父命名空间中查找常量")'
- en: '[Ruby’s Constant Lookup Algorithm](ch06.html#rubyapostrophes_constant_lookup_algorith
    "Ruby’s Constant Lookup Algorithm")'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 的常量查找算法](ch06.html#rubyapostrophes_constant_lookup_algorith "Ruby 的常量查找算法")'
- en: '**[Experiment 6-2: Which Constant Will Ruby Find First?](ch06.html#experiment_6-2_which_constant_will_ruby
    "Experiment 6-2: Which Constant Will Ruby Find First?")**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 6-2：Ruby 首先找到哪个常量？](ch06.html#experiment_6-2_which_constant_will_ruby
    "实验 6-2：Ruby 首先找到哪个常量？")**'
- en: '[Ruby’s Actual Constant Lookup Algorithm](ch06.html#rubyapostrophes_actual_constant_lookup_a
    "Ruby’s Actual Constant Lookup Algorithm")'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 的实际常量查找算法](ch06.html#rubyapostrophes_actual_constant_lookup_a "Ruby 的实际常量查找算法")'
- en: '[Summary](ch06.html#summary-id00023 "Summary")'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch06.html#summary-id00023 "总结")'
- en: How Ruby Implements Modules
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 如何实现模块
- en: 'As you may know, modules are very similar to classes in Ruby. You can create
    a module just as you create a class—by typing the `module` keyword followed by
    a series of method definitions. But while modules are similar to classes, they
    are handled differently by Ruby in three important ways:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，模块在 Ruby 中与类非常相似。你可以像创建类一样创建模块——通过输入 `module` 关键字，然后定义一系列方法。但尽管模块和类相似，它们在
    Ruby 中的处理方式有三点重要的不同：
- en: Ruby doesn’t allow you to create objects directly from modules. In practice
    this means that you can’t call the `new` method on a module because `new` is a
    method of `Class`, not of `Module`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 不允许你直接从模块创建对象。实际上，这意味着你不能在模块上调用 `new` 方法，因为 `new` 是 `Class` 的方法，而不是 `Module`
    的方法。
- en: Ruby doesn’t allow you to specify a superclass for a module.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 不允许为模块指定一个超类。
- en: In addition, you can include a module into a class using the `include` keyword.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你可以使用 `include` 关键字将模块包含到类中。
- en: But what are modules exactly? How does Ruby represent them internally? Does
    it use an `RModule` structure? And what does it mean to “include” a module into
    a class?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么模块到底是什么？Ruby是如何在内部表示它们的？它使用`RModule`结构吗？将模块“包含”到类中意味着什么？
- en: Modules Are Classes
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块即类
- en: As it turns out, internally Ruby implements modules as classes. When you create
    a module, Ruby creates another `RClass`/`rb_classext_struct` structure pair, just
    as it would for a new class. For example, suppose we define a new module like
    this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，在内部Ruby将模块实现为类。当你创建一个模块时，Ruby会为该模块创建一个新的`RClass`/`rb_classext_struct`结构对，就像它为一个新类创建一样。例如，假设我们像这样定义一个新的模块。
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Internally, Ruby would create a class, not a module! [Figure 6-1](ch06.html#portion_of_rubyapostrophes_class_str
    "Figure 6-1. The portion of Ruby’s class structures that’s used for modules")
    shows how Ruby represents a module internally.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Ruby会创建一个类，而不是一个模块！[图6-1](ch06.html#portion_of_rubyapostrophes_class_str
    "图6-1. Ruby类结构中用于模块的部分")展示了Ruby如何在内部表示模块。
- en: '![The portion of Ruby’s class structures that’s used for modules](httpatomoreillycomsourcenostarchimages1854087.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby类结构中用于模块的部分](httpatomoreillycomsourcenostarchimages1854087.png.jpg)'
- en: Figure 6-1. The portion of Ruby’s class structures that’s used for modules
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. Ruby类结构中用于模块的部分
- en: In this figure I show Ruby’s `RClass` structure again. However, I’ve removed
    some of the values from the diagram because modules don’t use all of them. Most
    importantly, I removed `iv_index_tbl` because you can’t create object instances
    of a module—in other words, you can’t call the `new` method on a module. This
    means there are no object-level attributes to keep track of. I also removed the
    `refined_class` and `allocator` values because modules don’t use them either.
    I’ve left the `super` pointer because modules do have superclasses internally
    even though you aren’t allowed to specify them yourself.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我再次展示了Ruby的`RClass`结构。然而，我从图表中移除了一些值，因为模块并不使用它们。最重要的是，我移除了`iv_index_tbl`，因为你不能为模块创建对象实例——换句话说，你不能在模块上调用`new`方法。这意味着没有对象级别的属性需要跟踪。我还移除了`refined_class`和`allocator`值，因为模块也不使用它们。我保留了`super`指针，因为模块确实有内部的超类，尽管你不能自行指定它们。
- en: 'A technical definition of a Ruby module (ignoring the `origin` value for now)
    might look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby模块的技术定义（暂时忽略`origin`值）可能如下所示：
- en: A Ruby module is a Ruby object that also contains method definitions, a superclass
    pointer, and a constants table.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ruby模块是一个Ruby对象，它还包含方法定义、一个超类指针和一个常量表。
- en: Including a Module into a Class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模块包含到类中
- en: The real magic behind modules happens when you include a module into a class,
    as shown in [Example 6-1](ch06.html#including_a_module_into_a_class-id00019 "Example 6-1. Including
    a module into a class").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块背后的真正魔力发生在你将模块包含到类中时，如[示例6-1](ch06.html#including_a_module_into_a_class-id00019
    "示例6-1. 将模块包含到类中")所示。
- en: Example 6-1. Including a module into a class
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-1. 将模块包含到类中
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we run [Example 6-1](ch06.html#including_a_module_into_a_class-id00019
    "Example 6-1. Including a module into a class"), Ruby creates a copy of the `RClass`
    structure for the `Professor` module and uses it as the new superclass for `Mathematician`.
    Ruby’s C source code refers to this copy of the module as an *included class*.
    The superclass of the new copy of `Professor` is set to the original superclass
    of `Mathematician`, which preserves the superclass, or ancestor chain. [Figure 6-2](ch06.html#including_a_module_into_a_class-id00020
    "Figure 6-2. Including a module into a class") summarizes this somewhat confusing
    state of affairs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行[示例6-1](ch06.html#including_a_module_into_a_class-id00019 "示例6-1. 将模块包含到类中")时，Ruby为`Professor`模块创建了一个`RClass`结构的副本，并将其作为`Mathematician`的新的超类。Ruby的C源代码将这个模块的副本称为*包含类*。新副本的`Professor`的超类被设置为`Mathematician`原始超类，这样可以保持超类或祖先链。[图6-2](ch06.html#including_a_module_into_a_class-id00020
    "图6-2. 将模块包含到类中")总结了这一有些令人困惑的情况。
- en: '![Including a module into a class](httpatomoreillycomsourcenostarchimages1854089.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![将模块包含到类中](httpatomoreillycomsourcenostarchimages1854089.png.jpg)'
- en: Figure 6-2. Including a module into a class
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2. 将模块包含到类中
- en: 'You can see the `Mathematician` class at the top-left corner of [Figure 6-2](ch06.html#including_a_module_into_a_class-id00020
    "Figure 6-2. Including a module into a class"). Below it and along the left side,
    you see its superclass chain: `Mathematician`’s superclass is `Person`, whose
    superclass is `Another Superclass`, and so on. The `super` pointer in each `RClass`
    structure (actually, each `rb_classext_struct` structure) points down to the next
    superclass.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到[图6-2](ch06.html#including_a_module_into_a_class-id00020 "图6-2. 将模块包含进类")左上角的`Mathematician`类。在它下面的左侧，你可以看到它的父类链：`Mathematician`的父类是`Person`，`Person`的父类是`Another
    Superclass`，依此类推。每个`RClass`结构中的`super`指针（实际上是每个`rb_classext_struct`结构中的`super`指针）都指向下一个父类。
- en: Now to the `Professor` module on the right side of [Figure 6-2](ch06.html#including_a_module_into_a_class-id00020
    "Figure 6-2. Including a module into a class"). When we include this module into
    the `Mathematician` class, Ruby changes the `super` pointer of `Mathematician`
    to point to a copy of `Professor` and the `super` pointer of this copy of `Professor`
    to point to `Person`, the original superclass of `Mathematician`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看[图6-2](ch06.html#including_a_module_into_a_class-id00020 "图6-2. 将模块包含进类")右侧的`Professor`模块。当我们将此模块包含到`Mathematician`类中时，Ruby会将`Mathematician`的`super`指针指向`Professor`的一个副本，而该副本的`super`指针又指向`Person`，即`Mathematician`的原始父类。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Ruby implements `extend` in exactly the same way, except the included class
    becomes the superclass of the target class’s class, or metaclass. Thus, `extend`
    allows you to add class methods to a class.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ruby实现`extend`的方式与此完全相同，不同之处在于被包含的类成为目标类的类或 metaclass 的父类。因此，`extend`允许你向类添加类方法。*'
- en: Ruby’s Method Lookup Algorithm
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby的方法查找算法
- en: 'Whenever you call a method, whenever you “send a message to a receiver” to
    use object-oriented programming jargon, Ruby needs to determine which class implements
    that method. Sometimes this is obvious: The receiver’s class might implement the
    target method. However, this isn’t often the case. It might be that some other
    module or class in your system implements the method. Ruby uses a very precise
    algorithm to search through the modules and classes in your program in a particular
    order to find the target method. An understanding of this process is essential
    for every Ruby developer, so let’s take a close look at it.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用一个方法，或者用面向对象编程术语来说，“给接收者发送一条消息”时，Ruby需要确定哪个类实现了该方法。有时这很明显：接收者的类可能实现了目标方法。然而，这种情况并不常见。可能是你的系统中其他模块或类实现了该方法。Ruby使用一个非常精确的算法，在你的程序中的模块和类之间按照特定的顺序进行搜索，以找到目标方法。理解这个过程对每个Ruby开发者来说都是至关重要的，所以让我们仔细研究一下。
- en: The flowchart in [Figure 6-3](ch06.html#rubyapostrophes_method_lookup_al-id00021
    "Figure 6-3. Ruby’s method lookup algorithm") gives you a graphical picture of
    Ruby’s method lookup algorithm.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](ch06.html#rubyapostrophes_method_lookup_al-id00021 "图6-3. Ruby的方法查找算法")中的流程图为你提供了Ruby方法查找算法的图形表示。'
- en: '![Ruby’s method lookup algorithm](httpatomoreillycomsourcenostarchimages1854091.png.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby的方法查找算法](httpatomoreillycomsourcenostarchimages1854091.png.jpg)'
- en: Figure 6-3. Ruby’s method lookup algorithm
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3. Ruby的方法查找算法
- en: This algorithm is remarkably simple, isn’t it? As you can see, Ruby simply follows
    the `super` pointers until it finds the class or module that contains the target
    method. You might imagine that Ruby would have to distinguish between modules
    and classes using some special logic—that it would have to handle the case where
    there are multiple included modules, for example. But no, it’s just a simple loop
    on the `super` pointer linked list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法非常简单，不是吗？正如你所看到的，Ruby只是沿着`super`指针一直查找，直到找到包含目标方法的类或模块。你可能会想象Ruby需要通过一些特殊的逻辑来区分模块和类——例如，它需要处理有多个包含模块的情况。但是不，实际上它只是对`super`指针链表进行简单的循环。
- en: A Method Lookup Example
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法查找示例
- en: In a moment we’ll walk through this algorithm to be sure we understand it thoroughly.
    But first, let’s set up an example we can use that has a class, a superclass,
    and a module. This will allow us to see how classes and modules work together
    inside of Ruby.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将详细演示这个算法，以确保我们完全理解它。但首先，让我们设置一个包含类、父类和模块的示例。这将帮助我们了解类和模块在Ruby中如何协同工作。
- en: '[Example 6-2](ch06.html#simple_ruby_classcomma_repeated_from_l "Example 6-2. A
    simple Ruby class, repeated from Example 5-1") shows the `Mathematician` class
    with the accessor methods `first_name` and `last_name`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-2](ch06.html#simple_ruby_classcomma_repeated_from_l "示例 6-2。一个简单的 Ruby
    类，重复自示例 5-1")展示了带有访问器方法 `first_name` 和 `last_name` 的 `Mathematician` 类。'
- en: Example 6-2. A simple Ruby class, repeated from [Example 5-1](ch05.html#simple_ruby_class
    "Example 5-1. A simple Ruby class")
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-2。一个简单的 Ruby 类，重复自[示例 5-1](ch05.html#simple_ruby_class "示例 5-1。一个简单的 Ruby
    类")
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now let’s introduce a superclass. In [Example 6-3](ch06.html#person_is_the_superclass_of_mathematicia
    "Example 6-3. Person is the superclass of Mathematician."), at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we set `Person` as the superclass of `Mathematician`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们介绍一个父类。在[示例 6-3](ch06.html#person_is_the_superclass_of_mathematicia "示例
    6-3。Person 是 Mathematician 的父类")中， 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    我们将 `Person` 设置为 `Mathematician` 的父类。
- en: Example 6-3. `Person` is the superclass of `Mathematician`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-3。`Person` 是 `Mathematician` 的父类。
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll move the name attributes to the `Person` superclass because not only mathematicians
    have names. We end up with the code shown in [Example 6-4](ch06.html#now_the_name_attributes_are_in_the_perso
    "Example 6-4. Now the name attributes are in the Person superclass.").
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将姓名属性移到 `Person` 父类中，因为不仅仅是数学家有名字。我们最终得到了[示例 6-4](ch06.html#now_the_name_attributes_are_in_the_perso
    "示例 6-4。现在姓名属性在 Person 父类中。")中显示的代码。
- en: Example 6-4. Now the name attributes are in the `Person` superclass.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-4。现在姓名属性在 `Person` 父类中。
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we’ll include the `Professor` module into the `Mathematician` class
    at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg). [Example 6-5](ch06.html#now_we_have_a_class_that_includes_a_modu
    "Example 6-5. Now we have a class that includes a module and has a superclass.")
    shows the completed example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在 `Mathematician` 类中包含 `Professor` 模块，如 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    所示。[示例 6-5](ch06.html#now_we_have_a_class_that_includes_a_modu "示例 6-5。现在我们有一个包含模块并且有父类的类。")展示了完整的示例。
- en: Example 6-5. Now we have a class that includes a module and has a superclass.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-5。现在我们有一个包含模块并且有父类的类。
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Method Lookup Algorithm in Action
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法查找算法的实际应用
- en: Now that we have our example set up, we’re ready to see how Ruby finds a method
    we call. Every time you call any method in one of your programs, Ruby follows
    the same process we’re about to see here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好示例，准备查看 Ruby 如何找到我们调用的方法。每当你在程序中调用任何方法时，Ruby 会按照我们接下来将看到的相同流程来查找方法。
- en: 'To kick things off, let’s call a method. Using this code, we create a new mathematician
    object and set its first name:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，先调用一个方法。使用以下代码，我们创建一个新的数学家对象并设置它的名字：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To execute this code, Ruby needs to find the `first_name=` method. Where is
    this method? How does Ruby find it exactly?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这段代码，Ruby 需要找到 `first_name=` 方法。这个方法在哪里呢？Ruby 到底是如何找到它的？
- en: First, Ruby gets the class from the `ramanujan` object via the `klass` pointer,
    as shown in [Figure 6-4](ch06.html#ruby_first_looks_for_the_firstunderscore "Figure 6-4. Ruby
    first looks for the first_name= method in the object’s class.").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Ruby 通过 `klass` 指针从 `ramanujan` 对象中获取类，如[图 6-4](ch06.html#ruby_first_looks_for_the_firstunderscore
    "图 6-4。Ruby 首先在对象的类中查找 first_name= 方法")所示。
- en: '![Ruby first looks for the first_name= method in the object’s class.](httpatomoreillycomsourcenostarchimages1854093.png.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 首先在对象的类中查找 first_name= 方法。](httpatomoreillycomsourcenostarchimages1854093.png.jpg)'
- en: Figure 6-4. Ruby first looks for the `first_name=` method in the object’s class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4。Ruby 首先在对象的类中查找 `first_name=` 方法。
- en: Next, Ruby checks to see whether `Mathematician` implements `first_name=` directly
    by looking through its method table, as shown in [Figure 6-5](ch06.html#ruby_first_looks_for_firstunderscorename
    "Figure 6-5. Ruby first looks for first_name= in the class’s method table.").
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 检查 `Mathematician` 是否通过查看其方法表直接实现了 `first_name=`，如[图 6-5](ch06.html#ruby_first_looks_for_firstunderscorename
    "图 6-5。Ruby 首先在类的方法表中查找 first_name=。")所示。
- en: '![Ruby first looks for first_name= in the class’s method table.](httpatomoreillycomsourcenostarchimages1854095.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 首先在类的方法表中查找 first_name=。](httpatomoreillycomsourcenostarchimages1854095.png.jpg)'
- en: Figure 6-5. Ruby first looks for `first_name=` in the class’s method table.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5。Ruby 首先在类的方法表中查找 `first_name=`。
- en: Because we’ve moved all of the methods down into the `Person` superclass, the
    `first_name=` method is no longer there. Ruby continues through the algorithm
    and gets the superclass of `Mathematician` using the `super` pointer, as shown
    in [Figure 6-6](ch06.html#superclass_of_mathematician_is_the_c "Figure 6-6. The
    superclass of Mathematician is the copy of the Professor module.").
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已将所有方法移到 `Person` 超类中，所以 `first_name=` 方法不再存在。Ruby 继续执行算法，并通过 `super` 指针获取
    `Mathematician` 的超类，如[图 6-6](ch06.html#superclass_of_mathematician_is_the_c "图
    6-6. `Mathematician` 的超类是 `Professor` 模块的副本.")所示。
- en: '![The superclass of Mathematician is the copy of the Professor module.](httpatomoreillycomsourcenostarchimages1854097.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Mathematician 的超类是 `Professor` 模块的副本。](httpatomoreillycomsourcenostarchimages1854097.png.jpg)'
- en: Figure 6-6. The superclass of `Mathematician` is the copy of the `Professor`
    module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6. `Mathematician` 的超类是 `Professor` 模块的副本。
- en: Remember, this is not the `Person` class; it’s the *included* class, which is
    a copy of the `Professor` module. Because it’s a copy, Ruby looks through the
    method table for `Professor`. Recall from [Example 6-5](ch06.html#now_we_have_a_class_that_includes_a_modu
    "Example 6-5. Now we have a class that includes a module and has a superclass.")
    that `Professor` contains only the single method `lectures`. Ruby won’t find the
    `first_name=` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这不是 `Person` 类；它是 *包含的* 类，即 `Professor` 模块的副本。由于它是副本，Ruby 会在 `Professor`
    的方法表中查找。回想一下[示例 6-5](ch06.html#now_we_have_a_class_that_includes_a_modu "示例 6-5.
    现在我们有一个包含模块并具有超类的类。")，`Professor` 只包含单一方法 `lectures`。Ruby 不会找到 `first_name=` 方法。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Notice that because Ruby inserts modules above the original superclass in
    the superclass chain, methods in an included module override methods present in
    a superclass. In this case, if `Professor` also had a `first_name=` method, Ruby
    would call it and not the method in `Person`.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，由于 Ruby 将模块插入到原始超类之上，包含的模块中的方法会覆盖超类中的方法。在这种情况下，如果 `Professor` 也有一个 `first_name=`
    方法，Ruby 将调用它，而不是 `Person` 中的方法。*'
- en: Because Ruby doesn’t find `first_name=` in `Professor`, it continues to iterate
    over the `super` pointers, but this time it uses the `super` pointer in `Professor`,
    as shown in [Figure 6-7](ch06.html#person_class_is_the_superclass_of_th "Figure 6-7. The
    Person class is the superclass of the included copy of the Professor module.").
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ruby 没有在 `Professor` 中找到 `first_name=`，它继续遍历 `super` 指针，但这一次它使用的是 `Professor`
    中的 `super` 指针，如[图 6-7](ch06.html#person_class_is_the_superclass_of_th "图 6-7.
    `Person` 类是包含的 `Professor` 模块副本的超类。")所示。
- en: '![The Person class is the superclass of the included copy of the Professor
    module.](httpatomoreillycomsourcenostarchimages1854099.png.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Person 类是包含的 `Professor` 模块副本的超类。](httpatomoreillycomsourcenostarchimages1854099.png.jpg)'
- en: Figure 6-7. The `Person` class is the superclass of the included copy of the
    `Professor` module.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7. `Person` 类是包含的 `Professor` 模块副本的超类。
- en: Note that the superclass of the `Professor` module—or more precisely, the superclass
    of the included copy of the `Professor` module—is the `Person` class. This was
    the original superclass of `Mathematician`. Finally, Ruby sees the `first_name=`
    method in the method table for `Person`. Because it has identified which class
    implements `first_name=`, Ruby can now call the method using the method dispatch
    process we learned about in [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Professor` 模块的超类——更准确地说，包含的 `Professor` 模块的副本的超类——是 `Person` 类。这是 `Mathematician`
    原始的超类。最后，Ruby 在 `Person` 的方法表中找到了 `first_name=` 方法。因为它已经确定了哪个类实现了 `first_name=`，所以
    Ruby 可以使用我们在[第4章](ch04.html "第4章 控制结构和方法调度")中学到的方法调度过程来调用这个方法。
- en: Multiple Inheritance in Ruby
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 中的多重继承
- en: What is most interesting here is that internally, Ruby implements module inclusion
    using class inheritance. Essentially, there is no difference between including
    a module and specifying a superclass. Both procedures make new methods available
    to the target class, and both use the class’s `super` pointer internally. Including
    multiple modules into a Ruby class is equivalent to specifying multiple superclasses.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最有趣的是，Ruby 在内部使用类继承来实现模块的包含。实际上，包含一个模块和指定一个超类之间没有区别。这两种操作都会将新的方法引入目标类，并且都在内部使用类的
    `super` 指针。将多个模块包含到 Ruby 类中，相当于指定多个超类。
- en: Still, Ruby keeps things simple by enforcing a single list of ancestors. While
    including multiple modules does create multiple superclasses internally, Ruby
    maintains them in a single list. The result? As a Ruby developer, you get the
    benefits of multiple inheritance (adding new behavior to a class from as many
    different modules as you would like) while keeping the simplicity of the single
    inheritance model.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Ruby 仍通过强制执行一个单一的祖先列表来保持简单。虽然包含多个模块会在内部创建多个超类，但 Ruby 会将它们维护在一个单一的列表中。结果是？作为
    Ruby 开发者，你既可以享受多重继承的好处（从任意数量的模块中为类添加新行为），又能保持单继承模型的简单性。
- en: Ruby benefits from this simplicity as well! By enforcing this single list of
    superclass ancestors, its method lookup algorithm can be very simple. Whenever
    you call a method on an object, Ruby simply has to iterate through the superclass
    linked list until it finds the class or module that contains the target method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 也从这种简化中受益！通过强制使用单一的超类祖先列表，其方法查找算法非常简单。每当你在对象上调用方法时，Ruby 只需要遍历超类链表，直到找到包含目标方法的类或模块。
- en: The Global Method Cache
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局方法缓存
- en: 'Depending on the number of superclasses in the chain, method lookup can be
    time consuming. To alleviate this, Ruby caches the result of a lookup for later
    use. It records which class or module implemented the method that your code called
    in two caches: a global method cache and an inline method cache.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据继承链中超类的数量，方法查找可能会很耗时。为了解决这个问题，Ruby 会缓存查找结果以供后续使用。它记录了哪个类或模块实现了你代码中调用的方法，存在两个缓存中：一个是全局方法缓存，一个是内联方法缓存。
- en: Let’s learn about the global method cache first. Ruby uses the *global method
    cache* to save a mapping between the receiver and implementer classes, as shown
    in [Table 6-1](ch06.html#example_of_what_the_global_method_cac "Table 6-1. An
    Example of What the Global Method Cache Might Contain").
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一下全局方法缓存。Ruby 使用 *全局方法缓存* 保存接收者类和实现者类之间的映射，如[表格 6-1](ch06.html#example_of_what_the_global_method_cac
    "表格 6-1. 全局方法缓存可能包含的示例")所示。
- en: Table 6-1. An Example of What the Global Method Cache Might Contain
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 6-1. 全局方法缓存可能包含的示例
- en: '| `klass` | `defined_class` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `klass` | `defined_class` |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Fixnum#times` | `Integer#times` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Fixnum#times` | `Integer#times` |'
- en: '| `Object#puts` | `BasicObject#puts` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Object#puts` | `BasicObject#puts` |'
- en: '| etc... | etc... |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 等等... | 等等... |'
- en: The left column in [Table 6-1](ch06.html#example_of_what_the_global_method_cac
    "Table 6-1. An Example of What the Global Method Cache Might Contain"), `klass`,
    shows the receiver class; this is the class of the object you call a method on.
    The right column, `defined_class`, records the result of the method lookup. This
    is the implementer class, or the class that implements the method Ruby was looking
    for.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 6-1](ch06.html#example_of_what_the_global_method_cac "表格 6-1. 全局方法缓存可能包含的示例")中的左栏
    `klass` 显示了接收者类；这是你在其上调用方法的对象所属的类。右栏 `defined_class` 记录了方法查找的结果。它是实现方法的类，或者说是实现
    Ruby 查找方法的类。'
- en: Let’s take the first row of [Table 6-1](ch06.html#example_of_what_the_global_method_cac
    "Table 6-1. An Example of What the Global Method Cache Might Contain") as an example;
    it reads `Fixnum#times` and `Integer#times`. In the global method cache, this
    information means that Ruby’s method lookup algorithm started to look for the
    `times` method in the `Fixnum` class but actually found it in the `Integer` class.
    In a similar way, the second row of [Table 6-1](ch06.html#example_of_what_the_global_method_cac
    "Table 6-1. An Example of What the Global Method Cache Might Contain") means that
    Ruby started to look for the `puts` method in the `Object` class but actually
    found it in the `BasicObject` class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以[表格 6-1](ch06.html#example_of_what_the_global_method_cac "表格 6-1. 全局方法缓存可能包含的示例")的第一行为例；它显示了
    `Fixnum#times` 和 `Integer#times`。在全局方法缓存中，这意味着 Ruby 的方法查找算法开始在 `Fixnum` 类中查找 `times`
    方法，但实际上它是在 `Integer` 类中找到了。类似地，[表格 6-1](ch06.html#example_of_what_the_global_method_cac
    "表格 6-1. 全局方法缓存可能包含的示例")的第二行表示 Ruby 开始在 `Object` 类中查找 `puts` 方法，但实际上找到了 `BasicObject`
    类中的实现。
- en: The global method cache allows Ruby to skip the method lookup process the next
    time your code calls a method listed in the first column of the global cache.
    After your code has called `Fixnum#times` once, Ruby knows that it can execute
    the `Integer#times` method, regardless of from where in your program you call
    `times`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 全局方法缓存允许 Ruby 在下次你的代码调用全局缓存中第一列列出的某个方法时跳过方法查找过程。你的代码第一次调用 `Fixnum#times` 后，Ruby
    知道它可以执行 `Integer#times` 方法，无论你在程序中的哪个位置调用 `times`。
- en: The Inline Method Cache
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联方法缓存
- en: Ruby uses another type of cache, called an *inline method cache*, to speed up
    method lookup even more. The inline cache saves information alongside the compiled
    YARV instructions that Ruby executes (see [Figure 6-8](ch06.html#yarv_instructions_on_the_left_should
    "Figure 6-8. The YARV instructions on the left should call the implementation
    of Integer#times on the right.")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby使用另一种类型的缓存，称为*内联方法缓存*，进一步加速方法查找。内联缓存将信息保存在Ruby执行的编译后YARV指令旁边（见[图6-8](ch06.html#yarv_instructions_on_the_left_should
    "图6-8. 左侧的YARV指令应调用右侧的`Integer#times`实现。")）。
- en: '![The YARV instructions on the left should call the implementation of Integer#times
    on the right.](httpatomoreillycomsourcenostarchimages1854101.png.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![左侧的YARV指令应调用右侧`Integer#times`的实现。](httpatomoreillycomsourcenostarchimages1854101.png.jpg)'
- en: Figure 6-8. The YARV instructions on the left should call the implementation
    of `Integer#times` on the right.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8. 左侧的YARV指令应调用右侧的`Integer#times`实现。
- en: On the left side of this figure, we see the compiled YARV instructions that
    correspond to the code `10.times do... end`. First, `putobject 10` pushes the
    `Fixnum` object `10` onto YARV’s internal stack. This is the receiver of the `times`
    method call. Next, `send` calls the `times` method, as indicated by the text between
    the angle brackets.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形的左侧，我们看到与代码`10.times do... end`对应的编译后的YARV指令。首先，`putobject 10`将`Fixnum`对象`10`推入YARV的内部栈中。这是`times`方法调用的接收者。接下来，`send`调用`times`方法，方法名位于尖括号之间的文本中。
- en: The rectangle on the right side of the figure represents the `Integer#times`
    method, which Ruby found using its method lookup algorithm (after looking up the
    `times` method among the `Fixnum` class and its superclasses). Ruby’s inline cache
    enables it to save the mapping between the `times` method call and the `Integer#times`
    implementation right in the YARV instructions. [Figure 6-9](ch06.html#inline_cache_saves_the_result_of_met
    "Figure 6-9. The inline cache saves the result of method lookup next to the send
    instruction that needs to call the method.") shows how the inline cache might
    look.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图形右侧的矩形表示Ruby通过其方法查找算法找到的`Integer#times`方法（在`Fixnum`类及其超类中查找`times`方法后）。Ruby的内联缓存使得它能够将`times`方法调用与`Integer#times`实现之间的映射直接保存在YARV指令中。[图6-9](ch06.html#inline_cache_saves_the_result_of_met
    "图6-9. 内联缓存将方法查找的结果保存在需要调用该方法的`send`指令旁边")展示了内联缓存的样子。
- en: '![The inline cache saves the result of method lookup next to the send instruction
    that needs to call the method.](httpatomoreillycomsourcenostarchimages1854103.png.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![内联缓存将方法查找的结果保存在需要调用该方法的`send`指令旁边。](httpatomoreillycomsourcenostarchimages1854103.png.jpg)'
- en: Figure 6-9. The inline cache saves the result of method lookup next to the `send`
    instruction that needs to call the method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-9. 内联缓存将方法查找的结果保存在需要调用该方法的`send`指令旁边。
- en: If Ruby executes this line of code again, it will immediately execute `Integer#times`
    without having to call the method lookup algorithm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Ruby再次执行这一行代码，它将立即执行`Integer#times`，而不需要调用方法查找算法。
- en: Clearing Ruby’s Method Caches
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除Ruby的方法缓存
- en: Because Ruby is a dynamic language, you can define new methods when you like.
    In order for you to be able to do so, Ruby must clear the global and inline method
    caches, because the results of method lookups might change. For example, if we
    add a new definition of the `times` method to the `Fixnum` or `Integer` classes,
    Ruby would need to call the new `times` method, not the `Integer#times` method
    that it was previously using.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ruby是一种动态语言，你可以随时定义新的方法。为了让你能够这样做，Ruby必须清除全局和内联方法缓存，因为方法查找的结果可能会发生变化。例如，如果我们向`Fixnum`或`Integer`类中添加新的`times`方法定义，Ruby需要调用新的`times`方法，而不是它之前使用的`Integer#times`方法。
- en: In effect, whenever you create or remove (*undefine*) a method, include a module
    into a class, or perform a similar action, Ruby clears the global and inline method
    caches, forcing a new call to the method lookup code. Ruby also clears the cache
    when you use refinements or employ other types of metaprogramming. In fact, clearing
    the cache happens quite frequently in Ruby. The global and inline method caches
    might remain valid for only a short time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每当你创建或删除（*未定义*）方法、将模块包含到类中或执行类似的操作时，Ruby会清除全局和内联方法缓存，迫使重新调用方法查找代码。当你使用修饰符或进行其他类型的元编程时，Ruby也会清除缓存。事实上，在Ruby中清除缓存是一个相当频繁的操作。全局和内联方法缓存可能只能在短时间内保持有效。
- en: Including Two Modules into One Class
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将两个模块包含到一个类中
- en: While Ruby’s method lookup algorithm may be simple, the code that it uses to
    include modules is not. As we saw above, when you include a module into a class,
    Ruby inserts a copy of the module into the class’s ancestor chain. This means
    that if you include two modules, one after the other, the second module appears
    first in the ancestor chain and is found first by Ruby’s method lookup logic.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ruby的方法查找算法可能很简单，但它用于包含模块的代码并不简单。如上所述，当你将一个模块包含到一个类中时，Ruby会将该模块的副本插入到该类的祖先链中。这意味着如果你依次包含两个模块，第二个模块会首先出现在祖先链中，并且会被Ruby的方法查找逻辑首先找到。
- en: For example, suppose we include two modules into `Mathematician`, as shown in
    [Example 6-6](ch06.html#including_two_modules_into_one_c-id00022 "Example 6-6. Including
    two modules into one class").
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们将两个模块包含到`Mathematician`中，如[示例6-6](ch06.html#including_two_modules_into_one_c-id00022
    "示例6-6. 将两个模块包含到一个类中")所示。
- en: Example 6-6. Including two modules into one class
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-6。将两个模块包含到一个类中
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now `Mathematician` objects have methods from the `Professor` module, the `Employee`
    module, and the `Person` class. But which methods does Ruby find first and which
    methods override which?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Mathematician`对象拥有来自`Professor`模块、`Employee`模块和`Person`类的方法。但Ruby会首先找到哪些方法，哪些方法会被覆盖呢？
- en: '[Figure 6-10](ch06.html#in_listing_6-6_we_include_the_professor "Figure 6-10. In
    Example 6-6 we include the Professor module first.") and [Figure 6-11](ch06.html#in_listing_6-6_we_include_the_employee_m
    "Figure 6-11. In Example 6-6 we include the Employee module second, after including
    Professor.") show the order of precedence. Because we include the `Professor`
    module first, Ruby inserts the included class corresponding to the `Professor`
    module as a superclass first.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-10](ch06.html#in_listing_6-6_we_include_the_professor "图6-10. 在示例6-6中，我们首先包含`Professor`模块")和[图6-11](ch06.html#in_listing_6-6_we_include_the_employee_m
    "图6-11. 在示例6-6中，我们在包含`Professor`模块之后，第二次包含`Employee`模块")展示了优先级的顺序。由于我们首先包含了`Professor`模块，Ruby首先将对应的`Professor`模块的包含类作为父类插入。'
- en: '![In we include the Professor module first.](httpatomoreillycomsourcenostarchimages1854105.png.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![在示例中，我们首先包含了`Professor`模块。](httpatomoreillycomsourcenostarchimages1854105.png.jpg)'
- en: Figure 6-10. In [Example 6-6](ch06.html#including_two_modules_into_one_c-id00022
    "Example 6-6. Including two modules into one class") we include the `Professor`
    module first.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10。在[示例6-6](ch06.html#including_two_modules_into_one_c-id00022 "示例6-6. 将两个模块包含到一个类中")中，我们首先包含了`Professor`模块。
- en: Now, when we include the `Employee` module, the included class for the `Employee`
    module is inserted above the included class for the `Professor` module, as shown
    in [Figure 6-11](ch06.html#in_listing_6-6_we_include_the_employee_m "Figure 6-11. In
    Example 6-6 we include the Employee module second, after including Professor.").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们包含`Employee`模块时，`Employee`模块对应的包含类会被插入到`Professor`模块对应的包含类之上，如[图6-11](ch06.html#in_listing_6-6_we_include_the_employee_m
    "图6-11. 在示例6-6中，我们在包含`Professor`模块之后，第二次包含`Employee`模块")所示。
- en: '![In we include the Employee module second, after including Professor.](httpatomoreillycomsourcenostarchimages1854107.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![在示例中，我们在包含`Professor`模块之后，第二次包含了`Employee`模块。](httpatomoreillycomsourcenostarchimages1854107.png.jpg)'
- en: Figure 6-11. In [Example 6-6](ch06.html#including_two_modules_into_one_c-id00022
    "Example 6-6. Including two modules into one class") we include the `Employee`
    module second, after including `Professor`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-11。在[示例6-6](ch06.html#including_two_modules_into_one_c-id00022 "示例6-6. 将两个模块包含到一个类中")中，我们在包含`Professor`模块之后，第二次包含了`Employee`模块。
- en: Because `Employee` appears above `Professor` in the superclass chain, as shown
    along the left side of [Figure 6-11](ch06.html#in_listing_6-6_we_include_the_employee_m
    "Figure 6-11. In Example 6-6 we include the Employee module second, after including
    Professor."), methods from `Employee` override methods from `Professor`, which
    in turn override methods from `Person`, the actual superclass.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Employee`在父类链中位于`Professor`之上，如[图6-11](ch06.html#in_listing_6-6_we_include_the_employee_m
    "图6-11. 在示例6-6中，我们在包含`Professor`模块之后，第二次包含`Employee`模块")左侧所示，`Employee`的方法会覆盖`Professor`的方法，而`Professor`的方法又会覆盖`Person`的方法，即实际的父类方法。
- en: Including One Module into Another
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一个模块包含到另一个模块中
- en: 'Modules don’t allow you to specify superclasses. For example, we can’t write
    the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 模块不允许你指定父类。例如，我们不能写出如下代码：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But we can include one module into another, as shown in [Example 6-7](ch06.html#one_module_including_another_module
    "Example 6-7. One module including another module").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以将一个模块包含到另一个模块中，正如在[示例6-7](ch06.html#one_module_including_another_module
    "示例6-7. 一个模块包含另一个模块")中所示。
- en: Example 6-7. One module including another module
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例6-7。一个模块包含另一个模块
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What if we include `Professor`, a module with other modules included into it,
    into `Mathematician`? Which methods will Ruby find first? As shown in [Figure 6-12](ch06.html#when_you_include_one_module_into_another
    "Figure 6-12. When you include one module into another, Ruby sets it as the superclass
    of the target module."), when we include `Employee` into `Professor`, Ruby creates
    a copy of `Employee` and sets it as the superclass of `Professor`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `Professor`（一个包含其他模块的模块）包含进 `Mathematician`，Ruby 会先找到哪些方法呢？如 [图 6-12](ch06.html#when_you_include_one_module_into_another
    "图 6-12. 当你将一个模块包含进另一个模块时，Ruby 会将其设置为目标模块的父类") 所示，当我们将 `Employee` 包含进 `Professor`
    时，Ruby 会创建一个 `Employee` 的副本，并将其设置为 `Professor` 的父类。
- en: '![When you include one module into another, Ruby sets it as the superclass
    of the target module.](httpatomoreillycomsourcenostarchimages1854109.png.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![当你将一个模块包含进另一个模块时，Ruby 会将其设置为目标模块的父类。](httpatomoreillycomsourcenostarchimages1854109.png.jpg)'
- en: Figure 6-12. When you include one module into another, Ruby sets it as the superclass
    of the target module.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-12. 当你将一个模块包含进另一个模块时，Ruby 会将其设置为目标模块的父类。
- en: Modules can’t have a superclass in your code, but they can inside Ruby because
    Ruby represents modules with classes internally!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在你的代码中不能有父类，但它们在 Ruby 内部可以有父类，因为 Ruby 内部用类来表示模块！
- en: Finally, when we include `Professor` into `Mathematician`, Ruby iterates over
    the two modules and inserts them both as superclasses of `Mathematician`, as shown
    in [Figure 6-13](ch06.html#including_two_modules_into_a_class_at_th "Figure 6-13. Including
    two modules into a class at the same time").
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们将 `Professor` 包含进 `Mathematician` 时，Ruby 会遍历这两个模块，并将它们都插入为 `Mathematician`
    的父类，如 [图 6-13](ch06.html#including_two_modules_into_a_class_at_th "图 6-13. 同时将两个模块包含到一个类中")
    所示。
- en: '![Including two modules into a class at the same time](httpatomoreillycomsourcenostarchimages1854111.png.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![同时将两个模块包含到一个类中](httpatomoreillycomsourcenostarchimages1854111.png.jpg)'
- en: Figure 6-13. Including two modules into a class at the same time
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-13. 同时将两个模块包含到一个类中
- en: Now Ruby will find the methods in `Professor` first and `Employee` second.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ruby 会首先查找 `Professor` 中的方法，其次查找 `Employee` 中的方法。
- en: A Module#prepend Example
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Module#prepend 示例
- en: In [Figure 6-2](ch06.html#including_a_module_into_a_class-id00020 "Figure 6-2. Including
    a module into a class") we saw how Ruby includes a module into a class. Specifically,
    we saw how Ruby inserts a copy of the module’s `RClass` structure into the superclass
    chain for the target class, between the class and its superclass.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6-2](ch06.html#including_a_module_into_a_class-id00020 "图 6-2. 将模块包含进类中")
    中，我们看到 Ruby 如何将一个模块包含进一个类。具体来说，我们看到 Ruby 如何将模块的 `RClass` 结构副本插入到目标类的父类链中，位于类和它的父类之间。
- en: Beginning with version 2.0, Ruby now allows you to “prepend” a module into a
    class. We’ll use the `Mathematician` class to explain, as shown in [Example 6-8](ch06.html#simple_ruby_class_with_a_name_attribut
    "Example 6-8. A simple Ruby class with a name attribute").
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始，Ruby 现在允许你将一个模块“前置”到类中。我们将使用 `Mathematician` 类来进行说明，如 [示例 6-8](ch06.html#simple_ruby_class_with_a_name_attribut
    "示例 6-8. 一个带有名称属性的简单 Ruby 类") 所示。
- en: Example 6-8. A simple Ruby class with a `name` attribute
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-8. 一个带有 `name` 属性的简单 Ruby 类
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we define the `Mathematician` class with just the single attribute `name`
    at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg). Then, we create
    an instance of `Mathematician`, set its name, and display it at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个仅有 `name` 属性的 `Mathematician` 类，如 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    所示。然后，我们创建一个 `Mathematician` 类的实例，设置其名称，并显示它，如 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    所示。
- en: Now suppose we make all of our mathematicians professors by including the `Professor`
    module into the `Mathematician` class again, as shown at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    in [Example 6-9](ch06.html#including_the_professor_module_into_the "Example 6-9. Including
    the Professor module into the Mathematician class").
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们通过再次将 `Professor` 模块包含进 `Mathematician` 类，使所有数学家都成为教授，如 [示例 6-9](ch06.html#including_the_professor_module_into_the
    "示例 6-9. 将 Professor 模块包含进 Mathematician 类") 所示的 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
- en: Example 6-9. Including the `Professor` module into the `Mathematician` class
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-9. 将 `Professor` 模块包含进 `Mathematician` 类
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Figure 6-14](ch06.html#professor_is_a_superclass_of_mathematici "Figure 6-14. Professor
    is a superclass of Mathematician.") shows the superclass chain for `Mathematician`
    and `Professor`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-14](ch06.html#professor_is_a_superclass_of_mathematici "图 6-14. Professor
    是 Mathematician 的父类") 显示了 `Mathematician` 和 `Professor` 的父类链。'
- en: '![Professor is a superclass of Mathematician.](httpatomoreillycomsourcenostarchimages1854113.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Professor 是 Mathematician 的父类。](httpatomoreillycomsourcenostarchimages1854113.png.jpg)'
- en: Figure 6-14. `Professor` is a superclass of `Mathematician`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-14. `Professor` 是 `Mathematician` 的父类。
- en: If we decide to display the title `Prof.` in front of each mathematician’s name,
    we can just add that behavior to the `Mathematician` class, as shown in [Example 6-10](ch06.html#ugly_way_to_display_the_profdot_title
    "Example 6-10. An ugly way to display the Prof. title before each mathematician’s
    name").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定在每个数学家的名字前显示 `Prof.` 头衔，我们可以像在 [示例 6-10](ch06.html#ugly_way_to_display_the_profdot_title
    "示例 6-10. 一种丑陋的方式在每个数学家的名字前显示 Prof. 头衔") 中所示那样，仅在 `Mathematician` 类中添加该行为。
- en: Example 6-10. An ugly way to display the `Prof.` title before each mathematician’s
    name
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-10. 一种丑陋的方式在每个数学家的名字前显示 `Prof.` 头衔
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But this is a very ugly solution: The `Mathematician` class has to do the work
    of displaying the professor title at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    What if other classes include `Professor`? Shouldn’t they display the `Prof.`
    title also? If `Mathematician` contains the code for showing `Prof.`, then any
    other classes that include `Professor` would be missing this code.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这是一个非常糟糕的解决方案：`Mathematician` 类必须承担显示教授头衔的工作，见 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。如果其他类也包含
    `Professor` 呢？它们不也应该显示 `Prof.` 头衔吗？如果 `Mathematician` 中包含了显示 `Prof.` 的代码，那么任何其他包含
    `Professor` 的类都将缺少这段代码。
- en: It makes more sense to include the code for displaying the title in the `Professor`
    module, as shown in [Example 6-11](ch06.html#how_can_we_get_ruby_to_call_the_moduleap
    "Example 6-11. How can we get Ruby to call the module’s name method?"). This way
    every class that includes `Professor` will be able to display the title `Prof.`
    along with its class name.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示头衔的代码包含在 `Professor` 模块中更为合理，正如在 [示例 6-11](ch06.html#how_can_we_get_ruby_to_call_the_moduleap
    "示例 6-11. 我们如何让 Ruby 调用模块的 name 方法？") 中所示。这样，任何包含 `Professor` 的类都能够显示 `Prof.`
    头衔以及其类名。
- en: Example 6-11. How can we get Ruby to call the module’s `name` method?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-11. 我们如何让 Ruby 调用模块的 `name` 方法？
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we define a `name`
    method inside `Professor` that will display the `Prof.` title before the actual
    name (assuming that `name` is defined in a superclass). At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we include `Professor` into `Mathematician`. Finally, at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    we call the `name` method, but we get the name `Henri Poincaré` without the `Prof.`
    title. What went wrong?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处，我们在 `Professor`
    中定义了一个 `name` 方法，该方法会在实际姓名之前显示 `Prof.` 头衔（假设 `name` 已在父类中定义）。在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处，我们将 `Professor` 包含到 `Mathematician` 中。最后，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    处，我们调用 `name` 方法，但得到的是 `Henri Poincaré` 的名字，没有 `Prof.` 头衔。出了什么问题？
- en: The problem, as shown in [Figure 6-14](ch06.html#professor_is_a_superclass_of_mathematici
    "Figure 6-14. Professor is a superclass of Mathematician."), is that `Professor`
    is a superclass of `Mathematician`, not the other way around. This means when
    I call `poincaré.name` at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    in [Example 6-11](ch06.html#how_can_we_get_ruby_to_call_the_moduleap "Example 6-11. How
    can we get Ruby to call the module’s name method?"), Ruby finds the `name` method
    from `Mathematician`, not from `Professor`. [Figure 6-15](ch06.html#ruby_calls_the_attrunderscoreaccessor_me
    "Figure 6-15. Ruby calls the attr_accessor method before finding the name method
    from Professor.") shows visually what Ruby’s method lookup algorithm finds when
    I call `poincaré.name`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 6-14](ch06.html#professor_is_a_superclass_of_mathematici "图 6-14. Professor
    是 Mathematician 的父类。") 所示，问题在于 `Professor` 是 `Mathematician` 的父类，而不是反过来。这意味着当我在
    [示例 6-11](ch06.html#how_can_we_get_ruby_to_call_the_moduleap "示例 6-11. 我们如何让 Ruby
    调用模块的 name 方法？") 中调用 `poincaré.name` 时，Ruby 会从 `Mathematician` 中找到 `name` 方法，而不是从
    `Professor` 中找到。[图 6-15](ch06.html#ruby_calls_the_attrunderscoreaccessor_me "图
    6-15. Ruby 在找到来自 Professor 的 name 方法之前会先调用 attr_accessor 方法。") 直观地展示了当我调用 `poincaré.name`
    时 Ruby 方法查找算法的执行过程。
- en: '![Ruby calls the attr_accessor method before finding the name method from Professor.](httpatomoreillycomsourcenostarchimages1854115.png.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在找到来自 Professor 的 name 方法之前会先调用 attr_accessor 方法。](httpatomoreillycomsourcenostarchimages1854115.png.jpg)'
- en: Figure 6-15. Ruby calls the `attr_accessor` method before finding the `name`
    method from `Professor`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-15. Ruby 在找到来自 `Professor` 的 `name` 方法之前会先调用 `attr_accessor` 方法。
- en: When we call `name` at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    in [Example 6-11](ch06.html#how_can_we_get_ruby_to_call_the_moduleap "Example 6-11. How
    can we get Ruby to call the module’s name method?"), Ruby finds the first `name`
    method that it sees in the superclass chain starting from the top and moving down.
    As you can see in [Figure 6-15](ch06.html#ruby_calls_the_attrunderscoreaccessor_me
    "Figure 6-15. Ruby calls the attr_accessor method before finding the name method
    from Professor."), the first `name` method is the simple `attr_accessor` method
    in `Mathematician`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[示例 6-11](ch06.html#how_can_we_get_ruby_to_call_the_moduleap "示例 6-11. 如何让
    Ruby 调用模块的 name 方法？")中调用`name`时，Ruby会在父类链中从顶部开始向下查找它看到的第一个`name`方法。如[图 6-15](ch06.html#ruby_calls_the_attrunderscoreaccessor_me
    "图 6-15. Ruby 在找到`Professor`的`name`方法之前，会先调用`Mathematician`中的`attr_accessor`方法。")所示，第一个`name`方法是`Mathematician`中的简单`attr_accessor`方法。
- en: However, if we prepend `Professor` instead of including it, we get the behavior
    we were hoping for, as shown in [Example 6-12](ch06.html#using_prependcomma_ruby_finds_the_module
    "Example 6-12. Using prepend, Ruby finds the module’s name method first.").
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用`prepend`而不是`include`，我们就能得到预期的行为，如[示例 6-12](ch06.html#using_prependcomma_ruby_finds_the_module
    "示例 6-12. 使用 prepend 时，Ruby 首先找到模块的 name 方法。")所示。
- en: Example 6-12. Using `prepend`, Ruby finds the module’s `name` method first.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-12. 使用`prepend`时，Ruby首先找到模块的`name`方法。
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only difference here is the use of `prepend` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的区别是使用了`prepend`，如[图 6-16](ch06.html#using_prependcomma_ruby_places_the_modul
    "图 6-16. 使用 prepend 时，Ruby 将模块放在目标类之前。")所示。
- en: How Ruby Implements Module#prepend
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby如何实现Module#prepend
- en: When you prepend a module to a class, Ruby places it before the class in the
    superclass chain, as shown in [Figure 6-16](ch06.html#using_prependcomma_ruby_places_the_modul
    "Figure 6-16. Using prepend, Ruby places the module before the target class in
    the superclass chain.").
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个模块预置到一个类时，Ruby会将其放在类之前，形成父类链，正如[图 6-16](ch06.html#using_prependcomma_ruby_places_the_modul
    "图 6-16. 使用 prepend 时，Ruby 将模块放在目标类之前，形成父类链。")所示。
- en: '![Using prepend, Ruby places the module before the target class in the superclass
    chain.](httpatomoreillycomsourcenostarchimages1854117.png.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![使用 prepend 时，Ruby 将模块放在目标类之前，形成父类链。](httpatomoreillycomsourcenostarchimages1854117.png.jpg)'
- en: Figure 6-16. Using `prepend`, Ruby places the module before the target class
    in the superclass chain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-16. 使用`prepend`时，Ruby将模块放在目标类之前，形成父类链。
- en: But there is something odd here. When we call `name` on a mathematician object,
    how does Ruby find the module’s method? That is, at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    in [Example 6-12](ch06.html#using_prependcomma_ruby_finds_the_module "Example 6-12. Using
    prepend, Ruby finds the module’s name method first."), we’re calling `name` on
    the `Mathematician` class, not on the `Professor` module. Ruby should find the
    simple `attr_accessor` method, not the version from the module, but that’s not
    the case. Does Ruby look backward up the superclass chain to find the module?
    If so, how does it do this when the `super` pointers point down?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这里有些奇怪的地方。当我们在一个mathematician对象上调用`name`时，Ruby是如何找到模块的方法的呢？也就是说，在[示例 6-12](ch06.html#using_prependcomma_ruby_finds_the_module
    "示例 6-12. 使用 prepend 时，Ruby 首先找到模块的 name 方法。")中，我们是在`Mathematician`类上调用`name`，而不是在`Professor`模块上调用。Ruby应该会找到简单的`attr_accessor`方法，而不是模块中的版本，但事实并非如此。Ruby是从父类链中向上查找模块的方法吗？如果是这样，Ruby是如何做到的呢，特别是当`super`指针指向下方时？
- en: The secret is that internally Ruby uses a trick to make it seem as if `Mathematician`
    is the superclass of `Professor` when it’s not, as shown in [Figure 6-17](ch06.html#ruby_creates_a_copy_of_the_target_class
    "Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass
    of the prepended module."). Prepending a module is like including a module. `Mathematician`
    is at the top of the superclass chain, and moving down the chain, we see that
    Ruby still sets the included class for `Professor` to be the superclass of `Mathematician`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的秘密在于，Ruby内部使用了一个技巧，使得它看起来`Mathematician`是`Professor`的父类，虽然实际上并不是，如[图 6-17](ch06.html#ruby_creates_a_copy_of_the_target_class
    "图 6-17. Ruby 创建目标类的副本并将其设置为被插入模块的父类。")所示。将一个模块预置（prepend）到类中，就像是将模块包含（include）到类中一样。`Mathematician`处于父类链的顶部，往下走时，我们会发现Ruby仍然将`Professor`类设置为`Mathematician`的父类。
- en: But below `Professor` in [Figure 6-17](ch06.html#ruby_creates_a_copy_of_the_target_class
    "Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass
    of the prepended module.") we see something new, the *origin class* for `Mathematician`.
    This is a new copy of `Mathematician` that Ruby creates to make `prepend` work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在[图 6-17](ch06.html#ruby_creates_a_copy_of_the_target_class "图 6-17. Ruby
    创建目标类的副本，并将其设置为被插入模块的父类.")中，`Professor` 下方我们看到了一些新的内容，即 `Mathematician` 的 *原始类*。这是
    Ruby 为使 `prepend` 生效而创建的 `Mathematician` 的新副本。
- en: When you prepend a module, Ruby creates a copy of the target class (called the
    *origin class* internally) and sets it as the superclass of the prepended module.
    Ruby uses the `origin` pointer that we saw in the `rb_classext_struct` structure
    in [Figure 6-1](ch06.html#portion_of_rubyapostrophes_class_str "Figure 6-1. The
    portion of Ruby’s class structures that’s used for modules") and [Figure 6-2](ch06.html#including_a_module_into_a_class-id00020
    "Figure 6-2. Including a module into a class") to track this new origin copy of
    the class. In addition, Ruby moves all of the methods from the original class
    to the origin class, which means that those methods may now be overridden by methods
    with the same name in the prepended module. In [Figure 6-17](ch06.html#ruby_creates_a_copy_of_the_target_class
    "Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass
    of the prepended module.") you can see that Ruby moved the `attr_accessor` method
    down from `Mathematician` to the origin class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `prepend` 插入模块时，Ruby 会创建目标类的副本（内部称为 *原始类*），并将其设置为被插入模块的父类。Ruby 使用我们在[图
    6-1](ch06.html#portion_of_rubyapostrophes_class_str "图 6-1. Ruby 类结构中用于模块的部分")和[图
    6-2](ch06.html#including_a_module_into_a_class-id00020 "图 6-2. 将模块包含进类")中看到的 `origin`
    指针来跟踪这个类的新副本。此外，Ruby 会将原始类中的所有方法移动到原始类中，这意味着这些方法现在可以被具有相同名称的插入模块中的方法重写。在[图 6-17](ch06.html#ruby_creates_a_copy_of_the_target_class
    "图 6-17. Ruby 创建目标类的副本，并将其设置为被插入模块的父类.")中，你可以看到 Ruby 已将 `attr_accessor` 方法从 `Mathematician`
    移动到原始类。
- en: '![Ruby creates a copy of the target class and sets it as the superclass of
    the prepended module.](httpatomoreillycomsourcenostarchimages1854119.png.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 创建目标类的副本，并将其设置为被插入模块的父类。](httpatomoreillycomsourcenostarchimages1854119.png.jpg)'
- en: Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass
    of the prepended module.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-17. Ruby 创建目标类的副本，并将其设置为被插入模块的父类。
- en: 'Experiment 6-1: Modifying a Module After Including It'
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '实验 6-1: 在包含模块后修改模块'
- en: Following a suggestion by Xavier Noria, this experiment will explore what happens
    when you modify a module once it’s been included into a class. We’ll use the same
    `Mathematician` class and the `Professor` module but with different methods, as
    shown in [Example 6-13](ch06.html#another_example_of_including_a_module_in "Example 6-13. Another
    example of including a module into a class").
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Xavier Noria 的建议，本实验将探讨当你修改已被包含到类中的模块时会发生什么。我们将使用相同的 `Mathematician` 类和 `Professor`
    模块，但方法有所不同，如在[示例 6-13](ch06.html#another_example_of_including_a_module_in "示例
    6-13. 另一个将模块包含进类的例子")中所示。
- en: Example 6-13. Another example of including a module into a class
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-13. 另一个将模块包含进类的例子
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time the `Mathematician` class contains the accessor methods at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    for `@first_name` and `@last_name`, and we’ve included the `Professor` module
    again at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). If we inspect
    the methods of a mathematician object, as shown in [Example 6-14](ch06.html#inspecting_the_methods_of_a_mathematicia
    "Example 6-14. Inspecting the methods of a mathematician object"), we should see
    the attribute methods, such as `first_name=` and the `lectures` method from `Professor`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Mathematician` 类包含了用于 `@first_name` 和 `@last_name` 的访问器方法，如下图所示！[](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，我们再次包含了
    `Professor` 模块，如下图所示！[](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。如果我们检查数学家对象的方法，如[示例
    6-14](ch06.html#inspecting_the_methods_of_a_mathematicia "示例 6-14. 检查数学家对象的方法")所示，我们应该看到属性方法，例如
    `first_name=` 和来自 `Professor` 的 `lectures` 方法。
- en: Example 6-14. Inspecting the methods of a mathematician object
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-14. 检查数学家对象的方法
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: No surprise; we see all the methods.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们看到所有方法。
- en: Classes See Methods Added to a Module Later
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类查看后添加到模块的方法
- en: Now let’s add some new methods to the `Professor` module after including it
    into the `Mathematician` class. Does Ruby know that the new methods should be
    added to `Mathematician` as well? Let’s find out by running [Example 6-15](ch06.html#adding_a_new_method_to_professor_after_i
    "Example 6-15. Adding a new method to Professor after including it into Mathematician")
    right after [Example 6-14](ch06.html#inspecting_the_methods_of_a_mathematicia
    "Example 6-14. Inspecting the methods of a mathematician object") finishes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在将`Professor`模块包含到`Mathematician`类之后，再添加一些新方法。Ruby 是否知道这些新方法也应该添加到`Mathematician`类呢？让我们通过在[示例6-15](ch06.html#adding_a_new_method_to_professor_after_i
    "Example 6-15. Adding a new method to Professor after including it into Mathematician")运行后，接着运行[示例6-14](ch06.html#inspecting_the_methods_of_a_mathematicia
    "Example 6-14. Inspecting the methods of a mathematician object")来找出答案。
- en: Example 6-15. Adding a new method to `Professor` after including it into `Mathematician`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-15. 将新方法添加到`Professor`模块，并在其被包含到`Mathematician`后进行修改。
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we get all the methods, including the new `primary_classroom` method that was
    added to `Professor` after it was included into `Mathematician`. No surprise here
    either. Ruby is one step ahead of us.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 我们得到了所有的方法，包括新添加的`primary_classroom`方法，它是在将`Professor`包含进`Mathematician`后添加的。这里也没有惊讶，Ruby总是领先一步。
- en: Classes Don’t See Submodules Included Later
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类看不到稍后包含的子模块
- en: Now for one more test. What if we reopen the `Professor` module and include
    yet another module into it using [Example 6-16](ch06.html#including_a_new_module_into_professor_af
    "Example 6-16. Including a new module into Professor after it was included into
    Mathematician")?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行另一个测试。如果我们重新打开`Professor`模块，并使用[示例6-16](ch06.html#including_a_new_module_into_professor_af
    "Example 6-16. Including a new module into Professor after it was included into
    Mathematician")再将另一个模块包含到其中，会发生什么呢？
- en: Example 6-16. Including a new module into `Professor` after it was included
    into `Mathematician`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-16. 将新模块包含进`Professor`模块，且该模块已被包含进`Mathematician`。
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is getting confusing, so let’s review what we did in [Example 6-13](ch06.html#another_example_of_including_a_module_in
    "Example 6-13. Another example of including a module into a class") and [Example 6-16](ch06.html#including_a_new_module_into_professor_af
    "Example 6-16. Including a new module into Professor after it was included into
    Mathematician"):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得有些混乱，因此让我们回顾一下在[示例6-13](ch06.html#another_example_of_including_a_module_in
    "Example 6-13. Another example of including a module into a class")和[示例6-16](ch06.html#including_a_new_module_into_professor_af
    "Example 6-16. Including a new module into Professor after it was included into
    Mathematician")中所做的操作：
- en: In [Example 6-13](ch06.html#another_example_of_including_a_module_in "Example 6-13. Another
    example of including a module into a class") we included the `Professor` module
    into the `Mathematician` class.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[示例6-13](ch06.html#another_example_of_including_a_module_in "Example 6-13. Another
    example of including a module into a class")中，我们将`Professor`模块包含进了`Mathematician`类。
- en: Then, in [Example 6-16](ch06.html#including_a_new_module_into_professor_af "Example 6-16. Including
    a new module into Professor after it was included into Mathematician") we included
    the `Employee` module into the `Professor` module. Therefore, the methods of the
    `Employee` module should now be available on a mathematician object.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在[示例6-16](ch06.html#including_a_new_module_into_professor_af "Example 6-16. Including
    a new module into Professor after it was included into Mathematician")中，我们将`Employee`模块包含进了`Professor`模块。因此，`Employee`模块的方法现在应该在`mathematician`对象上可用。
- en: 'Let’s see whether Ruby works as expected:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Ruby 是否按照预期工作：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It didn’t work! The `hire_date` method is *not* available in the `fermat` object.
    Including a module into a module already included into a class *does not* affect
    that class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 没有成功！`hire_date`方法在`fermat`对象中*不可用*。将模块包含到已包含模块的类中并不会影响该类。
- en: As we’ve learned how Ruby implements modules, this fact shouldn’t be too hard
    to understand. Including `Employee` into `Professor` changes the `Professor` module,
    not the copy of `Professor` that Ruby created when we included it into `Mathematician`,
    as shown in [Figure 6-18](ch06.html#employee_module_is_included_into_the "Figure 6-18. The
    Employee module is included into the original Professor module, not the included
    copy used by Mathematician.").
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经了解了 Ruby 如何实现模块，这个事实应该不难理解。将`Employee`模块包含进`Professor`模块并不会改变 Ruby 在我们将其包含到`Mathematician`模块时所创建的`Professor`模块副本，正如在[图6-18](ch06.html#employee_module_is_included_into_the
    "Figure 6-18. The Employee module is included into the original Professor module,
    not the included copy used by Mathematician.")中所示。
- en: '![The Employee module is included into the original Professor module, not the
    included copy used by Mathematician.](httpatomoreillycomsourcenostarchimages1854121.png.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Employee 模块被包含到原始的 Professor 模块中，而不是 Mathematician 使用的包含副本。](httpatomoreillycomsourcenostarchimages1854121.png.jpg)'
- en: Figure 6-18. The `Employee` module is included into the original `Professor`
    module, not the included copy used by `Mathematician`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-18. `Employee` 模块被包含到原始的 `Professor` 模块中，而不是 `Mathematician` 使用的包含副本。
- en: Included Classes Share the Method Table with the Original Module
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含的类与原始模块共享方法表
- en: But what about the `primary_classroom` method we added in [Example 6-15](ch06.html#adding_a_new_method_to_professor_after_i
    "Example 6-15. Adding a new method to Professor after including it into Mathematician")?
    How was Ruby able to include the `primary_classroom` method into `Mathematician`
    even though we added it to `Professor` after we included `Professor` into `Mathematician`?
    [Figure 6-18](ch06.html#employee_module_is_included_into_the "Figure 6-18. The
    Employee module is included into the original Professor module, not the included
    copy used by Mathematician.") shows that Ruby created a copy of the `Professor`
    module before we added the new method to it. But how does the `fermat` object
    get the new method?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在 [示例 6-15](ch06.html#adding_a_new_method_to_professor_after_i "示例 6-15.
    向 Professor 添加新方法，之后将其包含到 Mathematician 中") 中添加的 `primary_classroom` 方法呢？即使我们在将
    `Professor` 包含到 `Mathematician` 后才添加了 `primary_classroom` 方法，Ruby 是如何将该方法包含到 `Mathematician`
    中的呢？[图 6-18](ch06.html#employee_module_is_included_into_the "图 6-18. Employee
    模块被包含到原始的 Professor 模块中，而不是 Mathematician 使用的包含副本") 显示 Ruby 在我们向 `Professor` 添加新方法之前，已经创建了
    `Professor` 模块的副本。但那 `fermat` 对象是如何获得这个新方法的呢？
- en: As it turns out, when you include a module, Ruby copies the `RClass` structure,
    not the underlying method table, as shown in [Figure 6-19](ch06.html#ruby_doesnapostrophet_copy_the_method_ta
    "Figure 6-19. Ruby doesn’t copy the method table when you include a module.").
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，当你包含一个模块时，Ruby 复制的是 `RClass` 结构，而不是底层的方法表，如 [图 6-19](ch06.html#ruby_doesnapostrophet_copy_the_method_ta
    "图 6-19. Ruby 不会在包含模块时复制方法表。") 所示。
- en: '![Ruby doesn’t copy the method table when you include a module.](httpatomoreillycomsourcenostarchimages1854123.png.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 不会在包含模块时复制方法表。](httpatomoreillycomsourcenostarchimages1854123.png.jpg)'
- en: Figure 6-19. Ruby doesn’t copy the method table when you include a module.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-19. Ruby 不会在包含模块时复制方法表。
- en: Ruby doesn’t copy the method table for `Professor`. Instead, it simply sets
    `m_tbl` in the new copy of `Professor`, the “included class,” to point to the
    same method table. This means that modifying the method table by reopening the
    module and adding new methods will change both the module and any classes into
    which it was already included.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 不会复制 `Professor` 的方法表。相反，它只是将 `Professor` 的新副本中的 `m_tbl`（即“包含类”）设置为指向相同的方法表。这意味着，通过重新打开模块并添加新方法来修改方法表，将会改变该模块以及任何已经包含该模块的类。
- en: A Close Look at How Ruby Copies Modules
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解 Ruby 如何复制模块
- en: By looking at Ruby’s C source code directly, you’ll gain a precise understanding
    of how Ruby copies modules when you include them and why Ruby behaves as you’ll
    see in this experiment. You’ll find the C function that Ruby uses to make a copy
    of a module in the *class.c* file. [Example 6-17](ch06.html#portion_of_the_rbunderscoreincludeunde
    "Example 6-17. A portion of the rb_include_class_new C function, from class.c")
    shows a portion of the function `rb_include_class_new`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接查看 Ruby 的 C 源代码，你将精确理解 Ruby 在包含模块时如何复制它们，以及为什么 Ruby 会按你在这个实验中看到的行为表现。你可以在
    *class.c* 文件中找到 Ruby 用于复制模块的 C 函数。[示例 6-17](ch06.html#portion_of_the_rbunderscoreincludeunde
    "示例 6-17. rb_include_class_new C 函数的一部分，来自 class.c") 展示了 `rb_include_class_new`
    函数的一部分。
- en: Example 6-17. A portion of the `rb_include_class_new` C function, from *`class.c`*
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-17. `rb_include_class_new` C 函数的一部分，来自 *`class.c`*
- en: '[PRE20]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) Ruby passes in
    `module` (the target module to copy) and `super` (the superclass to use for the
    new copy of `module`). By specifying a particular superclass, Ruby inserts the
    new copy into the superclass chain at a particular place. If you search *class.c*
    for `rb_include_class_new`, you’ll find that Ruby calls it from another C function,
    `include_modules_at`, which handles the complex internal logic that Ruby uses
    to include modules.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 中，Ruby 传入了 `module`（要复制的目标模块）和
    `super`（用于新副本的超类）。通过指定特定的超类，Ruby 将新副本插入到超类链中的特定位置。如果你在 *class.c* 中搜索 `rb_include_class_new`，你会发现
    Ruby 是通过另一个 C 函数 `include_modules_at` 来调用它的，该函数处理了 Ruby 用来包含模块的复杂内部逻辑。
- en: At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) Ruby calls `class_alloc`
    to create a new `RClass` structure and saves a reference to it in `klass`. Notice
    the first parameter to `class_alloc` is the value `T_ICLASS`, which identifies
    the new class as an included class. Ruby uses `T_ICLASS` throughout its C source
    code when dealing with included classes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) Ruby 调用`class_alloc`创建一个新的`RClass`结构，并将其引用保存在`klass`中。请注意，`class_alloc`的第一个参数是值`T_ICLASS`，用于标识新类为一个包含类。在处理包含类时，Ruby在其C源代码中始终使用`T_ICLASS`。
- en: At ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) Ruby copies a
    series of pointers from the original module’s `RClass` structure over to the new
    copy using three C macros that operate on `RClass`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) Ruby 通过三个操作`RClass`的C宏，从原始模块的`RClass`结构复制一系列指针到新副本中。
- en: '`RCLASS_IV_TBL` gets or sets a pointer to the instance variable table.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RCLASS_IV_TBL` 获取或设置指向实例变量表的指针。'
- en: '`RCLASS_CONST_TBL` gets or sets a pointer to the constant variable table.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RCLASS_CONST_TBL` 获取或设置指向常量变量表的指针。'
- en: '`RCLASS_M_TBL` gets or sets a pointer to the method table.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RCLASS_M_TBL` 获取或设置指向方法表的指针。'
- en: 'For example, `RCLASS_IV_TBL(klass) = RCLASS_IV_TBL(module)` sets the instance
    variable table pointer in `klass` (the new copy) to the instance variable pointer
    from `module` (the target module to copy). Now `klass` and `module` use the same
    instance variables. In the same way, `klass` shares constant and method tables
    with `module`. Because they share the same method table, adding a new method to
    `module` also adds it to `klass`. This explains the behavior we saw in [Experiment
    6-1: Modifying a Module After Including It](ch06.html#experiment_6-1_modifying_a_module_after
    "Experiment 6-1: Modifying a Module After Including It"): Adding a method to a
    module also adds it to each class that includes that module.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`RCLASS_IV_TBL(klass) = RCLASS_IV_TBL(module)` 将`klass`（新副本）中的实例变量表指针设置为`module`（要复制的目标模块）中的实例变量指针。现在`klass`和`module`使用相同的实例变量。同样，`klass`与`module`共享常量和方法表。因为它们共享相同的方法表，向`module`添加新方法也会将其添加到`klass`。这解释了我们在[实验6-1：包含模块后修改模块](ch06.html#experiment_6-1_modifying_a_module_after
    "实验6-1：包含模块后修改模块")中看到的行为：向模块添加方法也会将其添加到包含该模块的每个类中。
- en: Also note at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) Ruby
    uses `RCLASS_ORIGIN(module)`, not `module`. Normally `RCLASS_ORIGIN(module)` is
    the same as `module`; however, if you have earlier used `prepend` in `module`,
    then `RCLASS_ORIGIN(module)` instead returns the origin class for `module`. Recall
    that when you call `Module#prepend`, Ruby makes a copy (the origin class) of the
    target module and inserts the copy into the superclass chain. By using `RCLASS_ORIGIN(module)`,
    Ruby gets the original module’s method table, even if you prepended it with a
    different module.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) Ruby 使用`RCLASS_ORIGIN(module)`，而不是`module`。通常`RCLASS_ORIGIN(module)`与`module`相同；但是，如果您之前在`module`中使用了`prepend`，那么`RCLASS_ORIGIN(module)`会返回`module`的原始类。回想一下，当您调用`Module#prepend`时，Ruby会复制（原始类）目标模块并将复制插入到超类链中。通过使用`RCLASS_ORIGIN(module)`，Ruby获取原始模块的方法表，即使您使用不同的模块进行了预先处理。
- en: Finally, at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg) Ruby
    sets the superclass pointer of `klass` to the specified superclass and returns
    it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg) Ruby 将`klass`的超类指针设置为指定的超类并返回它。
- en: Constant Lookup
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量查找
- en: 'We’ve learned about Ruby’s method lookup algorithm and how it searches through
    the superclass chain to find the right method to call. Now we’ll turn our attention
    to a related process: Ruby’s constant lookup algorithm, or the process Ruby uses
    to find a constant value that you refer to in your code.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了Ruby的方法查找算法以及它如何通过超类链搜索找到正确的方法调用。现在我们将把注意力转向一个相关的过程：Ruby的常量查找算法，或者说Ruby用来在代码中查找你引用的常量值的过程。
- en: Clearly method lookup is central to the language, but why study constant lookup?
    As Ruby developers, we don’t use constants very often in our code—certainly not
    as often as we use classes, modules, variables, and blocks.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，方法查找是语言的核心，但为什么要研究常量查找？作为Ruby开发人员，我们在代码中并不经常使用常量——当然不像我们经常使用类、模块、变量和块那样。
- en: One reason is that constants, like modules and classes, are central to the way
    Ruby works internally and to the way we use Ruby. Whenever you define a module
    or class, you also define a constant. And whenever you refer to or use a module
    or class, Ruby has to look up the corresponding constant.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个原因是常量像模块和类一样，是 Ruby 内部工作方式和我们使用 Ruby 的方式的核心。每当你定义一个模块或类时，你也定义了一个常量。而每当你引用或使用一个模块或类时，Ruby
    必须查找对应的常量。
- en: The second reason has to do with the way Ruby finds a constant that you refer
    to in your code. As you may know, Ruby finds constants defined in a superclass,
    but it also finds constants in the surrounding namespace or syntactical scope
    of your program. Studying how Ruby handles syntactical scope leads us to some
    important discoveries about how Ruby works internally.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因与 Ruby 查找你在代码中引用的常量的方式有关。你可能知道，Ruby 会查找在超类中定义的常量，但它也会查找在程序的周围命名空间或语法作用域中的常量。研究
    Ruby 如何处理语法作用域，能帮助我们发现一些关于 Ruby 内部工作方式的重要信息。
- en: Let’s begin by reviewing how constants work in Ruby.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下常量在 Ruby 中是如何工作的。
- en: Finding a Constant in a Superclass
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在超类中查找常量
- en: One way that Ruby searches for the definition of a constant you refer to is
    by using the superclass chain just as it would look for a method definition. [Example 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup
    "Example 6-18. Ruby finds constants you define in a superclass.") shows an example
    of one class finding a constant in its superclass.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 查找你引用的常量定义的一个方式是通过使用超类链，正如它查找方法定义时的方式一样。[示例 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup
    "示例 6-18. Ruby 查找你在超类中定义的常量。")展示了一个类如何在其超类中查找常量的例子。
- en: Example 6-18. Ruby finds constants you define in a superclass.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-18。Ruby 查找你在超类中定义的常量。
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In [Example 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup "Example 6-18. Ruby
    finds constants you define in a superclass.") we define `MyClass` with a single
    constant, `SOME_CONSTANT` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    Then we create `Subclass` and set `MyClass` as a superclass at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    When we print the value of `SOME_CONSTANT`, Ruby uses the same algorithm it uses
    to find a method, as shown in [Figure 6-20](ch06.html#ruby_searches_for_constants_using_the_su
    "Figure 6-20. Ruby searches for constants using the superclass chain, just as
    it does with methods.").
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup "示例 6-18. Ruby
    查找你在超类中定义的常量。")中，我们定义了一个只有一个常量 `SOME_CONSTANT` 的 `MyClass`，位置在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。然后我们创建了
    `Subclass`，并将 `MyClass` 设为超类，位置在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。当我们打印
    `SOME_CONSTANT` 的值时，Ruby 使用了与查找方法相同的算法，正如[图 6-20](ch06.html#ruby_searches_for_constants_using_the_su
    "图 6-20. Ruby 使用超类链查找常量，就像查找方法一样。")所示。
- en: '![Ruby searches for constants using the superclass chain, just as it does with
    methods.](httpatomoreillycomsourcenostarchimages1854125.png.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用超类链查找常量，就像查找方法一样。](httpatomoreillycomsourcenostarchimages1854125.png.jpg)'
- en: Figure 6-20. Ruby searches for constants using the superclass chain, just as
    it does with methods.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-20。Ruby 使用超类链来查找常量，就像查找方法一样。
- en: Here, on the right, you see the code from [Example 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup
    "Example 6-18. Ruby finds constants you define in a superclass.") and, on the
    left, the `RClass` structures that correspond to each of the two classes we created.
    At the top left of the figure, you see `MyClass`, which contains the value of
    `SOME_CONSTANT` in its constants table. Below that is `Subclass`. When we refer
    to `SOME_CONSTANT` from inside `Subclass`, Ruby uses the `super` pointer to find
    `MyClass` and the value of `SOME_CONSTANT`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，右侧显示了来自[示例 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup "示例
    6-18. Ruby 查找你在超类中定义的常量。")的代码，左侧显示了我们创建的两个类对应的 `RClass` 结构。在图的左上角，你可以看到 `MyClass`，它在常量表中包含了
    `SOME_CONSTANT` 的值。下面是 `Subclass`。当我们在 `Subclass` 中引用 `SOME_CONSTANT` 时，Ruby 使用
    `super` 指针查找 `MyClass` 及其 `SOME_CONSTANT` 的值。
- en: How Does Ruby Find a Constant in the Parent Namespace?
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 如何在父命名空间中查找常量？
- en: '[Example 6-19](ch06.html#using_a_constant_defined_in_the_surround "Example 6-19. Using
    a constant defined in the surrounding namespace") shows another way to define
    a constant.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-19](ch06.html#using_a_constant_defined_in_the_surround "示例 6-19. 使用在周围命名空间中定义的常量")展示了另一种定义常量的方法。'
- en: Example 6-19. Using a constant defined in the surrounding namespace
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-19。使用在周围命名空间中定义的常量
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using idiomatic Ruby style, we create a module called `Namespace` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    Then, inside this module, we declare the same `SOME_CONSTANT` value at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    Next, we declare `Subclass` inside `Namespace` at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg),
    and we’re able to refer to and print the value of `SOME_CONSTANT`, just as in
    [Example 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup "Example 6-18. Ruby
    finds constants you define in a superclass.").
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地道的Ruby风格，我们在![图片](httpatomoreillycomsourcenostarchimages1853843.png.jpg)中创建了一个名为`Namespace`的模块。然后，在该模块内，我们在![图片](httpatomoreillycomsourcenostarchimages1853845.png.jpg)中声明了相同的`SOME_CONSTANT`值。接下来，我们在![图片](httpatomoreillycomsourcenostarchimages1853847.png.jpg)中在`Namespace`内声明了`Subclass`，并且我们能够像在[示例
    6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup "示例 6-18. Ruby在超类中找到你定义的常量")中一样引用并打印`SOME_CONSTANT`的值。
- en: But how does Ruby find `SOME_CONSTANT` in [Example 6-19](ch06.html#using_a_constant_defined_in_the_surround
    "Example 6-19. Using a constant defined in the surrounding namespace") when we
    display it at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)? [Figure 6-21](ch06.html#how_does_ruby_find_constants_in_the_surr
    "Figure 6-21. How does Ruby find constants in the surrounding namespace?") shows
    the problem.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们在![图片](httpatomoreillycomsourcenostarchimages1853937.png.jpg)中显示`SOME_CONSTANT`时，Ruby是如何在[示例
    6-19](ch06.html#using_a_constant_defined_in_the_surround "示例 6-19. 使用在周围命名空间中定义的常量")中找到它的呢？[图
    6-21](ch06.html#how_does_ruby_find_constants_in_the_surr "图 6-21. Ruby如何在周围命名空间中找到常量？")展示了这个问题。
- en: '![How does Ruby find constants in the surrounding namespace?](httpatomoreillycomsourcenostarchimages1854127.png.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby如何在周围命名空间中找到常量？](httpatomoreillycomsourcenostarchimages1854127.png.jpg)'
- en: Figure 6-21. How does Ruby find constants in the surrounding namespace?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-21. Ruby如何在周围命名空间中找到常量？
- en: On the left side of this figure are two `RClass` structures, one for the `Namespace`
    module and one for `Subclass`. Notice that `Namespace` is not a superclass of
    `Subclass`; the `super` pointer in `Subclass` refers to the `Object` class, Ruby’s
    default superclass. Then how does Ruby find `SOME_CONSTANT` when we refer to it
    inside of `Subclass`? Somehow Ruby allows you to search up the “namespace chain”
    to find constants. This behavior is called using lexical scope to find a constant.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在该图的左侧有两个`RClass`结构，一个用于`Namespace`模块，另一个用于`Subclass`。注意，`Namespace`并不是`Subclass`的超类；`Subclass`中的`super`指针指向的是`Object`类，即Ruby的默认超类。那么，Ruby是如何在我们引用`Subclass`中的`SOME_CONSTANT`时找到它的呢？某种程度上，Ruby允许你沿着“命名空间链”向上查找常量。这种行为被称为使用词法作用域查找常量。
- en: Lexical Scope in Ruby
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby中的词法作用域
- en: '*Lexical scope* refers to a section of code within the syntactical structure
    of your program, rather than within the superclass hierarchy or some other scheme.
    For example, suppose we use the `class` keyword to define `MyClass`, as shown
    in [Example 6-20](ch06.html#defining_a_class_with_the_class_keyword "Example 6-20. Defining
    a class with the class keyword").'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*词法作用域*指的是程序中语法结构内的一部分代码区域，而不是在超类层次结构或其他某些方案内。例如，假设我们使用`class`关键字定义`MyClass`，如[示例
    6-20](ch06.html#defining_a_class_with_the_class_keyword "示例 6-20. 使用 class 关键字定义类")所示。'
- en: Example 6-20. Defining a class with the `class` keyword
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-20. 使用`class`关键字定义类
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code tells Ruby to create a new copy of the `RClass` structure, but it
    also defines a new scope or syntactical section of your program. This is the area
    between the `class` and `end` keywords, as shown with shading in [Figure 6-22](ch06.html#class_keyword_creates_a_class_and_a
    "Figure 6-22. The class keyword creates a class and a new lexical scope.").
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉Ruby创建`RClass`结构的新副本，但它也定义了程序中的一个新作用域或语法区域。这个区域是`class`和`end`关键字之间的部分，如[图
    6-22](ch06.html#class_keyword_creates_a_class_and_a "图 6-22. `class`关键字创建一个类并引入新的词法作用域")所示。
- en: '![The class keyword creates a class and a new lexical scope.](httpatomoreillycomsourcenostarchimages1854129.png.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![`class`关键字创建类并引入新的词法作用域。](httpatomoreillycomsourcenostarchimages1854129.png.jpg)'
- en: Figure 6-22. The `class` keyword creates a class and a new lexical scope.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-22. `class`关键字创建一个类并引入新的词法作用域。
- en: Think of your Ruby program as a series of scopes, one for each module or class
    that you create and another for the default, top-level lexical scope. To keep
    track of where this new scope lies inside your program’s lexical structure, Ruby
    attaches a couple of pointers to the YARV instruction snippet corresponding to
    the code it compiles inside this new scope, as shown in [Figure 6-23](ch06.html#for_each_snippet_of_compiled_codecomma_r
    "Figure 6-23. For each snippet of compiled code, Ruby uses pointers to track the
    parent lexical scope and the current class or module.").
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![For each snippet of compiled code, Ruby uses pointers to track the parent
    lexical scope and the current class or module.](httpatomoreillycomsourcenostarchimages1854131.png.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Figure 6-23. For each snippet of compiled code, Ruby uses pointers to track
    the parent lexical scope and the current class or module.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows the lexical scope information attached to the right side
    of the Ruby code. There are two important values here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: First, the `nd_next` pointer is set to the parent or surrounding lexical scope—the
    default or top-level scope in this case.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the `nd_clss` pointer indicates which Ruby class or module corresponds
    to this scope. In this example, because we just defined `MyClass` using the `class`
    keyword, Ruby sets the `nd_clss` pointer to the `RClass` structure corresponding
    to `MyClass`.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Constant for a New Class or Module
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you create a class or module, Ruby automatically creates a corresponding
    constant and saves it in the class or module for the parent lexical scope.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to the “namespace” example from [Example 6-19](ch06.html#using_a_constant_defined_in_the_surround
    "Example 6-19. Using a constant defined in the surrounding namespace"). [Figure 6-24](ch06.html#when_you_declare_a_new_classcomma_ruby_c
    "Figure 6-24. When you declare a new class, Ruby creates a new RClass structure
    and defines a new constant set to the new class’s name.") shows what Ruby does
    internally when you create `MyClass` inside `Namespace`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![When you declare a new class, Ruby creates a new RClass structure and defines
    a new constant set to the new class’s name.](httpatomoreillycomsourcenostarchimages1854133.png.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Figure 6-24. When you declare a new class, Ruby creates a new `RClass` structure
    and defines a new constant set to the new class’s name.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'The dashed arrows in this figure show what actions Ruby takes when you create
    a new class or module:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: First, Ruby creates a new `RClass` structure for the new module or class, as
    shown at the bottom.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, Ruby creates a new constant using the new module or class name and saves
    it inside the class corresponding to the parent lexical scope. Ruby sets the value
    of the new constant to be a reference or pointer to the new `RClass` structure.
    In [Figure 6-24](ch06.html#when_you_declare_a_new_classcomma_ruby_c "Figure 6-24. When
    you declare a new class, Ruby creates a new RClass structure and defines a new
    constant set to the new class’s name.") you can see that the `MyClass` constant
    appears in the constants table for the `Namespace` module.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，Ruby 使用新的模块或类名称创建一个新的常量，并将其保存在对应于父词法作用域的类中。Ruby 将新常量的值设置为指向新的 `RClass` 结构的引用或指针。在
    [图 6-24](ch06.html#when_you_declare_a_new_classcomma_ruby_c "图 6-24. 当你声明一个新类时，Ruby
    会创建一个新的 RClass 结构并定义一个新的常量，指向新类的名称。") 中，你可以看到 `MyClass` 常量出现在 `Namespace` 模块的常量表中。
- en: The new class also gets its own new lexical scope, as shown in [Figure 6-25](ch06.html#new_class_also_gets_its_own_lexical_sc
    "Figure 6-25. A new class also gets its own lexical scope, shown here as the second
    shaded rectangle.").
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类也获得了它自己的新的词法作用域，如 [图 6-25](ch06.html#new_class_also_gets_its_own_lexical_sc
    "图 6-25. 新的类也会获得它自己的词法作用域，图中显示为第二个阴影矩形。") 中所示。
- en: '![A new class also gets its own lexical scope, shown here as the second shaded
    rectangle.](httpatomoreillycomsourcenostarchimages1854135.png.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![新类也会获得它自己的词法作用域，图中显示为第二个阴影矩形。](httpatomoreillycomsourcenostarchimages1854135.png.jpg)'
- en: Figure 6-25. A new class also gets its own lexical scope, shown here as the
    second shaded rectangle.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-25. 新的类也会获得它自己的词法作用域，图中显示为第二个阴影矩形。
- en: This figure shows a new shaded rectangle for the new scope. Its `nd_clss` pointer
    is set to the new `RClass` structure for `MyClass`, and its `nd_next` pointer
    is set to the parent scope that corresponds to the `Namespace` module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了新作用域的一个新的阴影矩形。其 `nd_clss` 指针被设置为指向 `MyClass` 的新的 `RClass` 结构，而 `nd_next`
    指针被设置为对应于 `Namespace` 模块的父作用域。
- en: Finding a Constant in the Parent Namespace Using Lexical Scope
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在父命名空间中使用词法作用域查找常量
- en: In [Example 6-21](ch06.html#finding_a_constant_in_the_parent_lexical "Example 6-21. Finding
    a constant in the parent lexical scope (repeated from Example 6-19)") let’s return
    to the example from [Example 6-19](ch06.html#using_a_constant_defined_in_the_surround
    "Example 6-19. Using a constant defined in the surrounding namespace"), which
    prints the value of `SOME_CONSTANT`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 6-21](ch06.html#finding_a_constant_in_the_parent_lexical "示例 6-21. 在父级词法作用域中查找常量（重复自
    示例 6-19)") 中，让我们回到 [示例 6-19](ch06.html#using_a_constant_defined_in_the_surround
    "示例 6-19. 使用在周围命名空间中定义的常量") 的例子，该示例打印 `SOME_CONSTANT` 的值。
- en: Example 6-21. Finding a constant in the parent lexical scope (repeated from
    [Example 6-19](ch06.html#using_a_constant_defined_in_the_surround "Example 6-19. Using
    a constant defined in the surrounding namespace"))
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-21. 在父级词法作用域中查找常量（重复自 [示例 6-19](ch06.html#using_a_constant_defined_in_the_surround
    "示例 6-19. 使用在周围命名空间中定义的常量")）
- en: '[PRE24]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In [Figure 6-20](ch06.html#ruby_searches_for_constants_using_the_su "Figure 6-20. Ruby
    searches for constants using the superclass chain, just as it does with methods.")
    we saw how Ruby iterates over `super` pointers to find a constant from a superclass.
    But in [Figure 6-21](ch06.html#how_does_ruby_find_constants_in_the_surr "Figure 6-21. How
    does Ruby find constants in the surrounding namespace?") we saw that Ruby couldn’t
    use `super` pointers to find `SOME_CONSTANT` in this example because `Namespace`
    is not a superclass of `MyClass`. Instead, as [Figure 6-26](ch06.html#ruby_can_find_someunderscoreconstant_in
    "Figure 6-26. Ruby can find SOME_CONSTANT in the parent lexical scope using the
    nd_next and nd_clss pointers.") shows, Ruby can use the `nd_next` pointers to
    iterate up through your program’s lexical scopes in search of constant values.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6-20](ch06.html#ruby_searches_for_constants_using_the_su "图 6-20. Ruby
    通过父类链查找常量，就像它查找方法一样。") 中，我们看到了 Ruby 如何通过 `super` 指针遍历以查找来自父类的常量。但是在 [图 6-21](ch06.html#how_does_ruby_find_constants_in_the_surr
    "图 6-21. Ruby 如何在周围的命名空间中查找常量？") 中，我们看到 Ruby 无法使用 `super` 指针查找 `SOME_CONSTANT`，因为
    `Namespace` 不是 `MyClass` 的父类。相反，如 [图 6-26](ch06.html#ruby_can_find_someunderscoreconstant_in
    "图 6-26. Ruby 可以通过 `nd_next` 和 `nd_clss` 指针在父级词法作用域中找到 SOME_CONSTANT。") 所示，Ruby
    可以使用 `nd_next` 指针向上遍历程序的词法作用域，以查找常量值。
- en: '![Ruby can find SOME_CONSTANT in the parent lexical scope using the nd_next
    and nd_clss pointers.](httpatomoreillycomsourcenostarchimages1854137.png.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 可以通过 `nd_next` 和 `nd_clss` 指针在父级词法作用域中找到 SOME_CONSTANT。](httpatomoreillycomsourcenostarchimages1854137.png.jpg)'
- en: Figure 6-26. Ruby can find `SOME_CONSTANT` in the parent lexical scope using
    the `nd_next` and `nd_clss` pointers.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'By following the arrows in this figure, you can see how the `p SOME_CONSTANT`
    command at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) in [Example 6-21](ch06.html#finding_a_constant_in_the_parent_lexical
    "Example 6-21. Finding a constant in the parent lexical scope (repeated from Example 6-19)")
    works:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: First, Ruby looks for the value of `SOME_CONSTANT` in the current scope’s class,
    `MyClass`. In [Figure 6-26](ch06.html#ruby_can_find_someunderscoreconstant_in
    "Figure 6-26. Ruby can find SOME_CONSTANT in the parent lexical scope using the
    nd_next and nd_clss pointers.") the current scope contains the `p SOME_CONSTANT`
    code. You can see how Ruby finds the current scope’s class on the right using
    the `nd_clss` pointer. Here, `MyClass` has nothing in its constants table.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, Ruby finds the parent lexical scope using the `nd_next` pointer, moving
    up [Figure 6-26](ch06.html#ruby_can_find_someunderscoreconstant_in "Figure 6-26. Ruby
    can find SOME_CONSTANT in the parent lexical scope using the nd_next and nd_clss
    pointers.").
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby repeats the process, searching the current scope’s class using the `nd_clss`
    pointer. This time the current scope’s class is the `Namespace` module, at the
    top right of [Figure 6-26](ch06.html#ruby_can_find_someunderscoreconstant_in "Figure 6-26. Ruby
    can find SOME_CONSTANT in the parent lexical scope using the nd_next and nd_clss
    pointers."). Now Ruby finds `SOME_CONSTANT` in `Namespace`’s constants table.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby’s Constant Lookup Algorithm
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flowchart in [Figure 6-27](ch06.html#part_of_rubyapostrophes_constant_lookup
    "Figure 6-27. Part of Ruby’s constant lookup algorithm") summarizes how Ruby iterates
    over the lexical scope chain while looking for constants.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Part of Ruby’s constant lookup algorithm](httpatomoreillycomsourcenostarchimages1854139.png.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: Figure 6-27. Part of Ruby’s constant lookup algorithm
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this figure is very similar to [Figure 6-3](ch06.html#rubyapostrophes_method_lookup_al-id00021
    "Figure 6-3. Ruby’s method lookup algorithm"). Ruby iterates over the linked list
    formed by the `nd_next` pointers in each lexical scope while looking for a constant,
    just as it iterates over the `super` pointers while looking for a method. Ruby
    uses superclasses to find methods and parent lexical scopes to find constants.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: However, this is just part of Ruby’s constant lookup algorithm. As we saw earlier
    in [Figure 6-20](ch06.html#ruby_searches_for_constants_using_the_su "Figure 6-20. Ruby
    searches for constants using the superclass chain, just as it does with methods."),
    Ruby also looks through superclasses for constants.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 6-2: Which Constant Will Ruby Find First?'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve just learned that Ruby iterates over a linked list of lexical scopes in
    order to look up constant values. However, we saw earlier in [Figure 6-20](ch06.html#ruby_searches_for_constants_using_the_su
    "Figure 6-20. Ruby searches for constants using the superclass chain, just as
    it does with methods.") that Ruby also uses the superclass chain to look up constants.
    Let’s use [Example 6-22](ch06.html#does_ruby_search_the_lexical_scope_chain "Example 6-22. Does
    Ruby search the lexical scope chain first? Or does it search the superclass chain
    first? (find-constant.rb)") to see how this works in more detail.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-22. Does Ruby search the lexical scope chain first? Or does it search
    the superclass chain first? *(find-constant.rb)*
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice here that I’ve defined the constant `FIND_ME` twice—at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Which constant
    will Ruby find first? Will Ruby first iterate over the lexical scope chain and
    find the constant at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)?
    Or will it iterate over the superclass chain and find the constant value at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find out! When we run [Example 6-22](ch06.html#does_ruby_search_the_lexical_scope_chain
    "Example 6-22. Does Ruby search the lexical scope chain first? Or does it search
    the superclass chain first? (find-constant.rb)"), we get the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see that Ruby looks through the lexical scope chain first.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s comment out the second definition at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    in [Example 6-22](ch06.html#does_ruby_search_the_lexical_scope_chain "Example 6-22. Does
    Ruby search the lexical scope chain first? Or does it search the superclass chain
    first? (find-constant.rb)") and try the experiment again:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we run the modified [Example 6-22](ch06.html#does_ruby_search_the_lexical_scope_chain
    "Example 6-22. Does Ruby search the lexical scope chain first? Or does it search
    the superclass chain first? (find-constant.rb)"), we get the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because now there is only one definition of `FIND_ME`, Ruby finds it by iterating
    over the superclass chain.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Ruby’s Actual Constant Lookup Algorithm
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, things aren’t quite so simple; there are some other quirks in
    Ruby’s behavior with regard to constants. [Figure 6-28](ch06.html#high-level_summary_of_rubyapostrophes
    "Figure 6-28. A high-level summary of Ruby’s constant lookup algorithm") is a
    simplified flowchart showing Ruby’s entire constant lookup algorithm.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![A high-level summary of Ruby’s constant lookup algorithm](httpatomoreillycomsourcenostarchimages1854141.png.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: Figure 6-28. A high-level summary of Ruby’s constant lookup algorithm
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: At the top, you can see that Ruby begins by iterating up the lexical scope chain,
    as we saw in [Example 6-22](ch06.html#does_ruby_search_the_lexical_scope_chain
    "Example 6-22. Does Ruby search the lexical scope chain first? Or does it search
    the superclass chain first? (find-constant.rb)"). Ruby always finds constants,
    including classes or modules, that are defined in a parent lexical scope. However,
    as Ruby iterates up the scope chain, it looks to see whether you used the `autoload`
    keyword, which instructs it to open and read in a new code file if a given constant
    is undefined. (The Rails framework uses `autoload` to allow you to load models,
    controllers, and other Rails objects without having to use `require` explicitly.)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: If Ruby loops through the entire lexical scope chain without finding the given
    constant or a corresponding `autoload` keyword, it then iterates up the superclass
    chain, as we saw in [Example 6-18](ch06.html#ruby_finds_constants_you_define_in_a_sup
    "Example 6-18. Ruby finds constants you define in a superclass."). This allows
    you to load constants defined in a superclass. Ruby once again honors any `autoload`
    keyword that might exist in any of those superclasses, loading an additional file
    if necessary.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if all else fails and the constant still isn’t found, Ruby calls the
    `const_missing` method on your module if you provided one.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we’ve learned two very different ways to look at your Ruby program.
    On the one hand, you can organize your code by class and superclass, and on the
    other, you can organize it by lexical scope. We saw how internally Ruby uses different
    sets of C pointers to keep track of these two trees as it executes your program.
    The `super` pointers found in the `RClass` structures form the superclass tree,
    while the `nd_next` pointers from the lexical scope structures form the namespace
    or lexical scope tree.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'We studied two important algorithms that use these trees: how Ruby looks up
    methods and constants. Ruby uses the class tree to find the methods that your
    code (and Ruby’s own internal code) calls. Similarly, Ruby uses both the lexical
    scope tree and the superclass hierarchy to find constants that your code refers
    to. Understanding the method and constant lookup algorithms is essential. They
    allow you to design your program and organize your code using these two trees
    in a way that is appropriate for the problem you are trying to solve.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, these two organizational schemes seem completely orthogonal,
    but in fact they are closely related by the way Ruby’s classes behave. When you
    create a class or module, you add both to the superclass and lexical scope hierarchy,
    and when you refer to a class or superclass, you instruct Ruby to look up a particular
    constant using the lexical scope tree.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
