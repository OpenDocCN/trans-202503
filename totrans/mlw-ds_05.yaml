- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**SHARED CODE ANALYSIS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享代码分析**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Suppose you discovered a new malware sample on your network. How would you begin
    to analyze it? You could submit it to a multi-engine antivirus scanner such as
    VirusTotal to learn what malware family it belongs to. However, such results are
    often unclear and ambiguous, because engines often label the malware in generic
    terms like “agent” that mean nothing. You could also run the sample through CuckooBox
    or some other malware sandbox to get a limited report on the malware sample’s
    callback servers and behaviors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在网络上发现了一个新的恶意软件样本。你会如何开始分析它？你可以将它提交给一个多引擎的病毒扫描器，如VirusTotal，来了解它属于哪个恶意软件家族。然而，这样的结果往往不清晰且含糊，因为引擎通常使用“代理”等通用术语来标记恶意软件，而这些术语没有实际意义。你也可以通过CuckooBox或其他恶意软件沙箱运行该样本，以获得该恶意软件样本回调服务器和行为的有限报告。
- en: When these approaches don’t provide enough information, you may need to reverse-engineer
    the sample. At this stage, shared code analysis can dramatically improve your
    workflow. By revealing which previously analyzed samples the new malware sample
    is similar to, and thus revealing the code they share, shared code analysis allows
    you to reuse your previous analyses on new malware so that you’re not starting
    from scratch. Understanding where this previously seen malware came from can also
    help you figure out who may have deployed the malware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些方法没有提供足够的信息时，你可能需要对样本进行逆向工程。在这个阶段，共享代码分析可以显著改善你的工作流程。通过揭示新恶意软件样本与哪些之前分析过的样本相似，从而揭示它们共享的代码，共享代码分析使你能够在新恶意软件上重用以前的分析结果，避免从头开始。了解这些之前见过的恶意软件来自哪里，也有助于你弄清楚是谁可能部署了这些恶意软件。
- en: '*Shared code analysis*, also called *similarity analysis*, is the process by
    which we compare two malware samples by estimating the percentage of precompilation
    source code they share. It differs from shared attribute analysis, which compares
    malware samples based on their external attributes (the desktop icons they use,
    for example, or the servers they call out to).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*共享代码分析*，也叫*相似性分析*，是通过估算两个恶意软件样本共享的预编译源代码的百分比来比较它们的过程。它不同于共享属性分析，后者是根据恶意软件样本的外部属性（例如，它们使用的桌面图标或它们调用的服务器）进行比较的。'
- en: In reverse engineering, shared code analysis helps identify samples that can
    be analyzed *together* (because they were generated from the same malware toolkit
    or are different versions of the same malware family), which can determine whether
    the same developers could have been responsible for a group of malware samples.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在逆向工程中，共享代码分析有助于识别可以一起分析的样本（因为它们是由相同的恶意软件工具包生成的，或是同一恶意软件家族的不同版本），这可以判断是否是同一开发者可能负责了一组恶意软件样本。
- en: Consider the output shown in [Listing 5-1](ch05.xhtml#ch05list1), which comes
    from a program you’ll build later in this chapter to illustrate the value of malware
    shared code analysis. It shows previously seen samples that may share code with
    the new sample as well as comments made on those older samples.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[清单5-1](ch05.xhtml#ch05list1)中的输出，这来自于你将在本章稍后构建的一个程序，用于说明恶意软件共享代码分析的价值。它显示了与新样本可能共享代码的以前见过的样本，以及对那些旧样本所做的评论。
- en: '![image](../images/f0060-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0060-01.jpg)'
- en: '*Listing 5-1: The results of basic shared code analysis*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-1：基本共享代码分析的结果*'
- en: Given a new sample, shared code estimation allows us to see, within seconds,
    which samples it likely shares code with and what we know about those samples.
    In this example, it reveals that a very similar sample is from a known APT, or
    *advanced persistent threat*, thus providing immediate context for this new malware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个新样本，共享代码估算可以让我们在几秒钟内看到该样本可能与哪些样本共享代码，并且了解我们已知的这些样本的信息。在这个例子中，它揭示了一个非常相似的样本来自一个已知的APT（*高级持续性威胁*），从而为这个新恶意软件提供了即时的背景信息。
- en: We can also visualize sample shared code relationships using network visualization,
    which you learned about in [Chapter 4](ch04.xhtml#ch04). For example, [Figure
    5-1](ch05.xhtml#ch05fig1) shows a network of shared code relationships between
    samples in an advanced persistent threat dataset.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用网络可视化来展示样本共享代码关系，这在[第4章](ch04.xhtml#ch04)中你已学到。例如，[图5-1](ch05.xhtml#ch05fig1)展示了一个先进持续威胁数据集中的样本共享代码关系网络。
- en: 'As you can see from the visualization, automated shared code analysis techniques
    can quickly uncover the existence of malware families that would have taken days
    or weeks to discover through manual analysis. In this chapter, you’ll learn to
    use these techniques to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从可视化中可以看出，自动化共享代码分析技术可以快速揭示恶意软件家族的存在，而这些家族通过手动分析可能需要几天或几周才能发现。在本章中，你将学习使用这些技术来完成以下任务：
- en: Identify new malware families that come from the same malware toolkits or were
    written by the same attackers.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别来自相同恶意软件工具包或由相同攻击者编写的新恶意软件家族。
- en: Determine code similarity between a new sample and previously seen samples.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定一个新样本与之前见过的样本之间的代码相似性。
- en: Visualize malware relationships to better understand code-sharing patterns between
    malware samples and to communicate your results to others.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化恶意软件关系，更好地理解恶意软件样本之间的代码共享模式，并将你的结果传达给他人。
- en: Use two proof-of-concept tools I built for this book that implement these ideas
    and allow you to see malware shared code relationships.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我为本书开发的两个概念验证工具，这些工具实现了这些想法，允许你查看恶意软件共享的代码关系。
- en: '![image](../images/f0061-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0061-01.jpg)'
- en: '*Figure 5-1: An example of the kind of visualization you will learn to create
    in this chapter, showing shared code relationships between some of the APT1 samples*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：本章中你将学习创建的一种可视化示例，展示了一些APT1样本之间共享的代码关系*'
- en: First, I introduce the test malware samples you’ll be using in this chapter,
    which are the PLA APT1 samples from [Chapter 4](ch04.xhtml#ch04) and an assortment
    of crimeware samples. Then, you learn about mathematical similarity comparison
    and the concept of the *Jaccard index*, a set-theoretic method for comparing malware
    samples in terms of their shared features. Next, I introduce the concept of features
    to show how you can use them in conjunction with the Jaccard index to approximate
    the amount of code two malware samples share. You also learn how to evaluate malware
    features in terms of their usefulness. Finally, we create visualizations of malware
    code sharing at multiple scales, as shown in [Figure 5-1](ch05.xhtml#ch05fig1),
    by leveraging your knowledge of network visualization from [Chapter 4](ch04.xhtml#ch04).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我介绍一下你将在本章中使用的测试恶意软件样本，它们是来自[第 4 章](ch04.xhtml#ch04)的PLA APT1样本以及一组犯罪软件样本。然后，你将了解数学相似性比较和*Jaccard指数*的概念，这是一种基于集合论的方法，用于根据共享特征比较恶意软件样本。接下来，我介绍特征的概念，展示如何将它们与Jaccard指数结合使用，以近似两个恶意软件样本之间共享的代码量。你还将学习如何根据它们的有用性来评估恶意软件特征。最后，我们通过利用你在[第
    4 章](ch04.xhtml#ch04)中学习的网络可视化知识，创建多个尺度上的恶意软件代码共享可视化，如[图 5-1](ch05.xhtml#ch05fig1)所示。
- en: '**MALWARE SAMPLES USED IN THIS CHAPTER**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章使用的恶意软件样本**'
- en: In this chapter, we use real-world malware families that share significant amounts
    of code with one another to do our experiments. These datasets are available thanks
    to Mandiant and Mila Parkour, who curated these samples and made them available
    to the research community. In reality, however, you might not know what family
    a malware sample belongs to, or to what degree your new malware samples are similar
    to previously seen samples. But going through examples where we *d* know will
    be good practice, because it allows us to verify that our automated inferences
    of sample similarity line up with our knowledge of which samples actually belong
    in the same group.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了现实世界中的恶意软件家族，这些家族之间有大量共享的代码，来进行实验。这些数据集得益于Mandiant和Mila Parkour，他们策划了这些样本并将其提供给研究社区。然而，实际上，你可能不知道一个恶意软件样本属于哪个家族，或者你的新恶意软件样本与之前见过的样本的相似性有多大。但通过使用我们*已经知道*的示例进行练习会是一个很好的方法，因为这样可以验证我们自动化的样本相似性推断是否与我们关于哪些样本实际上属于同一组的知识一致。
- en: The first samples come from the APT1 dataset we used in [Chapter 4](ch04.xhtml#ch04)
    to demonstrate shared resource analysis. The other samples consist of thousands
    of crimeware malware samples developed by criminals to steal people’s credit cards,
    turn their computers into zombie hosts hooked into botnets, and so on. These are
    real-world samples sourced from a commercial malware feed provided as a paid service
    for threat intelligence researchers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个样本来自我们在[第 4 章](ch04.xhtml#ch04)中使用的APT1数据集，展示了共享资源分析。其他样本则由成千上万的犯罪软件样本组成，这些样本由犯罪分子开发，用于窃取人们的信用卡，将他们的计算机转变为僵尸主机并加入到僵尸网络中，等等。这些是来自商业恶意软件数据源的现实世界样本，这些服务是付费提供给威胁情报研究人员的。
- en: To identify their family names, I have input each sample into the Kaspersky
    antivirus engine. Kaspersky was able to classify 30,104 of these samples with
    robust hierarchical classifications (such as *trojan.win32.jorik.skor.akr*, indicating
    the *jorik.skor* family), assigned a class of “unknown” to 41,830 samples, and
    assigned generic labels (such as, generically, “win32 Trojan”) to the remaining
    28,481 samples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定它们的家族名称，我将每个样本输入到卡巴斯基的杀毒引擎中。卡巴斯基成功地将这些样本中的30,104个样本进行了稳健的层次分类（例如，*trojan.win32.jorik.skor.akr*，表示*jorik.skor*家族），将41,830个样本归类为“未知”，并将剩余的28,481个样本分配了通用标签（例如，通用的“win32
    Trojan”）。
- en: Because of the inconsistency of the Kaspersky labels (some Kaspersky label groupings,
    such as the jorik family, represent a very diffuse range of malware, whereas others,
    such as webprefix, represent a very specific set of variants) and the fact that
    Kaspersky often misses or mislabels malware, I selected seven malware classes
    that Kaspersky detects with high confidence. Specifically, these include the dapato,
    pasta, skor, vbna, webprefix, xtoober, and zango families.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于卡巴斯基标签的不一致性（某些卡巴斯基标签分组，如jorik家族，代表着范围非常广泛的恶意软件，而其他标签，如webprefix，则代表特定的一组变种），以及卡巴斯基经常漏掉或误标恶意软件，我选择了卡巴斯基能够高置信度检测到的七个恶意软件类别。具体来说，这些类别包括dapato、pasta、skor、vbna、webprefix、xtoober和zango家族。
- en: '**Preparing Samples for Comparison by Extracting Features**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过提取特征为比较做准备**'
- en: 'How do we even begin to think about estimating the amount of code two malicious
    binaries may have shared before they were compiled by attackers? There are many
    ways one might consider approaching this problem, but in the hundreds of computer
    science research papers that have been published on the topic, a common theme
    has emerged: to estimate the amount of shared code between binaries, we group
    malware samples into “bags of features” before comparing.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何开始思考估算两个恶意二进制文件在被攻击者编译之前可能共享的代码量呢？有许多方法可以考虑解决这个问题，但在成百上千篇已发布的计算机科学研究论文中，出现了一个共同的主题：为了估算二进制文件之间共享的代码量，我们先将恶意软件样本分组为“特征袋”，然后进行比较。
- en: By *features* I mean any malware attribute we might possibly want to consider
    in estimating the code similarity between samples. For example, the features we
    use could be the printable strings we can extract from the binaries. Instead of
    thinking of the samples as an interconnected system of functions, dynamic library
    imports, and so on, we think of malware as a bag of independent features for mathematical
    convenience (for example, a set of strings that have been extracted from the malware).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*特征*是指我们在估算样本之间代码相似性时，可能考虑的任何恶意软件属性。例如，我们使用的特征可以是从二进制文件中提取的可打印字符串。与其将样本视为一个相互关联的功能系统、动态库导入等，我们更倾向于从数学便利的角度将恶意软件看作一个由独立特征组成的集合（例如，从恶意软件中提取的一组字符串）。'
- en: '***How Bag of Features Models Work***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特征袋模型如何工作***'
- en: To understand how a bag of features works, consider a Venn diagram between two
    malware samples, as shown in [Figure 5-2](ch05.xhtml#ch05fig2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解特征袋如何工作，考虑一下两个恶意软件样本之间的维恩图，如[图5-2](ch05.xhtml#ch05fig2)所示。
- en: Here, sample A and sample B are shown as bags of features (features are represented
    as ellipses inside the Venn diagram). We can compare them by examining which features
    are shared between the two samples. Computing the overlap between two sets of
    features is fast, and can be used to compare malware samples’ similarity based
    on arbitrary features that we come up with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，样本A和样本B被显示为特征集合（特征在维恩图中用椭圆表示）。我们可以通过检查两个样本之间共享的特征来进行比较。计算两个特征集合之间的重叠非常快速，可以用于根据我们定义的任意特征比较恶意软件样本的相似性。
- en: For example, when dealing with packed malware, we may want to use features based
    on malware dynamic run logs since running malware in a sandbox is a way to get
    malware to unpack itself. In other cases, we may use strings extracted from the
    static malware binary to perform the comparison.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在处理打包的恶意软件时，我们可能希望使用基于恶意软件动态运行日志的特征，因为将恶意软件运行在沙箱中是一种让恶意软件自解包的方法。在其他情况下，我们可能会使用从静态恶意软件二进制文件中提取的字符串来执行比较。
- en: '![image](../images/f0063-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0063-01.jpg)'
- en: '*Figure 5-2: An illustration of the “bag of features” model for malware code
    sharing analysis*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2：用于恶意软件代码共享分析的“特征袋”模型示意图*'
- en: In the case of dynamic malware analysis, we may want to compare samples based
    not just on *what* behaviors they share but also on the order in which they express
    behaviors, or what we call their *sequences* of behaviors. A common way to incorporate
    sequence information into malware sample comparisons is to extend the bag of features
    model to accommodate sequential data using N-grams.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态恶意软件分析中，我们可能不仅希望基于它们共享的*行为*来比较样本，还希望根据它们表达行为的顺序来比较，或者我们所称之为它们的*行为序列*。将序列信息纳入恶意软件样本比较的一种常见方法是扩展特征集模型，以适应使用N-grams的顺序数据。
- en: '***What are N-Grams?***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***什么是N-Grams?***'
- en: An *N-gram* is a subsequence of events that has a certain length, *N*, of some
    larger sequence of events. We extract this subsequence from a larger sequence
    by sliding a window over the sequential data. In other words, we get N-grams by
    iterating over a sequence and, at each step, recording the subsequence from the
    event at index *i* to the event at index *i* + *N* – 1, as shown in [Figure 5-3](ch05.xhtml#ch05fig3).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*N-gram*是指具有某个特定长度*N*的事件子序列，它是从一个更大的事件序列中提取出来的。我们通过在顺序数据上滑动窗口来提取这个子序列。换句话说，我们通过迭代序列，在每一步记录从事件索引*i*到事件索引*i*
    + *N* - 1的子序列，如[图5-3](ch05.xhtml#ch05fig3)所示。'
- en: 'In [Figure 5-3](ch05.xhtml#ch05fig3), the sequence of integers (1,2,3,4,5,6,7)
    is translated into five different subsequences of length 3: (1,2,3), (2,3,4),
    (3,4,5), (4,5,6), (5,6,7).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图5-3](ch05.xhtml#ch05fig3)中，整数序列（1,2,3,4,5,6,7）被转换为五个不同的长度为3的子序列：（1,2,3），（2,3,4），（3,4,5），（4,5,6），（5,6,7）。
- en: 'Of course, we can do this with any sequential data. For example, using an N-gram
    word length of 2, the sentence “how now brown cow” yields the following subsequences:
    “how now”, “now brown”, and “brown cow.” In malware analysis, we would extract
    N-grams of sequential API calls that a malware sample made. Then we would represent
    the malware as a bag of features and use N-gram features to compare the malware
    sample to some other malware sample’s N-grams, thereby incorporating sequence
    information into the bag of features comparison model.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以对任何顺序数据执行此操作。例如，使用N-gram的词长为2，句子“how now brown cow”会生成以下子序列：“how now”，“now
    brown”和“brown cow”。在恶意软件分析中，我们会提取恶意软件样本所做的API调用的N-grams。然后，我们将恶意软件表示为一组特征，并使用N-gram特征将恶意软件样本与其他恶意软件样本的N-grams进行比较，从而将序列信息纳入特征集比较模型中。
- en: '![image](../images/f0064-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0064-01.jpg)'
- en: '*Figure 5-3: A visual explanation of how we can extract N-grams from malware’s
    assembly instructions and dynamic API call sequences, where* N *= 3*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-3：一个可视化的解释，展示我们如何从恶意软件的汇编指令和动态API调用序列中提取N-grams，其中*N*= 3*'
- en: Including sequence information in our comparison of malware samples has advantages
    and disadvantages. The advantage is that when order matters in the comparison
    (for example, when we care that API call A was observed before API call B, which
    was observed before API call C), it allows us to capture order, but when order
    is superfluous (for example, malware randomizing the order of API calls A, B,
    and C on every run), it can actually make our shared code estimation much worse.
    Deciding whether to include order information in our malware shared code estimation
    work depends on what kind of malware we’re working with, and requires that we
    experiment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们比较恶意软件样本时，包含序列信息有其优缺点。优点是当顺序在比较中很重要时（例如，当我们关心API调用A发生在API调用B之前，而B又发生在API调用C之前时），它允许我们捕捉到顺序，但当顺序是多余的（例如，恶意软件在每次运行时随机化API调用A、B和C的顺序时），它实际上可能使我们对共享代码的估计变得更差。是否在恶意软件共享代码估计中包含顺序信息，取决于我们处理的是哪种恶意软件，并且需要进行实验。
- en: '**Using the Jaccard Index to Quantify Similarity**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Jaccard指数量化相似度**'
- en: 'Once you’ve represented a malware sample as a bag of features, you’ll need
    to measure the degree of similarity between that sample’s bag of features and
    some other sample’s bag of features. To estimate the extent of code sharing between
    two malware samples, we use a *similarity function*, which should have the following
    properties:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将恶意软件样本表示为一组特征，你就需要衡量该样本的特征集与其他样本特征集之间的相似度。为了估计两个恶意软件样本之间的代码共享程度，我们使用一个*相似度函数*，该函数应具有以下属性：
- en: It yields a normalized value such that all similarity comparisons between pairs
    of malware samples can be placed on a common scale. By convention, the function
    should yield a value ranging from 0 (no code sharing) to 1 (samples share 100
    percent of their code).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它产生一个归一化值，使得所有恶意软件样本之间的相似度比较可以置于一个共同的尺度上。按照惯例，该函数的结果应在0（没有代码共享）到1（样本共享100%的代码）之间。
- en: The function should help us make accurate estimates of code sharing between
    two samples (we can determine this empirically through experimentation).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数应帮助我们准确估计两个样本之间的代码共享情况（我们可以通过实验经验性地确定这一点）。
- en: We should be able to easily understand why the function models code similarity
    well (it should not be a complicated mathematical black box that takes a lot of
    effort to understand or explain).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够轻松理解为什么该函数能够很好地建模代码相似性（它不应是一个复杂的数学黑箱，需要大量精力才能理解或解释）。
- en: The *Jaccard index* is a simple function that has these properties. In fact,
    even though other mathematical approaches to code similarity estimation have been
    tried in the security research community (for example, cosine distance, L1 distance,
    Euclidean [L2] distance, and so on), the Jaccard index has emerged as the most
    widely adopted—and for good reason. It simply and intuitively expresses the degree
    of overlap between two sets of malware features, giving us the percentage of unique
    features common to both of the two sets normalized by the percentage of unique
    features that exist in either set.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jaccard指数*是一个简单的函数，具有这些特性。事实上，尽管在安全研究领域曾尝试过其他数学方法来估计代码相似性（例如余弦距离、L1距离、欧几里得[L2]距离等），但Jaccard指数已成为最广泛采用的——并且有充分的理由。它简单直观地表达了两组恶意软件特征之间的重叠程度，给出了两组中共同的独特特征的百分比，经过归一化后，再与任何一组中存在的独特特征的百分比相比较。'
- en: '[Figure 5-4](ch05.xhtml#ch05fig4) illustrates examples of Jaccard index values.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](ch05.xhtml#ch05fig4)展示了Jaccard指数值的示例。'
- en: '![image](../images/f0065-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0065-01.jpg)'
- en: '*Figure 5-4: A visual illustration of the idea behind the Jaccard index*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：Jaccard指数背后的概念的视觉示意图*'
- en: This illustrates four pairs of malware features extracted from four pairs of
    malware samples. Each image shows the features shared between the two sets, the
    features not shared between the two sets, and the resulting Jaccard index for
    the given pair of malware samples and associated features. You can see that the
    Jaccard index between the samples is simply the number of features shared between
    the samples divided by the total number of features drawn in the Venn diagram.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了从四对恶意软件样本中提取的四组恶意软件特征。每张图展示了两组之间共享的特征、未共享的特征以及给定恶意软件样本对和相关特征的Jaccard指数。你可以看到，样本之间的Jaccard指数就是共享特征的数量除以Venn图中绘制的特征总数。
- en: '**Using Similarity Matrices to Evaluate Malware Shared Code Estimation Methods**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用相似度矩阵评估恶意软件共享代码估计方法**'
- en: 'Let’s discuss four methods for determining whether two malware samples come
    from the same family: instruction sequence-based similarity, strings-based similarity,
    Import Address Table–based similarity, and dynamic API call–based similarity.
    To compare these four methods, we’ll use a *similarity matrix* visualization technique.
    Our goal here will be to compare the relative strengths and weaknesses of each
    method in terms of its ability to illuminate shared code relationships between
    samples.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论四种确定两个恶意软件样本是否来自同一家族的方法：基于指令序列的相似性、基于字符串的相似性、基于导入地址表的相似性和基于动态API调用的相似性。为了比较这四种方法，我们将使用*相似度矩阵*可视化技术。我们的目标是比较每种方法在揭示样本之间共享代码关系方面的相对优缺点。
- en: To get started, let’s go over the concept of a similarity matrix. [Figure 5-5](ch05.xhtml#ch05fig5)
    compares an imaginary set of four malware samples using a similarity matrix.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下相似度矩阵的概念。[图 5-5](ch05.xhtml#ch05fig5)使用相似度矩阵对四个虚拟恶意软件样本进行了比较。
- en: '![image](../images/f0066-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0066-01.jpg)'
- en: '*Figure 5-5: An illustration of a notional similarity matrix*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：一个假设的相似度矩阵示意图*'
- en: This matrix allows you to see the similarity relationship between all samples.
    You can see that some space is wasted in this matrix. For example, we don’t care
    about the similarities represented in shaded boxes, as these entries just contain
    comparisons between a given sample and itself. You can also see that the information
    on either side of the shaded boxes is repeated, so you only need to look at one
    or the other.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵允许你看到所有样本之间的相似性关系。你可以看到这个矩阵中有一些空间被浪费了。例如，我们不关心阴影框中表示的相似性，因为这些条目只是比较了一个样本与其自身的相似性。你还可以看到阴影框两侧的信息是重复的，因此你只需要查看其中一个即可。
- en: '[Figure 5-6](ch05.xhtml#ch05fig6) gives a real-world example of a malware similarity
    matrix. Note that due to the large number of malware samples shown in the figure,
    each similarity value is represented by a shaded pixel. Instead of rendering the
    names of each sample, we render the family names for each sample along the horizontal
    and vertical axes. A perfect similarity matrix would look like a chain of white
    squares running diagonally from the top left to the bottom right, since the rows
    and columns representing each family are grouped together, and we expect all members
    of a given family to be similar to one another, but not samples from other families.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-6](ch05.xhtml#ch05fig6)展示了一个真实世界的恶意软件相似度矩阵示例。请注意，由于图中展示了大量恶意软件样本，每个相似度值是通过阴影像素表示的。我们没有渲染每个样本的名称，而是沿着横轴和纵轴渲染了每个样本所属的家族名称。一个完美的相似度矩阵应该像从左上角到右下角的一串白色方块，因为每个家族的行和列会被分组在一起，我们期望同一家族的所有成员彼此相似，但不同家族的样本之间不会有相似性。'
- en: '![image](../images/f0067-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0067-01.jpg)'
- en: '*Figure 5-6: A real-world malware similarity matrix computed over the seven
    malware families*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：计算七个恶意软件家族的真实世界恶意软件相似度矩阵*'
- en: In the results given in [Figure 5-6](ch05.xhtml#ch05fig6), you can see that
    some of the family squares are completely white—these are good results, because
    white pixels within a family square indicate an inferred similarity relationship
    between samples of the same family. Some are much darker, which means we did not
    detect strong similarity relationships. Finally, sometimes there are lines of
    pixels outside the family squares, which are either evidence of related malware
    families or false positives, meaning that we detected code-sharing between families
    despite their being inherently different.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-6](ch05.xhtml#ch05fig6)给出的结果中，你可以看到一些家族区域完全是白色的——这些是好结果，因为家族区域内的白色像素表示推测的同一家族样本之间的相似性关系。有些区域则要暗得多，这意味着我们没有检测到强的相似性关系。最后，有时会出现家族区域外的像素线条，这些要么是相关恶意软件家族的证据，要么是误报，意味着尽管这些家族本质上是不同的，我们仍然检测到了它们之间的代码共享。
- en: Next, we’ll use similarity matrix visualizations like [Figure 5-6](ch05.xhtml#ch05fig6)
    to compare the results of four different code-sharing estimation methods, starting
    with a description of instruction sequence-based similarity analysis.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用相似度矩阵可视化，如[图 5-6](ch05.xhtml#ch05fig6)，来比较四种不同代码共享估算方法的结果，首先从基于指令序列的相似性分析描述开始。
- en: '***Instruction Sequence–Based xSimilarity***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于指令序列的 xSimilarity***'
- en: The most intuitive way to compare two malware binaries in terms of the amount
    of code they share is by comparing their sequences of x86 assembly instructions,
    since samples that share sequences of instructions are likely to have shared,
    before compilation, actual source code. This requires disassembling malware samples
    using, for example, the *linear disassembly* technique introduced in [Chapter
    2](ch02.xhtml#ch02). Then we can use the N-gram extraction approach I discussed
    previously to extract sequences of instructions in the order they appear in the
    `.text` section of the malware file. Finally, we can use the instruction N-grams
    to compute Jaccard indices between samples to estimate how much code we think
    they share.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个恶意软件二进制文件共享代码量的最直观方式是通过比较它们的 x86 汇编指令序列，因为共享指令序列的样本很可能在编译前共享了实际的源代码。这需要通过例如在[第
    2 章](ch02.xhtml#ch02)中介绍的*线性反汇编*技术对恶意软件样本进行反汇编。然后，我们可以使用我之前讨论过的 N-gram 提取方法，按照它们在恶意软件文件的
    `.text` 部分出现的顺序提取指令序列。最后，我们可以使用指令 N-gram 计算样本之间的 Jaccard 相似度指数，来估计它们共享的代码量。
- en: The value we use for N during N-gram extraction depends on our analysis goals.
    The larger N is, the larger our extracted instruction subsequences will be, and
    thus the harder it will be for malware samples’ sequences to match. Setting N
    to a large number helps identify only samples that are highly likely to share
    code with one another. On the other hand, you can make N smaller to look for subtle
    similarities between samples, or if you suspect that the samples employ instruction
    reordering to obscure similarity analysis.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在N-gram提取中，我们使用的N值取决于我们的分析目标。N值越大，提取的指令子序列就越长，因此恶意软件样本的序列匹配就越困难。将N设置为较大数值有助于仅识别出那些高度可能共享代码的样本。另一方面，你也可以将N设置得较小，以便寻找样本之间的细微相似性，或者如果你怀疑样本使用了指令重排序来掩盖相似性分析。
- en: In [Figure 5-7](ch05.xhtml#ch05fig7), N is set to 5, which is an aggressive
    setting that makes it harder for samples to match.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-7](ch05.xhtml#ch05fig7)中，N值设置为5，这是一个激进的设置，使得样本之间的匹配更加困难。
- en: '![image](../images/f0068-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0068-01.jpg)'
- en: '*Figure 5-7: The similarity matrix generated using instruction N-gram features.
    Using* N *= 5, we completely miss many families’ similarity relationships but
    do well on webprefix and pasta.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：使用指令N-gram特征生成的相似性矩阵。使用* N *= 5，我们完全错过了许多家族之间的相似关系，但在webprefix和pasta上表现得很好。*'
- en: The results in [Figure 5-7](ch05.xhtml#ch05fig7) are not very compelling. While
    the instruction-based similarity analysis correctly identifies similarities between
    some families, it doesn’t within other families (for example, it detects few similarity
    relationships in dapato, skor, and vbna). It’s important to note, however, that
    there are few false positives in this analysis (false inferences of similarity
    between samples from different families, versus true inferences of similarities
    within samples of the same family).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-7](ch05.xhtml#ch05fig7)中的结果并不十分有说服力。虽然基于指令的相似性分析正确地识别出一些家族之间的相似性，但它在其他家族中无法识别（例如，它在dapato、skor和vbna中几乎没有检测到相似关系）。然而，需要注意的是，这种分析中的假阳性很少（即错误地推断出来自不同家族样本之间的相似性，而不是正确地推断出同一家族样本之间的相似性）。'
- en: As you can see, a limitation of instruction subsequence shared code analysis
    is that it can miss many code-sharing relationships between samples. This is because
    malware samples may be packed such that most of their instructions only become
    visible once we execute the malware samples and let them unpack themselves. Without
    unpacking our malware samples, the instruction sequence shared code estimation
    method will likely not work very well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，指令子序列共享代码分析的局限性在于，它可能会错过样本之间许多共享代码的关系。这是因为恶意软件样本可能被打包，以至于它们的大部分指令只有在我们执行恶意软件样本并让其解包后才会变得可见。如果不解包恶意软件样本，指令序列共享代码估计方法可能无法很好地工作。
- en: 'Even when we unpack our malware samples, the approach can be problematic, because
    of the noise introduced by the source code compilation process. Indeed, compilers
    can compile the same source code into radically different sequences of assembly
    instructions. Take, for example, the following simple function written in C:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们解包恶意软件样本，这种方法也可能存在问题，因为源代码编译过程会引入噪声。事实上，编译器可以将相同的源代码编译成完全不同的汇编指令序列。例如，以下是用C语言编写的一个简单函数：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You might think that regardless of compiler, the function would reduce to the
    same sequence of assembly instructions. But in fact, compilation depends heavily
    not just on what compiler you use, but also on the compiler settings. For example,
    compiling this function using the clang compiler under its default settings yields
    the following instructions corresponding to the line at ➊ in the source code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，无论使用什么编译器，函数都会被编译成相同的汇编指令序列。但实际上，编译过程不仅高度依赖于所使用的编译器，还依赖于编译器的设置。例如，使用clang编译器并按照其默认设置编译此函数时，源代码中➊行对应的汇编指令如下：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In contrast, compiling the same function with the `–O3` flag set, which tells
    the compiler to optimize the code for speed, yields the following assembly for
    the same line of the source code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用`–O3`标志编译相同的函数，告诉编译器优化代码以提高速度，编译出的汇编指令如下所示：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The difference results from the fact that in the second example, the compiler
    pre-computed the result of the function instead of explicitly computing it, as
    in the first compilation example. This means that if we compared these functions
    based on instruction sequences, they wouldn’t appear at all similar, even though
    in reality they were compiled from exactly the same source code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异的原因在于，在第二个例子中，编译器预先计算了函数的结果，而不是像第一个编译例子那样显式地计算它。这意味着，如果我们根据指令序列比较这些函数，它们看起来根本不相似，尽管实际上它们是从完全相同的源代码编译而来的。
- en: 'Beyond the problem of identical C and C++ code appearing to be very different
    when we’re looking at its assembly instructions, there’s an additional problem
    that arises when we compare binaries based on their assembly code: many malware
    binaries are now authored in high-level languages like C#. These binaries contain
    standard boilerplate assembly code that simply interprets these higher-level languages’
    bytecode. So, although binaries written in the same high-level language may share
    very similar x86 instructions, their actual bytecode may reflect the fact that
    they come from very different source code.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当我们查看汇编指令时，相同的C和C++代码看起来非常不同的问题外，当我们根据汇编代码比较二进制文件时，还会出现一个额外的问题：许多恶意软件二进制文件现在是用像C#这样的高级语言编写的。这些二进制文件包含标准的样板汇编代码，它只是解释这些高级语言的字节码。因此，尽管用相同高级语言编写的二进制文件可能共享非常相似的x86指令，但它们的实际字节码可能反映了它们来自完全不同源代码的事实。
- en: '***Strings-Based Similarity***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于字符串的相似性***'
- en: We can compute strings-based malware similarity by extracting all contiguous
    printable sequences of characters in the samples and then computing the Jaccard
    index between all pairs of malware samples based on their shared string relationships.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提取样本中的所有连续可打印字符序列，然后根据它们共享的字符串关系，计算恶意软件样本之间的Jaccard指数，从而计算基于字符串的恶意软件相似度。
- en: This approach gets around the compiler problem because the strings extracted
    from a binary tend to be *format strings* defined by the programmer, which compilers
    as a general rule do not transform, regardless of which compilers the malware
    authors are using or what parameters they give the compilers. For example, a typical
    string extracted from a malware binary might read, “Started key logger at %s on
    %s and time %s.” Regardless of compiler settings, this string will tend to look
    identical among multiple binaries and is related to whether or not they’re based
    on the same source code base.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法绕过了编译器的问题，因为从二进制文件中提取的字符串通常是由程序员定义的*格式字符串*，编译器通常不会对其进行转换，无论恶意软件作者使用的是哪种编译器，或者他们给编译器设置了什么参数。例如，从恶意软件二进制文件中提取的典型字符串可能是：“在%s上启动键盘记录器，时间为%s。”不管编译器设置如何，这个字符串在多个二进制文件中往往看起来是相同的，它与是否基于相同的源代码库有关。
- en: '[Figure 5-8](ch05.xhtml#ch05fig8) shows how well the string-based code-sharing
    metric identifies the correct code-sharing relationships in the crimeware dataset.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-8](ch05.xhtml#ch05fig8)展示了基于字符串的代码共享度量如何在犯罪软件数据集中识别正确的代码共享关系。'
- en: '![image](../images/f0070-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0070-01.jpg)'
- en: '*Figure 5-8: The similarity matrix generated using string features*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-8：使用字符串特征生成的相似度矩阵*'
- en: At first glance, this method does far better at identifying the malware families
    than the instruction-based method, accurately recovering much of the similarity
    relationships for all seven families. However, unlike the instruction similarity
    method, there are a few false positives, since it incorrectly predicts that xtoober
    and dapato share some level of code. It’s also worth noting that this method didn’t
    detect similarities between samples in some families, performing particularly
    poorly on the zango, skor, and dapato families.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这种方法在识别恶意软件家族方面比基于指令的方法表现得更好，准确地恢复了所有七个家族的大部分相似性关系。然而，与基于指令的相似性方法不同，仍然有一些误报，因为它错误地预测了xtoober和dapato共享某些代码。此外，值得注意的是，这种方法未能检测到某些家族样本之间的相似性，在zango、skor和dapato家族上表现特别差。
- en: '***Import Address Table–Based Similarity***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于导入地址表的相似性***'
- en: We can compute what I call “[Import Address Table–based similarity](ch05.xhtml#lev80)”
    by comparing the DLL imports made by malware binaries. The idea behind this approach
    is that even if the malware author has reordered instructions, obfuscated the
    initialized data section of the malware binary, and implemented anti-debugger
    and anti-VM anti-analysis techniques, they may have left the exact same import
    declarations in place. The results for the Import Address Table method are shown
    in [Figure 5-9](ch05.xhtml#ch05fig9).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过比较恶意软件二进制文件的 DLL 导入来计算我所称的 “[导入地址表–基础相似性](ch05.xhtml#lev80)”。这种方法背后的思想是，即使恶意软件作者已经重新排序了指令、混淆了恶意软件二进制文件的初始化数据段，并实施了反调试和反虚拟机反分析技术，他们可能仍然保留了相同的导入声明。导入地址表方法的结果如
    [图 5-9](ch05.xhtml#ch05fig9) 所示。
- en: '![image](../images/f0071-01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0071-01.jpg)'
- en: '*Figure 5-9: The similarity matrix generated using Import Address Table features*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：使用导入地址表特征生成的相似性矩阵*'
- en: The figure shows that the Import Address Table method does better than any of
    the preceding methods at estimating the similarity relationships between the webprefix
    and xtoober samples and does very well overall, even though it misses many of
    the skor, dapato, and vbna relationships. It’s also notable that this method gives
    few false positives on our experimental dataset.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示，导入地址表方法在估计 webprefix 和 xtoober 样本之间的相似性关系方面优于任何前述方法，并且总体表现非常好，尽管它错过了许多
    skor、dapato 和 vbna 关系。值得注意的是，这种方法在我们的实验数据集中给出的假阳性较少。
- en: '***Dynamic API Call–Based Similarity***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于动态 API 调用的相似性***'
- en: The final comparison method I introduce in this chapter is dynamic malware similarity.
    The advantage of comparing dynamic sequences is that even if malware samples are
    extremely obfuscated or packed, they will tend to perform similar sequences of
    actions within a sandboxed virtual machine as long as they’re derived from the
    same code or borrow code from one another. To implement this approach, you’ll
    need to run malware samples in a sandbox and record the API calls they make, extract
    N-grams of API calls from the dynamic logs, and finally compare the samples by
    taking the Jaccard index between their bags of N-grams.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我介绍的最后一种比较方法是动态恶意软件相似性。比较动态序列的优势在于，即使恶意软件样本经过了极度混淆或打包，只要它们源自相同的代码或相互借用代码，它们在沙箱虚拟机中执行的动作序列通常会非常相似。为了实现这种方法，你需要在沙箱中运行恶意软件样本，记录它们所做的
    API 调用，从动态日志中提取 API 调用的 N-gram，并最终通过计算它们的 N-gram 包之间的 Jaccard 指数来比较样本。
- en: '[Figure 5-10](ch05.xhtml#ch05fig10) shows that the dynamic N-gram similarity
    approach does about as well as the import and string methods in most cases.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-10](ch05.xhtml#ch05fig10) 显示了动态 N-gram 相似性方法在大多数情况下与导入方法和字符串方法的表现相当。'
- en: '![image](../images/f0072-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0072-01.jpg)'
- en: '*Figure 5-10: The similarity matrix generated using dynamic API call N-gram
    features*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：使用动态 API 调用 N-gram 特征生成的相似性矩阵*'
- en: The imperfect results here show that this method is no panacea. Simply running
    malware in a sandbox is not sufficient to trigger many of its behaviors. Variations
    of a command line malware tool, for example, may or may not enable an important
    code module, and therefore execute different sequences of behavior, even though
    they may share most of their code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不完美结果表明，这种方法并不是万能的。仅仅在沙箱中运行恶意软件并不足以触发它的许多行为。例如，一种命令行恶意软件工具的不同变种可能启用或不启用一个重要的代码模块，因此会执行不同的行为序列，尽管它们可能共享大部分代码。
- en: Another problem is that some samples detect that they’re running in a sandbox
    and then promptly exit execution, leaving us with little information to make comparisons.
    In summary, like the other similarity approaches I’ve outlined, dynamic API call
    sequence similarity isn’t perfect, but it can provide impressive insight into
    similarities between samples.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，一些样本能够检测到它们正在沙箱中运行，然后迅速退出执行，导致我们几乎无法获得任何信息来进行比较。总之，像我所概述的其他相似性方法一样，动态
    API 调用序列相似性并不完美，但它能为样本之间的相似性提供令人印象深刻的洞察。
- en: '**Building a Similarity Graph**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建相似性图**'
- en: Now that you understand the concepts behind methods for identifying malware
    code sharing, let’s build a simple system that performs this analysis over a malware
    dataset.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了识别恶意软件代码共享方法背后的概念，让我们构建一个简单的系统，针对恶意软件数据集进行此分析。
- en: First, we need to estimate the amount of code that samples share by extracting
    the features we would like to use. These could be any of the features described
    previously, such as Import Address Table–based functions, strings, N-grams of
    instructions, or N-grams of dynamic behavior. Here, we’ll use printable string
    features because they perform well and are simple to extract and understand.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过提取我们想要使用的特征来估算样本共享的代码量。这些特征可以是之前描述的任何特征，例如基于导入地址表的函数、字符串、指令的 N-gram
    或动态行为的 N-gram。在这里，我们将使用可打印字符串特征，因为它们表现良好，并且易于提取和理解。
- en: Once we’ve extracted the string features, we need to iterate over every pair
    of malware samples, comparing their features using the Jaccard index. Then, we
    need to build a code-sharing graph. To do this, we first need to decide on a threshold
    that defines how much code the two samples share—a standard value I use in my
    research is 0.8\. If the Jaccard index for a given pair of malware samples is
    above that value, we create a link between them for visualization. The final step
    is to study the graph to see which samples are connected by shared code relationships.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取了字符串特征，我们需要遍历每一对恶意软件样本，使用 Jaccard 指数比较它们的特征。然后，我们需要构建一个代码共享图。为此，我们首先需要决定一个阈值，定义两个样本共享多少代码——我在研究中使用的标准值是
    0.8。如果给定的恶意软件样本对的 Jaccard 指数高于该值，我们就会为它们创建一个可视化链接。最后一步是研究该图，看看哪些样本通过共享的代码关系连接在一起。
- en: '[Listings 5-2](ch05.xhtml#ch05list2) through [5-6](ch05.xhtml#ch05list6) contain
    our sample program. Because the listing is long, I break it into pieces and explain
    each piece as I go. [Listing 5-2](ch05.xhtml#ch05list2) imports the libraries
    we’ll use, and declares the `jaccard()` function, which computes the Jaccard index
    between two samples’ sets of features.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-2](ch05.xhtml#ch05list2) 到 [5-6](ch05.xhtml#ch05list6) 包含我们的示例程序。由于列表较长，我将其拆分为几部分，并在每一部分讲解。[列表
    5-2](ch05.xhtml#ch05list2) 导入了我们将使用的库，并声明了 `jaccard()` 函数，该函数计算两个样本特征集之间的 Jaccard
    指数。'
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-2: The imports and a helper function to compute the Jaccard index
    between two samples*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：导入和一个帮助函数，用于计算两个样本之间的 Jaccard 指数*'
- en: 'Next, in [Listing 5-3](ch05.xhtml#ch05list3), we declare two additional utility
    functions: `getstrings``()`, which finds the set of printable string sequences
    within the malware files we’ll be analyzing, and `pecheck()`, which ensures that
    target files are indeed Windows PE files. We’ll use these functions later when
    we’re performing feature extraction on the target malware binaries.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 [列表 5-3](ch05.xhtml#ch05list3) 中，我们声明了两个附加的实用函数：`getstrings()`，该函数查找我们将要分析的恶意软件文件中的可打印字符串序列集合；以及
    `pecheck()`，该函数确保目标文件确实是 Windows PE 文件。我们将在后续进行目标恶意软件二进制文件的特征提取时使用这些函数。
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-3: Declaring the functions we’ll use in feature extraction*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：声明我们将在特征提取中使用的函数*'
- en: Next, in [Listing 5-4](ch05.xhtml#ch05list4), we parse our user’s command line
    arguments. These arguments include the target directory in which the malware we’ll
    be analyzing exists, the output *.dot* file to which we’ll write the shared code
    network we build, and the Jaccard index threshold, which determines how high the
    Jaccard index must be between two samples for the program to decide that they
    share a common code base with one another.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 [列表 5-4](ch05.xhtml#ch05list4) 中，我们解析用户的命令行参数。这些参数包括存放我们将要分析的恶意软件的目标目录、我们将写入共享代码网络的输出
    *.dot* 文件，以及 Jaccard 指数阈值，该阈值决定了两个样本之间的 Jaccard 指数需要达到多少，程序才会判断它们共享相同的代码基础。
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-4: Parsing the user’s command line arguments*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：解析用户的命令行参数*'
- en: 'Next, in [Listing 5-5](ch05.xhtml#ch05list5), we use the helper functions we
    declared earlier to do the main work of the program: finding PE binaries in the
    target directory, extracting features from them, and initializing a network that
    we’ll use to express similarity relationships between the binaries.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 [列表 5-5](ch05.xhtml#ch05list5) 中，我们使用之前声明的帮助函数来执行程序的主要工作：在目标目录中找到 PE 二进制文件、从中提取特征，并初始化一个网络，用来表示二进制文件之间的相似性关系。
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-5: Extracting features from PE files in the target directory and
    initializing the shared code network*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：从目标目录中的 PE 文件提取特征并初始化共享代码网络*'
- en: After extracting features from our target samples, we need to iterate over every
    pair of malware samples, comparing their features using the Jaccard index. We
    do this in [Listing 5-6](ch05.xhtml#ch05list6). We also build a code-sharing graph
    where samples are linked together if their Jaccard index is above some user-defined
    threshold. The threshold I’ve found works best in my research is 0.8.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在从目标样本中提取特征之后，我们需要遍历每一对恶意软件样本，使用Jaccard指数比较它们的特征。我们在[清单 5-6](ch05.xhtml#ch05list6)中执行了这个操作。我们还构建了一个代码共享图，当样本的Jaccard指数高于某个用户定义的阈值时，它们会被连接在一起。我在我的研究中发现，0.8是效果最好的阈值。
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-6: Creating a code-sharing graph in Python*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6：在Python中创建代码共享图*'
- en: The code in [Listings 5-2](ch05.xhtml#ch05list2) through [5-6](ch05.xhtml#ch05list6)
    produces the chart shown in [Figure 5-11](ch05.xhtml#ch05fig11) when applied to
    the APT1 malware samples. To visualize the chart, you need to use the `fdp` Graphviz
    tool (discussed in [Chapter 4](ch04.xhtml#ch04)) to enter the command `fdp -Tpng
    network.dot -o network.png`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-2](ch05.xhtml#ch05list2)到[5-6](ch05.xhtml#ch05list6)中的代码，在应用于APT1恶意软件样本时，生成的图表如[图
    5-11](ch05.xhtml#ch05fig11)所示。要查看图表，你需要使用`fdp` Graphviz工具（在[第4章](ch04.xhtml#ch04)中讨论过）输入命令`fdp
    -Tpng network.dot -o network.png`。'
- en: '![image](../images/f0076-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0076-01.jpg)'
- en: '*Figure 5-11: The complete string-based similarity graph for the APT1 samples*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：APT1样本的完整基于字符串的相似度图*'
- en: The amazing thing about this output is that within a few minutes, we reproduced
    much of the manual, painstaking work that the original analysts of the APT1 produced
    in their report, identifying many of the malware families used by these nation
    state–level attackers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的惊人之处在于，几分钟之内，我们就重新生成了APT1原始分析师在其报告中所做的许多手动、艰苦的工作，识别出了这些国家级攻击者使用的许多恶意软件家族。
- en: We know that our method has performed accurately relative to the manual reverse
    engineering work that these analysts performed, because the names on the nodes
    are the names given to them by the Mandiant analysts. You can see this in the
    way samples with similar names group together in the network visualization in
    [Figure 5-11](ch05.xhtml#ch05fig11), such as the “STARSYPOUN” samples in the central
    circle. Because the malware in our network visualization automatically groups
    together in a way that aligns with these family names, our method seems to “agree”
    with the Mandiant malware analysts. You can extend the code in [Listings 5-2](ch05.xhtml#ch05list2)
    through [5-6](ch05.xhtml#ch05list6) and apply it to your own malware for similar
    intelligence.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的方法与这些分析师执行的手动逆向工程工作相比是准确的，因为节点上的名称是Mandiant分析师赋予它们的名称。你可以从[图 5-11](ch05.xhtml#ch05fig11)中的网络可视化中看到，具有相似名称的样本会聚集在一起，例如位于中央圆圈中的“STARSYPOUN”样本。因为我们的网络可视化中的恶意软件自动以与这些家族名称一致的方式分组，我们的方法似乎与Mandiant的恶意软件分析师“达成一致”。你可以扩展[清单
    5-2](ch05.xhtml#ch05list2)到[5-6](ch05.xhtml#ch05list6)中的代码，并将其应用于你自己的恶意软件，以获得类似的情报。
- en: '**Scaling Similarity Comparisons**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**扩展相似度比较**'
- en: 'Although the code in [Listings 5-2](ch05.xhtml#ch05list2) through [5-6](ch05.xhtml#ch05list6)
    works well for small malware datasets, it doesn’t work well for a large number
    of malware samples. This is because comparing all pairs of malware samples in
    a dataset grows quadratically with the number of samples. Specifically, the following
    equation gives the number of Jaccard index computations necessary to compute a
    similarity matrix over a dataset of size *n*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[清单 5-2](ch05.xhtml#ch05list2)到[5-6](ch05.xhtml#ch05list6)中的代码对于小型恶意软件数据集效果良好，但对于大量恶意软件样本则效果不佳。这是因为在数据集中比较所有恶意软件样本的每一对时，计算量随着样本数量的增加而呈二次增长。具体来说，下面的方程给出了计算Jaccard指数所需的计算次数，以计算一个大小为*n*的数据集的相似度矩阵：
- en: '![image](../images/f0077-01.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0077-01.jpg)'
- en: For example, let’s return to the similarity matrix in [Figure 5-5](ch05.xhtml#ch05fig5)
    to see how many Jaccard indices we would need to compute the four samples. At
    first glance, you might say 16 (4²), because that’s how many cells are in the
    matrix. However, because the bottom triangle of the matrix contains duplicates
    of the top triangle of the matrix, we don’t need to compute these twice. This
    means that we can subtract 6 from our total number of computations. Furthermore,
    we don’t need to compare malware samples to themselves, so we can eliminate the
    diagonal from the matrix, allowing us to subtract four more computations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of computations necessary is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0077-02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: This seems manageable, until our dataset grows to 10,000 malware samples, for
    example, which would require 49,995,000 computations. A dataset that has 50,000
    samples would require 1,249,975,000 Jaccard index computations!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: To scale malware similarity comparisons, we need to use randomized comparison
    approximation algorithms. The basic idea is to allow for some error in our computation
    of comparisons in exchange for a reduction in computation time. For our purposes,
    an approximate comparison approach known as *minhash* serves this purpose beautifully.
    The minhash method allows us to compute the Jaccard index using approximation
    to avoid computing similarities between nonsimilar malware samples below some
    predefined similarity threshold so that we can analyze shared code relationships
    between millions of samples.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Before you read about why minhash works, note that this is a tricky algorithm
    that can take some time to understand. If you decide to skip the “[Minhash in
    Depth](ch05.xhtml#lev85)” section, just read the “[Minhash in a Nutshell](ch05.xhtml#lev84)”
    section and use the code provided, and you should have no problems scaling your
    code sharing analysis.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '***Minhash in a Nutshell***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Minhash takes a malware sample’s features and hashes them with *k* hash functions.
    For each hash function, we retain only the minimum value of the hashes computed
    over all the features, so that the set of malware features is reduced to a fixed
    size array of *k* integers, which we call the minhashes. To compute the approximate
    Jaccard index between two samples based on their minhash arrays, you now just
    need to check how many of the *k* minhashes match, and divide that by *k*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Magically, the number that falls out of these computations is a close approximation
    of the true Jaccard index between any two samples. The benefit of using minhash
    instead of a literal computation of the Jaccard index is that it’s much faster
    to compute.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can even use minhash to cleverly index malware in a database such
    that we only need to compute comparisons between malware samples that are likely
    to be similar because at least one of their hashes matched, thereby dramatically
    speeding up computation of similarities within malware datasets.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '***Minhash in Depth***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s now discuss the math behind minhash in depth. [Figure 5-12](ch05.xhtml#ch05fig12)
    shows the sets of features (represented by the shaded circles) for two malware
    samples, how they are hashed and then sorted based on their hashes, and how they’re
    finally compared based on the value of the first element of each list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入讨论minhash背后的数学原理。[图5-12](ch05.xhtml#ch05fig12)展示了两个恶意软件样本的特征集合（由阴影圆圈表示），它们是如何哈希化并根据哈希值排序的，以及它们是如何基于每个列表的第一个元素的值进行最终比较的。
- en: '![image](../images/f0078-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0078-01.jpg)'
- en: '*Figure 5-12: An illustration of the idea behind minhash*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-12：minhash背后思想的插图*'
- en: The probability that the first elements will match is equal to the Jaccard index
    between the samples. How this works is beyond the scope of this book, but this
    serendipitous fact is what lets us approximate the Jaccard index using hashes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素匹配的概率等于样本之间的Jaccard指数。这一原理超出了本书的讨论范围，但正是这个偶然的事实使得我们可以通过哈希来近似估算Jaccard指数。
- en: 'Of course, just performing this hashing, sorting, and first-element-checking
    operation doesn’t tell us that much if we only do it once—the hashes either match
    or they don’t, and we can’t guess the underlying Jaccard index very accurately
    based on that one match. To get a better estimate of this underlying value, we
    have to use *k* hash functions and repeat this operation *k* times, and then estimate
    the Jaccard index by dividing the number of times these first elements matched
    by *k*. Our expected *error* in estimating the Jaccard index is defined as the
    following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅执行这个哈希、排序和检查第一个元素的操作，如果我们只做一次，是无法给我们提供太多信息的——哈希值要么匹配，要么不匹配，我们也无法根据这一次的匹配准确地推测底层的Jaccard指数。为了更好地估算这个底层值，我们必须使用
    *k* 个哈希函数，并且重复执行这个操作 *k* 次，然后通过将这些第一个元素匹配的次数除以 *k* 来估算Jaccard指数。我们估算Jaccard指数时的预期
    *误差* 定义如下：
- en: '![image](../images/f0079-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0079-01.jpg)'
- en: So the more times we perform this procedure, the more certain we’ll be (I tend
    to set *k* to 256 so that the estimate is off by 6 percent, on average).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们执行这个过程的次数越多，我们就越能够确定（我通常将 *k* 设置为 256，这样估算值平均偏差为6%）。
- en: Suppose we compute a minhash array for every malware sample in a malware dataset
    containing one million samples. How do we then use the minhashes to speed up the
    search for malware families in the dataset? We could iterate over every pair of
    malware samples in the dataset and compare their minhash arrays, which would lead
    to 499,999,500,000 comparisons. Even though it’s faster to compare minhash arrays
    than to compute the Jaccard index, this is still way too many comparisons to make
    on modern hardware. We need some way of exploiting the minhashes to optimize the
    comparison process even more.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为一个包含一百万个样本的恶意软件数据集中的每个恶意软件样本计算一个minhash数组。那我们如何使用这些minhash来加速在数据集中搜索恶意软件家族呢？我们可以遍历数据集中每对恶意软件样本，并比较它们的minhash数组，这样就会进行499,999,500,000次比较。尽管比较minhash数组比计算Jaccard指数要快，但这仍然是现代硬件上需要进行的比较次数，太多了。我们需要某种方式利用minhash来进一步优化比较过程。
- en: The standard approach to this problem is to use sketching combined with database
    indexing, which creates a system in which we compare only samples that we already
    know are highly likely to be similar. We make a sketch by hashing multiple minhashes
    together.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的标准方法是结合草图和数据库索引的方法，创建一个只比较我们已经知道高度相似的样本的系统。我们通过将多个minhash哈希值一起进行哈希，来生成一个草图。
- en: When we get a new sample, we check whether the database contains any sketches
    that match the new sample’s sketches. If so, the new sample is compared with the
    matching samples using their minhash arrays to approximate the Jaccard index between
    the new sample and the older, similar samples. This avoids having to compare the
    new sample to all samples in the database, and instead comparing it to only those
    samples that are highly likely to have high Jaccard indices with this new sample.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们得到一个新样本时，我们会检查数据库中是否包含任何与新样本的草图匹配的样本。如果有，那么就用它们的minhash数组将新样本与匹配的样本进行比较，从而近似估算新样本与旧样本之间的Jaccard指数。这避免了将新样本与数据库中的所有样本进行比较，而是只与那些与新样本的Jaccard指数很可能较高的样本进行比较。
- en: '**Building a Persistent Malware Similarity Search System**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建一个持久化的恶意软件相似性搜索系统**'
- en: Now that you’ve learned the pros and cons of using a variety of malware feature
    types to estimate shared code relationships between malware samples. You’ve also
    learned about the Jaccard index, similarity matrices, and the way in which minhash
    can make computing similarities between malware samples in even very large datasets
    tractable. With all this knowledge in hand, you understand all of the fundamental
    concepts necessary to build a scalable malware shared code search system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了使用各种恶意软件特征类型来估计恶意软件样本之间共享代码关系的优缺点。你还了解了 Jaccard 指数、相似性矩阵，以及 minhash
    如何使得在非常大的数据集中计算恶意软件样本之间的相似性变得可行。掌握了这些知识后，你理解了构建一个可扩展的恶意软件共享代码搜索系统所需的所有基本概念。
- en: '[Listings 5-7](ch05.xhtml#ch05list7) through [5-12](ch05.xhtml#ch05list12)
    show an example of a simple system in which I index malware samples based on their
    string features. In your own work, you should feel confident in modifying this
    system to use other malware features, or extending it to support more visualization
    features. Because the listing is long, I’ve broken it up and we’ll cover each
    subsection in turn.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-7](ch05.xhtml#ch05list7) 到 [5-12](ch05.xhtml#ch05list12) 展示了一个简单系统的示例，在该系统中，我根据恶意软件样本的字符串特征对其进行索引。在你的工作中，你应该有信心修改此系统，使用其他恶意软件特征，或扩展它以支持更多的可视化功能。由于列表很长，我将其分成了几个部分，我们将逐一讨论每个小节。'
- en: To begin, [Listing 5-7](ch05.xhtml#ch05list7) imports the Python packages required
    for our program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，[列表 5-7](ch05.xhtml#ch05list7) 导入了我们程序所需的 Python 包。
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-7: Importing Python modules and declaring minhash-related constants*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：导入 Python 模块并声明与 minhash 相关的常量*'
- en: Here, I import packages like `murmur`, `shelve`, and `sim_graph`. For example,
    `murmur` is a hashing library that we use to compute the minhash algorithm I just
    discussed. We use `shelve`, a simple database module included in the Python standard
    library, to store information about samples and their minhashes, which we use
    to compute similarities. We use `listings_5_2_to_5_6.py` to get functions for
    computing sample similarity.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我导入了像 `murmur`、`shelve` 和 `sim_graph` 这样的包。例如，`murmur` 是一个哈希库，我们用它来计算我刚才讨论的
    minhash 算法。我们使用 `shelve`，这是一个包含在 Python 标准库中的简单数据库模块，用来存储有关样本及其 minhash 的信息，这些信息用于计算相似性。我们使用
    `listings_5_2_to_5_6.py` 来获取计算样本相似性的函数。
- en: 'We also declare two constants in [Listing 5-7](ch05.xhtml#ch05list7): `NUM_MINHASHES`
    and `SKETCH_RATIO`. These correspond to the number of minhashes and the ratio
    of minhashes to sketches we compute for each sample. Recall that the more minhashes
    and sketches we use, the more accurate our similarity computations. For example,
    256 minhashes and a ratio of 8:1 (32 sketches) is enough to yield acceptable accuracy
    at a low computational cost.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在[列表 5-7](ch05.xhtml#ch05list7)中声明了两个常量：`NUM_MINHASHES` 和 `SKETCH_RATIO`。这两个常量分别对应我们为每个样本计算的
    minhash 数量和 minhash 与草图的比率。请记住，使用的 minhash 和草图越多，我们的相似性计算越准确。例如，256 个 minhash
    和 8:1 的比率（32 个草图）就足以在低计算成本下提供足够的准确性。
- en: '[Listing 5-8](ch05.xhtml#ch05list8) implements database functionality that
    we use to initialize, access, and delete the `shelve` database we use to store
    malware sample information.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-8](ch05.xhtml#ch05list8) 实现了我们用来初始化、访问和删除用于存储恶意软件样本信息的`shelve`数据库的数据库功能。'
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-8: Database helper functions*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：数据库辅助函数*'
- en: We define `wipe_database()` ➊ to delete our program’s database in case we want
    to wipe out sample information we’ve stored and start over. Then we define `get_database()`
    ➋ to open our database, creating it if it doesn’t yet exist, and then return a
    database object, allowing us to store and retrieve data about our malware samples.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `wipe_database()` ➊ 来删除程序的数据库，以便在我们想要清除存储的样本信息并重新开始时使用。然后，我们定义了 `get_database()`
    ➋ 来打开数据库，如果数据库尚不存在，则创建它，并返回一个数据库对象，允许我们存储和检索有关恶意软件样本的数据。
- en: '[Listing 5-9](ch05.xhtml#ch05list9) implements a core piece of the code for
    our shared code analysis: minhash.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-9](ch05.xhtml#ch05list9) 实现了共享代码分析的核心部分：minhash。'
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-9: Obtaining minhashes and sketches for a sample*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-9：获取样本的 minhash 和草图*'
- en: We loop `NUM_MINHASHES` times ➊ and append one minhash value. Each minhash value
    is computed by hashing all the features and then taking the minimum hash value.
    To perform this computation, we use the `murmur` package’s `string_hash()` function
    to hash the features, and then we take the minimum value of the list of hashes
    by calling Python’s `min()` function ➋.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The second argument of `string_hash` is a seed value, which causes the hash
    function to map to different hashes depending on the seed’s value. Because each
    minhash value requires a unique hash function such that all of our 256 min hash
    values aren’t identical, on each iteration we seed the `string_hash` function
    with our counter value `i`, which causes the features to map to different hashes
    on each iteration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Then, we loop over the minhashes we’ve computed and use the minhashes to compute
    sketches ➌. Recall that sketches are hashes of multiple minhashes, which we use
    for database indexing of our malware samples so that we can quickly retrieve samples
    that are likely to be similar to one another by querying the database. In the
    next code listing, we loop over all of our sample’s minhashes with step size `SKETCH_RATIO`,
    hashing each chunk of hashes as we go to obtain our sketches. Finally, we use
    `murmur` package’s `string_hash` function to hash the minhashes together ➍.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-10](ch05.xhtml#ch05list10) uses `get_database()` from [Listing 5-8](ch05.xhtml#ch05list8),
    the `getstrings()` function from the `sim_graph` module we imported, and the `minhash()`
    function from [Listing 5-9](ch05.xhtml#ch05list9) to create a function that indexes
    samples into our system’s database.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 5-10: Storing a sample’s minhashes in the shelve database by using
    its sketches as keys*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We call `get_database()` ➊, `getstrings()` ➋, and `minhash()` ➌ and then iterate
    over our sample’s sketches starting at ➍. Next, to index our samples in the database,
    we use a technique known as *inverted indexing*, which allows us to store samples
    based on their *sketch values* instead of an ID. More specifically, for each of
    a sample’s 32 sketch values, we look up that sketch’s record in the database and
    append our sample’s ID to the list of samples associated with that sketch. Here,
    we use a sample’s filesystem path as its ID.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how this is implemented in the code: we loop over the sketches
    we’ve computed for a sample ➍, we create a record for the sketch if it doesn’t
    already exist (associating our sample with the sketch while we’re at it) ➎, and
    finally, we add the sample path to the sketch’s set of associated sample paths
    if the sketch’s record does exist ➏.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-11](ch05.xhtml#ch05list11) shows the declaration of two important
    functions: `comment_sample()` and `search_sample()`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-11: Declaring functions that allow users to comment on samples and
    search for samples similar to a query sample*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As expected, `comment_sample()` ➊ adds a user-defined comment record to a sample’s
    database record. This functionality is useful, because it allows users of the
    program to include insights gained from reverse-engineering a sample in the database
    such that when they see a new sample similar to samples they have comments for,
    they can leverage those comments to more rapidly understand the origins and purpose
    of the new sample.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`comment_sample()` ➊ 会将用户定义的评论记录添加到样本的数据库记录中。这项功能非常有用，因为它允许程序的用户将反向工程过程中获得的见解存储到数据库中，以便当他们看到与他们有评论的样本相似的新样本时，他们可以利用这些评论更快速地了解新样本的来源和目的。
- en: Next, `search_sample()` ➋ leverages minhash to find samples similar to a query
    sample. To do this, first we extract string features, minhashes, and sketches
    from the query sample. Then, we iterate over the sample’s sketches, looking up
    samples stored in the database that also have that sketch ➌. For each sample that
    shares a sketch with the query sample, we compute its approximate Jaccard index
    using its minhashes ➍. Finally, we report the most similar samples to the query
    sample to the user, along with any comments associated with these samples that
    have been stored in the database ➎.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`search_sample()` ➋ 利用 minhash 查找与查询样本相似的样本。为此，我们首先从查询样本中提取字符串特征、minhash
    和草图。然后，我们遍历样本的草图，查找数据库中也具有该草图的样本 ➌。对于每个与查询样本共享草图的样本，我们使用其 minhash 计算其近似的 Jaccard
    指数 ➍。最后，我们向用户报告与查询样本最相似的样本，并附带与这些样本相关的评论（如果有的话） ➎。
- en: '[Listing 5-12](ch05.xhtml#ch05list12) concludes our program’s code by implementing
    the argument-parsing part of our program.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-12](ch05.xhtml#ch05list12) 通过实现程序的参数解析部分，完成了我们的程序代码。'
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-12: Performing similarity database updates and queries based on
    user command line arguments*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-12: 基于用户命令行参数执行相似度数据库更新和查询*'
- en: Here, we allow users to load malware samples into the database so that these
    samples will be compared with new malware samples when users search similar samples
    in the database ➊. Next, we allow users to search for samples similar to the sample
    the user has passed in ➋, printing the results to the terminal. We also allow
    the user to comment on samples already in the database ➌. Finally, we allow the
    user to wipe the existing database ➍.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们允许用户将恶意软件样本加载到数据库中，这样当用户搜索相似样本时，这些样本将与新恶意软件样本进行比较 ➊。接下来，我们允许用户搜索与用户提供的样本相似的样本
    ➋，并将结果打印到终端。我们还允许用户对数据库中已有的样本进行评论 ➌。最后，我们允许用户清除现有数据库 ➍。
- en: '**Running the Similarity Search System**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运行相似度搜索系统**'
- en: 'Once you’ve implemented this code, you can run the similarity search system,
    which consists of four simple operations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了这段代码，您就可以运行相似度搜索系统，该系统由四个简单的操作组成：
- en: '**Load** Loading the samples into the system stores them in the system database
    for future code-sharing searches. You can load samples individually or specify
    a directory, which the system will search recursively for PE files, loading them
    into the database. You can load samples into the database with the following command
    run in this chapter’s code directory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载** 将样本加载到系统中，会将它们存储在系统数据库中，以便以后进行代码共享搜索。您可以单独加载样本，或指定一个目录，系统会递归地搜索该目录下的
    PE 文件并将其加载到数据库中。您可以在本章的代码目录中运行以下命令来将样本加载到数据库中：'
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Comment** Commenting on a sample is useful because it allows you to store
    knowledge about that sample. Also, when you see new samples similar to this sample,
    a similarity search over those samples will reveal the comments you made on the
    older, similar sample, thus speeding up your workflow. You can comment on a malware
    sample with the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**评论** 对样本进行评论非常有用，因为它允许您将有关该样本的知识存储起来。此外，当您看到新的与该样本相似的样本时，对这些样本进行相似度搜索时，会显示您在旧样本上的评论，从而加速您的工作流程。您可以使用以下命令对恶意软件样本进行评论：'
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Search** Given a single malware sample, searching identifies all similar
    samples in the database and prints them in descending order of similarity. Also,
    any comments you might have made on those samples are printed. You can search
    for malware samples similar to a given sample using the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索** 给定一个恶意软件样本，搜索功能会识别数据库中所有相似的样本，并按相似度降序排列。同时，您可能对这些样本所做的任何评论也会被显示。您可以使用以下命令搜索与给定样本相似的恶意软件样本：'
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Wipe** Wiping the database simply clears all records from the system database,
    which you can do with the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Listing 5-13](ch05.xhtml#ch05list13) shows what it looks like when we load
    the APT1 samples into the system.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-13: Sample output from the loading data into the similarity search
    system implemented in this chapter*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: And [Listing 5-14](ch05.xhtml#ch05list14) shows what it looks like when we perform
    a similarity search.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-14: Sample output from the similarity search system implemented
    in this chapter*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Note that our system correctly determines that the query sample (a “greencat”
    sample) shares code with other greencat samples. If we didn’t have the luxury
    of already knowing these samples were members of the greencat family, our system
    would have just saved us a ton of reverse engineering work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: This similarity search system is only a small example of what would be implemented
    in a production similarity search system. But you should have no problem using
    what you learned so far to add visualization capabilities to the system and extend
    it to support multiple similarity search methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to identify shared code relationships between
    malware samples, compute code sharing similarity over thousands of malware samples
    to identify new malware families, determine a new malware sample’s code similarity
    to thousands of previously seen malware samples, and visualize malware relationships
    to understand patterns of code sharing.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: You should now feel comfortable adding shared code analysis to your malware
    analysis toolbox, which will allow you to gain fast intelligence over large volumes
    of malware and accelerate your malware analysis workflow.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapters 6](ch06.xhtml#ch06), [7](ch07.xhtml#ch07), and [8](ch08.xhtml#ch08),
    you’ll learn to build machine learning systems for detecting malware. Combining
    these detection techniques with what you’ve already learned will help you catch
    advanced malware that other tools miss, as well as analyze its relationships to
    other known malware to gain clues about who deployed the malware and what their
    goals are.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
