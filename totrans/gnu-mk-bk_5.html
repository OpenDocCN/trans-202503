<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Pushing the Envelope"><div class="titlepage"><div><div><h1 class="title"><a id="pushing_the_envelope"/>Chapter 5. Pushing the Envelope</h1></div></div></div><p><a id="iddle1056" class="indexterm"/>In this chapter, you’ll find techniques that you usually won’t need but can, from time to time, be very useful. For example, sometimes it’s useful to extend GNU <code class="literal">make</code>’s language by creating new functions in C or even Guile. This chapter shows how to do that and more.</p><div class="sect1" title="Doing Arithmetic"><div class="titlepage"><div><div><h1 class="title"><a id="doing_arithmetic"/>Doing Arithmetic</h1></div></div></div><p>GNU <code class="literal">make</code> has no built-in arithmetic capability. But it is possible to create functions for addition, subtraction, multiplication, and division of integers. You can also create functions for integer comparisons, such as greater than or not equal. These functions are implemented entirely using GNU <code class="literal">make</code>’s built-in list and string manipulation functions: <code class="literal">$(subst)</code>, <code class="literal">$(filter)</code>, <code class="literal">$(filter-out)</code>, <code class="literal">$(words)</code>, <code class="literal">$(wordlist)</code>, <code class="literal">$(call)</code>, <code class="literal">$(foreach)</code>, and <code class="literal">$(if)</code>. After we define our arithmetic functions, we’ll implement a simple calculator in GNU <code class="literal">make</code>.</p><p><a id="iddle1043" class="indexterm"/><a id="iddle1057" class="indexterm"/><a id="iddle1180" class="indexterm"/><a id="iddle1183" class="indexterm"/><a id="iddle1428" class="indexterm"/><a id="iddle1621" class="indexterm"/><a id="iddle1804" class="indexterm"/><a id="iddle1927" class="indexterm"/>To create an arithmetic library, we first need a representation of numbers. A simple way to represent a number is with a list containing that number of items. For example, for the arithmetic library, a number is a list of letter <code class="literal">x</code>s. So the number 5 is represented by <code class="literal">x x x x x</code>.</p><p>Given this representation, we can use the <code class="literal">$(words)</code> function to convert from the internal form (all <code class="literal">x</code>s) to a human-readable form. For example, the following will output 5:</p><a id="pro_id00417"/><pre class="programlisting">five := x x x x x

all: ; @echo $(words $(five))</pre><p>Let’s create a user-defined function <code class="literal">decode</code> to translate from the <code class="literal">x</code> representation to a number:</p><a id="pro_id00418"/><pre class="programlisting">decode = $(words $1)</pre><p>To use <code class="literal">decode</code> in a makefile, we need to use the GNU <code class="literal">make</code> function <code class="literal">$(call)</code>, which can call a user-defined function with a set of arguments:</p><a id="pro_id00419"/><pre class="programlisting">five := x x x x x

all: ; @echo $(call decode,$(five))</pre><p>The arguments will be stored in temporary variables called <code class="literal">$1</code>, <code class="literal">$2</code>, <code class="literal">$3</code>, and so on. In <code class="literal">decode</code>, which takes one argument—the number to decode—we just use <code class="literal">$1</code>.</p><div class="sect2" title="Addition and Subtraction"><div class="titlepage"><div><div><h2 class="title"><a id="addition_and_subtraction"/>Addition and Subtraction</h2></div></div></div><p>Now that we have a representation, we can define functions for addition, increment (by 1), and decrement (by 1):</p><a id="pro_id00420"/><pre class="programlisting">plus = $1 $2
increment = x $1
decrement = $(wordlist 2,$(words $1),$1)</pre><p>The <code class="literal">plus</code> function makes a list of its two arguments; concatenation is enough to implement addition with the <code class="literal">x</code> representation. The <code class="literal">increment</code> function adds a single <code class="literal">x</code> to its argument. <code class="literal">decrement</code> strips the first <code class="literal">x</code> off its argument by asking for the entire string of <code class="literal">x</code>s starting from index 2. For example, the following code will output 11:</p><a id="pro_id00421"/><pre class="programlisting">two := x x
three := x x x
four := x x x x
five := x x x x x
six := x x x x x x

all: ; @echo $(call decode,$(call plus,$(five),$(six)))</pre><p><a id="iddle1224" class="indexterm"/><a id="iddle1449" class="indexterm"/><a id="iddle1525" class="indexterm"/><a id="iddle1536" class="indexterm"/><a id="iddle1799" class="indexterm"/>Notice the nested calls to <code class="literal">plus</code> inside a call to <code class="literal">decode</code> so that we output the number 11 instead of a list of 11 <code class="literal">x</code>s.</p><p>We can create another simple function, <code class="literal">double</code>, which doubles its argument:</p><a id="pro_id00422"/><pre class="programlisting">double = $1 $1</pre><p>Implementing subtraction is more challenging that addition. But before we do that, let’s implement <code class="literal">max</code> and <code class="literal">min</code> functions:</p><a id="pro_id00423"/><pre class="programlisting">max = $(subst xx,x,$(join $1,$2))
min = $(subst xx,x,$(filter xx,$(join $1,$2)))</pre><p>The <code class="literal">max</code> function uses two GNU <code class="literal">make</code> built-in functions: <code class="literal">$(join)</code> and <code class="literal">$(subst)</code>. <code class="literal">$(join LIST1,LIST2)</code> takes two lists as arguments and joins the two lists together by concatenating the first element of <code class="literal">LIST1</code> with the first element of <code class="literal">LIST2</code> and so on through the list. If one list is longer than the other, the remaining items are just appended.</p><p><code class="literal">$(subst FROM,TO,LIST)</code> runs through a list and substitutes elements that match a <code class="literal">FROM</code> pattern with the <code class="literal">TO</code> value. To see how <code class="literal">max</code> works, consider the sequence of events in computing <code class="literal">$(call max,$(five),$(six))</code>:</p><a id="pro_id00424"/><pre class="programlisting">$(call max,$(five),$(six))
→  $(call max,x x x x x,x x x x x x)
→  $(subst xx,x,$(join x x x x x,x x x x x x))
→  $(subst xx,x,xx xx xx xx xx x)
→  x x x x x x</pre><p>First, <code class="literal">$(join)</code> joins the list with five <code class="literal">x</code>s with the list with six <code class="literal">x</code>s, resulting in a list with six elements, the first five of which are <code class="literal">xx.</code> Then, <code class="literal">$(subst)</code> turns the first five <code class="literal">xx</code>s into <code class="literal">x</code>s. The final result is six <code class="literal">x</code>s, which is the maximum.</p><p>To implement <code class="literal">min</code>, we use a similar trick, but we keep only the <code class="literal">xx</code>s and throw away the <code class="literal">x</code>s:</p><a id="pro_id00425"/><pre class="programlisting">$(call min,$(five),$(six))
→  $(call min,x x x x x,x x x x x x)
→  $(subst xx,x,$(filter xx,$(join x x x x x,x x x x x x)))
→  $(subst xx,x,$(filter xx,xx xx xx xx xx x))
→  $(subst xx,x,xx xx xx xx xx)
→  x x x x x</pre><p>The <code class="literal">xx</code>s represent where the two lists could be joined. The shorter of the two lists will have only <code class="literal">xx</code>s. The <code class="literal">$(filter PATTERN,LIST)</code> function runs through the list and removes elements that do not match the pattern.</p><p>A similar pattern works for subtraction:</p><a id="pro_id00426"/><pre class="programlisting">subtract = $(if $(call gte,$1,$2),          \
       $(filter-out xx,$(join $1,$2)),      \
       $(warning Subtraction underflow))</pre><p><a id="page_64"/>For a moment, ignore the <code class="literal">$(warning)</code> and <code class="literal">$(if)</code> parts of the definition, and focus on <code class="literal">$(filter-out)</code>. <code class="literal">$(filter-out)</code> is the opposite of <code class="literal">$(filter)</code>: it removes elements from a list that match the pattern. For example, we can see that the <code class="literal">$(filter-out)</code> here implements subtraction:</p><a id="pro_id00427"/><pre class="programlisting">$(filter-out xx,$(join $(six),$(five)))
→  $(filter-out xx,$(join x x x x x x,x x x x x))
→  $(filter-out xx,xx xx xx xx xx x)
→  x</pre><p><a id="iddle1250" class="indexterm"/><a id="iddle1285" class="indexterm"/><a id="iddle1389" class="indexterm"/><a id="iddle1392" class="indexterm"/><a id="iddle1395" class="indexterm"/>Unfortunately, this would also work if five and six were reversed, so we first need to check that the first argument is greater than or equal to the second. In the <code class="literal">subtract</code> definition, the special function <code class="literal">gte</code> (<span class="emphasis"><em>greater than or equal</em></span>) returns a non-empty string if its first argument is greater than its second. We use <code class="literal">gte</code> to decide whether to do the subtraction or output a warning message using <code class="literal">$(warning)</code>.</p><p>The <code class="literal">gte</code> function is implemented using two other functions for <span class="emphasis"><em>greater than</em></span> (<code class="literal">gt</code>) and <span class="emphasis"><em>equal</em></span> (<code class="literal">eq</code>):</p><a id="pro_id00428"/><pre class="programlisting">gt = $(filter-out $(words $2),$(words $(call max,$1,$2)))
eq = $(filter $(words $1),$(words $2))
gte = $(call gt,$1,$2)$(call eq,$1,$2)</pre><p><code class="literal">gte</code> will return a non-empty string if either <code class="literal">gt</code> or <code class="literal">eq</code> returns a non-empty string.</p><p>The <code class="literal">eq</code> function is a bit of a mind-bender. It works out the number of elements in its two arguments, treats one argument as a pattern and the other as a list, and uses <code class="literal">$(filter)</code> to decide whether they are the same. Here’s an example where they are equal:</p><a id="pro_id00429"/><pre class="programlisting">$(call eq,$(five),$(five))
→  $(call eq,x x x x x,x x x x x)
→  $(filter $(words x x x x x),$(words x x x x x))
→  $(filter 5,5)
→  5</pre><p>The <code class="literal">eq</code> function converts both <code class="literal">$(five)</code>s to a list of five <code class="literal">x</code>s. These are then both converted to the number 5 using <code class="literal">$(words)</code>. The two 5s are fed to <code class="literal">$(filter)</code>. Because the two arguments of <code class="literal">$(filter)</code> are the same, the result is 5 and because 5 is not an empty string, it is interpreted as meaning <span class="emphasis"><em>true</em></span>.</p><p>Here’s what happens when they are not:</p><a id="pro_id00430"/><pre class="programlisting">$(call eq,$(five),$(six))
→  $(call eq,x x x x x,x x x x x x)
→  $(filter $(words x x x x x),$(words x x x x x x))
→  $(filter 5,6)</pre><p>This proceeds as for <code class="literal">$(call eq,$(five),$(five))</code> but with <code class="literal">$(six)</code> in place of one of the <code class="literal">$(five)</code>s. Since <code class="literal">$(filter 5,6)</code> is an empty string, the result is false.</p><p><a id="iddle1059" class="indexterm"/><a id="iddle1219" class="indexterm"/><a id="iddle1286" class="indexterm"/><a id="iddle1390" class="indexterm"/><a id="iddle1396" class="indexterm"/><a id="iddle1461" class="indexterm"/><a id="iddle1463" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1493" class="indexterm"/><a id="iddle1545" class="indexterm"/><a id="iddle1555" class="indexterm"/><a id="iddle1568" class="indexterm"/>So the <code class="literal">$(filter)</code> function acts as a kind of string equality operator; the two strings in our case are the lengths of the two number strings. The <code class="literal">gt</code> function is implemented in a similar way: it returns a non-empty string if the length of the first number string is not equal to the maximum of the two number strings. Here’s an example:</p><a id="pro_id00431"/><pre class="programlisting">$(call gt,$(six),$(five))
→  $(call gt,x x x x x x,x x x x x)
→  $(filter-out $(words x x x x x),
   $(words $(call max,x x x x x x,x x x x x)))
→  $(filter-out $(words x x x x x),$(words x x x x x x))
→  $(filter-out 5,6)
→  6</pre><p>The <code class="literal">gt</code> function works in a manner similar to <code class="literal">eq</code> (described previously) but uses <code class="literal">$(filter-out)</code> instead of <code class="literal">$(filter)</code>. It converts both <code class="literal">x</code>-representation numbers to digits but compares—using <code class="literal">$(filter-out)</code>—the first of them against the max of the two. When the first number is greater than the second, two different numbers are fed to <code class="literal">$(filter-out)</code>. Because they are different, <code class="literal">$(filter-out)</code> returns a non-empty string indicating true.</p><p>Here’s an example in which the first number is less than the second:</p><a id="pro_id00432"/><pre class="programlisting">$(call gt,$(five),$(six))
→  $(call gt,x x x x x,x x x x x x)
→  $(filter-out $(words x x x x x x),
   $(words $(call max,x x x x x x,x x x x x)))
→  $(filter-out $(words x x x x x x),$(words x x x x x x))
→  $(filter-out 6,6)</pre><p>Here, because the <code class="literal">max</code> of the two numbers is the same as the second number (because it’s the largest), <code class="literal">$(filter-out)</code> is fed the same number and returns an empty string indicating false.</p><p>Similarly, we can define <span class="emphasis"><em>not-equal</em></span> (<code class="literal">ne</code>), <span class="emphasis"><em>less-than</em></span> (<code class="literal">lt</code>), and <span class="emphasis"><em>less-than-or-equal</em></span> (<code class="literal">lte</code>) operators:</p><a id="pro_id00433"/><pre class="programlisting">lt = $(filter-out $(words $1),$(words $(call max,$1,$2)))
ne = $(filter-out $(words $1),$(words $2))
lte = $(call lt,$1,$2)$(call eq,$1,$2)</pre><p><code class="literal">lte</code> is defined in terms of <code class="literal">lt</code> and <code class="literal">eq</code>. Because a non-empty string means <span class="emphasis"><em>true</em></span>, <code class="literal">lte</code> just concatenates the values returned by <code class="literal">lt</code> and <code class="literal">eq</code>; if either returned true, then <code class="literal">lte</code> returns true.</p></div><div class="sect2" title="Multiplication and Division"><div class="titlepage"><div><div><h2 class="title"><a id="multiplication_and_division"/>Multiplication and Division</h2></div></div></div><p>We’ll have a pretty powerful arithmetic package after we define just three more functions: <code class="literal">multiply</code>, <code class="literal">divide</code>, and <code class="literal">encode</code>. <code class="literal">encode</code> is a way to create a number string of <code class="literal">x</code>s from an integer; we’ll leave that for last and then implement our calculator.</p><p><a id="iddle1216" class="indexterm"/><a id="iddle1393" class="indexterm"/><a id="iddle1546" class="indexterm"/>Multiplication uses the <code class="literal">$(foreach VAR,LIST,DO)</code> function. It sets that variable named <code class="literal">VAR</code> to each element of <code class="literal">LIST</code> and does whatever <code class="literal">DO</code> says. So multiplication is easy to implement:</p><a id="pro_id00434"/><pre class="programlisting">multiply = $(foreach a,$1,$2)</pre><p><code class="literal">multiply</code> just strings together its second argument for however many <code class="literal">x</code>s there are in the first argument. For example:</p><a id="pro_id00435"/><pre class="programlisting">$(call multiply,$(two),$(three))
→  $(call multiply,x x,x x x)
→  $(foreach a,x x,x x x)
→  x x x x x x</pre><p><code class="literal">divide</code> is the most complex function of the lot because it requires recursion:</p><a id="pro_id00436"/><pre class="programlisting">divide = $(if $(call gte,$1,$2),             \
    x $(call divide,$(call subtract,$1,$2),$2),)</pre><p>If its first argument is less than its second, division returns <code class="literal">0</code> because the <code class="literal">ELSE</code> part of the <code class="literal">$(if)</code> is empty (see the <code class="literal">,)</code> at the end). If division is possible, <code class="literal">divide</code> works by repeated subtraction of the second argument from the first, using the <code class="literal">subtract</code> function. Each time it subtracts, it adds an <code class="literal">x</code> and calls <code class="literal">divide</code> again. Here’s an example:</p><a id="pro_id00437"/><pre class="programlisting">$(call divide,$(three),$(two))
→  $(call divide,x x x,x x)
→  $(if $(call gte,x x x,x x),
   x $(call divide,$(call subtract,x x x,x x),x x),)

→  x $(call divide,$(call subtract,x x x,x x),x x)
→  x $(call divide,x,x x)
→  x $(if $(call gte,x,x x),
   x $(call divide,$(call subtract,x,x x),x x),)

→  x</pre><p>First, <code class="literal">gte</code> returns a non-empty string, so recursion happens. Next, <code class="literal">gte</code> returns an empty string, so no more recursion occurs.</p><p>We can avoid recursion in the special case of division by 2; we define the <code class="literal">halve</code> function to be the opposite of <code class="literal">double</code>:</p><a id="pro_id00438"/><pre class="programlisting">halve = $(subst xx,x,      \
   $(filter-out xy x y,    \
     $(join $1,$(foreach a,$1,y x))))</pre><p>By now you’ve seen all the functions used in <code class="literal">halve</code>. Work through an example, say <code class="literal">$(call halve,$(five))</code>, to see how it works.</p><p><a id="iddle1058" class="indexterm"/><a id="iddle1100" class="indexterm"/><a id="iddle1685" class="indexterm"/>The only tricky thing to do is turn a number a user enters into a string of <code class="literal">x</code>s. The <code class="literal">encode</code> function does this by deleting a substring of <code class="literal">x</code>s from a predefined list of <code class="literal">x</code>s:</p><a id="pro_id00439"/><pre class="programlisting">16 := x x x x x x x x x x x x x x x x
input_int := $(foreach a,$(16),      \
       $(foreach b,$(16),            \
        $(foreach c,$(16),$(16)))))

encode = $(wordlist 1,$1,$(input_int))</pre><p>Here we are limited to entering numbers up to 65536. We can fix that by changing the number of <code class="literal">x</code>s in <code class="literal">input_int</code>. Once we have the number in the encoding, only available memory limits the size of integers we can work with.</p></div><div class="sect2" title="Using Our Arithmetic Library: A Calculator"><div class="titlepage"><div><div><h2 class="title"><a id="using_our_arithmetic_library_a_calculato"/>Using Our Arithmetic Library: A Calculator</h2></div></div></div><p>To really show off this library, here’s an implementation of a Reverse Polish Notation calculator written entirely in GNU <code class="literal">make</code> functions:</p><a id="pro_id00440"/><pre class="programlisting">stack :=

push = $(eval stack := $$1 $(stack))
pop = $(word 1,$(stack))$(eval stack := $(wordlist 2,$(words $(stack)),$(stack)))
pope = $(call encode,$(call pop))
pushd = $(call push,$(call decode,$1))
comma := ,
calculate = $(foreach t,$(subst $(comma), ,$1),$(call handle,$t))$(stack)
seq = $(filter $1,$2)
handle = $(call pushd,                            \
    $(if $(call seq,+,$1),                        \
      $(call plus,$(call pope),$(call pope)),     \
      $(if $(call seq,-,$1),                      \
      $(call subtract,$(call pope),$(call pope)), \
        $(if $(call seq,*,$1),                    \
     $(call multiply,$(call pope),$(call pope)),  \
        $(if $(call seq,/,$1),                    \
       $(call divide,$(call pope),$(call pope)),  \
           $(call encode,$1))))))

.PHONY: calc
calc: ; @echo $(call calculate,$(calc))</pre><p>The operators and numbers are passed into GNU <code class="literal">make</code> in the <code class="literal">calc</code> variable, separated by commas. For example:</p><a id="pro_id00441"/><pre class="programlisting">$ <span class="strong"><strong>make calc="3,1,-,3,21,5,*,+,/"</strong></span>
54</pre><p><a id="iddle1181" class="indexterm"/><a id="iddle1217" class="indexterm"/><a id="iddle1251" class="indexterm"/><a id="iddle1391" class="indexterm"/><a id="iddle1394" class="indexterm"/><a id="iddle1397" class="indexterm"/><a id="iddle1462" class="indexterm"/><a id="iddle1464" class="indexterm"/><a id="iddle1492" class="indexterm"/><a id="iddle1494" class="indexterm"/><a id="iddle1526" class="indexterm"/><a id="iddle1537" class="indexterm"/><a id="iddle1547" class="indexterm"/><a id="iddle1556" class="indexterm"/><a id="iddle1622" class="indexterm"/><a id="iddle1802" class="indexterm"/>Clearly, this is not what GNU <code class="literal">make</code> was designed for, but it does show the power of GNU <code class="literal">make</code> functions. Here’s the complete commented makefile:</p><a id="pro_id00442"/><pre class="programlisting"># input_int consists of 65536 x's built from the 16 x's in 16

16 := x x x x x x x x x x x x x x x x
input_int := $(foreach a,$(16),$(foreach b,$(16),$(foreach c,$(16),$(16)))))

# decode turns a number in x's representation into an integer for human
# consumption

decode = $(words $1)

# encode takes an integer and returns the appropriate x's
# representation of the number by chopping $1 x's from the start of
# input_int

encode = $(wordlist 1,$1,$(input_int))

# plus adds its two arguments, subtract subtracts its second argument
# from its first if and only if this would not result in a negative result

plus = $1 $2

subtract = $(if $(call gte,$1,$2),     \
       $(filter-out xx,$(join $1,$2)), \
       $(warning Subtraction underflow))

# multiply multiplies its two arguments and divide divides its first
# argument by its second

multiply = $(foreach a,$1,$2)
divide = $(if $(call gte,$1,$2),x $(call divide,$(call subtract,$1,$2),$2),)

# max returns the maximum of its arguments and min the minimum

max = $(subst xx,x,$(join $1,$2))
min = $(subst xx,x,$(filter xx,$(join $1,$2)))

# The following operators return a non-empty string if their result is true:
#
# gt First argument is greater than second argument
# gte First argument is greater than or equal to second argument
# lt First argument is less than second argument

# lte First argument is less than or equal to second argument
# eq First argument is numerically equal to the second argument
# ne First argument is not numerically equal to the second argument

gt = $(filter-out $(words $2),$(words $(call max,$1,$2)))
lt = $(filter-out $(words $1),$(words $(call max,$1,$2)))
eq = $(filter $(words $1),$(words $2))
ne = $(filter-out $(words $1),$(words $2))
gte = $(call gt,$1,$2)$(call eq,$1,$2)
lte = $(call lt,$1,$2)$(call eq,$1,$2)

# increment adds 1 to its argument, decrement subtracts 1. Note that
# decrement does not range check and hence will not underflow, but
# will incorrectly say that 0 - 1 = 0

increment = $1 x
decrement = $(wordlist 2,$(words $1),$1)

# double doubles its argument, and halve halves it

double = $1 $1
halve = $(subst xx,x,$(filter-out xy x y,$(join $1,$(foreach a,$1,y x))))

# This code implements a Reverse Polish Notation calculator by
# transforming a comma-separated list of operators (+ - * /) and
# numbers stored in the calc variable into the appropriate calls to
# the arithmetic functions defined in this makefile.

# This is the current stack of numbers entered into the calculator. The push
# function puts an item onto the top of the stack (the start of the list), and
# pop removes the top item.

stack :=

push = $(eval stack := $$1 $(stack))
pop = $(word 1,$(stack))$(eval stack := $(wordlist 2,$(words $(stack)),$(stack)))

# pope pops a number off the stack and encodes it
# and pushd pushes a number onto the stack after decoding

pope = $(call encode,$(call pop))
pushd = $(call push,$(call decode,$1))

# calculate runs through the input numbers and operations and either
# pushes a number on the stack or pops two numbers off and does a
# calculation followed by pushing the result back. When calculate is
# finished, there will be one item on the stack, which is the result.

comma := ,
calculate=$(foreach t,$(subst $(comma), ,$1),$(call handle,$t))$(stack)

# seq is a string equality operator that returns true (a non-empty
# string) if the two strings are equal

seq = $(filter $1,$2)

# handle is used by calculate to handle a single token. If it's an
# operator, the appropriate operator function is called; if it's a
# number, it is pushed.

handle = $(call pushd,                            \
      $(if $(call seq,+,$1),                      \
        $(call plus,$(call pope),$(call pope)),   \
        $(if $(call seq,-,$1),                    \
      $(call subtract,$(call pope),$(call pope)), \
          $(if $(call seq,*,$1),                  \
      $(call multiply,$(call pope),$(call pope)), \
            $(if $(call seq,/,$1),                \
       $(call divide,$(call pope),$(call pope)),  \
              $(call encode,$1))))))

.PHONY: calc
calc: ; @echo $(call calculate,$(calc))</pre><p><a id="iddle1182" class="indexterm"/><a id="iddle1427" class="indexterm"/><a id="iddle1465" class="indexterm"/><a id="iddle1495" class="indexterm"/><a id="iddle1625" class="indexterm"/><a id="iddle1649" class="indexterm"/><a id="iddle1650" class="indexterm"/><a id="iddle1705" class="indexterm"/><a id="iddle1081" class="indexterm"/><a id="iddle1930" class="indexterm"/>You’ll get a closer look at these techniques in <a class="xref" href="ch06.html" title="Chapter 6. The GNU Make Standard Library">Chapter 6</a> when you learn about the GNU Make Standard Library.</p></div></div><div class="sect1" title="Making an XML Bill of Materials"><div class="titlepage"><div><div><h1 class="title"><a id="making_an_xml_bill_of_materials"/>Making an XML Bill of Materials</h1></div></div></div><p>With standard GNU <code class="literal">make</code> output, it’s difficult to answer the question of what got built and why. This section presents a simple technique to get GNU <code class="literal">make</code> to create an XML file containing a <span class="emphasis"><em>bill of materials (BOM)</em></span>. The BOM contains the names of all the files built by the makefile and is nested to show the prerequisites of each file.</p><div class="sect2" title="An Example Makefile and BOM"><div class="titlepage"><div><div><h2 class="title"><a id="example_makefile_and_bom"/>An Example Makefile and BOM</h2></div></div></div><p><a class="xref" href="ch05.html#simple_makefile_to_illustrate_the_bom" title="Example 5-1. A simple makefile to illustrate the BOM">Example 5-1</a> shows an example makefile. We’ll look at its BOM and then work backward to see how the BOM JSON file was generated.</p><div class="example"><a id="simple_makefile_to_illustrate_the_bom"/><p class="title">Example 5-1. A simple makefile to illustrate the BOM</p><div class="example-contents"><pre class="programlisting">all: foo bar
→  @echo Making $@

foo: baz
→  @echo Making $@

bar:
→  @echo Making $@

baz:
→  @echo Making $@</pre></div></div><p>This makes <code class="literal">all</code> from <code class="literal">foo</code> and <code class="literal">bar.</code> In turn, <code class="literal">foo</code> is made from <code class="literal">baz</code>. Running this code in GNU <code class="literal">make</code> produces the following output:</p><a id="pro_id00443"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Making baz
Making foo
Making bar
Making all</pre><p><a id="iddle1931" class="indexterm"/>From the output, it’s impossible to identify the tree-ordering of the build or which files depend on which. In this case, the makefile is small and relatively easy to trace by hand; in a real makefile, hand tracing is almost impossible.</p><p>It would be nice to produce output like that shown in <a class="xref" href="ch05.html#xml_document_showing_the_structure_of_th" title="Example 5-2. An XML document showing the structure of the example makefile">Example 5-2</a> that shows what was built and why:</p><div class="example"><a id="xml_document_showing_the_structure_of_th"/><p class="title">Example 5-2. An XML document showing the structure of the example makefile</p><div class="example-contents"><pre class="programlisting">&lt;rule target="all"&gt;
&lt;prereq&gt;
 &lt;rule target="foo"&gt;
  &lt;prereq&gt;
   &lt;rule target="baz" /&gt;
  &lt;/prereq&gt;
 &lt;/rule&gt;
 &lt;rule target="bar" /&gt;
&lt;/prereq&gt;
&lt;/rule&gt;</pre></div></div><p>Here, each rule run by the makefile has a <code class="literal">&lt;rule&gt;</code> tag added with a <code class="literal">target</code> attribute giving the name of the target that the rule built. If the rule had any prerequisites, within the <code class="literal">&lt;rule&gt;</code>/<code class="literal">&lt;/rule&gt;</code> pair a list of prerequisite rules would be enclosed in <code class="literal">&lt;prereq&gt;</code>/<code class="literal">&lt;/prereq&gt;</code>.</p><p>You can see the structure of the makefile reflected in the nesting of the tags. Loading the XML document into an XML editor (or simply into a web browser) allows you to expand and contract the tree at will to explore the structure of the makefile.</p></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works"/>How It Works</h2></div></div></div><p>To create the output shown in <a class="xref" href="ch05.html#xml_document_showing_the_structure_of_th" title="Example 5-2. An XML document showing the structure of the example makefile">Example 5-2</a>, the example makefile is modified to include a special <code class="literal">bom</code> makefile using the standard <code class="literal">include bom</code> method. With that included, we can generate the XML output by running GNU <code class="literal">make</code> using a command line, such as <code class="literal">make bom-all</code>.</p><p><code class="literal">bom-all</code> instructs GNU <code class="literal">make</code> to build the BOM starting with the <code class="literal">all</code> target. It’s as if you typed <code class="literal">make all</code>, but now an XML document will be created.</p><p>By default, the XML document has the same name as the makefile but with <code class="literal">.xml</code> appended. If the example makefile was in <code class="literal">example.mk</code>, the XML document created would be called <code class="literal">example.mk.xml</code>.</p><p><a class="xref" href="ch05.html#bom_makefile_that_creates_xml_boms" title="Example 5-3. The bom makefile that creates XML BOMs">Example 5-3</a> shows the contents of the <code class="literal">bom</code> makefile to include:</p><div class="example"><a id="bom_makefile_that_creates_xml_boms"/><p class="title">Example 5-3. The <code class="literal">bom</code> makefile that creates XML BOMs</p><div class="example-contents"><pre class="programlisting">➊ PARENT_MAKEFILE := $(word $(words $(MAKEFILE_LIST)),x $(MAKEFILE_LIST))
➋ bom-file := $(PARENT_MAKEFILE).xml

➌ bom-old-shell := $(SHELL)
➍ SHELL = $(bom-run)$(bom-old-shell)

   bom-%: %
➎ → @$(shell rm -f $(bom-file))$(call bom-dump,$*)
   bom-write = $(shell echo '$1' &gt;&gt; $(bom-file))
➏ bom-dump = $(if $(bom-prereq-$1),$(call bom-write,&lt;rule target="$1"&gt;)      \
   $(call bom-write,&lt;prereq&gt;)$(foreach p,$(bom-prereq-$1),                    \
   $(call bom-dump,$p))$(call bom-write,&lt;/prereq&gt;)$(call bom-write,&lt;/rule&gt;),  \
   $(call bom-write,&lt;rule target="$1" /&gt;))

➐ bom-run = $(if $@,$(eval bom-prereq-$@ := $^))</pre></div></div><p><a id="iddle1737" class="indexterm"/>First we determine the correct name for the XML file by extracting the name of the makefile that included <code class="literal">bom</code> into <code class="literal">PARENT_MAKEFILE</code> ➊, appending <code class="literal">.xml</code>, and storing the resulting name in <code class="literal">bom-file</code> ➋.</p><p>Then we use a trick that’s appeared in this book a number of times: the <code class="literal">SHELL</code> hack. GNU <code class="literal">make</code> will expand the value of <code class="literal">$(SHELL)</code> for every rule that’s run in the makefile. And at the time that <code class="literal">$(SHELL)</code> is expanded, the per-rule automatic variables (such as <code class="literal">$@</code>) have already been set. So by modifying <code class="literal">SHELL</code>, we can perform some task for every rule in the makefile as it runs.</p><p>At ➌, we store the original value of <code class="literal">SHELL</code> in <code class="literal">bom-old-shell</code> using an immediate assignment (<code class="literal">:=</code>), and we then redefine <code class="literal">SHELL</code> to be the expansion of <code class="literal">$(bom-run)</code> and the original shell at ➍. Because <code class="literal">$(bom-run)</code> actually expands to an empty string, the effect is that <code class="literal">bom-run</code> is expanded for each rule in the makefile, but the actual shell used is unaffected.</p><p><code class="literal">bom-run</code> is defined at ➐. It uses <code class="literal">$(eval)</code> to store the relationship between the current target being built (the <code class="literal">$(if)</code> ensures that <code class="literal">$@</code> is defined) and its prerequisites. For example, when <code class="literal">foo</code> is being built, a call will be made to <code class="literal">bom-run</code> with <code class="literal">$@</code> set to <code class="literal">foo</code> and <code class="literal">$^</code> (the list of all prerequisites) set to <code class="literal">baz</code>. <code class="literal">bom-run</code> will set the value of <code class="literal">bom-prereq-foo</code> to <code class="literal">baz</code>. Later, the values of these <code class="literal">bom-prereq-X</code> variables are used to print out the XML tree.</p><p>At ➎, we define the pattern rule that handles the <code class="literal">bom-%</code> target. Because the prerequisite of <code class="literal">bom-%</code> is <code class="literal">%</code>, this pattern rule has the effect of building the target matching the <code class="literal">%</code> and then building <code class="literal">bom-%</code>. In our example, running <code class="literal">make bom-all</code> matches against this pattern rule to build <code class="literal">all</code> and then run the commands associated with <code class="literal">bom-%</code> with <code class="literal">$*</code> set to <code class="literal">all</code>.</p><p><code class="literal">bom-%</code>’s commands first delete the <code class="literal">bom-file</code> and then recursively dump out the XML starting from <code class="literal">$*</code>. In this example, where the user did <code class="literal">make bom-all</code>, the <code class="literal">bom-%</code> commands call <code class="literal">bom-dump</code> with the argument <code class="literal">all</code>.</p><p>We define <code class="literal">bom-dump</code> at ➏. It’s fairly routine: it uses a helper function <code class="literal">bom-write</code> to echo fragments of XML to the <code class="literal">bom-file</code> and calls itself for each of the targets in the prerequisites of each target it is dumping. Prerequisites are extracted from the <code class="literal">bom-prereq-X</code> variables created by <code class="literal">bom-run</code>.</p></div><div class="sect2" title="Gotchas"><div class="titlepage"><div><div><h2 class="title"><a id="gotchas"/>Gotchas</h2></div></div></div><p>The technique in <a class="xref" href="ch05.html#bom_makefile_that_creates_xml_boms" title="Example 5-3. The bom makefile that creates XML BOMs">Example 5-3</a> comes with a few gotchas. One gotcha is that the technique can end up producing enormous amounts of output. This is because it will print the entire tree below any target. If a target appears <a id="iddle1508" class="indexterm"/><a id="iddle1690" class="indexterm"/>multiple times in the tree, a large tree can be repeated many times in the output. Even for small projects, this can make the dump time for the XML very lengthy.</p><p>As a workaround, we can change the definition of <code class="literal">bom-dump</code> to just dump the prerequisite information once for each target. This is much faster than the approach in <a class="xref" href="ch05.html#bom_makefile_that_creates_xml_boms" title="Example 5-3. The bom makefile that creates XML BOMs">Example 5-3</a> and could be processed by a script like the following to help understand the structure of the <code class="literal">make</code>:</p><a id="pro_id00444"/><pre class="programlisting">bom-%: %
→  @$(shell rm -f $(bom-file))$(call bom-write,&lt;bom&gt;)$(call bom-dump,$*)$(call bom-write,&lt;/bom&gt;)

bom-write = $(shell echo '$1' &gt;&gt; $(bom-file))

bom-dump = $(if $(bom-prereq-$1),$(call bom-write,&lt;rule target="$1"&gt;) \
$(call bom-write,&lt;prereq&gt;)$(foreach p,$(bom-prereq-$1),               \
$(call bom-write,&lt;rule target="$p" /&gt;))$(call bom-write,&lt;/prereq&gt;)    \
$(call bom-write,&lt;/rule&gt;),$(call bom-write,&lt;rule target="$1" /&gt;))     \
$(foreach p,$(bom-prereq-$1),$(call bom-dump,$p))$(eval bom-prereq-$1 := )</pre><p>For the example makefile in <a class="xref" href="ch05.html#simple_makefile_to_illustrate_the_bom" title="Example 5-1. A simple makefile to illustrate the BOM">Example 5-1</a>, the XML document now looks like this:</p><a id="pro_id00445"/><pre class="programlisting">&lt;bom&gt;
&lt;rule target="all"&gt;
 &lt;prereq&gt;
  &lt;rule target="foo" /&gt;
  &lt;rule target="bar" /&gt;
 &lt;/prereq&gt;
&lt;/rule&gt;
&lt;rule target="foo"&gt;
 &lt;prereq&gt;
  &lt;rule target="baz" /&gt;
 &lt;/prereq&gt;
&lt;/rule&gt;
&lt;rule target="baz" /&gt;
&lt;rule target="bar" /&gt;
&lt;/bom&gt;</pre><p>Another gotcha is that if the makefile includes rules with no commands, those rules will cause a break in the tree outputted by the technique in <a class="xref" href="ch05.html#bom_makefile_that_creates_xml_boms" title="Example 5-3. The bom makefile that creates XML BOMs">Example 5-3</a>. For example, if the example makefile were this:</p><a id="pro_id00446"/><pre class="programlisting">all: foo bar
→ @echo Making $@

foo: baz

bar:
→ @echo Making $@

baz:
→ @echo Making $@</pre><p><a id="iddle1306" class="indexterm"/><a id="iddle1543" class="indexterm"/><a id="iddle1854" class="indexterm"/>the resulting XML would not mention <code class="literal">baz</code> at all because the rule for <code class="literal">foo</code> doesn’t have any commands. So <code class="literal">SHELL</code> is not expanded, and the hack doesn’t work. Here’s the XML in that case:</p><a id="pro_id00447"/><pre class="programlisting">&lt;bom&gt;
&lt;rule target="all"&gt;
 &lt;prereq&gt;
  &lt;rule target="foo" /&gt;
  &lt;rule target="bar" /&gt;
 &lt;/prereq&gt;
&lt;/rule&gt;
&lt;rule target="foo" /&gt;
&lt;rule target="bar" /&gt;
&lt;/bom&gt;</pre><p>As a workaround, we can modify <code class="literal">foo: baz</code> to include a useless command:</p><a id="pro_id00448"/><pre class="programlisting">foo: baz ; @true</pre><p>Now the correct results will be generated.</p></div></div><div class="sect1" title="Advanced User-Defined Functions"><div class="titlepage"><div><div><h1 class="title"><a id="advanced_user-defined_functions"/>Advanced User-Defined Functions</h1></div></div></div><p>In <a class="xref" href="ch01.html" title="Chapter 1. The Basics Revisited">Chapter 1</a>, we looked at creating user-defined functions in GNU <code class="literal">make</code>. Now we’ll look inside the GNU <code class="literal">make</code> source code to see how we can enhance GNU <code class="literal">make</code> with our own built-in functions by writing some C code.</p><p>First, we get the GNU <code class="literal">make</code> source code from the Free Software Foundation. For this section, I’m working with GNU <code class="literal">make</code> 3.81. Things haven’t changed much with GNU <code class="literal">make</code> 3.82 or 4.0.</p><p>Download <code class="literal">make-3.81.tar.gz</code>, and <code class="literal">gunzip</code> and <code class="literal">untar</code>, and then build GNU <code class="literal">make</code> using the standard <code class="literal">configure</code> and <code class="literal">make</code>:</p><a id="pro_id00449"/><pre class="programlisting">$ <span class="strong"><strong>cd make-3.81</strong></span>
$ <span class="strong"><strong>./configure</strong></span>
$ <span class="strong"><strong>make</strong></span></pre><p>With that done, we are left with a working GNU <code class="literal">make</code> in the same directory.</p><div class="sect2" title="Getting Started Modifying GNU make"><div class="titlepage"><div><div><h2 class="title"><a id="getting_started_modifying_gnu_make"/>Getting Started Modifying GNU make</h2></div></div></div><p>It’s handy to be able to tell which GNU <code class="literal">make</code> you’re running, so as a first modification let’s change the message printed out when we ask for the version information. Here’s the default:</p><a id="pro_id00450"/><pre class="programlisting">$ <span class="strong"><strong>./make -v</strong></span>
GNU Make 3.81
Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

This program built for i386-apple-darwin9.2.0</pre><p><a id="iddle1644" class="indexterm"/>As you can see, I’m working on a Mac (that final string will change depending on the machine you are working with) with GNU <code class="literal">make</code> version 3.81.</p><p>Let’s change that message so it prints <code class="literal">(with jgc's modifications)</code> after the version number. To do that, we need to open the file <code class="literal">main.c</code> in a text editor and find the function <code class="literal">print_version</code> (at line 2,922), which looks like this:</p><a id="pro_id00451"/><pre class="programlisting">/* Print version information. */

static void
print_version (void)
{
static int printed_version = 0;

char *precede = print_data_base_flag ? "# " : "";

if (printed_version)
 /* Do it only once. */
 return;

/* Print this untranslated. The coding standards recommend translating the
  (C) to the copyright symbol, but this string is going to change every
  year, and none of the rest of it should be translated (including the
  word "Copyright", so it hardly seems worth it. */

printf ("%sGNU Make %s\n\
%sCopyright (C) 2006 Free Software Foundation, Inc.\n",
    precede, version_string, precede);

printf (_("%sThis is free software; see the source for copying conditions.\n\
%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\n\
%sPARTICULAR PURPOSE.\n"),
     precede, precede, precede);

if (!remote_description || *remote_description == '\0')
 printf (_("\n%sThis program built for %s\n"), precede, make_host);
else
 printf (_("\n%sThis program built for %s (%s)\n"),
     precede, make_host, remote_description);

printed_version = 1;

/* Flush stdout so the user doesn't have to wait to see the
  version information while things are thought about. */
fflush (stdout);
}</pre><p><a id="iddle1093" class="indexterm"/><a id="iddle1300" class="indexterm"/><a id="iddle1302" class="indexterm"/>The first <code class="literal">printf</code> in <code class="literal">print_version</code> is where the version number is printed. We can modify it like this:</p><a id="pro_id00452"/><pre class="programlisting">printf ("%sGNU Make %s (with jgc's modifications)\n\
%sCopyright (C) 2006 Free Software Foundation, Inc.\n",
    precede, version_string, precede);</pre><p>Save the file, and then rerun <code class="literal">make</code>. Now enter <span class="strong"><strong><code class="literal">make -v</code></strong></span>:</p><a id="pro_id00453"/><pre class="programlisting">$ <span class="strong"><strong>./make -v</strong></span>
GNU Make 3.81 (with jgc's modifications)
Copyright (C) 2006 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

This program built for i386-apple-darwin9.2.0</pre><p>We now know which version we’re working with.</p></div><div class="sect2" title="Anatomy of a Built-In Function"><div class="titlepage"><div><div><h2 class="title"><a id="anatomy_of_a_built-in_function"/>Anatomy of a Built-In Function</h2></div></div></div><p>GNU <code class="literal">make</code>’s built-in functions are defined in the file <code class="literal">function.c</code>. To begin understanding how this file works, take a look at the table of functions that GNU <code class="literal">make</code> knows about. It’s called <code class="literal">function_table_init[]</code> and is on line 2,046. Because it’s quite large, I’ve removed some lines from the middle:</p><a id="pro_id00454"/><pre class="programlisting">static struct function_table_entry function_table_init[] =
{
/* Name/size */          /* MIN MAX EXP? Function */
{ STRING_SIZE_TUPLE("abspath"),    0, 1, 1, func_abspath},
{ STRING_SIZE_TUPLE("addprefix"),   2, 2, 1,
func_addsuffix_addprefix},
{ STRING_SIZE_TUPLE("addsuffix"),   2, 2, 1,
func_addsuffix_addprefix},
{ STRING_SIZE_TUPLE("basename"),   0, 1, 1, func_basename_dir},
{ STRING_SIZE_TUPLE("dir"),      0, 1, 1, func_basename_dir},
--<span class="emphasis"><em>snip</em></span>--

{ STRING_SIZE_TUPLE("value"),     0, 1, 1, func_value},
{ STRING_SIZE_TUPLE("eval"),     0, 1, 1, func_eval},
#ifdef EXPERIMENTAL
{ STRING_SIZE_TUPLE("eq"),      2, 2, 1, func_eq},
{ STRING_SIZE_TUPLE("not"),      0, 1, 1, func_not},
#endif
};</pre><p>Each line defines a single function and consists of five pieces of information: the name of the function, the minimum number of arguments that the function must have, the maximum number of arguments (specifying a maximum of zero with a non-zero minimum means that the function can <a id="iddle1109" class="indexterm"/><a id="iddle1290" class="indexterm"/><a id="iddle1687" class="indexterm"/><a id="iddle1791" class="indexterm"/><a id="iddle1860" class="indexterm"/>have an unlimited number of arguments), whether the arguments should be expanded, and the name of the C function that actually performs the function.</p><p>For example, here’s the definition of the <code class="literal">findstring</code> function:</p><a id="pro_id00455"/><pre class="programlisting">{ STRING_SIZE_TUPLE("findstring"), 2, 2, 1, func_findstring},</pre><p><code class="literal">findstring</code> has a minimum of two arguments and a maximum of two, and the arguments should be expanded before calling the C function <code class="literal">func_findstring</code>. <code class="literal">func_findstring</code> (in <code class="literal">function.c</code> at line 819) does the work:</p><a id="pro_id00456"/><pre class="programlisting">static char*
func_findstring (char *o, char **argv, const char *funcname UNUSED)
{
/* Find the first occurrence of the first string in the second. */
if (strstr (argv[1], argv[0]) != 0)
 o = variable_buffer_output (o, argv[0], strlen (argv[0]));

return o;
}</pre><p>The C functions that implement GNU <code class="literal">make</code> built-in functions have three arguments: <code class="literal">o</code> (a pointer to a buffer into which output of the function should be written), <code class="literal">argv</code> (the arguments of the function as a null-terminated array of strings), and <code class="literal">funcname</code> (a string containing the name of the function; most functions don’t need this, but it can be helpful if one C routine handles more than one GNU <code class="literal">make</code> function).</p><p>You can see that <code class="literal">func_findstring</code> just uses the standard C library <code class="literal">strstr</code> function to find the presence of its second argument (in <code class="literal">argv[1]</code>) in its first (in <code class="literal">argv[0]</code>).</p><p><code class="literal">func_findstring</code> uses a handy GNU <code class="literal">make</code> C function called <code class="literal">variable_buffer_ output</code> (defined in <code class="literal">expand.c</code> at line 57). <code class="literal">variable_buffer_output</code> copies a string into the output buffer <code class="literal">o</code> of a GNU <code class="literal">make</code> function. The first argument should be the output buffer, the second the string to copy, and the last the amount of the string to copy.</p><p><code class="literal">func_findstring</code> either copies all of its first argument (if the <code class="literal">strstr</code> was successful) or leaves <code class="literal">o</code> untouched (and hence, empty, because it is initialized to an empty string before <code class="literal">func_findstring</code> is called).</p><p>With that, we have enough information to start making our own GNU <code class="literal">make</code> function.</p></div><div class="sect2" title="Reverse a String"><div class="titlepage"><div><div><h2 class="title"><a id="reverse_a_string"/>Reverse a String</h2></div></div></div><p>There’s no easy way to reverse a string in GNU <code class="literal">make</code>, but it’s easy to write a C function that does and insert it into GNU <code class="literal">make</code>.</p><p>First, we’ll add the definition of <code class="literal">reverse</code> to the list of functions that GNU <code class="literal">make</code> knows about. <code class="literal">reverse</code> will have a single argument that must be expanded and will call a C function named <code class="literal">func_reverse</code>.</p><p>Here’s the entry to add to the <code class="literal">function_table_init[]</code>:</p><a id="pro_id00457"/><pre class="programlisting">{ STRING_SIZE_TUPLE("reverse"), 1, 1, 1, func_reverse},</pre><p>Now we can define <code class="literal">func_reverse</code>, which reverses the string in <code class="literal">argv[0]</code> by swapping characters and then updates the output buffer <code class="literal">o</code>, as shown in <a class="xref" href="ch05.html#defining_a_gnu_make_function_using_c" title="Example 5-4. Defining a GNU make function using C">Example 5-4</a>:</p><div class="example"><a id="defining_a_gnu_make_function_using_c"/><p class="title">Example 5-4. Defining a GNU make function using C</p><div class="example-contents"><pre class="programlisting">static char*
func_reverse(char *o, char **argv, const char *funcname UNUSED)
{
int len = strlen(argv[0]);
if (len &gt; 0) {
 char * p = argv[0];
 int left = 0;
 int right = len - 1;
 while (left &lt; right) {
  char temp = *(p + left);
  *(p + left) = *(p + right);
  *(p + right) = temp;
  left++;
  right--;
 }

 o = variable_buffer_output(o, p, len);
}

return o;
}</pre></div></div><p>This function works by walking from the start and end of the string at the same time and swapping pairs of characters until <code class="literal">left</code> and <code class="literal">right</code> meet in the middle.</p><p>To test it, we can write a little makefile that tries three possibilities: an empty string, a string with even length, and a string with odd length, all calling the new built-in function <code class="literal">reverse</code>:</p><a id="pro_id00458"/><pre class="programlisting">EMPTY :=

$(info Empty string: [$(reverse $(EMPTY))]);

EVEN := 1234
$(info Even length string: [$(reverse $(EVEN))]);

ODD := ABCDE
$(info Odd length string: [$(reverse $(ODD))]);</pre><p><a id="iddle1108" class="indexterm"/><a id="iddle1354" class="indexterm"/><a id="iddle1479" class="indexterm"/><a id="iddle1482" class="indexterm"/><a id="iddle1682" class="indexterm"/>The output shows that it works correctly:</p><a id="pro_id00459"/><pre class="programlisting">$ <span class="strong"><strong>./make</strong></span>
Empty string: []
Even length string: [4321]
Odd length string: [EDCBA]</pre><p>Writing in C gives you access to the full range of C library functions; therefore, the GNU <code class="literal">make</code> built-in functions you can create are limited only by your imagination.</p></div></div><div class="sect1" title="GNU make 4.0 Loadable Objects"><div class="titlepage"><div><div><h1 class="title"><a id="gnu_make_4dot0_loadable_objects"/>GNU make 4.0 Loadable Objects</h1></div></div></div><p>Adding the <code class="literal">reverse</code> function to GNU <code class="literal">make</code> was fairly complex because we had to modify GNU <code class="literal">make</code>’s source code. But using GNU <code class="literal">make</code> 4.0 or later, you can add C functions to GNU <code class="literal">make</code> without changing the source code. GNU <code class="literal">make</code> 4.0 added a <code class="literal">load</code> directive you can use to load a shared object containing GNU <code class="literal">make</code> functions written in C.</p><p>You can turn the <code class="literal">reverse</code> function from <a class="xref" href="ch05.html#defining_a_gnu_make_function_using_c" title="Example 5-4. Defining a GNU make function using C">Example 5-4</a> into a loadable GNU <code class="literal">make</code> object by saving it in a file called <code class="literal">reverse.c</code> with some small modifications. Here’s the complete <code class="literal">reverse.c</code> file:</p><a id="pro_id00460"/><pre class="programlisting">   #include &lt;string.h&gt;
   #include &lt;gnumake.h&gt;

➊ int plugin_is_GPL_compatible;

   char* func_reverse(const char *nm, unsigned int argc, char **argv)
   {
     int len = strlen(argv[0]);
     if (len &gt; 0) {
➋     char * p = gmk_alloc(len+1);
       *(p+len) = '\0';
       int i;
       for (i = 0; i &lt; len; i++) {
         *(p+i) = *(argv[0]+len-i-1);
       }
       return p;
     }

     return NULL;
   }

   int reverse_gmk_setup()
   {
➌   gmk_add_function("reverse", func_reverse, 1, 1, 1);
     return 1;
   }</pre><p><a id="iddle1316" class="indexterm"/><a id="iddle1344" class="indexterm"/><a id="iddle1401" class="indexterm"/><a id="iddle1475" class="indexterm"/><a id="iddle1620" class="indexterm"/><a id="iddle1686" class="indexterm"/>The <code class="literal">reverse</code> function is added to GNU <code class="literal">make</code> by the call to <code class="literal">gmk_add_function</code> at ➌. The function <code class="literal">reverse</code> is then available to use just like any other GNU <code class="literal">make</code> built-in function. The actual reversing of a string is handled by <code class="literal">func_reverse</code>, which calls a GNU <code class="literal">make</code> API function <code class="literal">gmk_alloc</code> to allocate space for the new string at ➋.</p><p>At ➊ is a special, unused variable called <code class="literal">plugin_is_GPL_compatible</code>, which is required in any loadable module.</p><p>To use the new <code class="literal">reverse</code> function, you need to compile the <code class="literal">reverse.c</code> file into a <code class="literal">.so</code> file and load it into GNU <code class="literal">make</code>:</p><a id="pro_id00461"/><pre class="programlisting">   all:
   --<span class="emphasis"><em>snip</em></span>--
   load reverse.so
➍ reverse.so: reverse.c ; @$(CC) -shared -fPIC -o $@ $&lt;</pre><p>The <code class="literal">load</code> directive loads the <code class="literal">.so</code>, and the rule at ➍ builds the <code class="literal">.so</code> from the <code class="literal">.c</code> file. If the <code class="literal">.so</code> file is missing when GNU <code class="literal">make</code> encounters the <code class="literal">load</code> directive, GNU <code class="literal">make</code> builds it (using the rule) and then restarts, parsing the makefile from the beginning.</p><p>Once loaded, you can use <code class="literal">reverse</code> as follows:</p><a id="pro_id00462"/><pre class="programlisting">A_PALINDROME := $(reverse saippuakivikauppias)</pre><p>Notice that it is not necessary to use <code class="literal">$(call)</code>. The <code class="literal">reverse</code> function is just like any other built-in GNU <code class="literal">make</code> function.</p></div><div class="sect1" title="Using Guile in GNU make"><div class="titlepage"><div><div><h1 class="title"><a id="using_guile_in_gnu_make"/>Using Guile in GNU make</h1></div></div></div><p>GNU <code class="literal">make</code> 4.0 introduced a big change with the <code class="literal">$(guile)</code> function. This function’s argument is sent to the built-in Guile language and is executed by it. (GNU Guile is an implementation of Scheme, which itself is Lisp.) <code class="literal">$(guile)</code>’s return value is the return value from the Guile code that was executed after converting to a type that GNU <code class="literal">make</code> recognizes. Strictly speaking, GNU <code class="literal">make</code> doesn’t have data types (everything is a string), although it sometimes treats strings as other types (for example, a string with spaces in it is treated as a list by many functions).</p><p>Here’s how to reverse a list using <code class="literal">$(guile)</code> and the Guile function <code class="literal">reverse</code>:</p><a id="pro_id00463"/><pre class="programlisting">   NAMES := liesl friedrich louisa kurt brigitta marta gretl

➊ $(info $(guile (reverse '($(NAMES)))))</pre><p>When run, this makefile will output:</p><a id="pro_id00464"/><pre class="programlisting">$ make
gretl marta brigitta kurt louisa friedrich liesl</pre><p><a id="iddle1164" class="indexterm"/><a id="iddle1274" class="indexterm"/><a id="iddle1341" class="indexterm"/><a id="iddle1345" class="indexterm"/><a id="iddle1411" class="indexterm"/><a id="iddle1684" class="indexterm"/>It’s worth diving into ➊ to see what happens, because there are a couple of subtle points. The argument to <code class="literal">$(guile)</code> is first expanded by GNU <code class="literal">make</code>, so ➊ becomes:</p><a id="pro_id00465"/><pre class="programlisting">$(info $(guile (reverse '(liesl friedrich louisa kurt brigitta marta gretl))))</pre><p>So the Guile code to be executed is <code class="literal">(reverse '(liesl friedrich louisa kurt brigitta marta gretl))</code>. The GNU <code class="literal">make</code> variable <code class="literal">$(NAMES)</code> has been expanded into the list of names and is turned into a Guile list by wrapping it in <code class="literal">'(...)</code>. Because Guile has data types, you must use the correct syntax: in this case, you need to surround a list with parentheses and quote it with a single quote to tell Guile that this is a literal list (not a function invocation).</p><p>The Guile <code class="literal">reverse</code> function reverses this list and returns the reversed list. GNU <code class="literal">make</code> then converts the Guile list into a GNU <code class="literal">make</code> list (a string with spaces in it). Finally, <code class="literal">$(info)</code> displays the list.</p><p>Because Guile is a rich language, it’s possible to create more complex functions. Here, for example, is a GNU <code class="literal">make</code> function called <code class="literal">file-exists</code> that uses the Guile <code class="literal">access?</code> function to determine whether a file exists. It returns a Boolean value after converting the Guile <code class="literal">#t</code>/<code class="literal">#f</code> (true/false) value returned by <code class="literal">access?</code> to a GNU <code class="literal">make</code> Boolean (a non-empty string for true or an empty string for false):</p><a id="pro_id00466"/><pre class="programlisting">file-exists = $(guile (access? "$1" R_OK))</pre><p>Notice the double quotes around the parameter <code class="literal">$1</code>. Guile needs to know that the filename is actually a string.</p><p>You can build a more complex example by using the Guile <code class="literal">http-get</code> function to download data from the Web inside a makefile:</p><a id="pro_id00467"/><pre class="programlisting">define setup
(use-modules (web uri))
(use-modules (web client))
(use-modules (ice-9 receive))
endef

$(guile $(setup))

UA := "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_0) \
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 \
Safari/537.36"

define get-url
(receive (headers body)
  (http-get
    (string-&gt;uri "$1")
    #:headers '((User-Agent . $(UA))))
  body)
endef
utc-time = $(guile $(call get-url,http://www.timeapi.org/utc/now))

$(info $(utc-time))</pre><p><a id="iddle1222" class="indexterm"/><a id="iddle1311" class="indexterm"/><a id="iddle1346" class="indexterm"/><a id="iddle1510" class="indexterm"/><a id="iddle1637" class="indexterm"/><a id="iddle1701" class="indexterm"/><a id="iddle1815" class="indexterm"/><a id="iddle1858" class="indexterm"/>Here, <code class="literal">http-get</code> gets the current UTC time from a web service that returns the time as a string in the body of the HTTP response.</p><p>The <code class="literal">utc-time</code> variable contains the current UTC time. It works by retrieving the time from <span class="emphasis"><em><a class="ulink" href="http://www.timeapi.org/utc/now/">http://www.timeapi.org/utc/now/</a></em></span> using the Guile code stored in the <code class="literal">get-url</code> variable. The Guile code in <code class="literal">get-url</code> uses the <code class="literal">http-get</code> function to retrieve the header and body of a web page, and returns just the body.</p><p>Notice how you can use the GNU <code class="literal">make define</code> directive to create large blocks of Guile code. If the Guile code becomes unwieldy, do this:</p><p><code class="literal">$(guile (load "myfunctions.scm"))</code></p><p>This is how you can store the Guile code in a file and load it.</p></div><div class="sect1" title="Self-Documenting Makefiles"><div class="titlepage"><div><div><h1 class="title"><a id="self-documenting_makefiles"/>Self-Documenting Makefiles</h1></div></div></div><p>Upon encountering a new makefile, many ask “What does this makefile do?” or “What are the important targets I need to know about?” For any sizable makefile, answering those questions can be difficult. In this section, I present a simple GNU <code class="literal">make</code> trick that you can use to make a makefile self-documenting and print out help automatically.</p><p>Before I show you how it works, here’s a small example. This makefile has three targets that the creator thinks you need to know about: <code class="literal">all</code>, <code class="literal">clean</code>, and <code class="literal">package</code>. They’ve documented the makefile by including some extra information with each target:</p><a id="pro_id00468"/><pre class="programlisting">include help-system.mk

all: $(call print-help,all,Build all modules in Banana Wumpus system)
→ ...commands for building all ...

clean: $(call print-help,clean,Remove all object and library files)
→ ...commands for doing a clean ...

package: $(call print-help,package,Package application-must run all target first)
→ ...commands for doing package step ...</pre><p>For each of the targets needing documentation, the makefile maintainer has added a call to a user-defined function <code class="literal">print-help</code> with two arguments: the name of the target and a brief description of that target. The call to <code class="literal">print-help</code> doesn’t interfere with the definition of the prerequisites of the rule because it always returns (or is expanded to) an empty string.</p><p><a id="iddle1388" class="indexterm"/><a id="iddle1499" class="indexterm"/><a id="iddle1557" class="indexterm"/>Typing <code class="literal">make</code> with this makefile outputs:</p><a id="pro_id00469"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Type 'make help' to get help</pre><p>and typing <code class="literal">make help</code> reveals:</p><a id="pro_id00470"/><pre class="programlisting">$ <span class="strong"><strong>make help</strong></span>
Makefile:11: all -- Build all modules in Banana Wumpus system
Makefile:17: clean -- Remove all object and library files
Makefile:23: package -- Package application-must run all target first</pre><p><code class="literal">make</code> automatically prints the names of the interesting targets and includes an explanation of what they do, as well as the line number of the makefile where you can find more information about the commands for that target.</p><p>The interesting work is done by the included makefile <code class="literal">help-system.mak</code>. <code class="literal">help-system.mak</code> first defines the user-defined function <code class="literal">print-help</code>. <code class="literal">print-help</code> is the function called for each target that needs documenting:</p><a id="pro_id00471"/><pre class="programlisting">define print-help
$(if $(need-help),$(warning $1 -- $2))
endef</pre><p><code class="literal">print-help</code> uses GNU <code class="literal">make</code>’s <code class="literal">$(warning)</code> function to output the appropriate message based on the two parameters passed to it. The first parameter (stored in <code class="literal">$1</code>) is the name of the target, and the second (in <code class="literal">$2</code>) is the help text; they are separated by <code class="literal">--</code>. <code class="literal">$(warning)</code> writes a message to the console and returns an empty string; hence, you can safely use <code class="literal">print-help</code> in the prerequisite list of a rule.</p><p><code class="literal">print-help</code> decides whether it needs to print any message by examining the <code class="literal">need-help</code> variable, which will be the string <code class="literal">help</code> if the user specified <code class="literal">help</code> on the <code class="literal">make</code> command line, or empty if they did not. In either case, the expanded value of <code class="literal">print-help</code> is an empty string. <code class="literal">need-help</code> determines whether the user entered <code class="literal">help</code> on the command line by examining the built-in variable <code class="literal">MAKECMDGOALS</code>, which is a space-separated list of all the goals specified on the <code class="literal">make</code> command line. <code class="literal">need-help</code> filters out any goal that doesn’t match the text <code class="literal">help</code> and, hence, is the string <code class="literal">help</code> if <code class="literal">help</code> was in <code class="literal">MAKECMDGOALS</code> or empty otherwise.</p><a id="pro_id00472"/><pre class="programlisting">need-help := $(filter help,$(MAKECMDGOALS))</pre><p>The definition of <code class="literal">need-help</code> and <code class="literal">print-help</code> are all we need to have <code class="literal">make</code> print out help on each target when run with <code class="literal">help</code> on the command line. The rest of <code class="literal">help-system.mak</code> prints the message <code class="literal">Type 'make help' to get help</code> when the user simply types <code class="literal">make.</code></p><p><a id="iddle1451" class="indexterm"/><a id="iddle1600" class="indexterm"/>It defines a default goal for the makefile called <code class="literal">help</code>, which will be run if no other goal is specified on the command line:</p><a id="pro_id00473"/><pre class="programlisting">help: ; @echo $(if $(need-help),,Type \'$(MAKE)$(dash-f) help\' to get help)</pre><p>This rule will output nothing if the user has asked for <code class="literal">help</code> (determined by the <code class="literal">need-help</code> variable), but if not, it will output the message containing the name of the <code class="literal">make</code> program (stored in <code class="literal">$(MAKE)</code>) followed by the appropriate parameter to load the makefile. This last part is subtle.</p><p>If the makefile that included <code class="literal">help-system.mak</code> was simply called <code class="literal">Makefile</code> (or <code class="literal">makefile</code> or <code class="literal">GNUmakefile</code>), then GNU <code class="literal">make</code> would look for it automatically, and it’s enough to type <code class="literal">make help</code> to get help. If it was not, the actual makefile name needs to be specified with the <code class="literal">-f</code> parameter.</p><p>This rule uses a variable called <code class="literal">dash-f</code> to output the correct command line. <code class="literal">dash-f</code> contains nothing if one of the default makefile names was used, or it contains <code class="literal">-f</code> followed by the correct makefile name:</p><a id="pro_id00474"/><pre class="programlisting">dash-f := $(if $(filter-out Makefile makefile GNUmakefile, \
$(parent-makefile)), -f $(parent-makefile))</pre><p><code class="literal">dash-f</code> looks at the value of a variable called <code class="literal">parent-makefile</code>, which contains the name of the makefile that included <code class="literal">help-system.mak</code>. If it’s not a standard name, <code class="literal">dash-f</code> returns the name of the parent makefile with the <code class="literal">-f</code> option.</p><p><code class="literal">parent-makefile</code> is determined by looking at the <code class="literal">MAKEFILE_LIST</code>. <code class="literal">MAKEFILE_LIST</code> is a list of all the makefiles read so far in order. <code class="literal">help-system.mak</code> first determines its own name:</p><a id="pro_id00475"/><pre class="programlisting">this-makefile := $(call last-element,$(MAKEFILE_LIST))</pre><p>Then it gets the list of all the other makefiles included by removing <code class="literal">this-makefile</code> (that is, <code class="literal">help-system.mak</code>) from the <code class="literal">MAKEFILE_LIST</code>:</p><a id="pro_id00476"/><pre class="programlisting">other-makefiles := $(filter-out $(this-makefile),$(MAKEFILE_LIST))</pre><p>The final element of <code class="literal">other-makefiles</code> will be the parent of <code class="literal">help-system.mak</code>:</p><a id="pro_id00477"/><pre class="programlisting">parent-makefile := $(call last-element,$(other-makefiles))</pre><p>You use the <code class="literal">last-element</code> function to get the last element of a spaceseparated list:</p><a id="pro_id00478"/><pre class="programlisting">define last-element
$(word $(words $1),$1)
endef</pre><p><code class="literal">last-element</code> returns the last word in a list by getting the word count using <code class="literal">$(words)</code> and returning the word referenced by it. Because GNU <code class="literal">make</code>’s lists are counted from position 1, <code class="literal">$(words LIST)</code> is the index of the last element.</p><div class="sect2" title="Documenting Makefiles with print-help"><div class="titlepage"><div><div><h2 class="title"><a id="documenting_makefiles_with_print-help"/>Documenting Makefiles with print-help</h2></div></div></div><p><a id="iddle1221" class="indexterm"/><a id="iddle1407" class="indexterm"/><a id="iddle1638" class="indexterm"/>Documenting makefiles with <code class="literal">print-help</code> is easy. Just add the relevant <code class="literal">$(call print-help,target,description)</code> to the prerequisite list for each target you want to document. If you add the call right next to the commands that are used for the target, the help system not only prints help but also automatically points the user to the place in the makefile to look for more information.</p><p>It’s also easy to keep the documentation up to date because the description of a target is actually part of the definition of the target, not in a separate help list.</p></div><div class="sect2" title="The Complete help-system.mak"><div class="titlepage"><div><div><h2 class="title"><a id="complete_help-systemdotmak"/>The Complete help-system.mak</h2></div></div></div><p>Finally, here’s the full <code class="literal">help_system.mak</code> file:</p><a id="pro_id00479"/><pre class="programlisting">help: ; @echo $(if $(need-help),,Type \'$(MAKE)$(dash-f) help\' to get help)

need-help := $(filter help,$(MAKECMDGOALS))

define print-help
$(if $(need-help),$(warning $1 -- $2))
endef

define last-element
$(word $(words $1),$1)
endef

this-makefile := $(call last-element,$(MAKEFILE_LIST))
other-makefiles := $(filter-out $(this-makefile),$(MAKEFILE_LIST))
parent-makefile := $(call last-element,$(other-makefiles))

dash-f := $(if $(filter-out Makefile makefile GNUmakefile, \
$(parent-makefile)), -f $(parent-makefile))</pre><p>Just <code class="literal">include help-system.mak</code> to start using this system in makefiles that could use documentation.</p><p>In <a class="xref" href="ch06.html" title="Chapter 6. The GNU Make Standard Library">Chapter 6</a>, we’ll look at a helpful resource, the GMSL project. Creating GNU <code class="literal">make</code> built-in functions is easy, but it does cause a maintenance problem: the next time GNU <code class="literal">make</code> is updated, we’ll need to port our changes to the new version. If we can do what we need with GNU <code class="literal">make</code> built-ins without modifying the source, then makefiles will be more portable. The GMSL provides lots of additional functionality without modifying the GNU <code class="literal">make</code> source.</p></div></div></div></body></html>