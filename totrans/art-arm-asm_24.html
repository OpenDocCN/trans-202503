<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="appD">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_949" aria-label="949"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="appD">&#13;
<span class="APN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">D</span></span>&#13;
<span class="APT"><span class="SANS_Dogma_OT_Bold_B_11">THE BASH SHELL INTERPRETER</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">The <i>Bourne-again shell</i>, otherwise known as the <i>Bourne shell</i> or <i>bash</i>, is a Unix shell interpreter. Bash is an upgraded version of the venerable Unix sh (shell) program, the default shell program in Unix System 7.</p>&#13;
<p class="TX">Bash is the typical shell used in Linux systems (though other shells are available, such as zsh and csh). Most Linux and macOS shell programs are roughly compatible with one another for simple command line activities, but they differ in their support for sophisticated shell programming purposes.</p>&#13;
<p class="TX">All the programming examples throughout this text run GCC and the Gas assembler via shell commands given by a bash command line. Therefore, you should have at least a small amount of bash knowledge in order to understand the basic commands in this book. This appendix gives instructions for using bash, including descriptions of its more common commands, but this discussion largely applies to other shell interpreters as well.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_950" aria-label="950"/>To avoid having to refer to specific OS or distribution names, I’ll use the name <i>Unix</i> in this appendix to refer to the underlying system (at the time of this writing, Unix is a registered trademark of The Open Group).</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h2 class="H1" id="sec1"><span id="h1-170"/><span class="SANS_Futura_Std_Bold_B_11">D.1 Running Bash</span></h2>&#13;
<p class="TNI1">The bash shell interpreter is an application similar to other Unix applications. To use it, you must first execute the bash application. On text-based Unix systems, some sort of shell application will run after you log in to the system. You can set up your system to automatically run bash (or any other shell program).</p>&#13;
<p class="TX">On GUI-based Linux systems or on macOS systems, you usually have to run a terminal program to start a shell interpreter. In either case, you’ll typically be presented with a <i>command prompt</i> when the shell application runs. This should be <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">#</span>, depending on whether you’re logged in as a normal user or root, respectively; some shells display a <span class="SANS_TheSansMonoCd_W5Regular_11">%</span> prompt. After printing the command prompt, the shell will wait for you to type a command.</p>&#13;
<p class="TX">At this point, you’re running a shell interpreter, though it might not be bash; it could be the standard sh shell or another shell (for example, the macOS <i>terminal</i> application runs zsh). Though most shells will behave approximately the same, to ensure you’re running bash, type the following line (followed by <small>ENTER</small>) after the command prompt:</p>&#13;
<pre id="pre-1241"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">bash</span></code></pre>&#13;
<p class="TX">This will ensure that you’re running the bash application so that all the comments in this appendix will apply. You can terminate this instance of bash and return to the original shell by executing the <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> command from the command line.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h2 class="H1" id="sec2"><span id="h1-171"/><span class="SANS_Futura_Std_Bold_B_11">D.2 Command Lines</span></h2>&#13;
<p class="TNI1">The previous example (<span class="SANS_TheSansMonoCd_W5Regular_11">bash</span>) is an instance of a command given to a shell interpreter. <i>Commands</i> consist of a line of text entered after a command prompt (typically via the keyboard) and take the following form:</p>&#13;
<pre id="pre-1242"><code><var>commandName optionalCommandLineArguments optionalRedirection</var></code></pre>&#13;
<p class="TX">This whole line of code is known as a <i>command line</i>, which consists of three components: a command (usually a single word, such as <span class="SANS_TheSansMonoCd_W5Regular_11">bash</span> in the previous example), followed by optional command line arguments, and, finally, optional redirection or piping operands.</p>&#13;
<p class="TX">The command is the name of a built-in bash command or the name of an executable application (or shell script). For example, the command could be the name of an assembled assembly language source file you’ve just created.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_951" aria-label="951"/>&#13;
<h3 class="H2" id="sec3"><span id="h2-275"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.2.1 Command Line Arguments</span></h3>&#13;
<p class="TNI1"><i>Command line arguments</i> are strings of characters separated by spaces or tabs that bash will pass along to the application. The exact syntax of these command line arguments is application dependent. Some simple applications (including the assembly language examples in this book) may completely ignore any command line arguments; others may require very specific arguments and report an error if they are not syntactically correct.</p>&#13;
<p class="TX">Some applications define two types of command line arguments: options and arguments. Historically, command line <i>options</i> consist of a dash (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) prefix followed by a single character, or a double dash (<span class="SANS_TheSansMonoCd_W5Regular_11">--</span>) prefix followed by a sequence of characters. For example, the bash command supports the option</p>&#13;
<pre id="pre-1243"><code>bash --help</code></pre>&#13;
<p class="Continued1">which displays help information and then terminates without running the bash interpreter.</p>&#13;
<p class="TX">In contrast, an actual command line <i>argument</i> is typically a filename or other word (or string) that the application will use as an input value. Consider the following command line:</p>&#13;
<pre id="pre-1244"><code>bash script</code></pre>&#13;
<p class="TX">In this example, bash will start a second instance of itself and read a set of commands (one per line of text) from the <i>script</i> file and execute those commands as though they had been typed from the keyboard. The <i>build</i> script file that appeared <span class="Xref">on <a href="chapter1.xhtml#pg_38">page 38</a></span> is a good example of a shell script.</p>&#13;
<p class="TX">Because bash uses spaces or tabs to separate command line arguments, problems arise if you want to specify a single argument that contains such <i>delimiters</i>, characters that separate items on the command line. Fortunately, bash provides a syntax that allows you to include such delimiters on the command line: if you surround a command line argument with quotation marks, bash will pass everything within the quotes to the application as a single command line argument.</p>&#13;
<p class="TX">For example, if a command requires a filename and the filename you wish to use contains spaces, you can pass that filename to the command as follows:</p>&#13;
<pre id="pre-1245"><code><var>command</var> "<var>filename with spaces</var>"</code></pre>&#13;
<p class="TX">Bash will not include the quotes as part of the argument it passes to the command. If you need to pass a quote character as part of a command line argument, precede the quote with a backslash character (<span class="SANS_TheSansMonoCd_W5Regular_11">\</span>). For example, consider the following command:</p>&#13;
<pre id="pre-1246"><code><var>command</var> "<var>argument containing</var> \"<var>quotes</var>\""</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_952" aria-label="952"/>This passes <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">argument containing "quotes"</span> as a single argument to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">command</span>.</p>&#13;
<p class="TX">As you will see later in this appendix, you can also surround a command line argument with single quotes (apostrophe characters). The difference has to do with variable expansion.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H2" id="sec4"><span id="h2-276"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.2.2 Redirection and Piping Arguments</span></h3>&#13;
<p class="TNI1">Bash programs (and Unix-like OSes in general) provide a standard input device, a standard output device, and a standard error device.</p>&#13;
<p class="TX">The <i>standard input device</i> is usually the console keyboard. If a program reads data from the standard input device, the program will halt until the user types a line of text from the keyboard.</p>&#13;
<p class="TX">The <i>standard output device</i> is the console display. If an application writes data to the standard output device, the system will display it on the display screen. The standard error device also defaults to the console display, so data written to the standard error device is also written to the display.</p>&#13;
<p class="TX">The bash shell provides the ability to <i>redirect</i> input and output by using special arguments on the command line. I/O redirection typically allows you to specify a filename. When redirecting the standard input device, the application will read lines of text from a file (rather than from the keyboard). When redirecting the standard output, the application will write data to a text file rather than to the console display.</p>&#13;
<p class="TX">To redirect the standard input from a file, use a command line argument of the form</p>&#13;
<pre id="pre-1247"><code><var>command</var> &lt;<var>InputFile</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">InputFile</span> is the name of a file containing text to be read by the application. Whenever the application command would normally read a line of text from the keyboard, it will instead read that line of text from the specified file.</p>&#13;
<p class="TX">To redirect the standard output to a file, use the following command line syntax:</p>&#13;
<pre id="pre-1248"><code><var>command</var> &gt;<var>OutputFile</var></code></pre>&#13;
<p class="TX">Any output normally written to the standard output device (the display) will be written to the specified file (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">OutputFile</span>). This syntax will delete the contents of any existing file named <i>OutputFile</i> and replace its contents with the output of the command application.</p>&#13;
<p class="TX">A variation of output redirection will append a program’s output to the end of an existing file rather than replacing its contents. To use output redirection this way, use this syntax:</p>&#13;
<pre id="pre-1249"><code><var>command</var> &gt;&gt;<var>OutputFile</var></code></pre>&#13;
<p class="TX">Note that redirecting the standard output device does not change the standard error output device. If you’ve redirected the standard output to a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_953" aria-label="953"/>file and an application writes data to the standard error device, that output still appears on the console display. You can redirect the standard error device by using the following syntax:</p>&#13;
<pre id="pre-1250"><code><var>command</var> 2&gt;<var>ErrorOutput</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">2&gt;</span> tells bash to redirect the output sent to file handle 2. Under Unix-style systems, handle 0 is reserved for the standard input, handle 1 is reserved for the standard output, and handle 2 is reserved for the standard error output device. Sticking the handle number in front of the <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> specifies which output to redirect.</p>&#13;
<p class="TX">If you like, you can also redirect the standard output by using this syntax:</p>&#13;
<pre id="pre-1251"><code><var>command</var> 1&gt;<var>OutputFile</var></code></pre>&#13;
<p class="TX">The final form of I/O redirection is the <i>pipe</i>, which connects the standard output from one application to the standard input of a second application. This allows the second application to read, as input, the output from the first application. Here’s the syntax for a pipe redirection:</p>&#13;
<pre id="pre-1252"><code><var>command1</var> <var>OptionalCommand1Arguments</var> | <var>command2</var> <var>OptionalCommand2Arguments</var></code></pre>&#13;
<p class="Continued1">This tells bash to redirect the output from <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">command1</span> as the input to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">command2</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h2 class="H1" id="sec5"><span id="h1-172"/><span class="SANS_Futura_Std_Bold_B_11">D.3 Directories, Pathnames, and Filenames</span></h2>&#13;
<p class="TNI1">When you run bash, it will default to a current directory in the OS’s file structure. Unix calls this the <i>current working directory</i>. Whenever you run bash (for example, when you first log in), the current working directory is typically your home directory (as determined by the OS). For example, on my Debian system, this is <i>/home/rhyde</i> (under macOS, it’s <i>/Users/rhyde</i>).</p>&#13;
<p class="TX">When you specify a filename on the command line that does not contain any slash characters, bash or the application will assume that file exists in the executable path supplied to the system. A <i>pathname</i> consists of a sequence of one or more directory names, separated by slashes, ending with a filename. A relative pathname begins with a directory name; the system looks for that directory within the current working directory. For example, <i>dir1/dir2/filename</i> specifies a file (<i>filename</i>) appearing in <i>dir1</i> in the current working directory and within <i>dir2</i>, which is itself within <i>dir1</i>. An <i>absolute pathname</i> begins with a slash followed by the outermost root directory. For example, <i>/home/rhyde/x.txt</i> specifies the file <i>x.txt</i> appearing in the <i>/home/rhyde</i> directory (my home directory under Debian).</p>&#13;
<p class="TX">The tilde special character (~) is shorthand for the current user’s home directory. Therefore, <i>~/x.txt</i> is another way for me to specify <i>/home/rhyde/x.txt</i> on my Debian system. This scheme also works in macOS, so it’s a useful way to specify user directory paths in a system-independent fashion.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_954" aria-label="954"/>The special character period (.), by itself, is shorthand for the current working directory. The double-period sequence (..) is shorthand for the directory that contains the current working directory (the parent directory). For example, <i>../x.txt</i> refers to the file named <i>x.txt</i> in the parent directory. On Linux-based systems, to execute an application from the current working directory, you must specify <i>./filename</i> rather than just <i>filename</i> (unless you’ve placed <i>./</i> in your execution path).</p>&#13;
<p class="TX">Some Unix commands allow you to specify multiple filenames on the command line. Such commands often allow the use of wildcard characters to specify multiple names. Unix supports a rich set of regular expressions when specifying wildcards, one of which you’ll commonly use: the asterisk (<span class="SANS_TheSansMonoCd_W5Regular_11">*</span>). Bash will match any number of characters (zero or more) in place of the asterisk. Therefore, the filename <i>*.txt</i> will match any file ending with the four-character sequence <i>.txt</i> (this includes <i>.txt</i> by itself).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h2 class="H1" id="sec6"><span id="h1-173"/><span class="SANS_Futura_Std_Bold_B_11">D.4 Built-in and External Bash Commands</span></h2>&#13;
<p class="TNI1">Bash supports two types of commands: built-in and external. <i>Built-in commands</i> exist as part of the bash application itself; a function inside the bash source code handles the given built-in command. <i>External commands</i> correspond to executable programs separate from bash that bash will load and execute (then take control back from those programs when they terminate). Built-in commands are always available when you run bash, but external commands may or may not be available, depending on the presence of the executable code for those commands. You can assume that the commands appearing in the following subsections are all external, unless otherwise noted.</p>&#13;
<p class="TX">The assembly language example programs in this book are examples of external commands. When you enter something like</p>&#13;
<pre id="pre-1253"><code>./Listing1-5</code></pre>&#13;
<p class="Continued1">at the command line, bash will locate the <i>Listing1-5</i> executable in the current working directory (<span class="SANS_TheSansMonoCd_W5Regular_11">./</span>) and attempt to execute that code.</p>&#13;
<p class="TX">For security reasons, bash will not automatically execute a program in the current working directory unless you explicitly prepend the characters <span class="SANS_TheSansMonoCd_W5Regular_11">./</span> to the executable’s name. Bash assumes that program names without explicit path information can be found in the <i>execution path</i>. The execution path (see section D.6.1, <span class="Xref">“Defining Shell Script Variables and Values,”</span> on <span class="Xref"><a href="appendix-D.xhtml#pg_961">page 961</a></span>) is a list of directories where bash will search for an executable program you specify without explicit path information. Usually, bash will look in places such as <i>/bin</i>, <i>/usr/bin</i>, and <i>/sbin</i> for executable programs.</p>&#13;
<p class="TX">To enable bash to execute programs from your current working directory without having to prefix the executable filename with the <span class="SANS_TheSansMonoCd_W5Regular_11">./</span> characters, you can add <span class="SANS_TheSansMonoCd_W5Regular_11">./</span> to your execution path. However, there are some very good security reasons for not doing this. For more on this, see section D.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="appendix-D.xhtml#pg_968">page 968</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_955" aria-label="955"/>&#13;
<h2 class="H1" id="sec7"><span id="h1-174"/><span class="SANS_Futura_Std_Bold_B_11">D.5 Basic Unix Commands</span></h2>&#13;
<p class="TNI1">It would be impossible to describe all Unix commands in this appendix. That would take a large book by itself. This section describes several commands useful to those developing assembly language programs, along with some of their options and parameters. For information on additional bash commands, check out section D.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="appendix-D.xhtml#pg_968">page 968</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H2" id="sec8"><span id="h2-277"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.1 man</span></h3>&#13;
<p class="TNI1">If you know the name of the command but are unsure about the syntax for its command line parameters and options, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> command to learn about it. This command brings up the manual page for a (supported) command, with the syntax</p>&#13;
<pre id="pre-1254"><code>man <var>CommandName</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">CommandName</span> is the name of the command whose manual page you would like to read. For example, the following brings up the manual page for the <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> command itself:</p>&#13;
<pre id="pre-1255"><code>man man</code></pre>&#13;
<p class="TX">You can use <span class="SANS_TheSansMonoCd_W5Regular_11">man</span>, with the command names listed in the following subsections, to learn additional information about each.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H2" id="sec9"><span id="h2-278"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.2 cd or chdir</span></h3>&#13;
<p class="TNI1">You can set the current working directory by using the <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span> (change directory) command (<span class="SANS_TheSansMonoCd_W5Regular_11">chdir</span> is an alias of this command). The standard syntax is</p>&#13;
<pre id="pre-1256"><code>cd <var>DirectoryPath</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DirectoryPath</span> is a relative or absolute path to a directory in the filesystem. Unix will report an error if the directory does not exist or if this is the name of a file rather than a directory.</p>&#13;
<p class="TX">If you specify the <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span> command without any arguments, it will switch to the current user’s home directory. This is equivalent to entering the following on the command line:</p>&#13;
<pre id="pre-1257"><code>cd ~</code></pre>&#13;
<p class="Continued1">The <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">chdir</span> commands are built into bash.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H2" id="sec10"><span id="h2-279"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.3 pwd</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">pwd</span> (print working directory) command prints the path to the current working directory. Bash is generally set up to print the current working directory as part of the command line prompt; if this is the case for your <span role="doc-pagebreak" epub:type="pagebreak" id="pg_956" aria-label="956"/>system, you probably won’t need to use <span class="SANS_TheSansMonoCd_W5Regular_11">pwd</span>. This is also an internal bash command.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H2" id="sec11"><span id="h2-280"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.4 ls</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> (list directory) command prints a directory listing to the standard output. When used with no options, it displays the contents of the current directory.</p>&#13;
<p class="TX">When printing the directory listing to the display, <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> defaults to a multicolumn format. If you direct the output to a file, by redirecting the standard output or by using a pipe, the command prints the listing in a single-column format.</p>&#13;
<p class="TX">If you supply a directory path as an argument, the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command will display the contents of the specified directory (assuming it exists). If you specify a pathname to a file as an argument, the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command will display only that filename (again, assuming that file exists in the specified path).</p>&#13;
<p class="TX">By default, the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command will not display filenames that begin with a period. Unix treats such files as <i>hidden</i>. If you want to display such filenames, use the <span class="SANS_TheSansMonoCd_W5Regular_11">-a</span> command line option:</p>&#13;
<pre id="pre-1258"><code>ls -a</code></pre>&#13;
<p class="TX">By default, the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command lists only the filenames and directory names in the specified directory. If you specify the <span class="SANS_TheSansMonoCd_W5Regular_11">-l</span> (long) option, the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command will display additional information about each file:</p>&#13;
<pre id="pre-1259"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">ls -l</span>&#13;
total 3256&#13;
-rw-r--r--@ 1 rhyde  staff   168089 Dec 29  20<var>xx</var> encoder.pdf&#13;
-rw-r--r--@ 1 rhyde  staff  1492096 Dec 27  20<var>xx</var> mcp23017.png</code></pre>&#13;
<p class="TX">The first column in the listing specifies the file permissions. The next three provide a link count and ownership information, followed by file size and modification date and time, followed by the filename.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H2" id="sec12"><span id="h2-281"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.5 file</span></h3>&#13;
<p class="TNI1">Unlike macOS and Windows, Unix does not associate a specific data type with a file. You can use the Unix <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> command to determine a file type for a particular file:</p>&#13;
<pre id="pre-1260"><code>file <var>pathname</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> command will respond with its best guess as to the type of the file specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">pathname</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H2" id="sec13"><span id="h2-282"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.6 cat, less, more, and tail</span></h3>&#13;
<p class="TNI1">To view the contents of a text file, you can display that file in its entirety using the <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> (catenate) command</p>&#13;
<pre id="pre-1261"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_957" aria-label="957"/>cat <var>pathname</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">pathname</span> is the path to the name of the file you wish to display.</p>&#13;
<p class="TX">The problem with <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> is that it tries to write the entire file to the display, all at once. Many files are larger than can be displayed on the screen at one time, so <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> ends up displaying only the last few lines of the file; moreover, very large files may take a while to display their contents. If you would like to be able to page through a file one screenful at a time, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">more</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">less</span> commands:</p>&#13;
<pre id="pre-1262"><code>more <var>pathname</var>&#13;
less <var>pathname</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">more</span> command is now obsolete but is still available to handle older script files that contain it. It displays a pageful of text and allows you to scroll through the file a line at a time (by pressing <small>ENTER</small>) or a page at a time (by pressing the spacebar). The big drawback to <span class="SANS_TheSansMonoCd_W5Regular_11">more</span> is that you can view only forward in a file; after information scrolls off the screen, it is lost.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">less</span> command (whose name comes from the phrase <i>less is more</i>) is an upgraded version of <span class="SANS_TheSansMonoCd_W5Regular_11">more</span> that allows you to scroll forward and backward in a page. Most people use the <span class="SANS_TheSansMonoCd_W5Regular_11">less</span> command rather than <span class="SANS_TheSansMonoCd_W5Regular_11">more</span> because of the additional features (such as being able to use the arrow keys to consistently scroll up and down a line at a time).</p>&#13;
<p class="TX">If you want to view only the last few lines of a large file, use the <span class="SANS_TheSansMonoCd_W5Regular_11">tail</span> command:</p>&#13;
<pre id="pre-1263"><code>tail <var>pathname</var></code></pre>&#13;
<p class="TX">By default, <span class="SANS_TheSansMonoCd_W5Regular_11">tail</span> prints the last 10 lines of the file. You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">-n</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">xxxx</span> command line option, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">xxxx</span> is a decimal numeric value, to specify a different line count. For example</p>&#13;
<pre id="pre-1264"><code>tail -n 20 x.txt</code></pre>&#13;
<p class="Continued1">displays the last 20 lines of the file <i>x.txt.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H2" id="sec14"><span id="h2-283"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.7 mv</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">mv</span> (move) command has the following syntax:</p>&#13;
<pre id="pre-1265"><code>mv <var>SourcePath DestinationPath</var></code></pre>&#13;
<p class="Continued1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">SourcePath</span> is the pathname of the file you want to move or rename, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DestinationPath</span> is the final destination path where you want the file moved (or the new name you want to use for the file).</p>&#13;
<p class="TX">To rename a file in the current directory, <span class="SANS_TheSansMonoCd_W5Regular_11">mv</span> takes the form</p>&#13;
<pre id="pre-1266"><code>mv <var>OldName NewName</var></code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_958" aria-label="958"/>where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">OldName</span> is the existing filename you want to change and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">NewName</span> is the new filename you want to rename the file. These are both simple filenames (no directory path components). Note that <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">NewName</span> must be different from <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">OldName</span>.</p>&#13;
<p class="TX">To move a file from one directory to another, either the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">SourcePath</span> or <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DestinationPath</span> (or both) must contain a directory component. The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">SourcePath</span> must contain a filename component at the end of the pathname (the name of the file to move). For the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DestinationPath</span>, a filename at the end is optional. If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DestinationPath</span> is the name of a directory (rather than a file), <span class="SANS_TheSansMonoCd_W5Regular_11">mv</span> will move the source file into the destination directory and use the same filename as the original source file. If there is a filename at the end of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DestinationPath</span>, then <span class="SANS_TheSansMonoCd_W5Regular_11">mv</span> will change the filename while it is moving it.</p>&#13;
<p class="TX">You can use wildcard characters with <span class="SANS_TheSansMonoCd_W5Regular_11">mv</span>, subject to the following restrictions: wildcard characters may appear only in the source pathname, and the destination path must be a directory, not an actual filename.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H2" id="sec15"><span id="h2-284"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.8 cp</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">cp</span> command has the following syntax:</p>&#13;
<pre id="pre-1267"><code>cp <var>SourcePath DestinationPath</var></code></pre>&#13;
<p class="Continued1">This command will make a copy of the file specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">SourcePath</span>, using the name <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DestinationPath</span> for the copy. If both pathnames are simple filenames (that is, you’re making a copy of a file in the current directory), the two filenames must be different.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cp</span> command accepts wildcard characters in the source operand. If wildcard characters are present, the destination must be a directory path. The <span class="SANS_TheSansMonoCd_W5Regular_11">cp</span> command will copy all files matching the wildcard designation to the specified directory.</p>&#13;
<p class="TX">If both source and destination operands specify a directory, use the <span class="SANS_TheSansMonoCd_W5Regular_11">-R</span> (recursive) command line option. This will copy all the files from the source directory to a directory by the same name in the destination directory (creating the new directory in the destination if it is not already present); it will also recursively copy any subdirectories in the source directory into similarly named subdirectories in the destination.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H2" id="sec16"><span id="h2-285"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.9 rm</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">rm</span> command removes (deletes) a file from a directory, using the following syntax:</p>&#13;
<pre id="pre-1268"><code>rm <var>pathname</var></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">pathname</span> argument must be a path to an individual file, not a directory. To delete a directory and all the files in it, use the following command:</p>&#13;
<pre id="pre-1269"><code>rm -R <var>DirectoryPath</var></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_959" aria-label="959"/>This will recursively delete all files and subdirectories in <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DirectoryPath</span>, then delete the directory specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DirectoryPath</span>.</p>&#13;
<p class="TX">To delete all the files in a directory without removing the directory itself, use the following command:</p>&#13;
<pre id="pre-1270"><code>rm -R <var>DirectoryPath/*</var></code></pre>&#13;
<p class="TX">Be very careful when using wildcard characters in an <span class="SANS_TheSansMonoCd_W5Regular_11">rm</span> command. Depending on the current working directory, the following command could delete everything on your storage devices:</p>&#13;
<pre id="pre-1271"><code>rm -R *</code></pre>&#13;
<p class="TX">There is also an <span class="SANS_TheSansMonoCd_W5Regular_11">rmdir</span> command you can use to remove empty directories. However, the <span class="SANS_TheSansMonoCd_W5Regular_11">rm -R</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">directory</span> command is easier to use for this purpose.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H2" id="sec17"><span id="h2-286"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.10 mkdir</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span> command creates a new (empty) directory, using the syntax</p>&#13;
<pre id="pre-1272"><code>mkdir <var>DirectoryPath</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DirectoryPath</span> specifies the pathname to a directory that does not already exist. If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">DirectoryPath</span> is an actual pathname, all subdirectory names up to the final name in the path must exist; the final directory name (after the last <span class="SANS_TheSansMonoCd_W5Regular_11">/</span>) must not exist. If you specify a simple directory name (no path), bash will create the directory in the current working directory.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span> command supports a <span class="SANS_TheSansMonoCd_W5Regular_11">-p</span> command line option that will create all nonexistent directories in the path.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H2" id="sec18"><span id="h2-287"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.11 date</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">date</span> command displays the current date and time. You can also use this command to set the Unix real-time clock. Run <span class="SANS_TheSansMonoCd_W5Regular_11">man date</span> for the details.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H2" id="sec19"><span id="h2-288"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.12 echo</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command prints the text on the remainder of the command line (subject to some expansions by bash) to the standard output device. For example</p>&#13;
<pre id="pre-1273"><code>echo hello, world!</code></pre>&#13;
<p class="Continued1">will write <span class="SANS_TheSansMonoCd_W5Regular_11">hello, world!</span> to the standard output. You’ll use this command most often in scripts or to display the value of various shell variables.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h3 class="H2" id="sec20"><span id="h2-289"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.5.13 chmod</span></h3>&#13;
<p class="TNI1">Although Unix files do not have a specific type, the directory does maintain whether a file is readable, writable, or executable by the owner of the file, a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_960" aria-label="960"/>group associated with the file, or anyone (standard Unix permissions). The <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> command allows you to set (or clear) permission mode bits for a particular file.</p>&#13;
<p class="TX">The basic syntax for <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> is</p>&#13;
<pre id="pre-1274"><code>chmod <var>options pathname</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">pathname</span> is the path to the file whose mode you want to change, and the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">options</span> parameter(s) specifies the new permissions.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">options</span> argument is either an octal (base-8) number (typically three digits) or a special string to set the permissions. Unix has three permission categories: owner/user, group, and other. The <i>owner</i> category applies to the user who created the file in the first place. The <i>group</i> category covers any groups that the user belongs to (and other users may belong to). The <i>other</i> category covers everyone else.</p>&#13;
<p class="TX">In addition to the three categories, Unix has three main types of permissions: permission to <i>read</i> a file, permission to <i>write</i> data to a file (or delete it), and permission to <i>execute</i> a file (this generally applies to object code or shell scripts).</p>&#13;
<p class="TX">A typical <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> option consists of a string of one to three characters from the set <span class="SANS_TheSansMonoCd_W5Regular_11">{ugo}</span> followed by a plus or minus character (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">-</span>, not <span class="SANS_TheSansMonoCd_W5Regular_11">±</span>), followed by a single character from the set <span class="SANS_TheSansMonoCd_W5Regular_11">{rwx}</span>. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">u+r</span> enables user read access, <span class="SANS_TheSansMonoCd_W5Regular_11">u+x</span> enables execution permission, and <span class="SANS_TheSansMonoCd_W5Regular_11">ugo-x</span> removes execution privileges for all categories. Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span> command will list the user, group, and other permissions for a given file.</p>&#13;
<p class="TX">You can also specify the permissions for the three categories as a three-digit octal number, where each digit represents the three <span class="SANS_TheSansMonoCd_W5Regular_11">rwx</span> bits for users (HO digit), groups (middle digit), and other (LO digit). For example, <span class="SANS_TheSansMonoCd_W5Regular_11">755</span> specifies read/write/execute permissions for the user (111<sub>2</sub> = 7<sub>8</sub>), read and execute permissions for the group, and other (101<sub>2</sub> = 5<sub>8</sub>). Note that <span class="SANS_TheSansMonoCd_W5Regular_11">755</span> is a typical set of permissions you would assign to a publicly usable script file.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h2 class="H1" id="sec21"><span id="h1-175"/><span class="SANS_Futura_Std_Bold_B_11">D.6 Shell Scripts</span></h2>&#13;
<p class="TNI1">A <i>shell script</i> is a text file that bash will interpret as a sequence of commands to execute, exactly as though each line in the text file were entered from the keyboard while running bash. For those with Microsoft Windows experience, this is similar to a batch file. This section discusses using shell variables and values, using special built-in shell variables, and creating your own bash shell scripts.</p>&#13;
<p class="TX">The bash interpreter is a full-fledged programming language that supports conditional and looping constructs as well as the sequential execution of commands on the command line. It supports <span class="SANS_TheSansMonoCd_W5Regular_11">if...elif...else</span> statements, a <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement (similar to C’s <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement), and various loops (<span class="SANS_TheSansMonoCd_W5Regular_11">while</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">for</span>, and so on). It also supports functions, local variables, and other features typically found in HLLs. Going into detail on these topics is beyond the scope of this book. See Ryan’s Tutorials in section D.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="appendix-D.xhtml#pg_968">page 968</a></span> for details beyond what this section covers.</p>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_961" aria-label="961"/>&#13;
<h3 class="H2" id="sec22"><span id="h2-290"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.6.1 Defining Shell Script Variables and Values</span></h3>&#13;
<p class="TNI1">Bash allows you to define shell variables. A <i>shell variable</i> is a name (think: programming language identifier) to which you can assign some text. For example, the following bash command assigns the text <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">list</span>:</p>&#13;
<pre id="pre-1275"><code>list=ls</code></pre>&#13;
<p class="TX">You can tell bash to expand a shell variable name to its associated text by prefixing the name with a <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> character. For example</p>&#13;
<pre id="pre-1276"><code>$list</code></pre>&#13;
<p class="Continued1">expands to</p>&#13;
<pre id="pre-1277"><code>ls</code></pre>&#13;
<p class="Continued1">which will display the current directory listing.</p>&#13;
<p class="TX">Normally, you would not use shell variables to create aliases of existing commands, as the <span class="SANS_TheSansMonoCd_W5Regular_11">alias</span> command is better suited to the job. Instead, you would use shell variables to keep track of paths, options, and other information commonly used on the command line.</p>&#13;
<p class="TX">Bash supplies several predefined shell variables, including the following:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">$HOME</span>    Contains the path to the current user’s home directory</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">$HOSTNAME</span>    Contains the machine’s name</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">$PATH</span>    Contains a list of directory paths, separated by colons (<span class="SANS_TheSansMonoCd_W5Regular_11">:</span>), that bash will search through when searching for an external command’s executable file</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">$PS1</span>    Contains a string that bash will print as the command line prompt</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">$PWD</span>    Contains the current working directory</p>&#13;
</div>&#13;
<p class="TX">For a complete list of predefined shell variables, and for more details on the <span class="SANS_TheSansMonoCd_W5Regular_11">$PS1</span> variable in particular, see section D.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="appendix-D.xhtml#pg_968">page 968</a></span>.</p>&#13;
<p class="TX">Shell variables to which you assign values will retain those values during the execution of the current bash shell. Often, when executing shell scripts, a second bash shell begins execution, and any variable values created or modified in that execution will be lost when that shell terminates. To avoid this problem, use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">export</span> command:</p>&#13;
<pre id="pre-1278"><code>export <var>variable name</var>=<var>value</var></code></pre>&#13;
<p class="Continued1">This command will make the variable assignment visible to parent shells. Typically, you must use <span class="SANS_TheSansMonoCd_W5Regular_11">export</span> when assigning values in a shell script that you want to retain after the shell script completes.</p>&#13;
<p class="TX">You can define shell variables in a script file, just as you can when interactively typing commands at the command line. As noted earlier, however, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_962" aria-label="962"/>any variable values defined in a shell script are lost when the shell terminates. This is because bash will make a copy of the execution environment (including all the shell variable values) when it starts a shell script. Any changes or additions you make, such as creating new variables or modifying existing ones, affect only the copy of the environment. When the shell script terminates, it deletes the copy of the environment and reverts to the original environment. The <span class="SANS_TheSansMonoCd_W5Regular_11">export</span> command tells bash to export the variable assignment to the parent environment (as well as applying to the current local environment).</p>&#13;
<p class="TX">Values assigned to a shell variable are generally treated as text. Because the bash interpreter breaks up command lines by using spaces or other delimiters, the string of text you assign to a script variable must consist of a single <i>word</i> (that is, a sequence of characters surrounded by delimiters). If you want to include delimiter (and other) characters within the value, you must surround the text value with quotes or apostrophes, as in the following example:</p>&#13;
<pre id="pre-1279"><code>value1="<var>Value containing delimiters (spaces)</var>"&#13;
value2='<var>Another value with delimiters</var>'</code></pre>&#13;
<p class="TX">Bash will expand the text inside double quotes (<span class="SANS_TheSansMonoCd_W5Regular_11">"</span>) and will maintain the text as is inside single quotes (<span class="SANS_TheSansMonoCd_W5Regular_11">'</span>). Consider the following example:</p>&#13;
<pre id="pre-1280"><code>aVariable="<var>Some text</var>"&#13;
value3="aVariable=$aVariable"&#13;
value4='aVariable=$aVariable'&#13;
echo $value3&#13;
echo $value4</code></pre>&#13;
<p class="TX">Executing this sequence will produce the following output:</p>&#13;
<pre id="pre-1281"><code>aVariable=Some Text&#13;
aVariable=$aVariable</code></pre>&#13;
<p class="TX">Bash expands <span class="SANS_TheSansMonoCd_W5Regular_11">$aVariable</span> inside the string enclosed in double quotes but will not expand it inside the string enclosed in single quotes.</p>&#13;
<p class="TX">You might see strings surrounded by grave accent characters (<span class="SANS_TheSansMonoCd_W5Regular_11">`</span>), commonly called <i>backticks</i> in Unix. Originally, such strings surrounded a command that the shell would execute, then substitute the textual output of the program in place of the backticked string. This syntax has been deprecated in modern shells. To capture the output of a command and assign it to a variable, use <span class="SANS_TheSansMonoCd_W5Regular_11">$(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">command</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span>, as in the following example:</p>&#13;
<pre id="pre-1282"><code>dirListing=$(ls)</code></pre>&#13;
<p class="TX">This creates a string consisting of the listing of the current working directory and assigns that string to the <span class="SANS_TheSansMonoCd_W5Regular_11">dirListing</span> variable.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_963" aria-label="963"/>&#13;
<h3 class="H2" id="sec23"><span id="h2-291"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.6.2 Defining Special Shell Variables</span></h3>&#13;
<p class="TNI1">In addition to the shell variables a script inherits from the parent environment, bash also defines certain shell variables that might prove useful in shell scripts you write. These special variables begin with <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> and typically deal with command line parameters passed to the script (see <a href="#tabD-1">Table D-1</a>).</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tabD-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table D-1:</span></span> <span class="SANS_Futura_Std_Book_11">Special Shell Variables</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Variable</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Expands to the pathname of the shell script file.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$1</span> <span class="SANS_Futura_Std_Book_11">through</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Expands to the first, second, ...,</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">th command line argument.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$#</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Expands to a decimal number specifying the parameter count.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$*</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Expands to a string containing all the command line parameters. Generally used to pass the parameters on to another command. To assign this command line parameter-list string to a shell variable, use</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$*</span> <span class="SANS_Futura_Std_Book_11">to capture the text as a single string.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$@</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Similar to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$*</span><span class="SANS_Futura_Std_Book_11">, except this variant puts quotes around each argument. Useful if the original arguments may have been quoted and could contain spaces or other delimiter characters. It’s best to invoke this as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$@</span> <span class="SANS_Futura_Std_Book_11">as well.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">See the references in section D.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="appendix-D.xhtml#pg_968">page 968</a></span> for more details on these features.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H2" id="sec24"><span id="h2-292"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">D.6.3 Writing Your Own Shell Scripts</span></h3>&#13;
<p class="TNI1">Consider the following text, from a file named <i>lsPix</i>:</p>&#13;
<pre id="pre-1283"><code>cd $HOME/Pictures&#13;
ls</code></pre>&#13;
<p class="TX">If you were to execute this shell script via the following command, bash would switch to the <i>Pictures</i> subdirectory in the user’s home directory, display the directory listing, and the return control to bash:</p>&#13;
<pre id="pre-1284"><code>bash lsPix</code></pre>&#13;
<p class="TX">Entering <span class="SANS_TheSansMonoCd_W5Regular_11">bash</span> in front of a shell script to execute it can become annoying if you commonly execute certain shell scripts. Fortunately, Unix (via shells such as sh, bash, or zsh) provides a mechanism to specify the shell script directly as a command: make the script file executable. You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> command to accomplish this:</p>&#13;
<pre id="pre-1285"><code>chmod 755 lsPix</code></pre>&#13;
<p class="TX">This sets the permissions to RWX (readable, writable, and executable) for the owner and R-X (readable and executable) for members of the group and other users.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_964" aria-label="964"/>Note that the <i>build</i> script (used throughout this book) has been made executable via a <span class="SANS_TheSansMonoCd_W5Regular_11">chmod 777 build</span> command (this allows everyone to modify the file). That is why you need to enter only <span class="SANS_TheSansMonoCd_W5Regular_11">./build</span> at the beginning of the command line rather than <span class="SANS_TheSansMonoCd_W5Regular_11">bash build</span>.</p>&#13;
<p class="TX">When making a bash shell script executable, also add the following statement to the beginning of the shell script file:</p>&#13;
<pre id="pre-1286"><code>#! /bin/bash</code></pre>&#13;
<p class="TX">The <i>shebang</i> (<span class="SANS_TheSansMonoCd_W5Regular_11">#!</span>) sequence tells bash that this is a shell script and provides the path to the shell interpreter to execute for this command. (The interpreter would be bash in this case, but you could specify a different shell interpreter, such as <span class="SANS_TheSansMonoCd_W5Regular_11">/bin/sh</span>, if you really wanted.) If you don’t know the path to the bash interpreter, execute the Unix command <span class="SANS_TheSansMonoCd_W5Regular_11">which bash</span> to print the path you need. The inclusion of the shebang on the first line also allows the <span class="SANS_TheSansMonoCd_W5Regular_11">file lspix</span> command to identify the file as a shell script rather than a simple ASCII text file.</p>&#13;
<p class="TX">Once you’ve added this line to <i>lsPix</i> and made the file executable, you need to enter only the following at the command line to execute the script:</p>&#13;
<pre id="pre-1287"><code>./lsPix</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> character is normally used to create comments in a shell script. With the exception of the shebang in the first line, the bash interpreter will ignore all the text from a <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> symbol to the end of the line.</p>&#13;
<p class="TX">It’s important to understand that shell scripts execute in their own copy of bash. Therefore, any changes they make to the bash environment—such as setting the current working directory with the <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span> command or changing shell variable values—are lost when the script terminates. For example, when this <i>lsPix</i> script terminates, the current working directory will return to its original directory; it will not be <i>$HOME/Pictures</i> (unless it happened to be <i>$HOME/Pictures</i> prior to executing <i>lsPix</i>).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h2 class="H1" id="sec25"><span id="h1-176"/><span class="SANS_Futura_Std_Bold_B_11">D.7 The build Script</span></h2>&#13;
<p class="TNI1">Shell scripts are useful for automating manual activities. For example, this book uses the <i>build</i> script to assemble/compile most of the example programs. The following listing presents the <i>build</i> script and describes how it works; I’ll explain the full script section by section.</p>&#13;
<p class="TX">As with any good shell script, the build script begins with the shebang that defines the shell interpreter to use (bash in this case):</p>&#13;
<pre id="pre-1288"><code>#!/bin/bash&#13;
#&#13;
# build&#13;
#&#13;
# Automatically builds an Art of ARM Assembly&#13;
# example program from the command line.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_965" aria-label="965"/>#&#13;
# Usage:&#13;
#&#13;
#   build {options} fileName&#13;
#&#13;
# (no suffix on the filename.)&#13;
#&#13;
# options:&#13;
#&#13;
#   -c: Assemble .S file to object code only.&#13;
#   -pie: On Linux, generate a PIE executable.&#13;
fileName=""&#13;
compileOnly=" "&#13;
pie="-no-pie"&#13;
cFile="c.cpp"&#13;
lib=" "</code></pre>&#13;
<p class="TX">The script also defines several variables (<span class="SANS_TheSansMonoCd_W5Regular_11">filename</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">compileOnly</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">pie</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cFile</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">lib</span>) that it will use to specify GCC command line options when assembling and compiling the source files.</p>&#13;
<p class="TX">The next section of the script processes command line parameters found on the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command line:</p>&#13;
<pre id="pre-1289"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> while [[$# -gt 0]]&#13;
do&#13;
    key="$1"&#13;
    case $key in&#13;
        -c)&#13;
        compileOnly='-c'&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> shift&#13;
        ;;&#13;
        -pie)&#13;
        pie='-pie'&#13;
        shift&#13;
        ;;&#13;
        -math)&#13;
        math='-lm'&#13;
        shift&#13;
        ;;&#13;
        *)&#13;
        fileName="$1"&#13;
        shift&#13;
        ;;&#13;
    esac&#13;
done</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_966" aria-label="966"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop processes each command line argument individually <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The Boolean expression <span class="SANS_TheSansMonoCd_W5Regular_11">$# -gt 0</span> returns true as long as there are one or more command line arguments (<span class="SANS_TheSansMonoCd_W5Regular_11">$#</span> is the number of arguments).</p>&#13;
<p class="TX">The body of the loop sets the key local variable equal to the value of the first command line parameter <span class="SANS_TheSansMonoCd_W5Regular_11">($1</span>). It then executes a <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement that compares this argument against the options <span class="SANS_TheSansMonoCd_W5Regular_11">-c</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">-pie</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">-math</span>. If the argument matches one of these, the script sets appropriate local variables to values that note the presence of these options. If the case expression doesn’t match any of these, the default case (<span class="SANS_TheSansMonoCd_W5Regular_11">*</span>) sets the filename variable to the value of the command line argument.</p>&#13;
<p class="TX">At the end of each case, you’ll notice a shift statement <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This statement shifts all the command line parameters to the left one position (deleting the original <span class="SANS_TheSansMonoCd_W5Regular_11">$1</span> argument), setting <span class="SANS_TheSansMonoCd_W5Regular_11">$1</span> = <span class="SANS_TheSansMonoCd_W5Regular_11">$2</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">$2</span> = <span class="SANS_TheSansMonoCd_W5Regular_11">$3</span>, ... and decrementing the parameter count (<span class="SANS_TheSansMonoCd_W5Regular_11">$#</span>) by one. This sets up the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop for the next iteration to process the remaining command line parameters.</p>&#13;
<p class="TX">The next section sets up the <span class="SANS_TheSansMonoCd_W5Regular_11">objectFile</span> variable that the script expands as part of the <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span> command line:</p>&#13;
<pre id="pre-1290"><code># If -c option was provided, assemble only the .S&#13;
# file and produce a .o output file.&#13;
#&#13;
# If -c not specified, compile both c.cpp and the .S&#13;
# file and produce an executable:&#13;
if ["$compileOnly" = '-c']; then&#13;
    objectFile="-o $fileName".o&#13;
    cFile=" "&#13;
else&#13;
    objectFile="-o $fileName"&#13;
fi</code></pre>&#13;
<p class="TX">This code sets <span class="SANS_TheSansMonoCd_W5Regular_11">objectFile</span> to a string that will specify an object filename on the <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span> command line. If <span class="SANS_TheSansMonoCd_W5Regular_11">-c</span> is not present, this code will set <span class="SANS_TheSansMonoCd_W5Regular_11">cFile</span> to expand to an empty string so that the <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span> command does not also compile <i>c.cpp</i> (the default case).</p>&#13;
<p class="TX">The following section of the <i>build</i> script deletes any existing object files or executable files that this command would create:</p>&#13;
<pre id="pre-1291"><code># If the executable already exists, delete it:&#13;
if test -e "$fileName"; then&#13;
    rm "$fileName"&#13;
fi&#13;
# If the object file already exists, delete it:&#13;
if test -e "$fileName".o; then&#13;
    rm "$fileName".o&#13;
fi</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_967" aria-label="967"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">test</span> built-in function returns true if the specified file exists. Therefore, these <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements will delete the object and executable files if they already exist.</p>&#13;
<p class="TX">Next, the <i>aoaa.inc</i> header file requires the definition of either the <span class="SANS_TheSansMonoCd_W5Regular_11">isLinux</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">isMacOS</span> symbols in order to determine the OS. The definition of these symbols allows <i>aoaa.inc</i> to select OS-specific code so that the example code will compile (portably) across the two OSes. Rather than force the user to manually define this symbol, the <i>build</i> script automatically defines one of these symbols when invoking GCC. To accomplish this, <i>build</i> uses the <span class="SANS_TheSansMonoCd_W5Regular_11">uname</span> command, which returns the name of the OS kernel:</p>&#13;
<pre id="pre-1292"><code># Determine what OS you're running under (Linux or Darwin [macOS]) and&#13;
# issue the appropriate GCC command to compile/assemble the files:&#13;
unamestr=$(uname)</code></pre>&#13;
<p class="TX">Under Linux, <span class="SANS_TheSansMonoCd_W5Regular_11">uname</span> returns the string <span class="SANS_TheSansMonoCd_W5Regular_11">Linux</span>; under macOS, it returns the string <span class="SANS_TheSansMonoCd_W5Regular_11">Darwin</span>.</p>&#13;
<p class="TX">Finally, the <i>build</i> script invokes the GCC compiler with command line arguments appropriate to the OS:</p>&#13;
<pre id="pre-1293"><code>if ["$unamestr" = 'Linux']; then&#13;
    gcc -D isLinux=1 $pie $compileOnly $objectFile  $cFile $fileName.S $math&#13;
elif ["$unamestr" = 'Darwin']; then&#13;
    gcc -D isMacOS=1  $compileOnly $objectFile $cFile  $fileName.S -lSystem $math&#13;
fi</code></pre>&#13;
<p class="TX">Note the <span class="SANS_TheSansMonoCd_W5Regular_11">-D</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_TheSansMonoCd_W5Regular_11">=1</span> command line option that defines the <span class="SANS_TheSansMonoCd_W5Regular_11">isLinux</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">isMacOS</span> symbols as appropriate. Also note that the <span class="SANS_TheSansMonoCd_W5Regular_11">pie</span> (position-independent code) option appears only when compiling under Linux, as macOS code is always position-independent.</p>&#13;
<p class="TX">It’s easy to modify the <i>build</i> script to add more features, should you desire. For example, one limitation to this script is that it allows you to specify only a single assembly language source file (if you specify two or more names, it will use only the last name you specify). You can change this with three modifications to the file, in the <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement.</p>&#13;
<p class="TX">The first change is to append the filename and add a <span class="SANS_TheSansMonoCd_W5Regular_11">.S</span> suffix to the <span class="SANS_TheSansMonoCd_W5Regular_11">fileName</span> variable rather than replacing its value. You must also set the executable output filename to the first assembly file specified on the command line:</p>&#13;
<pre id="pre-1294"><code>*)&#13;
    if[fileName = ""]&#13;
    then&#13;
        objectFile = "$1"&#13;
    fi&#13;
    fileName="$filename $1.S"&#13;
    shift&#13;
    ;;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_968" aria-label="968"/>The next change is to set <span class="SANS_TheSansMonoCd_W5Regular_11">objectFile</span> to the empty string if specifying compile-only mode:</p>&#13;
<pre id="pre-1295"><code>if ["$compileOnly" = '-c']; then&#13;
cFile=" "&#13;
else&#13;
    objectFile="-o $fileName"&#13;
fi</code></pre>&#13;
<p class="TX">The original code set this to the specified filename; however, that is the default for compile-only mode, and specifying a single object name when assembling multiple source files is problematic.</p>&#13;
<p class="TX">The final change is to modify the two <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span> command lines to remove the <span class="SANS_TheSansMonoCd_W5Regular_11">.S</span> suffix from the assembly filenames (since this was added in the <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement):</p>&#13;
<pre id="pre-1296"><code>if ["$unamestr" = 'Linux']; then&#13;
    gcc -D isLinux=1 $pie $compileOnly $objectFile  $cFile $fileName $math&#13;
elif ["$unamestr" = 'Darwin']; then&#13;
    gcc -D isMacOS=1  $compileOnly $objectFile $cFile  $fileName -lSystem $math&#13;
fi</code></pre>&#13;
<p class="TX">However, if you’re going to do a complex assembly using multiple source files, you’re probably better off using makefiles rather than shell scripts to do the job.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h2 class="H1" id="sec26"><span id="h1-177"/><span class="SANS_Futura_Std_Bold_B_11">D.8 For More Information</span></h2>&#13;
<ul class="ul">&#13;
<li class="BL">For details on Unix regular expressions and wildcards, see the Bash Reference Manual at <i><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html">https://<wbr/>www<wbr/>.gnu<wbr/>.org<wbr/>/savannah<wbr/>-checkouts<wbr/>/gnu<wbr/>/bash<wbr/>/manual<wbr/>/bash<wbr/>.html</a></i>.</li>&#13;
<li class="BL">For more information on bash shell scripts, check out <i>The Linux Command Line</i>, 2nd edition, by William Shotts (No Starch Press, 2019).</li>&#13;
<li class="BL">For an explanation of the risks of including <span class="SANS_TheSansMonoCd_W5Regular_11">./</span> in your execution path, see the Unix &amp; Linux Stack Exchange question at <i><a href="https://unix.stackexchange.com/questions/65700/is-it-safe-to-add-to-my-path-how-come">https://<wbr/>unix<wbr/>.stackexchange<wbr/>.com<wbr/>/questions<wbr/>/65700<wbr/>/is<wbr/>-it<wbr/>-safe<wbr/>-to<wbr/>-add<wbr/>-to<wbr/>-my<wbr/>-path<wbr/>-how<wbr/>-come</a></i>.</li>&#13;
<li class="BL">A complete list of bash shell script variables appears at the Advanced Bash Scripting Guide site, <i><a href="https://tldp.org/LDP/abs/html/internalvariables.html">https://<wbr/>tldp<wbr/>.org<wbr/>/LDP<wbr/>/abs<wbr/>/html<wbr/>/internalvariables<wbr/>.html</a></i>.</li>&#13;
<li class="BL">For details on changing the command line prompt, see the phoenixNap site at <i><a href="https://phoenixnap.com/kb/change-bash-prompt-linux">https://<wbr/>phoenixnap<wbr/>.com<wbr/>/kb<wbr/>/change<wbr/>-bash<wbr/>-prompt<wbr/>-linux</a></i>.</li>&#13;
</ul>&#13;
<p class="ListPlain"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_969" aria-label="969"/>Here are some websites that describe how to write bash scripts:</p>&#13;
<ul class="ul">&#13;
<li class="BL">freeCodeCamp: <i><a href="https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux">https://<wbr/>www<wbr/>.freecodecamp<wbr/>.org<wbr/>/news<wbr/>/shell<wbr/>-scripting<wbr/>-crash<wbr/>-course<wbr/>-how<wbr/>-to<wbr/>-write<wbr/>-bash<wbr/>-scripts<wbr/>-in<wbr/>-linux</a></i></li>&#13;
<li class="BL">Ryan’s Tutorials: <i><a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-script.php">https://<wbr/>ryanstutorials<wbr/>.net<wbr/>/bash<wbr/>-scripting<wbr/>-tutorial<wbr/>/bash<wbr/>-script<wbr/>.php</a></i></li>&#13;
<li class="BL">Linux Hint: <i><a href="https://linuxhint.com">https://<wbr/>linuxhint<wbr/>.com</a></i></li>&#13;
<li class="BL">Bash scripting cheat sheet: <i><a href="https://devhints.io/bash">https://<wbr/>devhints<wbr/>.io<wbr/>/bash</a></i></li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>