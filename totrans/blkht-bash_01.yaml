- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 1 BASH BASICS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Bash* is a command language interpreter that provides an environment in which
    users can execute commands and run applications. As penetration testers and security
    practitioners, we frequently write bash scripts to automate a wide variety of
    tasks, making bash an essential tool for hackers. In this chapter, you’ll set
    up your bash development environment, explore useful Linux commands to include
    in future scripts, and learn the fundamentals of the language’s syntax, including
    variables, arrays, streams, arguments, and operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Environmental Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you begin learning bash, you need both a bash shell running in a terminal
    and a text editor. You can access these on any major operating system by following
    the instructions in this section.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Beginning in [Chapter 4](chapter4.xhtml), you’ll use Kali Linux to run bash
    commands and complete hacking labs. If you’d like to set up Kali now, consult
    the steps included in [Chapter 3](chapter3.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Bash Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re running Linux or macOS, bash should already be available. On Linux,
    open the Terminal application by pressing ALT-CTRL-T. On macOS, you can find the
    terminal by navigating to the Launchpad icon on the system dock.
  prefs: []
  type: TYPE_NORMAL
- en: Kali and macOS use the Z Shell by default, so when you open a new terminal window,
    you’ll have to enter exec bash to switch to a bash shell before you run commands.
    If you want to change your default shell to bash so you don’t have to manually
    switch shells, you can use the chsh -s /bin/bash command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re running Windows, you can use the Windows Subsystem for Linux (WSL),
    which lets you run Linux distributions and access a bash environment. The official
    Microsoft WSL documentation page describes how to install it: *[https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)*.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to WSL is *Cygwin*, which emulates a Linux environment by providing
    a collection of Linux utilities and system-call functionalities. To install Cygwin,
    visit *[https://www.cygwin.com/install.html](https://www.cygwin.com/install.html)*
    to download the setup file, and then follow the installation wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Cygwin installs itself by default to the *C:\cygwin64\* Windows path. To execute
    your bash scripts, save the scripts in the directory containing your username
    at *C:\cygwin64\home*. For example, if your username is *david*, you should save
    your scripts under *C:\cygwin64\home\david*. Then, from the Cygwin terminal, you’ll
    be able to change the directory to the home directory to run your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Text Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To start writing bash scripts, you’ll need a text editor, preferably one with
    handy features such as syntax highlighting built in. You can choose between terminal-based
    text editors and graphical user interface–based text editors. Terminal-based text
    editors (such as vi or GNU nano) are useful because during a penetration test
    they may be the only available options when you need to develop a script on the
    spot.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer graphical text editors, Sublime Text (*[https://www.sublimetext.com](https://www.sublimetext.com)*)
    is one option you could use. In Sublime Text, you can toggle on the syntax highlighting
    feature for bash scripts by clicking **Plain Text** in the bottom-right corner
    and choosing **Bash** from the drop-down list of languages. If you’re using a
    different text editor, reference its official documentation to learn how to turn
    on syntax highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a functional bash environment, it’s time to learn some basics.
    Although you’ll develop scripts in your text editor, you’ll also probably find
    yourself frequently running single commands in the terminal. This is because you
    often need to see how a command runs and the kind of output it produces before
    including it in a script. Let’s get started by running some bash commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, enter the following command to verify that bash is available on your
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The version in the output will depend on the operating system you are running.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Environment Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When running in a terminal, bash loads a set of *environment variables* with
    every new session that gets invoked. Programs can use these environment variables
    for various purposes, such as discovering the identity of the user running the
    script, the location of their home directory, and their default shell.
  prefs: []
  type: TYPE_NORMAL
- en: To see the list of environment variables set by bash, run the env command directly
    from the shell ([Listing 1-1](chapter1.xhtml#Lis1-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-1: Listing bash’s environment variables'
  prefs: []
  type: TYPE_NORMAL
- en: You can read individual environment variables by using the echo command, which
    writes text to the terminal. For example, to print the default shell set for the
    user, use the SHELL environment variable preceded by a dollar sign ($) and surrounded
    by curly brackets ({}). This will cause bash to expand the variable to its assigned
    value, as shown in [Listing 1-2](chapter1.xhtml#Lis1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-2: Printing an environment variable to the terminal'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the default environment variables available:'
  prefs: []
  type: TYPE_NORMAL
- en: BASH_VERSION The bash version running
  prefs: []
  type: TYPE_NORMAL
- en: BASHPID The process identifier (PID) of the current bash process
  prefs: []
  type: TYPE_NORMAL
- en: GROUPS A list of groups the running user is a member of
  prefs: []
  type: TYPE_NORMAL
- en: HOSTNAME The name of the host
  prefs: []
  type: TYPE_NORMAL
- en: OSTYPE The type of operating system
  prefs: []
  type: TYPE_NORMAL
- en: PWD The current working directory
  prefs: []
  type: TYPE_NORMAL
- en: RANDOM A random number from 0 to 32,767
  prefs: []
  type: TYPE_NORMAL
- en: UID The user ID (UID) of the current user
  prefs: []
  type: TYPE_NORMAL
- en: SHELL The full pathname to the shell
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show how to check the values of a few of these environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These commands generate a random number, output the current user’s ID, and display
    the operating system type, respectively. You can find the full list of environment
    variables at *[https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html](https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: Running Linux Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bash scripts you’ll write in this book will run common Linux tools, so if
    you’re not yet familiar with command line navigation and file modification utilities
    such as cd, ls, chmod, mkdir, and touch, try exploring them by using the man (manual)
    command. You can insert it before any Linux command to open a terminal-based guide
    that explains that command’s use and options, as shown in [Listing 1-3](chapter1.xhtml#Lis1-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-3: Accessing a command’s manual page'
  prefs: []
  type: TYPE_NORMAL
- en: Linux commands can accept many types of input on the command line. For example,
    you can enter ls without any arguments to see files and directories, or pass it
    arguments to, for instance, display the list of files all on one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguments are passed on the command line by using either short-form or long-form
    argument syntax, depending on the command in use. *Short-form* syntax uses a single
    dash (-) followed by one or more characters. The following example uses ls to
    list files and directories with a short-form argument syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Some commands let you supply multiple arguments by joining them together or
    listing them separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that some commands may throw errors if you attempt to join two arguments
    with a single dash, so use the man command to learn the syntax that’s permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some command options may allow you to use *long-form* argument syntax, such
    as the --help command to list the available options. Long-form argument syntax
    is prepended by the double dash (--) symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes the same command argument supports both short- and long-form argument
    syntax for convenience. For example, ls supports the argument -a (all) to display
    all files, including those that are hidden. (Files starting with a dot in their
    name are considered hidden in Linux.) However, you could also pass the argument
    --all, and the outcome would be identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s execute some simple Linux commands so you can see the variation of options
    each offers. First, create a single directory with mkdir:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s create two directories with mkdir:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, list processes by using ps with short-form argument syntax, supplying
    the arguments separately and then together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s display the available disk space by using df with long-form
    argument syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this book, you’ll use Linux commands such as these in your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Elements of a Bash Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn the building blocks of a bash script. You’ll use
    comments to document what a script does, tell Linux to use a specific interpreter
    to execute the script, and style your scripts for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: Bash doesn’t have an official style guide, but we recommend adhering to Google’s
    Shell Style Guide (*[https://google.github.io/styleguide/shellguide.html](https://google.github.io/styleguide/shellguide.html)*),
    which outlines best practices to follow when developing bash code. If you work
    on a team of penetration testers and have an exploit code repository, using good
    code styling practices will help your team maintain it.
  prefs: []
  type: TYPE_NORMAL
- en: The Shebang Line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every script should begin with the *shebang* line, a character sequence that
    starts with the hash and exclamation marks (#!), followed by the full path to
    the script interpreter. [Listing 1-4](chapter1.xhtml#Lis1-4) shows an example
    of a shebang line for a typical bash script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-4: A bash shebang line'
  prefs: []
  type: TYPE_NORMAL
- en: The bash interpreter is typically located at */bin/bash*. If you instead wrote
    scripts in Python or Ruby, your shebang line would include the full path to the
    Python or Ruby interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll sometimes encounter bash scripts that use a shebang line like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You may want to use this shebang line because it is more portable than the one
    in [Listing 1-4](chapter1.xhtml#Lis1-4). Some Linux distributions place the bash
    interpreter in different system locations, and this shebang line will attempt
    to find that location. This approach could be particularly useful in penetration
    tests, where you might not know the location of the bash interpreter on the target
    machine. For simplicity, however, we’ll use the shebang version from [Listing
    1-4](chapter1.xhtml#Lis1-4) throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shebang line can also take optional arguments to change how the script
    executes. For example, you could pass the special argument -x to your bash shebang,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This option prints all commands and their arguments as they are executed to
    the terminal. It is useful for debugging scripts as you’re developing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of an optional argument is -r:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This option creates a *restricted bash shell*, which restricts certain potentially
    dangerous commands that could, for example, navigate to certain directories, change
    sensitive environment variables, or attempt to turn off the restricted shell from
    within the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying an argument within the shebang line requires modifying the script,
    but you can also pass arguments to the bash interpreter by using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Whether you pass arguments to the bash interpreter on the command line or on
    the shebang line won’t make a difference. The command line option is just an easier
    way to trigger different modes.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Comments* are parts of a script that the bash interpreter won’t treat as code
    and that can improve the readability of a program. Imagine that you write a long
    script and, a few years later, need to modify some of its logic. If you didn’t
    write comments to explain what you did, you might find it quite challenging to
    remember the purpose of each section.'
  prefs: []
  type: TYPE_NORMAL
- en: Comments in bash start with a hash mark (#), as shown in [Listing 1-5](chapter1.xhtml#Lis1-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-5: A comment in a bash script'
  prefs: []
  type: TYPE_NORMAL
- en: Except for the shebang line, every line that starts with a hash mark is considered
    a comment. If you wrote the shebang line twice, bash would consider the second
    one to be a comment.
  prefs: []
  type: TYPE_NORMAL
- en: To write a multiline comment, precede each individual line with the hash mark,
    as shown in [Listing 1-6](chapter1.xhtml#Lis1-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-6: A multiline comment'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to documenting a script’s logic, comments can provide metadata to
    indicate the author, the script’s version, the person to contact for issues, and
    more. These comments usually appear at the top part of the script, below the shebang
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scripts can be as short as two lines: the shebang line and a Linux command.
    Let’s write a simple script that prints Hello World! to the terminal. Open your
    text editor and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the shebang statement to specify the interpreter of
    choice, bash. Then we use the echo command to print the string Hello World! to
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run the script, save the file as *helloworld.sh*, open the terminal, and
    navigate to the directory where the script resides. If you saved the file in your
    home directory, you should run the set of commands shown in [Listing 1-7](chapter1.xhtml#Lis1-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-7: Running a script from the home directory'
  prefs: []
  type: TYPE_NORMAL
- en: We use the cd command to change directories. The tilde (~) represents the home
    directory of the current running user. Next, we use chmod to set the executable
    (u+x) permissions for the user who owns the file (in this case, us). We run the
    script by using dot-slash notation (./) followed by the script’s name. The dot
    (.) represents the current directory, so we’re essentially telling bash to run
    *helloworld.sh* from the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run a bash script with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Because we specified the bash command, the script will run using the bash interpreter
    and won’t require a shebang line. Also, if you use the bash command, the script
    doesn’t have to be set with an executable permission (+x). In later chapters,
    you’ll learn about the permission model in more depth and explore its importance
    in the context of finding misconfigurations in penetration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Errors will inevitably occur when you’re developing bash scripts. Luckily,
    debugging scripts is quite intuitive. An easy way to check for errors early is
    by using the -n parameter when running a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This parameter will read the commands in the script but won’t execute them,
    so any syntax errors that exist will be shown onscreen. You can think of -n as
    a dry-run method to test the validity of your syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the -x parameter to turn on verbose mode, which lets you see
    commands being executed and will help you debug issues as the script executes
    in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you want to start debugging at a given point in the script, include the set
    command in the script itself ([Listing 1-8](chapter1.xhtml#Lis1-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-8: Using set to debug a script'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of set as a valve that turns a certain option on and off. In this
    example, the first command sets the debugging mode (set -x), while the last command
    (set +x) disables it. By using set, you can avoid generating a massive amount
    of noise in your terminal when your script is large and contains a specific problem
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you’ve written a two-line script that prints the message Hello
    World! to the screen. You’ve also learned how to run and debug a script. Now you’ll
    learn some bash syntax so you can write more useful scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic bash scripts are just lists of Linux commands collected in a
    single file. For example, you could write a script that creates resources on a
    system and then prints information about these resources to the screen ([Listing
    1-9](chapter1.xhtml#Lis1-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-9: A bash script that lists directory contents'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use mkdir to create a directory named *mydirectory*. Next,
    we use the touch command to create a file named *myfile* within the directory.
    Finally, we run the ls -l command to list the contents of *mydirectory*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the script looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, this line-by-line strategy could be improved in several ways. First,
    when a command runs, bash waits until it finishes before advancing to the next
    line. If you include a long-running command (such as a file download or large
    file copy), the remaining commands won’t be executed until that command has completed.
    We also have yet to implement any checks to validate that all commands have executed
    correctly. You’ll need to write more-intelligent programs to reduce errors during
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Writing sophisticated programs often requires using features like variables,
    conditions, loops, and tests. For example, what if we want to change this script
    so that it checks for enough space on the disk before attempting to create new
    files and directories? Or what if we could check whether the directory and file
    creation actions actually succeeded? This section and [Chapter 2](chapter2.xhtml)
    introduce you to the syntactical elements you’ll need to accomplish these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every scripting language has variables. *Variables* are names that we assign
    to memory locations and that hold a value; they act like placeholders or labels.
    We can directly assign values to variables, or we can execute bash commands and
    store their output as variable values to use for various purposes.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve worked with programming languages, you may know that variables can
    be of different types, such as integers, strings, and arrays. In bash, variables
    are untyped; they’re all considered character strings. Even so, you’ll see that
    bash allows you to create arrays, access array elements, or perform arithmetic
    operations so long as the variable value consists of only numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following rules govern the naming of bash variables:'
  prefs: []
  type: TYPE_NORMAL
- en: They can include alphanumeric characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot start with a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can contain an underscore (_).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot contain whitespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning and Accessing Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s assign a variable. Open a terminal and enter the following directly within
    the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a variable named book and, by using the equal sign (=), assign the
    value black hat bash to it. Now we can use this variable in a command. In the
    following example, we use the echo command to print the variable to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we were able to print the variable by using the ${book} syntax within
    an echo command. This will expand the book variable to its value. You can also
    expand a variable by using just the dollar sign ($) followed by the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using the ${} syntax makes the code less prone to misinterpretation and helps
    readers understand when a variable starts and ends.
  prefs: []
  type: TYPE_NORMAL
- en: You can also assign the output of a command to a variable by using the command
    substitution syntax $(), placing the desired command within the parentheses. You’ll
    use this syntax often in bash programming. Try running the commands in [Listing
    1-10](chapter1.xhtml#Lis1-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-10: Assigning command output to a variable'
  prefs: []
  type: TYPE_NORMAL
- en: We assign the value of the ls -ld / command to a variable named root_directory
    and then use echo to print the output of the command. In this output, you can
    see that we were able to get metadata about the root directory (/), such as its
    type and permission, size, user and group owners, and the timestamp of the last
    modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you shouldn’t leave whitespace around the assignment symbol (=) when
    creating a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The previous variable assignment syntax is considered invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Unassigning Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can unassign assigned variables by using the unset command, as shown in
    [Listing 1-11](chapter1.xhtml#Lis1-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-11: Unassigning variables'
  prefs: []
  type: TYPE_NORMAL
- en: If you execute these commands in the terminal, no output will be shown after
    the echo command executes.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Global* variables are those available to the entire program. But variables
    in bash can also be *scoped* so that they are accessible only from within a certain
    block of code. These *local* variables are declared using the local keyword. The
    script in [Listing 1-12](chapter1.xhtml#Lis1-12) shows how local and global variables
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: local_scope _variable.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-12: Accessing global and local variables'
  prefs: []
  type: TYPE_NORMAL
- en: We assign the value No Starch Press to the variable PUBLISHER and then create
    a function called print_name(). (You’ll learn more about functions in the next
    chapter.) Within the function, we declare a local variable called name and assign
    it the value Black Hat Bash. Then we call print_name() and attempt to access the
    name variable as part of a sentence to be printed using echo.
  prefs: []
  type: TYPE_NORMAL
- en: The echo command at the end of the script file will result in an empty variable,
    as the name variable is locally scoped to the print_name() function, which means
    that nothing outside the function can access it. So, it will simply return without
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The scripts in this chapter are available at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this script, remembering to set the executable permission by using chmod,
    and run it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the local variable never prints.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Arithmetic operators* allow you to perform mathematical operations on integers.
    [Table 1-1](chapter1.xhtml#tab1-1) shows some of the arithmetic operators available.
    For the full list, see *[https://tldp.org/LDP/abs/html/ops.html](https://tldp.org/LDP/abs/html/ops.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-1: Arithmetic Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| + | Addition |'
  prefs: []
  type: TYPE_TB
- en: '| - | Subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| * | Multiplication |'
  prefs: []
  type: TYPE_TB
- en: '| / | Division |'
  prefs: []
  type: TYPE_TB
- en: '| % | Modulo |'
  prefs: []
  type: TYPE_TB
- en: '| += | Incrementing by a constant |'
  prefs: []
  type: TYPE_TB
- en: '| -= | Decrementing by a constant |'
  prefs: []
  type: TYPE_TB
- en: 'You can perform these arithmetic operations in bash in a few ways: using the
    let command, using the double parentheses syntax $((expression)), or using the
    expr command. Let’s consider an example of each method.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 1-13](chapter1.xhtml#Lis1-13), we perform a multiplication operation
    by using the let command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-13: Arithmetic with let'
  prefs: []
  type: TYPE_NORMAL
- en: This command takes a variable name and performs an arithmetic calculation to
    resolve its value. In [Listing 1-14](chapter1.xhtml#Lis1-14), we perform another
    multiplication operation using the double parentheses syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-14: Arithmetic with double parentheses syntax'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we perform the calculation within double parentheses. Finally,
    in [Listing 1-15](chapter1.xhtml#Lis1-15), we perform an addition operation using
    the expr command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-15: Evaluating expressions with expr'
  prefs: []
  type: TYPE_NORMAL
- en: The expr command evaluates expressions, which don’t have to be arithmetic operations;
    for example, you might use it to calculate the length of a string. Use man expr
    to learn more about the capabilities of expr.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bash allows you to create single-dimension arrays. An *array* is a collection
    of elements that are indexed. You can access these elements by using their index
    numbers, which begin at zero. In bash scripts, you might use arrays whenever you
    need to iterate over multiple strings and run the same commands on each one.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-16](chapter1.xhtml#Lis1-16) shows how to create an array in bash.
    Save this code to a file named *array.sh* and execute it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-16: Creating and accessing arrays'
  prefs: []
  type: TYPE_NORMAL
- en: This script uses an array named IP_ADDRESSES that contains three internet protocol
    (IP) addresses. The first echo command prints all the elements in the array by
    passing [*] to the variable name IP_ADDRESSES, which holds the array values. The
    asterisk (*) is a representation of every array element. Finally, another echo
    command prints just the first element in the array by specifying index 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this script should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we were able to get bash to print all elements in the array,
    as well as just the first element.
  prefs: []
  type: TYPE_NORMAL
- en: You can also delete elements from an array. [Listing 1-17](chapter1.xhtml#Lis1-17)
    will delete 192.168.1.2 from the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-17: Deleting array elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even swap one of the values with another value. This code will replace
    192.168.1.1 with 192.168.1.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find arrays particularly useful when you need to iterate over values
    and perform actions against them, such as a list of IP addresses to scan (or a
    list of email addresses to send a phishing email to).
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Streams* are files that act as communication channels between a program and
    its environment. When you interact with a program (whether a built-in Linux utility
    such as ls or mkdir or one that you wrote yourself), you’re interacting with one
    or more streams. Bash has three standard data streams, as shown in [Table 1-2](chapter1.xhtml#tab1-2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-2: Streams'
  prefs: []
  type: TYPE_NORMAL
- en: '| Stream name | Description | File descriptor number |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Standard input (stdin) | Data coming into a program as input | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Standard output (stdout) | Data coming out of a program | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Standard error (stderr) | Errors coming out of a program | 2 |'
  prefs: []
  type: TYPE_TB
- en: So far, we’ve run a few commands from the terminal and written and executed
    a simple script. The generated output was sent to the *standard output stream
    (stdout)*, or in other words, your terminal screen.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts can also receive commands as input. When a script is designed to receive
    input, it reads it from the *standard input stream (stdin)*. Finally, scripts
    may display error messages to the screen due to a bug or syntax error in the commands
    sent to it. These messages are sent to the *standard error stream (stderr)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate streams, we’ll use the mkdir command to create a few directories
    and then use ls to list the content of the current directory. Open your terminal
    and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice that mkdir generates an error. This is because we pass the directory
    name *directory1* twice on the command line. So, when mkdir runs, it creates *directory1*
    and *directory2*, then fails on the third argument because, at that point, *directory1*
    has already been created. These types of errors are sent to the standard error
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we execute ls -l, which simply lists the directories. The result of the
    ls command succeeds without any specific errors, so it is sent to the standard
    output stream.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll practice working with the standard input stream when we introduce redirection
    in “Redirection Operators” on [page 18](#pg_18).
  prefs: []
  type: TYPE_NORMAL
- en: Control Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Control operators* in bash are tokens that perform a control function. [Table
    1-3](chapter1.xhtml#tab1-3) gives an overview of control operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-3: Bash Control Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| & | Sends a command to the background. |'
  prefs: []
  type: TYPE_TB
- en: '| && | Used as a logical AND. The second command in the expression will be
    evaluated only if the first command evaluates to true. |'
  prefs: []
  type: TYPE_TB
- en: '| (and) | Used for command grouping. |'
  prefs: []
  type: TYPE_TB
- en: '| ; | Used as a list terminator. A command following the terminator will run
    after the preceding command has finished, regardless of whether it evaluates to
    true or not. |'
  prefs: []
  type: TYPE_TB
- en: '| ;; | Ends a case statement. |'
  prefs: []
  type: TYPE_TB
- en: '| &#124; | Redirects the output of a command as input to another command. |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;&#124; | Used as a logical OR. The second command will run if the first
    one evaluates to false. |'
  prefs: []
  type: TYPE_TB
- en: Let’s see some of these control operators in action. The & operator sends a
    command to the background. If you have a list of commands to run, as in [Listing
    1-18](chapter1.xhtml#Lis1-18), sending the first command to the background will
    allow bash to continue to the next line even if the previous command hasn’t finished
    its work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-18: Sending a command to the background so execution can move to
    the next line'
  prefs: []
  type: TYPE_NORMAL
- en: Commands that are long-running are often sent to the background to prevent scripts
    from hanging ❶. You’ll learn about sending commands to the background in more
    depth when we discuss job control in [Chapter 2](chapter2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'The && operator allows us to perform an AND operation between two commands.
    In the following example, the file *test123* will be created only if the first
    command is successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The () operator allows us to group commands so they act a single unit when
    we need to redirect them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is generally useful when you need to redirect results from multiple commands
    to a stream, as shown in “Redirection Operators,” next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ; operator allows us to run multiple commands regardless of their exit
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As a result, each command is executed one after the other, as soon as the previous
    one finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The || operator allows us to chain commands together using an OR operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the echo command will be executed only if the first command
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Redirection Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The three standard streams we highlighted earlier can be redirected from one
    program to another. *Redirection* is taking output from one command or script
    and using it as input to another script or file for writing purposes. [Table 1-4](chapter1.xhtml#tab1-4)
    describes the available redirection operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-4: Redirection Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| > | Redirects stdout to a file |'
  prefs: []
  type: TYPE_TB
- en: '| >> | Redirects stdout to a file by appending it to the existing content |'
  prefs: []
  type: TYPE_TB
- en: '| &> or >& | Redirects stdout and stderr to a file |'
  prefs: []
  type: TYPE_TB
- en: '| &>> | Redirects stdout and stderr to a file by appending them to the existing
    content |'
  prefs: []
  type: TYPE_TB
- en: '| < | Redirects input to a command |'
  prefs: []
  type: TYPE_TB
- en: '| << | Called a here document, or heredoc, redirects multiple input lines to
    a command |'
  prefs: []
  type: TYPE_TB
- en: '| &#124; | Redirects output of a command as input to another command |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s practice using redirection operators to see how they work with standard
    streams. The > operator redirects the standard output stream to a file. Any command
    that precedes this character will send its output to the specified location. Run
    the following command directly in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We redirect the standard output stream to a file named *output.txt*. To see
    the content of *output.txt*, simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll use the >> operator to append some content to the end of the same
    file ([Listing 1-19](chapter1.xhtml#Lis1-19)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-19: Appending content to a file'
  prefs: []
  type: TYPE_NORMAL
- en: If we had used > instead of >>, the content of *output.txt* would have been
    overwritten completely with the Goodbye! text.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can redirect both the standard output stream and the standard error stream
    to a file by using &>. This is useful when you don’t want to send any output to
    the screen and instead save everything in a logfile (perhaps for later analysis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To append both the standard output and standard error streams to a file, use
    the ampersand followed by the double chevron (&>>).
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to send the standard output stream to one file and the standard
    error stream to another? This is also possible using the streams’ file descriptor
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You may sometimes find it useful to redirect the standard error stream to a
    file, as we’ve done here, so you can log any errors that occur during runtime.
    The next example runs a nonexistent command, lzl. This should generate bash errors
    that will be written into the *error.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you don’t see the error onscreen because bash sends the error to
    the file instead.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s use the standard input stream. Run the command in [Listing 1-20](chapter1.xhtml#Lis1-20)
    in the shell to supply the contents of *output.txt* as input to the cat command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-20: Using a file as a command’s input'
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to redirect multiple lines to a command? Here document redirection
    (<<) can help with this ([Listing 1-21](chapter1.xhtml#Lis1-21)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-21: Here document redirection'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we pass multiple lines as input to a command. The EOF in this
    example acts as a delimiter, marking the start and end points of the input. *Here
    document redirection* treats the input as if it were a separate file, preserving
    line breaks and whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: The *pipe* operator (|) redirects the output of one command and uses it as the
    input of another. For example, we could run the ls command on the root directory
    and then use another command to extract data from it, as shown in [Listing 1-22](chapter1.xhtml#Lis1-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-22: Piping command output into another command'
  prefs: []
  type: TYPE_NORMAL
- en: We use ls to print the content of the root directory into the standard output
    stream, then use a pipe to send it as input to the grep command, which filters
    out any lines containing the word *bin*.
  prefs: []
  type: TYPE_NORMAL
- en: Positional Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bash scripts can take *positional arguments* (also called *parameters*) passed
    on the command line. Arguments are especially useful, for example, when you want
    to develop a program that modifies its behavior based on input passed to it by
    another program or user. Arguments can also change features of the script such
    as the output format and how verbose it will be during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine you develop an exploit and send it to a few colleagues,
    each of whom will use it against a different IP address. Instead of writing a
    script and asking the user to modify it with their network information, you can
    write it to take an IP address argument and then act against this input to avoid
    having to modify the source code in each case.
  prefs: []
  type: TYPE_NORMAL
- en: A bash script can access arguments passed to it on the command line by using
    the variables $1, $2, and so on. The number represents the order in which the
    argument was entered. To illustrate this, the script in [Listing 1-23](chapter1.xhtml#Lis1-23)
    takes in an argument (an IP address or domain name) and performs a ping test against
    it by using the ping utility. Save this file as *ping_with_arguments.sh*.
  prefs: []
  type: TYPE_NORMAL
- en: ping_with _arguments.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-23: A script that accepts command line input'
  prefs: []
  type: TYPE_NORMAL
- en: This script assigns the first positional argument to the variable TARGET. Notice,
    also, that the argument ${0} is assigned to the SCRIPT_NAME variable. This argument
    contains the script’s name (in this case, *ping_with_arguments.sh*).
  prefs: []
  type: TYPE_NORMAL
- en: To run this script, use the commands in [Listing 1-24](chapter1.xhtml#Lis1-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-24: Passing arguments to a script'
  prefs: []
  type: TYPE_NORMAL
- en: This script will perform a ping command against the domain *nostarch.com* passed
    to it on the command line. The value is assigned to the $1 variable; if we passed
    another argument, it would get assigned to the second variable, $2. Use CTRL-C
    to exit this script, as ping may run indefinitely on some operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to access all arguments? You can do so using the variable $@.
    Also, using $#, you can get the total number of arguments passed. [Listing 1-25](chapter1.xhtml#Lis1-25)
    demonstrates how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-25: Retrieving all arguments and the total number of arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this script to a file named *show_args.sh* and run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 1-5](chapter1.xhtml#tab1-5) summarizes the variables related to positional
    arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-5: Special Variables Related to Positional Arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| $0 | The name of the script file |'
  prefs: []
  type: TYPE_TB
- en: '| $1, $2, $3, ... | Positional arguments |'
  prefs: []
  type: TYPE_TB
- en: '| $# | The number of passed positional arguments |'
  prefs: []
  type: TYPE_TB
- en: '| $* | All positional arguments |'
  prefs: []
  type: TYPE_TB
- en: '| $@ | All positional arguments, where each argument is individually quoted
    |'
  prefs: []
  type: TYPE_TB
- en: 'When a script uses "$*" with the quotes included, bash will expand arguments
    into a single word. For instance, the following example groups the arguments into
    one word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When a script uses "$@" (again including the quotes), it will expand arguments
    into separate words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, you will want to use "$@" so that every argument is treated as
    an individual word.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script demonstrates how to use these special variables in a for
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Input Prompting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some bash scripts don’t take any arguments during execution. However, they may
    need to ask the user for information in an interactive way and have the response
    feed into their runtime. In these cases, we can use the read command. You often
    see applications use *input prompting* when attempting to install software, asking
    the user to enter *yes* to proceed or *no* to cancel the operation.
  prefs: []
  type: TYPE_NORMAL
- en: In the bash script in [Listing 1-26](chapter1.xhtml#Lis1-26), we ask the user
    for their first and last names and then print these to the standard output stream.
  prefs: []
  type: TYPE_NORMAL
- en: input _prompting.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-26: Prompting a user for input'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save and run this script as *input_prompting.sh*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you are prompted to enter information that then gets printed.
  prefs: []
  type: TYPE_NORMAL
- en: Exit Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bash commands return *exit codes*, which indicate whether the execution of the
    command succeeded. Exit codes fall in the 0 to 255 range, where 0 means success,
    1 means failure, 126 means that the command was found but is not executable, and
    127 means the command was not found. The meaning of any other number depends on
    the specific command being used and its logic.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Exit Codes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To see exit codes in action, save the script in [Listing 1-27](chapter1.xhtml#Lis1-27)
    to a file named *exit_codes.sh* and run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-27: Using exit codes to determine a command’s success'
  prefs: []
  type: TYPE_NORMAL
- en: We use the special variable $? with the echo command to return the exit codes
    of the executed commands ls and lzl. We also redirect their standard output and
    standard error streams to the file */dev/null*, a special device file that discards
    any data sent to it. When you want to silence commands, you can redirect their
    output to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We receive two distinct exit codes, one for each command. The first command
    returns 0 (success), and the second returns 127 (command not found).
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Use* /dev/null *with caution. You may miss out on important errors if you
    choose to redirect output to it. When in doubt, redirect standard streams such
    as standard output and standard error to a dedicated logfile instead.*'
  prefs: []
  type: TYPE_NORMAL
- en: To understand why you might want to use exit codes, imagine you’re trying to
    download a 1GB file from the internet by using bash. It might be wise to first
    check whether the file already exists on the filesystem in case someone ran the
    script and retrieved it. Also, you might want to check that you have enough free
    space on the disk before attempting the download. By running commands and looking
    at their returned exit codes, you can decide whether to proceed with the file
    download.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a Script’s Exit Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can set the exit code of a script by using the exit command followed by
    the code number, as shown in [Listing 1-28](chapter1.xhtml#Lis1-28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-28: Setting a script’s exit code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this script as *set_exit_code.sh* and run it on the command line. Then
    use the special variable $? to see the exit code it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the $? variable to check the returned exit code not only of a script
    but also of individual commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Exit codes are important; they can be used in a series of scripts that call
    one another or within the same script, to control the logical flow of the code
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Recording Your Name and the Date'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a script that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Accepts two arguments on the command line and assigns them to variables.
    The first argument should be your first name, and the second should be your last
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Creates a new file named *output.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Writes the current date to *output.txt* by using the date command. (Bonus
    points if you can make the date command print the date in the DD-MM-YYYY format;
    use man date to learn how this works.)
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Writes your full name to *output.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Makes a backup copy of *output.txt*, named *backup.txt*, using the cp command.
    (Use man cp if you aren’t sure of the command’s syntax.)
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Prints the content of the *output.txt* file to the standard output stream.
  prefs: []
  type: TYPE_NORMAL
- en: You can find an example solution, *exercise_solution.sh*, in the book’s GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you ran simple Linux commands in the terminal and used man
    to learn about command options. You also learned how to pass arguments to scripts
    and execute a sequence of commands from within scripts. We covered the fundamentals
    of bash, such as how to write basic programs that use variables, arrays, redirects,
    exit codes, and arguments. You also learned how to prompt the user to enter arbitrary
    information and use it as part of a script’s flow.
  prefs: []
  type: TYPE_NORMAL
