["```\nbl_crc = Crc(width = 16**,** poly=0x1021)\n```", "```\nbl_crc.bit_by_bit(message)\n```", "```\nfor byte in range(16):\n    for bit in range(8):\n        # Attack bit number (byte*8 + bit)\n```", "```\n#This will either result in a 0 or a 1\ncheckIfBitSet = **(**byteToCheck >> bit**)** & 0x01\n```", "```\nCorrelation values: [0.55993054 0.998865 0.99907424 0.99908035 0.9990855 4]\nSignature byte guess: [0 250 139 134 229]\n```", "```\n // Continue with decryption\n  trigger_high();\n  aes256_decrypt_ecb(&ctx, tmp32);\n  trigger_low();\n\n  // Apply IV (first 16 bytes)\n1 for (i = 0; i < 16; i++){\n      tmp32[i] ^= iv[i];\n  }\n\n  // Save IV for next time from original ciphertext\n2 for (i = 0; i < 16; i++){\n      iv[i] = tmp32[i+16];\n  }\n\n  // Tell the user that the CRC check was okay\n3 putch(COMM_OK);\n  putch(COMM_OK);\n\n  // Check the signature\n4 if ((tmp32[0] == SIGNATURE1) &&\n     (tmp32[1] == SIGNATURE2) &&\n     (tmp32[2] == SIGNATURE3) &&\n     (tmp32[3] == SIGNATURE4)){\n\n     // Delay to emulate a write to flash memory\n     _delay_ms(1);\n  }\n```", "```\nif ((tmp32[0] == SIGNATURE1) &&\n    (tmp32[1] == SIGNATURE2) &&\n    (tmp32[2] == SIGNATURE3) &&\n    (tmp32[3] == SIGNATURE4)){\n```", "```\n //Check the signature\n               if ((tmp32[0] == SIGNATURE1) &&\n   8000338:   f89d 3018   ldrb.w  r3, [sp, #24]\n   800033c:   2b00        cmp r3, #0\n   800033e:   d1c2        bne.n   80002c6 <main+0x52>\n   8000340:   f89d 2019   ldrb.w  r2, [sp, #25]\n 1 8000344:   2aeb        cmp r2, #235    ; 0xeb\n 2 8000346:   d1be        bne.n   80002c6 <main+0x52>\n                   (tmp32[1] == SIGNATURE2) &&\n   8000348:   f89d 201a   ldrb.w  r2, [sp, #26]\n 3 800034c:   2a02        cmp r2, #2\n 4 800034e:   d1ba        bne.n   80002c6 <main+0x52>\n                   (tmp32[2] == SIGNATURE3) &&\n   8000350:   f89d 201b   ldrb.w  r2, [sp, #27]\n   8000354:   2a1d        cmp r2, #29\n   8000356:   d1b6        bne.n   80002c6 <main+0x52>\n                   (tmp32[3] == SIGNATURE4)){\n```"]