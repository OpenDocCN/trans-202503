- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTROLLING
    HIGHER-POWERED DEVICES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Many Arduino users rely on the 74HC595 shift register for their projects, as
    it’s popular and easy to use. However, the 74HC595 can handle only a relatively
    low amount of current, especially when all pins are active: while you can draw
    20 mA of current from one output continuously, the entire IC is rated for a draw
    of only 70 mA through the V[CC] or GND pin.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need 20 mA per output to drive, for instance, eight separate LEDs, you
    could use only three of the eight pins under recommended operating conditions.
    While it may be possible to exceed the manufacturer’s direction, good electronic
    designs should consider safety and reliability. A shift register designed to handle
    higher currents is a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter shows you how to control higher-powered devices with your Arduino
    with the TPIC6B595 shift register IC. You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Experiment with a binary number display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiple TPIC6B595s to control more than eight high-powered outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use bright Piranha-style LEDs that are more powerful than regular LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also build a PC-controlled eight-relay board and control giant seven-segment
    numeric displays.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The TPIC6B595</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TPIC6B595 is controlled in the same way as the 74HC595 but offers up to
    150 mA per output and a 500 mA IC total current draw—just over 60 mA per pin when
    all pins are used. It can also switch voltages up to 50 V DC. This allows for
    control of eight higher-current items such as powerful LEDs, relay coils, or mechanical
    switchgear.
  prefs: []
  type: TYPE_NORMAL
- en: The TPIC6B595 is a *latching shift register*, meaning that as long as power
    is connected, it will maintain the output status. For example, if you upload a
    new sketch, the outputs are not affected. If you’ve powered your circuit from
    a power supply and not the Arduino, you can reset the Arduino without altering
    the outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-1](chapter8.xhtml#fig8-1) shows a TPIC6B595 in a dual in-line package,
    through-hole format in a solderless breadboard.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PICTURE OF A TPIC6B595 IN A SOLDERLESS BREADBOARD](../images/fig8-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: A TPIC6B595 shift
    register</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-2](chapter8.xhtml#fig8-2) shows the TPIC6B595’s schematic symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR THE TPIC6B595](../images/fig8-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: The schematic symbol
    for the TPIC6B595</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The eight output pins in the schematic are labeled DRAIN*x*, since the TPIC6B595
    has low-side outputs. Like the 2N7000 N-MOSFETs used in previous chapters, each
    of these outputs controls current entering the pin (as opposed to the 74HC595’s
    high-side outputs, for example, where currents flow out from the eight control
    pins). This means the devices to be controlled are connected between the power
    supply and the control pins on the TPIC6B595, which switches the currents’ ability
    to flow from the device to GND.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the schematic in [Figure 8-3](chapter8.xhtml#fig8-3). Current flows
    from the 5 V source, through the resistor and LED, and into the TPIC6B595’s output
    pin. When that pin is activated, the current continues to GND, completing the
    circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCHEMATIC OF THE LED CONNECTED TO THE TPIC6B595 VIA 5V AND CURRENT-LIMITING
    RESISTOR](../images/fig8-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: An example of LED
    control with TPIC6B595</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Given the TPIC6B595’s method of controlling current, the voltage of the devices
    it controls can be up to 50 V, while the shift register is still operating on
    5 V. Conveniently, that means you can control 12 V devices or higher without worrying
    about level conversion back to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put the TPIC6B595 to the test with a simple project that demonstrates
    shift register operation.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #25: Creating a TPIC6B595
    Binary Number Display</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project demonstrates the use of TPIC6B595 outputs while refreshing your
    knowledge of binary numbers and how they relate to shift register output control.
    You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TPIC6B595 shift register IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 0.1 µF capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 8-4](chapter8.xhtml#fig8-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #25, SHOWING A TPIC6B595 CONTROLLING EIGHT LEDS
    VIA CURRENT-LIMITING RESISTORS](../images/fig8-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">The
    schematic for Project #25</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the Project #25 sketch. Open the Serial Monitor in the IDE
    and enter a number between 0 and 255, inclusive, then press CTRL-ENTER. The Arduino
    should respond by displaying the number in binary using the LEDs, as well as in
    the Serial Monitor, as shown in [Figure 8-5](chapter8.xhtml#fig8-5). LED 1 will
    be the least significant bit of the number, which represents 1, and LED 8 will
    be the most significant bit, which represents 255.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OUTPUT FROM THE SERIAL MONITOR FOR PROJECT #25 SHOWING THE NUMBER
    ENTERED AND THE MATCHING BINARY VALUE](../images/fig8-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: Example output
    from Project #25</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch begins by defining the Arduino digital pins used for connecting to
    the shift register’s Latch, Clock, and Data pins, respectively ❶. The custom <samp
    class="SANS_TheSansMonoCd_W5Regular_11">displayBinary()</samp> function accepts
    an integer and sends it to the shift register for output control, using the same
    method as the 74HC595 shift register mentioned earlier. To send the bits representing
    the number to the shift register in binary and to activate the pins in the shift
    register to control the LEDs that will match the number to be displayed in binary,
    the function uses <samp class="SANS_TheSansMonoCd_W5Regular_11">MSBFIRST</samp>
    (most significant bit first).
  prefs: []
  type: TYPE_NORMAL
- en: You can turn shift register outputs on and off with the 8 bits of the number
    sent to the shift register, as each bit matches an output and a status (1 for
    HIGH, 0 for LOW). You can also change <samp class="SANS_TheSansMonoCd_W5Regular_11">MSBFIRST</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">LSBFIRST</samp>, standing for
    least significant bit first, to see the number “reversed” in binary.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch initializes the Serial Monitor and digital output pins ❷ and then
    flushes the serial input and waits for the user to enter a number into the Serial
    Monitor ❸. It then combines the digits of the number entered in the Serial Monitor
    to make the final number to display ❹. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">displayBinary()</samp>
    function sends that number to the shift register and the Serial Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll put this framework for shift register control to use in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #26: Building a PC-Controlled
    Relay Board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build a relay control board with eight single-pole,
    double-throw (SPDT) relays that you control via a PC or another device with an
    Arduino-compatible UART. In the future, you might use the technique introduced
    in this project to control low-voltage lighting or electric door locks, turn speakers
    on and off, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Each relay in this project is capable of controlling up to 30 V DC at 2 A of
    current, if you’re using the project PCB. If you’re using the solderless breadboard,
    the relays should be used to switch only up to 100 mA or so.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s possible to build this project using a solderless breadboard, this
    requires soldering jumper wires to the relay pins for remotely wiring the relays
    back to the circuit, as shown in [Figure 8-6](chapter8.xhtml#fig8-6), as the relay
    pins don’t sit in the breadboard very well. I strongly recommend you use the PCB
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A RELAY WITH JUMPER WIRES SOLDERED TO ITS PINS, FOR USE WITH A
    SOLDERLESS BREADBOARD](../images/fig8-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: A relay with remote
    wiring for breadboard use</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 12 V power supply or wall wart with DC plug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TPIC6B595 shift register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 20-pin IC socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 0.1 µF capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight 1N4001 power diodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight SRD-12VDC-SL-C SPDT relays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A solderless breadboard or Project #26 PCB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re using the PCB, you will also need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ten three-way 5.08 mm terminal blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 20-pin IC socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCB mount DC socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 8-7](chapter8.xhtml#fig8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCHEMATIC FOR PROJECT #26, SHOWING THE TPIC6B595 CONTROLLING EIGHT RELAYS
    WITH INDICATOR LEDS](../images/fig8-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-7: The schematic for
    Project #26</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the PCB, the layout is simple, as shown in [Figure 8-8](chapter8.xhtml#fig8-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF AN UNPOPULATED PCB FOR PROJECT #26](../images/fig8-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-8: The PCB for Project
    #26</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Start by inserting the resistors; then insert the diodes, the LEDs, the IC and
    DC sockets, the terminal blocks, and end with the relays. Be sure to insert the
    shift register correctly—pin 1 is marked on the PCB. Connect to the Arduino via
    the two terminal blocks next to the shift register, as shown in the schematic
    and [Figure 8-9](chapter8.xhtml#fig8-9). The Arduino is powered by the relay board’s
    12 V supply and returns 5 V to the board to power the shift register.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF COMPLETED PROJECT #26 CONNECTED TO EXTERNAL POWER AND AN ARDUINO
    UNO, WITH SEVEN LIGHTS LIT UP](../images/fig8-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-9: The completed hardware
    for Project #26</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve set up the hardware, enter and upload the Project #26 sketch, which
    controls the relays with various commands. Entering the numbers 0 through 7 using
    the Serial Monitor or terminal software turns on relays 0 through 7, respectively;
    entering 8 through F turns off relays 0 to 7; G turns all relays on; and H turns
    all relays off. Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> to
    check which relays are on and off based on the commands being entered. The result
    is returned as a binary number matching the relay order. If the user enters an
    unrecognized character, the Arduino returns a list of valid commands.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Figure 8-10](chapter8.xhtml#fig8-10) shows the output for the
    commands <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">Q</samp>
    (which caused the incorrect command message to display), then <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>,
    and then <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE SERIAL MONITOR OUTPUT FOR PROJECT #26 SHOWING EXAMPLE COMMANDS
    TO TURN ON AND OFF RELAYS AND SHOWING USER HELP LINE](../images/fig8-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-10: An example of
    operations in the Serial Monitor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re sharing the relay board and Arduino with others, they don’t need to
    run the Arduino IDE for control; instead they can use any terminal software on
    their PC, Mac, or other computer that supports USB serial. For example, the same
    operation is possible with Roger Meier’s CoolTerm application, available from
    [*http://<wbr>freeware<wbr>.the<wbr>-meiers<wbr>.org*](http://freeware.the-meiers.org),
    as shown in [Figure 8-11](chapter8.xhtml#fig8-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE OUTPUT FOR PROJECT #26 SHOWING EXAMPLE COMMANDS TO TURN ON AND
    OFF RELAYS AND SHOWING THE USER HELP LINE USING THE COOLTERM TERMINAL SOFTWARE
    INSTEAD OF A SERIAL MONITOR](../images/fig8-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-11: Controlling the
    relays using the CoolTerm application</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The control Arduino expects only single characters from the host computer (or
    other UART), so you can write software for your computer in many environments
    to control the relays. Search your preferred environment’s resources for “plaintext
    serial over USB” or similar to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The sketch first declares the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>,
    which holds the status of the relays. Think of this number in binary, with the
    least significant bit representing relay 0: if this bit is 1, the relay is on,
    and if it is 0, the relay is off. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">showStatus()</samp>
    function sends the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>
    in binary back to the serial interface, so the receiver can see which relays are
    on or off in their terminal, Serial Monitor, or other software. All the functions
    that control a relay also send feedback via serial to the user, describing the
    completed action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">relayOn(int a)</samp> function
    turns on relays, using the bitwise arithmetic operator OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>)
    to activate the desired relay without interrupting other relays. The function
    receives the value <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    performs a bitwise OR with the <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>
    variable, then it updates the relays using the new value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>.
    For example, if relays 0, 1, 2, and 3 are on, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>
    in binary is currently B00001111\. If the user then enters <samp class="SANS_TheSansMonoCd_W7Bold_B_11">5</samp>
    in the Serial Monitor (or terminal software) to turn on relay 5, the program would
    switch bit 5 to 1, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sendStatus()</samp> function
    changes the relays accordingly by updating the shift register outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">relayOff(int a)</samp> function
    turns relays off, using the bitwise arithmetic operator XOR (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>)
    to deactivate the desired relay without interrupting other relays. For example,
    if relays 0, 1, 2, 3, and 5 are on, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>
    in binary is currently B00101111\. If you enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A</samp>
    in the Serial Monitor or terminal software to turn off relay 3, the program should
    switch bit 3 to 0, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, the <samp class="SANS_TheSansMonoCd_W5Regular_11">sendStatus()</samp>
    function changes the relays accordingly by updating the shift register outputs.
    Two additional functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">allOn()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">allOff()</samp>, turn all relays
    on and off, respectively, by sending 255 (binary <samp class="SANS_TheSansMonoCd_W5Regular_11">B11111111</samp>)
    and 0 (binary <samp class="SANS_TheSansMonoCd_W5Regular_11">B0000000</samp>) to
    the shift register.
  prefs: []
  type: TYPE_NORMAL
- en: General operation is simple. The Arduino awaits a single character from the
    serial line ❶. Once a character has arrived, it is matched to a command ❷. The
    user can activate the simple <samp class="SANS_TheSansMonoCd_W5Regular_11">waveHello()</samp>
    function ❸ by pressing <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Z</samp> to
    turn the relays on and off one at a time, for testing and amusement. Finally,
    if the character isn’t a command, the program sends a quick reference to serial
    ❹ so the user can learn the command set.
  prefs: []
  type: TYPE_NORMAL
- en: For a challenge, you can modify the sketch so the relay status is saved to the
    internal EEPROM when changed and the system sets the relays from the EEPROM data
    after a reset.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to control eight higher-current devices with a single
    TPIC6B595, I’ll show you how to use two or more TPIC6B595s at once.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Multiple TPIC6B595s</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can easily use two or more TPIC6B595 shift registers at once to control
    16 or more devices in the same way you would with the 74HC595, but with the ability
    to handle higher currents. Start by connecting each TPIC6B595’s Clock lines together,
    connect their Latch lines together, then connect the Serial Out from the first
    shift register to the Serial In on the second shift register, repeating as required.
    For example, the schematic in [Figure 8-12](chapter8.xhtml#fig8-12) shows double
    the number of LEDs controlled by Project #25.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig8-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-12: The schematic
    for controlling 16 LEDs with shift registers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, send out 2 bytes of data while the latch is low, instead of 1 byte. You’ll
    need to send the byte for the last shift register in the chain first. For example,
    to send out 2 bytes to the shift registers in [Figure 8-12](chapter8.xhtml#fig8-12),
    you would use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To add one or more additional shift registers, just add more parameters and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shiftOut()</samp> functions, one
    for each extra register. You’ll use multiple TPIC6B595s in the following project,
    along with a new type of LED.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Piranha-Style LEDs</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s an incredible range of LEDs available on the market, from tiny surface-mount
    LEDs to those large enough to serve as part of an automotive headlight. One example
    in between these two is the compact yet very bright Piranha-style LED; its through-hole
    packaging makes it easy to use. [Figure 8-13](chapter8.xhtml#fig8-13) shows a
    pair of Piranha LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF TWO PIRANHA LEDS ON A SOLDERLESS BREADBOARD](../images/fig8-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-13: Two Piranha LEDs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each LED has four legs, two anodes, and two cathodes. The two anode pins are
    electrically connected to each other, as are the two cathode pins. The anode side
    has the corner cut off at the bottom left, as well as a larger metallic surface
    compared to the cathode side. [Figure 8-14](chapter8.xhtml#fig8-14) shows the
    schematic symbol for Piranha LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR PIRANHA LEDS](../images/fig8-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-14: The schematic
    symbol for Piranha-style LEDs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When used alone, these LEDs operate safely at 20 mA of current at around 2 to
    2.2 V DC. For the next project, you’ll use them in groups of four each, organized
    in series (rather than parallel to each other). In this configuration, each group
    of four LEDs will require 9 V DC power and a 47 Ω resistor to maintain the required
    current and a high brightness.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the required resistor to use with LEDs in series, you use formula
    R = (V[s] − V[f]) / I[f] , where V[s] is the power supply voltage, V[f] is the
    forward voltage (recommended operating voltage) of the LEDs, and I[f] is the recommended
    operating current for the LEDs. For the following project, you’d use 8 V at 20
    mA as the LED forward voltage and operating current, with a 9 V supply. This gives
    you R = (9 V − 8 V) / .02 A, which results in 50 Ω. We don’t have a 50 Ω resistor,
    so 47 Ω is the nearest choice.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #27: Creating a Giant Seven-Segment
    LED Display</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple TPIC6B595s work well to drive large numbers of LEDs. In this project,
    you’ll build one or more seven-segment LED displays to create large numerical
    displays you can use for various purposes. For instance, you might use them to
    indicate various data generated with an Arduino project, such as temperature,
    an event count, or time.
  prefs: []
  type: TYPE_NORMAL
- en: To construct a single-digit display, you’ll need the following parts. For a
    larger display, multiply all parts other than the Arduino by the number of digits
    you’d like to create. This project shows you how to use four digits at once, so
    multiply by four if you’d like to follow the example exactly. For this project,
    use the PCB rather than a breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 9 V power supply or wall wart with DC plug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TPIC6B595 shift register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 20-pin IC socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 0.1 µF capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thirty-two 5 mm Piranha-style LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight 47 Ω, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four 3-contact 5.08 mm terminal blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCB mount DC socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Project #27 PCB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 8-15](chapter8.xhtml#fig8-15) shows the project’s schematic.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #27, SHOWING SHIFT REGISTER CONTROL OF EIGHT GROUPS
    OF PIRANHA LEDS](../images/fig8-15.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-15: The schematic
    for Project #27</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the TPIC6B595 has “low-side” outputs. When an output is activated,
    the current starts from the power supply, goes through the items to be controlled,
    and then passes through the shift register DRAIN pins and out via GND.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Single-Digit Display</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 8-16](chapter8.xhtml#fig8-16) shows the simple PCB layout.'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN UNPOPULATED PCB FOR ONE DISPLAY DIGIT](../images/fig8-16.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-16: The unpopulated
    PCB for one digit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Always start by connecting the lowest-profile components: the resistors, the
    IC socket, the LEDs, and, finally, the DC socket and terminal blocks. Don’t be
    tempted to insert all the LEDs at once and then turn the PCB over, as some of
    the LEDs may come loose or fall out. Instead, solder them in one at a time. Orient
    all the LEDs with the anodes on the left and cathodes on the right (the left side
    of the PCB is the one with the DC socket). Once completed, your board should resemble
    the example shown in [Figure 8-17](chapter8.xhtml#fig8-17).'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE COMPLETED PCB FOR ONE DISPLAY DIGIT WITH ALL LEDS AND COMPONENTS SOLDERED
    IN, READY FOR USE](../images/fig8-17.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-17: The completed
    PCB for one digit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve set up the hardware, enter and upload the Project #27a sketch that
    follows, which demonstrates one digit (you can choose to build three more digits
    in the section “Four-Digit Display”). After uploading the sketch, you’ll need
    to connect your Arduino and power supply to the PCB. With the PCB facing upward
    and the DC socket on your left, make the connections as described in [Table 8-1](chapter8.xhtml#tab8-1).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">PCB
    to Arduino Connections</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PCB left side</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Arduino</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Clock</samp> | <samp class="SANS_Futura_Std_Book_11">D9</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Latch</samp> | <samp class="SANS_Futura_Std_Book_11">D8</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">9V</samp> | <samp class="SANS_Futura_Std_Book_11">Vin</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Serial In</samp> | <samp class="SANS_Futura_Std_Book_11">D10</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Finally, connect a 9 V DC power supply to the DC socket on the PCB. The Arduino
    is powered by the 9 V supply via the Vin pin and feeds back 5 V to the display
    board to power the shift register. The display should count from zero to nine;
    then again with a decimal point beside each numeral, as shown in [Figure 8-18](chapter8.xhtml#fig8-18);
    and finally repeat.
  prefs: []
  type: TYPE_NORMAL
- en: '![AN EXAMPLE PHOTO OF ONE DIGIT, DISPLAYING THE NUMBER THREE WITH THE DECIMAL
    POINT ON](../images/fig8-18.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-18: Example display
    board output</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the incredible brightness of the LEDs, I set the supply voltage to
    7 V DC before taking the photo in [Figure 8-18](chapter8.xhtml#fig8-18) for a
    clearer picture. Your display should be much brighter when operating at its designated
    9 V DC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each segment of the digit consists of 28 Piranha LEDs, plus 4 more for the
    decimal point, driven by an output on the TPIC6B595\. Therefore, you could consider
    the digit to be made up of seven LEDs, plus one more for the decimal point. These
    are controlled via the TPIC6B595’s outputs in the same method as the relay board
    described in Project #26.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first defines the Arduino digital pins used for connecting to the
    shift register’s Latch, Clock, and Data pins ❶. For the array of 8 bytes ❷, each
    byte represents the eight outputs that are used to control the segments on the
    display. For example, the number 1 is represented in binary as <samp class="SANS_TheSansMonoCd_W5Regular_11">B00000110</samp>,
    as you want to turn on the second and third segments of the display to display
    1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">sendNumber()</samp>
    function sends the requisite data to display each digit to the shift register,
    which then sets the appropriate outputs. This function accepts the digit to display
    and accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp> as the second parameter,
    which is used to turn the decimal point on or off. If the decimal point is required,
    the sketch uses the OR function <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>
    ❸ (as in Project #7 in [Chapter 2](chapter2.xhtml)) to turn on the most significant
    bit of the shift register (bit 7), which controls DRAIN7.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> function
    sets the required digital output pins. Finally, the sketch demonstrates the display
    by counting from zero to nine and back again ❹ and then again with the decimal
    point turned on ❺.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a large, impressive numerical LED display that can be seen from
    quite a distance. If the LEDs are too bright for your liking, you can increase
    the value of the resistors, perhaps to 180 or 270 Ω. Be sure to use 0.25 W (1/4
    W) resistor types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Four-Digit Display</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can build and use multiple display boards for larger numerical projects.
    In this example, you’ll use four boards to display numbers of up to four digits.
    You might use this to display data or as a large, bright clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Construct a second, third, and fourth board just as you did in the previous
    section, with one difference: these new boards won’t need the DC socket, as the
    first display board will act as your power source. Once the extra boards are assembled,
    connect them by bridging the terminal blocks on each side to each other. The matching
    labels on the rear of the display boards, as shown in [Figure 8-19](chapter8.xhtml#fig8-19),
    will help you do so.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO SHOWING THE WIRING BETWEEN TWO DIGIT PCBS](../images/fig8-19.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-19: The rears of two
    display boards</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter and upload the Project #27b demonstration sketch. Once the upload
    completes, connect the Arduino to the leftmost display board and connect the 9
    V power supply. The display boards should show random four-digit numbers, with
    random placement of the decimal point, as shown in [Figure 8-20](chapter8.xhtml#fig8-20).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE FOUR DIGITS IN OPERATION, SHOWING THE VALUE 634.1](../images/fig8-20.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-20: The four display
    boards operating at 7 V DC</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The sketch for four boards has a few differences from the Project #27a sketch
    to make using multiple displays easier. Once again, it defines the Arduino digital
    pins used for connecting to the shift register’s Latch, Clock, and Data pins ❶
    and defines the array of 8 bytes ❷ that represents the eight outputs used to control
    the segments on the display.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">void sendNumbers()</samp>
    function accepts two parameters: an array of four numbers (one for each display
    board) and an integer that represents on which boards to display the decimal point.
    The sketch checks for this ❸. If the parameter is 1, the required bit for the
    decimal point display is included in the byte sent to the shift register ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: As you’re displaying random numbers, the generator is seeded with the analog
    input data ❺, and then the array for numbers to be displayed is also filled with
    random numbers ❻ and sent to the display boards ❼. Finally, the sketch includes
    a delay before displaying more random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can display all sorts of numerical data with these boards. You might also
    add your own characters by adding more elements to the digit arrays. For example,
    a degree symbol for temperature would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For a challenge, pair up four display boards with an Arduino and a real-time
    clock module to make a large, bright clock. You might add a thermometer as well.
    I hope you enjoy using these display boards as much as I enjoyed designing them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to control currents and voltages using the
    TPIC6B595 shift register, a more capable alternative to the popular 74HC595\.
    You can now control items that draw more current than an Arduino’s digital I/O
    pin can safely handle. You also learned how to use bright Piranha-style LEDs for
    excellent indicators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll use MP3 player modules to create digital music players
    and sound boards for various purposes.
  prefs: []
  type: TYPE_NORMAL
