- en: Chapter 2. Compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The code Ruby actually runs looks nothing like your original code.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that Ruby has tokenized and parsed your code, is it ready to run it? Will
    it finally get to work and iterate through the block 10 times in my simple `10.times
    do` example? If not, what else could Ruby possibly have to do first?
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 1.9, Ruby compiles your code before executing it. The
    word *compile* means to translate your code from one programming language to another.
    Your programming language is easy for you to understand, while usually the target
    language is easy for the computer to understand.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you compile a C program, the compiler translates C code to
    machine language, a language your computer’s microprocessor hardware understands.
    When you compile a Java program, the compiler translates Java code to Java bytecode,
    a language the Java Virtual Machine understands.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby’s compiler is no different. It translates your Ruby code into another language
    that Ruby’s virtual machine understands. The only difference is that you don’t
    use Ruby’s compiler directly; unlike in C or Java, Ruby’s compiler runs automatically
    without you ever knowing. Here in [Chapter 2](ch02.html "Chapter 2. Compilation"),
    I’ll explain how Ruby does this and what language it translates your code into.
  prefs: []
  type: TYPE_NORMAL
- en: Roadmap
  prefs: []
  type: TYPE_NORMAL
- en: '[No Compiler for Ruby 1.8](ch02.html#no_compiler_for_ruby_1dot8 "No Compiler
    for Ruby 1.8")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ruby 1.9 and 2.0 Introduce a Compiler](ch02.html#ruby_1dot9_and_2dot0_introduce_a_compile
    "Ruby 1.9 and 2.0 Introduce a Compiler")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Ruby Compiles a Simple Script](ch02.html#how_ruby_compiles_a_simple_script
    "How Ruby Compiles a Simple Script")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Compiling a Call to a Block](ch02.html#compiling_a_call_to_a_block "Compiling
    a Call to a Block")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Ruby Iterates Through the AST](ch02.html#how_ruby_iterates_through_the_ast
    "How Ruby Iterates Through the AST")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Local Table](ch02.html#local_table "The Local Table")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Compiling Optional Arguments](ch02.html#compiling_optional_arguments "Compiling
    Optional Arguments")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Compiling Keyword Arguments](ch02.html#compiling_keyword_arguments "Compiling
    Keyword Arguments")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 2-2: Displaying the Local Table](ch02.html#experiment_2-2_displaying_the_local_tabl
    "Experiment 2-2: Displaying the Local Table")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](ch02.html#summary-id00008 "Summary")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No Compiler for Ruby 1.8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ruby core team introduced a compiler with version 1.9\. Ruby 1.8 and earlier
    versions of Ruby don’t contain a compiler. Instead, Ruby 1.8 immediately executes
    your code after the tokenizing and parsing processes are finished. It does this
    by walking through the nodes in the AST tree and executing each one. [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.")
    shows another way of looking at the Ruby 1.8 tokenizing and parsing processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top of [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.")
    shows your Ruby code. Below this are the different internal formats Ruby converts
    your Ruby code into. These are the tokens and AST nodes we saw in [Chapter 1](ch01.html
    "Chapter 1. Tokenization and Parsing")—the different forms your code takes when
    you run it using Ruby. The lower section of the diagram shows the code the Ruby
    core team wrote: the C source code for the Ruby language and the machine language
    it is converted into by the C compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: '![In Ruby 1.8, your code is converted into AST nodes and then interpreted.](httpatomoreillycomsourcenostarchimages1853899.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: The dotted line between the two code sections indicates that Ruby interprets
    your code. The Ruby C code, the lower section, reads and executes your code, the
    top section. Ruby 1.8 doesn’t compile or translate your code into any form beyond
    AST nodes. After converting it into AST nodes, it proceeds to iterate over the
    nodes in the AST, taking whatever action each node represents as it executes each
    node.
  prefs: []
  type: TYPE_NORMAL
- en: The gap in the middle of the diagram shows that your code is never completely
    compiled into machine language. If you were to disassemble and inspect the machine
    language that your CPU actually runs, you would not see instructions that directly
    map to your original Ruby code. Instead, you would find instructions that tokenize,
    parse, and execute your code, or, in other words, that implement the Ruby interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby 1.9 and 2.0 Introduce a Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve upgraded to Ruby 1.9 or 2.0, Ruby is still not quite ready to run
    your code. It needs to compile it first.
  prefs: []
  type: TYPE_NORMAL
- en: With Ruby 1.9, Koichi Sasada and the Ruby core team introduced Yet Another Ruby
    Virtual Machine (YARV), which actually executes your Ruby code. At a high level,
    this is the same idea behind the Java Virtual Machine (JVM) used by Java and many
    other languages. (I’ll cover YARV in more detail in [Chapter 3](ch03.html "Chapter 3. How
    Ruby Executes Your Code") and [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch").)
  prefs: []
  type: TYPE_NORMAL
- en: 'When using YARV (as with the JVM), you first compile your code into *bytecode*,
    a series of low-level instructions that the virtual machine understands. The only
    differences between YARV and the JVM are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby doesn’t expose the compiler to you as a separate tool. Instead, it automatically
    compiles your Ruby code into bytecode instructions internally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby never compiles your Ruby code all the way to machine language. As you can
    see in [Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "Figure 2-2. Ruby
    1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them."),
    Ruby interprets the bytecode instructions. The JVM, on the other hand, can compile
    some of the bytecode instructions all the way into machine language using its
    “hotspot” or just-in-time (JIT) compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "Figure 2-2. Ruby
    1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them.")
    shows how Ruby 1.9 and 2.0 handle your code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that this time, unlike in the process shown in [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted."),
    your code is translated into a third format. After parsing the tokens and producing
    the AST, Ruby 1.9 and 2.0 continue to compile your code into a series of low-level
    instructions called *YARV instructions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary reason for using YARV is speed: Ruby 1.9 and 2.0 run much faster
    than Ruby 1.8 due to the use of YARV instructions. Like Ruby 1.8, YARV is an interpreter—just
    a faster one. Your Ruby code ultimately is still not converted directly into machine
    language by Ruby 1.9 or 2.0\. There is still a gap in [Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod
    "Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before
    interpreting them.") between the YARV instructions and Ruby’s C code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting
    them.](httpatomoreillycomsourcenostarchimages1853901.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before
    interpreting them.
  prefs: []
  type: TYPE_NORMAL
- en: How Ruby Compiles a Simple Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at the last step along your code’s journey through
    Ruby: how Ruby compiles your code into the instructions that YARV expects. Let’s
    explore how Ruby’s compiler works by stepping through an example compilation.
    [Example 2-1](ch02.html#one-line_ruby_program_we_will_compile "Example 2-1. A
    one-line Ruby program we will compile as an example") shows a simple Ruby script
    that calculates 2 + 2 = 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1. A one-line Ruby program we will compile as an example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the "Figure 2-3. The
    AST Ruby produces after parsing the code in Example 2-1") shows the AST structure
    that Ruby will create after tokenizing and parsing this simple program. (This
    is a more detailed view of the AST than you would get from the Ripper tool that
    we saw in [Experiment 1-2: Using Ripper to Parse Different Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "Experiment 1-2: Using Ripper to Parse Different Ruby Scripts").)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The technical names shown in [Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the
    "Figure 2-3. The AST Ruby produces after parsing the code in Example 2-1") (*`NODE_SCOPE`*,
    *`NODE_FCALL`*, and so on) are taken from the actual Ruby C source code. To keep
    things simple, I’m omitting some AST nodes—specifically, ones that represent arrays
    of the arguments to each method call, which in this simple example would be arrays
    of only one element.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AST Ruby produces after parsing the code in](httpatomoreillycomsourcenostarchimages1853903.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3. The AST Ruby produces after parsing the code in [Example 2-1](ch02.html#one-line_ruby_program_we_will_compile
    "Example 2-1. A one-line Ruby program we will compile as an example")
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we cover the details of how Ruby compiles the `puts 2+2` script, let’s
    look at one very important attribute of YARV: It’s a *stack-oriented virtual machine*.
    That means when YARV executes your code, it maintains a stack of values—mainly
    arguments and return values for the YARV instructions. (I’ll explain this in more
    detail in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code").) Most
    of YARV’s instructions either push values onto the stack or operate on the values
    that they find on the stack, leaving a result value on the stack as well.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to compile the `puts 2+2` AST structure into YARV instructions, Ruby
    will iterate over the tree recursively from the top down, converting each AST
    node into instructions. [Figure 2-4](ch02.html#ruby_starts_the_compile_process_at_the_r
    "Figure 2-4. Ruby starts the compile process at the root of the AST.") shows how
    this works, beginning with `NODE_SCOPE`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby starts the compile process at the root of the AST.](httpatomoreillycomsourcenostarchimages1853905.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4. Ruby starts the compile process at the root of the AST.
  prefs: []
  type: TYPE_NORMAL
- en: '`NODE_SCOPE` tells the Ruby compiler that it is starting to compile a new *scope*,
    or section of Ruby code, which, in this case, is a whole new program. This scope
    is indicated on the right with an empty box. (The `table` and `args` values are
    both empty, so we’ll ignore them for now.)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Ruby compiler steps down the AST tree and encounters `NODE_FCALL`,
    as shown in [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "Figure 2-5. To
    compile a function call, Ruby first creates an instruction to push the receiver.").
  prefs: []
  type: TYPE_NORMAL
- en: '![To compile a function call, Ruby first creates an instruction to push the
    receiver.](httpatomoreillycomsourcenostarchimages1853907.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5. To compile a function call, Ruby first creates an instruction to
    push the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: '`NODE_FCALL` represents a *function call*—in this case, the call to `puts`.
    (Function and method calls are very important and very common in Ruby programs.)
    Ruby compiles function calls for YARV according to the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Push receiver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the method/function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "Figure 2-5. To
    compile a function call, Ruby first creates an instruction to push the receiver."),
    the Ruby compiler first creates a YARV instruction called `putself` to indicate
    that the function call uses the current value of the `self` pointer as the receiver.
    Because I call `puts` from the top-level scope—that is, the top section—of this
    simple script, `self` is set to point to the `top self` object. (The `top self`
    object is an instance of the `Object` class that is automatically created when
    Ruby starts up. One purpose of `top self` is to serve as the receiver for function
    calls like this one in the top-level scope.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In Ruby all functions are actually methods. That is, functions are always
    associated with a Ruby class; there is always a receiver. Inside of Ruby, however,
    Ruby’s parser and compiler distinguish between functions and methods: Method calls
    have an explicit receiver, while function calls assume the receiver is the current
    value of `self`*.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, Ruby needs to create instructions to push the arguments of the `puts`
    function call. But how? The argument to `puts` is `2+2`, which is the result of
    another method call. Although `2+2` is a simple expression, `puts` could instead
    be operating on some extremely complex Ruby expression involving many operators,
    method calls, and so on. How can Ruby know which instructions to create here?
  prefs: []
  type: TYPE_NORMAL
- en: The answer lies in the structure of the AST. By simply following the tree nodes
    down recursively, Ruby can take advantage of all the parser’s earlier work. In
    this case, it can now just step down to the `NODE_CALL` node, as shown in [Figure 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument
    to puts.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Next, Ruby writes instructions for calculating 2+2, the argument to puts.](httpatomoreillycomsourcenostarchimages1853909.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6. Next, Ruby writes instructions for calculating `2+2`, the argument
    to `puts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here Ruby will compile the `+` method call, which theoretically is the process
    of sending the `+` message to the `2` integer object. Again, following the same
    receiver, arguments, method call pattern, Ruby performs these actions in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a YARV instruction to push the receiver onto the stack (the object `2`
    in this case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a YARV instruction to push the argument or arguments onto the stack
    (again, `2` in this example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a method call YARV instruction `send <callinfo!mid:+, argc:1, ARGS_SKIP>`
    that means “send the + message” to the receiver, which is the object previously
    pushed onto the YARV stack (in this case, the first `Fixnum 2` object). `mid:+`
    means “method id = +” and is the name of the method we want to call. The `argc:1`
    parameter tells YARV there is one argument to this method call (the second `Fixnum
    2` object). `ARGS_SKIP` indicates the arguments are simple values (not blocks
    or arrays of unnamed arguments), allowing YARV to skip some work it would have
    to do otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Ruby executes the `send <callinfo!mid:+...` instruction it adds `2+2`,
    fetching those arguments from the stack, and leaves the result, `4`, as a new
    value on top of the stack. What’s fascinating about this is that YARV’s stack-oriented
    nature also helps Ruby compile the AST nodes more easily, as you can see when
    it finishes compiling the `NODE_FCALL`, as shown in [Figure 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi
    "Figure 2-7. Finally, Ruby can write an instruction for the call to puts.").
  prefs: []
  type: TYPE_NORMAL
- en: Now Ruby can assume that the return value of the `2+2` operation—that is, `4`—will
    be left at the top of the stack, just where it needs to be as the argument to
    the `puts` function call. Ruby’s stack-oriented virtual machine goes hand in hand
    with the way that it recursively compiles the AST nodes! As you can see at the
    right of [Figure 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi "Figure 2-7. Finally,
    Ruby can write an instruction for the call to puts."), Ruby has added the `send
    <callinfo!mid:puts, argc:1` instruction, which calls `puts` and indicates that
    there is one argument to `puts`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Finally, Ruby can write an instruction for the call to puts.](httpatomoreillycomsourcenostarchimages1853911.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7. Finally, Ruby can write an instruction for the call to `puts`.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Ruby further modifies these YARV instructions before executing
    them as part of an optimize step. One of its optimizations is to replace some
    YARV instructions with *specialized instructions*, which are YARV instructions
    that represent commonly used operations, such as `size`, `not`, `less than`, `greater
    than`, and so on. One such instruction, `opt_plus`, is used for adding two numbers
    together. During optimization, Ruby replaces `send <callinfo!mid:+...` with `opt_plus`,
    as shown in [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe "Figure 2-8. Ruby
    replaces some instructions with specialized instructions.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby replaces some instructions with specialized instructions.](httpatomoreillycomsourcenostarchimages1853913.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8. Ruby replaces some instructions with specialized instructions.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "Figure 2-8. Ruby replaces some instructions with specialized instructions."),
    Ruby also replaces the second `send` with `opt_send_simple`, which runs a bit
    faster when all of the arguments are simple values.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a Call to a Block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let’s compile my `10.times do` example from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)") in [Chapter 1](ch01.html
    "Chapter 1. Tokenization and Parsing") (see [Example 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2. A simple script that calls a block
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this example contains a block parameter to the `times` method. This
    is interesting because it will give us a chance to see how the Ruby compiler handles
    blocks. [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block") shows the AST for the `10.times
    do` example again, using the actual node names rather than the simplified output
    from Ripper.
  prefs: []
  type: TYPE_NORMAL
- en: '![The AST for the call to 10.times, passing a block](httpatomoreillycomsourcenostarchimages1853915.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9. The AST for the call to `10.times`, passing a block
  prefs: []
  type: TYPE_NORMAL
- en: This looks very different than `puts 2+2`, mostly because of the inner block
    shown at the right. (Ruby handles the inner block differently, as we’ll see shortly.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down how Ruby compiles the main portion of the script shown on the
    left of [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block"). As before, Ruby starts with the
    first `NODE_SCOPE` and creates a new snippet of YARV instructions, as shown in
    [Figure 2-10](ch02.html#each_nodeunderscorescope_is_compiled_int "Figure 2-10. Each
    NODE_SCOPE is compiled into a new snippet of YARV instructions.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Each NODE_SCOPE is compiled into a new snippet of YARV instructions.](httpatomoreillycomsourcenostarchimages1853917.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10. Each `NODE_SCOPE` is compiled into a new snippet of YARV instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, Ruby steps down the AST nodes to `NODE_ITER`, as shown in [Figure 2-11](ch02.html#ruby_stepping_through_an_ast
    "Figure 2-11. Ruby stepping through an AST").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby stepping through an AST](httpatomoreillycomsourcenostarchimages1853919.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-11. Ruby stepping through an AST
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, there is still no code generated, but notice in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block") that two arrows
    lead from `NODE_ITER`: one to `NODE_CALL`, which represents the `10.times` call,
    and another to the inner block. Ruby will first continue down the AST and compile
    the nodes corresponding to the `10.times` code. The resulting YARV code, following
    the same receiver-arguments-message pattern we saw in [Figure 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument
    to puts."), is shown in [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "Figure 2-12. Ruby compiles the 10.times method call.").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby compiles the 10.times method call.](httpatomoreillycomsourcenostarchimages1853921.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-12. Ruby compiles the `10.times` method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the new YARV instructions shown in [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "Figure 2-12. Ruby compiles the 10.times method call.") push the receiver (the
    integer object `10`) onto the stack first, after which Ruby generates an instruction
    to execute the `times` method call. But notice, too, the `block:block in <compiled>`
    argument in the `send` instruction. This indicates that the method call also contains
    a block argument: my `do |n| puts n end` block. In this example, `NODE_ITER` has
    caused the Ruby compiler to include this block argument because the AST above
    shows an arrow from `NODE_ITER` to the second `NODE_SCOPE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby continues by compiling the inner block, beginning with the second `NODE_SCOPE`
    shown at right in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block"). [Figure 2-13](ch02.html#branch_of_the_ast_for_the_contents_o
    "Figure 2-13. The branch of the AST for the contents of the block") shows what
    the AST for that inner block looks like.
  prefs: []
  type: TYPE_NORMAL
- en: This looks simple enough—just a single function call and a single argument `n`.
    But notice the value for `table` and `args` in `NODE_SCOPE`. These values were
    empty in the parent `NODE_SCOPE`, but they’re set here in the inner `NODE_SCOPE`.
    As you might guess, these values indicate the presence of the block parameter
    `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The branch of the AST for the contents of the block](httpatomoreillycomsourcenostarchimages1853923.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-13. The branch of the AST for the contents of the block
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that the Ruby parser created `NODE_DVAR` instead of `NODE_LIT`,
    which we saw earlier in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block"). This is the
    case because `n` is not just a literal string; it’s a block parameter passed in
    from the parent scope.
  prefs: []
  type: TYPE_NORMAL
- en: From a relatively high level, [Figure 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block
    "Figure 2-14. How Ruby compiles a call to a block") shows how Ruby compiles the
    inner block.
  prefs: []
  type: TYPE_NORMAL
- en: How Ruby Iterates Through the AST
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look more closely at how Ruby actually iterates through the AST structure,
    converting each node into YARV instructions. The MRI C source code file that implements
    the Ruby compiler is called *compile.c*. To learn how the code in *compile.c*
    works, we first look for the function `iseq_compile_each`. [Example 2-3](ch02.html#this_c_function_compiles_each_node_in_th
    "Example 2-3. This C function compiles each node in the AST.") shows the beginning
    of that function.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3. This C function compiles each node in the AST.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function is very long, with a very, very long `switch` statement that runs
    to thousands of lines! The `switch` statement branches based on the type of the
    current AST node and generates the corresponding YARV code. [Example 2-4](ch02.html#this_c_switch_statement_looks_at_the_typ
    "Example 2-4. This C switch statement looks at the type of each AST node.") shows
    the start of the `switch` statement ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4. This C `switch` statement looks at the type of each AST node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this statement, `node` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    is a parameter passed into `iseq_compile_each`, and `nd_type` is a C macro that
    returns the type from the given node structure.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll look at how Ruby compiles function or method call nodes into YARV
    instructions using the receiver-arguments-function call pattern. First, search
    *compile.c* for the C `case` statement shown in [Example 2-5](ch02.html#this_case_of_the_switch_compiles_method
    "Example 2-5. This case of the switch compiles method calls in your Ruby code.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5. This case of the switch compiles method calls in your Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`NODE_CALL` represents a real method call (like `10.times`), `NODE_FCALL` is
    a function call (like `puts`), and `NODE_VCALL` is a variable or function call.
    Skipping over some of the C code details (including the optional `SUPPORT_JOKE`
    code used for implementing the `goto` statement), [Example 2-6](ch02.html#this_c_code_compiles_the_receiver_value
    "Example 2-6. This C code compiles the receiver value for a method call.") shows
    what Ruby does next to compile these AST nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6. This C code compiles the receiver value for a method call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, Ruby calls either `COMPILE` or `ADD_CALL_RECEIVER` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of real method calls (like `NODE_CALL`), Ruby calls `COMPILE` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to recursively call into `iseq_compile_each` again, processing the next AST node
    down the tree that corresponds to the receiver of the method call or message.
    This will create YARV instructions to evaluate whatever expression was used to
    specify the target object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no receiver (`NODE_FCALL` or `NODE_VCALL`), Ruby calls `ADD_CALL_RECEIVER`
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), which creates a `putself`
    YARV instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, as shown in [Example 2-7](ch02.html#this_snippet_of_c_code_compiles_the_argu
    "Example 2-7. This snippet of C code compiles the arguments to every Ruby method
    call."), Ruby creates YARV instructions to push each argument of the method/function
    call onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7. This snippet of C code compiles the arguments to every Ruby method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For `NODE_CALL` and `NODE_FCALL`, Ruby calls into the `setup_args` function
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg), which will recursively
    call into `iseq_compile_each` again as needed in order to compile each argument
    to the method/function call. For `NODE_VCALL`, there are no arguments, so Ruby
    simply sets `argc` to 0 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Ruby creates YARV instructions to execute the actual method or function
    call, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This C macro will create the new `send` YARV instruction, which will cause the
    actual method call to occur when YARV executes it.
  prefs: []
  type: TYPE_NORMAL
- en: '![How Ruby compiles a call to a block](httpatomoreillycomsourcenostarchimages1853925.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-14. How Ruby compiles a call to a block
  prefs: []
  type: TYPE_NORMAL
- en: You can see the parent `NODE_SCOPE` at the top, along with the YARV code from
    [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call "Figure 2-12. Ruby
    compiles the 10.times method call."). Below that I’ve listed the YARV code compiled
    from the inner block’s AST.
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that Ruby compiles each distinct scope in your Ruby program—methods,
    blocks, classes, or modules, for example—into a separate snippet of YARV instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 2-1: Displaying YARV Instructions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One easy way to see how Ruby compiles your code is with the `RubyVM::InstructionSequence`
    object, which gives you access to Ruby’s YARV engine from your Ruby program! Like
    the Ripper tool, its use is very straightforward, as you can see in [Example 2-8](ch02.html#how_to_view_the_yarv_instructions_for_pu
    "Example 2-8. How to view the YARV instructions for puts 2+2").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8. How to view the YARV instructions for `puts 2+2`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The challenge lies in understanding what the output actually means. For example,
    [Example 2-9](ch02.html#yarv_instructions_for_puts_2plus2 "Example 2-9. The YARV
    instructions for puts 2+2") shows the output for `puts 2+2`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9. The YARV instructions for `puts 2+2`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in [Example 2-9](ch02.html#yarv_instructions_for_puts_2plus2
    "Example 2-9. The YARV instructions for puts 2+2"), the output contains all of
    the same instructions from [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir
    "Figure 2-5. To compile a function call, Ruby first creates an instruction to
    push the receiver.") to [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "Figure 2-8. Ruby replaces some instructions with specialized instructions.")
    and two new ones: `trace` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `leave` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). The `trace`
    instruction is used to implement the `set_trace_func` feature, which will call
    a given function for each Ruby statement executed in your program. The `leave`
    function is like a return statement. The line numbers on the left show the position
    of each instruction in the bytecode array that the compiler actually produces.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RubyVM::InstructionSequence` makes it easy to explore how Ruby compiles different
    Ruby scripts. For example, [Example 2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "Example 2-10. Displaying the YARV instructions for a call to a block") shows
    how to compile my `10.times do` example.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10. Displaying the YARV instructions for a call to a block
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output that I get now is shown below in [Example 2-11](ch02.html#yarv_instructions_for_a_call_to_a_bl
    "Example 2-11. The YARV instructions for a call to a block and for the block itself").
    Notice that the `send <callinfo!mid:times` YARV instruction shows `block:block
    in <compiled>` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), which
    indicates that I’m passing a block to the `10.times` method call.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11. The YARV instructions for a call to a block and for the block
    itself
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Ruby displays the two YARV instruction snippets separately.
    The first corresponds to the global scope ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and the second to the inner block scope ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The Local Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the "Figure 2-3. The
    AST Ruby produces after parsing the code in Example 2-1") through [Figure 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block
    "Figure 2-14. How Ruby compiles a call to a block"), you may have noticed that
    each `NODE_SCOPE` element in the AST contained information I labeled `table` and
    `args`. These values in the inner `NODE_SCOPE` structure contain information about
    the block’s parameter `n` (see [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby generated the information about this block parameter during the parsing
    process. As I discussed in [Chapter 1](ch01.html "Chapter 1. Tokenization and
    Parsing"), Ruby parses the block parameter along with the rest of my Ruby code
    using grammar rules. In fact, I showed the specific rule for parsing block parameters
    back in [Figure 1-30](ch01.html#entire_block_matches_the_braceunders "Figure 1-30. The
    entire block matches the brace_block rule."): `opt_block_param`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once Ruby’s compiler runs, however, the information about the block parameter
    is copied out of the AST and into another data structure called the *local table*,
    saved nearby the newly generated YARV instructions. Each snippet of YARV instructions,
    each scope in your Ruby program, has its own local table.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo "Figure 2-15. A
    snippet of YARV instructions with a local table") shows the local table attached
    to the YARV instructions that Ruby generated for the sample block code from [Example 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block").'
  prefs: []
  type: TYPE_NORMAL
- en: '![A snippet of YARV instructions with a local table](httpatomoreillycomsourcenostarchimages1853927.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-15. A snippet of YARV instructions with a local table
  prefs: []
  type: TYPE_NORMAL
- en: Notice on the right side of [Figure 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo
    "Figure 2-15. A snippet of YARV instructions with a local table") that Ruby has
    associated the number 2 with the block parameter `n`. As we’ll see in [Chapter 3](ch03.html
    "Chapter 3. How Ruby Executes Your Code"), the YARV instructions that refer to
    `n` will use this index 2\. The `getlocal` instruction is an example of this.
    The `<Arg>` notation indicates that this value is an argument to the block.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Ruby also saves information about local variables in this table,
    hence the name *local table*. [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari
    "Figure 2-16. This local table contains one local variable and two arguments.")
    shows the YARV instructions and local table Ruby will generate when compiling
    a method that uses one local variable and takes two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '![This local table contains one local variable and two arguments.](httpatomoreillycomsourcenostarchimages1853929.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-16. This local table contains one local variable and two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that Ruby lists all three values in the local table. As we’ll
    see in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"), Ruby treats
    local variables and method arguments in the same way. (Notice that the local variable
    `sum` does not have the `<Arg>` label.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of the local table as a key to help you understand what the YARV instructions
    do, similar to the legend on a map. As you can see in [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari
    "Figure 2-16. This local table contains one local variable and two arguments."),
    local variables have no label, but Ruby uses the following labels to describe
    different types of method and block arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`<Arg>`** | A standard method or block argument |'
  prefs: []
  type: TYPE_TB
- en: '| **`<Rest>`** | An array of unnamed arguments that are passed together using
    a splat (`*`) operator |'
  prefs: []
  type: TYPE_TB
- en: '| **`<Post>`** | A standard argument that appears after the splat array |'
  prefs: []
  type: TYPE_TB
- en: '| **`<Block>`** | A Ruby proc object that is passed using the `&` operator
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`<Opt=i>`** | A parameter defined with a default value. The integer value
    `i` is an index into a table that stores the actual default value. This table
    is stored along with the YARV snippet but not in the local table itself. |'
  prefs: []
  type: TYPE_TB
- en: Understanding the information displayed by the local table can help you understand
    how Ruby’s complex argument syntax works and how to take full advantage of the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand what I mean, let’s look at how Ruby compiles a method
    call that uses an array of unnamed arguments, as shown [Example 2-12](ch02.html#method_that_takes_standard_arguments_a
    "Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here `a`, `b`, and `c` are standard arguments, and `args` is an array of other
    arguments that appear between `b` and `c`. [Figure 2-17](ch02.html#ruby_saves_information_about_special_arg
    "Figure 2-17. Ruby saves information about special arguments in the local table.")
    shows how the local table saves all of this information.
  prefs: []
  type: TYPE_NORMAL
- en: As in [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari "Figure 2-16. This
    local table contains one local variable and two arguments."), `<Arg>` refers to
    a standard argument. But now Ruby uses `<Rest>` to indicate that value 3 contains
    the “rest” of the arguments and `<Post>` to indicate that value 2 contains the
    argument that appears after the unnamed array, the last one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby saves information about special arguments in the local table.](httpatomoreillycomsourcenostarchimages1853931.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-17. Ruby saves information about special arguments in the local table.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Optional Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you probably know, you can make an argument optional by specifying a default
    value for it in the argument list. Later, Ruby will use the default value if you
    don’t provide a value for that argument when you call the method or block. [Example 2-13](ch02.html#method_that_takes_an_optional_argument
    "Example 2-13. A method that takes an optional argument") shows a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13. A method that takes an optional argument
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you provide a value for `b`, the method will use that value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you don’t, Ruby will assign the default value of 5 to `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Ruby has a bit more work to do in this situation. Where does the default value
    go? Where does the Ruby compiler put it? [Figure 2-18](ch02.html#rubyapostrophes_compiler_generates_extra
    "Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.")
    shows how Ruby generates a few extra YARV instructions during the compile process
    that set the default value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby’s compiler generates extra code to handle optional arguments.](httpatomoreillycomsourcenostarchimages1853933.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby’s compiler generates the bolded YARV instructions, `putobject` and `setlocal`,
    to set the value of `b` to 5 when you call the method. (As we’ll see in [Chapter 3](ch03.html
    "Chapter 3. How Ruby Executes Your Code"), YARV will call these instructions if
    you don’t provide a value for `b` but skip them if you do.) You can also see that
    Ruby lists the optional argument `b` in the local table as `b<Opt=0>`. The `0`
    here is an index into a table that stores the default values for all the arguments.
    Ruby stores this data near the YARV snippet but not in the local table itself.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Keyword Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Ruby 2.0, we can specify a name along with a default value for each method
    or block argument. Arguments written this way are known as *keyword arguments*.
    For example, [Example 2-14](ch02.html#method_that_takes_a_keyword_argument "Example 2-14. A
    method that takes a keyword argument") shows the same argument `b` declared using
    Ruby 2.0’s new keyword argument syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14. A method that takes a keyword argument
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to provide a value for `b`, I need to use its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if I don’t specify `b` at all, Ruby will use the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How does Ruby compile keyword arguments? [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.") shows Ruby needs to add quite a bit of additional code to the method’s
    YARV snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Ruby compiler generates many more instructions to handle keyword arguments.](httpatomoreillycomsourcenostarchimages1853935.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ruby compiler generates all of the YARV instructions in bold—13 new instructions—to
    implement the keyword argument `b`. In [Chapter 3](ch03.html "Chapter 3. How Ruby
    Executes Your Code") and [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch"), I’ll cover how YARV works in detail and what these instructions
    actually mean, but for now, we can guess what’s going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: In the local table, we can see a new mystery value shown as `[ 3]?`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the left of [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments."), new YARV instructions call the `key?` and `delete` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Ruby class contains the `key?` and `delete` methods? The `Hash`. [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.") shows evidence that Ruby must implement keyword arguments using an
    internal, hidden hash object. All of these additional YARV instructions automatically
    add some logic to my method that checks this hash for the argument `b`. If Ruby
    finds the value of `b` in the hash, it uses it. If not, it uses the default value
    of 5\. The mystery element `[3]?` in the local table must be this hidden hash
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 2-2: Displaying the Local Table'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with YARV instructions, `RubyVM::InstructionSequence` will also display
    the local table associated with each YARV snippet or scope. Finding and understanding
    the local table for your code will help you to understand what the corresponding
    YARV instructions do. In this experiment, we’ll look at where the local table
    appears in the output generated by the `RubyVM::InstructionSequence` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-15](ch02.html#displaying_the_yarv_instructions-id00006 "Example 2-15. Displaying
    the YARV instructions for a call to a block") repeats [Example 2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "Example 2-10. Displaying the YARV instructions for a call to a block") from [Experiment
    2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15. Displaying the YARV instructions for a call to a block
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And [Example 2-16](ch02.html#along_with_the_yarv_instructionscomma_ru "Example 2-16. Along
    with the YARV instructions, RubyVM::InstructionSequence displays the local table.")
    repeats the output we saw earlier in [Experiment 2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-16. Along with the YARV instructions, `RubyVM::InstructionSequence`
    displays the local table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Just above the YARV snippet for the inner scope—the block—we see information
    about its local table at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    This displays the total size of the table (`size: 2`), the argument count (`argc:
    1`), and other information about the types of parameters (`opts: 0, rest: -1,
    post: 0`).'
  prefs: []
  type: TYPE_NORMAL
- en: The second line ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) shows
    the actual contents of the local table. In this example, we have just one argument,
    `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-17](ch02.html#this_method_uses_unnamed_arguments_with "Example 2-17. This
    method uses unnamed arguments with a splat operator.") shows how to use `RubyVM::InstructionSequence`
    in the same way to compile my unnamed arguments example from [Example 2-12](ch02.html#method_that_takes_standard_arguments_a
    "Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17. This method uses unnamed arguments with a splat operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And [Example 2-18](ch02.html#displaying_the_yarv_instructions-id00007 "Example 2-18. Displaying
    the YARV instructions for a call to a block") shows the output.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-18. Displaying the YARV instructions for a call to a block
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The top YARV scope, around ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    shows the instructions YARV uses to define a new method. Notice the call to `core#define_method`
    at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), an internal C function
    that YARV uses to create new Ruby methods. This corresponds to calling `def complex_formula`
    in my script. (I’ll discuss how Ruby implements methods in more detail in [Chapter 5](ch05.html
    "Chapter 5. Objects and Classes"), [Chapter 6](ch06.html "Chapter 6. Method Lookup
    and Constant Lookup"), and [Chapter 9](ch09.html "Chapter 9. Metaprogramming").)
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the local table for the lower YARV snippet at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
    This line now shows more information about the unnamed arguments (`rest: 2`) and
    the last standard argument following them (`post: 1`). Finally, the line at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    shows the contents of the local table that I showed back in [Figure 2-17](ch02.html#ruby_saves_information_about_special_arg
    "Figure 2-17. Ruby saves information about special arguments in the local table.").'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how Ruby compiles our code. You may think of Ruby
    as a dynamic scripting language, but, in fact, it uses a compiler just like C,
    Java, and many other programming languages. The obvious difference is that Ruby’s
    compiler runs automatically behind the scenes; you never need to worry about compiling
    your Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned that Ruby’s compiler works by iterating through the AST produced
    by the tokenizing and parsing processes, generating a series of bytecode instructions
    along the way. Ruby translates your code from Ruby into a language tailored for
    the YARV virtual machine, and it compiles every scope or section of your Ruby
    program into a different snippet or set of these YARV instructions. Every block,
    method, lambda, or other scope in your program has a corresponding set of bytecode
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also seen how Ruby handles different types of arguments. We were able
    to use the local table as a key or legend for understanding which YARV instructions
    accessed which arguments or local variables. And we saw how Ruby’s compiler generates
    additional, special YARV instructions to handle optional and keyword parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"), I’ll begin
    to explain how YARV executes the instructions produced by the compiler—that is,
    how YARV executes your Ruby program.
  prefs: []
  type: TYPE_NORMAL
