- en: Chapter 2. Compilation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：编译
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The code Ruby actually runs looks nothing like your original code.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Ruby 实际运行的代码与你原始的代码完全不同。*'
- en: Now that Ruby has tokenized and parsed your code, is it ready to run it? Will
    it finally get to work and iterate through the block 10 times in my simple `10.times
    do` example? If not, what else could Ruby possibly have to do first?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Ruby 已经对你的代码进行了词法分析和语法解析，它准备好运行了吗？它是否终于会在我的简单 `10.times do` 示例中迭代 10 次？如果没有，Ruby
    可能还需要做什么？
- en: Starting with version 1.9, Ruby compiles your code before executing it. The
    word *compile* means to translate your code from one programming language to another.
    Your programming language is easy for you to understand, while usually the target
    language is easy for the computer to understand.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.9 版本开始，Ruby 会在执行代码之前编译它。*编译*一词意味着将你的代码从一种编程语言转换为另一种语言。你的编程语言对你来说容易理解，而通常目标语言对计算机来说更容易理解。
- en: For example, when you compile a C program, the compiler translates C code to
    machine language, a language your computer’s microprocessor hardware understands.
    When you compile a Java program, the compiler translates Java code to Java bytecode,
    a language the Java Virtual Machine understands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你编译一个 C 程序时，编译器将 C 代码转换为机器语言，这是计算机的微处理器硬件能理解的语言。当你编译一个 Java 程序时，编译器将 Java
    代码转换为 Java 字节码，这是 Java 虚拟机能够理解的语言。
- en: Ruby’s compiler is no different. It translates your Ruby code into another language
    that Ruby’s virtual machine understands. The only difference is that you don’t
    use Ruby’s compiler directly; unlike in C or Java, Ruby’s compiler runs automatically
    without you ever knowing. Here in [Chapter 2](ch02.html "Chapter 2. Compilation"),
    I’ll explain how Ruby does this and what language it translates your code into.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的编译器也没有什么不同。它将你的 Ruby 代码转换为 Ruby 虚拟机能够理解的另一种语言。唯一的区别是你不会直接使用 Ruby 的编译器；不像
    C 或 Java，Ruby 的编译器会自动运行，你根本不会知道。在本章 [第 2 章](ch02.html "第 2 章：编译") 中，我将解释 Ruby
    是如何做到这一点的，以及它将你的代码转换为什么语言。
- en: Roadmap
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[No Compiler for Ruby 1.8](ch02.html#no_compiler_for_ruby_1dot8 "No Compiler
    for Ruby 1.8")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[没有 Ruby 1.8 的编译器](ch02.html#no_compiler_for_ruby_1dot8 "没有 Ruby 1.8 的编译器")'
- en: '[Ruby 1.9 and 2.0 Introduce a Compiler](ch02.html#ruby_1dot9_and_2dot0_introduce_a_compile
    "Ruby 1.9 and 2.0 Introduce a Compiler")'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 1.9 和 2.0 引入了编译器](ch02.html#ruby_1dot9_and_2dot0_introduce_a_compile
    "Ruby 1.9 和 2.0 引入了编译器")'
- en: '[How Ruby Compiles a Simple Script](ch02.html#how_ruby_compiles_a_simple_script
    "How Ruby Compiles a Simple Script")'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何编译一个简单脚本](ch02.html#how_ruby_compiles_a_simple_script "Ruby 如何编译一个简单脚本")'
- en: '[Compiling a Call to a Block](ch02.html#compiling_a_call_to_a_block "Compiling
    a Call to a Block")'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译对块的调用](ch02.html#compiling_a_call_to_a_block "编译对块的调用")'
- en: '[How Ruby Iterates Through the AST](ch02.html#how_ruby_iterates_through_the_ast
    "How Ruby Iterates Through the AST")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何遍历 AST](ch02.html#how_ruby_iterates_through_the_ast "Ruby 如何遍历 AST")'
- en: '**[Experiment 2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions")**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 2-1：显示 YARV 指令](ch02.html#experiment_2-1_displaying_yarv_instructi "实验
    2-1：显示 YARV 指令")**'
- en: '[The Local Table](ch02.html#local_table "The Local Table")'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[本地表](ch02.html#local_table "本地表")'
- en: '[Compiling Optional Arguments](ch02.html#compiling_optional_arguments "Compiling
    Optional Arguments")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译可选参数](ch02.html#compiling_optional_arguments "编译可选参数")'
- en: '[Compiling Keyword Arguments](ch02.html#compiling_keyword_arguments "Compiling
    Keyword Arguments")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编译关键字参数](ch02.html#compiling_keyword_arguments "编译关键字参数")'
- en: '**[Experiment 2-2: Displaying the Local Table](ch02.html#experiment_2-2_displaying_the_local_tabl
    "Experiment 2-2: Displaying the Local Table")**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 2-2：显示本地表](ch02.html#experiment_2-2_displaying_the_local_tabl "实验 2-2：显示本地表")**'
- en: '[Summary](ch02.html#summary-id00008 "Summary")'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch02.html#summary-id00008 "总结")'
- en: No Compiler for Ruby 1.8
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有 Ruby 1.8 的编译器
- en: The Ruby core team introduced a compiler with version 1.9\. Ruby 1.8 and earlier
    versions of Ruby don’t contain a compiler. Instead, Ruby 1.8 immediately executes
    your code after the tokenizing and parsing processes are finished. It does this
    by walking through the nodes in the AST tree and executing each one. [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.")
    shows another way of looking at the Ruby 1.8 tokenizing and parsing processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 核心团队在版本 1.9 中引入了编译器。Ruby 1.8 及更早版本不包含编译器。相反，Ruby 1.8 会在标记化和解析过程完成后立即执行代码。它通过遍历
    AST 树中的节点并执行每个节点来实现这一点。[图 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "图 2-1. 在 Ruby 1.8 中，您的代码被转换为 AST 节点，然后被解释执行。")展示了另一种看待 Ruby 1.8 标记化和解析过程的方式。
- en: 'The top of [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.")
    shows your Ruby code. Below this are the different internal formats Ruby converts
    your Ruby code into. These are the tokens and AST nodes we saw in [Chapter 1](ch01.html
    "Chapter 1. Tokenization and Parsing")—the different forms your code takes when
    you run it using Ruby. The lower section of the diagram shows the code the Ruby
    core team wrote: the C source code for the Ruby language and the machine language
    it is converted into by the C compiler.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte "图 2-1. 在 Ruby 1.8
    中，您的代码被转换为 AST 节点，然后被解释执行。") 的顶部显示了您的 Ruby 代码。其下是 Ruby 将您的 Ruby 代码转换成的不同内部格式。这些就是我们在[第
    1 章](ch01.html "第 1 章. 标记化和解析")中看到的标记和 AST 节点——当您使用 Ruby 运行代码时，代码所呈现的不同形式。图表的下半部分展示了
    Ruby 核心团队编写的代码：Ruby 语言的 C 源代码，以及 C 编译器将其转换成的机器语言。'
- en: '![In Ruby 1.8, your code is converted into AST nodes and then interpreted.](httpatomoreillycomsourcenostarchimages1853899.png.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![在 Ruby 1.8 中，您的代码被转换为 AST 节点，然后被解释执行。](httpatomoreillycomsourcenostarchimages1853899.png.jpg)'
- en: Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1. 在 Ruby 1.8 中，您的代码被转换为 AST 节点，然后被解释执行。
- en: The dotted line between the two code sections indicates that Ruby interprets
    your code. The Ruby C code, the lower section, reads and executes your code, the
    top section. Ruby 1.8 doesn’t compile or translate your code into any form beyond
    AST nodes. After converting it into AST nodes, it proceeds to iterate over the
    nodes in the AST, taking whatever action each node represents as it executes each
    node.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个代码部分之间的虚线表示 Ruby 会解释您的代码。Ruby 的 C 代码（下半部分）读取并执行您的代码（上半部分）。Ruby 1.8 不会将您的代码编译或转换为
    AST 节点之外的任何形式。在将其转换为 AST 节点后，它会继续遍历 AST 中的节点，按每个节点所代表的操作执行。
- en: The gap in the middle of the diagram shows that your code is never completely
    compiled into machine language. If you were to disassemble and inspect the machine
    language that your CPU actually runs, you would not see instructions that directly
    map to your original Ruby code. Instead, you would find instructions that tokenize,
    parse, and execute your code, or, in other words, that implement the Ruby interpreter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中间的空隙表明，您的代码从未完全编译成机器语言。如果您反汇编并检查 CPU 实际运行的机器语言，您将看不到直接映射到您原始 Ruby 代码的指令。相反，您会发现执行代码的指令，这些指令会进行标记化、解析和执行，换句话说，它们实现了
    Ruby 解释器。
- en: Ruby 1.9 and 2.0 Introduce a Compiler
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 1.9 和 2.0 引入了编译器
- en: If you’ve upgraded to Ruby 1.9 or 2.0, Ruby is still not quite ready to run
    your code. It needs to compile it first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经升级到 Ruby 1.9 或 2.0，Ruby 仍然无法直接运行您的代码。它首先需要编译代码。
- en: With Ruby 1.9, Koichi Sasada and the Ruby core team introduced Yet Another Ruby
    Virtual Machine (YARV), which actually executes your Ruby code. At a high level,
    this is the same idea behind the Java Virtual Machine (JVM) used by Java and many
    other languages. (I’ll cover YARV in more detail in [Chapter 3](ch03.html "Chapter 3. How
    Ruby Executes Your Code") and [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch").)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.9 中，Koichi Sasada 和 Ruby 核心团队引入了“另一个 Ruby 虚拟机”（YARV），它实际上执行您的 Ruby
    代码。从高层次上看，这与 Java 虚拟机（JVM）的概念相同，JVM 被 Java 和许多其他语言所使用。（我将在[第 3 章](ch03.html "第
    3 章. Ruby 如何执行您的代码")和[第 4 章](ch04.html "第 4 章. 控制结构与方法调用")中更详细地介绍 YARV。）
- en: 'When using YARV (as with the JVM), you first compile your code into *bytecode*,
    a series of low-level instructions that the virtual machine understands. The only
    differences between YARV and the JVM are the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 YARV 时（与 JVM 类似），你首先将代码编译成*字节码*，即虚拟机可以理解的一系列低级指令。YARV 和 JVM 之间的唯一区别如下：
- en: Ruby doesn’t expose the compiler to you as a separate tool. Instead, it automatically
    compiles your Ruby code into bytecode instructions internally.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 并没有将编译器作为一个独立的工具暴露给你。相反，它会自动将你的 Ruby 代码在内部编译成字节码指令。
- en: Ruby never compiles your Ruby code all the way to machine language. As you can
    see in [Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "Figure 2-2. Ruby
    1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them."),
    Ruby interprets the bytecode instructions. The JVM, on the other hand, can compile
    some of the bytecode instructions all the way into machine language using its
    “hotspot” or just-in-time (JIT) compiler.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 永远不会将你的 Ruby 代码完全编译成机器语言。正如你在[图 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod
    "图 2-2. Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令")中看到的那样，Ruby 会解释字节码指令。而 JVM 则可以通过其“热点”或即时编译器（JIT）将一些字节码指令编译成机器语言。
- en: '[Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "Figure 2-2. Ruby
    1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them.")
    shows how Ruby 1.9 and 2.0 handle your code.'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[图 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod "图 2-2. Ruby 1.9
    和 2.0 在解释之前会将 AST 节点编译成 YARV 指令")展示了 Ruby 1.9 和 2.0 如何处理你的代码。'
- en: Notice that this time, unlike in the process shown in [Figure 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte
    "Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted."),
    your code is translated into a third format. After parsing the tokens and producing
    the AST, Ruby 1.9 and 2.0 continue to compile your code into a series of low-level
    instructions called *YARV instructions*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次不同于[图 2-1](ch02.html#in_ruby_1dot8comma_your_code_is_converte "图 2-1.
    在 Ruby 1.8 中，你的代码首先被转换成 AST 节点然后被解释")中展示的过程，你的代码被转换成了第三种格式。在解析完符号并生成 AST 后，Ruby
    1.9 和 2.0 会继续将代码编译成一系列低级指令，称为*YARV 指令*。
- en: 'The primary reason for using YARV is speed: Ruby 1.9 and 2.0 run much faster
    than Ruby 1.8 due to the use of YARV instructions. Like Ruby 1.8, YARV is an interpreter—just
    a faster one. Your Ruby code ultimately is still not converted directly into machine
    language by Ruby 1.9 or 2.0\. There is still a gap in [Figure 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod
    "Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before
    interpreting them.") between the YARV instructions and Ruby’s C code.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 YARV 的主要原因是速度：由于采用了 YARV 指令，Ruby 1.9 和 2.0 比 Ruby 1.8 运行得要快得多。像 Ruby 1.8
    一样，YARV 是一个解释器——只不过是一个更快的解释器。最终，Ruby 1.9 或 2.0 依然不会直接将你的 Ruby 代码转换成机器语言。[图 2-2](ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod
    "图 2-2. Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令")中，YARV 指令和 Ruby 的 C 代码之间仍然存在差距。
- en: '![Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting
    them.](httpatomoreillycomsourcenostarchimages1853901.png.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令。](httpatomoreillycomsourcenostarchimages1853901.png.jpg)'
- en: Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before
    interpreting them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2. Ruby 1.9 和 2.0 在解释之前会将 AST 节点编译成 YARV 指令。
- en: How Ruby Compiles a Simple Script
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 如何编译一个简单的脚本
- en: 'In this section, we’ll look at the last step along your code’s journey through
    Ruby: how Ruby compiles your code into the instructions that YARV expects. Let’s
    explore how Ruby’s compiler works by stepping through an example compilation.
    [Example 2-1](ch02.html#one-line_ruby_program_we_will_compile "Example 2-1. A
    one-line Ruby program we will compile as an example") shows a simple Ruby script
    that calculates 2 + 2 = 4.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看代码在 Ruby 中执行的最后一步：Ruby 如何将你的代码编译成 YARV 所期望的指令。通过一个编译的示例，我们来探索 Ruby
    编译器的工作原理。[示例 2-1](ch02.html#one-line_ruby_program_we_will_compile "示例 2-1. 我们将编译的一个简单
    Ruby 程序")展示了一个简单的 Ruby 脚本，它计算了 2 + 2 = 4。
- en: Example 2-1. A one-line Ruby program we will compile as an example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-1. 我们将编译的一个简单 Ruby 程序
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the "Figure 2-3. The
    AST Ruby produces after parsing the code in Example 2-1") shows the AST structure
    that Ruby will create after tokenizing and parsing this simple program. (This
    is a more detailed view of the AST than you would get from the Ripper tool that
    we saw in [Experiment 1-2: Using Ripper to Parse Different Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "Experiment 1-2: Using Ripper to Parse Different Ruby Scripts").)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](ch02.html#ast_ruby_produces_after_parsing_the "图 2-3. Ruby 在解析 [示例
    2-1](ch02.html#one-line_ruby_program_we_will_compile) 代码后生成的 AST") 展示了 Ruby 在对这个简单程序进行词法分析和解析后生成的
    AST 结构。（这比我们在[实验 1-2: 使用 Ripper 解析不同的 Ruby 脚本](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "实验 1-2: 使用 Ripper 解析不同的 Ruby 脚本")中看到的 Ripper 工具所呈现的 AST 更为详细。）'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The technical names shown in [Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the
    "Figure 2-3. The AST Ruby produces after parsing the code in Example 2-1") (*`NODE_SCOPE`*,
    *`NODE_FCALL`*, and so on) are taken from the actual Ruby C source code. To keep
    things simple, I’m omitting some AST nodes—specifically, ones that represent arrays
    of the arguments to each method call, which in this simple example would be arrays
    of only one element.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 2-3](ch02.html#ast_ruby_produces_after_parsing_the "图 2-3. Ruby 在解析 [示例
    2-1](ch02.html#one-line_ruby_program_we_will_compile) 代码后生成的 AST") 中显示的技术名称（*`NODE_SCOPE`*，*`NODE_FCALL`*
    等）来自实际的 Ruby C 源代码。为了简化起见，我省略了一些 AST 节点——特别是那些表示每个方法调用的参数数组的节点，在这个简单的例子中，这些数组只有一个元素。*'
- en: '![The AST Ruby produces after parsing the code in](httpatomoreillycomsourcenostarchimages1853903.png.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 解析代码后生成的 AST](httpatomoreillycomsourcenostarchimages1853903.png.jpg)'
- en: Figure 2-3. The AST Ruby produces after parsing the code in [Example 2-1](ch02.html#one-line_ruby_program_we_will_compile
    "Example 2-1. A one-line Ruby program we will compile as an example")
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3. Ruby 在解析 [示例 2-1](ch02.html#one-line_ruby_program_we_will_compile "示例
    2-1. 一个我们将编译的 Ruby 单行程序") 代码后生成的 AST。
- en: 'Before we cover the details of how Ruby compiles the `puts 2+2` script, let’s
    look at one very important attribute of YARV: It’s a *stack-oriented virtual machine*.
    That means when YARV executes your code, it maintains a stack of values—mainly
    arguments and return values for the YARV instructions. (I’ll explain this in more
    detail in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code").) Most
    of YARV’s instructions either push values onto the stack or operate on the values
    that they find on the stack, leaving a result value on the stack as well.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细讲解 Ruby 如何编译 `puts 2+2` 脚本之前，让我们先看一下 YARV 的一个非常重要的特性：它是一个 *栈导向虚拟机*。这意味着，当
    YARV 执行你的代码时，它会维护一个值的栈——主要是 YARV 指令的参数和返回值。（我将在[第 3 章](ch03.html "第 3 章. Ruby
    如何执行你的代码")中详细解释这个问题。）YARV 的大多数指令要么将值推入栈中，要么操作栈中的值，最终将结果值保留在栈中。
- en: In order to compile the `puts 2+2` AST structure into YARV instructions, Ruby
    will iterate over the tree recursively from the top down, converting each AST
    node into instructions. [Figure 2-4](ch02.html#ruby_starts_the_compile_process_at_the_r
    "Figure 2-4. Ruby starts the compile process at the root of the AST.") shows how
    this works, beginning with `NODE_SCOPE`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `puts 2+2` 的 AST 结构编译成 YARV 指令，Ruby 将从上到下递归遍历树，将每个 AST 节点转换为指令。[图 2-4](ch02.html#ruby_starts_the_compile_process_at_the_r
    "图 2-4. Ruby 从 AST 的根开始编译过程") 展示了这个过程，从 `NODE_SCOPE` 开始。
- en: '![Ruby starts the compile process at the root of the AST.](httpatomoreillycomsourcenostarchimages1853905.png.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 从 AST 的根开始编译过程](httpatomoreillycomsourcenostarchimages1853905.png.jpg)'
- en: Figure 2-4. Ruby starts the compile process at the root of the AST.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4. Ruby 从 AST 的根开始编译过程。
- en: '`NODE_SCOPE` tells the Ruby compiler that it is starting to compile a new *scope*,
    or section of Ruby code, which, in this case, is a whole new program. This scope
    is indicated on the right with an empty box. (The `table` and `args` values are
    both empty, so we’ll ignore them for now.)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_SCOPE` 告诉 Ruby 编译器，它开始编译一个新的 *作用域*，或一段 Ruby 代码，在这个例子中是一个全新的程序。右侧的空框表示该作用域。（`table`
    和 `args` 值都为空，所以我们暂时忽略它们。）'
- en: Next, the Ruby compiler steps down the AST tree and encounters `NODE_FCALL`,
    as shown in [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "Figure 2-5. To
    compile a function call, Ruby first creates an instruction to push the receiver.").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 编译器会沿着 AST 树向下，遇到 `NODE_FCALL`，如[图 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir
    "图 2-5. 为了编译函数调用，Ruby 首先创建一个指令来推送接收者")所示。
- en: '![To compile a function call, Ruby first creates an instruction to push the
    receiver.](httpatomoreillycomsourcenostarchimages1853907.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![为了编译一个函数调用，Ruby 首先创建一个指令将接收者推入栈中。](httpatomoreillycomsourcenostarchimages1853907.png.jpg)'
- en: Figure 2-5. To compile a function call, Ruby first creates an instruction to
    push the receiver.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5. 为了编译一个函数调用，Ruby 首先创建一个指令将接收者推入栈中。
- en: '`NODE_FCALL` represents a *function call*—in this case, the call to `puts`.
    (Function and method calls are very important and very common in Ruby programs.)
    Ruby compiles function calls for YARV according to the following pattern:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_FCALL` 表示一个*函数调用*——在这个例子中，就是调用 `puts`。（函数和方法调用在 Ruby 程序中非常重要，也非常常见。）Ruby
    按照以下模式为 YARV 编译函数调用：'
- en: Push receiver.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推入接收者。
- en: Push arguments.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推入参数。
- en: Call the method/function.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法/函数。
- en: In [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "Figure 2-5. To
    compile a function call, Ruby first creates an instruction to push the receiver."),
    the Ruby compiler first creates a YARV instruction called `putself` to indicate
    that the function call uses the current value of the `self` pointer as the receiver.
    Because I call `puts` from the top-level scope—that is, the top section—of this
    simple script, `self` is set to point to the `top self` object. (The `top self`
    object is an instance of the `Object` class that is automatically created when
    Ruby starts up. One purpose of `top self` is to serve as the receiver for function
    calls like this one in the top-level scope.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir "图 2-5. 为了编译一个函数调用，Ruby
    首先创建一个指令将接收者推入栈中。")中，Ruby 编译器首先创建了一个名为 `putself` 的 YARV 指令，表示该函数调用使用当前 `self`
    指针的值作为接收者。由于我在该简单脚本的顶层作用域中调用了 `puts`，也就是说在顶层部分，`self` 被设置为指向 `top self` 对象。(`top
    self` 对象是一个 `Object` 类的实例，它在 Ruby 启动时自动创建。`top self` 的一个作用是作为顶层作用域中类似这种函数调用的接收者。)
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In Ruby all functions are actually methods. That is, functions are always
    associated with a Ruby class; there is always a receiver. Inside of Ruby, however,
    Ruby’s parser and compiler distinguish between functions and methods: Method calls
    have an explicit receiver, while function calls assume the receiver is the current
    value of `self`*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Ruby 中，所有函数实际上都是方法。也就是说，函数总是与 Ruby 类关联；总会有一个接收者。然而，在 Ruby 内部，Ruby 的解析器和编译器区分函数和方法：方法调用有显式的接收者，而函数调用则假定接收者是当前的
    `self` 值。*'
- en: Next, Ruby needs to create instructions to push the arguments of the `puts`
    function call. But how? The argument to `puts` is `2+2`, which is the result of
    another method call. Although `2+2` is a simple expression, `puts` could instead
    be operating on some extremely complex Ruby expression involving many operators,
    method calls, and so on. How can Ruby know which instructions to create here?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 需要创建指令将 `puts` 函数调用的参数推入栈中。但是，如何做到这一点呢？`puts` 的参数是 `2+2`，它是另一个方法调用的结果。尽管
    `2+2` 是一个简单的表达式，`puts` 也可能是在处理一个非常复杂的 Ruby 表达式，涉及许多运算符、方法调用等。那么，Ruby 如何知道在这里创建哪些指令呢？
- en: The answer lies in the structure of the AST. By simply following the tree nodes
    down recursively, Ruby can take advantage of all the parser’s earlier work. In
    this case, it can now just step down to the `NODE_CALL` node, as shown in [Figure 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument
    to puts.").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在 AST（抽象语法树）的结构中。通过递归地向下遍历树节点，Ruby 可以利用解析器之前的工作。在这种情况下，Ruby 现在只需一步步下到 `NODE_CALL`
    节点，如[图 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c "图 2-6. 接下来，Ruby
    编写计算 2+2 的指令，作为 `puts` 的参数。")所示。
- en: '![Next, Ruby writes instructions for calculating 2+2, the argument to puts.](httpatomoreillycomsourcenostarchimages1853909.png.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![接下来，Ruby 编写计算 2+2 的指令，作为 `puts` 的参数。](httpatomoreillycomsourcenostarchimages1853909.png.jpg)'
- en: Figure 2-6. Next, Ruby writes instructions for calculating `2+2`, the argument
    to `puts`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-6. 接下来，Ruby 编写计算 `2+2` 的指令，作为 `puts` 的参数。
- en: 'Here Ruby will compile the `+` method call, which theoretically is the process
    of sending the `+` message to the `2` integer object. Again, following the same
    receiver, arguments, method call pattern, Ruby performs these actions in order:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 Ruby 将编译 `+` 方法调用，理论上这就是将 `+` 消息发送给 `2` 这个整数对象的过程。同样，按照接收者、参数、方法调用的模式，Ruby
    按顺序执行以下操作：
- en: Creates a YARV instruction to push the receiver onto the stack (the object `2`
    in this case).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 YARV 指令，将接收者（在此例中为对象`2`）推入栈中。
- en: Creates a YARV instruction to push the argument or arguments onto the stack
    (again, `2` in this example).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 YARV 指令，将参数或参数们推入栈中（在此例中是 `2`）。
- en: Creates a method call YARV instruction `send <callinfo!mid:+, argc:1, ARGS_SKIP>`
    that means “send the + message” to the receiver, which is the object previously
    pushed onto the YARV stack (in this case, the first `Fixnum 2` object). `mid:+`
    means “method id = +” and is the name of the method we want to call. The `argc:1`
    parameter tells YARV there is one argument to this method call (the second `Fixnum
    2` object). `ARGS_SKIP` indicates the arguments are simple values (not blocks
    or arrays of unnamed arguments), allowing YARV to skip some work it would have
    to do otherwise.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法调用 YARV 指令 `send <callinfo!mid:+, argc:1, ARGS_SKIP>`，这意味着“发送 + 消息”给接收者，也就是之前被推入
    YARV 栈中的对象（在此例中为第一个 `Fixnum 2` 对象）。`mid:+` 表示“方法 ID = +”，是我们想调用的方法的名称。`argc:1`
    参数告诉 YARV 该方法调用有一个参数（第二个 `Fixnum 2` 对象）。`ARGS_SKIP` 表示参数是简单值（而非块或未命名参数的数组），允许
    YARV 跳过一些原本需要做的工作。
- en: When Ruby executes the `send <callinfo!mid:+...` instruction it adds `2+2`,
    fetching those arguments from the stack, and leaves the result, `4`, as a new
    value on top of the stack. What’s fascinating about this is that YARV’s stack-oriented
    nature also helps Ruby compile the AST nodes more easily, as you can see when
    it finishes compiling the `NODE_FCALL`, as shown in [Figure 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi
    "Figure 2-7. Finally, Ruby can write an instruction for the call to puts.").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 执行 `send <callinfo!mid:+...` 指令时，它会将 `2+2` 相加，从栈中获取这些参数，并将结果 `4` 留在栈顶作为一个新值。令人着迷的是，YARV
    的栈导向特性也有助于 Ruby 更容易地编译 AST 节点，正如你在编译完 `NODE_FCALL` 时看到的那样，如[图 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi
    "图 2-7. 最终，Ruby 可以为调用 puts 写一条指令.")所示。
- en: Now Ruby can assume that the return value of the `2+2` operation—that is, `4`—will
    be left at the top of the stack, just where it needs to be as the argument to
    the `puts` function call. Ruby’s stack-oriented virtual machine goes hand in hand
    with the way that it recursively compiles the AST nodes! As you can see at the
    right of [Figure 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi "Figure 2-7. Finally,
    Ruby can write an instruction for the call to puts."), Ruby has added the `send
    <callinfo!mid:puts, argc:1` instruction, which calls `puts` and indicates that
    there is one argument to `puts`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ruby 可以假设 `2+2` 操作的返回值——也就是 `4`——将留在栈顶，正好作为 `puts` 函数调用的参数。Ruby 的栈导向虚拟机与它递归编译
    AST 节点的方式相得益彰！正如你在[图 2-7](ch02.html#finallycomma_ruby_can_write_an_instructi "图
    2-7. 最终，Ruby 可以为调用 puts 写一条指令.")右侧所看到的，Ruby 已经添加了 `send <callinfo!mid:puts, argc:1`
    指令，该指令调用 `puts` 并表示 `puts` 有一个参数。
- en: '![Finally, Ruby can write an instruction for the call to puts.](httpatomoreillycomsourcenostarchimages1853911.png.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![最终，Ruby 可以为调用 puts 写一条指令。](httpatomoreillycomsourcenostarchimages1853911.png.jpg)'
- en: Figure 2-7. Finally, Ruby can write an instruction for the call to `puts`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7. 最终，Ruby 可以为调用 `puts` 写一条指令。
- en: As it turns out, Ruby further modifies these YARV instructions before executing
    them as part of an optimize step. One of its optimizations is to replace some
    YARV instructions with *specialized instructions*, which are YARV instructions
    that represent commonly used operations, such as `size`, `not`, `less than`, `greater
    than`, and so on. One such instruction, `opt_plus`, is used for adding two numbers
    together. During optimization, Ruby replaces `send <callinfo!mid:+...` with `opt_plus`,
    as shown in [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe "Figure 2-8. Ruby
    replaces some instructions with specialized instructions.").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，Ruby 在执行这些 YARV 指令之前，会进一步修改它们作为优化步骤的一部分。它的一项优化是用*专用指令*替换一些 YARV 指令，专用指令是代表常用操作的
    YARV 指令，比如`size`、`not`、`less than`、`greater than`等。其中一条指令，`opt_plus`，用于将两个数字相加。在优化过程中，Ruby
    会将 `send <callinfo!mid:+...` 替换为 `opt_plus`，如[图 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "图 2-8. Ruby 用专用指令替换一些指令.")所示。
- en: '![Ruby replaces some instructions with specialized instructions.](httpatomoreillycomsourcenostarchimages1853913.png.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 用专用指令替换一些指令。](httpatomoreillycomsourcenostarchimages1853913.png.jpg)'
- en: Figure 2-8. Ruby replaces some instructions with specialized instructions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8. Ruby 用专用指令替换一些指令。
- en: As you can see in [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "Figure 2-8. Ruby replaces some instructions with specialized instructions."),
    Ruby also replaces the second `send` with `opt_send_simple`, which runs a bit
    faster when all of the arguments are simple values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 2-8](ch02.html#ruby_replaces_some_instructions_with_spe "Figure 2-8.
    Ruby replaces some instructions with specialized instructions.")中看到的，Ruby 还将第二个
    `send` 替换为 `opt_send_simple`，当所有参数都是简单值时，它运行得更快。
- en: Compiling a Call to a Block
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译调用块
- en: Next, let’s compile my `10.times do` example from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)") in [Chapter 1](ch01.html
    "Chapter 1. Tokenization and Parsing") (see [Example 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block")).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编译我在[示例 1-1](ch01.html#very_simple_ruby_program_left_parenthe "Example
    1-1. A very simple Ruby program (simple.rb)")中给出的 `10.times do` 示例，位于[第 1 章](ch01.html
    "Chapter 1. Tokenization and Parsing")（参见[示例 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block")）。
- en: Example 2-2. A simple script that calls a block
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-2. 一个简单的调用块的脚本
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that this example contains a block parameter to the `times` method. This
    is interesting because it will give us a chance to see how the Ruby compiler handles
    blocks. [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block") shows the AST for the `10.times
    do` example again, using the actual node names rather than the simplified output
    from Ripper.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个示例包含了传递给 `times` 方法的块参数。这很有趣，因为它将让我们有机会看看 Ruby 编译器如何处理块。[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block")再次显示了 `10.times
    do` 示例的 AST，使用实际的节点名称，而不是 Ripper 简化的输出。
- en: '![The AST for the call to 10.times, passing a block](httpatomoreillycomsourcenostarchimages1853915.png.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![调用 10.times 时传递块的 AST](httpatomoreillycomsourcenostarchimages1853915.png.jpg)'
- en: Figure 2-9. The AST for the call to `10.times`, passing a block
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-9. 调用 `10.times` 时传递块的 AST
- en: This looks very different than `puts 2+2`, mostly because of the inner block
    shown at the right. (Ruby handles the inner block differently, as we’ll see shortly.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与 `puts 2+2` 非常不同，主要是因为右侧显示的内部块。（Ruby 对内部块的处理方式不同，稍后我们会看到。）
- en: Let’s break down how Ruby compiles the main portion of the script shown on the
    left of [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block"). As before, Ruby starts with the
    first `NODE_SCOPE` and creates a new snippet of YARV instructions, as shown in
    [Figure 2-10](ch02.html#each_nodeunderscorescope_is_compiled_int "Figure 2-10. Each
    NODE_SCOPE is compiled into a new snippet of YARV instructions.").
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下 Ruby 如何编译位于左侧的[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block")所示的脚本的主要部分。如同之前一样，Ruby
    从第一个 `NODE_SCOPE` 开始，并创建一个新的 YARV 指令片段，如[图 2-10](ch02.html#each_nodeunderscorescope_is_compiled_int
    "Figure 2-10. Each NODE_SCOPE is compiled into a new snippet of YARV instructions.")所示。
- en: '![Each NODE_SCOPE is compiled into a new snippet of YARV instructions.](httpatomoreillycomsourcenostarchimages1853917.png.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![每个 NODE_SCOPE 都被编译成一个新的 YARV 指令片段。](httpatomoreillycomsourcenostarchimages1853917.png.jpg)'
- en: Figure 2-10. Each `NODE_SCOPE` is compiled into a new snippet of YARV instructions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-10. 每个 `NODE_SCOPE` 都被编译成一个新的 YARV 指令片段。
- en: Next, Ruby steps down the AST nodes to `NODE_ITER`, as shown in [Figure 2-11](ch02.html#ruby_stepping_through_an_ast
    "Figure 2-11. Ruby stepping through an AST").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 继续遍历 AST 节点，直到 `NODE_ITER`，如[图 2-11](ch02.html#ruby_stepping_through_an_ast
    "Figure 2-11. Ruby stepping through an AST")所示。
- en: '![Ruby stepping through an AST](httpatomoreillycomsourcenostarchimages1853919.png.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 遍历 AST](httpatomoreillycomsourcenostarchimages1853919.png.jpg)'
- en: Figure 2-11. Ruby stepping through an AST
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-11. Ruby 遍历 AST
- en: 'At this point, there is still no code generated, but notice in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block") that two arrows
    lead from `NODE_ITER`: one to `NODE_CALL`, which represents the `10.times` call,
    and another to the inner block. Ruby will first continue down the AST and compile
    the nodes corresponding to the `10.times` code. The resulting YARV code, following
    the same receiver-arguments-message pattern we saw in [Figure 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument
    to puts."), is shown in [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "Figure 2-12. Ruby compiles the 10.times method call.").'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，仍然没有生成代码，但请注意在[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "图 2-9.
    调用 10.times 时的 AST，传递一个块")中，两条箭头从 `NODE_ITER` 指向：一条指向 `NODE_CALL`，表示 `10.times`
    调用，另一条指向内部块。Ruby 将首先继续沿着 AST 向下编译与 `10.times` 代码对应的节点。生成的 YARV 代码遵循我们在[图 2-6](ch02.html#nextcomma_ruby_writes_instructions_for_c
    "图 2-6. 接下来，Ruby 为计算 2+2 写入指令")中看到的相同的接收者-参数-消息模式，并在[图 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "图 2-12. Ruby 编译 10.times 方法调用")中显示。
- en: '![Ruby compiles the 10.times method call.](httpatomoreillycomsourcenostarchimages1853921.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 编译 10.times 方法调用](httpatomoreillycomsourcenostarchimages1853921.png.jpg)'
- en: Figure 2-12. Ruby compiles the `10.times` method call.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-12. Ruby 编译 `10.times` 方法调用
- en: 'Notice that the new YARV instructions shown in [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call
    "Figure 2-12. Ruby compiles the 10.times method call.") push the receiver (the
    integer object `10`) onto the stack first, after which Ruby generates an instruction
    to execute the `times` method call. But notice, too, the `block:block in <compiled>`
    argument in the `send` instruction. This indicates that the method call also contains
    a block argument: my `do |n| puts n end` block. In this example, `NODE_ITER` has
    caused the Ruby compiler to include this block argument because the AST above
    shows an arrow from `NODE_ITER` to the second `NODE_SCOPE`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call "图 2-12. Ruby
    编译 10.times 方法调用")中显示的新 YARV 指令，首先将接收者（整数对象 `10`）压入栈中，然后 Ruby 生成一条指令来执行 `times`
    方法调用。但同样要注意的是，`send` 指令中的 `block:block in <compiled>` 参数。这表明该方法调用还包含一个块参数：我的 `do
    |n| puts n end` 块。在这个例子中，`NODE_ITER` 导致 Ruby 编译器包含了这个块参数，因为上面的 AST 显示了从 `NODE_ITER`
    到第二个 `NODE_SCOPE` 的箭头。
- en: Ruby continues by compiling the inner block, beginning with the second `NODE_SCOPE`
    shown at right in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma "Figure 2-9. The
    AST for the call to 10.times, passing a block"). [Figure 2-13](ch02.html#branch_of_the_ast_for_the_contents_o
    "Figure 2-13. The branch of the AST for the contents of the block") shows what
    the AST for that inner block looks like.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 继续编译内部块，从右侧的第二个 `NODE_SCOPE` 开始，正如在[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "图 2-9. 调用 10.times 时的 AST，传递一个块")中所示。[图 2-13](ch02.html#branch_of_the_ast_for_the_contents_o
    "图 2-13. AST 分支，表示块的内容") 显示了内部块对应的 AST 结构。
- en: This looks simple enough—just a single function call and a single argument `n`.
    But notice the value for `table` and `args` in `NODE_SCOPE`. These values were
    empty in the parent `NODE_SCOPE`, but they’re set here in the inner `NODE_SCOPE`.
    As you might guess, these values indicate the presence of the block parameter
    `n`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单——只有一个函数调用和一个单一的参数 `n`。但请注意 `NODE_SCOPE` 中 `table` 和 `args` 的值。这些值在父
    `NODE_SCOPE` 中是空的，但在内部的 `NODE_SCOPE` 中被设置了。正如你所猜测的，这些值表明了块参数 `n` 的存在。
- en: '![The branch of the AST for the contents of the block](httpatomoreillycomsourcenostarchimages1853923.png.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![AST 分支，表示块的内容](httpatomoreillycomsourcenostarchimages1853923.png.jpg)'
- en: Figure 2-13. The branch of the AST for the contents of the block
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-13. AST 分支，表示块的内容
- en: Also notice that the Ruby parser created `NODE_DVAR` instead of `NODE_LIT`,
    which we saw earlier in [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block"). This is the
    case because `n` is not just a literal string; it’s a block parameter passed in
    from the parent scope.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，Ruby 解析器创建了 `NODE_DVAR` 而不是我们在[图 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "图 2-9. 调用 10.times 时的 AST，传递一个块")中看到的 `NODE_LIT`。这是因为 `n` 不仅仅是一个字面量字符串；它是一个从父作用域传递过来的块参数。
- en: From a relatively high level, [Figure 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block
    "Figure 2-14. How Ruby compiles a call to a block") shows how Ruby compiles the
    inner block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: How Ruby Iterates Through the AST
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look more closely at how Ruby actually iterates through the AST structure,
    converting each node into YARV instructions. The MRI C source code file that implements
    the Ruby compiler is called *compile.c*. To learn how the code in *compile.c*
    works, we first look for the function `iseq_compile_each`. [Example 2-3](ch02.html#this_c_function_compiles_each_node_in_th
    "Example 2-3. This C function compiles each node in the AST.") shows the beginning
    of that function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3. This C function compiles each node in the AST.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is very long, with a very, very long `switch` statement that runs
    to thousands of lines! The `switch` statement branches based on the type of the
    current AST node and generates the corresponding YARV code. [Example 2-4](ch02.html#this_c_switch_statement_looks_at_the_typ
    "Example 2-4. This C switch statement looks at the type of each AST node.") shows
    the start of the `switch` statement ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4. This C `switch` statement looks at the type of each AST node.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this statement, `node` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    is a parameter passed into `iseq_compile_each`, and `nd_type` is a C macro that
    returns the type from the given node structure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll look at how Ruby compiles function or method call nodes into YARV
    instructions using the receiver-arguments-function call pattern. First, search
    *compile.c* for the C `case` statement shown in [Example 2-5](ch02.html#this_case_of_the_switch_compiles_method
    "Example 2-5. This case of the switch compiles method calls in your Ruby code.").
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5. This case of the switch compiles method calls in your Ruby code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`NODE_CALL` represents a real method call (like `10.times`), `NODE_FCALL` is
    a function call (like `puts`), and `NODE_VCALL` is a variable or function call.
    Skipping over some of the C code details (including the optional `SUPPORT_JOKE`
    code used for implementing the `goto` statement), [Example 2-6](ch02.html#this_c_code_compiles_the_receiver_value
    "Example 2-6. This C code compiles the receiver value for a method call.") shows
    what Ruby does next to compile these AST nodes.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6. This C code compiles the receiver value for a method call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, Ruby calls either `COMPILE` or `ADD_CALL_RECEIVER` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In the case of real method calls (like `NODE_CALL`), Ruby calls `COMPILE` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to recursively call into `iseq_compile_each` again, processing the next AST node
    down the tree that corresponds to the receiver of the method call or message.
    This will create YARV instructions to evaluate whatever expression was used to
    specify the target object.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no receiver (`NODE_FCALL` or `NODE_VCALL`), Ruby calls `ADD_CALL_RECEIVER`
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), which creates a `putself`
    YARV instruction.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, as shown in [Example 2-7](ch02.html#this_snippet_of_c_code_compiles_the_argu
    "Example 2-7. This snippet of C code compiles the arguments to every Ruby method
    call."), Ruby creates YARV instructions to push each argument of the method/function
    call onto the stack.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7. This snippet of C code compiles the arguments to every Ruby method
    call.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For `NODE_CALL` and `NODE_FCALL`, Ruby calls into the `setup_args` function
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg), which will recursively
    call into `iseq_compile_each` again as needed in order to compile each argument
    to the method/function call. For `NODE_VCALL`, there are no arguments, so Ruby
    simply sets `argc` to 0 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Ruby creates YARV instructions to execute the actual method or function
    call, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This C macro will create the new `send` YARV instruction, which will cause the
    actual method call to occur when YARV executes it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![How Ruby compiles a call to a block](httpatomoreillycomsourcenostarchimages1853925.png.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 2-14. How Ruby compiles a call to a block
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You can see the parent `NODE_SCOPE` at the top, along with the YARV code from
    [Figure 2-12](ch02.html#ruby_compiles_the_10dottimes_method_call "Figure 2-12. Ruby
    compiles the 10.times method call."). Below that I’ve listed the YARV code compiled
    from the inner block’s AST.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that Ruby compiles each distinct scope in your Ruby program—methods,
    blocks, classes, or modules, for example—into a separate snippet of YARV instructions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 2-1: Displaying YARV Instructions'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One easy way to see how Ruby compiles your code is with the `RubyVM::InstructionSequence`
    object, which gives you access to Ruby’s YARV engine from your Ruby program! Like
    the Ripper tool, its use is very straightforward, as you can see in [Example 2-8](ch02.html#how_to_view_the_yarv_instructions_for_pu
    "Example 2-8. How to view the YARV instructions for puts 2+2").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8. How to view the YARV instructions for `puts 2+2`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The challenge lies in understanding what the output actually means. For example,
    [Example 2-9](ch02.html#yarv_instructions_for_puts_2plus2 "Example 2-9. The YARV
    instructions for puts 2+2") shows the output for `puts 2+2`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9. The YARV instructions for `puts 2+2`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in [Example 2-9](ch02.html#yarv_instructions_for_puts_2plus2
    "Example 2-9. The YARV instructions for puts 2+2"), the output contains all of
    the same instructions from [Figure 2-5](ch02.html#to_compile_a_function_callcomma_ruby_fir
    "Figure 2-5. To compile a function call, Ruby first creates an instruction to
    push the receiver.") to [Figure 2-8](ch02.html#ruby_replaces_some_instructions_with_spe
    "Figure 2-8. Ruby replaces some instructions with specialized instructions.")
    and two new ones: `trace` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `leave` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). The `trace`
    instruction is used to implement the `set_trace_func` feature, which will call
    a given function for each Ruby statement executed in your program. The `leave`
    function is like a return statement. The line numbers on the left show the position
    of each instruction in the bytecode array that the compiler actually produces.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`RubyVM::InstructionSequence` makes it easy to explore how Ruby compiles different
    Ruby scripts. For example, [Example 2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "Example 2-10. Displaying the YARV instructions for a call to a block") shows
    how to compile my `10.times do` example.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10. Displaying the YARV instructions for a call to a block
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output that I get now is shown below in [Example 2-11](ch02.html#yarv_instructions_for_a_call_to_a_bl
    "Example 2-11. The YARV instructions for a call to a block and for the block itself").
    Notice that the `send <callinfo!mid:times` YARV instruction shows `block:block
    in <compiled>` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), which
    indicates that I’m passing a block to the `10.times` method call.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11. The YARV instructions for a call to a block and for the block
    itself
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, Ruby displays the two YARV instruction snippets separately.
    The first corresponds to the global scope ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and the second to the inner block scope ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The Local Table
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Figure 2-3](ch02.html#ast_ruby_produces_after_parsing_the "Figure 2-3. The
    AST Ruby produces after parsing the code in Example 2-1") through [Figure 2-14](ch02.html#how_ruby_compiles_a_call_to_a_block
    "Figure 2-14. How Ruby compiles a call to a block"), you may have noticed that
    each `NODE_SCOPE` element in the AST contained information I labeled `table` and
    `args`. These values in the inner `NODE_SCOPE` structure contain information about
    the block’s parameter `n` (see [Figure 2-9](ch02.html#ast_for_the_call_to_10dottimescomma
    "Figure 2-9. The AST for the call to 10.times, passing a block")).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby generated the information about this block parameter during the parsing
    process. As I discussed in [Chapter 1](ch01.html "Chapter 1. Tokenization and
    Parsing"), Ruby parses the block parameter along with the rest of my Ruby code
    using grammar rules. In fact, I showed the specific rule for parsing block parameters
    back in [Figure 1-30](ch01.html#entire_block_matches_the_braceunders "Figure 1-30. The
    entire block matches the brace_block rule."): `opt_block_param`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Once Ruby’s compiler runs, however, the information about the block parameter
    is copied out of the AST and into another data structure called the *local table*,
    saved nearby the newly generated YARV instructions. Each snippet of YARV instructions,
    each scope in your Ruby program, has its own local table.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo "Figure 2-15. A
    snippet of YARV instructions with a local table") shows the local table attached
    to the YARV instructions that Ruby generated for the sample block code from [Example 2-2](ch02.html#simple_script_that_calls_a_block
    "Example 2-2. A simple script that calls a block").'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![A snippet of YARV instructions with a local table](httpatomoreillycomsourcenostarchimages1853927.png.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Figure 2-15. A snippet of YARV instructions with a local table
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Notice on the right side of [Figure 2-15](ch02.html#snippet_of_yarv_instructions_with_a_lo
    "Figure 2-15. A snippet of YARV instructions with a local table") that Ruby has
    associated the number 2 with the block parameter `n`. As we’ll see in [Chapter 3](ch03.html
    "Chapter 3. How Ruby Executes Your Code"), the YARV instructions that refer to
    `n` will use this index 2\. The `getlocal` instruction is an example of this.
    The `<Arg>` notation indicates that this value is an argument to the block.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, Ruby also saves information about local variables in this table,
    hence the name *local table*. [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari
    "Figure 2-16. This local table contains one local variable and two arguments.")
    shows the YARV instructions and local table Ruby will generate when compiling
    a method that uses one local variable and takes two arguments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![This local table contains one local variable and two arguments.](httpatomoreillycomsourcenostarchimages1853929.png.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: Figure 2-16. This local table contains one local variable and two arguments.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that Ruby lists all three values in the local table. As we’ll
    see in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"), Ruby treats
    local variables and method arguments in the same way. (Notice that the local variable
    `sum` does not have the `<Arg>` label.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of the local table as a key to help you understand what the YARV instructions
    do, similar to the legend on a map. As you can see in [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari
    "Figure 2-16. This local table contains one local variable and two arguments."),
    local variables have no label, but Ruby uses the following labels to describe
    different types of method and block arguments:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '| **`<Arg>`** | A standard method or block argument |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| **`<Rest>`** | An array of unnamed arguments that are passed together using
    a splat (`*`) operator |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| **`<Post>`** | A standard argument that appears after the splat array |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| **`<Block>`** | A Ruby proc object that is passed using the `&` operator
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| **`<Opt=i>`** | A parameter defined with a default value. The integer value
    `i` is an index into a table that stores the actual default value. This table
    is stored along with the YARV snippet but not in the local table itself. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: Understanding the information displayed by the local table can help you understand
    how Ruby’s complex argument syntax works and how to take full advantage of the
    language.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand what I mean, let’s look at how Ruby compiles a method
    call that uses an array of unnamed arguments, as shown [Example 2-12](ch02.html#method_that_takes_standard_arguments_a
    "Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments").
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here `a`, `b`, and `c` are standard arguments, and `args` is an array of other
    arguments that appear between `b` and `c`. [Figure 2-17](ch02.html#ruby_saves_information_about_special_arg
    "Figure 2-17. Ruby saves information about special arguments in the local table.")
    shows how the local table saves all of this information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: As in [Figure 2-16](ch02.html#this_local_table_contains_one_local_vari "Figure 2-16. This
    local table contains one local variable and two arguments."), `<Arg>` refers to
    a standard argument. But now Ruby uses `<Rest>` to indicate that value 3 contains
    the “rest” of the arguments and `<Post>` to indicate that value 2 contains the
    argument that appears after the unnamed array, the last one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby saves information about special arguments in the local table.](httpatomoreillycomsourcenostarchimages1853931.png.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: Figure 2-17. Ruby saves information about special arguments in the local table.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Optional Arguments
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you probably know, you can make an argument optional by specifying a default
    value for it in the argument list. Later, Ruby will use the default value if you
    don’t provide a value for that argument when you call the method or block. [Example 2-13](ch02.html#method_that_takes_an_optional_argument
    "Example 2-13. A method that takes an optional argument") shows a simple example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13. A method that takes an optional argument
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you provide a value for `b`, the method will use that value as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But if you don’t, Ruby will assign the default value of 5 to `b`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ruby has a bit more work to do in this situation. Where does the default value
    go? Where does the Ruby compiler put it? [Figure 2-18](ch02.html#rubyapostrophes_compiler_generates_extra
    "Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.")
    shows how Ruby generates a few extra YARV instructions during the compile process
    that set the default value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby’s compiler generates extra code to handle optional arguments.](httpatomoreillycomsourcenostarchimages1853933.png.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Ruby’s compiler generates the bolded YARV instructions, `putobject` and `setlocal`,
    to set the value of `b` to 5 when you call the method. (As we’ll see in [Chapter 3](ch03.html
    "Chapter 3. How Ruby Executes Your Code"), YARV will call these instructions if
    you don’t provide a value for `b` but skip them if you do.) You can also see that
    Ruby lists the optional argument `b` in the local table as `b<Opt=0>`. The `0`
    here is an index into a table that stores the default values for all the arguments.
    Ruby stores this data near the YARV snippet but not in the local table itself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Keyword Arguments
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Ruby 2.0, we can specify a name along with a default value for each method
    or block argument. Arguments written this way are known as *keyword arguments*.
    For example, [Example 2-14](ch02.html#method_that_takes_a_keyword_argument "Example 2-14. A
    method that takes a keyword argument") shows the same argument `b` declared using
    Ruby 2.0’s new keyword argument syntax.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14. A method that takes a keyword argument
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now to provide a value for `b`, I need to use its name:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, if I don’t specify `b` at all, Ruby will use the default value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How does Ruby compile keyword arguments? [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.") shows Ruby needs to add quite a bit of additional code to the method’s
    YARV snippet.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![The Ruby compiler generates many more instructions to handle keyword arguments.](httpatomoreillycomsourcenostarchimages1853935.png.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ruby compiler generates all of the YARV instructions in bold—13 new instructions—to
    implement the keyword argument `b`. In [Chapter 3](ch03.html "Chapter 3. How Ruby
    Executes Your Code") and [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch"), I’ll cover how YARV works in detail and what these instructions
    actually mean, but for now, we can guess what’s going on here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In the local table, we can see a new mystery value shown as `[ 3]?`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the left of [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments."), new YARV instructions call the `key?` and `delete` methods.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Ruby class contains the `key?` and `delete` methods? The `Hash`. [Figure 2-19](ch02.html#ruby_compiler_generates_many_more_in
    "Figure 2-19. The Ruby compiler generates many more instructions to handle keyword
    arguments.") shows evidence that Ruby must implement keyword arguments using an
    internal, hidden hash object. All of these additional YARV instructions automatically
    add some logic to my method that checks this hash for the argument `b`. If Ruby
    finds the value of `b` in the hash, it uses it. If not, it uses the default value
    of 5\. The mystery element `[3]?` in the local table must be this hidden hash
    object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 2-2: Displaying the Local Table'
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with YARV instructions, `RubyVM::InstructionSequence` will also display
    the local table associated with each YARV snippet or scope. Finding and understanding
    the local table for your code will help you to understand what the corresponding
    YARV instructions do. In this experiment, we’ll look at where the local table
    appears in the output generated by the `RubyVM::InstructionSequence` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-15](ch02.html#displaying_the_yarv_instructions-id00006 "Example 2-15. Displaying
    the YARV instructions for a call to a block") repeats [Example 2-10](ch02.html#displaying_the_yarv_instructions_for_a_c
    "Example 2-10. Displaying the YARV instructions for a call to a block") from [Experiment
    2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions").'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15. Displaying the YARV instructions for a call to a block
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And [Example 2-16](ch02.html#along_with_the_yarv_instructionscomma_ru "Example 2-16. Along
    with the YARV instructions, RubyVM::InstructionSequence displays the local table.")
    repeats the output we saw earlier in [Experiment 2-1: Displaying YARV Instructions](ch02.html#experiment_2-1_displaying_yarv_instructi
    "Experiment 2-1: Displaying YARV Instructions").'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-16. Along with the YARV instructions, `RubyVM::InstructionSequence`
    displays the local table.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just above the YARV snippet for the inner scope—the block—we see information
    about its local table at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    This displays the total size of the table (`size: 2`), the argument count (`argc:
    1`), and other information about the types of parameters (`opts: 0, rest: -1,
    post: 0`).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The second line ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) shows
    the actual contents of the local table. In this example, we have just one argument,
    `n`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-17](ch02.html#this_method_uses_unnamed_arguments_with "Example 2-17. This
    method uses unnamed arguments with a splat operator.") shows how to use `RubyVM::InstructionSequence`
    in the same way to compile my unnamed arguments example from [Example 2-12](ch02.html#method_that_takes_standard_arguments_a
    "Example 2-12. A method that takes standard arguments and an array of unnamed
    arguments").'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17. This method uses unnamed arguments with a splat operator.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And [Example 2-18](ch02.html#displaying_the_yarv_instructions-id00007 "Example 2-18. Displaying
    the YARV instructions for a call to a block") shows the output.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-18. Displaying the YARV instructions for a call to a block
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The top YARV scope, around ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    shows the instructions YARV uses to define a new method. Notice the call to `core#define_method`
    at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), an internal C function
    that YARV uses to create new Ruby methods. This corresponds to calling `def complex_formula`
    in my script. (I’ll discuss how Ruby implements methods in more detail in [Chapter 5](ch05.html
    "Chapter 5. Objects and Classes"), [Chapter 6](ch06.html "Chapter 6. Method Lookup
    and Constant Lookup"), and [Chapter 9](ch09.html "Chapter 9. Metaprogramming").)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the local table for the lower YARV snippet at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
    This line now shows more information about the unnamed arguments (`rest: 2`) and
    the last standard argument following them (`post: 1`). Finally, the line at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    shows the contents of the local table that I showed back in [Figure 2-17](ch02.html#ruby_saves_information_about_special_arg
    "Figure 2-17. Ruby saves information about special arguments in the local table.").'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how Ruby compiles our code. You may think of Ruby
    as a dynamic scripting language, but, in fact, it uses a compiler just like C,
    Java, and many other programming languages. The obvious difference is that Ruby’s
    compiler runs automatically behind the scenes; you never need to worry about compiling
    your Ruby code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned that Ruby’s compiler works by iterating through the AST produced
    by the tokenizing and parsing processes, generating a series of bytecode instructions
    along the way. Ruby translates your code from Ruby into a language tailored for
    the YARV virtual machine, and it compiles every scope or section of your Ruby
    program into a different snippet or set of these YARV instructions. Every block,
    method, lambda, or other scope in your program has a corresponding set of bytecode
    instructions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also seen how Ruby handles different types of arguments. We were able
    to use the local table as a key or legend for understanding which YARV instructions
    accessed which arguments or local variables. And we saw how Ruby’s compiler generates
    additional, special YARV instructions to handle optional and keyword parameters.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"), I’ll begin
    to explain how YARV executes the instructions produced by the compiler—that is,
    how YARV executes your Ruby program.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
