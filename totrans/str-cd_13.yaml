- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BRAINFUCK
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: '*Brainfuck*, or *BF* as we’ll call it, is more or less the grandfather of all
    esolangs. It’s one of the earliest and probably the most extended, modified, discussed,
    and parodied esolang in existence. In this chapter, we’ll see what all the fuss
    is about it—there’s more to it than just the name!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**WTF Is BF?**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BF is the brainchild of Urban Müller, who loosed it upon an unsuspecting world
    in 1993\. His goal was to create a tiny language leading to a tiny compiler for
    the Amiga computer. His compiler was 296 bytes long. Later in the chapter, we’ll
    encounter a BF compiler that’s only 166 bytes long.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: How can BF compilers be so tiny? Because BF itself is tiny (see [Table 10-1](ch10.xhtml#ch010tab1),
    which describes all *eight* commands). As a certain pig might say, “Th-th-that’s
    all, folks!”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** BF in All Its Glory'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Action** |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: '| `>` | Increment memory pointer |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| `<` | Decrement memory pointer |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| `.` | Print memory as a character |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| `,` | Input a character to memory |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| `+` | Increment memory |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| `-` | Decrement memory |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `[` | Begin loop if memory not 0 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `]` | Continue loop if memory not 0 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: The machine BF expects is quite similar to a Turing machine. The BF machine
    is a vector of cells, each of which holds a single value. Originally, there were
    30,000 cells, each capable of holding a single byte [0, 255]. The interpreters
    we’ll use in this chapter have 32-bit cells. BF is analogous to what’s called
    a *Harvard architecture*, a hardware architecture in which the program space and
    memory are distinct. There’s no self-modifying code here, though I wouldn’t be
    surprised if someone has created a von Neumann version of BF just to explore what
    self-modifying BF code might be able to accomplish. Recall that a von Neumann
    architecture combines program space and memory. Modern PCs are von Neumann machines.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: A Turing machine has a tape head that moves along a tape to read and write symbols.
    BF does the same, but in this case we’ll call the “tape head” a memory or cell
    pointer. The `>` and `<` instructions move the memory pointer from cell to cell
    and the remaining BF instructions operate on the current memory cell. When a BF
    program starts, it assumes each memory cell has a value of 0 and the pointer is
    looking at cell 0.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We now know what two of BF’s eight instructions do. The comma (`,`) and period
    (`.`) are input and output, respectively. The `+` increments the cell and `-`
    decrements it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'What makes BF interesting as a language are the `[` and `]` loop instructions.
    Loops begin with `[` and end with `]`, but both are commands. When BF executes
    the `[` instruction, it looks at the current cell and asks: “Is the value 0?”
    If the answer is “yes,” BF skips ahead to the `]` instruction and continues with
    the instruction after it. If the answer is “no,” BF moves to the next instruction
    to begin the loop.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: When BF encounters a `]` instruction, it doesn’t automatically jump to the corresponding
    `[`. Instead, it examines the *current* memory cell and jumps back if that cell
    *isn’t* 0\. Otherwise, the loop ends and BF continues with the next instruction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当 BF 遇到 `]` 指令时，它不会自动跳转到对应的 `[ `。相反，它会检查 *当前* 的内存单元格，如果该单元格 *不是* 0，它就跳回去。否则，循环结束，BF
    继续执行下一个指令。
- en: 'Think about this for a bit. The `[` command is a gatekeeper that decides whether
    a loop begins, but it doesn’t check anything after that. The decision about continuing
    a loop falls to the matching `]` instruction. Also, the cell that initiated the
    loop need not be the cell that decides whether the loop continues. BF is very
    flexible when it comes to looping, as we might expect from such a provocatively
    named language—it’s messing with our brains. BF loops are neither top-tested nor
    bottom-tested, but rather are a mix of both. There is a top test to decide whether
    the loop even begins, but from then on, the loop is bottom-tested. In C, we can
    accomplish something similar by nesting loops:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下这个问题。`[` 指令是一个门控，它决定循环是否开始，但它之后不会再检查任何事情。决定是否继续循环的责任落在匹配的 `]` 指令上。而且，启动循环的单元格不一定是决定循环是否继续的单元格。BF
    在循环方面非常灵活，正如我们从这种具有挑衅性的名称中可以预见的那样——它在挑战我们的思维。BF 循环既不是顶部测试也不是底部测试，而是两者的混合。存在一个顶部测试来决定循环是否开始，但从那时起，循环是底部测试的。在
    C 中，我们可以通过嵌套循环来实现类似的效果：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To begin the loop, `cond1` must be true. However, after `cond1` begins the loop,
    it isn’t examined again; the loop runs until `cond2` is no longer true. To get
    the desired effect in C, `cond1` must be made false (`cond1 = 0`), so the entire
    structure exits when `cond2` becomes false.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始循环，`cond1` 必须为真。然而，在 `cond1` 开始循环后，它不会再被检查；循环会一直执行，直到 `cond2` 不再为真。为了在 C
    中实现所需的效果，`cond1` 必须被设为假（`cond1 = 0`），这样整个结构在 `cond2` 变为假时会退出。
- en: BF code isn’t particularly easy to write, but it is complete enough to implement
    interesting, nontrivial programs. BF is more than ABC. We need an interpreter
    to see that’s the case; we’ll leave compiler design for another day.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: BF 代码写起来并不特别容易，但它足够完整，可以实现有趣的、非平凡的程序。BF 不仅仅是简单的 ABC。我们需要一个解释器来验证这一点；编译器设计我们可以留到另一天讨论。
- en: '**The Two Implementations**'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**两个实现**'
- en: BF implementations abound. Let’s investigate two in this section. The first
    is a slightly updated version of Urban Müller’s original 1993 C code for the Amiga
    computer. The second we’ll build from scratch in SNOBOL because an unusual, minimalist
    esoteric language deserves an equally unusual implementation. If you skipped [Chapter
    5](ch05.xhtml#ch05) on SNOBOL, now’s a good time to go back and read it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: BF 实现层出不穷。让我们在本节中探讨两个实现。第一个是 Urban Müller 于 1993 年为 Amiga 计算机编写的原始 C 代码的稍微更新版本。第二个我们将在
    SNOBOL 中从零开始构建，因为这种不寻常的、极简的晦涩语言值得一个同样不寻常的实现。如果你跳过了[第五章](ch05.xhtml#ch05)中的 SNOBOL
    内容，现在是时候回去阅读了。
- en: '***The Original***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原版***'
- en: The original Amiga LHA archive with the first version of BF is in the file *brainf-2.lha*.
    Müller’s implementation is in plain C. To work with the code on a modern Linux
    system, I took the liberty of updating it to compile without warnings, changed
    the cell size from 8 bits (`unsigned char`) to 32 bits (`int`), and increased
    the program space to 70,000 cells. Using 32-bit cells matches the SNOBOL implementation
    we’ll develop in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 Amiga LHA 压缩包包含了第一版 BF 的代码，文件名为 *brainf-2.lha*。Müller 的实现是用纯 C 编写的。为了在现代
    Linux 系统上使用该代码，我自行更新了它，使其能够无警告地编译，将单元格大小从 8 位（`unsigned char`）改为 32 位（`int`），并将程序空间增加到
    70,000 个单元格。使用 32 位单元格与我们将在下一节中开发的 SNOBOL 实现相匹配。
- en: '[Listing 10-1](ch10.xhtml#ch010list1) shows the interpreter in its entirety.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](ch10.xhtml#ch010list1) 显示了完整的解释器代码。'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: Urban Müller’s original BF interpreter (updated)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：Urban Müller 的原始 BF 解释器（更新版）*'
- en: This implementation is quite compact and handles loops via recursion (notice
    the recursive call to `interpret` ➊). Our SNOBOL implementation will process loops
    without recursion. Also, notice that `#` is a supported command. It prints basic
    debugging information if the interpreter is called with a second command line
    argument. The `#` command was dropped from later versions of BF. My modifications
    introduce `MAXMEM` and `MAXPROG` and the addition of `int` before `main` to avoid
    a `gcc` warning.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现非常紧凑，并通过递归处理循环（注意 `interpret` 的递归调用 ➊）。我们的 SNOBOL 实现将通过非递归方式处理循环。另外，注意到
    `#` 是一个受支持的命令。如果解释器被调用并传递第二个命令行参数，`#` 命令会打印基本的调试信息。后来版本的 BF 中已经去掉了 `#` 命令。我的修改引入了
    `MAXMEM` 和 `MAXPROG`，并在 `main` 前添加了 `int`，以避免 `gcc` 警告。
- en: The interpreter processes the input BF program loaded into `f`. The `interpret`
    function loops over the characters in `f`, or the characters of the nested loop
    enclosed in brackets via the recursive call. If the character is a BF command,
    the command is performed; otherwise, it is ignored.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器处理加载到 `f` 中的输入 BF 程序。`interpret` 函数循环遍历 `f` 中的字符，或者通过递归调用遍历括号中的嵌套循环字符。如果字符是
    BF 命令，则执行该命令；否则，忽略它。
- en: 'Building the interpreter is straightforward:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 构建解释器是直接的：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So is testing it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试它的过程如下：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the BF examples in the book’s GitHub repository work with this interpreter.
    However, not every BF example you’ll find on the web does. Take a look at the
    *README* file in the *examples* directory, as it contains attribution and license
    information. Credit is given to code authors where authorship is known. I’ll leave
    working through the operation of *hello.b* as an exercise, as there are explanatory
    comments in the file. As you might expect, it involves generating and printing
    the required sequence of ASCII values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的所有 BF 示例都可以与这个解释器一起使用。然而，并非所有你在网上找到的 BF 示例都能兼容。查看 *README* 文件，它位于
    *examples* 目录中，因为它包含了归属和许可证信息。如果已知作者身份，代码作者会得到相应的署名。我将让你自行完成 *hello.b* 文件的操作过程，因为文件中已经有了解释性注释。如你所料，它涉及到生成并打印所需的
    ASCII 值序列。
- en: '***SNOBOL Meets BF***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SNOBOL 与 BF 的结合***'
- en: 'The seductive elegance of BF requires, indeed, almost demands that we make
    our own interpreter. We’ll use SNOBOL because SNOBOL provides all the facilities
    we need. Besides, it’s fun. The full interpreter is in *bf.sno*. Let’s begin with
    the parser:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: BF 的诱人优雅确实几乎要求我们自己编写解释器。我们将使用 SNOBOL，因为 SNOBOL 提供了我们所需的所有功能。此外，它很有趣。完整的解释器在
    *bf.sno* 中。我们从解析器开始：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-2: Parsing the input file*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-2: 解析输入文件*'
- en: '[Listing 10-2](ch10.xhtml#ch010list2) presents global memory definitions and
    the `parse` function to read the input file and keep only actual program commands.
    Code is stored in the array `prog` with memory in `mem`, a second array. BF expects
    memory to be initialized to 0, which SNOBOL does for us via the second argument
    to `array` ➊. We’ll discuss the `jump` table momentarily.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-2](ch10.xhtml#ch010list2) 展示了全局内存定义和 `parse` 函数，用来读取输入文件并仅保留有效的程序命令。代码存储在数组
    `prog` 中，内存存储在第二个数组 `mem` 中。BF 期望内存被初始化为 0，SNOBOL 通过 `array` 的第二个参数 ➊ 为我们完成了这一操作。稍后我们将讨论
    `jump` 表。'
- en: The `parse` function accepts the `name` of the input text file, defines a pattern
    to match valid program characters (`pat`), and opens the file for input, reading
    one character at a time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse` 函数接受输入文本文件的 `name`，定义一个模式来匹配有效的程序字符（`pat`），并打开文件进行输入，每次读取一个字符。'
- en: The loop (`parse_l0`) reads a character into `c` and applies the pattern. If
    the pattern succeeds, then `c` contains one of the allowed command characters;
    therefore, `prog` is set and its index is incremented. Notice the SNOBOL idiom
    of embedding the `ne` predicate to test for maximum program length. If the predicate
    fails, the increment to `n` does not happen and execution falls through to `endfile`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 循环（`parse_l0`）将字符读入 `c` 并应用模式。如果模式匹配成功，那么 `c` 包含一个允许的命令字符；因此，`prog` 被设置，并且其索引递增。注意
    SNOBOL 的惯用法，将 `ne` 谓词嵌入来测试程序的最大长度。如果谓词失败，则 `n` 的递增不会发生，执行将跳转到 `endfile`。
- en: When `parse` finishes processing the input file, `prog` contains the valid commands
    and only the valid commands. The number of commands read is returned by assigning
    `n` to `parse`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `parse` 完成输入文件的处理时，`prog` 中包含了有效命令，且仅包含有效命令。读取的命令数量通过将 `n` 赋值给 `parse` 来返回。
- en: A BF program is executed sequentially until the interpreter encounters a loop.
    The original BF interpreter used recursion to handle loops; however, we’ll take
    a more literal approach. Every time we see an opening bracket (`[`), we’ll scan
    the program text forward to find the corresponding closing bracket (`]`). Similarly,
    for a closing bracket, we’ll scan backward to find the matching opening bracket.
    We could do this while interpreting the code, but that’s hideously inefficient—imagine
    a loop running tens of thousands of times.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: BF 程序按顺序执行，直到解释器遇到一个循环。原始的 BF 解释器使用递归来处理循环；然而，我们将采取更直接的方法。每当看到一个左括号 (`[`)，我们会向前扫描程序文本，找到对应的右括号
    (`]`)。类似地，对于右括号，我们将向后扫描，找到匹配的左括号。我们本可以在解释代码时进行此操作，但这效率低下——想象一下，一个循环运行了数万次。
- en: A moment’s thought makes it clear that a single pass through the code before
    starting the interpreter is sufficient to locate each opening bracket and its
    corresponding closing bracket. This is where the `jump` table comes into play.
    Recall that a SNOBOL table is like a Python dictionary; it’s an associative array.
    The index into the table is the index of an opening bracket in `prog`. Closing
    brackets also go in `jump`, as their index values are unique. With `jump` built
    ahead of time, a single reference to `jump` during program execution returns the
    proper index into `prog` for both the opening and closing brackets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 片刻思考就能清楚，开始解释器之前对代码进行一次遍历就足以定位每个左括号及其对应的右括号。这就是 `jump` 表发挥作用的地方。回想一下，SNOBOL
    的表就像 Python 字典；它是一个关联数组。表中的索引是 `prog` 中左括号的索引。右括号也存储在 `jump` 中，因为它们的索引值是唯一的。通过提前构建
    `jump`，在程序执行期间对 `jump` 的一次引用就能为左右括号提供正确的索引。
- en: '[Listing 10-3](ch10.xhtml#ch010list3) shows `buildtable` and its helper function,
    `closing`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-3](ch10.xhtml#ch010list3) 显示了 `buildtable` 及其辅助函数 `closing`。'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-3: Building the jump table*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-3：构建跳转表*'
- en: Here, `buildtable` scans the program text looking for an opening bracket. When
    it finds one, it calls `closing` to return the index of the corresponding closing
    bracket. Next, `buildtable` sets the `jump` table to the opening and closing locations
    for rapid lookup during program execution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`buildtable` 扫描程序文本，寻找左括号。当找到一个左括号时，它调用 `closing` 来返回对应右括号的索引。接着，`buildtable`
    设置 `jump` 表，将左右括号的位置存入表中，以便程序执行期间快速查找。
- en: The `closing` function locates the matching closing bracket by scanning forward
    and incrementing `n` each time a new opening bracket is found. When a closing
    bracket is found, `n` is decremented. When `n` is zero, the closing bracket matching
    the initial opening bracket has been found, so its index is returned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`closing` 函数通过向前扫描并在每次找到新的左括号时递增 `n`，来定位匹配的右括号。当找到右括号时，`n` 会递减。当 `n` 为零时，表示找到了与最初的左括号匹配的右括号，于是返回该右括号的索引。'
- en: 'BF accepts single-character input that it stores in memory as an ASCII value.
    SNOBOL has a `char` function to return the character associated with a given ASCII
    value; however, it lacks what many languages call `ord`, a function to return
    the ASCII value of a given character. No matter; we’ll make our own:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: BF 接受单字符输入，并将其作为 ASCII 值存储在内存中。SNOBOL 有一个 `char` 函数，可以返回与给定 ASCII 值关联的字符；然而，它缺少许多语言所称的
    `ord` 函数，后者用于返回给定字符的 ASCII 值。没关系，我们自己实现一个：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SNOBOL includes a special variable, `&alphabet`, which is the full range of
    ASCII characters, [0, 255]. The `ord` function uses pattern matching to locate
    all the characters of this special variable up to the given character, `c`. The
    pattern stores this substring in `v` and the length of the substring is the ASCII
    code for the character.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 包含一个特殊变量 `&alphabet`，它包含所有的 ASCII 字符范围 [0, 255]。`ord` 函数使用模式匹配来定位此特殊变量中所有字符，直到给定字符
    `c`。该模式将子字符串存储在 `v` 中，并且子字符串的长度就是该字符的 ASCII 代码。
- en: We’re now ready to run the BF program in `prog`. Let’s walk through the main
    portion of the interpreter. We’ll add some debugging abilities to help us later.
    BF is hard, so we’ll take all the help we can get.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好运行 `prog` 中的 BF 程序了。让我们一起走一遍解释器的主要部分。我们将添加一些调试功能，以便后续使用。BF 很难，所以我们会尽可能多地利用帮助。
- en: The main portion of the interpreter is in [Listing 10-4](ch10.xhtml#ch010list4).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的主要部分在 [Listing 10-4](ch10.xhtml#ch010list4) 中。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-4: The main BF interpreter loop*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-4：主要的 BF 解释器循环*'
- en: '[Listing 10-4](ch10.xhtml#ch010list4) consists of some preliminaries followed
    by a `loop` that moves through the program in `prog`. The preliminaries call `parse`
    to process the input file and `buildtable` to configure the `jump` table. BF expects
    single-character input and output with the console, which SNOBOL supports using
    the given `input` and `output` incantations.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-4](ch10.xhtml#ch010list4)包含一些准备工作，随后是一个`loop`，它在`prog`中移动程序。准备工作调用`parse`来处理输入文件，调用`buildtable`来配置`jump`表。BF期望与控制台进行单字符输入和输出，SNOBOL通过给定的`input`和`output`咒语来支持这一点。'
- en: The current program counter is `pc` and the memory pointer is `mp`. We’ll use
    `gmp` to track the highest memory cell accessed by the program. Doing this simplifies
    dumping relevant memory when the program ends.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的程序计数器是`pc`，内存指针是`mp`。我们将使用`gmp`来跟踪程序访问的最高内存单元。这样做简化了在程序结束时转储相关内存。
- en: The `loop` executes the current instruction depending on its character. Recall
    that `ident` is the SNOBOL predicate to compare two strings. Executing an instruction
    is a jump to the relevant line. Most instructions are a single statement. For
    example, `>` moves the cell pointer to the right (`mp=mp+1`). When incrementing
    the cell pointer, there’s an extra check to see if `gmp` should be updated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`根据当前指令的字符执行。回想一下，`ident`是SNOBOL谓词，用于比较两个字符串。执行指令时会跳转到相关行。大多数指令都是单一语句。例如，`>`将单元指针向右移动（`mp=mp+1`）。在增加单元指针时，还会额外检查是否需要更新`gmp`。'
- en: SNOBOL has one quirk requiring a bit of extra code. Take a look at `gchar`,
    which reads a single character of input. The `cin` variable reads the character
    and places its ASCII value in `ch`. The problem occurs when the user presses ENTER.
    On Unix systems, this should return the ASCII value 10; however, the SNOBOL interpreter
    returns the ASCII value 13\. So a quick check converts ASCII 13 to ASCII 10 before
    assigning the character to the current memory location (`gchar0`) ➊. Notice that
    each instruction ends with a jump to `cont` to continue processing the next instruction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL有一个怪癖，需要一些额外的代码。看看`gchar`，它读取单个字符的输入。`cin`变量读取字符，并将其ASCII值放入`ch`中。问题出现在用户按下ENTER时。在Unix系统上，这应该返回ASCII值10；然而，SNOBOL解释器返回的是ASCII值13。所以在赋值当前内存位置（`gchar0`）之前，会快速检查并将ASCII
    13转换为ASCII 10 ➊。注意，每个指令都以跳转到`cont`来继续处理下一条指令。
- en: Additionally, observe how opening and closing brackets are handled as `begin`
    and `again`, respectively ➋. Even though there is a single statement for each,
    a bit of explanation is in order. For example, the code for an opening bracket
    is
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，观察如何处理开括号和闭括号，分别作为`begin`和`again` ➋。尽管每个都有单个语句，但还是需要做一些解释。例如，开括号的代码是
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The BF standard says to begin a loop if the currently active memory cell is
    not 0; otherwise, skip the loop. Here, the SNOBOL predicate `eq` will succeed
    if the current memory cell is 0\. In that case, the assignment happens and `pc`
    is set to `jump[pc]`, which is the *end* of the loop that we’re currently considering.
    In contrast, if the memory cell is not 0, `eq` fails and the assignment does not
    happen. Therefore, the interpreter enters the loop as it should. The test in `again`
    is much the same, only the logic is reversed, so we jump to the beginning of the
    loop if the memory cell is not 0.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: BF标准规定，如果当前活动的内存单元不为0，则开始一个循环；否则跳过循环。在这里，SNOBOL谓词`eq`将在当前内存单元为0时成功。这样，赋值会发生，`pc`被设置为`jump[pc]`，即我们当前考虑的循环的*结束*。相反，如果内存单元不为0，`eq`失败，赋值不会发生。因此，解释器会按预期进入循环。`again`中的测试与此类似，只是逻辑相反，因此如果内存单元不为0，我们跳转到循环的开始。
- en: 'Take another look at the statement to decrement the current cell:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看递减当前单元的语句：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the decrement succeeds, flow continues with the next instruction, `s(cont)`.
    However, if `mp` is negative or too large, the statement fails and the interpreter
    jumps to `bad1`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递减成功，流程继续执行下一条指令`s(cont)`。然而，如果`mp`为负数或过大，语句会失败，解释器会跳转到`bad1`：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This prints an error message and exits. A similar error happens if an opening
    bracket has no matching closing bracket.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印错误信息并退出。如果开括号没有匹配的闭括号，也会发生类似的错误。
- en: If the second command line argument is `dump`, the interpreter will dump the
    final value of all memory locations accessed by the program before exiting. The
    code for this is in [Listing 10-5](ch10.xhtml#ch010list5).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个命令行参数是`dump`，解释器将在退出前转储程序访问的所有内存位置的最终值。相关代码见[列表 10-5](ch10.xhtml#ch010list5)。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-5: Dumping memory*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Memory values are dumped, one per line. If the value is in the range 31 < *v*
    < 127, the corresponding character is displayed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The BF interpreter is now complete. Let’s test it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The memory dump shows that cells 0 through 6 were used at some point in the
    program, and that the program ended with the memory pointer looking at cell 6\.
    Knowing which memory cell is active is critical to successful BF programming.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation appears to work. Now, let’s do stuff with it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**BF in Action**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s explore BF with worked examples. I encourage you to consider the other
    examples included on the GitHub site. However, the more complex ones like *mandelbrot.b*
    and *hanoi.b* are the output of programs that generate BF code. They were not
    written by hand.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with some basic examples and then develop more advanced examples
    that require a bit of thought. For example, we’ll end with a program to multiply
    two numbers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '***Baby Steps***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It increments cell 0 five times, then starts a loop: `[-]`. Incrementing five
    times is obvious, so let’s work through the loop to see what it does. The first
    command is `[`. It checks to see whether the current cell is 0\. In this case,
    the cell is 5 and not 0, so `[` succeeds and the loop begins.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction, `-`, decrements the value in the current memory cell (cell
    0), so the value is now 4\. The closing bracket, `]`, asks if cell 0 is 0, which
    it isn’t, so it jumps to the beginning of the loop. Note that the beginning of
    the loop isn’t `[`, but the first instruction after it (`-`). Cell 0 is decremented
    again and `]` runs again. When the value of cell 0 is 0, `]` will fail and the
    program will end. Therefore, the snippet of code above zeroes a cell. You’ll see
    `[-]` in many BF programs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a basic loop under our belt, let’s contemplate the following
    bit of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What do you think it might be doing? The code itself is in *cat.b*. Let’s run
    it and see what it produces. To run it, use this command line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Do you see the text of *bf.sno*? The filename is a clue, of course, but this
    simple program acts like the Unix `cat` command to display the contents of a file.
    Let’s add comments to the code to explain what is happening.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Reading a character, printing, and looping until there are no more characters
    to read is a good idea in this case, but what’s with `+` and `-`? These extra
    commands handle the case where a 0 character has been read. They are present to
    deal with how different systems process end-of-file (EOF). For example, this version
    of the program works nicely with our SNOBOL interpreter
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: but hangs at EOF when using the C interpreter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another loop example. Honestly, all our examples will be loop
    examples, as that’s all BF has to offer that isn’t quickly boring. This example
    is in *countdown0.b*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s only slightly more interesting than our first example. Beyond counting
    down, we also print the value of cell 0\. However, BF’s print (`.`) expects an
    ASCII character, so this example won’t print anything visible, only a set of control
    characters. We can see this by using the Unix `xxd` command to dump binary files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它比我们的第一个示例稍微有趣一些。除了倒计时，我们还打印了单元格 0 的值。然而，BF 的打印（`.`）期望的是一个 ASCII 字符，所以这个示例不会打印任何可见的内容，只有一组控制字符。我们可以使用
    Unix 的 `xxd` 命令来查看二进制文件：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `xxd` command dumps binary data as hexadecimal values. Looking at the output
    you’ll see the countdown (09, 08, 07, . . . , 00). To get a countdown we must
    convert the current value of cell 0 to a digit. The offset between a digit value
    and the ASCII code for the digit is 48, so we must add 48 before printing and
    subtract 48 afterward.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`xxd` 命令将二进制数据转储为十六进制值。查看输出，你会看到倒计时（09, 08, 07, ... , 00）。为了得到倒计时，我们必须将单元格
    0 的当前值转换为数字。数字值和该数字的 ASCII 码之间的偏移量是 48，所以我们在打印之前必须加上 48，打印后再减去 48。'
- en: '[Listing 10-6](ch10.xhtml#ch010list6) shows us *countdown1.b*. We’ve included
    comments to explain the code.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-6](ch10.xhtml#ch010list6) 向我们展示了 *countdown1.b*。我们已包含注释来解释代码。'
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 10-6: Countdown with ASCII output*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：带有 ASCII 输出的倒计时*'
- en: Running [Listing 10-6](ch10.xhtml#ch010list6) produces a countdown as output
    (9, 8, 7, . . . , 0). To output newline repeatedly, it’s easiest to store it somewhere,
    so we set cell 0 to 10\. Next, `>` moves the cell pointer to look at cell 1\.
    As you write BF code, pay very close attention to where the cell pointer is looking.
    Cell 1 is set to 10 as well, but in this case, it is the value to count down.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [清单 10-6](ch10.xhtml#ch010list6) 会产生倒计时输出（9, 8, 7, ... , 0）。为了重复输出换行，最简单的方法是将它存储在某个地方，所以我们将单元格
    0 设置为 10。接下来，`>` 将单元格指针移到单元格 1。编写 BF 代码时，必须非常注意单元格指针所指向的位置。单元格 1 也设置为 10，但在这种情况下，它是倒计时的值。
- en: The loop begins by incrementing the value in cell 0 with 48 `+` commands. This
    is boring but quick to implement. The current loop count is now a valid ASCII
    digit, so we print it and subtract 48 to get back to the actual count. The bottom
    of the loop looks at cell 0, which is always 10, and prints it to get the newline
    character. The code then looks again at cell 1, where our count lives, and loops
    until 0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 循环通过使用 48 个 `+` 命令来递增单元格 0 的值。这很无聊，但实现起来很快。当前的循环计数现在是一个有效的 ASCII 数字，因此我们打印它，并减去
    48 以恢复到实际的计数。循环的底部查看单元格 0，它始终为 10，并打印它来获取换行符。然后代码再次查看单元格 1，我们的计数存储在这里，并循环直到 0。
- en: '***Bunches O’Bits***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***大量的比特***'
- en: '*Bit twiddling*, meaning fiddling around with the bits of a byte, is the goal
    of this section. Here we’ll implement two examples. The first calculates the ones’
    complement of a byte. The second calculates the even parity bit. Don’t be concerned
    if these terms are new to you; I’ll clarify as we go.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特操作*，即操作字节中的比特，是本节的目标。我们将在这里实现两个示例。第一个计算字节的反码。第二个计算偶校验位。如果这些术语对你来说是新的，不用担心；我们会在过程中解释。'
- en: '**A Complimentary Complement**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**补充的补码**'
- en: Internally, computers represent integers as a set number of bits, that is, as
    a base-2 number. One method for encoding negative numbers is to use the *ones’
    complement*, where each bit is the opposite of what it would be for a positive
    value. For example, if a number is 00001101[2] = 11, then 11110010[2] = *–*11
    where each 1 is now a 0 and vice versa. In this encoding, the leading bit will
    be one when the number should be interpreted as a negative value. Our goal is
    to write a BF program to calculate the ones’ complement of an input byte. The
    byte will be entered as a string of eight characters (each 0 or 1).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，计算机将整数表示为固定数量的位，即以二进制表示。编码负数的一种方法是使用 *反码*，即每一位的值与正数值的相反。例如，如果一个数字是 00001101[2]
    = 11，那么 11110010[2] = *–*11，其中每个 1 变成 0，反之亦然。在这种编码中，当数字应该被解释为负值时，最高位为 1。我们的目标是编写一个
    BF 程序来计算输入字节的反码。字节将作为一串八个字符（每个字符是 0 或 1）输入。
- en: Let’s think about this task for a bit (or eight). We know we’ll likely want
    a loop to read eight bits. After reading a bit, we need to subtract 48 to map
    the ASCII value read to its actual value (0 or 1). Once we have the actual value,
    we then output a 0 if the value is 1 or a 1 if the value is 0\. In typical languages,
    a simple `if` statement would do the trick. Of course, we’re not working with
    an ordinary language, but rather in the strange world of BF.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下这个任务（或者说八个）。我们知道，可能需要一个循环来读取八个比特。读取完一个比特后，我们需要减去48，以将读取的ASCII值映射到实际值（0或1）。一旦得到实际值，如果值是1，我们输出0；如果值是0，我们输出1。在常见编程语言中，一个简单的`if`语句就能解决问题。当然，我们并不是在使用普通的语言，而是在BF的奇特世界中。
- en: A loop to read a byte’s worth of bits could be written as
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用来读取一个字节比特的循环可以写成如下形式：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code, we first set cell 0 to 8 and then start a loop. The loop decrements
    cell 0, moves to cell 1, and inputs something. It then moves the memory pointer
    back to cell 0 and loops if the count isn’t 0\. This reads eight characters and
    then exits. Adding a period after the comma echoes the input. Of course, we need
    a 0 or 1 in memory, not the ASCII code for 0 or 5, so somewhere we’ll have to
    subtract 48\. We’ll use a sequence of 48 `-` instructions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先将单元格0设置为8，然后开始一个循环。该循环递减单元格0，移到单元格1并输入内容。然后它将内存指针移回单元格0，并在计数不为0时继续循环。这个循环读取八个字符后退出。在逗号后加一个句号可以回显输入内容。当然，我们需要在内存中存储0或1，而不是ASCII码0或5，因此我们需要在某个地方减去48。我们将使用一系列48个`-`指令。
- en: All right, we have the input bit, but how do we decide whether we should output
    a 0 or a 1? If the bit is 1, we could enter a loop that is otherwise skipped if
    the bit is 0\. How can we use that? Well, we might be able to set another memory
    location to 1, read the input bit, and if it is 1, decrement the preset memory
    location. If we do that, we’ll be in business. However, before we go too far,
    it’s a good idea to make a map of how we are using BF memory. So far, we have
    the setup
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经得到了输入比特，但如何决定是否输出0或1呢？如果比特是1，我们可以进入一个循环，如果比特是0，则跳过该循环。我们如何利用这一点呢？其实，我们可以设置另一个内存位置为1，读取输入的比特，如果是1，就递减该预设的内存位置。如果这样做，我们就可以成功了。不过，在继续之前，最好先绘制一下我们如何使用BF内存的地图。到目前为止，我们的设置如下
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: where our loop counter is in cell 0, the bit entered by the user is in cell
    1, cell 2 holds a 1, and the memory pointer is looking at cell 1.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们的循环计数器在单元格0中，用户输入的位在单元格1中，单元格2存储着1，内存指针指向单元格1。
- en: 'If the user’s bit is 1, we want to enter a loop to decrement cell 2\. If the
    bit is 0, the loop will be skipped and cell 2 will remain 1\. Then, we print cell
    2 and we have it: a 1 is changed into a 0, and a 0 is changed into a 1\. We then
    move the memory pointer back to cell 0 to decrement the bit counter and repeat
    until we’re done.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的位是1，我们希望进入一个循环来递减单元格2。如果位是0，则跳过循环，单元格2保持为1。然后，我们打印单元格2，得到的结果是：1变为0，0变为1。接着，我们将内存指针移回单元格0，递减位计数器，并重复直到完成。
- en: '[Listing 10-7](ch10.xhtml#ch010list7) shows *ones.b*, which implements our
    algorithm. Let’s walk through the code to see that it does what I claim.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10-7](ch10.xhtml#ch010list7)展示了*ones.b*，它实现了我们的算法。让我们一起分析这段代码，看看它是否按照我所说的那样执行。'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-7: Ones’ complement*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-7：反码*'
- en: First, the outermost loop uses cell 0 to count down from 8\. Inside this loop,
    after decrementing the count, the memory pointer is moved to cell 2, which is
    then incremented. We know that cell 2 was initially 0, so it must be 1 now. We
    then move back to cell 1 to get the user’s input, which we’ll assume is a 0 or
    1\. This much is `->>+<,` if the comments are removed. Look at the commands until
    you are sure you follow what’s going on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最外层的循环使用单元格0从8开始递减。在这个循环内部，递减计数后，内存指针移到单元格2，然后对其进行递增。我们知道，单元格2最初是0，所以现在它应该是1。接着，我们返回到单元格1以获取用户的输入，我们假设输入是0或1。去掉注释后，这部分是`->>+<,`。看看这些指令，直到你完全明白它在做什么。
- en: 'The next block of code is an uninspired sequence of 48 `-` commands to change
    the user’s input into either a 0 or 1\. Recall that we’re looking at cell 1\.
    At this point, we have memory as we want it: cell 1 is 0 or 1 and cell 2 is 1\.
    The next set of commands are key to the entire program: `[->-<]>`. The small loop
    (`[->-<]`) executes if the user’s bit is 1 because we are looking at cell 1 and
    it isn’t 0; therefore, `[` enters the loop. Cell 1 is immediately decremented
    to make it 0 because we only want the code in the loop to execute once. Next,
    `>` looks at cell 2 and `-` decrements it to change it from 1 to 0\. Lastly, `<`
    looks again at cell 1, which is now 0, so the loop exits, and the final `>` executes
    to look at cell 2\. If the user’s bit is a 0, then `[` fails, skipping the entire
    loop and moving directly to the final `>` to also look at cell 2\. At this point,
    cell 2 is the focus, and it contains a 1 if the input bit was a 0 or a 0 if the
    input bit was a 1\. The next block of 48 `+` commands increments the value in
    cell 2 to get the corresponding ASCII code and `.` prints it.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: What does `[-]` do? As we saw above, `[-]` is the BF idiom to zero a memory
    location. This is necessary to make sure cell 2 is 0 when the outer loop comes
    around for the next input bit. Right now, cell 2 is either 48 or 49\. The final
    two `<<` instructions move focus back to cell 0, the loop counter. The outer `]`
    then loops if cell 0 isn’t 0\. When it is, the final line, `++++++++++.`, outputs
    ASCII 10, a newline, and the program exits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Whew! Let’s see [Listing 10-7](ch10.xhtml#ch010list7) in action. Run *ones.b*
    like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `echo` command is a convenient way to send input to a program without typing
    it directly. Notice that the input is 11 as we saw it earlier, 00001101[2]. The
    output is 11110010[2], which is –11 in ones’ complement, as we wanted. The memory
    dump tells us we end the program looking at cell 0, which contains 10 for the
    final newline. The other two cells used by the program are both 0.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: One note before moving on. [Listing 10-7](ch10.xhtml#ch010list7) excludes a
    comment block at the top of *ones.b*. The BF interpreter ignores non-command characters;
    however, the comments must not include any command characters. That gets a bit
    annoying at times. The comments at the top of *ones.b* are enclosed in brackets
    (`[` and `]`). This means the entire comment block (at least the characters that
    are valid BF commands) is a loop. But this doesn’t matter. The comment block is
    the first loop in the program, and we know cell 0 is always 0, so the loop will
    never execute and we are free to enter whatever text we want in the comments.
    This was not my idea, but it is another illustration of the creativity present
    in the esolang community.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieving Parity**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Serial communication protocols sometimes use a *parity bit*, an extra bit transmitted
    with the data that makes it easier to detect transmission errors. For example,
    if the data fits in seven bits, as standard ASCII characters do, then an eighth
    bit can be added to make the number of one bits (bits with a value of 1) in the
    8-bit byte even. This is known as even parity. If the received byte does not have
    an even number of one bits, the receiver immediately knows there is an error and
    can request the byte again. A single parity bit can capture a single-bit error,
    which is sufficient in most cases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Our mission is to write a BF program to accept seven input bits and output
    the proper even parity bit. We’ll input bits as a sequence of seven ASCII characters
    as before and then output either ASCII 0 or ASCII 1 to make the number of one
    bits even. The following are some examples of bytes with parity bits:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '| 0000000 | → | 0000000**0** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| 0000010 | → | 0000010**1** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| 0011001 | → | 0011001**1** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| 1111111 | → | 1111111**1** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: The bold output bit ensures that every byte has an even number of 1s.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: How should we go about getting BF to do this for us? There are likely multiple
    approaches, but the approach we’ll use here is first to tally the number of 1s
    present in the seven inputs. Then we’ll decide which bit to output based on this
    tally. As with *ones.b* above, we need an outer loop to read the ASCII bits and
    subtract 48\. To tally the one bits, we’ll increment a memory cell each time the
    bit is a 1.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-8](ch10.xhtml#ch010list8) presents a loop to read seven bits and
    tally the number of one bits.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-8: Adding the input bits*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: As always, tracking memory use is essential. In this case, cell 0 holds the
    bits read counter, cell 1 is the input bit, and cell 2 the tally of one bits.
    The first part of the loop is `>,.`, which moves to cell 1, reads the input bit,
    and echoes it. Next comes a block of 48 `-` commands to turn the ASCII character
    code into a 0 or 1.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If the bit is a 1, `[` begins the inner loop. The loop body, `->+<`, decrements
    cell 1, looks at cell 2 and increments it, and looks again at cell 1\. Because
    cell 1 is now 0, `]` fails and the loop ends. If the input bit is 0, `[` skips
    ahead to `<-`. In both cases, the memory pointer is looking at cell 1, so `<`
    looks at cell 0, which `-` then decrements. The final `]` fires to repeat the
    loop six more times. When the loop ends, cell 2 contains a tally of the number
    of one bits read and the memory pointer is looking at cell 0\. It’s important
    to note that cell 0 and cell 1 are both 0 when the outer loop exits.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Cell 2 contains the number of one bits in the input. If this number is odd,
    the output bit should be 1\. Otherwise, it should be 0\. How do we tell if cell
    2 is even or odd? Here’s where things get a bit tricky. Our solution is in [Listing
    10-9](ch10.xhtml#ch010list9), but we must walk through it to understand it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 10-9: Using the ones tally to decide the parity bit*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In essence, when the outer loop of [Listing 10-9](ch10.xhtml#ch010list9) ends,
    the memory pointer will be looking at cell 0 if the output bit should be 1 or
    cell 2 if the output bit should be 0\. Additionally, cell 3 will be 1 if we end
    at cell 0 and cell 5 will be its default value of 0.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The code before the main loop of [Listing 10-9](ch10.xhtml#ch010list9) is simple
    enough. Move the memory pointer twice to look at cell 2, which has the one bits
    tally. If this tally is 0, the loop is skipped by `[` and we move to the final
    bit of code with the memory pointer looking at cell 2\. We’ll get to the final
    bit of code soon.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If the tally in cell 2 isn’t 0, we enter the main loop of [Listing 10-9](ch10.xhtml#ch010list9).
    The body of this loop has two inner loops, one after the other. The body of the
    first inner loop is `->+>`. It subtracts 1 from cell 2, looks at and increments
    cell 3, and then looks at cell 4, which is always 0\. Because cell 4 is 0, `]`
    exits the loop, meaning the loop never actually loops. Notice that when the loop
    exits, the memory pointer is looking at cell 4 and cell 3 is 1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: If we assume that cell 2 was initially 1 ➊, cell 2 is now 0, cell 3 is 1, and
    we are looking at cell 4, which is also 0\. The `<<` between the inner loops moves
    back to cell 2, which, as it is 0, skips the second inner loop and hits the final
    `<<` to move back from cell 2 to cell 0\. Because cell 0 is 0, the outer loop
    exits, meaning we are looking at cell 0 and cell 3 is still 1.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: This situation happens every time cell 2 contains an odd value. What if cell
    2 contains 2? After the first inner loop of [Listing 10-9](ch10.xhtml#ch010list9),
    cell 2 contains 1, cell 3 contains 1, and we are looking at cell 2\. Therefore,
    the second inner loop fires to decrement cell 2 and cell 3, making them both 0\.
    The loop then moves to cell 4, which is always 0, exits, and moves back to cell
    2, which is now also 0\. The outer loop then exits, and we are looking at cell
    2 this time, not cell 0\. Whenever cell 2 is initially even, both inner loops
    will repeatedly fire to make cell 2 0\. Cell 3 is also decremented by the second
    inner loop to make sure it only ever contains a 1.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost done. The code in [Listing 10-9](ch10.xhtml#ch010list9) ends, leaving
    BF in one of two states. If the tally in cell 2 was even, we’re looking at cell
    2\. If the tally is odd, we’re looking at cell 0 and cell 3 is 1\. To output the
    proper bit, we need the code in [Listing 10-10](ch10.xhtml#ch010list10).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 10-10: Printing the proper parity bit*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: We use `>>>` to move to either cell 3 or cell 5\. Cell 3 would be 1 if we ended
    at cell 0 and that’s the value we want to output. If we ended at cell 2, we move
    to cell 5, which is initialized to be 0 and is also the value we want. All that
    remains is to add 48 to convert the value to the ASCII character code for either
    1 or 0, print it, and then move to either cell 4 or cell 6, both of which are
    initially 0, to output the final newline character.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try *parity.b* with the example inputs above:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output is as expected, meaning that *parity.b* works. You’ll get the same
    results if you use the SNOBOL interpreter as well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s work on our final BF example: multiplication.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiplicative Multiplicity***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Multiplication is repeated addition. Let’s use that fact to write a BF program
    to accept two single-digit numbers and compute their product. We’ll write two
    versions. The first version implements multiplication but leaves the product in
    memory. This is unsatisfying, so the second version uses freely available code
    from *[https://esolangs.org/](https://esolangs.org/)* to output the product as
    ASCII characters. The full source code for both examples is in *mult.b* and *mult2.b*,
    respectively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We require two inputs, which we’ll store in cells 0 and 1\. We’ll use cells
    2 and 3 while multiplying and place the final product in cell 3\. Reading the
    input characters is straightforward; see [Listing 10-11](ch10.xhtml#ch010list11).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-11: Reading and printing the inputs*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The first character is read and converted to its numeric value. Then cell 1
    is used to output `*` before reading the second digit.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: To multiply, we must increment a memory location as many times as the value
    in cell 1 dictates (that is, increment it cell 1 times), and repeat until cell
    0 is 0\. For example, if cell 0 is 5 and cell 1 is 4, the algorithm is to calculate
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 5 × 4 = 4 + 4 + 4 + 4 + 4 = 20
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: which we might write in a language like Python as
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s duplicate this code in BF. However, we have a minor issue. We need two
    loops, an outer loop running until cell 0 is 0, and an inner loop to increment
    cell 3 by cell 1 times. Recall that BF loops are destructive. For example, if
    we write `++++[.-]`, we’ll print the current value of cell 0 four times, from
    4 down to 1\. When the loop exits, cell 0 is 0, meaning its original value has
    been lost. Thus, we must preserve the value of cell 1 to use it again on the next
    pass.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-12](ch10.xhtml#ch010list12) shows us the multiplication algorithm.
    Let’s see how it preserves the inner loop counter.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 10-12: Multiplying the two digits*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The first `<` moves us back to cell 0 as the code in [Listing 10-11](ch10.xhtml#ch010list11)
    ends with the memory pointer looking at cell 1\. Cell 0 isn’t 0, generally, so
    the outer loop begins, and cell 0 is immediately decremented. Next, `>` moves
    to cell 1, and the first inner loop begins if cell 1 isn’t 0\. Cell 1 is also
    immediately decremented.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the first inner loop is `>+>+<<`. The `>+` instructions move to
    cell 2 and increment it. The following `>+` does the same to cell 3\. Lastly,
    `<<` moves back to cell 1 so `]` can decide whether to continue the loop or not.
    When the loop exits, memory looks like this, assuming the user entered `5` and
    `4`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Recall that cell 3 holds our product. It’s currently 4 because the first inner
    loop ran four times. We now must restore cell 1\. That’s why the loop incremented
    both cell 2 and cell 3\. We use cell 3 for the product and we can use cell 2 to
    restore the inner loop counter. That’s what `>[-<+>]` does; it decrements cell
    2 while incrementing cell 1\. The final `<<` ensures that the outer loop’s `]`
    instruction is looking at cell 0.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Each pass through the outer loop adds cell 1 to cell 3, using cell 2 to restore
    cell 1 for the next pass. When cell 0 is finally 0, cell 3 holds the product.
    Note that we entered single digits, but this multiplication routine is generic
    and will work for any two values. Also, the trick of double incrementing memory
    to have a place to restore from is another BF idiom. We saw similar code in [Chapter
    8](ch08.xhtml#ch08) when we implemented multiplication in FRACTRAN.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take *mult.b* out for a test drive. We’ll use our interpreter’s ability
    to dump memory to see if it is working. For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In both cases, we see that cell 3 contains the correct product.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: To print the product as a number, we add the code in [Listing 10-13](ch10.xhtml#ch010list13)
    to the end of the multiplication routine in [Listing 10-12](ch10.xhtml#ch010list12)
    (see *mult2.b*).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 10-13: The print routine*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, this routine comes from *[https://esolangs.org/](https://esolangs.org/)*.
    What is particularly nice about this routine is that it works with any memory
    location, so we move from cell 0 to cell 3 prior to running it. The provided comments
    give some indication of what the routine is doing. Notice that the second line
    of [Listing 10-13](ch10.xhtml#ch010list13) uses the “clear a cell” idiom three
    times to initialize memory. We won’t walk through [Listing 10-13](ch10.xhtml#ch010list13)
    in any detail, as it is quite challenging. Motivated readers will find the code,
    with some additional details, at *[https://esolangs.org/wiki/Brainfuck_algorithms](https://esolangs.org/wiki/Brainfuck_algorithms)*
    under the heading beginning with “Print value of cell x as number.”
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review some examples to see that the routine works as advertised.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The examples of this section, *ones.b*, *parity.b*, *mult.b*, and *mult2.b*,
    serve as our introduction to BF. There’s much more we might say, but we covered
    the essentials. Let’s turn now to outside resources to see additional examples,
    learn more about BF programming, and gain insight on how BF has influenced esolangs
    as a whole, to say nothing of genuine academic research involving BF.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**The BF Multiverse**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If Piet generated a universe, then to be fair, we must say that BF has created
    a multiverse. Let’s briefly investigate some of those universes in this section:
    examples, tutorials, implementations, inspirations, and academic BF. Enjoy!'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '***Examples***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best way to learn a language is to use it. We did that in the previous section.
    The next best way to learn a language is to see how others have used it. Let’s
    take a cursory look at the BF examples included with this book. I did not write
    these examples. See the *README* file for attribution information.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The most impressive set of BF programs written by hand and not generated by
    another system producing BF code as output I’ve found are by Daniel B. Cristofani.
    You’ll find them at *[http://brainfuck.org/](http://brainfuck.org/)*, which alone
    tells you Cristofani’s a serious BF coder—he registered the domain name. I suspect
    you’ll learn much from the examples and even more from the tutorial information
    on his site.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The book repository contains the following, all of which run with both the
    C and SNOBOL interpreters:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '***squares.b***  Print *n*² for [0,100].'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '***fib.b***  Generate an endless stream of Fibonacci numbers. We encountered
    the Fibonacci sequence in [Chapter 1](ch01.xhtml#ch01) and will again in [Chapter
    13](ch13.xhtml#ch13). This version does not use a single cell to hold the number,
    but rather handles arbitrary-sized numbers. This is a good example of how compact
    BF code can be while still doing something interesting.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '***factorial2.b***  Another gem. This one calculates an endless stream of factorials.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '***sierpinski.b***  The Sierpiński triangle is a common fractal, one that a
    straightforward algorithm can generate. This version produces ASCII output. We’ll
    work with the Sierpiński triangle again in [Chapter 13](ch13.xhtml#ch13). Consider
    this example a preview.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '***random.b***  Implements Wolfram’s Rule 30, a 1D cellular automaton. This
    automaton, especially the center bit, passes many tests for randomness and formed
    the basis for Mathematica’s first pseudorandom generator. To experiment more with
    Rule 30 and other 1D automatons, see [Chapter 7](ch07.xhtml#ch07) of my book *Random
    Numbers and Computers* (Springer, 2018).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '***golden.b***  Calculates the decimal expansion of ![Image](Images/f0292-01.jpg).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***e.b***  Calculates the decimal expansion of *e*, the base of the natural
    logarithm. The natural log can be defined via an integral, In ![Image](Images/f0293-1.jpg)
    with *e* the limit such that the log is ![Image](Images/f0293-2.jpg).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '***tictactoe.b***  Tic-tac-toe in BF. You against the computer. Good luck.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining examples, beyond *cat.b* and *hello.b*, which we saw earlier,
    include the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '***prime.b***  Calculate prime numbers less than the given number. This commented
    example was written by hand, but I have not succeeded in identifying the author.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '***hanoi.b***  An animated Tower of Hanoi. This example is the output of Claire
    Wolf’s BF compiler suite (see below). It’s fun to watch, but run it with the C
    interpreter or you’ll be waiting a very long time indeed.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '***mandelbrot.b***  Creates an ASCII version of the Mandelbrot set. The *README*
    file gives the URL of the code. It appears to be the output of Wolf’s BF compiler
    as well. If you use the SNOBOL interpreter, you’ll eventually finish, but it runs
    about 100 times slower than the C interpreter.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '***Tutorials***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tutorials here offer plenty of good BF programming insights, idioms, and
    explanations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Daniel B Cristofani’s BF pages**  Mentioned earlier but worth mentioning
    again because of the helpful programming advice. You’ll even find advice on how
    to write a “compliant” interpreter. Our SNOBOL interpreter is not compliant, but
    we’re happy with it. (*[http://brainfuck.org/](http://brainfuck.org/)*)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Frans Faase’s BF pages**  You’ll find many good reference/tutorial pages
    here. Some are Faase’s, whereas others are links to still more information about
    BF. The World Wide Web is a web, after all. (*[https://www.iwriteiam.nl/Ha_BF.html](https://www.iwriteiam.nl/Ha_BF.html)*)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**Katie Ball’s BF tutorial**  Ball’s tutorial is another good reference. (*[https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/](https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/)*)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementations***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The implementations of BF are legion, which is somehow fitting. Only a tiny
    selection is referenced here, and I’m completely ignoring all the hardware implementations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Compilers**'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The phrase *BF compiler* has multiple meanings. For example, a BF compiler
    might be a program that takes a higher-level language and produces BF code. In
    that case, BF is the machine code for the compiler. Alternatively, a BF compiler
    might be just that: a program that takes BF as input and produces executable code
    from it. I offer an example of each kind here.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**Brian Raiter’s native BF compiler**  As promised above, here’s Brian Raiter’s
    166-byte BF compiler. It’s written in assembly language (install `nasm` on Linux)
    and produces standalone executables. Not every example in the repository works
    with this compiler, but many do, and the results are significantly faster than
    even the C interpreter. Try *e.b*, *golden.b*, and *tictactoe.b*. There are many
    comments in the source code, *bf.asm*. Hopefully, your x86 assembly is much stronger
    than mine. (*[http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt](http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt)*)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Claire Wolf’s compiler to BF**  This compiler takes a higher-level macro
    language and produces executable BF code. It produced two of our examples: *hanoi.b*
    and *mandelbrot.b*. (*[http://bygone.clairexen.net/bfcpu/bfcomp.html](http://bygone.clairexen.net/bfcpu/bfcomp.html)*)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**Interpreters**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We saw how easy it is to write a BF interpreter, even in SNOBOL. The two links
    here point to large lists of BF interpreters in all kinds of languages.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**[esolangs.org](http://esolangs.org)’s BF implementations**  This page has
    a long list of BF and BF-related goods and services, er, implementations. (*[https://esolangs.org/wiki/Brainfuck_implementations](https://esolangs.org/wiki/Brainfuck_implementations)*)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**Rosetta Code’s BF implementations**  BF interpreters in a plethora of languages.
    Neither Jefe nor I are responsible for time or bits lost due to incomplete or
    erroneous code. (*[http://rosettacode.org/wiki/Execute_Brain****](http://rosettacode.org/wiki/Execute_Brain****)*)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspirations***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Perhaps the greatest tribute to BF is that it has inspired many other esolangs.
    Some are serious, genuine extensions to core BF. Others are less serious or even
    outright jokes. If you browse the (long) language list at *[https://esolangs.org/wiki/Language_list](https://esolangs.org/wiki/Language_list)*,
    you’ll recognize many BF-related languages from nothing more than the colorful,
    if not sometimes offensive, names.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '***Academic BF***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: BF isn’t all just fun and games. The language is elementary, yet Turing complete.
    This makes it attractive to researchers looking for a target or other language
    to use in their systems. The references here are to academic papers that use BF,
    either actively or as an example. What’s particularly interesting is that not
    all of the references are from traditional computer science journals. BF is useful
    even in relation to more traditional human pursuits, like poetry. This list is
    by no means exhaustive, merely illustrative, and favors more recent references
    to BF.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '*BF++: A Language for General-purpose Program Synthesis*, Vadim Liventsev,
    Aki Härmä, and Milan Petković (2021).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '*Neural Program Synthesis with Priority Queue Training*, Daniel A. Abolafia,
    Mohammad Norouzi, Jonathan Shen, Rui Zhao, and Quoc V Le (2018).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '*Resisting Clarity/Highlighting Form: Comparing Vanguard Approaches in Poetry
    and Programming*, Irina Lyubchenko (2020).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '*Fully Human, Fully Machine: Rhetorics of Digital Disembodiment in Programming*,
    Brandee Easter (2020).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '*50,000,000,000 Instructions per Second: Design and Implementation of a 256-Core
    BrainFuck Computer*, Sang-Woo Jun (2016).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '*A Box, Darkly: Obfuscation, Weird Languages, and Code Aesthetics*, Michael
    Mateas and Nick Montfort (2005).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The first two references use BF with reinforcement learning, thereby combining
    esolangs and deep machine learning. Advanced neural networks generate BF programs
    to solve problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BF is Turing complete. It is imperative, has the requisite control structures
    (brackets), and, ignoring the self-imposed 30,000-cell memory limit, uses arbitrary
    memory. Additionally, and impressively, Daniel Cristofani implemented a universal
    Turing machine in BF, thereby directly demonstrating Turing completeness. The
    machine is in *utm.b* in the BF examples directory. Comments in the file explain,
    in detail, what the program is and what it means.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: There’s a certain enticing nature to BF due to its simplicity. Yes, it’s challenging
    to work with, which might have been intentional, like a gauntlet thrown down to
    see who might pick it up. But I don’t view BF that way. Life is built from the
    combinatorial mixing of a multitude of smaller components. Might it be possible
    to view something like BF as the DNA of programming? We already know from [Chapter
    3](ch03.xhtml#ch03) that a Turing machine captures the essence of what an algorithm
    is. BF is more advanced than a Turing machine, but just barely, so it can serve
    the same purpose as an encapsulation of the idea of an “algorithm.”
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In his famous *Epigrams on Programming*, Alan Perlis wrote
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 19\. A language that doesn’t affect the way you think about programming, is
    not worth knowing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This is true for every language in this book, but I hope it is especially so
    for the esolangs, with BF chief among them. Struggling to write code in BF, especially
    when decades of experience make the necessary code almost instantly present itself
    in more familiar languages, does affect the way you think about programming. I
    found myself trying, with varying levels of success, to think in a new way to
    understand how to fit what BF offers to what I would instinctively do in a language
    like Python or C. Perhaps that’s the most enduring effect of learning BF. It requires
    you to think in new ways instead of relying on what is already familiar. BF is
    a way out of the Python (or C or Java or . . .) echo chamber, as it were.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Perlis offers more wisdom directly applicable to BF:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 23\. To understand a program you must become both the machine and the program.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: For modern, high-level languages, we need not think about the machine too much.
    Indeed, modern languages go to great lengths to abstract themselves from the machine.
    With BF, as with a Turing machine, we must consider both the machine and the program
    if we hope to be successful.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’re quoting Perlis, I’d be remiss not to include this epigram:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 54\. Beware of the Turing tar-pit in which everything is possible but nothing
    of interest is easy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Turing tar-pits might be a bit like beauty—in the eye of the beholder. The
    following that has grown around BF and, by extension, esolangs in general, argues
    against Perlis in this case, at least to me. Perlis’s first epigram is “One man’s
    constant is another man’s variable.” I’m tempted to rephrase it: “One man’s Turing
    tar-pit is another man’s inspiration.”'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter introduced us to the strangely attractive, if frustratingly difficult,
    multiverse of BF. We explored what BF is and then implemented it twice: once in
    C using the original implementation and again in SNOBOL. After this, we wrote
    a few example programs to get a feel for thinking in BF. With a basic grasp of
    the language in hand, we then turned our gaze upward to examine some of the brighter
    lights in the BF multiverse. As with every language, we closed the chapter with
    a brief discussion.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 9](ch09.xhtml#ch09) we painted pretty pictures with Piet, a 2D
    language. Let’s close our survey of existing esolangs by returning to the world
    of 2D programming, but this time using text instead of pixels. Next stop: Befunge.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
