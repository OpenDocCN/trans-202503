<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_461"/><span class="big">9</span><br/>ARM ASSEMBLY</h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">In this chapter, we cover the ARM version 8 application profile (ARMv8-A) architecture A64 ISA, the latest ARM ISA that is in use on all Linux OS ARM computers. Recall that an instruction set architecture (or ISA; see <a href="ch05.xhtml#ch05">Chapter 5</a>) defines the set of instructions and binary encodings of a machine-level program. To run the examples in this chapter, you will need access to a machine with an ARMv8-A processor with a 64-bit operating system installed. The examples in this chapter use a Raspberry Pi 3B+ running the 64-bit Ubuntu Mate operating system. Note that every Raspberry Pi released since 2016 can use the A64 ISA. However, Raspberry Pi OS (the default Raspberry Pi operating system) is still 32-bit as of this writing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_462"/>You can confirm that you have a 64-bit version of the operating system (OS) on your system by running the <span class="literal">uname -p</span> command. A system with a 64-bit OS will output the following:</p>&#13;
<p class="programs">$ <span class="codestrong1">uname -p</span><br/>&#13;
aarch64</p>&#13;
<p class="indent">Although it is possible to <em>build</em> ARM binaries on Intel machines using ARM’s GNU toolchain cross-compilation tools,<sup><a href="ch09.xhtml#fn9_1" id="rfn9_1">1</a></sup> you cannot <em>run</em> ARM binaries directly on a x86 system. Readers interested in learning about ARM assembly directly on their laptops are encouraged to explore QEMU,<sup><a href="ch09.xhtml#fn9_2" id="rfn9_2">2</a></sup> which can <em>emulate</em> an ARM system. Emulators differ from virtual machines in that they also simulate the hardware of another system.</p>&#13;
<p class="indent">Another alternative is to use one of Amazon’s recently released EC2 A1 instances.<sup><a href="ch09.xhtml#fn9_3" id="rfn9_3">3</a></sup> Each instance gives users access to a 64-bit Graviton processor, which follows the ARMv8-A specification.</p>&#13;
<p class="indent">Keep in mind, however, that the specific assembly instructions produced by a compiler are highly influenced by the operating system and precise machine architecture. Therefore, the assembly produced on AWS instances or through QEMU emulation may differ slightly from the examples shown in this chapter.</p>&#13;
<div class="g-box">&#13;
<p class="box-title">RISC AND ARM PROCESSORS</p>&#13;
<p class="noindent">For many years, complex instruction set computer (CISC) architectures dominated the personal computing and server markets. Common examples of CISC architectures include Intel and AMD processors. However, reduced instruction set computer (RISC) architectures gained momentum over the past decade due to demand from the mobile computing sector. ARM (which stands for Acorn RISC machine) is an example of a RISC architecture, along with RISC-V and MIPS. RISC architectures are especially attractive to mobile computing due to the energy efficiency of their processors, which prolongs battery life. In recent years, ARM and other RISC processors have begun making headway in the server and high performance computing (HPC) markets. For example, Japan’s Fugaku supercomputer, the fastest in the world as of 2020, uses ARM processors.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_73">9.1 Diving into Assembly: Basics</h3>&#13;
<p class="noindent">For a first look at assembly, we modify the <span class="literal">adder</span> function from <a href="ch06.xhtml#ch06">Chapter 6</a> to simplify its behavior. The modified function (<span class="literal">adder2</span>) is shown here:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
//adds two to an integer and returns the result<br/>&#13;
int adder2(int a) {<br/>&#13;
    return a + 2;<br/>&#13;
}<br/>&#13;
<span epub:type="pagebreak" id="page_463"/>&#13;
int main(){<br/>&#13;
    int x = 40;<br/>&#13;
    x = adder2(x);<br/>&#13;
    printf("x is: %d\n", x);<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">To compile this code, use the following command:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o adder adder.c</span></p>&#13;
<p class="indent">Next, let’s view the corresponding assembly of this code by using the <span class="literal">objdump</span> command:</p>&#13;
<p class="programs">$ <span class="codestrong1">objdump -d adder &gt; output</span><br/>&#13;
$ <span class="codestrong1">less output</span></p>&#13;
<p class="indent">Search for the code snippet associated with <span class="codestrong">adder2</span> by typing <span class="codestrong">/adder</span> while examining the file <span class="literal">output</span> using <span class="literal">less</span>. The section associated with <span class="literal">adder</span> should look similar to the following:</p>&#13;
<p class="programs">0000000000000724 &lt;adder2&gt;:<br/>&#13;
 724:   d10043ff        sub     sp, sp, #0x10<br/>&#13;
 728:   b9000fe0        str     w0, [sp, #12]<br/>&#13;
 72c:   b9400fe0        ldr     w0, [sp, #12]<br/>&#13;
 730:   11000800        add     w0, w0, #0x2<br/>&#13;
 734:   910043ff        add     sp, sp, #0x10<br/>&#13;
 738:   d65f03c0        ret</p>&#13;
<p class="indent">Don’t worry if you don’t understand what’s going on just yet. We will cover assembly in greater detail in future sections. For now, let’s study the structure of these individual instructions.</p>&#13;
<p class="indent">Each line in the preceding example contains the instruction’s 64-bit address in program memory (shortened to the lowest three digits to save space), the bytes corresponding to the instruction, and the plaintext representation of the instruction itself. For example, <span class="literal">d10043ff</span> is the machine code representation of the instruction <span class="literal">sub sp, sp, #0x10</span>, and the instruction occurs at address <span class="literal">0x724</span> in code memory. Note that <span class="literal">0x724</span> is an abbreviation of the full 64-bit address associated with the <span class="literal">sub sp, sp #0x10</span> instruction; <span class="literal">objdump</span> omits the leading zeros to help with readability.</p>&#13;
<p class="indent">It is important to note that a single line of C code often translates to multiple instructions in assembly. The operation <span class="literal">a + 2</span> is represented by the three instructions at code memory addresses <span class="literal">0x728</span> through <span class="literal">0x730</span>: <span class="literal">str w0, [sp, #12]</span>, <span class="literal">ldr w0, [sp, #12]</span>, and <span class="literal">add w0, w0, #0x2</span>.</p>&#13;
<p class="note"><span epub:type="pagebreak" id="page_464"/><strong><span class="black">Warning</span> YOUR ASSEMBLY MAY LOOK DIFFERENT!</strong></p>&#13;
<p class="note-w">If you are compiling your code along with us, you may notice that some of your assembly examples look different. The precise assembly instructions that are output by a compiler depend on the generating compiler’s version, the precise architecture, and the underlying OS. Most of the assembly examples in this chapter were generated on a Raspberry Pi 3B+ running the 64-bit Ubuntu Mate operating system and using GCC. If you use a different OS, a different compiler, or a different Raspberry Pi or single-board computer, your assembly output may vary.</p>&#13;
<p class="note-w">In the examples that follow, we do not use any optimization flags. For example, we compile any example file (e.g. <span class="literal">example.c</span>) using the command <span class="literal">gcc -o example example.c</span>. Consequently, there are many seemingly redundant instructions in the examples that follow. Remember that the compiler is not “smart”—it simply follows a series of rules to translate human-readable code into machine language. During this translation process, it is not uncommon for some redundancy to occur. Optimizing compilers remove many of these redundancies during optimization, which is covered in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<h4 class="h4" id="lev2_163">9.1.1 Registers</h4>&#13;
<p class="noindent">Recall that a <em>register</em> is a word-sized storage unit located directly on the CPU. The ARMv8 CPU has a total of 31 registers for storing general-purpose 64-bit data: <span class="literal">x0</span> to <span class="literal">x30</span>. Whereas a program may interpret a register’s contents as integers or as addresses, the register itself makes no distinction. Programs can read from or write to all 31 registers.</p>&#13;
<p class="indent">The ARMv8-A ISA also specifies special-purpose registers. The first two worth noting are the <em>stack pointer</em> register (<span class="literal">sp</span>) and the <em>program counter</em> register (<span class="literal">pc</span>). The compiler reserves the <span class="literal">sp</span> register for maintaining the layout of the program stack. The <span class="literal">pc</span> register points to the next instruction to be executed by the CPU; unlike the other registers, programs cannot write directly to the <span class="literal">pc</span> register. Next, the <em>zero register</em> <span class="literal">zr</span> permanently stores the value 0, and is only useful as a source register.</p>&#13;
<h4 class="h4" id="lev2_164">9.1.2 Advanced Register Notation</h4>&#13;
<p class="noindent">Since ARMv8-A is an extension of the 32-bit ARMv7-A architecture, the A64 ISA provides mechanisms to access the lower 32 bits of each of the general-purpose registers, or <span class="literal">w0</span> through <span class="literal">w30</span>. <a href="ch09.xhtml#ch9fig1">Figure 9-1</a> shows a sample layout of register <span class="literal">x0</span>. If 32-bit data is stored in component register <span class="literal">w0</span>, then the upper 32 bits of the register become inaccessible, and are zeroed out.</p>&#13;
<div class="imagec" id="ch9fig1"><img alt="image" src="../images/09fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-1: Component register layout of register %x0</em></p>&#13;
<p class="note"><span epub:type="pagebreak" id="page_465"/><strong><span class="black">Warning</span> THE COMPILER MAY CHOOSE COMPONENT REGISTERS DEPENDING ON TYPE</strong></p>&#13;
<p class="note-w">When reading assembly code, keep in mind that the compiler typically uses the 64-bit registers when dealing with 64-bit values (e.g., pointers or <span class="literal">long</span> types) and the 32-bit component registers when dealing with 32-bit types (e.g., <span class="literal">int</span>). In A64, it is very common to see 32-bit component registers intermixed with the full 64-bit registers. For example, in the <span class="literal">adder2</span> function shown earlier, the compiler references component register <span class="literal">w0</span> instead of <span class="literal">x0</span> given that <span class="literal">int</span> types typically take up 32 bits (four bytes) of space on 64-bit systems. If the <span class="literal">adder2</span> function had a <span class="literal">long</span> parameter instead of an <span class="literal">int</span> parameter, the compiler would store <span class="literal">a</span> in register <span class="literal">x0</span> instead of component register <span class="literal">w0</span>.</p>&#13;
<p class="indent">For readers previously familiar with the A32 ISA, it is important to note that the 32-bit general-purpose registers <span class="literal">r0</span> to <span class="literal">r12</span> from the A32 ISA map to the A64 component registers <span class="literal">w0</span> to <span class="literal">w12</span>. The A64 ISA more than doubles the number of available registers.</p>&#13;
<h4 class="h4" id="lev2_165">9.1.3 Instruction Structure</h4>&#13;
<p class="noindent">Each instruction consists of an operation code (or <em>opcode</em>) that specifies what it does, and one or more <em>operands</em> that tells the instruction how to do it. For most A64 instructions, the following format is typically used:</p>&#13;
<p class="programs"><span class="codeitalic1">&lt;opcode&gt; &lt;D&gt;</span>, <span class="codeitalic1">&lt;O1&gt;</span>, <span class="codeitalic1">&lt;O2&gt;</span></p>&#13;
<p class="indent">Where <span class="literal"/> <span class="codeitalic">&lt;opcode&gt;</span> is the operation code, <span class="literal"/> <span class="codeitalic">&lt;D&gt;</span> is the destination register, <span class="literal"/> <span class="codeitalic">&lt;O1&gt;</span> is the first operand, and <span class="literal"/> <span class="codeitalic">&lt;O2&gt;</span> the second operand. For example, the instruction <span class="literal">add w0, w0, #0x2</span> has the opcode <span class="literal">add</span>, a destination register of <span class="literal">w0</span>, and the two operands <span class="literal">w0</span> and <span class="literal">#0x2</span>. There are multiple types of operands:</p>&#13;
<ul>&#13;
<li class="noindent"><em>Constant (literal)</em> values are preceded by the <span class="literal">#</span> sign. For example, in the instruction <span class="literal">add w0, w0, #0x2</span>, the operand <span class="literal">#0x2</span> is a literal value that corresponds to the hexadecimal value 0x2.</li>&#13;
<li class="noindent"><em>Register</em> forms refer to individual registers. The instruction <span class="literal">add</span> <span class="literal">sp, sp, #0x10</span> uses the stack pointer register <span class="literal">sp</span> to designate the destination register and the first of the two operands needed for the <span class="literal">add</span> instruction.</li>&#13;
<li class="noindent"><em>Memory</em> forms correspond to some value inside main memory (RAM) and are commonly used for address lookups. Memory address forms can contain a combination of registers and constant values. For example, in the instruction <span class="literal">str w0, [sp, #12]</span>, the operand <span class="literal">[sp,</span> <span class="literal">#12]</span> is an example of a memory form. It loosely translates to “add 12 to the value in register <span class="literal">sp</span>, and then perform a memory lookup on the corresponding address.” If this sounds like a pointer dereference, that’s because it is!</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_166">9.1.4 An Example with Operands</h4>&#13;
<p class="noindent">The best way to explain operands in detail is to present a quick example. Suppose that memory contains the following values:</p>&#13;
<span epub:type="pagebreak" id="page_466"/>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x808</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x80c</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x810</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x1E</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Let’s also assume that the following registers contain the values:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Register</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x0</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x1</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xC</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">w3</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x4</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Then the operands in <a href="ch09.xhtml#ch9tab1">Table 9-1</a> evaluate to the values shown there. Each row of the table matches an operand with its form (e.g., constant, register, memory), how it is translated, and its value.</p>&#13;
<p class="tabcap" id="ch9tab1"><strong>Table 9-1:</strong> Example Operands</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Operand</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Form</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x0</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Register</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x0</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">[x0]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(0x804)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">#0x804</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Constant</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">[x0, #8]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(<span class="literal">x0</span> + 8) or *(0x80c)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">[x0, x1]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(<span class="literal">x0</span> + <span class="literal">x1</span>) or *(0x810)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x1E</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">[x0, w3, SXTW]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">(Sign-extend) memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(<span class="literal">x0</span> + SignExtend(<span class="literal">w3</span>)) or *(0x808)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">[x0, x2, LSL, #2]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Scaled memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(<span class="literal">x0</span> + (<span class="literal">x2 ≪ 2</span>)) or *(0x80c)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">[x0, w3, SXTW, #1]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">(Sign-extend) scaled memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(<span class="literal">x0</span> + SignExtend(<span class="literal">w3 ≪ 1</span>)) or *(0x80c)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9tab1">Table 9-1</a>, the notation <span class="literal">x0</span> indicates the value stored in 64-bit register <span class="literal">x0</span>, whereas <span class="literal">w3</span> indicates a 32-bit value stored in component register <span class="literal">w3</span>. The operand <span class="literal">[x0]</span> indicates that the value inside <span class="literal">x0</span> should be treated as an address, and to dereference (look up) the value at that address. Therefore, the operand <span class="literal">[x0]</span> corresponds to *(0x804) or the value 0xCA. An operation on a 32-bit register can be combined with a 64-bit register using the sign-extend word (<span class="literal">SXTW</span>) instruction. So, <span class="literal">[x0, w3, SXTW]</span> sign extends <span class="literal">w3</span> into a 64-bit value before adding it to <span class="literal">x0</span> and performing a memory lookup. Lastly, scaled memory types enable the calculation of offsets through the use of a left shift.</p>&#13;
<p class="indent">A few important notes before continuing. Although <a href="ch09.xhtml#ch9tab1">Table 9-1</a> shows many valid operand forms, not all forms can be used interchangeably in all circumstances.</p>&#13;
<p class="indent">Specifically:</p>&#13;
<ul>&#13;
<li class="noindent">Data cannot be read or written to memory directly; instead, ARM follows a load/store model, which requires data to be operated on <span epub:type="pagebreak" id="page_467"/>in registers. Thus, data must be transferred to registers before being operated on, and transferred back to memory after the operations are complete.</li>&#13;
<li class="noindent">The destination component of an instruction must always be a register.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab1">Table 9-1</a> is provided as a reference; however, understanding key operand forms will help improve the reader’s speed in parsing assembly language.</p>&#13;
<h3 class="h3" id="lev1_74">9.2 Common Instructions</h3>&#13;
<p class="noindent">In this section, we discuss several common ARM assembly instructions. <a href="ch09.xhtml#ch9tab2">Table 9-2</a> lists the most foundational instructions in ARM assembly.</p>&#13;
<p class="tabcap" id="ch9tab2"><strong>Table 9-2:</strong> Most Common Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ldr D, [addr]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = *(addr)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(loads the value in memory into register D)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">str S, [addr]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(addr) = S</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(stores S into memory location *(addr))</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mov D, S</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = S</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(copies value of S into D)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">add D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 + O2</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(adds O1 to O2 and stores result in D)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sub D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 – O2</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(subtracts O2 from O1 and stores result in D)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Therefore, the sequence of instructions</p>&#13;
<p class="programs">str     w0, [sp, #12]<br/>&#13;
ldr     w0, [sp, #12]<br/>&#13;
add     w0, w0, #0x2</p>&#13;
<p class="noindent">translates to:</p>&#13;
<ul>&#13;
<li class="noindent">Store the value in register <span class="literal">w0</span> in the <em>memory</em> location specified by <span class="literal">sp</span> + 12 (or <span class="literal">*(sp + 12)</span>).</li>&#13;
<li class="noindent">Load the value <em>from</em> memory location <span class="literal">sp</span> + 12 (or <span class="literal">*(sp + 12)</span>) into register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">Add the value 0x2 to register <span class="literal">w0</span>, and store the result in register <span class="literal">w0</span> (or <span class="literal">w0</span> = <span class="literal">w0</span> + 0x2).</li>&#13;
</ul>&#13;
<p class="indent">The <span class="literal">add</span> and <span class="literal">sub</span> instructions shown in <a href="ch09.xhtml#ch9tab2">Table 9-2</a> also assist with maintaining the organization of the program stack (i.e., the <em>call stack</em>). Recall that the <em>stack pointer</em> (<span class="literal">sp</span>) is reserved by the compiler for call stack management. Recall also from our earlier discussion on program memory in “Parts of Program Memory and Scope” on <a href="ch02.xhtml#lev1_9">page 64</a> that the call stack typically stores local variables and parameters and helps the program track its own execution (see <a href="ch09.xhtml#ch9fig2">Figure 9-2</a>). On ARM systems, the execution stack grows toward <em>lower</em> addresses. Like all stack data structures, operations occur at the “top” of the call stack; <span class="literal">sp</span> therefore “points” to the top of the stack, and its value is the address of top of the stack.</p>&#13;
<span epub:type="pagebreak" id="page_468"/>&#13;
<div class="imagec" id="ch9fig2"><img alt="image" src="../images/09fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-2: The parts of a program’s address space</em></p>&#13;
<p class="indent">The <span class="literal">ldp</span> and <span class="literal">stp</span> instructions shown in <a href="ch09.xhtml#ch9tab3">Table 9-3</a> assist with moving multiple memory locations, usually either on or off the program stack. As shown in <a href="ch09.xhtml#ch9tab3">Table 9-3</a>, the register <span class="literal">x0</span> holds a memory address.</p>&#13;
<p class="tabcap" id="ch9tab3"><strong>Table 9-3:</strong> Some Instructions for Accessing Multiple Memory Locations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ldp D1, D2, [x0]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D1 = *(x0), D2 = *(x0+8) (loads the value at x0 and</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">X0+8 into registers D1 and D2, respectively)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ldp D1, D2, [x0, #0x10]!</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">x0 = x0 + 0x10, then sets D1 = *(x0), D2 = *(x0+8)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ldp D1, D2, [x0], #0x10</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D1 = *(x0), D2 = *(x0+8), then sets x0 = x0 + 0x10</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">stp S1, S2, [x0]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">*(x0) = S1, *(x0+8) = S2 (stores S1 and S2 at</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">locations *(x0) and *(x0+8), respectively)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">stp S1, S2, [x0, #-16]!</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">sets x0 = x0 – 16, then stores *(x0) = S1, *(x0+8) = S2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">stp S1, S2, [x0], #-16</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">stores *(x0) = S1, *(x0+8) = S2 then sets x0 = x0 – 16</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In short, the <span class="literal">ldp</span> instruction loads a pair of values from the memory locations held in register <span class="literal">x0</span> and at an offset of eight from that memory location (i.e., <span class="literal">x0</span>+0x8) into the destination registers D1 and D2, respectively. Meanwhile, the <span class="literal">stp</span> instruction stores the pair of values in source registers S1 and S2 to the memory locations held in register <span class="literal">x0</span> and at an offset of eight from that address (i.e., <span class="literal">x0</span>+0x8). Note that the assumption here is that the values in the registers are 64-bit quantities. If 32-bit registers are being used instead, the memory offsets change to <span class="literal">x0</span> and <span class="literal">x0</span>+0x4, respectively.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_469"/>There are also two special forms of the <span class="literal">ldp</span> and <span class="literal">stp</span> instructions that enable simultaneous updates to <span class="literal">x0</span>. For example, the instruction <span class="literal">stp S1, S2, [x0,</span> <span class="literal">#-16]!</span> implies that 16 bytes should <em>first</em> be subtracted from <span class="literal">x0</span>, and only afterward should S1 and S2 be stored at the offsets <span class="literal">[x0]</span> and <span class="literal">[x0+8]</span>. In contrast, the instruction <span class="literal">ldp D1, D2, [x0], #0x10</span> states that the values at offsets <span class="literal">[x0]</span> and <span class="literal">[x0+8]</span> should first be stored in destination registers D1 and D2, and <em>only afterward</em> should <span class="literal">x0</span> have 16 bytes added to it. These special forms are commonly used at the beginning and end of functions that have multiple function calls, as we will see later.</p>&#13;
<h4 class="h4" id="lev2_167">9.2.1 Putting It All Together: A More Concrete Example</h4>&#13;
<p class="noindent">Let’s take a closer look at the <span class="literal">adder2</span> function</p>&#13;
<p class="programs">//adds two to an integer and returns the result<br/>&#13;
int adder2(int a) {<br/>&#13;
    return a + 2;<br/>&#13;
}</p>&#13;
<p class="noindent">and its corresponding assembly code:</p>&#13;
<p class="programs">0000000000000724 &lt;adder2&gt;:<br/>&#13;
 724:   d10043ff        sub     sp, sp, #0x10<br/>&#13;
 728:   b9000fe0        str     w0, [sp, #12]<br/>&#13;
 72c:   b9400fe0        ldr     w0, [sp, #12]<br/>&#13;
 730:   11000800        add     w0, w0, #0x2<br/>&#13;
 734:   910043ff        add     sp, sp, #0x10<br/>&#13;
 738:   d65f03c0        ret</p>&#13;
<p class="indent">The assembly code consists of a <span class="literal">sub</span> instruction, followed by <span class="literal">str</span> and <span class="literal">ldr</span> instructions, two <span class="literal">add</span> instructions, and finally a <span class="literal">ret</span> instruction. To understand how the CPU executes this set of instructions, we need to revisit the structure of program memory (see “Parts of Program Memory and Scope” on <a href="ch02.xhtml#lev1_9">page 64</a>). Recall that every time a program executes, the operating system allocates the new program’s address space (also known as <em>virtual memory</em>). Virtual memory and the related concept of processes are covered in greater detail in <a href="ch13.xhtml#ch13">Chapter 13</a>; for now, it suffices to think of a process as the abstraction of a running program and virtual memory as the memory that is allocated to a single process. Every process has its own region of memory called the <em>call stack</em>. Keep in mind that the call stack is located in process/virtual memory, unlike registers (which are located in the CPU).</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9fig3">Figure 9-3</a> depicts a sample state of the call stack and registers prior to the execution of the <span class="literal">adder2</span> function.</p>&#13;
<span epub:type="pagebreak" id="page_470"/>&#13;
<div class="imagec" id="ch9fig3"><img alt="image" src="../images/09fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-3: Execution stack prior to execution</em></p>&#13;
<p class="indent">Notice that the stack grows toward <em>lower</em> addresses. The parameter to the <span class="literal">adder2</span> function (or <span class="literal">a</span>) is stored in register <span class="literal">x0</span> by convention. Since <span class="literal">a</span> is of type <span class="literal">int</span>, it is stored in component register <span class="literal">w0</span>, as shown in <a href="ch09.xhtml#ch9fig3">Figure 9-3</a>. Likewise, since the <span class="literal">adder2</span> function returns an <span class="literal">int</span>, component register <span class="literal">w0</span> is used for the return value instead of <span class="literal">x0</span>.</p>&#13;
<p class="indent">The addresses associated with the instructions in the code segment of program memory have been shortened to 0x724–0x738 to improve figure readability. Likewise, the addresses associated with the call stack segment of program memory have been shortened to 0xe40–0xe50 from 0xffffffffee40–0xffffffffee50. In truth, call stack addresses occur at much higher addresses in program memory than code segment addresses.</p>&#13;
<p class="indent">Pay close attention to the initial values of registers <span class="literal">sp</span> and <span class="literal">pc</span>: they are 0xe50 and 0x724, respectively. The <span class="literal">pc</span> register (or program counter) indicates the next instruction to execute, and the address 0x724 corresponds to the first instruction in the <span class="literal">adder2</span> function. The upper-left arrow in the following figures visually indicates the currently executing instruction.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0470-01.jpg"/></div>&#13;
<p class="indent">The first instruction (<span class="literal">sub sp, sp, #0x10</span>) subtracts the constant value 0x10 from the stack pointer, and updates the stack pointer with the new result. Since the stack pointer contains the address of the top of the stack, this <span epub:type="pagebreak" id="page_471"/>operation <em>grows</em> the stack by 16 bytes. The stack pointer now contains the address 0xe40, whereas the program counter (<span class="literal">pc</span>) register contains the address of the next instruction to execute, or 0x728.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0471-01.jpg"/></div>&#13;
<p class="indent">Recall that the <span class="literal">str</span> instruction <em>stores</em> a value located in a register into memory. Thus, the next instruction (<span class="literal">str w0, [sp, #12]</span>) places the value in <span class="literal">w0</span> (the value of <span class="literal">a</span>, or 0x28) at call stack location <span class="literal">sp</span> + 12, or 0xe4c. Note that this instruction does not modify the contents of register <span class="literal">sp</span> in any way; it simply stores a value on the call stack. Once this instruction executes, <span class="literal">pc</span> advances to the address of the next instruction, or 0x72c.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0471-02.jpg"/></div>&#13;
<p class="indent">Next, <span class="literal">ldr w0, [sp, #12]</span> executes. Recall that the <span class="literal">ldr</span> instruction <em>loads</em> a value in memory into a register. By executing this instruction, the CPU replaces the value in register <span class="literal">w0</span> with the value located at stack address <span class="literal">sp</span> + 12. Even though this may seem like a nonsensical operation (0x28 is replaced by 0x28, after all), it highlights a convention where the compiler typically stores function parameters onto the call stack for later use and then reloads them into registers as needed. Again, the value stored in the <span class="literal">sp</span> register is not affected by the <span class="literal">str</span> operation. As far as the program is concerned, the “top” of the stack is still 0xe40. Once the <span class="literal">ldr</span> instruction executes, <span class="literal">pc</span> advances to address 0x730.</p>&#13;
<span epub:type="pagebreak" id="page_472"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0472-01.jpg"/></div>&#13;
<p class="indent">Afterward, <span class="literal">add w0, w0, #0x2</span> executes. Recall that the <span class="literal">add</span> instruction has the form <span class="literal">add D, O1, O2</span> and places O1 + O2 in the destination register D. So, <span class="literal">add w0, w0, #0x2</span> adds the constant value 0x2 to the value stored in <span class="literal">w0</span> (0x28), resulting in 0x2A being stored in register <span class="literal">w0</span>. Register <span class="literal">pc</span> advances to the next instruction to be executed, or 0x734.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0472-02.jpg"/></div>&#13;
<p class="indent">The next instruction that executes is <span class="literal">add sp, sp, #0x10</span>. This instruction adds 16 bytes to the address stored in <span class="literal">sp</span>. Since the stack grows toward lower addresses, adding 16 bytes to the stack pointer consequently <em>shrinks</em> the stack, and reverts <span class="literal">sp</span> to its original value of 0xe50. The <span class="literal">pc</span> register then advances to 0x738.</p>&#13;
<p class="indent">Recall that the purpose of the call stack is to store the temporary data that each function uses as it executes in the context of a larger program. By convention, the stack “grows” at the beginning of a function call, and reverts to its original state when the function ends. As a result, it is common to see a <span class="literal">sub sp, sp, #v</span> instruction (where <span class="literal">v</span> is some constant value) at the beginning of a function, and <span class="literal">add sp, sp, #v</span> at the end.</p>&#13;
<span epub:type="pagebreak" id="page_473"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0473-01.jpg"/></div>&#13;
<p class="indent">The last instruction that executes is <span class="literal">ret</span>. We will talk more about what <span class="literal">ret</span> does in future sections when we discuss function calls, but for now it suffices to know that <span class="literal">ret</span> prepares the call stack for returning from a function. By convention, the register <span class="literal">x0</span> always contains the return value (if one exists). In this case, since <span class="literal">adder2</span> is of type <span class="literal">int</span>, the return value is stored in component register <span class="literal">w0</span> and the function returns the value 0x2A, or 42.</p>&#13;
<h3 class="h3" id="lev1_75">9.3 Arithmetic Instructions</h3>&#13;
<h4 class="h4" id="lev2_168">9.3.1 Common Arithmetic Instructions</h4>&#13;
<p class="noindent">The A64 ISA implements several instructions that correspond to arithmetic operations performed by the ALU. <a href="ch09.xhtml#ch9tab4">Table 9-4</a> lists several arithmetic instructions that one may encounter when reading ARM assembly.</p>&#13;
<p class="tabcap" id="ch9tab4"><strong>Table 9-4:</strong> Common Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">add D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 + O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sub D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 – O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">neg D, O1</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = –(O1)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <span class="literal">add</span> and <span class="literal">sub</span> instructions correspond to addition and subtraction and require two operands in addition to the destination register. In contrast, the <span class="literal">neg</span> instruction requires only one operand in addition to the destination register.</p>&#13;
<p class="indent">The three instructions in <a href="ch09.xhtml#ch9tab4">Table 9-4</a> also have <em>carry</em> forms that enable the instruction to use the optional carry condition flag, <span class="literal">C</span>. The one-bit carry flag is set when an unsigned operation overflows. We cover other condition control flags in the following section, but describe the carry flag here to introduce the additional arithmetic instructions. The carry forms and their rough translation are shown in <a href="ch09.xhtml#ch9tab5">Table 9-5</a>.</p>&#13;
<p class="tabcap" id="ch9tab5"><span epub:type="pagebreak" id="page_474"/><strong>Table 9-5:</strong> Carry Forms for Common Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:45%"/>&#13;
<col style="width:55%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">adc D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 + O2 + <span class="literal">C</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sbc D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 – O2 – <span class="literal">~C</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ngc D, O1</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = –(O1) – <span class="literal">~C</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The preceding instructions also have an optional <span class="literal">s</span> suffix. When the <span class="literal">s</span> suffix is used (e.g., <span class="literal">adds</span>), it indicates that the arithmetic operation is setting condition flags.</p>&#13;
<h5 class="h5" id="lev3_72">9.3.1.1 Multiplication and Division</h5>&#13;
<p class="tabcap" id="ch9tab6"><strong>Table 9-6:</strong> Common Multiplication and Division Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mul D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 × O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">udiv D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 / O2 (32-bit unsigned)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sdiv D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 / O2 (64-bit signed)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="noindent">The most common multiplication and division instructions are shown in <a href="ch09.xhtml#ch9tab6">Table 9-6</a>. The <span class="literal">mul</span> instruction operates on two operands and places the product in the destination D. The division operation does <em>not</em> have a generic form; the <span class="literal">udiv</span> and <span class="literal">sdiv</span> instructions operate on 32-bit and 64-bit data, respectively. Note that you cannot multiply 32-bit registers with 64-bit registers.</p>&#13;
<p class="indent">In addition, ARMv8-A provides composite forms for multiplication, allowing the CPU to perform more sophisticated operations in a single instruction. These instructions are shown in <a href="ch09.xhtml#ch9tab7">Table 9-7</a>.</p>&#13;
<p class="tabcap" id="ch9tab7"><strong>Table 9-7:</strong> Composite Multiplication Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">madd D, O1, O2, O3</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O3 + (O1 × O2)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">msub D, O1, O2, O3</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O3 – (O1 × O2)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mneg D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = –(O1 × S2)</p></td>&#13;
</tr>&#13;
</table>&#13;
<h4 class="h4" id="lev2_169">9.3.2 Bit Shifting Instructions</h4>&#13;
<p class="noindent">Bit shifting instructions enable the compiler to perform bit shifting operations. Multiplication and division instructions typically take a long time to execute. Bit shifting offers the compiler a shortcut for multiplicands and divisors that are powers of 2. For example, to compute <span class="literal">77 * 4</span>, most compilers will translate this operation to <span class="literal">77 ≪ 2</span> to avoid the use of a <span class="literal">mul</span> instruction. Likewise, to compute <span class="literal">77 / 4</span>, a compiler typically translates this operation to <span class="literal">77 ≫ 2</span> to avoid using the <span class="literal">sdiv</span> instruction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_475"/>Keep in mind that left and right bit shifts translate to different instructions based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.</p>&#13;
<p class="tabcap" id="ch9tab8"><strong>Table 9-8:</strong> Bit Shift Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Arithmetic or logical?</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lsl D, R, #v</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = R <span class="literal">≪</span> v</p></td>&#13;
<td style="vertical-align: top"><p class="tab">logical or arithmetic</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lsr D, R, #v</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = R <span class="literal">≫</span> v</p></td>&#13;
<td style="vertical-align: top"><p class="tab">logical</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">asr D, R, #v</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = R <span class="literal">≫</span> v</p></td>&#13;
<td style="vertical-align: top"><p class="tab">arithmetic</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ror D, R, #v</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = R <span class="literal">≫&gt;</span> v</p></td>&#13;
<td style="vertical-align: top"><p class="tab">neither (rotate)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In addition to the destination register, each shift instruction takes two operands; one is usually a register (denoted by R) and the other is a 6-bit shift value (v). On 64-bit systems, the shift value is encoded as a single byte (since it doesn’t make sense to shift past 63). The shift value v must either be a constant or stored in a component register.</p>&#13;
<p class="indent">The last bit shifting instruction, <span class="literal">ror</span>, requires special discussion. The <span class="literal">ror</span> instruction <em>rotates</em> the bits, replacing the most significant bits with the least significant bits. We represent the rotate shift instruction using the <span class="literal">≫&gt;</span> symbol.</p>&#13;
<p class="note"><strong><span class="black">Note</span> DIFFERENT VERSIONS OF INSTRUCTIONS HELP US DISTINGUISH TYPES AT AN ASSEMBLY LEVEL</strong></p>&#13;
<p class="note1">At the assembly level, there is no notion of types. However, recall that the compiler can choose to use component registers based on the types present at the code level. Similarly, recall that shift right works differently depending on whether the value is signed or unsigned. At the assembly level, the compiler uses separate instructions to distinguish between logical and arithmetic shifts!</p>&#13;
<h4 class="h4" id="lev2_170">9.3.3 Bitwise Instructions</h4>&#13;
<p class="noindent">Bitwise instructions enable the compiler to perform bitwise operations on data. One way in which the compiler uses bitwise operations is for certain optimizations. For example, a compiler may choose to implement 77 mod 4 with the operation <span class="literal">77 &amp; 3</span> in lieu of the more expensive <span class="literal">sdiv</span> instruction.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab9">Table 9-9</a> lists common bitwise instructions, and composite bitwise instructions that utilize negation.</p>&#13;
<p class="tabcap" id="ch9tab9"><span epub:type="pagebreak" id="page_476"/><strong>Table 9-9:</strong> Bitwise Operations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">and D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 <span class="literal">&amp;</span> O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">orr D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 <span class="literal">|</span> O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">eor D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 <span class="literal">^</span> O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mvn D, O</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = <span class="literal">~</span>O</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">bic D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 <span class="literal">&amp; ~</span>O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">orn D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 <span class="literal">| ~</span>O2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">eon D, O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D = O1 <span class="literal">^ ~</span>O2</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Remember that bitwise <span class="literal">not</span> is distinct from negation (<span class="literal">neg</span>). The <span class="literal">mvn</span> instruction flips the bits of the operand but does not add 1. Be careful not to confuse these two instructions.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!</strong></p>&#13;
<p class="note-w">After reading this section, it may be tempting to replace common arithmetic operations in your C code with bitwise shifts and other operations. This is <em>not</em> recommended. Most modern compilers are smart enough to replace simple arithmetic operations with bitwise operations when it makes sense, making it unnecessary for the programmer to do so. As a general rule, programmers should prioritize code readability whenever possible and avoid premature optimization.</p>&#13;
<h3 class="h3" id="lev1_76">9.4 Conditional Control and Loops</h3>&#13;
<p class="noindent">This section covers assembly instructions for conditionals and loops (see “Conditionals and Loops” on <a href="ch01.xhtml#lev1_3">page 30</a>). Recall that conditional statements enable coders to modify program execution based on the result of a conditional expression. The compiler translates conditionals into assembly instructions that modify the instruction pointer (<span class="literal">pc</span>) to point to an address that is not the next one in the program sequence.</p>&#13;
<h4 class="h4" id="lev2_171">9.4.1 Preliminaries</h4>&#13;
<h5 class="h5" id="lev3_73">Conditional Comparison Instructions</h5>&#13;
<p class="noindent">Comparison instructions perform an arithmetic operation for the purpose of guiding the conditional execution of a program. <a href="ch09.xhtml#ch9tab10">Table 9-10</a> lists the basic instructions associated with conditional control.</p>&#13;
<p class="tabcap" id="ch9tab10"><strong>Table 9-10:</strong> Conditional Control Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cmp O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Compares O1 with O2 (computes O1 – O2)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">tst O1, O2</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Computes O1 <span class="literal">&amp;</span> O2</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_477"/>The <span class="literal">cmp</span> instruction compares the value of two operands, O1 and O2. Specifically, it subtracts O2 from O1. The <span class="literal">tst</span> instruction performs bitwise AND. It is common to see an instruction like:</p>&#13;
<p class="programs">tst x0, x0</p>&#13;
<p class="indent">In this example, the bitwise AND of <span class="literal">x0</span> with itself is zero only when <span class="literal">x0</span> contains zero. In other words, this is a test for a zero value and is equivalent to the following:</p>&#13;
<p class="programs">cmp x0, #0</p>&#13;
<p class="indent">Unlike the arithmetic instructions covered thus far, <span class="literal">cmp</span> and <span class="literal">tst</span> do not modify a destination register. Instead, both instructions modify a series of single-bit values known as <em>condition code flags</em>. For example, <span class="literal">cmp</span> will modify condition code flags based on whether the value O1 – O2 results in a positive (greater), negative (less), or zero (equal) value. Recall that condition code values encode information about an operation in the ALU (see “The ALU” on <a href="ch05.xhtml#lev2_100">page 261</a>). The condition code flags are part of the ARM processor state (<span class="literal">PSTATE</span>), which replaces the current program status register (<span class="literal">CPSR</span>) from ARMv7-A systems.</p>&#13;
<p class="tabcap" id="ch9tab11"><strong>Table 9-11:</strong> Common Condition Code Flags</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:85%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Flag</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">Z</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Is equal to zero (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">N</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Is negative (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">V</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Signed overflow has occurred (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">C</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Arithmetic carry/unsigned overflow has occurred (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab11">Table 9-11</a> depicts the common flags used for condition code operations. Revisiting the <span class="literal">cmp O1, O2</span> instruction:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">Z</span> flag is set to 1 if O1 and O2 are equal.</li>&#13;
<li class="noindent">The <span class="literal">N</span> flag is set to 1 if O1 is <em>less</em> than O2 (O1 – O2 results in a negative value).</li>&#13;
<li class="noindent">The <span class="literal">V</span> flag is set to 1 if the operation O1 – O2 results in overflow (useful for signed comparisons).</li>&#13;
<li class="noindent">The <span class="literal">C</span> flag is set to 1 if the operation O1 – O2 results in an arithmetic carry operation (useful for unsigned comparisons).</li>&#13;
</ul>&#13;
<p class="indent">While an in-depth discussion of condition code flags is beyond the scope of this book, the setting of these registers by <span class="literal">cmp</span> and <span class="literal">tst</span> enables the next set of instructions we cover (the <em>branch</em> instructions) to operate correctly.</p>&#13;
<h5 class="h5" id="lev3_74">Branch Instructions</h5>&#13;
<p class="noindent">A branch instruction enables a program’s execution to “jump” to a new position in the code. In the assembly programs we have traced through thus <span epub:type="pagebreak" id="page_478"/>far, <span class="literal">pc</span> always points to the next instruction in program memory. The branch instructions enable <span class="literal">pc</span> to be set to either a new instruction not yet seen (as in the case of an <span class="literal">if</span> statement) or to a previously executed instruction (as in the case of a loop).</p>&#13;
<p class="tabcap" id="ch9tab12"><strong>Table 9-12:</strong> Common Branch Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:75%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">b addr L</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">pc</span> = addr</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">br A</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">pc</span> = A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cbz R, addr L</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">If R is equal to 0, <span class="literal">pc</span> = addr (conditional branch)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cbnz R, addr L</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">If R is not equal to 0, <span class="literal">pc</span> = addr (conditional branch)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">b.c addr L</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">If c, <span class="literal">pc</span> = addr (conditional branch)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="noindent"><strong>Direct branch instructions</strong>   <a href="ch09.xhtml#ch9tab12">Table 9-12</a> lists the set of common branch instructions; L refers to a <em>symbolic label</em>, which serves as an identifier in the program’s object file. All labels consist of some letters and digits followed by a colon. Labels can be <em>local</em> or <em>global</em> to an object file’s scope. Function labels tend to be <em>global</em> and usually consist of the function name and a colon. For example, <span class="literal">main:</span> (or <span class="literal">&lt;main&gt;:</span>) is used to label a user-defined <span class="literal">main</span> function. In contrast, labels whose scope are <em>local</em> are preceded by a period. For example, <span class="literal">.L1:</span> is a label one may encounter in the context of an <span class="literal">if</span> statement or loop.</p>&#13;
<p class="indent">All labels have an associated address (<span class="literal">addr</span> in <a href="ch09.xhtml#ch9tab12">Table 9-12</a>). When the CPU executes a <span class="literal">b</span> instruction, it sets the <span class="literal">pc</span> register to <span class="literal">addr</span>. The <span class="literal">b</span> instruction enables the program counter to change within 128 MB of its current location; a programmer writing assembly can also specify a particular address to branch to by using the <span class="literal">br</span> instruction. Unlike the <span class="literal">b</span> instruction, there are no restrictions on the address range of <span class="literal">br</span>.</p>&#13;
<p class="indent">Sometimes, local labels also are shown as an offset from the start of a function. Therefore, an instruction whose address is 28 bytes away from the start of <span class="literal">main</span> may be represented with the label <span class="literal">&lt;main+28&gt;</span>. For example, the instruction <span class="literal">b</span> <span class="literal">0x7d0 &lt;main+28&gt;</span> indicates a branch to address 0x7d0, which has the associated label <span class="literal">&lt;main+28&gt;</span>, meaning that it is 28 bytes away from the starting address of the <span class="literal">main</span> function. Executing this instruction sets <span class="literal">pc</span> to 0x7d0.</p>&#13;
<p class="indent">The last three instructions are <em>conditional branch instructions</em>. In other words, the program counter register is set to <span class="literal">addr</span> only if the given condition evaluates to true. The <span class="literal">cbz</span> and <span class="literal">cbnz</span> instructions require a register in addition to an address. In the case of <span class="literal">cbz</span>, if R is zero, the branch is taken and <span class="literal">pc</span> is set to <span class="literal">addr</span>. In the case of <span class="literal">cbnz</span>, if R is nonzero, the branch is taken and <span class="literal">pc</span> is set to <span class="literal">addr</span>.</p>&#13;
<p class="indent">The most powerful of the conditional branch instructions are the <span class="literal">b.c</span> instructions, which enable the compiler or assembly writer to pick a custom suffix that indicates the condition on which a branch is taken.</p>&#13;
<p class="noindentt"><strong>Conditional branch instruction suffixes</strong>   <a href="ch09.xhtml#ch9tab13">Table 9-13</a> lists the set of common conditional branch suffixes (c). When used in conjunction with a branch, each instruction starts with the letter <span class="literal">b</span> and a dot, denoting that it is a branch <span epub:type="pagebreak" id="page_479"/>instruction. The suffix of each instruction (c) indicates the <em>condition</em> for the branch. The branch instruction suffixes also determine whether to interpret numerical comparisons as signed or unsigned. Note that conditional branch instructions have a much more limited range (1 MB) than the <span class="literal">b</span> instruction. These suffixes are also used for the conditional select instruction (<span class="literal">csel</span>), which is covered in the next section.</p>&#13;
<p class="tabcap" id="ch9tab13"><strong>Table 9-13:</strong> Conditional Branch Instruction Suffixes (synonyms shown in parentheses)</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Signed Comparison</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Unsigned Comparison</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">eq</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">eq</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if equal (==) or branch if zero</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ne</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ne</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if not equal (!=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mi</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mi</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if minus (negative)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">pl</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">pl</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if non-negative (&gt;= 0)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">gt</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">hi</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if greater than (higher) (&gt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ge</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">cs</span> (<span class="literal">hs</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if greater than or equal (&gt;=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lt</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">lo</span> (<span class="literal">cc</span>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if less than (&lt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">le</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ls</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">branch if less than or equal (&lt;=)</p></td>&#13;
</tr>&#13;
</table>&#13;
<h5 class="h5" id="lev3_75">The goto Statement</h5>&#13;
<p class="noindent">In the following subsections, we look at conditionals and loops in assembly and reverse engineer them back to C. When translating assembly code of conditionals and loops back into C, it is useful to understand their corresponding C language <span class="literal">goto</span> forms. The <span class="literal">goto</span> statement is a C primitive that forces program execution to switch to another line in the code. The assembly instruction associated with the <span class="literal">goto</span> statement is <span class="literal">b</span>.</p>&#13;
<p class="indent">The <span class="literal">goto</span> statement consists of the <span class="literal">goto</span> keyword followed by a <em>goto label</em>, a type of program label that indicates that execution should continue at the corresponding label. So, <span class="literal">goto done</span> means that the program execution should branch to the line marked by label <span class="literal">done</span>. Other examples of program labels in C include the <span class="literal">switch</span> statement labels previously covered in “switch Statements” on <a href="ch02.xhtml#lev2_36">page 122</a>.</p>&#13;
<p class="indent">The following code listings depict a function <span class="literal">getSmallest</span> written in regular C code (first) and its associated <span class="literal">goto</span> form in C (second). The <span class="literal">getSmallest</span> function compares the value of two integers (<span class="literal">x</span> and <span class="literal">y</span>), and assigns the smaller value to variable <span class="literal">smallest</span>.</p>&#13;
<p class="margnote">Regular C version</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if ( x &gt; y ) { //if (conditional)<br/>&#13;
        smallest = y; //then statement<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x; //else statement<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<span epub:type="pagebreak" id="page_480"/>&#13;
<p class="margnote">goto version</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
<br/>&#13;
    if (x &lt;= y ) { //if (!conditional)<br/>&#13;
        goto else_statement;<br/>&#13;
    }<br/>&#13;
    smallest = y; //then statement<br/>&#13;
    goto done;<br/>&#13;
<br/>&#13;
else_statement:<br/>&#13;
    smallest = x; //else statement<br/>&#13;
<br/>&#13;
done:<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">goto</span> form of this function may seem counterintuitive, but let’s discuss what exactly is going on. The conditional checks to see whether variable <span class="literal">x</span> is less than or equal to <span class="literal">y</span>.</p>&#13;
<ul>&#13;
<li class="noindent">If <span class="literal">x</span> is less than or equal to <span class="literal">y</span>, the program transfers control to the label marked by <span class="literal">else_statement</span>, which contains the single statement <span class="literal">smallest = x</span>. Since the program executes linearly, the program continues on to execute the code under the label <span class="literal">done</span>, which returns the value of <span class="literal">smallest</span> (<span class="literal">x</span>).</li>&#13;
<li class="noindent">If <span class="literal">x</span> is greater than <span class="literal">y</span>, then <span class="literal">smallest</span> is set to <span class="literal">y</span>. The program then executes the statement <span class="literal">goto done</span>, which transfers control to the <span class="literal">done</span> label, which returns the value of <span class="literal">smallest</span> (<span class="literal">y</span>).</li>&#13;
</ul>&#13;
<p class="indent">Although <span class="literal">goto</span> statements were commonly used in the early days of programming, their use in modern code is considered bad practice because it reduces the overall readability of code. In fact, computer scientist Edsger Dijkstra wrote a famous paper lambasting the use of <span class="literal">goto</span> statements called “Go To Statement Considered Harmful.”<sup><a href="ch09.xhtml#fn9_4" id="rfn9_4">4</a></sup></p>&#13;
<p class="indent">In general, well-designed C programs do not use <span class="literal">goto</span> statements, and programmers are discouraged from using them to avoid writing code that is difficult to read, debug, and maintain. However, the C <span class="literal">goto</span> statement is important to understand, as GCC typically changes C code with conditionals into a <span class="literal">goto</span> form prior to translating it to assembly, including code that contains <span class="literal">if</span> statements and loops.</p>&#13;
<p class="indent">The following subsections cover the assembly representation of <span class="literal">if</span> statements and loops in greater detail.</p>&#13;
<h4 class="h4" id="lev2_172">9.4.2 if Statements in Assembly</h4>&#13;
<p class="noindent">Let’s take a look at the <span class="literal">getSmallest</span> function in assembly. For convenience, the function is reproduced here.</p>&#13;
<span epub:type="pagebreak" id="page_481"/>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if ( x &gt; y ) {<br/>&#13;
        smallest = y;<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x;<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="indent">The corresponding assembly code extracted from GDB looks similar to the following:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">disas getSmallest</span><br/>&#13;
Dump of assembler code for function getSmallest:<br/>&#13;
0x07f4 &lt;+0&gt;:    sub  sp, sp, #0x20<br/>&#13;
0x07f8 &lt;+4&gt;:    str  w0, [sp, #12]<br/>&#13;
0x07fc &lt;+8&gt;:    str  w1, [sp, #8]<br/>&#13;
0x0800 &lt;+12&gt;:   ldr  w1, [sp, #12]<br/>&#13;
0x0804 &lt;+16&gt;:   ldr  w0, [sp, #8]<br/>&#13;
0x0808 &lt;+20&gt;:   cmp  w1, w0<br/>&#13;
0x080c &lt;+24&gt;:   b.le 0x81c &lt;getSmallest+40&gt;<br/>&#13;
0x0810 &lt;+28&gt;:   ldr  w0, [sp, #8]<br/>&#13;
0x0814 &lt;+32&gt;:   str  w0, [sp, #28]<br/>&#13;
0x0818 &lt;+36&gt;:   b    0x824 &lt;getSmallest+48&gt;<br/>&#13;
0x081c &lt;+40&gt;:   ldr  w0, [sp, #12]<br/>&#13;
0x0820 &lt;+44&gt;:   str  w0, [sp, #28]<br/>&#13;
0x0824 &lt;+48&gt;:   ldr  w0, [sp, #28]<br/>&#13;
0x0828 &lt;+52&gt;:   add  sp, sp, #0x20<br/>&#13;
0x082c &lt;+56&gt;:   ret</p>&#13;
<p class="indent">This is a different view of the assembly code than we have seen before. Here, we can see the <em>address</em> associated with each instruction, but not the <em>bytes</em>. Note that this assembly segment has been lightly edited for the sake of simplicity. By convention, GCC places the first and second parameters of a function in registers <span class="literal">x0</span> and <span class="literal">x1</span>, respectively. Since the parameters to <span class="literal">getSmallest</span> are of type <span class="literal">int</span>, the compiler places the parameters in the respective component registers <span class="literal">w0</span> and <span class="literal">w1</span> instead. For the sake of clarity, we refer to these parameters as <span class="literal">x</span> and <span class="literal">y</span>, respectively.</p>&#13;
<p class="indent">Let’s trace through the first few lines of the previous assembly code snippet. Note that we will not draw out the stack explicitly in this example. We leave this as an exercise for the reader, and encourage you to practice your stack tracing skills by drawing it out yourself.</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">sub</span> instruction grows the call stack by 32 bytes (0x20).</li>&#13;
<li class="noindent">The <span class="literal">str</span> instructions at <span class="literal">&lt;getSmallest+4&gt;</span> and <span class="literal">&lt;getSmallest+8&gt;</span> store <span class="literal">x</span> and <span class="literal">y</span> at stack locations <span class="literal">sp</span> + 12 and <span class="literal">sp</span> + 8, respectively.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_482"/>The <span class="literal">ldr</span> instructions at <span class="literal">&lt;getSmallest+12&gt;</span> and <span class="literal">&lt;getSmallest+16</span> load <span class="literal">x</span> and <span class="literal">y</span> into registers <span class="literal">w1</span> and <span class="literal">w0</span>, respectively. Note that the original contents of <span class="literal">w0</span> and <span class="literal">w1</span> have swapped!</li>&#13;
<li class="noindent">The <span class="literal">cmp</span> instruction compares <span class="literal">w1</span> to <span class="literal">w0</span> (i.e., <span class="literal">x</span> to <span class="literal">y</span>) and sets appropriate condition code flag registers.</li>&#13;
<li class="noindent">The <span class="literal">b.le</span> instruction at <span class="literal">&lt;getSmallest+24&gt;</span> indicates that if <span class="literal">x</span> is less than or equal to <span class="literal">y</span>, the next instruction that should execute should be at location <span class="literal">&lt;getSmallest+40&gt;</span> (or <span class="literal">pc</span> = 0x81c). Otherwise, <span class="literal">pc</span> is set to the next instruction in sequence, or 0x810.</li>&#13;
</ul>&#13;
<p class="indent">The next instructions to execute depend on whether the program follows the branch (i.e., executes the jump) at (<span class="literal">&lt;getSmallest+24&gt;</span>). Let’s first suppose that the branch was <em>not</em> followed. In this case, <span class="literal">pc</span> is set to 0x810 (i.e., <span class="literal">&lt;getSmallest+28&gt;</span>) and the following sequence of instructions executes:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">ldr</span> instruction at <span class="literal">&lt;getSmallest+28&gt;</span> loads <span class="literal">y</span> to register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">The <span class="literal">str</span> instruction at <span class="literal">&lt;getSmallest+32&gt;</span> stores <span class="literal">y</span> at stack location <span class="literal">sp</span> + 28.</li>&#13;
<li class="noindent">The <span class="literal">b</span> instruction at <span class="literal">&lt;getSmallest+36&gt;</span> sets register <span class="literal">pc</span> to address 0x824.</li>&#13;
<li class="noindent">The <span class="literal">ldr</span> instruction at <span class="literal">&lt;getSmallest+48&gt;</span> loads <span class="literal">y</span> into register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">The last two instructions revert the call stack to its original size and return from the function call. In this case, <span class="literal">y</span> is in the return register, <span class="literal">w0</span>, and <span class="literal">getSmallest</span> returns <span class="literal">y</span>.</li>&#13;
</ul>&#13;
<p class="indent">Now, suppose that the branch <em>was</em> taken at <span class="literal">&lt;getSmallest+24&gt;</span>. In other words, the <span class="literal">b.le</span> instruction sets register <span class="literal">pc</span> to 0x81c (i.e., <span class="literal">&lt;getSmallest+40&gt;</span>). Then, the next instructions to execute are:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">ldr</span> instruction at <span class="literal">&lt;getSmallest+40&gt;</span> loads <span class="literal">x</span> into register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">The <span class="literal">str</span> instruction at <span class="literal">&lt;getSmallest+44&gt;</span> stores <span class="literal">x</span> at stack location <span class="literal">sp</span> + 28.</li>&#13;
<li class="noindent">The <span class="literal">ldr</span> instruction at <span class="literal">&lt;getSmallest+48&gt;</span> loads <span class="literal">x</span> into register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">The last two instructions revert the call stack to its original size and return from the function call. In this case, <span class="literal">x</span> is in the return register, <span class="literal">w0</span>, and <span class="literal">getSmallest</span> returns <span class="literal">x</span>.</li>&#13;
</ul>&#13;
<p class="indent">We can then annotate the preceding assembly as follows:</p>&#13;
<p class="programs">0x07f4 &lt;+0&gt;:   sub  sp, sp, #0x20          // grow stack by 32 bytes<br/>&#13;
0x07f8 &lt;+4&gt;:   str  w0, [sp, #12]          // store x at sp+12<br/>&#13;
0x07fc &lt;+8&gt;:   str  w1, [sp, #8]           // store y at sp+8<br/>&#13;
0x0800 &lt;+12&gt;:  ldr  w1, [sp, #12]          // w1 = x<br/>&#13;
0x0804 &lt;+16&gt;:  ldr  w0, [sp, #8]           // w0 = y<br/>&#13;
0x0808 &lt;+20&gt;:  cmp  w1, w0                 // compare x and y<br/>&#13;
0x080c &lt;+24&gt;:  b.le 0x81c &lt;getSmallest+40&gt; // if(x &lt;= y) goto &lt;getSmallest+40&gt;<br/>&#13;
0x0810 &lt;+28&gt;:  ldr  w0, [sp, #8]           // w0 = y<br/>&#13;
0x0814 &lt;+32&gt;:  str  w0, [sp, #28]          // store y at sp+28 (smallest)<br/>&#13;
<span epub:type="pagebreak" id="page_483"/>&#13;
0x0818 &lt;+36&gt;:  b    0x824 &lt;getSmallest+48&gt; // goto &lt;getSmallest+48&gt;<br/>&#13;
0x081c &lt;+40&gt;:  ldr  w0, [sp, #12]          // w0 = x<br/>&#13;
0x0820 &lt;+44&gt;:  str  w0, [sp, #28]          // store x at sp+28 (smallest)<br/>&#13;
0x0824 &lt;+48&gt;:  ldr  w0, [sp, #28]          // w0 = smallest<br/>&#13;
0x0828 &lt;+52&gt;:  add  sp, sp, #0x20          // clean up stack<br/>&#13;
0x082c &lt;+56&gt;:  ret                         // return smallest</p>&#13;
<p class="indent">Translating this back to C code yields:</p>&#13;
<p class="margnote">goto form</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest=y;<br/>&#13;
    if (x &lt;= y) {<br/>&#13;
        goto assign_x;<br/>&#13;
    }<br/>&#13;
    smallest = y;<br/>&#13;
    goto done;<br/>&#13;
<br/>&#13;
assign_x:<br/>&#13;
    smallest = x;<br/>&#13;
<br/>&#13;
done:<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="margnote">Translated C code</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest=y;<br/>&#13;
    if (x &lt;= y) {<br/>&#13;
        smallest = x;<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = y;<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="indent">In these code listings, the variable <span class="literal">smallest</span> corresponds to register <span class="literal">w0</span>. If <span class="literal">x</span> is less than or equal to <span class="literal">y</span>, the code executes the statement <span class="literal">smallest = x</span>, which is associated with the <span class="literal">goto</span> label <span class="literal">assign_x</span> in our <span class="literal">goto</span> form of this function. Otherwise, the statement <span class="literal">smallest = y</span> is executed. The <span class="literal">goto</span> label <span class="literal">done</span> is used to indicate that the value in <span class="literal">smallest</span> should be returned.</p>&#13;
<p class="indent">Notice that the preceding C translation of the assembly code is a bit different from the original <span class="literal">getSmallest</span> function. These differences don’t matter; a close inspection of both functions reveals that the two programs are logically equivalent. However, the compiler first converts each <span class="literal">if</span> statement into an equivalent <span class="literal">goto</span> form, which results in the slightly different but equivalent version. The following code listings show the standard <span class="literal">if</span> statement format and its equivalent <span class="literal">goto</span> form.</p>&#13;
<span epub:type="pagebreak" id="page_484"/>&#13;
<p class="margnote">C if statement</p>&#13;
<p class="programs">if (<span class="codeitalic1">&lt;condition&gt;</span>) {<br/>&#13;
    <span class="codeitalic1">&lt;then_statement&gt;</span>;<br/>&#13;
}<br/>&#13;
else {<br/>&#13;
    <span class="codeitalic1">&lt;else_statement&gt;</span>;<br/>&#13;
}</p>&#13;
<p class="margnote">Compiler’s equivalent goto form</p>&#13;
<p class="programs">    if (!<span class="codeitalic1">&lt;condition&gt;</span>) {<br/>&#13;
        goto else;<br/>&#13;
    }<br/>&#13;
    <span class="codeitalic1">&lt;then_statement&gt;</span>;<br/>&#13;
    goto done;<br/>&#13;
else:<br/>&#13;
    <span class="codeitalic1">&lt;else_statement&gt;</span>;<br/>&#13;
done:</p>&#13;
<p class="indent">Compilers translating code into assembly designate a branch when a condition is true. Contrast this behavior with the structure of an <span class="literal">if</span> statement, where a “jump” (to the <span class="literal">else</span>) occurs when conditions are <em>not</em> true. The <span class="literal">goto</span> form captures this difference in logic.</p>&#13;
<p class="indent">Considering the original <span class="literal">goto</span> translation of the <span class="literal">getSmallest</span> function, we can see that:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">x &lt;= y</span> corresponds to <span class="literal">!<em>&lt;condition&gt;</em></span>.</li>&#13;
<li class="noindent"><span class="literal">smallest = x</span> is the <span class="literal"/> <span class="codeitalic">&lt;else_statement&gt;</span>.</li>&#13;
<li class="noindent">The line <span class="literal">smallest = y</span> is the <span class="literal"/> <span class="codeitalic">&lt;then_statement&gt;</span>.</li>&#13;
<li class="noindent">The last line in the function is <span class="literal">return smallest</span>.</li>&#13;
</ul>&#13;
<p class="indent">Rewriting the original version of the function with the preceding annotations yields:</p>&#13;
<p class="programs">int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if (x &gt; y) {     //!(x &lt;= y)<br/>&#13;
        smallest = y; //then_statement<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x; //else_statement<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</p>&#13;
<p class="indent">This version is identical to the original <span class="literal">getSmallest</span> function. Keep in mind that a function written in different ways at the C code level can translate to the same set of assembly instructions.</p>&#13;
<h5 class="h5" id="lev3_76"><span epub:type="pagebreak" id="page_485"/>The Conditional Select Instruction</h5>&#13;
<p class="noindent">The final conditional instruction we cover is the <em>conditional select</em> (<span class="literal">csel</span>) instruction. The <span class="literal">cmp</span>, <span class="literal">tst</span>, and <span class="literal">b</span> instructions implement a <em>conditional transfer of control</em> in a program. In other words, the execution of the program branches in many directions. This can be very problematic for optimizing code because branch instructions are typically very expensive to execute, due to the disruption they can cause to the instruction pipeline (see “Pipelining Hazards: Control Hazards” on <a href="ch05.xhtml#lev2_106">page 279</a> for the details). In contrast, the <span class="literal">csel</span> instruction implements a <em>conditional transfer of data</em>. In other words, the CPU executes <em>both</em> the <span class="literal"/> <span class="codeitalic">&lt;then_statement&gt;</span> and <span class="literal"/> <span class="codeitalic">&lt;else_statement&gt;</span>, and places the data in the appropriate register based on the result of the condition.</p>&#13;
<p class="indent">The use of C’s <em>ternary expression</em> often results in the compiler generating a <span class="literal">csel</span> instruction in place of branches. For the standard if–then–else statement, the ternary expression has the form:</p>&#13;
<p class="programs">result = (<span class="codeitalic1">&lt;condition&gt;</span>) ? <span class="codeitalic1">&lt;then_expression&gt;</span> : <span class="codeitalic1">&lt;else_expression&gt;</span>;</p>&#13;
<p class="indent">Let’s use this format to rewrite the <span class="literal">getSmallest</span> function as a ternary expression. Keep in mind that this new version of the function behaves exactly as the original <span class="literal">getSmallest</span> function:</p>&#13;
<p class="programs">int getSmallest_csel(int x, int y) {<br/>&#13;
    return x &gt; y ? y : x;<br/>&#13;
}</p>&#13;
<p class="indent">Even though this may not seem like a big change, let’s look at the resulting assembly. Recall that the first and second parameters (<span class="literal">x</span> and <span class="literal">y</span>) are stored in registers <span class="literal">w0</span> and <span class="literal">w1</span>, respectively:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">disas getSmallest_csel</span><br/>&#13;
Dump of assembler code for function getSmallest_csel:<br/>&#13;
0x0860 &lt;+0&gt;:  sub  sp, sp, #0x10      // grow stack by 16 bytes<br/>&#13;
0x0864 &lt;+4&gt;:  str  w0, [sp, #12]      // store x at sp+12<br/>&#13;
0x0868 &lt;+8&gt;:  str  w1, [sp, #8]       // store y at sp+8<br/>&#13;
0x086c &lt;+12&gt;: ldr  w0, [sp, #8]       // w0 = y<br/>&#13;
0x0870 &lt;+16&gt;: ldr  w2, [sp, #12]      // w2 = x<br/>&#13;
0x0874 &lt;+20&gt;: ldr  w1, [sp, #12]      // w1 = x<br/>&#13;
0x0878 &lt;+24&gt;: cmp  w2, w0             // compare x and y<br/>&#13;
0x087c &lt;+28&gt;: csel w0, w1, w0, le     // if (x &lt;= y) w0 = x, else w0=y<br/>&#13;
0x0880 &lt;+32&gt;: add  sp, sp, #0x10      // restore sp<br/>&#13;
0x0884 &lt;+36&gt;: ret                     // return (w0)</p>&#13;
<p class="indent">This assembly code has no jumps. After the comparison of <span class="literal">x</span> and <span class="literal">y</span>, <span class="literal">x</span> moves into the return register <span class="literal">w0</span> only if <span class="literal">x</span> is less than or equal to <span class="literal">y</span>.</p>&#13;
<p class="indent">The structure of the <span class="literal">csel</span> instruction is</p>&#13;
<p class="programs">csel D, R1, R2, C // if (C) D = R1 else D = R2</p>&#13;
<p class="noindent">where <span class="literal">D</span> denotes the destination register, <span class="literal">R1</span> and <span class="literal">R2</span> are the two registers containing the values to be compared, and <span class="literal">C</span> is the condition to be evaluated.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_486"/>As for the branch instructions, the <span class="literal">C</span> component of the <span class="literal">csel</span> instructions indicates the condition on which the conditional select occurs. They are identical to those shown in <a href="ch09.xhtml#ch9tab13">Table 9-13</a> on <a href="ch09.xhtml#ch9tab13">page 479</a>.</p>&#13;
<p class="indent">In the case of the original <span class="literal">getSmallest</span> function, the compiler’s internal optimizer (see <a href="ch12.xhtml#ch12">Chapter 12</a>) will replace the <span class="literal">b</span> instructions with a <span class="literal">csel</span> instruction if level 1 optimizations are turned on (i.e., <span class="literal">-O1</span>):</p>&#13;
<p class="programs">// compiled with: gcc -O1 -o getSmallest getSmallest.c<br/>&#13;
Dump of assembler code for function getSmallest:<br/>&#13;
0x0734 &lt;+0&gt;: cmp  w0, w1            // compare x and y<br/>&#13;
0x0738 &lt;+4&gt;: csel w0, w0, w1, le    // if (x&lt;=y)  w0=x, else w0=y<br/>&#13;
0x073c &lt;+8&gt;: ret                    // return (w0)<br/>&#13;
</p>&#13;
<p class="indent">In general, the compiler is very cautious about optimizing branch instructions into <span class="literal">csel</span> instructions, especially in cases where side effects and pointer values are involved. Here, we show two equivalent ways of writing a function called <span class="literal">incrementX</span>:</p>&#13;
<p class="margnote">C code</p>&#13;
<p class="programs">int incrementX(int * x) {<br/>&#13;
    if (x != NULL) { //if x is not NULL<br/>&#13;
        return (*x)++; //increment x<br/>&#13;
    }<br/>&#13;
    else { //if x is NULL<br/>&#13;
        return 1; //return 1<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="margnote">C ternary form</p>&#13;
<p class="programs">int incrementX2(int * x){<br/>&#13;
    return x ? (*x)++ : 1;<br/>&#13;
}</p>&#13;
<p class="indent">Each function takes a pointer to an integer as input and checks whether it is <span class="literal">NULL</span>. If <span class="literal">x</span> is not <span class="literal">NULL</span>, the function increments and returns the dereferenced value of <span class="literal">x</span>. Otherwise, the function returns the value 1.</p>&#13;
<p class="indent">It is tempting to think that <span class="literal">incrementX2</span> uses a <span class="literal">csel</span> instruction given that it uses a ternary expression. However, both functions yield the exact same assembly code:</p>&#13;
<p class="programs">// parameter x is in register x0<br/>&#13;
Dump of assembler code for function incrementX2:<br/>&#13;
0x0774 &lt;+0&gt;:  mov  w1, #0x1                   // w1 = 0x1<br/>&#13;
0x0778 &lt;+4&gt;:  cbz  x0, 0x788 &lt;incrementX2+20&gt; // if(x==0) goto&lt;incrementX2+20&gt;<br/>&#13;
0x077c &lt;+8&gt;:  ldr  w1, [x0]                   // w1 = *x<br/>&#13;
0x0780 &lt;+12&gt;: add  w2, w1, #0x1               // w2 = w1 + 1<br/>&#13;
0x0784 &lt;+16&gt;: str  w2, [x0]                   // *x = w2<br/>&#13;
0x0788 &lt;+20&gt;: mov  w0, w1                     // w0 = *x<br/>&#13;
0x078c &lt;+24&gt;: ret                             // return (w0)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_487"/>Recall that the <span class="literal">csel</span> instruction <em>executes both branches of the conditional</em>. In other words, <span class="literal">x</span> gets dereferenced no matter what. Consider the case where <span class="literal">x</span> is a null pointer. Recall that dereferencing a null pointer leads to a null pointer exception in the code, causing a segmentation fault. To prevent any chance of this happening, the compiler takes the safe road and uses a branch.</p>&#13;
<h4 class="h4" id="lev2_173">9.4.3 Loops in Assembly</h4>&#13;
<p class="noindent">Like <span class="literal">if</span> statements, loops in assembly are also implemented using branch instructions. However, loops enable instructions to be <em>revisited</em> based on the result of an evaluated condition.</p>&#13;
<p class="indent">The <span class="literal">sumUp</span> function in the following example sums up all the positive integers from 1 to a user-defined integer <em>n</em>. This code is intentionally written suboptimally to illustrate a <span class="literal">while</span> loop in C.</p>&#13;
<p class="programs">int sumUp(int n) {<br/>&#13;
    //initialize total and i<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
<br/>&#13;
    while (i &lt;= n) {  //while i is less than or equal to n<br/>&#13;
        total += i;   //add i to total<br/>&#13;
        i++;          //increment i by 1<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">Compiling this code and disassembling it using GDB yields the following assembly code:</p>&#13;
<p class="programs">Dump of assembler code for function sumUp:<br/>&#13;
0x0724 &lt;+0&gt;:   sub   sp, sp, #0x20<br/>&#13;
0x0728 &lt;+4&gt;:   str   w0, [sp, #12]<br/>&#13;
0x072c &lt;+8&gt;:   str   wzr, [sp, #24]<br/>&#13;
0x0730 &lt;+12&gt;:  mov   w0, #0x1<br/>&#13;
0x0734 &lt;+16&gt;:  str   w0, [sp, #28]<br/>&#13;
0x0738 &lt;+20&gt;:  b     0x758 &lt;sumUp+52&gt;<br/>&#13;
0x073c &lt;+24&gt;:  ldr   w1, [sp, #24]<br/>&#13;
0x0740 &lt;+28&gt;:  ldr   w0, [sp, #28]<br/>&#13;
0x0744 &lt;+32&gt;:  add   w0, w1, w0<br/>&#13;
0x0748 &lt;+36&gt;:  str   w0, [sp, #24]<br/>&#13;
0x074c &lt;+40&gt;:  ldr   w0, [sp, #28]<br/>&#13;
0x0750 &lt;+44&gt;:  add   w0, w0, #0x1<br/>&#13;
0x0754 &lt;+48&gt;:  str   w0, [sp, #28]<br/>&#13;
0x0758 &lt;+52&gt;:  ldr   w1, [sp, #28]<br/>&#13;
0x075c &lt;+56&gt;:  ldr   w0, [sp, #12]<br/>&#13;
0x0760 &lt;+60&gt;:  cmp   w1, w0<br/>&#13;
<span epub:type="pagebreak" id="page_488"/>0x0764 &lt;+64&gt;:  b.le  0x73c &lt;sumUp+24&gt;<br/>&#13;
0x0768 &lt;+68&gt;:  ldr   w0, [sp, #24]<br/>&#13;
0x076c &lt;+72&gt;:  add   sp, sp, #0x20<br/>&#13;
0x0770 &lt;+76&gt;:  ret</p>&#13;
<p class="indent">Again, we will not draw out the stack explicitly in this example. However, we encourage readers to draw the stack out themselves.</p>&#13;
<h5 class="h5" id="lev3_77">The First Five Instructions</h5>&#13;
<p class="noindent">The first five instructions of this function set the stack up for function execution and store some temporary values:</p>&#13;
<p class="programs">0x0724 &lt;+0&gt;:  sub  sp, sp, #0x20   //grow stack by 32 bytes (new stack frame)<br/>&#13;
0x0728 &lt;+4&gt;:  str  w0, [sp, #12]   //store n at sp+12 (n)<br/>&#13;
0x072c &lt;+8&gt;:  str  wzr, [sp, #24]  //store 0 at sp+24 (total)<br/>&#13;
0x0730 &lt;+12&gt;: mov  w0, #0x1        //w0 = 1<br/>&#13;
0x0734 &lt;+16&gt;: str  w0, [sp, #28]   //store 1 at sp+28 (i)</p>&#13;
<p class="indent">Specifically, they:</p>&#13;
<ul>&#13;
<li class="noindent">Grow the call stack by 32 bytes, marking the new frame.</li>&#13;
<li class="noindent">Store the first parameter (<span class="literal">n</span>) at stack location <span class="literal">sp</span> + 12.</li>&#13;
<li class="noindent">Store the value 0 at stack location <span class="literal">sp</span> + 24, indicating <span class="literal">total</span>.</li>&#13;
<li class="noindent">Copy the value 1 into register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">Store the value 1 at stack location <span class="literal">sp</span> + 28, indicating <span class="literal">i</span>.</li>&#13;
</ul>&#13;
<p class="indent">Recall that stack locations store <em>temporary variables</em> in a function. For simplicity we will refer to the location marked by <span class="literal">sp</span> + 24 as <span class="literal">total</span> and <span class="literal">sp</span> + 28 as <span class="literal">i</span>. The input parameter to <span class="literal">sumUp</span> (<span class="literal">n</span>) is located at stack address <span class="literal">sp</span> + 12. Despite the placement of temporary variables on the stack, keep in mind that the stack pointer has not changed after the execution of the first instruction (<span class="literal">sub sp, sp,</span> <span class="literal">#0x20</span>).</p>&#13;
<h5 class="h5" id="lev3_78">The Heart of the Loop</h5>&#13;
<p class="noindent">The next 12 instructions in the <span class="literal">sumUp</span> function represent the heart of the loop:</p>&#13;
<p class="programs">0x0738 &lt;+20&gt;: b     0x758 &lt;sumUp+52&gt;  // goto &lt;sumUp+52&gt;<br/>&#13;
0x073c &lt;+24&gt;: ldr   w1, [sp, #24]     // w1 = total<br/>&#13;
0x0740 &lt;+28&gt;: ldr   w0, [sp, #28]     // w0 = i<br/>&#13;
0x0744 &lt;+32&gt;: add   w0, w1, w0        // w0 =  i + total<br/>&#13;
0x0748 &lt;+36&gt;: str   w0, [sp, #24]     // store (total + i) at sp+24 (total+=i)<br/>&#13;
0x074c &lt;+40&gt;: ldr   w0, [sp, #28]     // w0 = i<br/>&#13;
0x0750 &lt;+44&gt;: add   w0, w0, #0x1      // w0 = i + 1<br/>&#13;
0x0754 &lt;+48&gt;: str   w0, [sp, #28]     // store (i+1) at sp+28 (i++)<br/>&#13;
0x0758 &lt;+52&gt;: ldr   w1, [sp, #28]     // w1 = i<br/>&#13;
0x075c &lt;+56&gt;: ldr   w0, [sp, #12]     // w0 = n<br/>&#13;
<span epub:type="pagebreak" id="page_489"/>0x0760 &lt;+60&gt;: cmp   w1, w0            // compare i and n<br/>&#13;
0x0764 &lt;+64&gt;: b.le  0x73c &lt;sumUp+24&gt;  // if (i &lt;= n) goto &lt;sumUp+24&gt;&#13;
</p>&#13;
<ul>&#13;
<li class="noindent">The first instruction is a direct jump to <span class="literal">&lt;sumUp+52&gt;</span>, which sets the program counter register (<span class="literal">pc</span>) to address 0x758.</li>&#13;
<li class="noindent">The next two instructions that execute (at <span class="literal">&lt;sumUp+52&gt;</span> and <span class="literal">&lt;sumUp+56&gt;</span>) load <span class="literal">i</span> and <span class="literal">n</span> into registers <span class="literal">w1</span> and <span class="literal">w0</span>, respectively.</li>&#13;
<li class="noindent">The <span class="literal">cmp</span> instruction at <span class="literal">&lt;sumUp+60&gt;</span> compares <span class="literal">i</span> and <span class="literal">n</span>, setting the appropriate condition flags. The program counter <span class="literal">pc</span> advances to the next instruction, or address 0x764.</li>&#13;
<li class="noindent">The <span class="literal">b.le</span> instruction at <span class="literal">&lt;sumUp+64&gt;</span> replaces the <span class="literal">pc</span> register with address 0x73c if <span class="literal">i</span> is less than or equal to <span class="literal">n</span>.</li>&#13;
</ul>&#13;
<p class="indent">If the branch is taken (that is, if <span class="literal">i &lt;= n</span>), program execution jumps to <span class="literal">&lt;sumUp+24&gt;</span> and the following instructions execute:</p>&#13;
<ul>&#13;
<li class="noindent">The <span class="literal">ldr</span> instructions at <span class="literal">&lt;sumUp+24&gt;</span> and <span class="literal">&lt;sumUp+28&gt;</span> load <span class="literal">total</span> and <span class="literal">i</span> into registers <span class="literal">w1</span> and <span class="literal">w0</span>, respectively.</li>&#13;
<li class="noindent">The <span class="literal">add</span> instruction at <span class="literal">&lt;sumUp+32&gt;</span> then adds <span class="literal">total</span> to <span class="literal">i</span> (<span class="literal">i +</span> <span class="literal">total</span>) and stores the result in <span class="literal">w0</span>.</li>&#13;
<li class="noindent">The <span class="literal">str</span> instruction at <span class="literal">&lt;sumUp+36&gt;</span> then updates <span class="literal">total</span> with the value in register <span class="literal">w0</span> (<span class="literal">total = total + i</span>)</li>&#13;
<li class="noindent">The <span class="literal">ldr</span> instruction at <span class="literal">&lt;sumUp+40&gt;</span> loads <span class="literal">i</span> into register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">The <span class="literal">add</span> instruction at <span class="literal">&lt;sumUp+44&gt;</span> adds 1 to <span class="literal">i</span> and stores the result in register <span class="literal">w0</span>.</li>&#13;
<li class="noindent">The <span class="literal">str</span> instruction at <span class="literal">&lt;sumUp+48&gt;</span> updates <span class="literal">i</span> with the value stored in register <span class="literal">w0</span> (<span class="literal">i = i + 1</span>)</li>&#13;
<li class="noindent">The <span class="literal">ldr</span> instructions at <span class="literal">&lt;sumUp+52&gt;</span> and <span class="literal">&lt;sumUp+56&gt;</span> load <span class="literal">i</span> and <span class="literal">n</span> into registers <span class="literal">w1</span> and <span class="literal">w0</span>, respectively.</li>&#13;
<li class="noindent">The <span class="literal">cmp</span> instruction at <span class="literal">&lt;sumUp+60&gt;</span> compares <span class="literal">i</span> to <span class="literal">n</span> and sets the appropriate condition code flags.</li>&#13;
<li class="noindent">The <span class="literal">b.le</span> instruction then executes. If <span class="literal">i</span> is less than or equal to <span class="literal">n</span>, program execution jumps back to <span class="literal">&lt;sumUp+24&gt;</span>, <span class="literal">pc</span> is set to 0x73c, and the instructions between <span class="literal">&lt;sumUp+24&gt;</span> and <span class="literal">&lt;sumUp+64&gt;</span> repeat execution. Otherwise, register <span class="literal">pc</span> is set to the address of the next instruction in sequence, or 0x768 (<span class="literal">&lt;sumUp+68&gt;</span>).</li>&#13;
</ul>&#13;
<p class="indent">If the branch is <em>not</em> taken (i.e., <span class="literal">i</span> is greater than <span class="literal">n</span>), the following instructions execute:</p>&#13;
<p class="programs">0x0768 &lt;+68&gt;:  ldr   w0, [sp, #24]   // w0 = total<br/>&#13;
0x076c &lt;+72&gt;:  add   sp, sp, #0x20   // restore stack<br/>&#13;
0x0770 &lt;+76&gt;:  ret                   // return w0 (total)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_490"/>These instructions copy <span class="literal">total</span> to the return register <span class="literal">w0</span>, restore the call stack by shrinking <span class="literal">sp</span>, and exit the function. Thus, the function returns <span class="literal">total</span> upon exit.</p>&#13;
<p class="indent">The following code listings show the assembly and C <span class="literal">goto</span> forms of the <span class="literal">sumUp</span> function:</p>&#13;
<p class="margnote">Assembly</p>&#13;
<p class="programs">&lt;sumUp&gt;:<br/>&#13;
  &lt;+0&gt;:   sub   sp, sp, #0x20<br/>&#13;
  &lt;+4&gt;:   str   w0, [sp, #12]<br/>&#13;
  &lt;+8&gt;:   str   wzr, [sp, #24]<br/>&#13;
  &lt;+12&gt;:  mov   w0, #0x1<br/>&#13;
  &lt;+16&gt;:  str   w0, [sp, #28]<br/>&#13;
  &lt;+20&gt;:  b     0x758 &lt;sumUp+52&gt;<br/>&#13;
  &lt;+24&gt;:  ldr   w1, [sp, #24]<br/>&#13;
  &lt;+28&gt;:  ldr   w0, [sp, #28]<br/>&#13;
  &lt;+32&gt;:  add   w0, w1, w0<br/>&#13;
  &lt;+36&gt;:  str   w0, [sp, #24]<br/>&#13;
  &lt;+40&gt;:  ldr   w0, [sp, #28]<br/>&#13;
  &lt;+44&gt;:  add   w0, w0, #0x1<br/>&#13;
  &lt;+48&gt;:  str   w0, [sp, #28]<br/>&#13;
  &lt;+52&gt;:  ldr   w1, [sp, #28]<br/>&#13;
  &lt;+56&gt;:  ldr   w0, [sp, #12]<br/>&#13;
  &lt;+60&gt;:  cmp   w1, w0<br/>&#13;
  &lt;+64&gt;:  b.le  0x73c &lt;sumUp+24&gt;<br/>&#13;
  &lt;+68&gt;:  ldr   w0, [sp, #24]<br/>&#13;
  &lt;+72&gt;:  add   sp, sp, #0x20<br/>&#13;
  &lt;+76&gt;:  ret</p>&#13;
<p class="margnote">Translated goto form</p>&#13;
<p class="programs">int sumUp(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    goto start;<br/>&#13;
body:<br/>&#13;
    total += i;<br/>&#13;
    i += 1;<br/>&#13;
start:<br/>&#13;
    if (i &lt;= n) {<br/>&#13;
        goto body;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">The preceding code is also equivalent to the following C code without <span class="literal">goto</span> statements:</p>&#13;
<p class="programs">int sumUp(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_491"/>&#13;
    while (i &lt;= n) {<br/>&#13;
        total += i;<br/>&#13;
        i += 1;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<h5 class="h5" id="lev3_79">for Loops in Assembly</h5>&#13;
<p class="noindent">The primary loop in the <span class="literal">sumUp</span> function can also be written as a <span class="literal">for</span> loop:</p>&#13;
<p class="programs">int sumUp2(int n) {<br/>&#13;
    int total = 0;             //initialize total to 0<br/>&#13;
    int i;<br/>&#13;
    for (i = 1; i &lt;= n; i++) { //initialize i to 1, increment by 1 while i&lt;=n<br/>&#13;
        total += i;            //updates total by i<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">This yields identical assembly code to our <span class="literal">while</span> loop example. We repeat the assembly code here and annotate each line with its English translation:</p>&#13;
<p class="programs">Dump of assembler code for function sumUp2:<br/>&#13;
0x0774 &lt;+0&gt;:  sub   sp, sp, #0x20     // grow stack by 32 bytes (new frame)<br/>&#13;
0x0778 &lt;+4&gt;:  str   w0, [sp, #12]     // store n at sp+12 (n)<br/>&#13;
0x077c &lt;+8&gt;:  str   wzr, [sp, #24]    // store 0 at sp+24 (total)<br/>&#13;
0x0780 &lt;+12&gt;: mov   w0, #0x1          // w0 = 1<br/>&#13;
0x0784 &lt;+16&gt;: str   w0, [sp, #28]     // store 1 at sp+28 (i)<br/>&#13;
0x0788 &lt;+20&gt;: b     0x7a8 &lt;sumUp2+52&gt; // goto &lt;sumUp2+52&gt;<br/>&#13;
0x078c &lt;+24&gt;: ldr   w1, [sp, #24]     // w1 = total<br/>&#13;
0x0790 &lt;+28&gt;: ldr   w0, [sp, #28]     // w0 = i<br/>&#13;
0x0794 &lt;+32&gt;: add   w0, w1, w0        // w0 = total + i<br/>&#13;
0x0798 &lt;+36&gt;: str   w0, [sp, #24]     // store (total+i) in total<br/>&#13;
0x079c &lt;+40&gt;: ldr   w0, [sp, #28]     // w0 = i<br/>&#13;
0x07a0 &lt;+44&gt;: add   w0, w0, #0x1      // w0 = i + 1<br/>&#13;
0x07a4 &lt;+48&gt;: str   w0, [sp, #28]     // store (i+1) in i (i.e., i+=1)<br/>&#13;
0x07a8 &lt;+52&gt;: ldr   w1, [sp, #28]     // w1 = i<br/>&#13;
0x07ac &lt;+56&gt;: ldr   w0, [sp, #12]     // w0 = n<br/>&#13;
0x07b0 &lt;+60&gt;: cmp   w1, w0            // compare i and n<br/>&#13;
0x07b4 &lt;+64&gt;: b.le  0x78c &lt;sumUp2+24&gt; // if (i &lt;= n) goto &lt;sumUp2+24&gt;<br/>&#13;
0x07b8 &lt;+68&gt;: ldr   w0, [sp, #24]     // w0 = total<br/>&#13;
0x07bc &lt;+72&gt;: add   sp, sp, #0x20     // restore stack<br/>&#13;
0x07c0 &lt;+76&gt;: ret                     // return w0 (total)</p>&#13;
<p class="indent">To understand why the <span class="literal">for</span> loop version of this code results in identical assembly to the <span class="literal">while</span> loop version of the code, recall that the <span class="literal">for</span> loop has the following representation.</p>&#13;
<span epub:type="pagebreak" id="page_492"/>&#13;
<p class="programs">for ( <span class="codeitalic1">&lt;initialization&gt;</span>; <span class="codeitalic1">&lt;boolean expression&gt;</span>; <span class="codeitalic1">&lt;step&gt;</span> ){<br/>&#13;
    <span class="codeitalic1">&lt;body&gt;</span><br/>&#13;
}</p>&#13;
<p class="indent">This is equivalent to the following <span class="literal">while</span> loop representation:</p>&#13;
<p class="programs"><span class="codeitalic1">&lt;initialization&gt;</span><br/>&#13;
while (<span class="codeitalic1">&lt;boolean expression&gt;</span>) {<br/>&#13;
    <span class="codeitalic1">&lt;body&gt;</span><br/>&#13;
    <span class="codeitalic1">&lt;step&gt;</span><br/>&#13;
}</p>&#13;
<p class="indent">Since every <span class="literal">for</span> loop can be represented by a <span class="literal">while</span> loop (see “for Loops” on <a href="ch01.xhtml#lev3_5">page 35</a>), the following two C programs are equivalent representations for the previous assembly:</p>&#13;
<p class="margnote">for loop</p>&#13;
<p class="programs">int sumUp2(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    for (i; i &lt;= n; i++) {<br/>&#13;
        total += i;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="margnote">while loop</p>&#13;
<p class="programs">int sumUp(int n){<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    while (i &lt;= n) {<br/>&#13;
        total += i;<br/>&#13;
        i += 1;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<h3 class="h3" id="lev1_77">9.5 Functions in Assembly</h3>&#13;
<p class="noindent">In the previous section, we traced through simple functions in assembly. In this section, we discuss the interaction between multiple functions in assembly in the context of a larger program. We also introduce some new instructions involved with function management.</p>&#13;
<p class="indent">Let’s begin with a refresher on how the call stack is managed. Recall that <span class="literal">sp</span> is the <em>stack pointer</em> and always points to the top of the stack. The register <span class="literal">x29</span> represents the base pointer (also known as the <em>frame pointer</em> or <span class="literal">FP</span>) and points to the base of the current stack frame. The <em>stack frame</em> (also known as the <em>activation frame</em> or the <em>activation record</em>) refers to the portion of the stack allocated to a single function call. The currently executing function is always <span epub:type="pagebreak" id="page_493"/>at the top of the stack, and its stack frame is referred to as the <em>active frame</em>. The active frame is bounded by the stack pointer (at the top of stack, lower address) and frame pointer (at the bottom of the frame, higher address). The activation record typically holds local variables for a function. Lastly, the <em>return address</em> indicates the program address at which the calling function (e.g., <span class="literal">main</span>) resumes execution as soon as the callee function exits. In A64 systems, the return address is stored in register <span class="literal">x30</span> (also known as <span class="literal">LR</span>).</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9fig4">Figure 9-4</a> shows the stack frames for <span class="literal">main</span> and a function it calls named <span class="literal">fname</span>. We will refer to the <span class="literal">main</span> function as the <em>caller</em> function and <span class="literal">fname</span> as the <em>callee</em> function.</p>&#13;
<div class="imagec" id="ch9fig4"><img alt="image" src="../images/09fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-4: Stack frame management</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>, the current active frame belongs to the callee function (<span class="literal">fname</span>). The region of the call stack between the stack and frame pointers is used for local variables. The stack pointer moves as local values are pushed onto and popped from the stack. The frame pointer is not commonly used in optimized code, and is usually optional for operation. As a result, compilers like GCC commonly reference values on the stack relative to the stack pointer. In <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>, the active frame is bounded below by the base pointer of <span class="literal">fname</span>, or <span class="literal">x29</span>, which contains stack address 0xef30. The value stored at address 0xef30 is the “saved” frame pointer value (0xef50), which itself indicates the bottom of the activation frame for the <span class="literal">main</span> function. Right below the frame pointer is a saved <em>return address</em> (stored in <span class="literal">x30</span>), which indicates the address that the program will continue executing once <span class="literal">main</span> exits.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> THE RETURN ADDRESS POINTS TO CODE MEMORY, NOT STACK MEMORY</strong></p>&#13;
<p class="note-w">Recall that the call stack region (stack memory) of a program is different from its code region (code memory). Whereas <span class="literal">sp</span> and <span class="literal">x29</span> point to addresses in the stack memory, <span class="literal">pc</span> points to an address in <em>code</em> memory. In other words, the return address is an address in <em>code</em> memory, not stack memory (see <a href="ch09.xhtml#ch9fig5">Figure 9-5</a>).</p>&#13;
<span epub:type="pagebreak" id="page_494"/>&#13;
<div class="imagec" id="ch9fig5"><img alt="image" src="../images/09fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-5: The parts of a program’s address space</em></p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab14">Table 9-14</a> contains several additional instructions that the compiler uses for basic function management.</p>&#13;
<p class="tabcap" id="ch9tab14"><strong>Table 9-14:</strong> Common Function Management Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">bl addr &lt;fname&gt;</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Sets <span class="literal">x30</span> = <span class="literal">pc</span> + 4 and sets <span class="literal">pc</span> = addr</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">blr R &lt;fname&gt;</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Sets <span class="literal">x30</span> = <span class="literal">pc</span> + 4 and sets <span class="literal">pc</span> = R</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ret</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Returns value in <span class="literal">x0</span> and sets <span class="literal">pc</span> = <span class="literal">x30</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <span class="literal">bl</span> and <span class="literal">ret</span> instructions play a prominent role in the process where one function calls another. Both instructions modify the instruction pointer (register <span class="literal">pc</span>). When the caller function executes the <span class="literal">bl</span> instruction, the value of <span class="literal">pc</span> + 4 is saved in register <span class="literal">x30</span> to represent the return address, or the program address at which the caller resumes executing once the callee function finishes. The <span class="literal">bl</span> instruction also replaces the value of <span class="literal">pc</span> with the address of the callee function.</p>&#13;
<p class="indent">The <span class="literal">ret</span> instruction restores the value of <span class="literal">pc</span> to the value saved in <span class="literal">x30</span>, ensuring that the program resumes execution at the program address specified in the caller function. Any value returned by the callee is stored in register <span class="literal">x0</span> or its component register <span class="literal">w0</span>. The <span class="literal">ret</span> instruction is usually the last instruction that executes in any function.</p>&#13;
<span epub:type="pagebreak" id="page_495"/>&#13;
<h4 class="h4" id="lev2_174">9.5.1 Function Parameters</h4>&#13;
<p class="noindent">Function parameters are typically preloaded into registers prior to a function call. The first eight parameters to a function are stored in registers <span class="literal">x0</span>–<span class="literal">x7</span>. If a function requires more than seven parameters, the remaining parameters are successively loaded into the call stack based on their size (4-byte offsets for 32-bit data, 8-byte offsets for 64-bit data).</p>&#13;
<h4 class="h4" id="lev2_175">9.5.2 Tracing Through an Example</h4>&#13;
<p class="noindent">Using our knowledge of function management, let’s trace through the code example first introduced at the beginning of this chapter.</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int assign() {<br/>&#13;
    int y = 40;<br/>&#13;
    return y;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int adder() {<br/>&#13;
    int a;<br/>&#13;
    return a + 2;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int x;<br/>&#13;
    assign();<br/>&#13;
    x = adder();<br/>&#13;
    printf("x is: %d\n", x);<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">We compile this code with the command <span class="literal">gcc -o prog prog.c</span> and use <span class="literal">objdump -d</span> to view the underlying assembly. The latter command outputs a pretty big file that contains a lot of information that we don’t need. Use <span class="literal">less</span> and the search functionality to extract the <span class="literal">adder</span>, <span class="literal">assign</span>, and <span class="literal">main</span> functions:</p>&#13;
<p class="programs">0000000000000724 &lt;assign&gt;:<br/>&#13;
 724:   d10043ff        sub     sp, sp, #0x10<br/>&#13;
 728:   52800500        mov     w0, #0x28                       // #40<br/>&#13;
 72c:   b9000fe0        str     w0, [sp, #12]<br/>&#13;
 730:   b9400fe0        ldr     w0, [sp, #12]<br/>&#13;
 734:   910043ff        add     sp, sp, #0x10<br/>&#13;
 738:   d65f03c0        ret<br/>&#13;
<br/>&#13;
000000000000073c &lt;adder&gt;:<br/>&#13;
 73c:   d10043ff        sub     sp, sp, #0x10<br/>&#13;
 740:   b9400fe0        ldr     w0, [sp, #12]<br/>&#13;
<span epub:type="pagebreak" id="page_496"/> 744:   11000800        add     w0, w0, #0x2<br/>&#13;
 748:   910043ff        add     sp, sp, #0x10<br/>&#13;
 74c:   d65f03c0        ret<br/>&#13;
<br/>&#13;
0000000000000750 &lt;main&gt;:<br/>&#13;
 750:   a9be7bfd        stp     x29, x30, [sp, #-32]!<br/>&#13;
 754:   910003fd        mov     x29, sp<br/>&#13;
 758:   97fffff3        bl      724 &lt;assign&gt;<br/>&#13;
 75c:   97fffff8        bl      73c &lt;adder&gt;<br/>&#13;
 760:   b9001fa0        str     w0, [x29, #28]<br/>&#13;
 764:   90000000        adrp    x0, 0 &lt;_init-0x598&gt;<br/>&#13;
 768:   91208000        add     x0, x0, #0x820<br/>&#13;
 76c:   b9401fa1        ldr     w1, [x29, #28]<br/>&#13;
 770:   97ffffa8        bl      610 &lt;printf@plt&gt;<br/>&#13;
 774:   52800000        mov     w0, #0x0                        // #0<br/>&#13;
 778:   a8c27bfd        ldp     x29, x30, [sp], #32<br/>&#13;
 77c:   d65f03c0        ret</p>&#13;
<p class="indent">Each function begins with a symbolic label that corresponds to its declared name in the program. For example, <span class="literal">&lt;main&gt;:</span> is the symbolic label for the <span class="literal">main</span> function. The address of a function label is also the address of the first instruction in that function. To save space in the figures that follow, we truncate code addresses to the lower 12 bits, and stack addresses to the lower 16 bits. So, stack address 0xffffffffef50 is shown as 0xef50.</p>&#13;
<h4 class="h4" id="lev2_176">9.5.3 Tracing Through main</h4>&#13;
<p class="noindent"><a href="ch09.xhtml#ch9fig6">Figure 9-6</a> shows the execution stack immediately prior to the execution of <span class="literal">main</span>.</p>&#13;
<div class="imagec" id="ch9fig6"><img alt="image" src="../images/09fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-6: Initial state of CPU registers and call stack prior to executing the <span class="literal">main</span> function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_497"/>Recall that the stack grows toward lower addresses. In this example, the frame and stack pointers (<span class="literal">x29</span> and <span class="literal">sp</span>) both contain address 0xef50. Initially, <span class="literal">pc</span> is the address of the first instruction in the <span class="literal">main</span> function, or 0x750. Registers <span class="literal">x30</span> and <span class="literal">w0</span> are also highlighted in this example, and both contain initial junk values.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0497-01.jpg"/></div>&#13;
<p class="indent">The first instruction (<span class="literal">stp</span>) is a composite instruction with two parts. First, the second operand (<span class="literal">[sp, #-32]!</span>) decrements the stack pointer by 32 bytes, thus allocating space for the current stack frame. After the evaluation of the operand, the stack pointer updates to 0xef30. Next, the <span class="literal">stp</span> instruction stores the current values of <span class="literal">x29</span> and <span class="literal">x30</span> at locations <span class="literal">sp</span> and <span class="literal">sp</span> + 8, respectively. The instruction pointer <span class="literal">pc</span> advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0497-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_498"/>The next instruction (<span class="literal">mov x29, sp</span>) updates the value of <span class="literal">x29</span> to be the same as <span class="literal">sp</span>. Thus, the frame pointer (<span class="literal">x29</span>) now points to the start of the stack frame for the <span class="literal">main</span> function. The instruction pointer <span class="literal">pc</span> advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0498-01.jpg"/></div>&#13;
<p class="indent">The first <span class="literal">bl</span> instruction stores <span class="literal">pc</span> + 4 (or 0x75c) in register <span class="literal">x30</span>, which is the address in <span class="literal">main</span> at which the program will resume executing once the <span class="literal">assign</span> function returns. Next, the register <span class="literal">pc</span> is updated with address 0x724, which indicates the address of the first instruction in the <span class="literal">assign</span> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0498-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_499"/>The next instruction that executes is the first instruction in <span class="literal">assign</span>. The <span class="literal">sub</span> instruction decrements the stack pointer by 16 bytes. Note that <span class="literal">x29</span> and <span class="literal">sp</span> now denote the active stack frame boundaries for the <span class="literal">assign</span> function. The program counter advances to the next instruction.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0499-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">mov</span> instruction stores the constant value 0x28 in register <span class="literal">w0</span>. Register <span class="literal">pc</span> advances to the next instruction in sequence.</p>&#13;
<span epub:type="pagebreak" id="page_500"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0500-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">str</span> instruction stores 0x28 at an offset of 12 bytes from the stack pointer, or at address 0xef2c. The instruction pointer advances to the next instruction.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0500-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_501"/>The <span class="literal">ldr</span> instruction saves 0x28 from stack address 0xef2c into register <span class="literal">w0</span>. The instruction pointer advances to the next instruction.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0501-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">add</span> instruction deallocates the current stack frame and reverts <span class="literal">sp</span> to its previous value, or 0xef30.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0501-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_502"/>The <span class="literal">ret</span> instruction replaces the value in <span class="literal">pc</span> with the value in <span class="literal">x30</span>, or 0x75c. As a result, program execution returns to the first instruction in the <span class="literal">main</span> function immediately after the call to <span class="literal">assign</span>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0502-01.jpg"/></div>&#13;
<p class="indent">The next instruction that executes is a function call to <span class="literal">adder</span> (or <span class="literal">bl 73c</span> <span class="literal">&lt;adder&gt;</span>). Therefore, register <span class="literal">x30</span> is updated with <span class="literal">pc</span> + 4, or 0x760. The program counter is replaced with address 0x73c, signifying that program execution continues into the <span class="literal">adder</span> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0502-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_503"/>The first instruction in the <span class="literal">adder</span> function decrements the stack pointer by 16 bytes, allocating the new stack frame for the <span class="literal">adder</span> function. Note that the active stack frame boundaries for the <span class="literal">adder</span> function are designated by registers <span class="literal">sp</span> and <span class="literal">x29</span>. The instruction pointer advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0503-01.jpg"/></div>&#13;
<p class="indent">What happens next is crucial. The <span class="literal">ldr</span> instruction loads an <em>old</em> value from the stack (at <span class="literal">sp</span> + 12) into register <span class="literal">w0</span>. This is a direct result of the fact that the programmer forgot to initialize <span class="literal">a</span> in the <span class="literal">adder</span> function. The instruction pointer advances to the next instruction in sequence.</p>&#13;
<span epub:type="pagebreak" id="page_504"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0504-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">add</span> instruction then adds 0x2 to the value in <span class="literal">w0</span> and stores the result (0x2A) in register <span class="literal">w0</span>. The instruction pointer advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0504-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_505"/>The next <span class="literal">add</span> instruction increments the stack pointer by 16 bytes, thus destroying the active frame for <span class="literal">adder</span> and restoring <span class="literal">sp</span> to its previous value. The instruction pointer advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0505-01.jpg"/></div>&#13;
<p class="indent">Finally, the <span class="literal">ret</span> instruction overwrites <span class="literal">pc</span> with the address in register <span class="literal">x30</span>, indicating that program execution should continue in the <span class="literal">main</span> function at code segment address 0x760.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0505-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_506"/>Back in the <span class="literal">main</span> function, the <span class="literal">str</span> instruction at program address 0x760 stores the contents of the <span class="literal">w0</span> register (0x2A) at a call stack location that is 28 bytes from the frame pointer (<span class="literal">x29</span>). Therefore, 0x2A is stored at stack address 0xef4c.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0506-01.jpg"/></div>&#13;
<p class="indent">The next two instructions together load an address of a page into register <span class="literal">x0</span>. Since addresses are 8 bytes long, the 64-bit register <span class="literal">x0</span> is used instead of its 32-bit component, <span class="literal">w0</span>. The <span class="literal">adrp</span> instruction loads the address (0x0) into register <span class="literal">x0</span>, while the <span class="literal">add</span> instruction at code segment address 0x768 adds the value 0x820 to it. At the end of these two instructions, register <span class="literal">x0</span> contains memory address 0x820. Note that the value stored at address 0x820 is the string <span class="literal">"x is</span> <span class="literal">%d\n"</span>.</p>&#13;
<span epub:type="pagebreak" id="page_507"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0507-01.jpg"/></div>&#13;
<p class="indent">Next, the <span class="literal">ldr</span> instruction at program address 0x76c loads 0x2A (which is located at an offset of 28 bytes from the frame pointer) into register <span class="literal">w1</span>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0507-02.jpg"/></div>&#13;
<p class="indent">The next instruction calls the <span class="literal">printf</span> function. For the sake of brevity, we will not trace the <span class="literal">printf</span> function, which is part of <span class="literal">stdio.h</span>. However, we know from the manual page (<span class="literal">man -s3 printf</span>) that <span class="literal">printf</span> has the following format:</p>&#13;
<p class="programs">int printf(const char * format, ...)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_508"/>In other words, the first argument is a pointer to a string specifying the format, and the second argument onward specify the values that are used in that format. The instructions specified by addresses 0x764–0x770 correspond to the following line in the <span class="literal">main</span> function:</p>&#13;
<p class="programs">printf("x is %d\n", x);</p>&#13;
<p class="indent">When the <span class="literal">printf</span> function is called:</p>&#13;
<ul>&#13;
<li class="noindent">The return address (<span class="literal">pc</span> + 4 or 0x774) is stored in register <span class="literal">x30</span>.</li>&#13;
<li class="noindent">Register <span class="literal">pc</span> switches address 0x610, which is the start of the <span class="literal">printf</span> function.</li>&#13;
<li class="noindent">Register <span class="literal">sp</span> is updated to reflect the new stack frame for the <span class="literal">printf</span> function.</li>&#13;
</ul>&#13;
<p class="indent">At some point, <span class="literal">printf</span> references its arguments, which are the string <span class="literal">"x is %d\n"</span> and the value 0x2A. Recall that for any function with <em>n</em> arguments, gcc places the first eight arguments in registers <span class="literal">x0</span>–<span class="literal">x7</span>, and the remaining arguments onto the stack <em>below</em> the frame pointer. In this case, the first parameter is stored in register <span class="literal">x0</span> (since it is an address to a string), and the second parameter is stored in component register <span class="literal">w1</span>.</p>&#13;
<p class="indent">After the call to <span class="literal">printf</span>, the value 0x2A is output to the user in integer format. Thus, the value 42 is printed to the screen. The stack pointer reverts to its previous value, and <span class="literal">pc</span> updates to the value stored in register <span class="literal">x30</span>, or 0x774.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0508-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">mov</span> instructions at address 0x774 loads the constant value <span class="literal">#0x0</span> into component register <span class="literal">w0</span>. This represents the value that will be returned when <span class="literal">main</span> completes execution. The program counter advances to the next instruction in sequence.</p>&#13;
<span epub:type="pagebreak" id="page_509"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0509-01.jpg"/></div>&#13;
<p class="indent">The <span class="literal">ldp</span> instruction at program address 0x778 first copies the values at <span class="literal">sp</span> and <span class="literal">sp</span> + 8 into registers <span class="literal">x29</span> and <span class="literal">x30</span>, reverting them to their original values prior to the start of the execution of the <span class="literal">main</span> function. The last part of the <span class="literal">ldp</span> instruction (as specified by the operand <span class="literal">[sp], #32</span>) increments the stack pointer by 32 bytes, restoring <span class="literal">sp</span> to its original value prior to the execution of <span class="literal">main</span>. Thus, when the <span class="literal">ldp</span> instruction completes execution, the stack pointer (<span class="literal">sp</span>), frame pointer (<span class="literal">x29</span>), and return register (<span class="literal">x30</span>) all have returned to their original values. The program counter advances to the last instruction in the <span class="literal">main</span> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0509-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_510"/>The last instruction that executes is <span class="literal">ret</span>. With 0x0 in the return register <span class="literal">w0</span>, the program returns 0, indicating correct termination.</p>&#13;
<p class="indent">If you have carefully read through this section, you should understand why our program prints out the value 42. In essence, the program inadvertently uses old values on the stack to cause it to behave in a way that we didn’t expect. This example was pretty harmless; however we discuss in future sections how hackers have misused function calls to make programs misbehave in truly malicious ways.</p>&#13;
<h3 class="h3" id="lev1_78">9.6 Recursion</h3>&#13;
<p class="noindent">Recursive functions are a special class of functions that call themselves (also known as <em>self-referential</em> functions) to compute a value. Like their nonrecursive counterparts, recursive functions create new stack frames for each function call. Unlike standard functions, recursive functions contain function calls to themselves.</p>&#13;
<p class="indent">Let’s revisit the problem of summing up the set of positive integers from 1 to <em>n</em>. In previous sections, we discussed the <span class="literal">sumUp</span> function to achieve this task. The following code shows a related function called <span class="literal">sumDown</span>, which adds the numbers in reverse (<em>n</em> to 1), and its recursive equivalent <span class="literal">sumr</span>:</p>&#13;
<p class="margnote">Iterative</p>&#13;
<p class="programs">int sumDown(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = n;<br/>&#13;
    while (i &gt; 0) {<br/>&#13;
        total += i;<br/>&#13;
        i--;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="margnote">Recursive</p>&#13;
<p class="programs">int sumr(int n) {<br/>&#13;
    if (n &lt;= 0) {<br/>&#13;
        return 0;<br/>&#13;
    }<br/>&#13;
    return n + sumr(n-1);<br/>&#13;
}</p>&#13;
<p class="indent">The base case in the recursive function <span class="literal">sumr</span> accounts for any values of <em>n</em> that are less than or equal to zero, and the recursive step adds the current value of <em>n</em> to the result of the function call to <span class="literal">sumr</span> with the value <em>n –</em> 1. Compiling <span class="literal">sumr</span> and disassembling it with GDB yields the following assembly code:</p>&#13;
<p class="programs">Dump of assembler code for function sumr:<br/>&#13;
0x770 &lt;+0&gt;:  stp   x29, x30, [sp, #-32]! // sp = sp-32; store x29,x30 on stack<br/>&#13;
0x774 &lt;+4&gt;:  mov   x29, sp               // x29 = sp (i.e. x29 = top of stack)<br/>&#13;
0x778 &lt;+8&gt;:  str   w0, [x29, #28]        // store w0 at x29+28 (n)<br/>&#13;
<span epub:type="pagebreak" id="page_511"/>0x77c &lt;+12&gt;: ldr   w0, [x29, #28]        // w0 = n<br/>&#13;
0x780 &lt;+16&gt;: cmp   w0, #0x0              // compare n to 0<br/>&#13;
0x784 &lt;+20&gt;: b.gt  0x790 &lt;sumr+32&gt;       // if (n &gt; 0) goto &lt;sumr+32&gt;<br/>&#13;
0x788 &lt;+24&gt;: mov   w0, #0x0              // w0 = 0<br/>&#13;
0x78c &lt;+28&gt;: b     0x7a8 &lt;sumr+56&gt;       // goto &lt;sumr+56&gt;<br/>&#13;
0x790 &lt;+32&gt;: ldr   w0, [x29, #28]        // w0 = n<br/>&#13;
0x794 &lt;+36&gt;: sub   w0, w0, #0x1          // w0 = w0 - 1 (i.e. n-1)<br/>&#13;
0x798 &lt;+40&gt;: bl    0x770 &lt;sumr&gt;          // call sumr(n-1) (result)<br/>&#13;
0x79c &lt;+44&gt;: mov   w1, w0                // copy result into register w1<br/>&#13;
0x7a0 &lt;+48&gt;: ldr   w0, [x29, #28]        // w0 = n<br/>&#13;
0x7a4 &lt;+52&gt;: add   w0, w1, w0            // w0 = w0 + w1 (i.e n + result)<br/>&#13;
0x7a8 &lt;+56&gt;: ldp   x29, x30, [sp], #32   // restore x29, x30, and sp<br/>&#13;
0x7ac &lt;+60&gt;: ret                         // return w0 (result)</p>&#13;
<p class="indent">Each line in the preceding assembly code is annotated with its English translation. Here, we show the corresponding <span class="literal">goto</span> form (first) and C program without <span class="literal">goto</span> statements (second):</p>&#13;
<p class="margnote">C goto form</p>&#13;
<p class="programs">int sumr(int n) {<br/>&#13;
    int result;<br/>&#13;
    if (n &gt; 0) {<br/>&#13;
        goto body;<br/>&#13;
    }<br/>&#13;
    result = 0;<br/>&#13;
    goto done;<br/>&#13;
body:<br/>&#13;
    result = n;<br/>&#13;
    result--;<br/>&#13;
    result = sumr(result);<br/>&#13;
    result += n;<br/>&#13;
done:<br/>&#13;
    return result;<br/>&#13;
}</p>&#13;
<p class="margnote">C version without goto</p>&#13;
<p class="programs">int sumr(int n) {<br/>&#13;
    int result;<br/>&#13;
    if (n &lt;= 0) {<br/>&#13;
        return 0;<br/>&#13;
    }<br/>&#13;
    result = sumr(n-1);<br/>&#13;
    result += n;<br/>&#13;
    return result;<br/>&#13;
}</p>&#13;
<p class="indent">Although this translation may not initially appear to be identical to the original <span class="literal">sumr</span> function, close inspection reveals that the two functions are indeed equivalent.</p>&#13;
<h4 class="h4" id="lev2_177"><span epub:type="pagebreak" id="page_512"/>9.6.1 Animation: Observing How the Call Stack Changes</h4>&#13;
<p class="noindent">As an exercise, we encourage you to draw out the stack and see how the values change. We have provided an animation online that depicts how the stack is updated when we run this function with the value <span class="literal">3</span>.<sup><a href="ch09.xhtml#fn9_5" id="rfn9_5">5</a></sup></p>&#13;
<h3 class="h3" id="lev1_79">9.7 Arrays</h3>&#13;
<p class="noindent">Recall that arrays (see “Introduction to Arrays” on <a href="ch01.xhtml#lev2_9">page 44</a>) are ordered collections of data elements of the same type that are contiguously stored in memory. Statically allocated single-dimension arrays (see “Single-Dimensional Arrays” on <a href="ch02.xhtml#lev2_22">page 81</a>) have the form <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> <span class="literal">arr[N]</span>, where <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> is the data type, <span class="literal">arr</span> is the identifier associated with the array, and <span class="literal">N</span> is the number of data elements. Declaring an array statically as <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> <span class="literal">arr[N]</span> or dynamically as <span class="literal">arr = malloc(N*sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">))</span> allocates <em>N</em> × <span class="literal">sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">)</span> total bytes of memory.</p>&#13;
<p class="indent">To access the element at index <span class="literal">i</span> in array <span class="literal">arr</span>, use the syntax <span class="literal">arr[i]</span>. Compilers commonly convert array references into pointer arithmetic (see “Pointer Variables” on <a href="ch02.xhtml#lev1_10">page 67</a>) prior to translating to assembly. So, <span class="literal">arr+i</span> is equivalent to <span class="literal">&amp;arr[i]</span>, and <span class="literal">*(arr+i)</span> is equivalent to <span class="literal">arr[i]</span>. Since each data element in <span class="literal">arr</span> is of type <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span>, <span class="literal">arr+i</span> implies that element <span class="literal">i</span> is stored at address <span class="literal">arr</span> + <span class="literal">sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">)</span> × <span class="literal">i</span>.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9tab15">Table 9-15</a> outlines some common array operations and their corresponding assembly instructions. In the examples that follow, suppose that we declare an <span class="literal">int</span> array of length 10 (e.g., <span class="literal">int arr[10]</span>). Assume that register <span class="literal">x1</span> stores the address of <span class="literal">arr</span>, register <span class="literal">x2</span> stores the <span class="literal">int</span> value <span class="literal">i</span>, and register <span class="literal">x0</span> represents some variable <span class="literal">x</span> (also of type <span class="literal">int</span>). Recall that <span class="literal">int</span> variables take up four bytes of space, whereas <span class="literal">int *</span> variables take up eight bytes.</p>&#13;
<p class="tabcap" id="ch9tab15"><strong>Table 9-15:</strong> Common Array Operations and Their Corresponding Assembly Representations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Assembly Representation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">mov x0, x1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr[0]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ldr w0, [x1]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr[i]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ldr w0, [x1, x2, LSL, #2]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = &amp;arr[3]</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">add x0, x1, #12</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = arr+3</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int *</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">add x0, x1, #12</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">x = *(arr+5)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">int</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">ldr w0, [x1, #20]</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Notice that to access element <span class="literal">arr[5]</span> (or <span class="literal">*(arr+5)</span> using pointer arithmetic), the compiler performs a memory lookup on address <span class="literal">arr+5*4</span> instead of <span class="literal">arr+5</span>. To understand why this is necessary, recall that any element at index <span class="literal">i</span> in an array is stored at address <span class="literal">arr</span> + <span class="literal">sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">)</span> × <span class="literal">i</span>. The compiler must therefore multiply the index by the size of the data type (in this case 4, given that <span class="literal">sizeof(int)</span> = 4) to compute the correct offset. Recall also that memory is byte-addressable; offsetting by the correct number of bytes is the same as computing an address.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_513"/>As an example, consider a sample array (<span class="literal">array</span>) with 10 integer elements (<a href="ch09.xhtml#ch9fig7">Figure 9-7</a>).</p>&#13;
<div class="imagec" id="ch9fig7"><img alt="image" src="../images/09fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-7: The layout of a ten-integer array in memory. Each a<sub>i</sub>-labeled box represents an offset of four bytes, as each integer requires four bytes to store.</em></p>&#13;
<p class="indent">Notice that since <span class="literal">array</span> is an array of integers, each element takes up exactly four bytes. Thus, an integer array with 10 elements consumes 40 bytes of contiguous memory.</p>&#13;
<p class="indent">To compute the address of element 3, the compiler multiplies the index 3 by the data size of the integer type (4) to yield an offset of 12 (or 0xc). Sure enough, element 3 in <a href="ch09.xhtml#ch9fig7">Figure 9-7</a> is located at byte offset <em>a</em><sub>12</sub>.</p>&#13;
<p class="indent">Let’s take a look at a simple C function called <span class="literal">sumArray</span> that sums up all the elements in an array:</p>&#13;
<p class="programs">int sumArray(int *array, int length) {<br/>&#13;
    int i, total = 0;<br/>&#13;
    for (i = 0; i &lt; length; i++) {<br/>&#13;
        total += array[i];<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">sumArray</span> function takes the address of an array and the array’s associated length and sums up all the elements in the array. Now take a look at the corresponding assembly of the <span class="literal">sumArray</span> function:</p>&#13;
<p class="programs">Dump of assembler code for function sumArray:<br/>&#13;
0x874 &lt;+0&gt;:   sub    sp, sp, #0x20       // grow stack by 32 bytes (new frame)<br/>&#13;
0x878 &lt;+4&gt;:   str    x0, [sp, #8]        // store x0 at sp + 8 (array address)<br/>&#13;
0x87c &lt;+8&gt;:   str    w1, [sp, #4]        // store w1 at sp + 4 (length)<br/>&#13;
0x880 &lt;+12&gt;:  str    wzr, [sp, #28]      // store 0 at sp + 28  (total)<br/>&#13;
0x884 &lt;+16&gt;:  str    wzr, [sp, #24]      // store 0 at sp + 24 (i)<br/>&#13;
0x888 &lt;+20&gt;:  b      0x8b8 &lt;sumArray+68&gt; // goto &lt;sumArray+68&gt;<br/>&#13;
0x88c &lt;+24&gt;:  ldrsw  x0, [sp, #24]       // x0 = i<br/>&#13;
0x890 &lt;+28&gt;:  lsl    x0, x0, #2          // left shift i by 2 (i ≪ 2, or i*4)<br/>&#13;
0x894 &lt;+32&gt;:  ldr    x1, [sp, #8]        // x1 = array<br/>&#13;
0x898 &lt;+36&gt;:  add    x0, x1, x0          // x0 = array + i*4<br/>&#13;
0x89c &lt;+40&gt;:  ldr    w0, [x0]            // w0 = array[i]<br/>&#13;
0x8a0 &lt;+44&gt;:  ldr    w1, [sp, #28]       // w1 = total<br/>&#13;
0x8a4 &lt;+48&gt;:  add    w0, w1, w0          // w0 = total + array[i]<br/>&#13;
0x8a8 &lt;+52&gt;:  str    w0, [sp, #28]       // store (total + array[i]) in total<br/>&#13;
0x8ac &lt;+56&gt;:  ldr    w0, [sp, #24]       // w0 = i<br/>&#13;
0x8b0 &lt;+60&gt;:  add    w0, w0, #0x1        // w0 = w0 + 1 (i+1)<br/>&#13;
<span epub:type="pagebreak" id="page_514"/>0x8b4 &lt;+64&gt;:  str    w0, [sp, #24]       // store (i + 1) in i (i.e. i+=1)<br/>&#13;
0x8b8 &lt;+68&gt;:  ldr    w1, [sp, #24]       // w1 = i<br/>&#13;
0x8bc &lt;+72&gt;:  ldr    w0, [sp, #4]        // w0 = length<br/>&#13;
0x8c0 &lt;+76&gt;:  cmp    w1, w0              // compare i and length<br/>&#13;
0x8c4 &lt;+80&gt;:  b.lt   0x88c &lt;sumArray+24&gt; // if (i &lt; length) goto &lt;sumArray+24&gt;<br/>&#13;
0x8c8 &lt;+84&gt;:  ldr    w0, [sp, #28]       // w0 = total<br/>&#13;
0x8cc &lt;+88&gt;:  add    sp, sp, #0x20       // revert stack to original state<br/>&#13;
0x8d0 &lt;+92&gt;:  ret                        // return (total)</p>&#13;
<p class="indent">When tracing this assembly code, consider whether the data being accessed represents a pointer or a value. For example, the instruction at <span class="literal">&lt;sumArray+12&gt;</span> results in stack location <span class="literal">sp</span> + 28 containing a variable of type <span class="literal">int</span>, which is initially set to 0. In contrast, the argument stored at location <span class="literal">sp</span> + 8 is the first argument to the function (<span class="literal">array</span>), which is of type <span class="literal">int *</span> and corresponds to the base address of the array. A different variable (which we call <span class="literal">i</span>) is stored at location <span class="literal">sp</span> + 24 and is initially set to 0.</p>&#13;
<p class="indent">The astute reader will notice a previously unseen instruction at line <span class="literal">&lt;sumArray+30&gt;</span> called <span class="literal">ldrsw</span>. The <span class="literal">ldrsw</span> instruction stands for “load register signed word” and converts the 32-bit <span class="literal">int</span> value stored at <span class="literal">sp</span> + 24 to a 64-bit integer value and stores it in <span class="literal">x0</span>. This operation is necessary because the instructions that follow perform pointer arithmetic. Recall that on 64-bit systems, pointers take up eight bytes of space. The compiler’s use of <span class="literal">ldrsw</span> simplifies the process by ensuring that all data are stored in full 64-bit registers instead of their 32-bit components.</p>&#13;
<p class="indent">Let’s take a closer look at the seven instructions between locations <span class="literal">&lt;sumArray+28&gt;</span> and <span class="literal">&lt;sumArray+52&gt;</span>:</p>&#13;
<p class="programs">0x890 &lt;+28&gt;:  lsl    x0, x0, #2         // left shift i by 2 (i ≪ 2, or i*4)<br/>&#13;
0x894 &lt;+32&gt;:  ldr    x1, [sp, #8]       // x1 = array<br/>&#13;
0x898 &lt;+36&gt;:  add    x0, x1, x0         // x0 = array + i*4<br/>&#13;
0x89c &lt;+40&gt;:  ldr    w0, [x0]           // w0 = array[i]<br/>&#13;
0x8a0 &lt;+44&gt;:  ldr    w1, [sp, #28]      // w1 = total<br/>&#13;
0x8a4 &lt;+48&gt;:  add    w0, w1, w0         // w0 = total + array[i]<br/>&#13;
0x8a8 &lt;+52&gt;:  str    w0, [sp, #28]      // store (total + array[i]) in total</p>&#13;
<p class="indent">The compiler uses <span class="literal">lsl</span> to perform a left shift on the value <span class="literal">i</span> stored in <span class="literal">x0</span>. When this instruction completes execution, register <span class="literal">x0</span> contains <span class="literal">i ≪ 2</span>, or <span class="literal">i * 4</span>. At this point, <span class="literal">x0</span> contains the number of bytes to calculate the correct offset of <span class="literal">array[i]</span> (or <span class="literal">sizeof(int)</span> = 4).</p>&#13;
<p class="indent">The next instruction (<span class="literal">ldr x1, [sp, #8]</span>) loads the first argument to the function (i.e., the base address of <span class="literal">array</span>) into register <span class="literal">x1</span>. Adding <span class="literal">x1</span> to <span class="literal">x0</span> in the next instruction causes <span class="literal">x0</span> to contain <span class="literal">array</span> + <span class="literal">i</span> × 4. Recall that the element at index <span class="literal">i</span> in <span class="literal">array</span> is stored at address <span class="literal">array</span> + <span class="literal">sizeof(</span> <span class="codeitalic">&lt;type&gt;</span><span class="literal">)</span> × <span class="literal">i</span> Therefore, <span class="literal">x0</span> now contains the assembly-level computation of address <span class="literal">&amp;array[i]</span>.</p>&#13;
<p class="indent">The instruction at <span class="literal">&lt;sumArray+40&gt;</span> <em>dereferences</em> the value located at <span class="literal">x0</span>, placing the value <span class="literal">array[i]</span> into <span class="literal">w1</span>. Notice the use of the component register <span class="literal">w1</span>, since <span class="literal">array[i]</span> contains a 32-bit <span class="literal">int</span> value! In contrast, the variable <span class="literal">i</span> was changed to a 64-bit integer on line <span class="literal">&lt;sumArray+24&gt;</span> because <span class="literal">i</span> was about to be <span epub:type="pagebreak" id="page_515"/>used for <em>address computation</em>. Again, addresses (pointers) are stored as 64-bit words.</p>&#13;
<p class="indent">The last three instructions between <span class="literal">&lt;sumArray+44&gt;</span> and <span class="literal">&lt;sumArray+52&gt;</span> load the current value of <span class="literal">total</span> into component register <span class="literal">w1</span>, add <span class="literal">array[i]</span> to it, and store the result in component register <span class="literal">w0</span>, before updating <span class="literal">total</span> at location <span class="literal">sp</span> + 28 with the new sum. Therefore, the seven instructions between <span class="literal">&lt;sumArray+28&gt;</span> and <span class="literal">&lt;sumArray+52&gt;</span> are equivalent to the line <span class="literal">total += array[i]</span> in the <span class="literal">sumArray</span> function.</p>&#13;
<h3 class="h3" id="lev1_80">9.8 Matrices</h3>&#13;
<p class="noindent">A matrix is a 2D array. A matrix in C can be statically allocated as a 2D array (<span class="literal">M[n][m]</span>), dynamically allocated with a single call to <span class="literal">malloc</span>, or dynamically allocated as an array of arrays. Let’s consider the array of arrays implementation. The first array contains <span class="literal">n</span> elements (<span class="literal">M[n]</span>), and each element <span class="literal">M[i]</span> in our matrix contains an array of <span class="literal">m</span> elements. The following code snippets each declare matrices of size 4 × 3:</p>&#13;
<p class="programs">//statically allocated matrix (allocated on stack)<br/>&#13;
int M1[4][3];<br/>&#13;
<br/>&#13;
//dynamically allocated matrix (programmer friendly, allocated on heap)<br/>&#13;
int **M2, i;<br/>&#13;
M2 = malloc(4 * sizeof(int*));<br/>&#13;
for (i = 0; i &lt; 4; i++) {<br/>&#13;
    M2[i] = malloc(3 * sizeof(int));<br/>&#13;
}</p>&#13;
<p class="indent">In the case of the dynamically allocated matrix, the main array contains a contiguous array of <span class="literal">int</span> pointers. Each integer pointer points to a different array in memory. <a href="ch09.xhtml#ch9fig8">Figure 9-8</a> illustrates how we would normally visualize each of these matrices.</p>&#13;
<div class="imagec" id="ch9fig8"><img alt="image" src="../images/09fig08.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-8: Illustration of a statically allocated (<span class="literal">M1</span>) and dynamically allocated (<span class="literal">M2</span>) 3 × 4 matrix</em></p>&#13;
<p class="indent">For both of these matrix declarations, element (<em>i</em>,<em>j</em>) can be accessed using the double-indexing syntax <span class="literal">M[i][j]</span>, where <span class="literal">M</span> is either <span class="literal">M1</span> or <span class="literal">M2</span>. However, these matrices are organized differently in memory. Even though both store the elements in their primary array contiguously in memory, our statically <span epub:type="pagebreak" id="page_516"/>allocated matrix also stores all the rows contiguously in memory, as shown in <a href="ch09.xhtml#ch9fig9">Figure 9-9</a>.</p>&#13;
<div class="imagec" id="ch9fig9"><img alt="image" src="../images/09fig09.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-9: Matrix <span class="literal">M1</span>’s memory layout in row-major order</em></p>&#13;
<p class="indent">This contiguous ordering is not guaranteed for <span class="literal">M2</span>. Recall (from “Two-Dimensional Array Memory Layout” on <a href="ch02.xhtml#lev3_13">page 86</a>) that to contiguously allocate an <em>n</em> × <em>m</em> matrix on the heap, we should use a single call to <span class="literal">malloc</span> that allocates <em>n</em> × <em>m</em> elements:</p>&#13;
<p class="programs">//dynamic matrix (allocated on heap, memory efficient way)<br/>&#13;
#define ROWS 4<br/>&#13;
#define COLS 3<br/>&#13;
int *M3;<br/>&#13;
M3 = malloc(ROWS*COLS*sizeof(int));</p>&#13;
<p class="indent">Recall that with the declaration of <span class="literal">M3</span>, element (<em>i</em>,<em>j</em>) <em>cannot</em> be accessed using the <span class="literal">M[i][j]</span> notation. Instead, we must index the element using the format <span class="literal">M3[i*cols + j]</span>.</p>&#13;
<h4 class="h4" id="lev2_178">9.8.1 Contiguous Two-Dimensional Arrays</h4>&#13;
<p class="noindent">Consider a function <span class="literal">sumMat</span> that takes a pointer to a contiguously allocated (either statically allocated or memory-efficient dynamically allocated) matrix as its first parameter, along with a number of rows and columns, and returns the sum of all the elements inside the matrix.</p>&#13;
<p class="indent">We use scaled indexing in the code snippet that follows because it applies to both statically and dynamically allocated contiguous matrices. Recall that the syntax <span class="literal">m[i][j]</span> does not work with the memory-efficient contiguous dynamic allocation previously discussed.</p>&#13;
<p class="programs">int sumMat(int *m, int rows, int cols) {<br/>&#13;
    int i, j, total = 0;<br/>&#13;
    for (i = 0; i &lt; rows; i++){<br/>&#13;
        for (j = 0; j &lt; cols; j++){<br/>&#13;
            total += m[i*cols + j];<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">Here is the corresponding assembly. Each line is annotated with its English translation:</p>&#13;
<p class="programs">Dump of assembler code for function sumMat:<br/>&#13;
0x884 &lt;+0&gt;:   sub   sp, sp, #0x20      // grow stack by 32 bytes (new frame)<br/>&#13;
<span epub:type="pagebreak" id="page_517"/>0x888 &lt;+4&gt;:   str   x0, [sp, #8]       // store m in location sp + 8<br/>&#13;
0x88c &lt;+8&gt;:   str   w1, [sp, #4]       // store rows in location sp + 4<br/>&#13;
0x890 &lt;+12&gt;:  str   w2, [sp]           // store cols at top of stack<br/>&#13;
0x894 &lt;+16&gt;:  str   wzr, [sp, #28]     // store zero at sp + 28 (total)<br/>&#13;
0x898 &lt;+20&gt;:  str   wzr, [sp, #20]     // store zero at sp + 20 (i)<br/>&#13;
0x89c &lt;+24&gt;:  b     0x904 &lt;sumMat+128&gt; // goto &lt;sumMat+128&gt;<br/>&#13;
0x8a0 &lt;+28&gt;:  str   wzr, [sp, #24]     // store zero at sp + 24 (j)<br/>&#13;
0x8a4 &lt;+32&gt;:  b     0x8e8 &lt;sumMat+100&gt; // goto &lt;sumMat+100&gt;<br/>&#13;
0x8a8 &lt;+36&gt;:  ldr   w1, [sp, #20]      // w1 = i<br/>&#13;
0x8ac &lt;+40&gt;:  ldr   w0, [sp]           // w0 = cols<br/>&#13;
0x8b0 &lt;+44&gt;:  mul   w1, w1, w0         // w1 = cols * i<br/>&#13;
0x8b4 &lt;+48&gt;:  ldr   w0, [sp, #24]      // w0 = j<br/>&#13;
0x8b8 &lt;+52&gt;:  add   w0, w1, w0         // w0 = (cols * i) + j<br/>&#13;
0x8bc &lt;+56&gt;:  sxtw  x0, w0             // x0 = signExtend(cols * i + j)<br/>&#13;
0x8c0 &lt;+60&gt;:  lsl   x0, x0, #2         // x0 = (cols * i + j) * 4<br/>&#13;
0x8c4 &lt;+64&gt;:  ldr   x1, [sp, #8]       // x1 = m<br/>&#13;
0x8c8 &lt;+68&gt;:  add   x0, x1, x0         // x0 = m+(cols*i+j)*4 (or &amp;m[i*cols+j])<br/>&#13;
0x8cc &lt;+72&gt;:  ldr   w0, [x0]           // w0 = m[i*cols + j]<br/>&#13;
0x8d0 &lt;+76&gt;:  ldr   w1, [sp, #28]      // w1 = total<br/>&#13;
0x8d4 &lt;+80&gt;:  add   w0, w1, w0         // w0 = total + m[i*cols + j]<br/>&#13;
0x8d8 &lt;+84&gt;:  str   w0, [sp, #28]      // total is now (total + m[i*cols + j])<br/>&#13;
0x8dc &lt;+88&gt;:  ldr   w0, [sp, #24]      // w0  = j<br/>&#13;
0x8e0 &lt;+92&gt;:  add   w0, w0, #0x1       // w0 = j + 1<br/>&#13;
0x8e4 &lt;+96&gt;:  str   w0, [sp, #24]      // update j  with (j + 1)<br/>&#13;
0x8e8 &lt;+100&gt;: ldr   w1, [sp, #24]      // w1 = j<br/>&#13;
0x8ec &lt;+104&gt;: ldr   w0, [sp]           // w0 = cols<br/>&#13;
0x8f0 &lt;+108&gt;: cmp   w1, w0             // compare j with cols<br/>&#13;
0x8f4 &lt;+112&gt;: b.lt  0x8a8 &lt;sumMat+36&gt;  // if (j &lt; cols) goto &lt;sumMat+36&gt;<br/>&#13;
0x8f8 &lt;+116&gt;: ldr   w0, [sp, #20]      // w0 = i<br/>&#13;
0x8fc &lt;+120&gt;: add   w0, w0, #0x1       // w0 = i + 1<br/>&#13;
0x900 &lt;+124&gt;: str   w0, [sp, #20]      // update i with (i+1)<br/>&#13;
0x904 &lt;+128&gt;: ldr   w1, [sp, #20]      // w1 = i<br/>&#13;
0x908 &lt;+132&gt;: ldr   w0, [sp, #4]       // w0 = rows<br/>&#13;
0x90c &lt;+136&gt;: cmp   w1, w0             // compare i with rows<br/>&#13;
0x910 &lt;+140&gt;: b.lt  0x8a0 &lt;sumMat+28&gt;  // if (i &lt; rows) goto &lt;sumMat+28&gt;<br/>&#13;
0x914 &lt;+144&gt;: ldr   w0, [sp, #28]      // w0 = total<br/>&#13;
0x918 &lt;+148&gt;: add   sp, sp, #0x20      // revert stack to prior state<br/>&#13;
0x91c &lt;+152&gt;: ret                      // return (total)</p>&#13;
<p class="indent">The local variables <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">total</span> are stored at stack locations <span class="literal">sp</span> + 20, <span class="literal">sp</span> + 24, and <span class="literal">sp</span> + 28, respectively. The input parameters <span class="literal">m</span>, <span class="literal">row</span>, and <span class="literal">cols</span> are stored at locations <span class="literal">sp</span> + 8, <span class="literal">sp</span> + 4, and <span class="literal">sp</span> (top of stack), respectively. Using this knowledge, let’s zoom in on the component that just deals with the access of element (<em>i</em>,<em>j</em>) in our matrix (0x8a8–0x8d8):</p>&#13;
<p class="programs">0x8a8 &lt;+36&gt;:   ldr   w1, [sp, #20]       // w1 = i<br/>&#13;
0x8ac &lt;+40&gt;:   ldr   w0, [sp]            // w0 = cols<br/>&#13;
0x8b0 &lt;+44&gt;:   mul   w1, w1, w0          // w1 = cols * i</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_518"/>The first set of instructions calculates the value <span class="literal">cols*i</span> and places it in register <span class="literal">w1</span>. Recall that for some matrix called <span class="literal">matrix</span>, <span class="literal">matrix+i*cols</span> is equivalent to <span class="literal">&amp;matrix[i]</span>.</p>&#13;
<p class="programs">0x8b4 &lt;+48&gt;:   ldr   w0, [sp, #24]       // w0 = j<br/>&#13;
0x8b8 &lt;+52&gt;:   add   w0, w1, w0          // w0 = (cols * i) + j<br/>&#13;
0x8bc &lt;+56&gt;:   sxtw  x0, w0              // x0 = signExtend(cols * i + j)<br/>&#13;
0x8c0 &lt;+60&gt;:   lsl   x0, x0, #2          // x0 = (cols * i + j) * 4</p>&#13;
<p class="indent">The next set of instructions computes <span class="literal">(cols*i + j) * 4</span>. The compiler multiplies the index <span class="literal">cols * i + j</span> by four because each element in the matrix is a four-byte integer, and this multiplication enables the compiler to compute the correct offset. The <span class="literal">sxtw</span> instruction on line <span class="literal">&lt;sumMat+56&gt;</span> sign-extends the contents of <span class="literal">w0</span> into a 64-bit integer, since that value is needed for address calculation.</p>&#13;
<p class="indent">The following set of instructions adds the calculated offset to the matrix pointer and dereferences it to yield the value of element (<em>i</em>,<em>j</em>):</p>&#13;
<p class="programs">0x8c4 &lt;+64&gt;: ldr   x1, [sp, #8]  // x1 = m<br/>&#13;
0x8c8 &lt;+68&gt;: add   x0, x1, x0    // x0 = m + (cols*i + j)*4 (or m[i*cols + j])<br/>&#13;
0x8cc &lt;+72&gt;: ldr   w0, [x0]      // w0 = m[i*cols + j]<br/>&#13;
0x8d0 &lt;+76&gt;: ldr   w1, [sp, #28] // w1 = total<br/>&#13;
0x8d4 &lt;+80&gt;: add   w0, w1, w0    // w0 = total + m[i*cols + j]<br/>&#13;
0x8d8 &lt;+84&gt;: str   w0, [sp, #28] // update total with (total + m[i*cols + j])</p>&#13;
<p class="indent">The first instruction loads the address of matrix <span class="literal">m</span> into register <span class="literal">x1</span>. The <span class="literal">add</span> instruction adds <span class="literal">(cols * i + j) * 4</span> to the address of <span class="literal">m</span> to correctly calculate the offset of element (<em>i</em>,<em>j</em>) and then places the result in register <span class="literal">x0</span>. The third instruction dereferences the address in <span class="literal">x0</span> and places the value (<span class="literal">m[i * cols + j]</span>) into <span class="literal">w0</span>. Notice the use of <span class="literal">w0</span> as the destination component register; since our matrix contains integers, and integers take up four bytes of space, component register <span class="literal">w0</span> is again used instead of <span class="literal">x0</span>.</p>&#13;
<p class="indent">The last three instructions load the current value of <span class="literal">total</span> into register <span class="literal">w1</span>, add <span class="literal">total</span> with <span class="literal">m[i * cols + j]</span>, and then update <span class="literal">total</span> with the resulting sum.</p>&#13;
<p class="indent">Let’s consider how element (1,2) is accessed in matrix <span class="literal">M1</span>.</p>&#13;
<div class="imagec" id="ch9fig10"><img alt="image" src="../images/09fig10.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-10: Matrix <span class="literal">M1</span>’s memory layout in row-major order (reproduced from <a href="ch09.xhtml#ch9fig9">Figure 9-9</a>)</em></p>&#13;
<p class="indent">Element (1,2) is located at address <span class="literal">M1 + 1 * cols + 2</span>. Since <span class="literal">cols</span> = 3, element (1,2) corresponds to <span class="literal">M1 + 5</span>. To access the element at this location, the compiler must multiply 5 by the size of the <span class="literal">int</span> data type (four bytes), yielding the offset <span class="literal">M1 + 20</span>, which corresponds to byte <em>a</em><sub>20</sub> in the figure. Dereferencing this location yields element 5, which is indeed element (1,2) in the matrix.</p>&#13;
<h4 class="h4" id="lev2_179"><span epub:type="pagebreak" id="page_519"/>9.8.2 Noncontiguous Matrix</h4>&#13;
<p class="noindent">The noncontiguous matrix implementation is a bit more complicated. <a href="ch09.xhtml#ch9fig11">Figure 9-11</a> visualizes how <span class="literal">M2</span> may be laid out in memory.</p>&#13;
<div class="imagec" id="ch9fig11"><img alt="image" src="../images/09fig11.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-11: Matrix M2’s noncontiguous layout in memory</em></p>&#13;
<p class="indent">Notice that the array of pointers in <span class="literal">M2</span> is contiguous, and that each array pointed to by some element of <span class="literal">M2</span> (e.g., <span class="literal">M2[i]</span>) is contiguous. However, the individual arrays are not contiguous with one another. Since <span class="literal">M2</span> is an array of pointers, each element of <span class="literal">M2</span> takes eight bytes of space. In contrast, since each <span class="literal">M2[i]</span> is an <span class="literal">int</span> array, the elements of every <span class="literal">M2[i]</span> array are four bytes apart.</p>&#13;
<p class="indent">The <span class="literal">sumMatrix</span> function in the following example takes an array of integer pointers (called <span class="literal">matrix</span>) as its first parameter, and a number of rows and columns as its second and third parameters:</p>&#13;
<p class="programs">int sumMatrix(int **matrix, int rows, int cols) {<br/>&#13;
    int i, j, total=0;<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; cols; j++) {<br/>&#13;
            total += matrix[i][j];<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</p>&#13;
<p class="indent">Even though this function looks nearly identical to the <span class="literal">sumMat</span> function shown earlier, the matrix accepted by this function consists of a contiguous array of <em>pointers</em>. Each pointer contains the address of a separate contiguous array, which corresponds to a separate row in the matrix.</p>&#13;
<p class="indent">The corresponding assembly for <span class="literal">sumMatrix</span> follows. Each line is annotated with its English translation.</p>&#13;
<p class="programs">Dump of assembler code for function sumMatrix:<br/>&#13;
0x920 &lt;+0&gt;:   sub   sp, sp, #0x20         // grow stack 32 bytes (new frame)<br/>&#13;
0x924 &lt;+4&gt;:   str   x0, [sp, #8]          // store matrix at sp + 8<br/>&#13;
0x928 &lt;+8&gt;:   str   w1, [sp, #4]          // store rows at sp + 4<br/>&#13;
0x92c &lt;+12&gt;:  str   w2, [sp]              // store cols at sp (top of stack)<br/>&#13;
0x930 &lt;+16&gt;:  str   wzr, [sp, #28]        // store 0 at sp + 28 (total)<br/>&#13;
0x934 &lt;+20&gt;:  str   wzr, [sp, #20]        // store 0 at sp + 20 (i)<br/><span epub:type="pagebreak" id="page_520"/>&#13;
0x938 &lt;+24&gt;:  b     0x99c &lt;sumMatrix+124&gt; // goto &lt;sumMatrix+124&gt;<br/>&#13;
0x93c &lt;+28&gt;:  str   wzr, [sp, #24]        // store 0 at sp + 24 (j)<br/>&#13;
0x940 &lt;+32&gt;:  b     0x980 &lt;sumMatrix+96&gt;  // goto &lt;sumMatrix+96&gt;<br/>&#13;
0x944 &lt;+36&gt;:  ldrsw x0, [sp, #20]         // x0 = signExtend(i)<br/>&#13;
0x948 &lt;+40&gt;:  lsl   x0, x0, #3            // x0 = i ≪ 3 (or i * 8)<br/>&#13;
0x94c &lt;+44&gt;:  ldr   x1, [sp, #8]          // x1 = matrix<br/>&#13;
0x950 &lt;+48&gt;:  add   x0, x1, x0            // x0 = matrix + i * 8<br/>&#13;
0x954 &lt;+52&gt;:  ldr   x1, [x0]              // x1 = matrix[i]<br/>&#13;
0x958 &lt;+56&gt;:  ldrsw x0, [sp, #24]         // x0 = signExtend(j)<br/>&#13;
0x95c &lt;+60&gt;:  lsl   x0, x0, #2            // x0 = j ≪ 2 (or j * 4)<br/>&#13;
0x960 &lt;+64&gt;:  add   x0, x1, x0            // x0 = matrix[i] + j * 4<br/>&#13;
0x964 &lt;+68&gt;:  ldr   w0, [x0]              // w0 = matrix[i][j]<br/>&#13;
0x968 &lt;+72&gt;:  ldr   w1, [sp, #28]         // w1 = total<br/>&#13;
0x96c &lt;+76&gt;:  add   w0, w1, w0            // w0 = total + matrix[i][j]<br/>&#13;
0x970 &lt;+80&gt;:  str   w0, [sp, #28]         // store total = total+matrix[i][j]<br/>&#13;
0x974 &lt;+84&gt;:  ldr   w0, [sp, #24]         // w0 = j<br/>&#13;
0x978 &lt;+88&gt;:  add   w0, w0, #0x1          // w0 = j + 1<br/>&#13;
0x97c &lt;+92&gt;:  str   w0, [sp, #24]         // update j with (j + 1)<br/>&#13;
0x980 &lt;+96&gt;:  ldr   w1, [sp, #24]         // w1 = j<br/>&#13;
0x984 &lt;+100&gt;: ldr   w0, [sp]              // w0 = cols<br/>&#13;
0x988 &lt;+104&gt;: cmp   w1, w0                // compare j with cols<br/>&#13;
0x98c &lt;+108&gt;: b.lt  0x944 &lt;sumMatrix+36&gt;  // if (j &lt; cols) goto &lt;sumMatrix+36&gt;<br/>&#13;
0x990 &lt;+112&gt;: ldr   w0, [sp, #20]         // w0 = i<br/>&#13;
0x994 &lt;+116&gt;: add   w0, w0, #0x1          // w0 = i + 1<br/>&#13;
0x998 &lt;+120&gt;: str   w0, [sp, #20]         // update i with (i + 1)<br/>&#13;
0x99c &lt;+124&gt;: ldr   w1, [sp, #20]         // w1 = i<br/>&#13;
0x9a0 &lt;+128&gt;: ldr   w0, [sp, #4]          // w0 = rows<br/>&#13;
0x9a4 &lt;+132&gt;: cmp   w1, w0                // compare i with rows<br/>&#13;
0x9a8 &lt;+136&gt;: b.lt  0x93c &lt;sumMatrix+28&gt;  // if (i &lt; rows) goto &lt;sumMatrix+28&gt;<br/>&#13;
0x9ac &lt;+140&gt;: ldr   w0, [sp, #28]         // w0 = total<br/>&#13;
0x9b0 &lt;+144&gt;: add   sp, sp, #0x20         // revert stack to its original form<br/>&#13;
0x9b4 &lt;+148&gt;: ret                         // return (total)</p>&#13;
<p class="indent">Again, variables <span class="literal">i</span>, <span class="literal">j</span>, and <span class="literal">total</span> are at stack addresses <span class="literal">sp</span> + 20, <span class="literal">sp</span> + 24, and <span class="literal">sp</span> + 28, respectively. The input parameters <span class="literal">matrix</span>, <span class="literal">row</span>, and <span class="literal">cols</span> are located at stack addresses <span class="literal">sp</span> + 8, <span class="literal">sp</span> + 4, and <span class="literal">sp</span> (top of stack), respectively.</p>&#13;
<p class="indent">Let’s zoom in on the section that deals specifically with an access to element (<em>i</em>,<em>j</em>), or <span class="literal">matrix[i][j]</span>, which is between instructions 0x944 and 0x970:</p>&#13;
<p class="programs">0x944 &lt;+36&gt;:   ldrsw  x0, [sp, #20]          // x0 = signExtend(i)<br/>&#13;
0x948 &lt;+40&gt;:   lsl    x0, x0, #3             // x0 = i ≪ 3 (or i * 8)<br/>&#13;
0x94c &lt;+44&gt;:   ldr    x1, [sp, #8]           // x1 = matrix<br/>&#13;
0x950 &lt;+48&gt;:   add    x0, x1, x0             // x0 = matrix + i * 8<br/>&#13;
0x954 &lt;+52&gt;:   ldr    x1, [x0]               // x1 = matrix[i]</p>&#13;
<p class="indent">The five instructions in this example compute <span class="literal">matrix[i]</span>, or <span class="literal">*(matrix+i)</span>. Since <span class="literal">matrix[i]</span> contains a pointer, <span class="literal">i</span> is first converted to a 64-bit integer. Then, the compiler multiplies <span class="literal">i</span> by eight by using a shift operation and then <span epub:type="pagebreak" id="page_521"/>adds the result to <span class="literal">matrix</span> to yield the correct address offset (recall that pointers are eight bytes in size). The instruction at <span class="literal">&lt;sumMatrix+52&gt;</span> then dereferences the calculated address to get the element <span class="literal">matrix[i]</span>.</p>&#13;
<p class="indent">Since <span class="literal">matrix</span> is an array of <span class="literal">int</span> pointers, the element located at <span class="literal">matrix[i]</span> is itself an <span class="literal">int</span> pointer. The <em>j</em>th element in <span class="literal">matrix[i]</span> is located at offset <span class="literal">j</span> × 4 in the <span class="literal">matrix[i]</span> array.</p>&#13;
<p class="indent">The next set of instructions extract the <em>j</em>th element in array <span class="literal">matrix[i]</span>:</p>&#13;
<p class="programs">0x958 &lt;+56&gt;:   ldrsw  x0, [sp, #24]     // x0 = signExtend(j)<br/>&#13;
0x95c &lt;+60&gt;:   lsl    x0, x0, #2        // x0 = j ≪ 2 (or j * 4)<br/>&#13;
0x960 &lt;+64&gt;:   add    x0, x1, x0        // x0 = matrix[i] + j * 4<br/>&#13;
0x964 &lt;+68&gt;:   ldr    w0, [x0]          // w0 = matrix[i][j]<br/>&#13;
0x968 &lt;+72&gt;:   ldr    w1, [sp, #28]     // w1 = total<br/>&#13;
0x96c &lt;+76&gt;:   add    w0, w1, w0        // w0 = total + matrix[i][j]<br/>&#13;
0x970 &lt;+80&gt;:   str    w0, [sp, #28]     // store total = total + matrix[i][j]</p>&#13;
<p class="indent">The first instruction in this snippet loads variable <span class="literal">j</span> into register <span class="literal">x0</span>, sign-extending it in the process. The compiler then uses the left shift (<span class="literal">lsl</span>) instruction to multiply <span class="literal">j</span> by four and stores the result in register <span class="literal">x0</span>. The compiler finally adds the resulting value to the address located in <span class="literal">matrix[i]</span> to get the address of element <span class="literal">matrix[i][j]</span>, or <span class="literal">&amp;matrix[i][j]</span>. The instruction at <span class="literal">&lt;sumMatrix+68&gt;</span> then dereferences the address to get the <em>value</em> at <span class="literal">matrix[i][j]</span>, which is then stored in register <span class="literal">w0</span>. Lastly, the instructions from <span class="literal">&lt;sumMatrix+72&gt;</span> through <span class="literal">&lt;sumMatrix+80&gt;</span> add <span class="literal">total</span> to <span class="literal">matrix[i][j]</span> and update the variable <span class="literal">total</span> with the resulting sum.</p>&#13;
<p class="indent">Let’s consider an example access to <span class="literal">M2[1][2]</span>.</p>&#13;
<div class="imagec" id="ch9fig12"><img alt="image" src="../images/09fig12.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-12: Matrix M2’s noncontiguous layout in memory (reproduced from <a href="ch09.xhtml#ch9fig11">Figure 9-11</a>)</em></p>&#13;
<p class="indent">Note that <span class="literal">M2</span> starts at memory location <em>a</em><sub>0</sub>. The compiler first computes the address of <span class="literal">M2[1]</span> by multiplying 1 by 8 (<span class="literal">sizeof(int *)</span>) and adding it to the address of <span class="literal">M2</span> (<em>a</em><sub>0</sub>), yielding the new address <em>a</em><sub>8</sub>. A dereference of this address yields the address associated with <span class="literal">M2[1]</span>, or <em>a</em><sub>36</sub>. The compiler then multiplies index 2 by 4 (<span class="literal">sizeof(int)</span>), and adds the result (8) to <em>a</em><sub>36</sub>, yielding a final address of <em>a</em><sub>44</sub>. The address <em>a</em><sub>44</sub> is dereferenced, yielding the value 5. Sure enough, the element in <a href="ch09.xhtml#ch9fig12">Figure 9-12</a> that corresponds to <span class="literal">M2[1][2]</span> has the value 5.</p>&#13;
<h3 class="h3" id="lev1_81"><span epub:type="pagebreak" id="page_522"/>9.9 structs in Assembly</h3>&#13;
<p class="noindent">A <span class="literal">struct</span> (see “C Structs” on <a href="ch02.xhtml#lev1_15">page 103</a>) is another way to create a collection of data types in C. Unlike arrays, they enable different data types to be grouped together. C stores a <span class="literal">struct</span> like a single-dimension array, where the data elements (fields) are stored contiguously.</p>&#13;
<p class="indent">Let’s revisit <span class="literal">struct studentT</span> from <a href="ch01.xhtml#ch01">Chapter 1</a>:</p>&#13;
<p class="programs">struct studentT {<br/>&#13;
    char name[64];<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentT student;</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9fig13">Figure 9-13</a> shows how <span class="literal">student</span> is laid out in memory. Each <em>a</em><sub><em>i</em></sub> denotes an offset in memory.</p>&#13;
<div class="imagec" id="ch9fig13"><img alt="image" src="../images/09fig13.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-13: The memory layout of <span class="literal">struct studentT</span></em></p>&#13;
<p class="indent">Each field is stored contiguously next to one another in memory in the order in which they are declared. In <a href="ch09.xhtml#ch9fig13">Figure 9-13</a>, the <span class="literal">age</span> field is allocated at the memory location directly after the <span class="literal">name</span> field (at byte offset <em>a</em><sub>64</sub>) and is followed by the <span class="literal">grad_yr</span> (byte offset <em>a</em><sub>68</sub>) and <span class="literal">gpa</span> (byte offset <em>a</em><sub>72</sub>) fields. This organization enables memory-efficient access to the fields.</p>&#13;
<p class="indent">To understand how the compiler generates assembly code to work with a <span class="literal">struct</span>, consider the function <span class="literal">initStudent</span>:</p>&#13;
<p class="programs">void initStudent(struct studentT *s, char *nm, int ag, int gr, float g) {<br/>&#13;
    strncpy(s-&gt;name, nm, 64);<br/>&#13;
    s-&gt;grad_yr = gr;<br/>&#13;
    s-&gt;age = ag;<br/>&#13;
    s-&gt;gpa = g;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">initStudent</span> function uses the base address of a <span class="literal">struct studentT</span> as its first parameter, and the desired values for each field as its remaining parameters. The following listing depicts this function in assembly:</p>&#13;
<p class="programs">Dump of assembler code for function initStudent:<br/>&#13;
0x7f4 &lt;+0&gt;:  stp  x29, x30, [sp, #-48]!  // sp-=48; store x29, x30 at sp, sp+4<br/>&#13;
0x7f8 &lt;+4&gt;:  mov  x29, sp                // x29 = sp (frame ptr = stack ptr)<br/>&#13;
0x7fc &lt;+8&gt;:  str  x0, [x29, #40]         // store s at x29 + 40<br/>&#13;
0x800 &lt;+12&gt;: str  x1, [x29, #32]         // store nm at x29 + 32<br/>&#13;
<span epub:type="pagebreak" id="page_523"/>0x804 &lt;+16&gt;: str  w2, [x29, #28]         // store ag at x29 + 28<br/>&#13;
0x808 &lt;+20&gt;: str  w3, [x29, #24]         // store gr at x29 + 24<br/>&#13;
0x80c &lt;+24&gt;: str  s0, [x29, #20]         // store g at x29 + 20<br/>&#13;
0x810 &lt;+28&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x814 &lt;+32&gt;: mov  x2, #0x40              // x2 = 0x40 (or 64)<br/>&#13;
0x814 &lt;+36&gt;: ldr  x1, [x29, #32]         // x1 = nm<br/>&#13;
0x818 &lt;+40&gt;: bl   0x6e0 &lt;strncpy@plt&gt;    // call strncpy(s, nm, 64) (s-&gt;name)<br/>&#13;
0x81c &lt;+44&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x820 &lt;+48&gt;: ldr  w1, [x29, #24]         // w1 = gr<br/>&#13;
0x824 &lt;+52&gt;: str  w1, [x0, #68]          // store gr at (s + 68) (s-&gt;grad_yr)<br/>&#13;
0x828 &lt;+56&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x82c &lt;+60&gt;: ldr  w1, [x29, #28]         // w1 = ag<br/>&#13;
0x830 &lt;+64&gt;: str  w1, [x0, #64]          // store ag at (s + 64) (s-&gt;age)<br/>&#13;
0x834 &lt;+68&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x838 &lt;+72&gt;: ldr  s0, [x29, #20]         // s0 = g<br/>&#13;
0x83c &lt;+80&gt;: str  s0, [x0, #72]          // store g at (s + 72) (s-&gt;gpa)<br/>&#13;
0x844 &lt;+84&gt;: ldp  x29, x30, [sp], #48    // x29 = sp, x30 = sp+4, sp += 48<br/>&#13;
0x848 &lt;+88&gt;: ret                         // return (void)</p>&#13;
<p class="indent">Being mindful of the byte offsets of each field is key to understanding this code. Here are a few things to keep in mind.</p>&#13;
<p class="indent">The <span class="literal">strncpy</span> call takes the base address of the <span class="literal">name</span> field of <span class="literal">s</span>, the address of array <span class="literal">nm</span>, and a length specifier as its three arguments. Recall that since <span class="literal">name</span> is the first field in <span class="literal">struct studentT</span>, the address of <span class="literal">s</span> is synonymous with the address of <span class="literal">s-&gt;name</span>.</p>&#13;
<p class="programs">0x7fc &lt;+8&gt;:  str  x0, [x29, #40]         // store s at x29 + 40<br/>&#13;
0x800 &lt;+12&gt;: str  x1, [x29, #32]         // store nm at x29 + 32<br/>&#13;
0x804 &lt;+16&gt;: str  w2, [x29, #28]         // store ag at x29 + 28<br/>&#13;
0x808 &lt;+20&gt;: str  w3, [x29, #24]         // store gr at x29 + 24<br/>&#13;
0x80c &lt;+24&gt;: str  s0, [x29, #20]         // store g at x29 + 20<br/>&#13;
0x810 &lt;+28&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x814 &lt;+32&gt;: mov  x2, #0x40              // x2 = 0x40 (or 64)<br/>&#13;
0x814 &lt;+36&gt;: ldr  x1, [x29, #32]         // x1 = nm<br/>&#13;
0x818 &lt;+40&gt;: bl   0x6e0 &lt;strncpy@plt&gt;    // call strncpy(s, nm, 64) (s-&gt;name)</p>&#13;
<p class="indent">The above code snippet contains an undiscussed register (<span class="literal">s0</span>). The <span class="literal">s0</span> register is an example of a register reserved for floating point values.</p>&#13;
<p class="indent">The next part (instructions <span class="literal">&lt;initStudent+44&gt;</span> through <span class="literal">&lt;initStudent+52&gt;</span>) places the value of the <span class="literal">gr</span> parameter at an offset of 68 from the start of <span class="literal">s</span>. Revisiting the memory layout of the struct in <a href="ch09.xhtml#ch9fig13">Figure 9-13</a> shows that this address corresponds to <span class="literal">s-&gt;grad_yr</span>.</p>&#13;
<p class="programs">0x81c &lt;+44&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x820 &lt;+48&gt;: ldr  w1, [x29, #24]         // w1 = gr<br/>&#13;
0x824 &lt;+52&gt;: str  w1, [x0, #68]          // store gr at (s + 68) (s-&gt;grad_yr)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_524"/>The next section (instructions <span class="literal">&lt;initStudent+56&gt;</span> through <span class="literal">&lt;initStudent+64&gt;</span>) copies the <span class="literal">ag</span> parameter to the <span class="literal">s-&gt;age</span> field, which is located at an offset of 64 bytes from the address of <span class="literal">s</span>.</p>&#13;
<p class="programs">0x828 &lt;+56&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x82c &lt;+60&gt;: ldr  w1, [x29, #28]         // w1 = ag<br/>&#13;
0x830 &lt;+64&gt;: str  w1, [x0, #64]          // store ag at (s + 64) (s-&gt;age)</p>&#13;
<p class="indent">Lastly, the <span class="literal">g</span> parameter value is copied to the <span class="literal">s-&gt;gpa</span> field (byte offset 72). Notice the use of the <span class="literal">s0</span> register given that the data contained at location <span class="literal">x29</span> + 20 is single-precision floating point:</p>&#13;
<p class="programs">0x834 &lt;+68&gt;: ldr  x0, [x29, #40]         // x0 = s<br/>&#13;
0x838 &lt;+72&gt;: ldr  s0, [x29, #20]         // s0 = g<br/>&#13;
0x83c &lt;+80&gt;: str  s0, [x0, #72]          // store g at (s + 72) (s-&gt;gpa)</p>&#13;
<h4 class="h4" id="lev2_180">9.9.1 Data Alignment and structs</h4>&#13;
<p class="noindent">Consider the following modified declaration of <span class="literal">studentT</span>:</p>&#13;
<p class="programs">struct studentTM {<br/>&#13;
    char name[63]; //updated to 63 instead of 64<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentTM student2;</p>&#13;
<p class="indent">The size of the <span class="literal">name</span> field is modified to be 63 bytes, instead of the original 64 bytes. Consider how this affects the way the <span class="literal">struct</span> is laid out in memory. It may be tempting to visualize it as in <a href="ch09.xhtml#ch9fig14">Figure 9-14</a>.</p>&#13;
<div class="imagec" id="ch9fig14"><img alt="image" src="../images/09fig14.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-14: An incorrect memory layout for the updated <span class="literal">struct</span> <span class="literal">studentTM</span>. Note that the <span class="literal">name</span> field is reduced from 64 to 63 bytes.</em></p>&#13;
<p class="indent">In this depiction, the <span class="literal">age</span> field occurs in the byte immediately following the <span class="literal">name</span> field. But this is incorrect. <a href="ch09.xhtml#ch9fig15">Figure 9-15</a> depicts the actual layout in memory.</p>&#13;
<div class="imagec" id="ch9fig15"><img alt="image" src="../images/09fig15.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-15: The correct memory layout for the updated <span class="literal">struct</span> <span class="literal">studentTM</span>. Byte <em>a</em><sub>63</sub> is added by the compiler to satisfy memory alignment constraints, but it doesn’t correspond to any of the fields.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_525"/>A64’s alignment policy requires that four-byte data types (e.g., <span class="literal">int</span>) reside at addresses that are a multiple of four, whereas 64-bit data types (<span class="literal">long</span>, <span class="literal">double</span>, and pointer data) reside at addresses that are a multiple of eight. For a <span class="literal">struct</span>, the compiler adds empty bytes as “padding” between fields to ensure that each field satisfies its alignment requirements. For example, in the <span class="literal">struct</span> declared in the previous code snippet, the compiler adds a byte of padding at byte <em>a</em><sub>63</sub> to ensure that the <span class="literal">age</span> field starts at an address that is at a multiple of four. Values aligned properly in memory can be read or written in a single operation, enabling greater efficiency.</p>&#13;
<p class="indent">Consider what happens when the <span class="literal">struct</span> is defined as the following:</p>&#13;
<p class="programs">struct studentTM {<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
    char name[63];<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentTM student3;</p>&#13;
<p class="indent">Moving the <span class="literal">name</span> array to the end ensures that <span class="literal">age</span>, <span class="literal">grad_yr</span>, and <span class="literal">gpa</span> are four-byte aligned. Most compilers will remove the filler byte at the end of the <span class="literal">struct</span>. However, if the <span class="literal">struct</span> is ever used in the context of an array (e.g., <span class="literal">struct studentTM courseSection[20];</span>) the compiler will again add the filler byte as padding between each <span class="literal">struct</span> in the array to ensure that alignment requirements are properly met.</p>&#13;
<h3 class="h3" id="lev1_82">9.10 Real World: Buffer Overflow</h3>&#13;
<p class="noindent">The C language does not perform automatic array bounds checking. Accessing memory outside of the bounds of an array is problematic and often results in errors such as segmentation faults. However, a clever attacker can inject malicious code that intentionally overruns the boundary of an array (also known as a <em>buffer</em>) to force the program to execute in an unintended manner. In the worst cases, the attacker can run code that allows them to gain <em>root privilege</em>, or OS-level access to the computer system. A piece of software that takes advantage of the existence of a known buffer overrun error in a program is known as a <em>buffer overflow exploit</em>.</p>&#13;
<p class="indent">In this section, we use GDB and assembly language to fully characterize the mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage you to explore “Debugging Assembly Code” on <a href="ch03.xhtml#lev1_24">page 177</a>.</p>&#13;
<h4 class="h4" id="lev2_181">9.10.1 Famous Examples of Buffer Overflow</h4>&#13;
<p class="noindent">Buffer overflow exploits emerged in the 1980s and remained a chief scourge of the computing industry through the early parts of the 2000s. Even though many modern operating systems have protections against the simplest buffer overflow attacks, careless programming errors can still leave modern programs <span epub:type="pagebreak" id="page_526"/>wide open to attack. Buffer overflow exploits have recently been discovered in Skype,<sup><a href="ch09.xhtml#fn9_6" id="rfn9_6">6</a></sup> Android,<sup><a href="ch09.xhtml#fn9_7" id="rfn9_7">7</a></sup> Google Chrome,<sup><a href="ch09.xhtml#fn9_8" id="rfn9_8">8</a></sup> and others.</p>&#13;
<p class="indent">Here are some notable historic examples of buffer overflow exploits.</p>&#13;
<h5 class="h5" id="lev3_80">The Morris Worm</h5>&#13;
<p class="noindent">The Morris Worm<sup><a href="ch09.xhtml#fn9_9" id="rfn9_9">9</a></sup> was released in 1998 on ARPANet from MIT (to hide that it was written by a student at Cornell) and exploited a buffer overrun vulnerability that existed in the Unix finger daemon (<span class="literal">fingerd</span>). In Linux and other Unix-like systems, a <em>daemon</em> is a type of process that continuously executes in the background, usually performing clean-up and monitoring tasks. The <span class="literal">fingerd</span> daemon returns a user-friendly report on a computer or person. Most crucially, the worm had a replication mechanism that caused it to be sent to the same computer multiple times, bogging down the system to an unusable state. Even though the author claimed that the worm was meant as a harmless intellectual exercise, the replication mechanism enabled the worm to spread easily and made it difficult to remove. In future years, other worms would employ buffer overflow exploits to gain unauthorized access into systems. Notable examples include Code Red (2001), MS-SQLSlammer (2003), and W32/Blaster (2003).</p>&#13;
<h5 class="h5" id="lev3_81">AOL Chat Wars</h5>&#13;
<p class="noindent">David Auerbach,<sup><a href="ch09.xhtml#fn9_10" id="rfn9_10">10</a></sup> a former Microsoft engineer, detailed his experience with a buffer overflow during his efforts to integrate Microsoft’s Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then, AOL Instant Messenger (AIM) was <em>the</em> service to use if you wanted to instant message (or IM) friends and family. Microsoft tried to gain a foothold in this market by designing a feature in MMS that enabled MMS users to talk to their AIM “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect to them. Microsoft engineers figured out a way for MMS clients to mimic the messages sent by AIM clients to AOL servers, making it difficult for AOL to distinguish between messages received by MMS and AIM. AOL responded by changing the way AIM sent messages, and MMS engineers duly changed their client’s messages to once again match AIM’s. This “chat war” continued until AOL started using a buffer overflow error <em>in their own client</em> to verify that sent messages came from AIM clients. Since MMS clients did not have the same vulnerability, the chat wars ended, with AOL as the victor.</p>&#13;
<h4 class="h4" id="lev2_182">9.10.2 A First Look: The Guessing Game</h4>&#13;
<p class="noindent">To help you understand the mechanism of the buffer overflow attack, we provide an executable of a simple program that enables the user to play a guessing game with the program. Download the <span class="literal">secret</span> executable<sup><a href="ch09.xhtml#fn9_11" id="rfn9_11">11</a></sup> and extract it using the <span class="literal">tar</span> command:</p>&#13;
<p class="programs">$ <span class="codestrong1">tar -xzvf secretARM64.tar.gz</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_527"/>In the following, we provide a copy of the main file associated with the executable:</p>&#13;
<p class="margnote">main.c</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include "other.h"<br/>&#13;
<br/>&#13;
int endGame(void){<br/>&#13;
  printf("You win!\n");<br/>&#13;
  exit(0);<br/>&#13;
}<br/>&#13;
<br/>&#13;
int playGame(void){<br/>&#13;
  int guess, secret, len, x=3;<br/>&#13;
  char buf[12];<br/>&#13;
  printf("Enter secret number:\n");<br/>&#13;
  scanf("%s", buf);<br/>&#13;
  guess = atoi(buf);<br/>&#13;
  secret=getSecretCode();<br/>&#13;
  if (guess == secret)<br/>&#13;
    printf("You got it right!\n");<br/>&#13;
  else{<br/>&#13;
    printf("You are so wrong!\n");<br/>&#13;
    return 1;<br/>&#13;
  }<br/>&#13;
  printf("Enter the secret string to win:\n");<br/>&#13;
  scanf("%s", buf);<br/>&#13;
  guess = calculateValue(buf, strlen(buf));<br/>&#13;
  if (guess != secret){<br/>&#13;
    printf("You lose!\n");<br/>&#13;
    return 2;<br/>&#13;
  }<br/>&#13;
  endGame();<br/>&#13;
  return 0;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main(){<br/>&#13;
  int res = playGame();<br/>&#13;
  return res;<br/>&#13;
}</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_528"/>This game prompts the user to enter first a secret number and then a secret string to win the guessing game. The header file <span class="literal">other.h</span> contains the definition of the <span class="literal">getSecretCode</span> and <span class="literal">calculateValue</span> functions, but it is unavailable to us. How then can a user beat the program? Brute forcing the solution will take too long. One strategy is to analyze the <span class="literal">secret</span> executable in GDB and step through the assembly to reveal the secret number and string. The process of examining assembly code to reveal knowledge of how it works is commonly referred to as <em>reverse engineering</em>. Readers comfortable enough with GDB and reading assembly should be able to use GDB to reverse engineer the secret number and the secret string.</p>&#13;
<p class="indent">However, there is a different, sneakier way to win.</p>&#13;
<h4 class="h4" id="lev2_183">9.10.3 Taking a Closer Look (Under the C)</h4>&#13;
<p class="noindent">The program contains a potential buffer overrun vulnerability at the first call to <span class="literal">scanf</span>. To understand what is going on, let’s inspect the assembly code of the <span class="literal">main</span> function using GDB. Let’s also place a breakpoint at address 0x0000aaaaaaaaa92c, which is the address of the instruction right before the call to <span class="literal">scanf</span> (placing the breakpoint at the address for <span class="literal">scanf</span> causes program execution to halt <em>inside</em> the call to <span class="literal">scanf</span>, not in <span class="literal">main</span>) and then use <span class="literal">ni</span> to advance forward one instruction:</p>&#13;
<p class="programs">Dump of assembler code for function playGame:<br/>&#13;
   0x0000aaaaaaaaa908 &lt;+0&gt;: stp	x29, x30, [sp, #-48]!<br/>&#13;
   0x0000aaaaaaaaa90c &lt;+4&gt;: mov	x29, sp<br/>&#13;
   0x0000aaaaaaaaa910 &lt;+8&gt;: mov	w0, #0x3<br/>&#13;
   0x0000aaaaaaaaa914 &lt;+12&gt;: str	w0, [x29, #44]<br/>&#13;
   0x0000aaaaaaaaa918 &lt;+16&gt;: adrp	x0, 0xaaaaaaaaa000<br/>&#13;
   0x0000aaaaaaaaa91c &lt;+20&gt;: add	x0, x0, #0xac0<br/>&#13;
   0x0000aaaaaaaaa920 &lt;+24&gt;: bl	0xaaaaaaaaa730 &lt;puts@plt&gt;<br/>&#13;
   0x0000aaaaaaaaa924 &lt;+28&gt;: add	x1, x29, #0x18<br/>&#13;
   0x0000aaaaaaaaa928 &lt;+32&gt;: adrp	x0, 0xaaaaaaaaa000<br/>&#13;
   0x0000aaaaaaaaa92c &lt;+36&gt;: add	x0, x0, #0xad8<br/>&#13;
=&gt; 0x0000aaaaaaaaa930 &lt;+40&gt;: bl	0xaaaaaaaaa740 &lt;__isoc99_scanf@plt&gt;</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9fig16">Figure 9-16</a> depicts the stack immediately before the call to <span class="literal">scanf</span>.</p>&#13;
<span epub:type="pagebreak" id="page_529"/>&#13;
<div class="imagec" id="ch9fig16"><img alt="image" src="../images/09fig16.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-16: The call stack immediately before the call to <span class="literal">scanf</span></em></p>&#13;
<p class="indent">Prior to the call to <span class="literal">scanf</span>, the first two arguments for <span class="literal">scanf</span> are preloaded into registers <span class="literal">x0</span> and <span class="literal">x1</span>, respectively. The address of array <span class="literal">buf</span> is stored at stack location <span class="literal">x29</span> + 0x18 (see <span class="literal">&lt;playGame+28&gt;</span>).</p>&#13;
<p class="indent">Now, suppose that the user enters <span class="literal">1234567890</span> at the prompt. <a href="ch09.xhtml#ch9fig17">Figure 9-17</a> illustrates what the stack looks like immediately after the call to <span class="literal">scanf</span> completes.</p>&#13;
<div class="imagec" id="ch9fig17"><img alt="image" src="../images/09fig17.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-17: The call stack immediately after the call to <span class="literal">scanf</span> with input <span class="literal">1234567890</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_530"/>Recall that the hex values for the ASCII encodings of the digits 0 to 9 are 0x30 to 0x39, and that each stack memory location is eight bytes long. The frame pointer for <span class="literal">main</span> is 56 bytes away from the stack pointer. Readers tracing along can confirm the value of <span class="literal">x29</span> by using GDB to print its value (<span class="literal">p x29</span>). In the example shown, the saved value of <span class="literal">x29</span> is 0xffffffffeef0. The following command allows the reader to inspect the 64 bytes (in hex) below register <span class="literal">sp</span>:</p>&#13;
<p class="programs">(gdb) <span class="codestrong1">x /64bx $sp</span></p>&#13;
<p class="indent">This GDB command yields output that looks similar to the following:</p>&#13;
<p class="programs">(gdb) x /64bx $sp<br/>&#13;
0xffffffffeec0:	0xf0 0xee 0xff 0xff 0xff 0xff 0x00 0x00<br/>&#13;
0xffffffffeec8: 0xf0 0xa9 0xaa 0xaa 0xaa 0xaa 0x00 0x00<br/>&#13;
0xffffffffeed0: 0x10 0xef 0xff 0xff 0xff 0xff 0x00 0x00<br/>&#13;
0xffffffffeed8: 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38<br/>&#13;
0xffffffffeee0: 0x39 0x30 0x00 0xaa 0xaa 0xaa 0x00 0x00<br/>&#13;
0xffffffffeee8: 0x00 0x00 0x00 0x00 0x03 0x00 0x00 0x00<br/>&#13;
0xffffffffeef0: 0x10 0xef 0xff 0xff 0xff 0xff 0x00 0x00<br/>&#13;
0xffffffffeef8: 0xe0 0x36 0x58 0xbf 0xff 0xff 0x00 0x00</p>&#13;
<p class="indent">Each line represents one 64-bit address, or two 32-bit addresses. So, the value associated with the 32-bit address 0xffffffffeedc is located at the rightmost four bytes of the line showing 0xffffffffeed8.</p>&#13;
<p class="note"><strong><span class="black">Note</span> MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER</strong></p>&#13;
<p class="note1">In the preceding assembly segment, the byte at address 0xffffffffeec0 is 0xf0, the byte at address 0xffffffffeec1 is 0xee, the byte at address 0xffffffffeec2 is 0xff, the byte at address 0xffffffffeec3 is 0xff, the byte at address 0xffffffffeec4 is 0xff, and the byte at address 0xffffffffeec5 is 0xff. However, the 64-bit <em>value</em> at address 0xffffffffeec0 is in fact 0xffffffffeef0. Remember that because ARM64 is a little-endian system by default (see “Integer Byte Order” on <a href="ch04.xhtml#lev1_34">page 224</a>), the bytes for multibyte values such as addresses are stored in reverse order.</p>&#13;
<p class="indent">In this example, the address for <span class="literal">buf</span> is located at address 0xffffffffeed8. Therefore, the following two addresses hold the bytes associated with input string <span class="literal">1234567890</span>:</p>&#13;
<p class="programs">0xffffffffeed8: 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38<br/>&#13;
0xffffffffeee0: 0x39 0x30 0x00 0xaa 0xaa 0xaa 0x00 0x00</p>&#13;
<p class="indent">The null termination byte <span class="literal">\0</span> appears in the third byte location at address 0xffffffffeee2. Recall that <span class="literal">scanf</span> terminates all strings with a null byte.</p>&#13;
<p class="indent">Of course, <span class="literal">1234567890</span> is not the secret number. Here is the output when we try to run <span class="literal">secret</span> with input string <span class="literal">1234567890</span>:</p>&#13;
<p class="programs">$ <span class="codestrong1">./secret</span><br/>&#13;
<span epub:type="pagebreak" id="page_531"/>Enter secret number:<br/>&#13;
<span class="codestrong1">1234567890</span><br/>&#13;
You are so wrong!<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
1</p>&#13;
<p class="indent">The <span class="literal">echo $?</span> command prints out the return value of the last executed command in the shell. In this case, the program returned 1, because the secret number we entered is wrong. Recall that by convention, programs return 0 when there are no errors. Our goal going forward is to trick the program to exit with a 0 return value, indicating that we won the game.</p>&#13;
<h4 class="h4" id="lev2_184">9.10.4 Buffer Overflow: First Attempt</h4>&#13;
<p class="noindent">Next, let’s try typing in the string <span class="codestrong">12345678901234567890123456789012345</span>:</p>&#13;
<p class="programs">$ <span class="codestrong1">./secret</span><br/>&#13;
Enter secret number:<br/>&#13;
<span class="codestrong1">12345678901234567890123456789012345</span><br/>&#13;
You are so wrong!<br/>&#13;
Bus error<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
139</p>&#13;
<p class="indent">Interesting! Now the program crashes with a bus error (another type of memory error), with return code 139. <a href="ch09.xhtml#ch9fig18">Figure 9-18</a> shows what the call stack for <span class="literal">main</span> looks like immediately after the call to <span class="literal">scanf</span> with this new input.</p>&#13;
<div class="imagec" id="ch9fig18"><img alt="image" src="../images/09fig18.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-18: The call stack immediately after the call to <span class="literal">scanf</span> with input <span class="literal">12345678901234567890123456789012345</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_532"/>The input string is so long that it not only overwrote the saved <span class="literal">x29</span> stored at address 0xeed8, but it spilled over into the return address below the stack frame for <span class="literal">main</span>. Recall that when a function returns, the program tries to resume execution at the address specified by the return address. In this example, the program tries to resume execution at address 0xffff00353433 after exiting <span class="literal">main</span>, which does not appear to exist. So the program crashes with a bus error.</p>&#13;
<p class="indent">Rerunning the program in GDB (<span class="literal">input.txt</span> contains the input string above) reveals this devilry in action:</p>&#13;
<p class="programs">$ <span class="codestrong1">gdb secret</span><br/>&#13;
(gdb) <span class="codestrong1">break *0x0000aaaaaaaaa934</span><br/>&#13;
(gdb) <span class="codestrong1">run &lt; input.txt</span><br/>&#13;
(gdb) <span class="codestrong1">ni</span><br/>&#13;
(gdb) <span class="codestrong1">x /64bx $sp</span><br/>&#13;
0xffffffffeec0: 0xf0 0xee 0xff 0xff 0xff 0xff 0x00 0x00<br/>&#13;
0xffffffffeec8: 0xf0 0xa9 0xaa 0xaa 0xaa 0xaa 0x00 0x00<br/>&#13;
0xffffffffeed0: 0x10 0xef 0xff 0xff 0xff 0xff 0x00 0x00<br/>&#13;
0xffffffffeed8: 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38<br/>&#13;
0xffffffffeee0: 0x39 0x30 0x31 0x32 0x33 0x34 0x35 0x36<br/>&#13;
0xffffffffeee8: 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x34<br/>&#13;
0xffffffffeef0: 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32<br/>&#13;
0xffffffffeef8: 0x33 0x34 0x35 0x00 0xff 0xff 0x00 0x00<br/>&#13;
(gdb) <span class="codestrong1">n</span><br/>&#13;
Single stepping until exit from function playGame,<br/>&#13;
which has no line number information.<br/>&#13;
You are so wrong!<br/>&#13;
0x0000aaaaaaaaa9f0 in main ()<br/>&#13;
(gdb) <span class="codestrong1">n</span><br/>&#13;
Single stepping until exit from function main,<br/>&#13;
which has no line number information.<br/>&#13;
0x0000ffff00353433 in ?? ()</p>&#13;
<p class="indent">Notice that our input string blew past the stated limits of the array <span class="literal">buf</span>, overwriting all the other values stored on the stack. In other words, our string created a buffer overrun and corrupted the call stack, causing the program to crash. This process is also known as <em>smashing the stack</em>.</p>&#13;
<h4 class="h4" id="lev2_185">9.10.5 A Smarter Buffer Overflow: Second Attempt</h4>&#13;
<p class="noindent">Our first example smashed the stack by overwriting the saved <span class="literal">x29</span> register and return address for <span class="literal">main</span> with junk, causing the program to crash. An attacker whose goal is to simply crash a program would be satisfied at this point. However, our goal is to trick the guessing game to return 0, indicating that we won the game. We accomplish this by filling the call stack with data more meaningful than junk values. For example, we could overwrite the stack so that the return address is replaced with the address of <span class="literal">endGame</span>. <span epub:type="pagebreak" id="page_533"/>Then, when the program attempts to return from <span class="literal">main</span>, it will instead execute <span class="literal">endGame</span> instead of crashing.</p>&#13;
<p class="indent">To find out the address of <span class="literal">endGame</span>, let’s inspect <span class="literal">secret</span> again in GDB:</p>&#13;
<p class="programs">$ <span class="codestrong1">gdb secret</span><br/>&#13;
(gdb) <span class="codestrong1">disas endGame</span><br/>&#13;
Dump of assembler code for function endGame:<br/>&#13;
   0x0000aaaaaaaaa8ec &lt;+0&gt;: stp x29, x30, [sp, #-16]!<br/>&#13;
   0x0000aaaaaaaaa8f0 &lt;+4&gt;: mov x29, sp<br/>&#13;
   0x0000aaaaaaaaa8f4 &lt;+8&gt;: adrp x0, 0xaaaaaaaaa000<br/>&#13;
   0x0000aaaaaaaaa8f8 &lt;+12&gt;: add x0, x0, #0xab0<br/>&#13;
   0x0000aaaaaaaaa8fc &lt;+16&gt;: bl 0xaaaaaaaaa730 &lt;puts@plt&gt;<br/>&#13;
   0x0000aaaaaaaaa900 &lt;+20&gt;: mov w0, #0x0<br/>&#13;
   0x0000aaaaaaaaa904 &lt;+24&gt;: bl 0xaaaaaaaaa6d0 &lt;exit@plt&gt;</p>&#13;
<p class="indent">Observe that <span class="literal">endGame</span> starts at address 0x0000aaaaaaaaa8ec. <a href="ch09.xhtml#ch9fig19">Figure 9-19</a> illustrates a sample exploit that forces <span class="literal">secret</span> to run the <span class="literal">endGame</span> function.</p>&#13;
<div class="imagec" id="ch9fig19"><img alt="image" src="../images/09fig19.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-19: A sample string that can force <span class="literal">secret</span> to execute the <span class="literal">endGame</span> function</em></p>&#13;
<p class="indent">Essentially, there are 32 bytes of junk values followed by the return address. Again, because ARM64 is a little-endian system by default, the bytes in the return address appear to be in reverse order.</p>&#13;
<p class="indent">The following program illustrates how an attacker could construct the preceding exploit:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
char ebuff[]=<br/>&#13;
<span epub:type="pagebreak" id="page_534"/>"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*first 10 bytes of junk*/<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*next 10 bytes of junk*/<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*following 10 bytes of junk*/<br/>&#13;
"\x00\x00" /*last 2 bytes of junk*/<br/>&#13;
"\xec\xa8\xaa\xaa\xaa\xaa\x00\x00" /*address of endGame (little endian)*/<br/>&#13;
;<br/>&#13;
<br/>&#13;
int main(void) {<br/>&#13;
    int i;<br/>&#13;
    for (i = 0; i &lt; sizeof(ebuff); i++) { /*print each character*/<br/>&#13;
        printf("%c", ebuff[i]);<br/>&#13;
    }<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">The <span class="literal">\x</span> before each number indicates that the number is formatted as the hexadecimal representation for a character. After defining <span class="literal">ebuff[]</span>, the <span class="literal">main</span> function simply prints it out, character by character. To get the associated byte string, compile and run this program as follows:</p>&#13;
<p class="programs">$ <span class="codestrong1">gcc -o genEx genEx.c</span><br/>&#13;
$ <span class="codestrong1">./genEx &gt; exploit</span></p>&#13;
<p class="indent">To use <span class="literal">exploit</span> as input to <span class="literal">scanf</span>, it suffices to run <span class="literal">secret</span> with <span class="literal">exploit</span>. To get the exploit to work on a Raspberry Pi, type the following set of commands as root (we will explain what is going on following the example):</p>&#13;
<p class="programs">$ <span class="codestrong1">sudo su</span><br/>&#13;
[sudo] password for pi:<br/>&#13;
root@pi# <span class="codestrong1">echo "0" &gt; /proc/sys/kernel/randomize_va_space</span><br/>&#13;
root@pi# <span class="codestrong1">exit</span><br/>&#13;
$</p>&#13;
<p class="indent">The <span class="literal">sudo su</span> command puts you in root mode on the Raspberry Pi. When prompted for a password, use your password (we assume you have root access to the Raspberry Pi). As soon as the password is entered, the next set of commands are typed in root mode. Note that the command prompt changes when a user is in root mode (it looks something like <span class="literal">root@pi#</span>).</p>&#13;
<p class="indent">The <span class="literal">echo</span> command overwrites the contents of the file <span class="literal">randomize_va_space</span> with the value 0. Next, the <span class="literal">exit</span> command returns the user back to user mode.</p>&#13;
<p class="indent">Now, type the following command at the prompt:</p>&#13;
<p class="programs">$ <span class="codestrong1">./secret &lt; exploit</span><br/>&#13;
Enter secret number:<br/>&#13;
You are so wrong!<br/>&#13;
You win!</p>&#13;
<p class="indent">The program prints out “You are so wrong!” because the string contained in <span class="literal">exploit</span> is <em>not</em> the secret number. However, the program also prints <span epub:type="pagebreak" id="page_535"/>out the string “You win!” Recall, though, that our goal is to trick the program to return 0. In a larger system, where the notion of “success” is tracked by an external program, it is often most important what a program returns, not what it prints out.</p>&#13;
<p class="indent">Checking the return value yields:</p>&#13;
<p class="programs">$ <span class="codestrong1">echo $?</span><br/>&#13;
0</p>&#13;
<p class="indent">Our exploit works! We won the game!</p>&#13;
<h4 class="h4" id="lev2_186">9.10.6 Protecting Against Buffer Overflow</h4>&#13;
<p class="noindent">The example we showed changed the control flow of the <span class="literal">secret</span> executable, forcing it to return a zero value associated with success. We had to accomplish this in a fairly wonky way due to stack protections that ARM and GCC include to combat this particular type of attack. However, buffer overflow exploits can do real damage on older systems. Some older computer systems also <em>executed</em> bytes from stack memory. If an attacker placed bytes associated with assembly instructions on the call stack, the CPU would interpret the bytes as <em>real</em> instructions, enabling the attacker to force the CPU to execute <em>any arbitrary code of their choosing</em>. Fortunately, there are strategies that modern computer systems employ to make it more difficult for attackers to run buffer overflow exploits:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Stack randomization.</strong>   The OS allocates the starting address of the stack at a random location in stack memory, causing the position/size of the call stack to vary from one run of a program to another. When we overwrote the <span class="literal">/proc/sys/kernel/randomize_va_space</span> file with a 0 value, we temporarily turned off stack randomization on the Raspberry Pi (this file returns to its original value on restart). Without turning off stack randomization, multiple machines running the same code would have different stack addresses. Modern Linux systems use stack randomization as a standard practice. However, a determined attacker can brute force the attack, by attempting to repeat attacks with different addresses. A common trick is to use a <em>NOP sled</em> (i.e., a large number of NOP instructions) before the actual exploit code. Executing the NOP instruction (<span class="literal">0x90</span>) has no effect, other than causing the program counter to increment to the next instruction. As long as the attacker can get the CPU to execute somewhere in the NOP sled, the NOP sled will eventually lead to the exploit code that follows it. Aleph One’s writeup<sup><a href="ch09.xhtml#fn9_12" id="rfn9_12">12</a></sup> details the mechanism of this type of attack.</p>&#13;
<p class="ul-noindent"><strong>Stack corruption detection.</strong>   Another line of defense is to try to detect when the stack is corrupted. Recent versions of GCC use a stack protector known as a <em>canary</em> that acts as a guard between the buffer and the other elements of the stack. A canary is a value stored in a nonwriteable section of memory that can be compared to a value put on the stack. If the canary “dies” during a program’s execution, the program knows that <span epub:type="pagebreak" id="page_536"/>it is under attack and aborts with an error message. For simplicity, we removed the canary from our <span class="literal">secret</span> executable by compiling it with the <span class="literal">fno-stack-protector</span> flag in GCC. However, a clever attacker can replace the canary during the course of the attack to prevent the program from detecting stack corruption.</p>&#13;
<p class="ul-noindent"><strong>Limiting executable regions.</strong>   In this line of defense, executable code is restricted to only particular regions of memory. In other words, the call stack is no longer executable. However, even this defense can be defeated. In an attack utilizing <em>return-oriented programming</em> (ROP), an attacker can “cherry-pick” instructions in executable regions and jump from instruction to instruction to build an exploit. There are some famous examples of this online, especially in video games.<sup><a href="ch09.xhtml#fn9_13" id="rfn9_13">13</a></sup></p>&#13;
</div>&#13;
<p class="indent">However, the best line of defense is always the programmer. To prevent buffer overflow attacks on your programs, use C functions with <em>length specifiers</em> whenever possible and add code that performs array bounds checking. It is crucial that any defined arrays match the chosen length specifiers. <a href="ch09.xhtml#ch9tab16">Table 9-16</a> lists some common “bad” C functions that are vulnerable to buffer overflow, and the corresponding “good” function to use (assume that <span class="literal">buf</span> is allocated 12 bytes):</p>&#13;
<p class="tabcap" id="ch9tab16"><strong>Table 9-16:</strong> C Functions with Length Specifiers</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instead of</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Use</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">gets(buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">fgets(buf, 12, stdin)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">scanf("%s", buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">scanf("%12s", buf)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strcpy(buf2, buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strncpy(buf2, buf, 12)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strcat(buf2, buf)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">strncat(buf2, buf, 12)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">sprintf(buf, "%d", num)</span></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><span class="literal">snprintf(buf, 12, "%d", num)</span></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <span class="literal">secret2</span> binary<sup><a href="ch09.xhtml#fn9_14" id="rfn9_14">14</a></sup> no longer has the buffer overflow vulnerability. The <span class="literal">playGame</span> function of this new binary appears as follows:</p>&#13;
<p class="margnote">main2.c</p>&#13;
<p class="programs">int playGame(void){<br/>&#13;
  int guess, secret, len, x=3;<br/>&#13;
  char buf[12];<br/>&#13;
  printf("Enter secret number:\n");<br/>&#13;
  scanf("%12s", buf); //lengths specifier added here!<br/>&#13;
  guess = atoi(buf);<br/>&#13;
  secret=getSecretCode();<br/>&#13;
  if (guess == secret)<br/>&#13;
    printf("You got it right!\n");<br/>&#13;
  else{<br/>&#13;
    printf("You are so wrong!\n");<br/>&#13;
    return 1;<br/>&#13;
  }<br/>&#13;
  printf("Enter the secret string to win:\n");<br/>&#13;
  scanf("%12s", buf); //length specifier added here!<br/>&#13;
<span epub:type="pagebreak" id="page_537"/>&#13;
  guess = calculateValue(buf, strlen(buf));<br/>&#13;
  if (guess != secret){<br/>&#13;
    printf("You lose!\n");<br/>&#13;
    return 2;<br/>&#13;
  }<br/>&#13;
  endGame();<br/>&#13;
  return 0;<br/>&#13;
}</p>&#13;
<p class="indent">Notice that we added a length specifier to all calls of <span class="literal">scanf</span>, causing the <span class="literal">scanf</span> function to stop reading from input after the first 12 bytes are read. The exploit string no longer breaks the program:</p>&#13;
<p class="programs">$ <span class="codestrong1">./secret2 &lt; exploit</span><br/>&#13;
Enter secret number:<br/>&#13;
You are so wrong!<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
1</p>&#13;
<p class="indent">Of course, any reader with basic reverse-engineering skills can still win the guessing game by analyzing the assembly code. If you haven’t tried to beat the program yet with reverse engineering, we encourage you to do so now.</p>&#13;
<h3 class="h3" id="lev1_83">Notes</h3>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_1" id="fn9_1">1.</a> <em><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads">https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads</a></em></p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_2" id="fn9_2">2.</a> <em><a href="https://www.qemu.org/">https://www.qemu.org/</a></em></p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_3" id="fn9_3">3.</a> <em><a href="https://aws.amazon.com/ec2/instance-types/a1/">https://aws.amazon.com/ec2/instance-types/a1/</a></em></p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_4" id="fn9_4">4.</a> Edsger Dijkstra,“Go To Statement Considered Harmful,” <em>Communications of the ACM</em> 11(3), pp. 147–148, 1968.</p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_5" id="fn9_5">5.</a> <em><a href="https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes">https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes</a></em></p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_6" id="fn9_6">6.</a> Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely Execute Malicious Code,” <em><a href="https://thehackernews.com/2017/06/skype-crash-bug.html">https://thehackernews.com/2017/06/skype-crash-bug.html</a></em>, 2017.</p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_7" id="fn9_7">7.</a> Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow in multiple Android DRM services,” <em><a href="https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/">https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/</a></em>, 2018.</p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_8" id="fn9_8">8.</a> Tom Spring, “Google Patches ‘High Severit’ Browser Bug,” <em><a href="https://threatpost.com/google-patches-high-severity-browser-bug/128661/">https://threatpost.com/google-patches-high-severity-browser-bug/128661/</a></em>, 2017.</p>&#13;
<p class="fnote"><a href="ch09.xhtml#rfn9_9" id="fn9_9">9.</a> Christopher Kelty, “The Morris Worm,” <em>Limn Magazine</em>, Issue 1: Systemic Risk, 2011. <em><a href="https://limn.it/articles/the-morris-worm/">https://limn.it/articles/the-morris-worm/</a></em></p>&#13;
<p class="fnote1"><a href="ch09.xhtml#rfn9_10" id="fn9_10">10.</a> David Auerbach, “Chat Wars: Microsoft vs. AOL,” <em>NplusOne Magazine</em>, Issue 19, Spring 2014. <em><a href="https://nplusonemag.com/issue-19/essays/chat-wars/">https://nplusonemag.com/issue-19/essays/chat-wars/</a></em></p>&#13;
<p class="fnote1"><a href="ch09.xhtml#rfn9_11" id="fn9_11">11.</a> <em><a href="https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz">https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz</a></em></p>&#13;
<p class="fnote1"><a href="ch09.xhtml#rfn9_12" id="fn9_12">12.</a> Aleph One, “Smashing the Stack for Fun and Profit,” <em><a href="http://insecure.org/stf/smashstack.html">http://insecure.org/stf/smashstack.html</a></em>, 1996.</p>&#13;
<p class="fnote1"><span epub:type="pagebreak" id="page_538"/><a href="ch09.xhtml#rfn9_13" id="fn9_13">13.</a> DotsAreCool, “Super Mario World Credit Warp” (Nintendo ROP example), <em><a href="https://youtu.be/vAHXK2wut_I">https://youtu.be/vAHXK2wut_I</a></em>, 2015.</p>&#13;
<p class="fnote1"><a href="ch09.xhtml#rfn9_14" id="fn9_14">14.</a> <em><a href="https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz">https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz</a></em></p>&#13;
</body></html>