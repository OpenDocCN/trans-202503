<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch11">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label=" Page 201. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">EARLY LAUNCH ANTIMALWARE DRIVERS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">In 2012, adversaries launched the Zacinlo adware campaign, whose rootkit, a member of the Detrahere family, includes a number of self-protection features. One of the most interesting is its persistence mechanism.</p>&#13;
<p class="TX">Similar to the callback routines discussed in <span class="Xref"><a href="chapter3.xhtml">Chapters 3</a> through <a href="chapter5.xhtml">5</a></span>, drivers can register callback routines called <i>shutdown handlers</i> that let them perform some action when the system is shutting down. To ensure that their rootkit persisted on the system, the Zacinlo rootkit developers used a shutdown handler to rewrite the driver to disk under a new name and create new registry keys for a service that would relaunch the rootkit as a boot-start driver. If anyone made an attempt to clean the rootkit from the system, the driver would simply drop these files and keys, allowing it to persist much more effectively.</p>&#13;
<p class="TX">While this malware is no longer prevalent, it highlights a large gap in protection software: the ability to mitigate threats that operate early in the boot process. To address this weakness, Microsoft introduced a new antimalware feature in Windows 8 that allows certain special drivers to load <span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label=" Page 202. "/>before all other boot-start drivers. Today, nearly all EDR vendors leverage this capability, called <i>Early Launch Antimalware (ELAM)</i>, in some way, as it offers the ability to affect the system extremely early in the boot process. It also provides access to specific types of system telemetry not available to other components.</p>&#13;
<p class="TX">This chapter covers the development, deployment, and boot-start protection functionality of ELAM drivers, as well as strategies for evading these drivers. In <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, we’ll cover the telemetry sources and process protections available to vendors that deploy ELAM drivers to hosts.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-146"/><samp class="SANS_Futura_Std_Bold_B_11">How ELAM Drivers Protect the Boot Process</samp></h2>&#13;
<p class="TNI">Microsoft lets third-party drivers load early in the boot process so that software vendors can initialize those that are critical to the system. However, this is a double-edged sword. While it provides a useful way to guarantee the loading of critical drivers, malware authors too can insert their rootkits into these early-load-order groups. If a malicious driver is able to load before antivirus or other security-related drivers, it could tamper with the system to keep those protection drivers from working as intended or prevent them from loading in the first place.</p>&#13;
<p class="TX">To avoid these attacks, Microsoft needed a way to load endpoint security drivers earlier in the boot process, before any malicious driver can load. The primary function of an ELAM driver is to receive notifications when another driver attempts to load during the boot process, then decide whether to allow it to load. This validation process is part of Trusted Boot, the Windows security feature responsible for validating the digital signature of the kernel and other components, like drivers, and only vetted antimalware vendors can participate in it.</p>&#13;
<p class="TX">To publish an ELAM driver, developers must be part of the Microsoft Virus Initiative (MVI), a program open to antimalware companies that produce security software for the Windows operating system. As of this writing, in order to qualify to participate in this program, vendors must have a positive reputation (assessed by conference participation and industry-standard reports, among other factors), submit their applications to Microsoft for performance testing and feature review, and provide their solution for independent testing. Vendors must also sign a nondisclosure agreement, which is likely why those with knowledge of this program have been tight-lipped.</p>&#13;
<p class="TX">The Microsoft Virus Initiative and ELAM are closely tied. To create a <i>production driver</i> (one that can be deployed to systems not in test-signing mode), Microsoft must countersign the driver. This countersignature uses a special certificate, visible in the ELAM driver’s digital signature information under <i>Microsoft Windows Early Launch Anti-malware Publisher</i>, as shown in <a href="#fig11-1">Figure 11-1</a>. This countersignature is available to participants of the Microsoft Virus Initiative program only.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label=" Page 203. "/>&#13;
<figure class="IMG"><img id="fig11-1" class="img60" src="../images/Figure11-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: Microsoft’s countersignature on an ELAM driver</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Without this signature, the driver won’t be able to load as part of the <i>Early-Launch</i> service group discussed in <span class="Xref">“Loading an ELAM Driver” on <a href="#sec6">page 208</a></span>. For this reason, the examples in this chapter target a system with test-signing enabled, allowing us to ignore the countersigning requirement. The process and code described here are the same as for production ELAM drivers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-147"/><samp class="SANS_Futura_Std_Bold_B_11">Developing ELAM Drivers</samp></h2>&#13;
<p class="TNI">In many ways, ELAM drivers resemble the drivers covered in the previous chapters; they use callbacks to receive information about system events and make security decisions on the local host. ELAM drivers focus specifically on prevention rather than detection, however. When an ELAM driver is started early in the boot process, it evaluates every boot-start driver on the system and either approves or denies the load based on its own internal malware-signature data and logic, as well as a system policy that dictates the host’s risk tolerance. This section covers the process of developing an ELAM driver, including its internal workings and decision logic.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-148"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering Callback Routines</samp></h3>&#13;
<p class="TNI">The first ELAM-specific action the driver takes is to register its callback routines. ELAM drivers commonly use both registry and boot-start callbacks. The registry callback functions, registered with <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmRegisterCallbackEx()</samp>, validate the configuration data of the drivers being loaded in the registry, and we covered them extensively in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, so we won’t revisit them here.</p>&#13;
<p class="TX">More interesting is the boot-start callback routine, registered with <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IoRegisterBootDriverCallback()</samp>. This callback provides the ELAM driver <span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label=" Page 204. "/>with updates about the status of the boot process, as well as information about each boot-start driver being loaded. Boot-start callback functions are passed to the registration function as a <samp class="SANS_TheSansMonoCd_W5Regular_11">PBOOT_DRIVER_CALLBACK_FUNCTION</samp> and must have a signature matching the one shown in <a href="#list11-1">Listing 11-1</a>.</p>&#13;
<pre id="list11-1"><code>void BootDriverCallbackFunction(&#13;
   PVOID CallbackContext,&#13;
   BDCB_CALLBACK_TYPE Classification,&#13;
   PBDCB_IMAGE_INFORMATION ImageInformation&#13;
)</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-1: An ELAM driver callback signature</span></p>&#13;
<p class="TX">During the boot process, this callback routine receives two different types of events, dictated by the value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp> input parameter. These are defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_CALLBACK_TYPE</samp> enum shown in <a href="#list11-2">Listing 11-2</a>.</p>&#13;
<pre id="list11-2"><code>typedef enum _BDCB_CALLBACK_TYPE {&#13;
   BdCbStatusUpdate,&#13;
   BdCbInitializeImage,&#13;
} BDCB_CALLBACK_TYPE, *PBDCB_CALLBACK_TYPE;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_CALLBACK_TYPE</samp> enumeration</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusUpdate</samp> events tell the ELAM driver how far the system has gotten in the process of loading boot-start drivers so that the driver may act appropriately. It can report any of three states, shown in <a href="#list11-3">Listing 11-3</a>.</p>&#13;
<pre id="list11-3"><code>typedef enum _BDCB_STATUS_UPDATE_TYPE {&#13;
  BdCbStatusPrepareForDependencyLoad,&#13;
  BdCbStatusPrepareForDriverLoad,&#13;
  BdCbStatusPrepareForUnload&#13;
} BDCB_STATUS_UPDATE_TYPE, *PBDCB_STATUS_UPDATE_TYPE;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_STATUS_UPDATE_TYPE</samp> values</span></p>&#13;
<p class="TX">The first of these values indicates that the system is about to load driver dependencies. The second indicates that the system is about to load boot-start drivers. The last indicates that all boot-start drivers have been loaded, so the ELAM driver should prepare to be unloaded.</p>&#13;
<p class="TX">During the first two states, the ELAM driver will receive another type of event that correlates to the loading of a boot-start driver’s image. This event, passed to the callback as a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_IMAGE_INFORMATION</samp> structure, is defined in <a href="#list11-4">Listing 11-4</a>.</p>&#13;
<pre id="list11-4"><code>typedef struct _BDCB_IMAGE_INFORMATION {&#13;
   BDCB_CLASSIFICATION Classification;&#13;
   ULONG ImageFlags;&#13;
   UNICODE_STRING ImageName;&#13;
   UNICODE_STRING RegistryPath;&#13;
   UNICODE_STRING CertificatePublisher;&#13;
   UNICODE_STRING CertificateIssuer;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label=" Page 205. "/>&#13;
   PVOID ImageHash;&#13;
   PVOID CertificateThumbprint;&#13;
   ULONG ImageHashAlgorithm;&#13;
   ULONG ThumbprintHashAlgorithm;&#13;
   ULONG ImageHashLength;&#13;
   ULONG CertificateThumbprintLength;&#13;
} BDCB_IMAGE_INFORMATION, *PBDCB_IMAGE_INFORMATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-4: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_IMAGE_INFORMATION</samp> structure definition</span></p>&#13;
<p class="TX">As you can see, this structure contains the bulk of the information used to decide whether some driver is a rootkit. Most of it relates to the image’s digital signature, and it notably omits a few fields you might expect to see, such as a pointer to the contents of the image on disk. This is due in part to the performance requirements imposed on ELAM drivers. Because they can affect system boot times (as they’re initialized every time Windows boots), Microsoft imposes a time limit of 0.5 ms for the evaluation of each boot-start driver and 50 ms for the evaluation of all boot-start drivers together, within a 128KB memory footprint. These performance requirements limit what an ELAM driver can do; for instance, it is too time-intensive to scan the contents of an image. Therefore, developers typically rely on static signatures to identify malicious drivers.</p>&#13;
<p class="TX">During the boot process, the operating system loads the signatures in use by ELAM drivers into an early-launch drivers registry hive under <i>HKLM:\ELAM\</i>, followed by the vendor’s name (for example, <i>HKLM:\ELAM\Windows Defender</i> for Microsoft Defender, shown in <a href="#fig11-2">Figure 11-2</a>). This hive is unloaded later in the boot process and is not present in the registry by the time users start their sessions. If the vendor wishes to update signatures in this hive, they may do so from user mode by mounting the hive containing the signatures from <i>%SystemRoot%\System32\config\ELAM</i> and modifying their key.</p>&#13;
<figure class="IMG"><img id="fig11-2" class="img100" src="../images/Figure11-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: Microsoft Defender in the ELAM registry hive</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label=" Page 206. "/>Vendors can use three values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_BINARY</samp> in this key: <samp class="SANS_TheSansMonoCd_W5Regular_11">Measured</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Policy</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Config</samp>. Microsoft hasn’t published formal public documentation about the purposes of these values or their differences. However, the company does state that the signature data blob must be signed and its integrity validated using <i>Cryptography API: Next Generation (CNG)</i> primitive cryptographic functions before the ELAM driver begins making decisions regarding the status of the boot-start driver.</p>&#13;
<p class="TX">No standard exists for how the signature blobs must be structured or used once the ELAM driver has verified their integrity. In case you’re interested, however, in 2018 the German <i>Bundesamt für Sicherheit in der Informationstechnik</i> (BSI) published its Work Package 5, which includes an excellent walk-through of how Defender’s <i>wdboot.sys</i> performs its own integrity checks and parses its signature blocks.</p>&#13;
<p class="TX">If the cryptographic validation of the signature blob fails for any reason, the ELAM driver must return the <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbClassificationUnknownImage</samp> classification for all boot-start drivers using its callback, as the signature data isn’t considered reliable and shouldn’t affect <i>Measured Boot</i>, the Windows feature that measures each boot component from the firmware to the drivers and stores the results in the Trusted Platform Module (TPM), where it can be used to validate the integrity of the host.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-149"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Applying Detection Logic</samp></h3>&#13;
<p class="TNI">Once the ELAM driver has received the <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusPrepareForDriverLoad</samp> status update and pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_IMAGE_INFORMATION</samp> structures for each boot-load driver, it applies its detection logic using the information provided in the structure. Once it has made a determination, the driver updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp> member of the current image-information structure (not to be confused with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp> input parameter passed to the callback function) with a value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_CLASSIFICATION</samp> enumeration, defined in <a href="#list11-5">Listing 11-5</a>.</p>&#13;
<pre id="list11-5"><code>typedef enum _BDCB_CLASSIFICATION {&#13;
     BdCbClassificationUnknownImage,&#13;
     BdCbClassificationKnownGoodImage,&#13;
     BdCbClassificationKnownBadImage,&#13;
     BdCbClassificationKnownBadImageBootCritical,&#13;
     BdCbClassificationEnd,&#13;
} BDCB_CLASSIFICATION, *PBDCB_CLASSIFICATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-5: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">The BDCB_CLASSIFICATION</samp> enumeration</span></p>&#13;
<p class="TX">Microsoft defines these values as follows, from top to bottom: the image hasn’t been analyzed, or a determination regarding its maliciousness can’t be made; the ELAM driver has found no malware; the ELAM driver detected malware; the boot-load driver is malware, but it is critical to the boot process; and the boot-load driver is reserved for system use. The ELAM driver sets one of these classifications for each boot-start driver until it receives the <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusPrepareForUnload</samp> status update instructing it to clean up. The ELAM driver is then unloaded.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label=" Page 207. "/>Next, the operating system evaluates the classifications returned by each ELAM driver and takes action if needed. To determine which action to take, Windows consults the registry key <i>HKLM:\System\CurrentControlSet\Control\EarlyLaunch\DriverLoadPolicy</i>, which defines the drivers allowed to run on the system. This value, read by <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IopInitializeBootDrivers()</samp>, can be any of the options included in <a href="#tab11-1">Table 11-1</a>.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab11-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp> <samp class="SANS_Futura_Std_Book_11">Possible Driver Load-Policy Values</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Value</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Good drivers only</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Good and unknown drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Good, unknown, and bad but critical to the boot process (Default)</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">All drivers</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">The kernel (specifically, the Plug and Play manager) uses the classification specified by the ELAM driver to prevent any banned drivers from loading. All other drivers are allowed to load, and system boot continues as normal.</p>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT"><i>If the ELAM driver identifies a known malicious boot-start driver and is running on a system that leverages Measured Boot, developers must call <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tbs!Tbsi_Revoke_Attestation()</samp>. What this function does is a bit technical; essentially, it extends a platform configuration register bank in the TPM, specifically <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PCR[12]</samp>, by an unspecified value and then increments the TPM’s event counter, breaking trust in the security state of the system.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h-150"/><samp class="SANS_Futura_Std_Bold_B_11">An Example Driver: Preventing Mimidrv from Loading</samp></h2>&#13;
<p class="TNI">The debugger output in <a href="#list11-6">Listing 11-6</a> shows debug messaging from an ELAM driver when it encounters a known malicious driver, Mimikatz’s Mimidrv, and prevents it from loading.</p>&#13;
<pre id="list11-6"><code>[ElamProcessInitializeImage] The following boot start driver is about to be initialized:&#13;
    Image name: \SystemRoot\System32\Drivers\mup.sys&#13;
    Registry Path: \Registry\Machine\System\CurrentControlSet\Services\Mup&#13;
    Image Hash Algorithm: 0x0000800c&#13;
    Image Hash: cf2b679a50ec16d028143a2929ae56f9117b16c4fd2481c7e0da3ce328b1a88f&#13;
    Signer: Microsoft Windows&#13;
    Certificate Issuer: Microsoft Windows Production PCA 2011&#13;
    Certificate Thumbprint Algorithm: 0x0000800c&#13;
    Certificate Thumbprint: a22f7e7385255df6c06954ef155b5a3f28c54eec85b6912aaaf4711f7676a073&#13;
<b>[ElamProcessInitializeImage] The following boot start driver is about to be initialized:</b>&#13;
<b>[ElamProcessInitializeImage] Found a suspected malicious driver (\SystemRoot\system32\drivers\</b>&#13;
<b>mimidrv.sys). Marking its classification accordingly</b>&#13;
[ElamProcessInitializeImage] The following boot start driver is about to be initialized:&#13;
    Image name: \SystemRoot\system32\drivers\iorate.sys&#13;
    Registry Path: \Registry\Machine\System\CurrentControlSet\Services\iorate&#13;
    Image Hash Algorithm: 0x0000800c<span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label=" Page 208. "/>&#13;
    Image Hash: 07478daeebc544a8664adb00704d71decbc61931f9a7112f9cc527497faf6566&#13;
    Signer: Microsoft Windows&#13;
    Certificate Issuer: Microsoft Windows Production PCA 2011&#13;
    Certificate Thumbprint Algorithm: 0x0000800c&#13;
    Certificate Thumbprint: 3cd79dfbdc76f39ab4855ddfaeff846f240810e8ec3c037146b88cb5052efc08</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-6: ELAM driver output showing the detection of Mimidrv</span></p>&#13;
<p class="TX">In this example, you can see that the ELAM driver allows other boot-start drivers to load: the native Universal Naming Convention driver, <i>mup.sys</i>, and the Disk I/O Rate Filter driver, <i>iorate.sys</i>, both of which are signed by Microsoft. Between these two drivers, it detects Mimidrv using the file’s known cryptographic hash. Because it deems this driver to be malicious, it prevents Mimidrv from loading on the system before the operating system is fully initialized and without requiring any interaction from the user or other EDR components.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h-151"/><samp class="SANS_Futura_Std_Bold_B_11">Loading an ELAM Driver</samp></h2>&#13;
<p class="TNI">Before you can load your ELAM driver, you must complete a few preparatory steps: signing the driver and assigning its load order.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-152"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signing the Driver</samp></h3>&#13;
<p class="TNI">The most headache-inducing part of deploying an ELAM driver, especially during development and testing, is ensuring that its digital signature meets Microsoft’s requirements for loading on the system. Even when operating in test-signing mode, the driver must have specific certificate attributes.</p>&#13;
<p class="TX">Microsoft publishes limited information about the process of test-signing an ELAM driver. In its demo, Microsoft says the following:</p>&#13;
<blockquote>&#13;
<p class="EX">Early Launch drivers are required to be signed with a code-signing certificate that also contains the Early Launch EKU “1.3.6.1.4.1.311.61.4.1” […] and the “1.3.6.1.5.5.7.3.3” Code Signing EKU. Once a certificate of this form has been created, signtool.exe can be used to sign [the ELAM driver].</p>&#13;
</blockquote>&#13;
<p class="TX">In test-signing scenarios, you can create a certificate with these EKUs by running <i>makecert.exe</i>, a utility that ships with the Windows SDK, in an elevated command prompt. <a href="#list11-7">Listing 11-7</a> demonstrates the syntax for doing this.</p>&#13;
<pre id="list11-7"><code>PS &gt; <b>&amp; 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.19042.0\x64\makecert.exe'</b>&#13;
&gt;&gt; -a SHA256 -r -pe&#13;
&gt;&gt; -ss PrivateCertStore&#13;
&gt;&gt; -n "CN=DevElamCert"&#13;
&gt;&gt; -sr localmachine&#13;
&gt;&gt; -eku 1.3.6.1.4.1.311.61.4.1,1.3.6.1.5.5.7.3.3&#13;
&gt;&gt; C:\Users\dev\Desktop\DevElamCert.cer</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-7: Generating a self-signed certificate</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label=" Page 209. "/>This tool supports a robust set of arguments, but only two are really relevant to ELAM. This first is the <samp class="SANS_TheSansMonoCd_W5Regular_11">-eku</samp> option, which adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">Early Launch Antimalware Driver</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Code Signing</samp> object identifiers to the certificate. The second is the path to which the certificate should be written.</p>&#13;
<p class="TX">When <i>makecert.exe</i> completes, you’ll find a new self-signed certificate written to the specified location. This certificate should have the necessary object identifiers, which you can validate by opening the certificate and viewing its details, as shown in <a href="#fig11-3">Figure 11-3</a>.</p>&#13;
<figure class="IMG"><img id="fig11-3" class="img50" src="../images/Figure11-3.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: ELAM EKUs included in the certificate</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, you can use <i>signtool.exe</i>, another tool from the Windows SDK, to sign the compiled ELAM driver. <a href="#list11-8">Listing 11-8</a> shows an example of doing this using the previously generated certificate.</p>&#13;
<pre id="list11-8"><code>PS &gt; <b>&amp; 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x64\signtool.exe'</b>&#13;
&gt;&gt; sign&#13;
&gt;&gt; /fd SHA256&#13;
&gt;&gt; /a&#13;
&gt;&gt; /ph&#13;
&gt;&gt; /s "PrivateCertStore"&#13;
&gt;&gt; /n "MyElamCert"&#13;
&gt;&gt; /tr http://sha256timestamp.ws.symantec.com/sha256/timestamp&#13;
&gt;&gt; .\elamdriver.sys</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-8: Signing an ELAM driver with</span> <span class="eSANS_Futura_Std_Book_11a">signtool.exe</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label=" Page 210. "/>Like <i>makecert.exe</i>, this tool supports a large set of arguments, some of which aren’t particularly important to ELAM. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">/fd</samp> argument specifies the file-digest algorithm to use for signing the certificate (SHA256 in our case). The <samp class="SANS_TheSansMonoCd_W5Regular_11">/ph</samp> argument instructs <i>signtool.exe</i> to generate <i>page hashes</i> for executable files. Versions of Windows starting with Vista use these hashes to verify the signature of each page of the driver as it is loaded into memory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/tr</samp> argument accepts the URL of a timestamp server that allows the certificate to be appropriately timestamped (see RFC 3161 for details about the Time-Stamp Protocol). Developers can use a number of publicly available servers to complete this task. Lastly, the tool accepts the file to sign (in our case, the ELAM driver).</p>&#13;
<p class="TX">Now we can inspect the driver’s properties to check whether it is signed with the self-signed certificate and a countersignature from the timestamp server, as shown in <a href="#fig11-4">Figure 11-4</a>.</p>&#13;
<figure class="IMG"><img id="fig11-4" class="img50" src="../images/Figure11-4.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: A signed driver with the timestamp included</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If so, you may deploy the driver to the system. As for most drivers, the system uses a service to facilitate the driver’s loading at the desired time. To function properly, the ELAM driver must load very early in the boot process. This is where the concept of load-order grouping comes into play.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-153"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting the Load Order</samp></h3>&#13;
<p class="TNI">When creating a boot-start service on Windows, the developer can specify when it should be loaded in the boot order. This is useful in cases when the driver depends on the availability of another service or otherwise needs to load at a specific time.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label=" Page 211. "/>The developer can’t specify any arbitrary string for the load-order group, however. Microsoft keeps a list containing most of the groups available in the registry at <i>HKLM:\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder</i>, which you can retrieve easily, as shown in <a href="#list11-9">Listing 11-9</a>.</p>&#13;
<pre id="list11-9"><code>PS&gt; <b>(Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder).List</b>&#13;
&#13;
System Reserved&#13;
EMS&#13;
WdfLoadGroup&#13;
Boot Bus Extender&#13;
System Bus Extender&#13;
SCSI miniport&#13;
Port&#13;
Primary Disk&#13;
SCSI Class&#13;
SCSI CDROM Class&#13;
FSFilter Infrastructure&#13;
FSFilter System&#13;
FSFilter Bottom&#13;
FSFilter Copy Protection&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-9: Retrieving service-load-order groups from the registry with PowerShell</span></p>&#13;
<p class="TX">This command parses the values of the registry key containing the load-order group names and returns them as a list. At the time of this writing, the registry key contains 70 groups.</p>&#13;
<p class="TX">Microsoft instructs ELAM driver developers to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp> load-order group, which is notably missing from the <i>ServiceGroupOrder</i> key. No other special loading requirements exist, and you can do it simply by using <i>sc.exe</i> or the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi32!CreateService()</samp> Win32 API. For example, <a href="#list11-10">Listing 11-10</a> loads <i>WdBoot</i>, an ELAM service that ships with Windows 10 and is used to load Defender’s boot-start driver of the same name.</p>&#13;
<pre id="list11-10"><code>PS C:\&gt; <b>Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\WdBoot |</b>&#13;
<b>&gt;&gt; select PSChildName, Group, ImagePath | fl</b>&#13;
&#13;
PSChildName : WdBoot&#13;
Group       : Early-Launch&#13;
ImagePath   : system32\drivers\wd\WdBoot.sys</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 11-10: Inspecting Defender’s WdBoot ELAM driver</span></p>&#13;
<p class="TX">This command collects the name of the service, its load-order group, and the path to the driver on the filesystem.</p>&#13;
<p class="TX">If you step inside the process of loading the ELAM drivers, you’ll find that it’s primarily the responsibility of the Windows bootloader, <i>winload.efi</i>. The bootloader, a complex piece of software in its own right, performs a few actions. First, it searches the registry for all boot-start drivers on the system in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp> group and adds them to a list. Next, it loads core drivers, such as the System Guard Runtime Monitor (<i>sgrmagent.sys</i>) and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label=" Page 212. "/>the Security Events Component Minifilter (<i>mssecflt.sys</i>). Finally, it goes over its list of ELAM drivers, performing some integrity checking and eventually loading the drivers. Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp> drivers are loaded, the boot process continues, and the ELAM vetting process described in <span class="Xref">“Developing ELAM Drivers” on <a href="#sec2">page 203</a></span> is executed.</p>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT"><i>This is an oversimplified description of the process of loading ELAM drivers. If you’re interested in learning more about it, check out “Understanding WdBoot,” a blog post by @n4r1b detailing how Windows loads essential drivers.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h-154"/><samp class="SANS_Futura_Std_Bold_B_11">Evading ELAM Drivers</samp></h2>&#13;
<p class="TNI">Because ELAM drivers mostly use static signatures and hashes to identify malicious boot-start drivers, you can evade them in the same way you’d evade user-mode file-based detections: by changing static indicators. Doing this for drivers is more difficult than doing it in user mode, however, because there are generally fewer viable drivers than user-mode executables to choose from. This is due in no small part to the Driver Signature Enforcement in modern versions of Windows.</p>&#13;
<p class="TX"><i>Driver Signature Enforcement</i> is a control implemented in Windows Vista and beyond that requires kernel-mode code (namely drivers) to be signed in order to load. Starting in build 1607, Windows 10 further requires that drivers be signed with an Extended Validation (EV) certificate and, optionally, a Windows Hardware Quality Labs (WHQL) signature if the developer would like the driver to load on Windows 10 S or have its updates distributed through Windows Update. Due to the complexity of these signing processes, attackers have a substantially harder time loading a rootkit on modern versions of Windows.</p>&#13;
<p class="TX">An attacker’s driver can serve a number of functions while operating under the requirements of Driver Signature Enforcement. For example, the NetFilter rootkit, signed by Microsoft, passed all Driver Signature Enforcement checks and can load on modern Windows versions. Getting a rootkit signed by Microsoft isn’t the easiest process, however, and it’s impractical for many offensive teams.</p>&#13;
<p class="TX">If the attacker takes the <i>Bring Your Own Vulnerable Driver (BYOVD)</i> approach, their options open up. These are vulnerable drivers that the attacker loads onto the system, and they’re usually signed by legitimate software vendors. As they don’t contain any overtly malicious code, they are difficult to detect and rarely have their certificate revoked after their vulnerability is discovered. If this BYOVD component is loaded during boot, a user-mode component running later in the boot process could exploit the driver to load the operator’s rootkit using any number of techniques, depending on the nature of the vulnerability.</p>&#13;
<p class="TX">Another approach involves the deployment of firmware rootkits or bootkits. While this technique is exceedingly rare, it can effectively evade ELAM’s boot-start protections. For example, the ESPecter bootkit patched <span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label=" Page 213. "/>the Boot Manager (<i>bootmgfw.efi</i>), disabled Driver Signature Enforcement, and dropped its driver, which was responsible for loading user-mode components and performing keylogging. ESPecter was initialized as soon as the system loaded UEFI modules, so early in the boot process that ELAM drivers had no ability to affect its presence.</p>&#13;
<p class="TX">While the specifics of implementing rootkits and bootkits are outside the scope of this book, they’re a fascinating topic for any of those interested in “apex” malware. <i>Rootkits and Bootkits: Reversing Modern Malware and Next Generation Threats</i> by Alex Matrosov, Eugene Rodionov, and Sergey Bratus is the most up-to-date resource on this topic at the time of this writing and is highly recommended as a complement to this section.</p>&#13;
<p class="TX">Thankfully, Microsoft continues to invest heavily in protecting the part of the boot process that occurs before ELAM has a chance to act. These protections fall under the Measured Boot umbrella, which validates the integrity of the boot process from UEFI firmware through ELAM. During the boot process, Measured Boot produces cryptographic hashes, or <i>measurements</i>, of these boot components, along with other configuration data, such as the status of BitLocker and Test Signing, and stores them in the TPM.</p>&#13;
<p class="TX">Once the system has completed booting, Windows uses the TPM to generate a cryptographically signed statement, or <i>quote</i>, used to confirm the validity of the system’s configuration. This quote is sent to an attestation authority, which authenticates the measurements, returns a determination of whether the system should be trusted, and optionally takes actions to remediate any issues. As Windows 11, which requires a TPM, becomes more widely adopted, this technology will become an important detective component for system integrity inside enterprises.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h2 class="H1" id="sec10"><span id="h-155"/><samp class="SANS_Futura_Std_Bold_B_11">The Unfortunate Reality</samp></h2>&#13;
<p class="TNI">In the vast majority of situations, ELAM vendors don’t meet Microsoft’s recommendations. In 2021, Maxim Suhanov published a blog post, “Measured Boot and Malware Signatures: exploring two vulnerabilities found in the Windows loader,” wherein he compared 26 vendors’ ELAM drivers. He noted that only 10 used signatures at all; of these, only two used them to affect Measured Boot in the way intended by Microsoft. Instead, these vendors use their ELAM drivers nearly exclusively to create protected processes and access the Microsoft-Windows-Threat-Intelligence ETW provider discussed in the next chapter.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec11">&#13;
<h2 class="H1" id="sec11"><span id="h-156"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">ELAM drivers give an EDR insight into portions of the boot process previously unable to be monitored. This allows an EDR to detect, or potentially even stop, an attacker that can execute their code before the primary EDR agent even starts. Despite this seemingly massive benefit, almost no vendors make use of this technology and instead use it only for its auxiliary function: gaining access to the Microsoft-Windows-Threat-Intelligence ETW provider.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>