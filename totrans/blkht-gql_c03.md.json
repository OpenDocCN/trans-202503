["```\nmutation {\n  editPaste(id: 1, content: \"My first mutation!\") {\n    paste {\n       id\n       title\n       content\n    }\n  }\n}\n```", "```\nGET **/subscriptions** HTTP/1.1\nHost: 0.0.0.0:5013\nConnection: Upgrade\nPragma: no-cache\nCache-Control: no-cache\nUpgrade: websocket\nOrigin: http://localhost:5013\n**Sec-WebSocket-Version: 13**\nSec-WebSocket-Key: MV5U83GH1UG8AlEb18lHiA==\n```", "```\nHTTP/1.1 **101 Switching Protocols**\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: aRnlpG8XwzRHPVxYmGVdqJv3D7U=\n```", "```\nsubscription {\n  paste {\n     id\n     title\n     content\n  }\n}\n```", "```\nmutation {\n  createPaste(title: \"New paste\", content: \"Test\", public: false) {\n    paste {\n      id\n      title\n      content\n    }\n  }\n}\n```", "```\nquery {\n  pastes {\n    title\n  }\n}\n```", "```\n{\n  pastes {\n    title\n  }\n}\n```", "```\nquery getPasteTitles {\n  pastes {\n    title\n  }\n}\n\nquery getPasteContent {\n  pastes {\n    content\n  }\n}\n```", "```\n{\n  id\n  title\n  content\n}\n```", "```\n{\n  id\n  title\n  content\n  owner {\n    name\n  }\n}\n```", "```\n\"Cannot query field \\\"titl\\\" on type \\\"PasteObject\\\". Did you mean \\\"title\\\"?\"\n```", "```\nquery {\n  users(id: 1) {\n    id\n username\n  }\n}\n```", "```\n{\n  \"data\": {\n    \"users\": [\n      {\n        \"id\": \"1\",\n        \"username\": \"admin\"\n      }\n    ]\n  }\n}\n```", "```\nquery {\n  users(id: 1)  {\n    username(capitalize: true)\n  }\n}\n```", "```\n{\n  \"data\": {\n    \"users\": [\n      {\n        \"username\": \"Admin\"\n      }\n    ]\n  }\n}\n```", "```\nquery {\n  pastes(**limit: 1, public: true**){\n    id\n  }\n}\n```", "```\nquery {\n   pastes {\n      **myalias:**title\n   }\n}\n```", "```\n{\n  \"data\": {\n    \"pastes\": [\n      {\n        **\"myalias\":** \"My Title!\"\n      }\n    ]\n  }\n}\n```", "```\nquery {\n  pastes(public: false) {\n    title\n  }\n  pastes(public: true) {\n    title\n  }\n}\n```", "```\n{\n  \"errors\": [\n    {\n      \"message\": \"Fields \\\"pastes\\\" conflict because they have differing arguments.\n      Use different aliases on the fields to fetch both if this was intentional.\",\n`--snip--`\n}\n```", "```\nQuery {\n  **queryOne:**pastes(public: false) {\n    title\n  }\n  **queryTwo:**pastes(public: true) {\n    title\n  }\n}\n```", "```\n{\n  \"data\": {\n    \"queryOne\": [\n {\n        \"title\": \"My Title!\"\n      }\n    ],\n    \"queryTwo\": [\n      {\n        \"title\": \"Testing Testing\"\n      }\n    ]\n  }\n}\n```", "```\nfragment CommonFields on PasteObject {\n  title\n  content\n}\n```", "```\nquery {\n  pastes {\n    **...CommonFields**\n  }\n}\n\nfragment CommonFields on PasteObject {\n   title\n   content\n}\n```", "```\nquery publicPastes($status: Boolean!){\n  pastes(public: $status){\n    id\n    title\n    content\n  }\n}\n```", "```\nquery pasteDetails($pasteOnly: Boolean!){\n  pastes{\n    id\n    title\n    content\n  ❶ owner @skip(if: $pasteOnly) {\n      name\n    }\n  }\n}\n\n`--snip--`\n\n{\n  \"pasteOnly\": true\n}\n```", "````` ``` type PasteObject { `--snip--`   userAgent: String   ipAddr: String @deprecated(reason: \"We no longer log IP addresses\")   owner: OwnerObject `--snip--` } ```    Listing 3-9: A deprecated schema-directive defined in an SDL    Finally, the more recently added `@specifiedBy` schema-level directive is used to provide a human-readable specification URL for a custom scalar type. We will discuss how `@specifiedBy` is typically used in “Scalars” on page 58.    The `@skip`, `@include`, `@deprecated`, and `@specifiedBy` directives are required; GraphQL server implementations must support them to be considered spec compliant.    Custom directives empower GraphQL implementations to develop new features or augment functionality not currently supported, or widely used, by the ecosystem. One example of a widely adopted custom directive is `@computed`. This powerful schema-level directive saves implementers from having to create resolver functions for fields that can be computed from the values of other fields in the schema. [Listing 3-10](#listing3-10) shows how the `@computed` directive can merge the `firstName` and `lastName` fields into the `fullName` field.    ``` type User {   firstName: String   lastName: String   fullName: String **@computed(value: \"$firstName $lastName\")** } ```    Listing 3-10: A computed directive used for the merger of two fields    The power of directives is also their greatest weakness: they are essentially unregulated. Other than describing their general syntax, the GraphQL spec doesn’t mention much about directives, allowing every server implementation the freedom to design their own architecture. Not every GraphQL server implementation will support the same directives. However, implementations that use directives to alter the underlying behavior of the GraphQL language could introduce risks if implemented incorrectly.    The use of custom directives to expand GraphQL opens implementations to customized attack vectors that we hackers can exploit. A vulnerability in a custom directive used by a popular GraphQL implementation could impact hundreds of organizations. In Chapter 5, we will explore how to use directives to attack GraphQL servers.    ## Data Types    GraphQL’s *types* define the custom objects and data structures that make up a GraphQL schema. There are six kinds of types: object, scalar, enum, union, interface, and input. In this section, we will define each type and explain what it is used for.    We reference the types defined in DVGA’s schema as examples. If you’d like more context, you can use Altair to download the full SDL file for DVGA. To download it, click the **Docs** link next to the Send Request button and select the ellipsis (...) button to expose the Export SDL option, shown in [Figure 3-3](#figure3-3).  ![](image_fi/502840c03/f03003.png)    Figure 3-3: Altair’s Export SDL feature      ### Objects    Custom *object types* are groups of one or more fields that define domain- or application-specific objects. Consider the snippet of DVGA’s schema in [Listing 3-11](#listing3-11).    ``` type PasteObject {   id: ID!   title: String   content: String   public: Boolean   userAgent: String   ipAddr: String   ownerId: Int   burn: Boolean ❶ owner: OwnerObject } ```    Listing 3-11: The DVGA `PasteObject` type    We define a new custom object type, called `PasteObject`. This object has fields described between curly brackets. You may recognize a few of these fields, as we used them in a GraphQL query earlier in this chapter. Each of these fields uses GraphQL’s out-of-the-box scalar types except for the `owner` field, which is also a custom object type.    If you look at the `id` field, you’ll notice that it contains the exclamation mark (`!`) character. This means that every `Paste` ``object requires an `ID`, whereas every other field can be null. These required fields are known as *non-null wrapping types*. Also notice the one-way-link relationship between our `Paste` and `Owner` object nodes ❶. We discussed such relationships in Chapter 1. In practice, this means that we can request an `Owner` object and its associated fields through a `Paste` object.``   ````### Scalars    *Scalars* include several core built-in value types, such as `ID`, `Int`, `Float`, `String`, and `Boolean`. Unlike object types, they don’t have their own fields.    Implementations can also define their own custom scalars. Consider [Listing 3-12](#listing3-12), which shows how DVGA could introduce a new field within the `Paste` object called `createdAt`.    ``` **scalar DateTime**  type PasteObject {   id: ID!   title: String   content: String   public: Boolean   userAgent: String   ipAddr: String   ownerId: Int   burn: Boolean   owner: OwnerObject   **createdAt: DateTime!** } ```    Listing 3-12: A scalar SDL definition    Just like the `ID` field, this `createdAt` field could be automatically assigned upon paste creation with a custom scalar type known as `DateTime`. This custom scalar can help us ensure proper serialization, formatting, and validation.    Custom scalars may also use the `@specifiedBy` built-in directive to describe their specification URL for clients. For example, a custom scalar type `UUID` may set its specification URL to the relevant Internet Engineering Task Force (IETF) specification:    ``` scalar UUID @specifiedBy(url:\"https://tools.ietf.org/html/rfc4122\") ```    ### Enums    *Enums*, or *enumeration* types, are fields used to return a single string value from a list of possible values. For example, an application may want to allow a client to choose how to sort a list of usernames in the response. To do so, they might create an enum named `UserSortEnum` to represent types of sorting (such as by username, email, password, or the date a user joined):    ``` enum UserSortEnum {   ID   EMAIL  USERNAME   DATE_JOINED } ```    This `UserSortEnum` enum can then be used as the type for an argument such as `order`, exposed via an input type named `UserOrderedType`. (We discuss input types later in this chapter.) [Listing 3-13](#listing3-13) shows how such a schema might look.    ``` enum UserSortEnum {   ID   EMAIL   USERNAME   DATE_JOINED }  input UserOrderType {   sort: UserSortEnum! }  type UserObject {   id: Int!   username: String! }  type Query {   users(limit: Int, order: UserOrderType): UserObject! } ```    Listing 3-13: A user sorting based on an input type that uses an enum    In this example, we define the `UserSortEnum` with a few enum fields, such as `ID`, `EMAIL`, `USERNAME`, and `DATE_JOINED`. We then define an input type named `UserOrderType`, which contains a field named `sort` of type `UserSortEnum`. We expose a query named `users`, which takes two arguments, `limit` and `order`, where `order` is of type `UserOrderType`. This allows clients to return a list of users sorted based on any of the defined enums. Such a query may look like the following:    ``` query {   users(limit: 100, order: {**sort: ID**}) } ```    Allowing the client to sort using the options listed in `UserSortEnum` can be risky. For example, if the client can sort users by their `ID`, an attacker might have access to the identity of the first user created in the system. This user is likely a super-admin or built-in application account, and so could help focus the attack on high-value accounts with potentially broader permissions than other accounts.    ### Unions    A *union* is a type that returns one of many object types. A client can leverage unions to send a single request to a GraphQL server and get a list of objects. Consider [Listing 3-14](#listing3-14), which shows a query using a search feature in DVGA. This feature allows a client to search for a keyword that returns multiple `Users` and `Paste` objects:    ``` query {   search(keyword: \"p\") {     **... on UserObject {**  **username**  **}**  **... on PasteObject {**  **title**  **content**  **}**   } } ```    Listing 3-14: The DVGA search feature    This search feature empowers clients to find both pastes and users that match the keyword with just a single request. Pretty neat! The response to the query can be seen in the following code. It returns a list of matching paste and user fields that have the letter *p* in either their username or title:    ``` {   \"data\": {     \"search\": [       {         \"title\": \"This is my first **p**aste\",         \"content\": \"What does your room look like?\"       },       {         \"id\": \"2\",         \"username\": \"o**p**erator\"       }     ]   } } ```    To accept and resolve a request like this, a schema can use a union type. In [Listing 3-15](#listing3-15), we define a `union` named `SearchResults`.    ``` **union SearchResults = UserObject | PasteObject**  type UserObject {   id: ID!   username: String! }  type PasteObject {   id: ID!  title: String   content: String `--snip--` }  type Query {   **search(keyword: String): [SearchResults!]** } ```    Listing 3-15: A union definition    As you can see, the `SearchResults` union type merges the user and paste objects into a single type. That type can then be used in a single search query operation that accepts a `keyword` string argument.    ### Interfaces    Another way to return multiple types within the same field is through interfaces. *Interfaces* define a list of fields that must be included across all object types that implement them. In the union request example covered in the previous section, you saw how we could retrieve the `username` field of any `User` object, as well as the `title` and `content` fields of any `Paste` object, as long as these matched the search pattern. Interfaces do not work like this; they require the same fields to be present in both objects in order for the objects to be joined in a response to the client.    To implement our search functionality using interfaces instead of unions, we could use the schema shown in [Listing 3-16](#listing3-16).    ``` **interface SearchItem {**   **keywords: [String!]** **}**  type UserObject **implements SearchItem** {   id: ID!   username: String!   **keywords: [String!]** }  type PasteObject **implements SearchItem** {   id: ID!   title: String   content: String   **keywords: [String!]** `--snip--` }  type Query {   search(keyword: String): [SearchItem!]! } ```    Listing 3-16: An interface SDL definition    We create an interface type called `SearchItem` with a `keywords` string list field. Any object type that wants to implement this interface will need to include the `keywords` field. We then define this field within both the `UserObject` and `PasteObject` objects. Now a client could send a search query much like the one outlined in [Listing 3-15](#listing3-15) to retrieve all user and paste objects that use a particular keyword.    Interfaces could pose a problem in applications that poorly implement authorization. One way to implement authorization in GraphQL is by using custom schema-level directives. Because an interface defines fields to be used by other objects, any sensitive field that isn’t properly decorated could be exposed unintentionally. Large SDL files can have thousands of lines, and there is always a chance a developer might forget to add the relevant authorization directives. You’ll learn more about authorization in Chapter 8.    ### Inputs    Arguments are able to accept values of different types, such as scalars, but when we need to pass large and complex inputs to the server, we can leverage an input type to simplify our requests. *Input types* are essentially the same as object types, but they can be used only as inputs for arguments. They help organize client requests and make it easier for clients to reuse inputs in multiple arguments. Mature GraphQL deployments use input types to better structure their APIs and make their schema documentation easier to read.    Let’s see input types in action. In [Listing 3-17](#listing3-17), we declare an `$input` variable and assign the type as `UserInput!`. Then we pass this input variable into the `userData` argument for our `createUser` mutation.    ``` mutation newUser(**$input: UserInput!**) {   createUser(**userData: $input**) {     user {       username     }   } } ```    Listing 3-17: An input type in a mutation    As you learned in “Variables” on page 53, to submit inputs to the application, we’ll need to create a JSON object that represents our `UserInput!` and assign it to the input key, as shown in [Listing 3-18](#listing3-18).    ``` {   \"input\": {     \"username\": \"tom\",     \"password\": \"secret\",     \"email\": \"tom@example.com\"   } } ```    Listing 3-18: An input definition    In tools such as Altair or GraphiQL Explorer, [Listing 3-18](#listing3-18)’s JSON will be defined in the Variables pane of the client.    Input types provide clients with a possible way to defeat type validations, which may or may not have broken validation logic. For example, earlier in this chapter we discussed how custom scalar types could fail to validate values sent by clients, such as IP addresses or email addresses. Validation issues related to email addresses could allow attackers to bypass registration forms and login processes or perform injections.    ## Introspection    After reviewing GraphQL’s language and type system, you should have noticed stark differences in what GraphQL APIs and REST APIs can offer clients. GraphQL puts a lot of power in the hands of the client by default. But wait, there’s more!    Arguably one of GraphQL’s most powerful features is *introspection*, the built-in tool that empowers clients to discover actions they can take using a GraphQL API. Introspection lets clients query a GraphQL server for information about its underlying schema, which includes data like queries, mutations, subscriptions, directives, types, fields, and more. As hackers, this feature can be a gold mine in supporting our reconnaissance, profiling, data collection, and attack-vector analysis efforts. Let’s dive into how we can use it.    The GraphQL introspection system has seven introspection types that we can use to query the schema. [Table 3-3](#table3-3) lists these introspection types.      Table 3-3: The Introspection System Types       | **Introspection type** | **Usage** | | --- | --- | | `__Schema` | Provides all information about the schema of a GraphQL service | | `__Type` | Provides all information about a type | | `__TypeKind` | Provides the different kinds of types (scalars, objects, interface, union, enum, and so on) | | `__Field` | Provides all information for each field of an object or interface type | | `__InputValue` | Provides field and directive argument information | | `__EnumValue` | Provides one of the possible values of an enum | | `__Directive` | Provides all information on both custom and built-in directives |    Consider [Listing 3-19](#listing3-19), which uses the `__Schema` introspection type against DVGA.    ``` query {   **__schema** {     types {  name     }   } } ```    Listing 3-19: An introspection query for schema types    The `__schema` introspection top-level field will query all the information available to us through the GraphQL schema we are interacting with. We further refine our investigation by telling the query to look for all `types` and to select their `name` fields.    Here is how GraphQL displays the introspection response to this request:    ``` {   \"data\": {     \"__schema\": {       \"types\": [     `--snip--`         {           \"name\": **\"PasteObject\"**         },         {           \"name\": **\"ID\"**         }     `--snip--`         {           \"name\": **\"String\"**         },         {           \"name\": **\"OwnerObject\"**         },         {           \"name\": **\"UserObject\"**         }     `--snip--`      ]    } } ```    Here, we can see many returned type names. A few should be familiar to you, such as `ID`, `String`, and `PasteObject`. We know that `ID` and `String` are GraphQL’s built-in scalar types, but names like `PasteObject`, `OwnerObject`, and `UserObject` should immediately catch our attention as we probe the schema for goodies, because these are custom object types introduced by the developers and not built-in GraphQL types. Let’s dive deeper into these.    We can use `__type` to further investigate information about types we find interesting. [Listing 3-20](#listing3-20) provides us with a powerful query to discover all fields and their types within a custom object type of our choosing.    ``` query {   **__type(name: \"PasteObject\")** {     name  **kind**  **fields** {       name       type {         name         kind       }     }   } } ```    Listing 3-20: An introspection query for discovering fields within an object of interest    In this case, we decided to dive deeper into the `PasteObject` type. You will notice that we are selecting not just the name of the type but also its `kind`, which returns the `__TypeKind` introspection type for the object. We’re also selecting all of the `PasteObject` fields and their names, types, and kinds. Let’s take a look at the response:    ``` \"__type\": {       \"name\": \"PasteObject\",       \"kind\": \"OBJECT\",       \"fields\": [         {           \"name\": \"id\",           \"type\": {             \"name\": null,             \"kind\": \"NON_NULL\"           }         },         {           \"name\": \"title\",           \"type\": {             \"name\": \"String\",             \"kind\": \"SCALAR\"           }         },  `--snip--`         {           \"name\": \"content\",           \"type\": {             \"name\": \"String\",             \"kind\": \"SCALAR\"           }         },         {           \"name\": \"owner\",           \"type\": {             \"name\": \"OwnerObject\",             \"kind\": \"OBJECT\"           }         }       ]  } ```    The structure of the introspection query we made matches that of the response we received. We now have the entire list of fields we can request, as well as their types.    Sensitive fields, intended for staff or internal use only, may easily become revealed to the public if they are included in the GraphQL schema and introspection is enabled. But introspection isn’t only about field discovery; it is the equivalent of being handed a REST API Swagger (OpenAPI) definition file. It allows us to discover the queries, mutations, and subscriptions that are supported, the arguments they accept, and how to construct and execute them. Having this intelligence at our fingertips may allow us to discover and craft malicious operations.    We will dive into more introspection fun in Chapter 6, which focuses on information disclosure tools and techniques.    ## Validation and Execution    All GraphQL query requests are tested for their validity against the schema and type system before they are executed and resolved by the server. For instance, when a client sends a query for certain fields, the GraphQL implementation’s validations will check the schema to verify that all the requested fields exist on the given type. If a field doesn’t exist within the schema or isn’t associated with a given type, the query will be flagged as invalid and won’t execute.    The GraphQL spec outlines several validation types. These include document, operation, field, argument, fragment, value, directive, and variable validations. The example we just mentioned is a field validation; other validations, such as directive validations, can check if a directive sent by the client is recognized in the schema and supported by the implementation.    There are significant differences in the way GraphQL implementations interpret and conform to the GraphQL spec, and especially in the way they handle responses to invalid requests. This variation is what fingerprinting tools like Graphw00f (covered in Chapter 4) aim to detect. Because the thoroughness of a server’s validation stage reveals information about its security maturity, it’s important to analyze these implementation weaknesses. This is where the GraphQL Threat Matrix comes in handy.    The GraphQL Threat Matrix ([https://github.com/nicholasaleks/graphql-threat-matrix](https://github.com/nicholasaleks/graphql-threat-matrix)) is a security framework for GraphQL developed by the authors of this book. It is used by bug bounty hunters, security researchers, and hackers to assist with uncovering vulnerabilities across multiple GraphQL implementations. [Figure 3-4](#figure3-4) shows its interface.    The matrix analyzes, tracks, and compares the most common implementations, looking at their supported validations, default security configurations, features, and notable vulnerabilities. The matrix is useful for both hackers and defenders. Knowing how to attack an implementation is crucial, but making data-driven decisions about which implementation to choose in the first place is just as important.  ![](image_fi/502840c03/f03004.png)    Figure 3-4: The GraphQL Threat Matrix      Once successfully validated, a GraphQL request is executed by the server. Resolver functions, which we covered in Chapter 1, are responsible for returning a response for a requested field.    ## Common Weaknesses    In this section, we will provide a high-level overview of the common weaknesses found in GraphQL. In later chapters, we will perform penetration testing against each vulnerability class, as well as review related exploit code.    ### Specification Rule and Implementation Weaknesses    GraphQL’s specification defines rules, design principles, and standard practices. If you ever want to develop your own GraphQL implementation, this is the document your implementation should conform to, including the way it formats its responses, validates arguments, and so on.    Here are two examples of rules taken from the GraphQL specification:    > Arguments may be provided in any syntactic order and maintain identical semantic meaning. >  > The *data* entry in the response will be the result of the execution of the requested operation.    These two rules are pretty simple. The first one explains that the order of arguments provided in a query shouldn’t change the server’s response, and the second rule explains that a GraphQL server response must be returned as part of the *data* JSON field.    Yet complying with these rules is the developer’s responsibility, which is where discrepancies may happen. In fact, the GraphQL spec doesn’t care about how implementations conform to the spec:    > Conformance requirements expressed as algorithms can be fulfilled by an implementation of this specification in any way as long as the perceived result is equivalent.    To highlight an example of the behavioral differences between certain implementations, take a look at graphql-php ([https://github.com/webonyx/graphql-php](https://github.com/webonyx/graphql-php)). This open source implementation is written in PHP and based on GraphQL’s reference implementation library GraphQL.js ([https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)).    However, when you look at how graphql-php handles aliases, you will notice that it differs from many other implementations; it allows clients to submit aliases with special characters, such as `$`. These subtle differences between implementations not only help hackers fingerprint the underlying technology behind a GraphQL API service (as you will learn in Chapter 4) but also may allow us to craft special payloads to impact services using certain implementations. Finally, these varying execution behaviors mean that a vulnerability detected in one implementation may not necessarily impact others.    As a hacker, you will often find yourself referencing an application’s design document to better understand how it is meant to function compared with how it functions in practice. Often, you’ll find discrepancies. For example, imagine that an application design document defines the following rule:    > The application must be able to receive a URL from a client, fetch it over the network, and return a response to the client.    This rule isn’t very specific; it doesn’t explain how to secure this function and what the developer should be cautious of when implementing it. However, many things can go wrong in a feature that fetches content from a user-controlled URL. An attacker might be able to do any of the following:    *   Specify a private IP address (for example, 10.1.1.1) in the URL, which effectively allows access to internal resources on the server where the application lives. *   Specify a remote URL that includes malicious code. The server will download the code and host malware on the server. *   Specify a URL pointing to a very large file, exhausting server resources and impacting other users’ ability to use the application.    This is just a partial list of harmful possibilities. If the developer doesn’t take these scenarios into consideration during implementation, anyone who uses their application will be exposed to these vulnerabilities.    Building bug-free software is hard (and likely impossible to avoid completely). The more you know about an application and the deeper you dig into it, the higher your chances of finding a vulnerability.    ### Denial of Service    One of the most prevalent vulnerability classes in GraphQL is DoS-based vulnerabilities. These vulnerabilities can degrade a targeted system’s performance or exhaust its resources completely, making it unable to fulfill client queries or even crash. In this chapter, we hinted at how field and object relationships, aliases, directives, and fragments could all potentially be used as attack vectors against a GraphQL service, because these capabilities provide API clients with an enormous amount of control over the query structure and execution behavior.    In Chapter 5, you’ll learn how this power can also enable clients to construct very complex queries that effectively degrade a GraphQL server’s performance if the right security countermeasures are not put in place. We will review four ways that a client can create expensive queries. These may overwhelm the GraphQL server and lead to DoS conditions.    ### Information Disclosure    A common weakness in many web applications is the unintended disclosure of data to the public, or to a group of users that isn’t authorized to access it. Information leakages have many causes, and systems entrusted with protecting sensitive information such as PII should deploy numerous layers of detection and prevention controls to protect information from being exposed.    When it comes to GraphQL, hackers can fingerprint and collect data from its API in several ways. In Chapter 6, we’ll teach you how to leverage introspection queries to hunt for fields that may contain sensitive information. We’ll equip you with tools that take advantage of how field suggestions and error messages work to help uncover hidden data models and maneuver around GraphQL environments where introspection may be disabled.    ### Authentication and Authorization Flaws    Authentication and authorization are complex security controls in any API system architecture. The fact that the GraphQL spec refrains from providing authentication and authorization guidance for implementations doesn’t help. This void often leads engineers to implement their own authentication and authorization mechanisms based on open source, in-house, or third-party solutions.    Most of the authentication and authorization vulnerabilities you’ll find in GraphQL stem from the same issues you’d find in traditional APIs, such as failure to adequately protect against brute-force attacks, logic flaws, or poor coding that allows controls to be entirely bypassed. In Chapter 7, we’ll review several common GraphQL authentication and authorization strategies and teach you how to defeat them with aliases, batch queries, and good, old-fashioned logic flaws.    ### Injections    Injection vulnerabilities can have devastating impacts on application data, and while frameworks have gotten better at protecting against them by offering reusable security methods, they are still prevalent today. Much like its counterparts REST and SOAP, GraphQL isn’t immune to the Open Web Application Security Project (OWASP) Top 10, a list of the most common web vulnerabilities, and can become vulnerable to injection-based attacks if untrusted information from a client is accepted and processed by the application.    GraphQL’s language supports multiple avenues for a malicious client to send injection data to a server, such as query arguments, field arguments, directive arguments, and mutations. Implementations of GraphQL also vary in their conformance with the GraphQL spec, leading to differences in the way they may handle, sanitize, and validate the data coming to them from clients. In Chapter 8, you will learn about specific GraphQL injection vulnerabilities and their various entry points into backend systems.    ## Summary    By now, you should understand what GraphQL is and what some of its attack vectors may look like. You should also be quite comfortable with GraphQL’s language, having reviewed the anatomy of a query and dissected its internal components, such as operations, fields, and arguments. You also began to leverage the GraphQL lab you built in Chapter 2 by using Altair to send numerous queries to DVGA. From a server’s perspective, you were introduced to the major components that make up GraphQL’s type system and the role these types play in supporting the structure of GraphQL schemas and introspection queries.    Finally, we created a base camp from which we can launch our future GraphQL hacking attacks. We hinted at the weaknesses and loopholes in the GraphQL spec and in how implementations interpret and extend unregulated functionality beyond the spec. Keep following this trail of breadcrumbs as you continue your GraphQL hacker journey.```` `````"]