- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: PROCESS ISOLATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进程隔离
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Containers build on a rich history of technologies designed to isolate one computer
    program from another while allowing many programs to share the same CPU, memory,
    storage, and network resources. Containers use fundamental capabilities of the
    Linux kernel, particularly namespaces, which create separate views of process
    identifiers, users, the filesystem, and network interfaces. Container runtimes
    use multiple types of namespaces to give each container an isolated view of the
    system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 容器建立在一系列技术的基础上，这些技术旨在隔离一个计算机程序与另一个程序，同时允许多个程序共享相同的 CPU、内存、存储和网络资源。容器利用 Linux
    内核的基本能力，特别是命名空间（namespace），它们创建了进程标识符、用户、文件系统和网络接口的独立视图。容器运行时使用多种类型的命名空间，为每个容器提供系统的隔离视图。
- en: In this chapter, we’ll consider some of the reasons for process isolation and
    look at how Linux has historically isolated processes. We’ll then examine how
    containers use namespaces to provide isolation. We’ll test this using a couple
    of different container runtimes. Finally, we will use Linux commands to create
    namespaces directly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑进程隔离的一些原因，并回顾 Linux 是如何历史性地实现进程隔离的。然后，我们将研究容器如何使用命名空间来提供隔离。我们将通过几种不同的容器运行时进行测试。最后，我们将使用
    Linux 命令直接创建命名空间。
- en: Understanding Isolation
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解隔离
- en: Before running some containers and inspecting their isolation, let’s look at
    the motivation for process isolation. We’ll also consider traditional process
    isolation in Linux and how that has led to the isolation capabilities that containers
    use.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行一些容器并检查其隔离性之前，让我们先看看进程隔离的动机。我们还将考虑 Linux 中传统的进程隔离方式，以及这如何促成了容器所使用的隔离能力。
- en: Why Processes Need Isolation
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么进程需要隔离
- en: The whole idea of a computer is that it is a general-purpose machine that can
    run many different kinds of programs. Ever since the beginning of computing, there
    has been a need to share a single computer between multiple programs. It started
    with people taking turns submitting programs on punch cards, but as computer multitasking
    became more sophisticated, people could start multiple programs, and the computer
    would make it seem as if they were all running on the same CPU at once.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的整体概念是它是一台通用机器，可以运行多种不同类型的程序。自计算机诞生以来，就有需要在多个程序之间共享同一台计算机的需求。最初，人们通过打孔卡片轮流提交程序，但随着计算机多任务处理的日益复杂，人们可以启动多个程序，而计算机会让它们看起来好像都在同一个
    CPU 上同时运行。
- en: 'Of course, as soon as something needs to be shared, there is a need to make
    sure it is shared fairly, and computer programs are no different. So although
    we think of a *process* as an independent program with its own time on the CPU
    and its own memory space, there are many ways that one process can cause trouble
    for another, including:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦某个资源需要共享，就需要确保共享是公平的，计算机程序也不例外。所以，尽管我们认为一个*进程*是一个独立的程序，拥有自己的 CPU 时间和内存空间，但有许多方式可能导致一个进程对另一个进程造成困扰，包括：
- en: Using too much CPU, memory, storage, or network
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过多的 CPU、内存、存储或网络资源
- en: Overwriting the memory or files of another process
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖另一个进程的内存或文件
- en: Extracting secret information from another process
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个进程中提取机密信息
- en: Sending another process bad data to cause it to misbehave
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向另一个进程发送错误数据，导致其行为异常
- en: Flooding another process with requests so that it stops responding
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向另一个进程发送大量请求，使其停止响应
- en: Bugs can cause processes to do these same things by accident, but a bigger concern
    is a security vulnerability that allows a bad actor to use one process to cause
    problems for another. It takes only one vulnerability to create major problems
    in a system, so we need ways to isolate processes that limit damage from both
    accidental and intentional behavior.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可能会导致进程意外地做出这些行为，但更大的问题是安全漏洞，允许恶意行为者利用一个进程对另一个进程造成问题。一个漏洞就足以在系统中造成重大问题，因此我们需要能够隔离进程的方式，以限制意外和故意行为带来的损害。
- en: Physical isolation is best—*air-gapped* systems are regularly used to protect
    government-classified information and safety-critical systems—but this approach
    is also too expensive and inconvenient for many uses. Virtual machines can give
    the appearance of separation while sharing physical hardware, but a virtual machine
    has the overhead of running its own operating system, services, and virtual devices,
    making it slower to start and less scalable. The solution is to run regular processes,
    but use process isolation to reduce the risk of affecting other processes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 物理隔离是最好的——*气隔*系统常常被用于保护政府机密信息和安全关键系统——但这种方法对于许多应用来说也过于昂贵且不便。虚拟机可以在共享物理硬件的同时，提供隔离的外观，但虚拟机需要运行自己的操作系统、服务和虚拟设备，导致启动更慢，扩展性差。解决方案是运行常规进程，但利用进程隔离来降低影响其他进程的风险。
- en: File Permissions and Change Root
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件权限与变更根目录
- en: Most of the effort in process isolation involves preventing one process from
    seeing things it shouldn’t. After all, if a process can’t even see another process,
    it will be far more difficult to cause trouble, either accidentally or on purpose.
    The traditional ways that Linux has controlled what processes can see and do serve
    as the foundation for the ideas behind containers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数进程隔离的工作集中在防止一个进程看到它不应该看到的内容。毕竟，如果一个进程甚至无法看到另一个进程，它就更难制造麻烦，无论是意外还是故意。Linux传统上控制进程能够看到和做什么的方式为容器的思想提供了基础。
- en: One of the most basic visibility controls is *filesystem permissions*. Linux
    associates an owner and group with each file and directory, and manages read,
    write, and execute permissions. This basic permission scheme works well to ensure
    that user files are kept private, that a process cannot overwrite the files of
    another process, and that only a privileged user like root can install new software
    or modify critical system configuration files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的可见性控制之一是*文件系统权限*。Linux为每个文件和目录关联一个所有者和一个组，并管理读、写和执行权限。这种基本的权限方案能够很好地确保用户文件的私密性，防止进程覆盖另一个进程的文件，并确保只有像root这样的特权用户才能安装新软件或修改关键的系统配置文件。
- en: Of course, this permission scheme relies on us ensuring that each process is
    run as the authentic user and that users are in the appropriate groups. Typically,
    each new service install creates a user just for running that service. Even better,
    this *service user* can be configured without a real login shell, which means
    that the user cannot be exploited to log in to the system. To make this clear,
    let’s look at an example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种权限方案依赖于我们确保每个进程以真实用户身份运行，并且用户位于适当的组中。通常，每个新服务安装都会为该服务创建一个专用用户。更好的是，这个*服务用户*可以配置为没有真实的登录shell，这意味着该用户无法被利用登录系统。为了更清楚地说明这一点，我们来看一个示例。
- en: '**NOTE**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The example repository for this book is at* [https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples).
    *See “Running Examples” on [page xx](ch00.xhtml#ch00lev1sec2) for details on getting
    set up.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书的示例仓库在* [https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples)。*有关设置的详细信息，请参见[第xx页](ch00.xhtml#ch00lev1sec2)中的“运行示例”。*'
- en: 'The Linux `rsyslogd` service provides logging services, so it needs to write
    to files in */var/log*, but it should not have permissions to read or write all
    of the files in that directory. File permissions are used to control this, as
    shown in this example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的`rsyslogd`服务提供日志服务，因此需要写入*/var/log*中的文件，但不应该有权限读取或写入该目录中的所有文件。文件权限用于控制这一点，示例如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *syslog* user ➊ exists specifically to run `rsyslogd`, and that user is
    configured with no login shell for security reasons ➋. Because `rsyslogd` needs
    to be able to write to *auth.log*, it’s given write permission, as shown in the
    file mode printout ➌. Members of the admin (*adm*) group have read-only access
    to this file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*syslog*用户 ➊ 专门用于运行`rsyslogd`，并且出于安全原因，该用户被配置为没有登录shell ➋。由于`rsyslogd`需要能够写入*auth.log*，因此赋予了写权限，如文件模式输出中所示
    ➌。管理员组（*adm*）的成员对该文件具有只读权限。'
- en: An initial `d` in the file mode ➍ indicates that this is a directory. The following
    `rwx` indicates that the root user has read, write, and execute permissions. The
    remaining dashes indicate that there are no rights for members of the *root* group
    or for other system users, so we can conclude that the `rsyslogd` process cannot
    see the contents of this directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件模式中的初始 `d` ➍ 表示这是一个目录。接下来的 `rwx` 表示 root 用户具有读、写和执行权限。其余的破折号表示 root 组的成员或其他系统用户没有权限，因此我们可以推断出
    `rsyslogd` 进程无法查看此目录的内容。
- en: 'Permission control is important, but it doesn’t fully satisfy our goal of process
    isolation. One reason is that it is not enough to protect us from *privilege escalation*,
    wherein a vulnerable process and a vulnerable system allow a bad actor to obtain
    root privileges. To help deal with this, some Linux services go a step beyond
    by running in an isolated part of the filesystem. This approach is known as `chroot`
    for “change root.” Running in a `chroot` environment requires quite a bit of setup,
    as you can see in this example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 权限控制很重要，但它并不能完全满足我们对进程隔离的需求。一个原因是，它不足以防止*特权升级*，即一个脆弱的进程和系统可能让恶意行为者获得 root 权限。为了解决这个问题，一些
    Linux 服务通过在文件系统的隔离部分中运行来进一步加强安全。这种方法被称为 `chroot`，即“更改根目录”。在 `chroot` 环境中运行需要一些配置，正如我们在这个示例中看到的那样：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we need to copy in all of the executables that we intend to run ➊. We
    also need to copy in all of the shared libraries these executables use, which
    we specify with the `ldd | grep | awk` command ➋. When both binaries and libraries
    are copied in, we can use the `chroot` command ➌ to move into our isolated environment.
    Only the files we copied in are visible ➍.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将所有打算运行的可执行文件复制到容器中 ➊。我们还需要将这些可执行文件使用的所有共享库复制进来，我们通过 `ldd | grep | awk`
    命令来指定这些库 ➋。当二进制文件和库都被复制进容器后，我们可以使用 `chroot` 命令 ➌ 进入隔离环境。只有我们复制进来的文件是可见的 ➍。
- en: Container Isolation
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器隔离
- en: For experienced Linux system administrators, file permissions and change root
    are basic-level knowledge. However, those concepts also serve as the foundation
    for how containers work. Even though a running container appears like a completely
    separate system, with its own hostname, network, processes, and filesystem (as
    we saw in [Chapter 1](ch01.xhtml#ch01)), it’s really a regular Linux process using
    isolation rather than a virtual machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有经验的 Linux 系统管理员来说，文件权限和更改根目录是基础知识。然而，这些概念也为容器的工作原理提供了基础。尽管正在运行的容器看起来像是一个完全独立的系统，拥有自己的主机名、网络、进程和文件系统（正如我们在[第一章](ch01.xhtml#ch01)中看到的那样），它实际上只是一个普通的
    Linux 进程，利用隔离机制而不是虚拟机。
- en: 'A container has multiple kinds of isolation, including several essential kinds
    of isolation that we haven’t seen before:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容器具有多种隔离方式，包括一些我们之前未曾见过的关键隔离类型：
- en: Mounted filesystems
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载的文件系统
- en: Hostname and domain name
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机名和域名
- en: Interprocess communication
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信
- en: Process identifiers
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程标识符
- en: Network devices
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备
- en: These separate kinds of isolation work together so that a process or collection
    of processes looks like a completely separate system. Although these processes
    still share the kernel and physical hardware, this isolation goes a long way toward
    ensuring that they cannot cause trouble for other processes, especially when we
    configure containers correctly to control the CPU, memory, storage, and network
    resources available to them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同类型的隔离机制共同作用，使得一个进程或一组进程看起来像是一个完全独立的系统。尽管这些进程仍然共享内核和物理硬件，但这种隔离机制大大确保了它们不会对其他进程造成困扰，特别是当我们正确配置容器，以控制它们可用的
    CPU、内存、存储和网络资源时。
- en: Container Platforms and Container Runtimes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器平台和容器运行时
- en: Specifying all the binaries, libraries, and configuration files needed to run
    a process in an isolated filesystem would be laborious. Fortunately, as we saw
    in [Chapter 1](ch01.xhtml#ch01), *container images* come prepackaged with the
    needed executables and libraries. Using Docker, we were able to easily download
    and run NGINX in a container. Docker is an example of a *container platform*,
    providing not only the ability to run containers but also container storage, networking,
    and security.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 指定在隔离文件系统中运行进程所需的所有二进制文件、库和配置文件会很繁琐。幸运的是，正如我们在[第一章](ch01.xhtml#ch01)中看到的那样，*容器镜像*已经预先打包了所需的可执行文件和库。通过使用
    Docker，我们能够轻松下载并在容器中运行 NGINX。Docker 是一个*容器平台*的例子，提供了不仅是运行容器的能力，还有容器存储、网络和安全性。
- en: Under the covers, modern versions of Docker are using `containerd` as the *container
    runtime*, also known as a *container engine*. A container runtime provides low-level
    functionality to run processes in containers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在背后，现代版本的Docker使用`containerd`作为*容器运行时*，也被称为*容器引擎*。容器运行时提供了在容器中运行进程的底层功能。
- en: To explore isolation further, let’s experiment with two different container
    runtimes to start containers from preexisting images and then inspect how processes
    in containers are isolated from the rest of the system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探索隔离性，让我们实验使用两种不同的容器运行时，从现有镜像启动容器，然后检查容器中进程如何与系统的其他部分隔离。
- en: Installing containerd
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装containerd
- en: We’ll be using `containerd` in [Part II](part02.xhtml#part02) in support of
    our Kubernetes clusters, so let’s begin by installing and interacting with this
    runtime directly. Interacting directly with `containerd` will also benefit our
    exploration of process isolation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第二部分](part02.xhtml#part02)中使用`containerd`来支持我们的Kubernetes集群，因此让我们首先安装并直接与这个运行时交互。直接与`containerd`交互也将有助于我们探索进程隔离。
- en: You can skip install commands by using the *extra* provisioning script provided
    with this chapter’s examples. See the README file for this chapter for instructions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用本章示例提供的*额外*配置脚本跳过安装命令。请参阅本章的README文件以获取说明。
- en: 'Even though `containerd` is available in the standard Ubuntu package repository,
    we’ll install it from the official Docker package registry so that we get the
    latest stable version. To do that, we need Apt to support HTTP/S, so let’s do
    that first:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`containerd`可以在标准的Ubuntu软件包库中找到，我们还是会从官方的Docker软件包库安装，以确保我们获得最新的稳定版本。为此，我们需要让Apt支持HTTP/S协议，因此我们首先需要进行此设置：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let’s add the package registry and install:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加包注册表并进行安装：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The final command just ensures that the package installed correctly, that the
    service is running, and that the `ctr` command is working. We don’t see any images
    because we haven’t installed any yet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的命令只是确保包已正确安装，服务正在运行，并且`ctr`命令可以正常工作。我们没有看到任何镜像，因为我们还没有安装任何镜像。
- en: Container runtimes are low-level libraries. They are typically not used directly
    but are used by a higher-level container platform or orchestration environment
    such as Docker or Kubernetes. This means that they put a lot of focus into a quality
    application programming interface (API) but not as much effort into user-facing
    tools we can use from the command line. Fortunately, command line tools are still
    needed for testing, and `containerd` provides the `ctr` tool that we’ll use for
    experimentation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时是底层库。通常不会直接使用它们，而是由更高层的容器平台或编排环境（例如Docker或Kubernetes）使用。这意味着它们会将大量精力放在高质量的应用程序编程接口（API）上，但不会在命令行工具上花费太多精力，尽管这些工具仍然是测试所必需的。幸运的是，`containerd`提供了我们将用于实验的`ctr`工具。
- en: Using containerd
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用containerd
- en: 'Our initial `containerd` command showed that no images have been downloaded
    yet. Let’s download a small image with which we can run a container. We will use
    *BusyBox*, a tiny container image that includes a shell and basic Linux utilities.
    To download the image, we use the `pull` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的`containerd`命令显示尚未下载任何镜像。让我们下载一个小镜像，用于运行容器。我们将使用*BusyBox*，这是一个包含shell和基本Linux工具的小型容器镜像。为了下载镜像，我们使用`pull`命令：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our list of images is no longer empty. Let’s run a container from that image:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的镜像列表不再为空。让我们从这个镜像运行一个容器：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This looks similar to using Docker. We use `-t` to create a TTY for this container,
    allowing us to interact with it, and we use `--rm` to tell `containerd` to delete
    the container when the main process stops. However, there are some important differences
    to note. When we used Docker in [Chapter 1](ch01.xhtml#ch01), we didn’t worry
    about pulling the image before running it, and we were able to use simpler names
    like `nginx` or `rockylinux:8`. The `ctr` tool requires us to specify *docker.io/library/busybox:latest*,
    the full path to the image, with registry hostname and tag included. Also, we
    are required to pull the image first because the runtime won’t do this for us
    automatically.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与使用Docker类似。我们使用`-t`来为这个容器创建一个TTY，以便与其交互，并使用`--rm`告诉`containerd`在主进程停止时删除容器。然而，有一些重要的区别需要注意。当我们在[第一章](ch01.xhtml#ch01)中使用Docker时，我们并没有担心在运行容器之前拉取镜像，我们可以使用像`nginx`或`rockylinux:8`这样的简化名称。`ctr`工具要求我们指定*docker.io/library/busybox:latest*，即镜像的完整路径，包括注册表主机名和标签。另外，我们需要先拉取镜像，因为运行时不会自动为我们做这件事。
- en: 'Now that we’re inside this container, we can see that it has an isolated network
    stack and process space:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入这个容器，可以看到它具有隔离的网络栈和进程空间：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inside the container, we see a loopback network interface. We also see our shell
    process and the `ps` command that we ran. As far as the processes in our container
    are concerned, we are running on a separate system with no other processes running
    or listening on the network.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内部，我们看到一个回环网络接口。我们还看到我们的 shell 进程和我们运行的 `ps` 命令。就容器中的进程而言，我们正在一个没有其他进程运行或在网络上监听的独立系统上运行。
- en: '**WHY NO BRIDGE INTERFACE?**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么没有桥接接口？**'
- en: If you’ve worked with Docker, you might be surprised to see that this container
    has only a loopback interface. Default networking on a container platform also
    provides an additional interface that is attached to a bridge. This allows containers
    to see one another and also allows containers to use the host interface to access
    external networks via Network Address Translation (NAT).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 Docker，可能会惊讶地发现这个容器只有一个回环接口。容器平台的默认网络配置通常还提供一个附加的接口，该接口连接到一个桥接。这样，容器之间可以互相看到，并且容器可以通过网络地址转换（NAT）使用主机接口访问外部网络。
- en: In this case, we are talking directly to a lower-level container runtime. This
    container runtime handles managing images and running containers only. If we want
    a bridge interface and a connection to the internet, we’ll need to provide it
    ourselves (and we do exactly that in [Chapter 4](ch04.xhtml#ch04)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们直接与一个较低级别的容器运行时进行交互。这个容器运行时仅处理镜像管理和容器运行。如果我们需要一个桥接接口和互联网连接，就需要自己提供（我们在[第4章](ch04.xhtml#ch04)中正是这么做的）。
- en: We’ve illustrated that we can talk to the `containerd` runtime to run a container,
    and that inside the container, we’re isolated from the rest of the system. How
    does that isolation work? To find out, let’s keep the container running and investigate
    it from the host system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说明了如何与 `containerd` 运行时交互以运行容器，并且在容器内部，我们与系统的其他部分是隔离的。这个隔离是如何工作的呢？为了找出答案，我们将继续让容器运行并从主机系统进行调查。
- en: Introducing Linux Namespaces
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 介绍 Linux 命名空间
- en: Like other container runtimes, `containerd` uses a Linux kernel feature called
    *namespaces* to isolate the processes in the container. As mentioned earlier,
    most of the effort in process isolation is to ensure that a process can’t see
    things it shouldn’t. A process running in a namespace sees a limited view of a
    particular system resource.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他容器运行时一样，`containerd` 使用名为 *命名空间* 的 Linux 内核特性来隔离容器中的进程。如前所述，进程隔离的主要工作是确保进程看不到它不该看到的东西。运行在命名空间中的进程只能看到特定系统资源的有限视图。
- en: 'Even though containerization seems like new technology, Linux namespaces have
    been available for many years. Over time, more types of namespaces were added.
    We can find out what namespaces are associated with our container using the `lsns`
    command, but first we need to know the process ID (PID) on the host for our container’s
    shell process. While leaving the container running, open another terminal tab
    or window. (See “Running Examples” on [page xx](ch00.xhtml#ch00lev1sec2) for more
    information.) Then, use `ctr` to list running containers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器化看起来像是新技术，但 Linux 命名空间已经存在了多年。随着时间的推移，添加了更多类型的命名空间。我们可以使用 `lsns` 命令找出与我们的容器相关联的命名空间，但首先我们需要知道容器内
    shell 进程在主机上的进程 ID（PID）。在保持容器运行的同时，打开另一个终端标签或窗口。（有关更多信息，请参见[第xx页](ch00.xhtml#ch00lev1sec2)中的“运行示例”）。然后，使用
    `ctr` 列出正在运行的容器：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s use `ps` to verify that we have the correct PID. When you run these commands
    yourself, be sure to use the PID that displays in your listing:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `ps` 来验证我们是否得到了正确的 PID。当你自己运行这些命令时，请务必使用列出中显示的 PID：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As expected, the parent of this PID is `containerd`. Next let’s use `lsns`
    to list the namespaces that `containerd` has created to isolate this process:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这个 PID 的父进程是 `containerd`。接下来，让我们使用 `lsns` 列出 `containerd` 创建的命名空间，以隔离这个进程：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, `containerd` is using five different types of namespaces in order to
    fully isolate the processes running in the `busybox` container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`containerd` 使用五种不同类型的命名空间来完全隔离在 `busybox` 容器中运行的进程：
- en: mnt Mount points
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: mnt 挂载点
- en: uts Unix time sharing (hostname and network domain)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: uts Unix 时间共享（主机名和网络域）
- en: ipc Interprocess communication (for example, shared memory)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ipc 进程间通信（例如，共享内存）
- en: pid Process identifiers (and list of running processes)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: pid 进程标识符（以及正在运行的进程列表）
- en: net Network (including interfaces, routing table, and firewall)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: net 网络（包括接口、路由表和防火墙）
- en: 'Finally, we’ll close out the BusyBox container by running `exit` from within
    that container (first terminal window):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在该容器中运行`exit`来关闭BusyBox容器（第一个终端窗口）：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command returns us to a regular shell prompt so that we can be ready for
    the next set of examples.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回常规的Shell提示符，使我们准备好进行下一组示例。
- en: Containers and Namespaces in CRI-O
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CRI-O中的容器和命名空间
- en: In addition to `containerd`, Kubernetes supports other container runtimes. Depending
    on which Kubernetes distribution you use, you might find that the container runtime
    is different. For example, Red Hat OpenShift uses *CRI-O*, an alternative container
    runtime. CRI-O is also used by the Podman, Buildah, and Skopeo suite of tools,
    which are the standard way to manage containers on Red Hat 8 and related systems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`containerd`，Kubernetes还支持其他容器运行时。根据你使用的Kubernetes发行版，你可能会发现容器运行时不同。例如，Red
    Hat OpenShift使用*CRI-O*，这是另一种容器运行时。CRI-O还被Podman、Buildah和Skopeo工具套件使用，它们是Red Hat
    8及相关系统上管理容器的标准方式。
- en: Let’s run the same container image using CRI-O to get a better picture of how
    container runtimes are different from one another but also to show how they use
    the same underlying Linux kernel capabilities for process isolation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用CRI-O运行相同的容器镜像，以便更好地了解容器运行时如何彼此不同，但也展示它们如何利用相同的Linux内核功能进行进程隔离。
- en: You can skip these install commands by using the *extra* provisioning script
    provided with this chapter’s examples. See the README file for this chapter for
    instructions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用本章示例中提供的*额外*预配脚本跳过这些安装命令。有关说明，请参阅本章的README文件。
- en: 'The OpenSUSE Kubic project hosts repositories for CRI-O for various Linux distributions,
    including Ubuntu, so we will install from there. The exact URL is dependent on
    the version of CRI-O we want to install, and the URLs are long and challenging
    to type, so the automation installs a script to configure some useful environment
    variables. Before proceeding, we need to load that script:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSUSE Kubic项目为各种Linux发行版（包括Ubuntu）提供CRI-O的存储库，因此我们将从那里安装。具体的URL取决于我们要安装的CRI-O版本，且URL较长并且难以输入，因此自动化会安装一个脚本来配置一些有用的环境变量。在继续之前，我们需要加载该脚本：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now use the environment variables to set up the CRI-O repositories and
    install CRI-O:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用环境变量来设置CRI-O存储库并安装CRI-O：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We first add to the list of repositories for `apt` by adding files to */etc/apt/sources.list.d*.
    We then use `apt` to install CRI-O packages. After CRI-O is installed, we use
    `systemd` to enable and start its service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过向*/etc/apt/sources.list.d*添加文件来将CRI-O添加到`apt`的存储库列表中。然后我们使用`apt`安装CRI-O软件包。安装CRI-O后，我们使用`systemd`启用并启动其服务。
- en: Unlike `containerd`, CRI-O does not ship with any command line tools that we
    can use for testing, so the last command installs `crictl`, which is part of the
    Kubernetes project and is designed for testing any container runtime compatible
    with the Container Runtime Interface (CRI) standard. CRI is the programming API
    that Kubernetes itself uses to communicate with container runtimes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与`containerd`不同，CRI-O没有附带我们可以用来进行测试的命令行工具，因此最后一条命令安装了`crictl`，它是Kubernetes项目的一部分，旨在测试任何与容器运行时接口（CRI）标准兼容的容器运行时。CRI是Kubernetes本身用于与容器运行时通信的编程API。
- en: 'Because `crictl` is compatible with any container runtime that supports CRI,
    it needs configuration to connect to CRI-O. CRI-O has installed a configuration
    file */etc/crictl.yaml* to configure `crictl`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`crictl`与任何支持CRI的容器运行时兼容，所以需要配置它以连接到CRI-O。CRI-O已安装了一个配置文件*/etc/crictl.yaml*来配置`crictl`：
- en: '*crictl.yaml*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*crictl.yaml*'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This configuration tells `crictl` to connect to CRI-O’s socket.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置告诉`crictl`连接到CRÍ-O的套接字。
- en: 'To create and run containers, the `crictl` command requires us to provide definition
    files in the JSON or YAML file format. The automated scripts for this chapter
    added two `crictl` definition files to */opt*. The first file, shown in [Listing
    2-1](ch02.xhtml#ch02list1), creates a Pod:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和运行容器，`crictl`命令要求我们提供JSON或YAML文件格式的定义文件。本章的自动化脚本已将两个`crictl`定义文件添加到*/opt*目录。第一个文件，如[清单2-1](ch02.xhtml#ch02list1)所示，创建一个Pod：
- en: '*pod.yaml*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*pod.yaml*'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-1: CRI-O Pod definition*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-1：CRI-O Pod定义*'
- en: 'Similar to the Kubernetes Pod we saw in [Chapter 1](ch01.xhtml#ch01), the Pod
    is a group of one or more containers that run in the same isolated space. In our
    case, we need only one container in the Pod, and the second file, shown in [Listing
    2-2](ch02.xhtml#ch02list2), defines the container process that CRI-O should start.
    We provide a name (`busybox`) and namespace (`crio`) to distinguish this Pod from
    any others. Otherwise, we need to provide only network configuration. CRI-O expects
    to use a Container Network Interface (CNI) plug-in to configure the network namespace.
    We cover CNI plug-ins in [Chapter 8](ch08.xhtml#ch08), so for now, we’ll use `network:
    2` to tell CRI-O not to create a separate network namespace and instead use the
    host network:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '与我们在 [第 1 章](ch01.xhtml#ch01) 中看到的 Kubernetes Pod 类似，Pod 是一组在同一隔离空间中运行的一个或多个容器。在我们的案例中，我们只需要一个容器在
    Pod 中，第二个文件，见 [示例 2-2](ch02.xhtml#ch02list2)，定义了 CRI-O 应该启动的容器进程。我们提供一个名称（`busybox`）和命名空间（`crio`）来区分这个
    Pod 和其他 Pod。否则，我们只需提供网络配置。CRI-O 期望使用容器网络接口（CNI）插件来配置网络命名空间。我们将在 [第 8 章](ch08.xhtml#ch08)
    中讨论 CNI 插件，因此现在我们将使用 `network: 2` 告诉 CRI-O 不要创建单独的网络命名空间，而是使用主机网络：'
- en: '*container.yaml*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*container.yaml*'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 2-2: CRI-O container definition*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-2：CRI-O 容器定义*'
- en: Again we are using BusyBox because its small size makes it fast and lightweight.
    However, because `crictl` will create this container in the background without
    a terminal, we need to specify */bin/sleep* as the command to be run inside the
    container; otherwise, the container will immediately terminate when the shell
    realizes that it doesn’t have a TTY.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 BusyBox 是因为它体积小，运行快速且轻量。然而，由于 `crictl` 会在后台创建此容器而没有终端，我们需要指定 */bin/sleep*
    作为容器内要运行的命令；否则，容器会立即终止，因为 shell 会发现它没有 TTY。
- en: 'Before we can run the container, we first need to pull the image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器之前，我们首先需要拉取镜像：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we provide the *pod.yaml* and *container.yaml* files to `crictl` to create
    and start our BusyBox container:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 *pod.yaml* 和 *container.yaml* 文件提供给 `crictl`，以创建并启动我们的 BusyBox 容器：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We capture the Pod’s unique identifier and the container in `POD_ID` and `CONTAINER_ID`
    variables, so we can use them here and upcoming commands.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们捕获了 Pod 的唯一标识符和容器的标识符，分别保存在 `POD_ID` 和 `CONTAINER_ID` 变量中，以便在这里和接下来的命令中使用。
- en: 'Before looking at the Linux namespaces created by CRI-O, let’s look inside
    the `busybox` container by using the `crictl exec` command to start a new shell
    process inside it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 CRI-O 创建的 Linux 命名空间之前，让我们通过使用 `crictl exec` 命令在容器内部启动一个新的 shell 进程来查看 `busybox`
    容器的内部：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This BusyBox container running in CRI-O looks a little different from BusyBox
    running in `containerd`. First, because we configured our Pod with `network: 2`,
    the container can see the same network devices that a regular process would see.
    Second, we see a couple of additional processes. We look at the `pause` process
    with PID 1 when we discuss container runtimes under Kubernetes in [Chapter 12](ch12.xhtml#ch12).
    The other extra process is `sleep`, which we created as the entry point for this
    container.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '这个在 CRI-O 中运行的 BusyBox 容器与在 `containerd` 中运行的 BusyBox 看起来有些不同。首先，因为我们将 Pod
    配置为 `network: 2`，所以容器可以看到与常规进程相同的网络设备。其次，我们看到了一些额外的进程。当我们在 [第 12 章](ch12.xhtml#ch12)讨论
    Kubernetes 下的容器运行时时，我们会看到 PID 为 1 的 `pause` 进程。另一个额外的进程是 `sleep`，我们将其作为此容器的入口点。'
- en: 'CRI-O is also using Linux namespaces for process isolation, as we can see from
    examining the container processes and listing namespaces:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: CRI-O 也使用 Linux 命名空间来进行进程隔离，正如我们从检查容器进程和列出命名空间中看到的那样：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `crictl inspect` command provides a wealth of information about the container,
    but for the moment, we need only the PID. Because `crictl` returns JSON-formatted
    output, we can use `jq` to extract the `pid` field from the `info` structure and
    save it to an environment variable called `PID`. Try running crictl inspect $CONTAINER_ID
    to see the full information.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`crictl inspect` 命令提供了大量关于容器的信息，但目前我们只需要 PID。由于 `crictl` 返回 JSON 格式的输出，我们可以使用
    `jq` 从 `info` 结构中提取 `pid` 字段并将其保存到一个名为 `PID` 的环境变量中。尝试运行 crictl inspect $CONTAINER_ID
    来查看完整信息。'
- en: 'Using the PID we discovered, we can see our `sleep` command. We then can use
    its parent PID to verify that it is managed by `conmon`, a CRI-O utility. Next,
    let’s see the namespaces that CRI-O has created. The allocation of namespaces
    to processes is more complex in CRI-O, so let’s just list all of the namespaces
    on our Linux system and pick out the ones related to the container:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们发现的PID，我们可以看到我们的`sleep`命令。然后，我们可以使用其父PID来验证它是由`conmon`（一个CRI-O工具）管理的。接下来，让我们看看CRI-O创建的命名空间。由于CRI-O中进程的命名空间分配更为复杂，我们将列出Linux系统上的所有命名空间，并挑选出与容器相关的命名空间：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we see only four types of namespaces. Because we told CRI-O to give the
    container access to the host’s network namespace, it didn’t need to create a `net`
    namespace. Also, with CRI-O, most namespaces are associated with the `pause` command
    (although some are shared by multiple processes, as we can see via the `NPROCS`
    column). There are two `mnt` namespaces because each separate container in a Pod
    gets a different set of mount points for reasons that we cover in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只看到四种类型的命名空间。因为我们告诉CRI-O允许容器访问主机的网络命名空间，所以它不需要创建`net`命名空间。此外，在CRI-O中，大多数命名空间与`pause`命令关联（尽管有些命名空间被多个进程共享，正如我们通过`NPROCS`列看到的）。有两个`mnt`命名空间，因为每个Pod中的独立容器会得到一组不同的挂载点，具体原因我们将在[第5章](ch05.xhtml#ch05)中讨论。
- en: Running Processes in Namespaces Directly
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在命名空间中直接运行进程
- en: One of the trickier jobs when running a process in a container is handling the
    responsibility that comes with being PID 1\. To better understand this, we won’t
    have our container runtime create a namespace for us. Instead, we’ll talk directly
    to the Linux kernel to run a process in a namespace manually. We’ll use the command
    line, although container runtimes use the Linux kernel API, but the result will
    be the same.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行进程时，最棘手的任务之一是处理作为PID 1所带来的责任。为了更好地理解这一点，我们不会让容器运行时为我们创建命名空间。而是直接与Linux内核通信，手动在命名空间中运行进程。我们将使用命令行，虽然容器运行时使用Linux内核API，但结果是相同的。
- en: 'Because namespaces are a Linux kernel feature, nothing else needs to be installed
    or configured. We just use the `unshare` command when launching the process:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为命名空间是Linux内核的特性，所以无需安装或配置其他内容。我们只需在启动进程时使用`unshare`命令：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `unshare` command runs a program with different namespaces from the parent.
    By adding `-p`, we specify that a new PID namespace is needed. The option `--mount-proc`
    goes along with that, adding a new mount namespace and ensuring */proc* is remounted
    correctly, so that the process sees the correct process information. Otherwise,
    the process would still be able to see information about other processes in the
    system. Finally, the content after `--` indicates the command to run.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshare`命令在不同命名空间下运行一个程序。通过添加`-p`，我们指定需要一个新的PID命名空间。选项`--mount-proc`与此配合，添加一个新的挂载命名空间，并确保`/proc`被正确地重新挂载，以便进程看到正确的进程信息。否则，进程仍然可以看到系统中其他进程的信息。最后，`--`后面的内容指示要运行的命令。'
- en: 'Because this is an isolated process namespace, it cannot see a list of processes
    outside this namespace:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个隔离的进程命名空间，它无法看到该命名空间外的进程列表：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s get the ID of this namespace so that we can recognize it in a list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这个命名空间的ID，以便我们在列表中识别它：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, from another terminal window, list all of the namespaces and look for
    those related to our isolated shell:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从另一个终端窗口列出所有命名空间，并查找与我们的隔离shell相关的命名空间：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We see a `pid` namespace matching what we saw. In addition, we see a `mnt` namespace.
    This namespace ensures that our shell sees the proper information in */proc*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个与之前看到的匹配的`pid`命名空间。此外，我们还看到了一个`mnt`命名空间。这个命名空间确保我们的shell看到`/proc`中的正确信息。
- en: Because the `pid` namespace is owned by the `sh` command, that command is PID
    1 when we run `ps` within the namespace. This means that `sh` has the responsibility
    to manage its children properly (such as `bash`). For example, `sh` is responsible
    for passing signals to its children to ensure that they terminate correctly. It’s
    important to keep this in mind as it is a common problem when running containers
    that can result in zombie processes or other issues cleaning up a stopped container.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`pid`命名空间是由`sh`命令拥有的，当我们在命名空间内运行`ps`时，`sh`命令的PID为1。这意味着`sh`负责正确管理其子进程（如`bash`）。例如，`sh`负责向其子进程发送信号，确保它们正确终止。记住这一点很重要，因为这是在运行容器时常见的问题，可能导致僵尸进程或清理已停止容器时的其他问题。
- en: 'Fortunately, `sh` handles its management duties well, as we can see by the
    fact that when we pass a `kill` signal to it, it passes that signal on to its
    children. Run this from the second terminal window, outside the namespace:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`sh` 很好地处理了它的管理任务，我们可以看到，当我们向它发送 `kill` 信号时，它会将该信号传递给它的子进程。从第二个终端窗口运行此命令，位于命名空间之外：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the first window you will see this output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个窗口中，你会看到以下输出：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This indicates that `bash` received the `kill` signal and terminated correctly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `bash` 收到了 `kill` 信号并正确终止。
- en: Final Thoughts
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后的思考
- en: Although containers create the appearance of a completely separate system, it’s
    done in a way that has nothing in common with virtual machines. Instead, the process
    is similar to traditional means of process isolation, such as user permissions
    and separate filesystems. Container runtimes use namespaces, which are built in
    to the Linux kernel and enable various types of process isolation. In this chapter,
    we examined how the `containerd` and CRI-O container runtimes use multiple types
    of Linux namespaces to give each container an independent view of other processes,
    network devices, and the filesystem. The use of namespaces prevents processes
    running in a container from seeing and interfering with other processes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器创建了一个完全独立的系统的表象，但其实现方式与虚拟机完全不同。相反，这个过程类似于传统的进程隔离方式，例如用户权限和独立的文件系统。容器运行时使用命名空间，这是
    Linux 内核内置的功能，可实现各种类型的进程隔离。在本章中，我们研究了 `containerd` 和 CRI-O 容器运行时如何使用多种类型的 Linux
    命名空间，为每个容器提供对其他进程、网络设备和文件系统的独立视图。命名空间的使用防止了容器中的进程看到并干扰其他进程。
- en: At the same time, processes in a container are still sharing the same CPU, memory,
    and network. A process that uses too many of those resources will prevent other
    processes from running properly. Namespaces can’t solve that problem, however.
    To prevent this issue, we’ll need to look at resource limiting—the topic of our
    next chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，容器中的进程仍然共享相同的 CPU、内存和网络。一个使用过多资源的进程会阻止其他进程正常运行。然而，命名空间无法解决这个问题。为了防止这个问题，我们需要关注资源限制——这是下一章的主题。
