- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PROCESS ISOLATION
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Containers build on a rich history of technologies designed to isolate one computer
    program from another while allowing many programs to share the same CPU, memory,
    storage, and network resources. Containers use fundamental capabilities of the
    Linux kernel, particularly namespaces, which create separate views of process
    identifiers, users, the filesystem, and network interfaces. Container runtimes
    use multiple types of namespaces to give each container an isolated view of the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll consider some of the reasons for process isolation and
    look at how Linux has historically isolated processes. We’ll then examine how
    containers use namespaces to provide isolation. We’ll test this using a couple
    of different container runtimes. Finally, we will use Linux commands to create
    namespaces directly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Isolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before running some containers and inspecting their isolation, let’s look at
    the motivation for process isolation. We’ll also consider traditional process
    isolation in Linux and how that has led to the isolation capabilities that containers
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Why Processes Need Isolation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The whole idea of a computer is that it is a general-purpose machine that can
    run many different kinds of programs. Ever since the beginning of computing, there
    has been a need to share a single computer between multiple programs. It started
    with people taking turns submitting programs on punch cards, but as computer multitasking
    became more sophisticated, people could start multiple programs, and the computer
    would make it seem as if they were all running on the same CPU at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as soon as something needs to be shared, there is a need to make
    sure it is shared fairly, and computer programs are no different. So although
    we think of a *process* as an independent program with its own time on the CPU
    and its own memory space, there are many ways that one process can cause trouble
    for another, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Using too much CPU, memory, storage, or network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overwriting the memory or files of another process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting secret information from another process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending another process bad data to cause it to misbehave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flooding another process with requests so that it stops responding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs can cause processes to do these same things by accident, but a bigger concern
    is a security vulnerability that allows a bad actor to use one process to cause
    problems for another. It takes only one vulnerability to create major problems
    in a system, so we need ways to isolate processes that limit damage from both
    accidental and intentional behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Physical isolation is best—*air-gapped* systems are regularly used to protect
    government-classified information and safety-critical systems—but this approach
    is also too expensive and inconvenient for many uses. Virtual machines can give
    the appearance of separation while sharing physical hardware, but a virtual machine
    has the overhead of running its own operating system, services, and virtual devices,
    making it slower to start and less scalable. The solution is to run regular processes,
    but use process isolation to reduce the risk of affecting other processes.
  prefs: []
  type: TYPE_NORMAL
- en: File Permissions and Change Root
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the effort in process isolation involves preventing one process from
    seeing things it shouldn’t. After all, if a process can’t even see another process,
    it will be far more difficult to cause trouble, either accidentally or on purpose.
    The traditional ways that Linux has controlled what processes can see and do serve
    as the foundation for the ideas behind containers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most basic visibility controls is *filesystem permissions*. Linux
    associates an owner and group with each file and directory, and manages read,
    write, and execute permissions. This basic permission scheme works well to ensure
    that user files are kept private, that a process cannot overwrite the files of
    another process, and that only a privileged user like root can install new software
    or modify critical system configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this permission scheme relies on us ensuring that each process is
    run as the authentic user and that users are in the appropriate groups. Typically,
    each new service install creates a user just for running that service. Even better,
    this *service user* can be configured without a real login shell, which means
    that the user cannot be exploited to log in to the system. To make this clear,
    let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The example repository for this book is at* [https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples).
    *See “Running Examples” on [page xx](ch00.xhtml#ch00lev1sec2) for details on getting
    set up.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux `rsyslogd` service provides logging services, so it needs to write
    to files in */var/log*, but it should not have permissions to read or write all
    of the files in that directory. File permissions are used to control this, as
    shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The *syslog* user ➊ exists specifically to run `rsyslogd`, and that user is
    configured with no login shell for security reasons ➋. Because `rsyslogd` needs
    to be able to write to *auth.log*, it’s given write permission, as shown in the
    file mode printout ➌. Members of the admin (*adm*) group have read-only access
    to this file.
  prefs: []
  type: TYPE_NORMAL
- en: An initial `d` in the file mode ➍ indicates that this is a directory. The following
    `rwx` indicates that the root user has read, write, and execute permissions. The
    remaining dashes indicate that there are no rights for members of the *root* group
    or for other system users, so we can conclude that the `rsyslogd` process cannot
    see the contents of this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Permission control is important, but it doesn’t fully satisfy our goal of process
    isolation. One reason is that it is not enough to protect us from *privilege escalation*,
    wherein a vulnerable process and a vulnerable system allow a bad actor to obtain
    root privileges. To help deal with this, some Linux services go a step beyond
    by running in an isolated part of the filesystem. This approach is known as `chroot`
    for “change root.” Running in a `chroot` environment requires quite a bit of setup,
    as you can see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to copy in all of the executables that we intend to run ➊. We
    also need to copy in all of the shared libraries these executables use, which
    we specify with the `ldd | grep | awk` command ➋. When both binaries and libraries
    are copied in, we can use the `chroot` command ➌ to move into our isolated environment.
    Only the files we copied in are visible ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Container Isolation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For experienced Linux system administrators, file permissions and change root
    are basic-level knowledge. However, those concepts also serve as the foundation
    for how containers work. Even though a running container appears like a completely
    separate system, with its own hostname, network, processes, and filesystem (as
    we saw in [Chapter 1](ch01.xhtml#ch01)), it’s really a regular Linux process using
    isolation rather than a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A container has multiple kinds of isolation, including several essential kinds
    of isolation that we haven’t seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: Mounted filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hostname and domain name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interprocess communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These separate kinds of isolation work together so that a process or collection
    of processes looks like a completely separate system. Although these processes
    still share the kernel and physical hardware, this isolation goes a long way toward
    ensuring that they cannot cause trouble for other processes, especially when we
    configure containers correctly to control the CPU, memory, storage, and network
    resources available to them.
  prefs: []
  type: TYPE_NORMAL
- en: Container Platforms and Container Runtimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying all the binaries, libraries, and configuration files needed to run
    a process in an isolated filesystem would be laborious. Fortunately, as we saw
    in [Chapter 1](ch01.xhtml#ch01), *container images* come prepackaged with the
    needed executables and libraries. Using Docker, we were able to easily download
    and run NGINX in a container. Docker is an example of a *container platform*,
    providing not only the ability to run containers but also container storage, networking,
    and security.
  prefs: []
  type: TYPE_NORMAL
- en: Under the covers, modern versions of Docker are using `containerd` as the *container
    runtime*, also known as a *container engine*. A container runtime provides low-level
    functionality to run processes in containers.
  prefs: []
  type: TYPE_NORMAL
- en: To explore isolation further, let’s experiment with two different container
    runtimes to start containers from preexisting images and then inspect how processes
    in containers are isolated from the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing containerd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll be using `containerd` in [Part II](part02.xhtml#part02) in support of
    our Kubernetes clusters, so let’s begin by installing and interacting with this
    runtime directly. Interacting directly with `containerd` will also benefit our
    exploration of process isolation.
  prefs: []
  type: TYPE_NORMAL
- en: You can skip install commands by using the *extra* provisioning script provided
    with this chapter’s examples. See the README file for this chapter for instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though `containerd` is available in the standard Ubuntu package repository,
    we’ll install it from the official Docker package registry so that we get the
    latest stable version. To do that, we need Apt to support HTTP/S, so let’s do
    that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s add the package registry and install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The final command just ensures that the package installed correctly, that the
    service is running, and that the `ctr` command is working. We don’t see any images
    because we haven’t installed any yet.
  prefs: []
  type: TYPE_NORMAL
- en: Container runtimes are low-level libraries. They are typically not used directly
    but are used by a higher-level container platform or orchestration environment
    such as Docker or Kubernetes. This means that they put a lot of focus into a quality
    application programming interface (API) but not as much effort into user-facing
    tools we can use from the command line. Fortunately, command line tools are still
    needed for testing, and `containerd` provides the `ctr` tool that we’ll use for
    experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: Using containerd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our initial `containerd` command showed that no images have been downloaded
    yet. Let’s download a small image with which we can run a container. We will use
    *BusyBox*, a tiny container image that includes a shell and basic Linux utilities.
    To download the image, we use the `pull` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our list of images is no longer empty. Let’s run a container from that image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This looks similar to using Docker. We use `-t` to create a TTY for this container,
    allowing us to interact with it, and we use `--rm` to tell `containerd` to delete
    the container when the main process stops. However, there are some important differences
    to note. When we used Docker in [Chapter 1](ch01.xhtml#ch01), we didn’t worry
    about pulling the image before running it, and we were able to use simpler names
    like `nginx` or `rockylinux:8`. The `ctr` tool requires us to specify *docker.io/library/busybox:latest*,
    the full path to the image, with registry hostname and tag included. Also, we
    are required to pull the image first because the runtime won’t do this for us
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’re inside this container, we can see that it has an isolated network
    stack and process space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Inside the container, we see a loopback network interface. We also see our shell
    process and the `ps` command that we ran. As far as the processes in our container
    are concerned, we are running on a separate system with no other processes running
    or listening on the network.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHY NO BRIDGE INTERFACE?**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve worked with Docker, you might be surprised to see that this container
    has only a loopback interface. Default networking on a container platform also
    provides an additional interface that is attached to a bridge. This allows containers
    to see one another and also allows containers to use the host interface to access
    external networks via Network Address Translation (NAT).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are talking directly to a lower-level container runtime. This
    container runtime handles managing images and running containers only. If we want
    a bridge interface and a connection to the internet, we’ll need to provide it
    ourselves (and we do exactly that in [Chapter 4](ch04.xhtml#ch04)).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve illustrated that we can talk to the `containerd` runtime to run a container,
    and that inside the container, we’re isolated from the rest of the system. How
    does that isolation work? To find out, let’s keep the container running and investigate
    it from the host system.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Linux Namespaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like other container runtimes, `containerd` uses a Linux kernel feature called
    *namespaces* to isolate the processes in the container. As mentioned earlier,
    most of the effort in process isolation is to ensure that a process can’t see
    things it shouldn’t. A process running in a namespace sees a limited view of a
    particular system resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though containerization seems like new technology, Linux namespaces have
    been available for many years. Over time, more types of namespaces were added.
    We can find out what namespaces are associated with our container using the `lsns`
    command, but first we need to know the process ID (PID) on the host for our container’s
    shell process. While leaving the container running, open another terminal tab
    or window. (See “Running Examples” on [page xx](ch00.xhtml#ch00lev1sec2) for more
    information.) Then, use `ctr` to list running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use `ps` to verify that we have the correct PID. When you run these commands
    yourself, be sure to use the PID that displays in your listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the parent of this PID is `containerd`. Next let’s use `lsns`
    to list the namespaces that `containerd` has created to isolate this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `containerd` is using five different types of namespaces in order to
    fully isolate the processes running in the `busybox` container:'
  prefs: []
  type: TYPE_NORMAL
- en: mnt Mount points
  prefs: []
  type: TYPE_NORMAL
- en: uts Unix time sharing (hostname and network domain)
  prefs: []
  type: TYPE_NORMAL
- en: ipc Interprocess communication (for example, shared memory)
  prefs: []
  type: TYPE_NORMAL
- en: pid Process identifiers (and list of running processes)
  prefs: []
  type: TYPE_NORMAL
- en: net Network (including interfaces, routing table, and firewall)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll close out the BusyBox container by running `exit` from within
    that container (first terminal window):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command returns us to a regular shell prompt so that we can be ready for
    the next set of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and Namespaces in CRI-O
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to `containerd`, Kubernetes supports other container runtimes. Depending
    on which Kubernetes distribution you use, you might find that the container runtime
    is different. For example, Red Hat OpenShift uses *CRI-O*, an alternative container
    runtime. CRI-O is also used by the Podman, Buildah, and Skopeo suite of tools,
    which are the standard way to manage containers on Red Hat 8 and related systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run the same container image using CRI-O to get a better picture of how
    container runtimes are different from one another but also to show how they use
    the same underlying Linux kernel capabilities for process isolation.
  prefs: []
  type: TYPE_NORMAL
- en: You can skip these install commands by using the *extra* provisioning script
    provided with this chapter’s examples. See the README file for this chapter for
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenSUSE Kubic project hosts repositories for CRI-O for various Linux distributions,
    including Ubuntu, so we will install from there. The exact URL is dependent on
    the version of CRI-O we want to install, and the URLs are long and challenging
    to type, so the automation installs a script to configure some useful environment
    variables. Before proceeding, we need to load that script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the environment variables to set up the CRI-O repositories and
    install CRI-O:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We first add to the list of repositories for `apt` by adding files to */etc/apt/sources.list.d*.
    We then use `apt` to install CRI-O packages. After CRI-O is installed, we use
    `systemd` to enable and start its service.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `containerd`, CRI-O does not ship with any command line tools that we
    can use for testing, so the last command installs `crictl`, which is part of the
    Kubernetes project and is designed for testing any container runtime compatible
    with the Container Runtime Interface (CRI) standard. CRI is the programming API
    that Kubernetes itself uses to communicate with container runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `crictl` is compatible with any container runtime that supports CRI,
    it needs configuration to connect to CRI-O. CRI-O has installed a configuration
    file */etc/crictl.yaml* to configure `crictl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*crictl.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This configuration tells `crictl` to connect to CRI-O’s socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and run containers, the `crictl` command requires us to provide definition
    files in the JSON or YAML file format. The automated scripts for this chapter
    added two `crictl` definition files to */opt*. The first file, shown in [Listing
    2-1](ch02.xhtml#ch02list1), creates a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pod.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: CRI-O Pod definition*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the Kubernetes Pod we saw in [Chapter 1](ch01.xhtml#ch01), the Pod
    is a group of one or more containers that run in the same isolated space. In our
    case, we need only one container in the Pod, and the second file, shown in [Listing
    2-2](ch02.xhtml#ch02list2), defines the container process that CRI-O should start.
    We provide a name (`busybox`) and namespace (`crio`) to distinguish this Pod from
    any others. Otherwise, we need to provide only network configuration. CRI-O expects
    to use a Container Network Interface (CNI) plug-in to configure the network namespace.
    We cover CNI plug-ins in [Chapter 8](ch08.xhtml#ch08), so for now, we’ll use `network:
    2` to tell CRI-O not to create a separate network namespace and instead use the
    host network:'
  prefs: []
  type: TYPE_NORMAL
- en: '*container.yaml*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-2: CRI-O container definition*'
  prefs: []
  type: TYPE_NORMAL
- en: Again we are using BusyBox because its small size makes it fast and lightweight.
    However, because `crictl` will create this container in the background without
    a terminal, we need to specify */bin/sleep* as the command to be run inside the
    container; otherwise, the container will immediately terminate when the shell
    realizes that it doesn’t have a TTY.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can run the container, we first need to pull the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we provide the *pod.yaml* and *container.yaml* files to `crictl` to create
    and start our BusyBox container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We capture the Pod’s unique identifier and the container in `POD_ID` and `CONTAINER_ID`
    variables, so we can use them here and upcoming commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before looking at the Linux namespaces created by CRI-O, let’s look inside
    the `busybox` container by using the `crictl exec` command to start a new shell
    process inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This BusyBox container running in CRI-O looks a little different from BusyBox
    running in `containerd`. First, because we configured our Pod with `network: 2`,
    the container can see the same network devices that a regular process would see.
    Second, we see a couple of additional processes. We look at the `pause` process
    with PID 1 when we discuss container runtimes under Kubernetes in [Chapter 12](ch12.xhtml#ch12).
    The other extra process is `sleep`, which we created as the entry point for this
    container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CRI-O is also using Linux namespaces for process isolation, as we can see from
    examining the container processes and listing namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `crictl inspect` command provides a wealth of information about the container,
    but for the moment, we need only the PID. Because `crictl` returns JSON-formatted
    output, we can use `jq` to extract the `pid` field from the `info` structure and
    save it to an environment variable called `PID`. Try running crictl inspect $CONTAINER_ID
    to see the full information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the PID we discovered, we can see our `sleep` command. We then can use
    its parent PID to verify that it is managed by `conmon`, a CRI-O utility. Next,
    let’s see the namespaces that CRI-O has created. The allocation of namespaces
    to processes is more complex in CRI-O, so let’s just list all of the namespaces
    on our Linux system and pick out the ones related to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see only four types of namespaces. Because we told CRI-O to give the
    container access to the host’s network namespace, it didn’t need to create a `net`
    namespace. Also, with CRI-O, most namespaces are associated with the `pause` command
    (although some are shared by multiple processes, as we can see via the `NPROCS`
    column). There are two `mnt` namespaces because each separate container in a Pod
    gets a different set of mount points for reasons that we cover in [Chapter 5](ch05.xhtml#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: Running Processes in Namespaces Directly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the trickier jobs when running a process in a container is handling the
    responsibility that comes with being PID 1\. To better understand this, we won’t
    have our container runtime create a namespace for us. Instead, we’ll talk directly
    to the Linux kernel to run a process in a namespace manually. We’ll use the command
    line, although container runtimes use the Linux kernel API, but the result will
    be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because namespaces are a Linux kernel feature, nothing else needs to be installed
    or configured. We just use the `unshare` command when launching the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `unshare` command runs a program with different namespaces from the parent.
    By adding `-p`, we specify that a new PID namespace is needed. The option `--mount-proc`
    goes along with that, adding a new mount namespace and ensuring */proc* is remounted
    correctly, so that the process sees the correct process information. Otherwise,
    the process would still be able to see information about other processes in the
    system. Finally, the content after `--` indicates the command to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is an isolated process namespace, it cannot see a list of processes
    outside this namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s get the ID of this namespace so that we can recognize it in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from another terminal window, list all of the namespaces and look for
    those related to our isolated shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We see a `pid` namespace matching what we saw. In addition, we see a `mnt` namespace.
    This namespace ensures that our shell sees the proper information in */proc*.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `pid` namespace is owned by the `sh` command, that command is PID
    1 when we run `ps` within the namespace. This means that `sh` has the responsibility
    to manage its children properly (such as `bash`). For example, `sh` is responsible
    for passing signals to its children to ensure that they terminate correctly. It’s
    important to keep this in mind as it is a common problem when running containers
    that can result in zombie processes or other issues cleaning up a stopped container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, `sh` handles its management duties well, as we can see by the
    fact that when we pass a `kill` signal to it, it passes that signal on to its
    children. Run this from the second terminal window, outside the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the first window you will see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that `bash` received the `kill` signal and terminated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although containers create the appearance of a completely separate system, it’s
    done in a way that has nothing in common with virtual machines. Instead, the process
    is similar to traditional means of process isolation, such as user permissions
    and separate filesystems. Container runtimes use namespaces, which are built in
    to the Linux kernel and enable various types of process isolation. In this chapter,
    we examined how the `containerd` and CRI-O container runtimes use multiple types
    of Linux namespaces to give each container an independent view of other processes,
    network devices, and the filesystem. The use of namespaces prevents processes
    running in a container from seeing and interfering with other processes.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, processes in a container are still sharing the same CPU, memory,
    and network. A process that uses too many of those resources will prevent other
    processes from running properly. Namespaces can’t solve that problem, however.
    To prevent this issue, we’ll need to look at resource limiting—the topic of our
    next chapter.
  prefs: []
  type: TYPE_NORMAL
