- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 13 MACROS AND THE GAS COMPILE-TIME LANGUAGE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13 宏和 Gas 编译时语言
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter discusses the Gas compile-time language (CTL), including its macro
    expansion facilities. A *macro*, the CTL equivalent of a procedure, is an identifier
    that the assembler will expand into additional text. This allows you to abbreviate
    large amounts of code with a single identifier. Gas’s macro facility is a computer
    language inside a computer language; that is, you can write short programs inside
    a Gas source file whose purpose is to generate other Gas source code to be assembled
    by Gas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 Gas 编译时语言（CTL），包括其宏扩展功能。*宏*，是 CTL 中等同于过程的概念，是一个标识符，汇编器将其扩展为额外的文本。这允许你通过一个标识符来缩写大量代码。Gas
    的宏功能相当于计算机语言中的计算机语言；也就是说，你可以在 Gas 源文件中编写短程序，其目的是生成其他将由 Gas 汇编的源代码。
- en: The Gas CTL consists of macros, conditionals (if statements), loops, and other
    statements. This chapter covers many Gas CTL features and how you can use them
    to reduce the effort needed to write assembly language code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Gas CTL 包含宏、条件语句（如 if 语句）、循环以及其他语句。本章介绍了许多 Gas CTL 特性，以及如何使用它们来减少编写汇编语言代码的工作量。
- en: '### 13.1 The Gas Compile-Time Language Interpreter'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 13.1 Gas 编译时语言解释器'
- en: Gas is actually two languages rolled into a single program. The *runtime language*
    is the standard ARM/Gas assembly language you’ve been reading about in the previous
    chapters. This is called the runtime language because the programs you write execute
    when you run the executable file. Gas contains an interpreter for a second language,
    the *Gas CTL*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 实际上是将两种语言合并到一个程序中。*运行时语言*是你在前几章中阅读的标准 ARM/Gas 汇编语言。之所以称之为运行时语言，是因为你编写的程序在你运行可执行文件时执行。Gas
    包含一个解释器，用于解释第二种语言——*Gas CTL*。
- en: Gas source files contain instructions for both the Gas CTL and the runtime program,
    and Gas executes the CTL program during assembly (compilation). Once Gas completes
    assembly, the CTL program terminates. [Figure 13-1](chapter13.xhtml#fig13-1) shows
    the relationship between compile-time and runtime with respect to the Gas assembler
    and your assembly language source code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 源文件包含 Gas CTL 和运行时程序的指令，Gas 在汇编（编译）过程中执行 CTL 程序。一旦 Gas 完成汇编，CTL 程序便终止。[图13-1](chapter13.xhtml#fig13-1)
    显示了 Gas 汇编器和你的汇编语言源代码在编译时与运行时之间的关系。
- en: '![](../images/Figure13-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-1.jpg)'
- en: 'Figure 13-1: Compile-time versus runtime execution'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：编译时执行与运行时执行
- en: The CTL application is not a part of the runtime executable that Gas emits,
    although the CTL application can write part of the runtime program for you. In
    fact, this is the major purpose of the CTL. Using automatic code generation, the
    CTL gives you the ability to emit repetitive code easily and elegantly. By learning
    how to use the Gas CTL and applying it properly, you can potentially develop assembly
    language applications as rapidly as HLL applications (even faster because Gas’s
    CTL lets you create very HLL, or VHLL, constructs).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CTL 应用程序并不是 Gas 发出的运行时可执行文件的一部分，尽管 CTL 应用程序可以为你编写部分运行时程序。事实上，这正是 CTL 的主要目的。通过自动代码生成，CTL
    使你能够轻松且优雅地生成重复的代码。通过学习如何使用 Gas CTL 并正确应用它，你可以像开发高级语言（HLL）应用程序一样快速开发汇编语言应用程序（甚至更快，因为
    Gas 的 CTL 让你能够创建非常接近 HLL 的结构，简称 VHLL）。
- en: 13.2 The C/C++ Preprocessor
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2 C/C++ 预处理器
- en: 'The Gas CTL consists of two separate language processors: the Gas built-in
    macro processor and the C/C++ preprocessor (CPP). As noted in [Chapter 1](chapter1.xhtml),
    standard Gas assembly language source files use the *.s* suffix. However, if you
    specify *.S* as the suffix, Gas will run the source file through the CPP prior
    to processing the file (see [Figure 13-2](chapter13.xhtml#fig13-2)). The CPP emits
    a temporary source file (with the *.s* suffix), which the Gas assembler then assembles
    into object code.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Gas CTL 由两个独立的语言处理器组成：Gas 内置宏处理器和 C/C++ 预处理器（CPP）。正如在[第1章](chapter1.xhtml)中所提到的，标准的
    Gas 汇编语言源文件使用 *.s* 后缀。然而，如果你指定 *.S* 作为后缀，Gas 会在处理文件之前先通过 CPP 运行该源文件（参见[图13-2](chapter13.xhtml#fig13-2)）。CPP
    会生成一个临时源文件（使用 *.s* 后缀），然后 Gas 汇编器将其汇编成目标代码。
- en: '![](../images/Figure13-2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-2.jpg)'
- en: 'Figure 13-2: C preprocessor processing by Gas'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：Gas 的 C 预处理器处理过程
- en: It is extremely important to remember that the CPP runs independently of Gas
    and prior to it assembling the assembly language source file. In particular, Gas’s
    macro processing takes place *after* the CPP runs. Therefore, you cannot use Gas
    statements, symbols, or Gas macros to affect the operation of the CPP. Later in
    this chapter, I’ll point out the areas where you must take care when mixing the
    macro facilities of the two languages. This section describes the various features
    of the CPP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是要记住，CPP 独立于 Gas 运行，并且在 Gas 汇编汇编语言源文件之前运行。特别是，Gas 的宏处理发生在 CPP 运行之后。因此，你不能使用
    Gas 语句、符号或 Gas 宏来影响 CPP 的操作。稍后在本章中，我将指出在混合两种语言的宏功能时需要注意的地方。本节描述了 CPP 的各种特性。
- en: '13.2.1 The #warning and #error Directives'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '13.2.1 #warning 和 #error 指令'
- en: 'When writing macros by using CPP, you’ll sometimes encounter a problem (such
    as a bad parameter argument) that you’ll want to report as an error or a diagnostic
    message during the assembly process. To do so, you can use the #warning and #error
    diagnostic statements with the following syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用 CPP 编写宏时，你有时会遇到一个问题（例如一个不正确的参数），你希望在汇编过程中将其报告为错误或诊断消息。为此，你可以使用 #warning
    和 #error 诊断语句，语法如下：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These statements must appear on a source line by themselves; nothing other
    than whitespace (spaces and tabs) should appear on the line before the # character.
    (Technically, whitespace is allowed to appear between the # and the error or the
    warning tokens, but good programming style dictates keeping them together.)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '这些语句必须单独出现在源代码行上；在 # 字符前面，除了空白字符（空格和制表符）外，不应出现其他内容。（从技术上讲，空白字符可以出现在 # 和错误或警告标记之间，但良好的编程风格建议将它们保持在一起。）'
- en: 'During assembly (or, more precisely, while CPP is processing the source file),
    the system should display a diagnostic message and print the line containing the
    #error or #warning statement, including all the arbitrary text up to the end of
    the line. By convention, most programmers surround the error or warning message
    (the arbitrary text) in quotes, but this isn’t absolutely necessary.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '在汇编过程中（或者更准确地说，在 CPP 处理源文件时），系统应该显示诊断消息，并打印包含 #error 或 #warning 语句的行，包括所有的
    arbitrary_text，直到行的末尾。按照惯例，大多数程序员会将错误或警告消息（arbitrary_text）括在引号中，但这并不是绝对必要的。'
- en: 'If CPP encounters any #error statements, it will terminate the assembly after
    CPP is done scanning the source file, without running the Gas assembler to assemble
    that file. In this case, you will need to modify the source file as necessary
    to eliminate the error message before Gas even gets a chance to process the file
    (and, for example, report on any errors in the assembly language source code).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 CPP 遇到任何 #error 语句，它将在 CPP 完成扫描源文件后终止汇编过程，而不会运行 Gas 汇编器来汇编该文件。在这种情况下，你需要在
    Gas 处理文件之前修改源文件，以消除错误消息（例如，报告汇编语言源代码中的任何错误）。'
- en: 'If the CPP encounters any #warning statements, it will print the appropriate
    message during assembly but will allow assembly to proceed after the CPP is done
    preprocessing the source file. Hence, you can use the #warning statement to display
    arbitrary text during the assembly and preprocessing process.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 CPP 遇到任何 #warning 语句，它会在汇编过程中打印相应的消息，但会在 CPP 完成预处理源文件后继续汇编。因此，你可以使用 #warning
    语句在汇编和预处理过程中显示 arbitrary_text。'
- en: 13.2.2 Compile-Time Constant Definition with CPP
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2 使用 CPP 定义编译时常量
- en: 'You can use the CPP #define statement to create constant definitions in your
    source file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以使用 CPP 的 #define 语句在源文件中创建常量定义：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When CPP processes the source file, it will replace any following occurrences
    of identifier by arbitrary_text. Programmers commonly use this statement, for
    example, to define manifest (named) constants in their source file, as in the
    following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CPP 处理源文件时，它会将随后的标识符替换为 arbitrary_text。程序员通常使用此语句，例如在源文件中定义显式（命名）常量，如下例所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In an assembly language program, you would normally use the .equ, .set, or
    = directives to define named constants, as in the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言程序中，你通常会使用 .equ、.set 或 = 指令来定义命名常量，如下例所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, various bugs in Gas might not allow you to use these constants the
    way you like. Consider the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Gas 中的各种错误可能会导致你无法像预期那样使用这些常量。考虑以下情况：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you try to assemble this, Gas will complain that 3.14159 is not a valid constant
    and that pi is not a valid floating-point constant. (The Clang assembler under
    macOS will accept pi = 3.14159 but will still complain that pi is not a valid
    floating-point constant.) However, if you replace this with
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试汇编这个，Gas 会抱怨 3.14159 不是一个有效的常量，pi 也不是一个有效的浮点常量。（在 macOS 下的 Clang 汇编器会接受
    pi = 3.14159，但仍然会抱怨 pi 不是一个有效的浮点常量。）但是，如果你将其替换为
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: then Gas will assemble the code just fine because CPP will preprocess the source
    file and replace each occurrence of pi with 3.14159. Therefore, when Gas actually
    sees the source file, it will find
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Gas 会正常汇编代码，因为 CPP 会预处理源文件并将每个出现的 pi 替换为 3.14159。因此，当 Gas 实际看到源文件时，它会发现
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'which is perfectly acceptable. This is a good example of why it helps to use
    CPP in your Gas source files: it provides you with capabilities, such as real
    constant definitions, that you wouldn’t normally have with Gas alone.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全可以接受的。这是一个很好的例子，说明为什么在 Gas 源文件中使用 CPP 会有帮助：它为你提供了一些能力，比如真实常量定义，这些是仅用 Gas
    无法实现的。
- en: 'Because CPP does a textual replacement of the defined identifier wherever it
    finds that identifier (outside of a string or character constant), you’re not
    limited to using #define for numeric constants. You can supply character constants,
    string constants, or even arbitrary text (including nothing) after the #define:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '因为 CPP 会在每次找到该标识符（在字符串或字符常量外部）时进行文本替换，所以你不仅限于使用 #define 来定义数字常量。你可以在 #define
    后面定义字符常量、字符串常量，甚至任意文本（包括什么都不定义）：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You could even do something like the following if you really prefer the xor
    mnemonic over the eor mnemonic:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于使用 xor 助记符而不是 eor 助记符，你甚至可以像下面这样做：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although redefining instruction mnemonics like this is generally considered
    poor programming practice, ARM does it all over the place with its “instruction
    aliases.” If it’s good enough for the ARM, there is no reason you can’t do it
    if it makes your code more readable to you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像这样重新定义指令助记符通常被认为是糟糕的编程实践，但 ARM 在其“指令别名”中到处都这么做。如果 ARM 这么做没问题，那么如果它能让你的代码对你来说更易读，也没有理由你不能这么做。
- en: 'Another important use of the #define statement is to create symbols that the
    CPP can recognize. The CPP is blissfully unaware of all identifiers appearing
    in your source file, except those you create with the #define statement. As you’ll
    see starting in the next section, you’ll sometimes want to use various expressions
    in a CPP CTL statement involving named constants. Those named constants must be
    defined with the #define statement, not one of Gas’s equate directives.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#define 语句的另一个重要用途是创建 CPP 可以识别的符号。CPP 对源文件中出现的所有标识符毫无察觉，除了你用 #define 语句创建的那些标识符。正如你将在下一节中看到的那样，你有时会希望在
    CPP CTL 语句中使用涉及命名常量的各种表达式。这些命名常量必须通过 #define 语句来定义，而不是 Gas 的 equate 指令之一。'
- en: 13.2.3 CPP Compile-Time Expressions
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3 CPP 编译时表达式
- en: 'Certain CPP statements allow simple arithmetic expressions involving constants.
    The arithmetic operators are the usual C arithmetic operators, including these:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 CPP 语句允许涉及常量的简单算术表达式。算术运算符是常见的 C 算术运算符，包括以下这些：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that CPP supports only (signed) 64-bit integer and character expressions
    and will report an error if you attempt to use floating-point or string constants.
    You can use a named constant in a CPP CTL expression as long as you’ve previously
    declared that name with a #define statement.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，CPP 仅支持（有符号的）64位整数和字符表达式，如果你尝试使用浮点或字符串常量，它会报告错误。只要你之前用 #define 语句声明了该名称，就可以在
    CPP CTL 表达式中使用命名常量。'
- en: 'You can use the following CPP built-in function in CPP CTL expressions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 CPP CTL 表达式中使用以下 CPP 内建函数：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This function returns 1 if the identifier was previously defined in a #define
    statement; it returns 0 if no such definition exists (note that you can also use
    the GCC -D identifier=value command line option to define symbols). The defined()
    function recognizes only symbols defined in a #define statement, a good example
    of the “important use” mentioned in the preceding section. If you pass a normal
    Gas assembly language identifier here, the function will return 0 even if the
    definition occurred earlier in the source file.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '这个函数如果标识符之前在 #define 语句中定义过，会返回 1；如果没有此类定义，则返回 0（注意，你也可以使用 GCC 的 -D identifier=value
    命令行选项来定义符号）。defined() 函数只识别在 #define 语句中定义的符号，这是前一节中提到的“重要用途”的一个好例子。如果你在这里传递一个普通的
    Gas 汇编语言标识符，即使该定义在源文件的早期出现，函数也会返回 0。'
- en: 13.2.4 Conditional Assembly
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.4 条件汇编
- en: 'The CPP provides several statements that allow you to make decisions when processing
    the source file. Here are those directives:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CPP 提供了几个语句，允许你在处理源文件时做出决策。以下是这些指令：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'During preprocessing, CPP will evaluate expression. If it yields a nonzero
    value (true), the #if or #elif (else if) statements will process the text up to
    the next #elif, #else, or #endif statement.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '在预处理期间，CPP 将评估表达式。如果它的值为非零（即 true），则 #if 或 #elif（else if）语句将处理文本，直到下一个 #elif、#else
    或 #endif 语句。'
- en: 'If expression evaluates to false, CPP will skip over the following text (up
    to the next #elif, #else, or #endif statement) and will not write that text to
    the temporary output file. Therefore, Gas will not assemble that text during the
    assembly phase.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '如果表达式的结果为 false，CPP 将跳过接下来的文本（直到下一个 #elif、#else 或 #endif 语句），并且不会将该文本写入临时输出文件。因此，Gas
    在汇编阶段不会汇编该文本。'
- en: Remember that this conditional processing happens during preprocessing (assembly),
    not at runtime. This is not a generic if/then/elseif/else/endif statement you’d
    find in an HLL. The conditional compilation statements control whether the instructions
    will actually appear in the final object code, activity that should be familiar
    to anyone who has used conditional compilation in an HLL such as C/C++.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种条件处理发生在预处理阶段（汇编），而不是在运行时。这不是你在高级语言（HLL）中找到的通用 if/then/elseif/else/endif
    语句。条件编译语句控制是否将指令实际出现在最终的目标代码中，这对于那些使用过 C/C++ 等高级语言进行条件编译的人来说应该很熟悉。
- en: 'The #ifdef statement is equivalent to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#ifdef 语句等效于以下内容：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The CPP checks the identifier to see whether it was previously defined with
    a #define statement (or the -D command line option). If so, CPP processes the
    text after the #if (or #ifdef) and up to the #endif (or up to an #elif or #else
    statement, if present).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'CPP 检查标识符是否之前已经通过 #define 语句（或 -D 命令行选项）定义。如果是，CPP 将处理 #if（或 #ifdef）后面的文本，直到
    #endif（或直到遇到 #elif 或 #else 语句，如果存在的话）。'
- en: 'The #ifndef (if not defined) statement is equivalent to this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#ifndef（如果未定义）语句等效于此：'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The #ifdef and #ifndef statements are common in code that is written for different
    execution environments. Consider the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '#ifdef 和 #ifndef 语句在为不同执行环境编写的代码中很常见。考虑以下示例：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Prior to this point, if the following statement appeared, then the former code
    would compile the section for macOS:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，如果出现以下语句，则前面的代码将为 macOS 编译该部分：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Had this definition not appeared, the code would compile the Linux or Pi OS
    code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现此定义，代码将编译为 Linux 或 Pi OS 代码。
- en: Another common use of conditional assembly is to introduce debugging and testing
    code into your programs. As a typical debugging technique, many Gas programmers
    insert print statements at strategic points, enabling them to trace through their
    code and display important values at various checkpoints. A big problem with this
    technique, however, is that they must remove the debugging code prior to completing
    the project. Moreover, programmers often forget to remove some debugging statements,
    creating defects in the final program. Finally, after removing a debugging statement,
    these programmers often discover that they need that same statement to debug a
    different problem at a later time. Hence, they must constantly insert and remove
    the same statements over and over again.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的条件汇编用途是将调试和测试代码引入你的程序中。作为一种典型的调试技术，许多 Gas 程序员会在关键位置插入打印语句，使他们能够追踪代码并在各个检查点显示重要的值。然而，这种技术的一个大问题是，他们必须在项目完成之前移除调试代码。此外，程序员经常忘记移除一些调试语句，这会导致最终程序中的缺陷。最后，在移除调试语句后，这些程序员往往会发现他们需要这些语句来调试其他问题。因此，他们必须一遍又一遍地插入和移除相同的语句。
- en: 'Conditional assembly provides a solution to this problem. By defining a symbol
    (say, debug) to control debugging output in your program, you can activate or
    deactivate *all* debugging output by modifying a single line of source code, as
    the following code fragment demonstrates:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 条件汇编提供了该问题的解决方案。通过定义一个符号（比如 debug）来控制程序中的调试输出，你可以通过修改一行源代码来启用或禁用*所有*调试输出，正如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As long as you surround all debugging output statements with an #if statement
    like the one in the preceding code, you don’t have to worry about debugging output
    accidentally appearing in your final application. Commenting out the debug symbol
    definition will automatically disable all such output (or, better yet, just use
    the -D debug command line option to turn on output when you want it). Likewise,
    you can leave the debugging statements from your programs in your code even after
    they’ve served their immediate purpose, since conditional assembly makes them
    easy to deactivate. Later, if you decide you need to view this same debugging
    information during assembly, you can reactivate it by defining the debug symbol.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '只要你将所有调试输出语句用 #if 语句包围（如前面的代码所示），就不必担心调试输出会意外出现在最终应用程序中。注释掉调试符号定义将自动禁用所有此类输出（或者，更好的是，使用
    -D debug 命令行选项在需要时打开输出）。同样，即使调试语句已经完成它们的即时目的，你也可以将它们保留在代码中，因为条件汇编使它们容易停用。以后，如果你决定在汇编期间查看相同的调试信息，你可以通过定义调试符号重新启用它。'
- en: '#### 13.2.5 CPP Macros'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 13.2.5 CPP 宏'
- en: 'Previously, this chapter used the #define statement to define compile-time
    constants, a special case of a *macro definition*. This section describes CPP
    macro definitions and expansion in more depth, including a discussion of macro
    parameters, variable argument lists, and other CPP macro definition features.
    By using this information, you will be able to create and use CPP macros in your
    Gas assembly language source files.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '之前，本章使用 #define 语句定义了编译时常量，这是*宏定义*的一个特例。本节将更深入地描述 CPP 宏定义和展开，包括宏参数、可变参数列表和其他
    CPP 宏定义功能的讨论。通过使用这些信息，你将能够在 Gas 汇编语言源文件中创建并使用 CPP 宏。'
- en: 13.2.5.1 Functional Macros
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.1 函数宏
- en: 'A macro is a mechanism that CPP uses to replace an identifier with arbitrary
    text. When defining constants with #define, you’re telling CPP to replace every
    following occurrence of that identifier with the text, which happens to be the
    constant.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '宏是 CPP 用来将标识符替换为任意文本的机制。当使用 #define 定义常量时，你是在告诉 CPP 将后续每次出现该标识符的地方替换为相应的文本，也就是常量。'
- en: 'However, CPP provides a second type of macro, the *functional macro*, which
    behaves more like a (compile-time) function supporting an arbitrary number of
    arguments. The following example demonstrates a single-argument macro:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CPP 提供了第二种类型的宏，即*函数宏*，它更像是一个（编译时）函数，支持任意数量的参数。以下示例演示了一个单参数宏：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This last statement expands to
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句展开为
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'because the macro lcl expands to [fp, #varName]. The CPP calls these *functional
    macros* because their invocation resembles a function call in the C programming
    language.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '因为宏 lcl 展开为 [fp, #varName]。CPP 称这些为*函数宏*，因为它们的调用方式类似于 C 编程语言中的函数调用。'
- en: 13.2.5.2 CPP Macro Arguments
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.2 CPP 宏参数
- en: Functional macros support an arbitrary number of arguments. You can specify
    zero arguments thusly
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数宏支持任意数量的参数。你可以通过以下方式指定零个参数
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: where zeroArgs() will expand into the specified text.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 zeroArgs() 将展开为指定的文本。
- en: 'This is a difference between the following two macro declarations that manifests
    when you invoke them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以下两种宏声明之间的区别，在调用它们时会表现出来：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You invoke the first macro with noArgs and the second macro with zeroArgs().
    If the macro declaration has an empty set of parentheses, the macro invocation
    must also include the empty parentheses. You can use this declaration scheme to
    differentiate between constant declarations and macro declarations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你用 noArgs 调用第一个宏，用 zeroArgs() 调用第二个宏。如果宏声明有一个空的圆括号，宏调用也必须包含空的圆括号。你可以使用这种声明方式来区分常量声明和宏声明。
- en: 'You can also specify two or more arguments in a #define statement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以在 #define 语句中指定两个或更多参数：'
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is an example of a twoArgs() invocation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 twoArgs() 调用的示例：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When invoking twoArgs(), you must supply exactly two parameters, or Gas will
    report an error. In general, the number of arguments you supply in a macro invocation
    must exactly match the parameter list in the #define declaration.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '在调用 twoArgs() 时，必须提供恰好两个参数，否则 Gas 会报告错误。通常，宏调用中提供的参数数量必须与 #define 声明中的参数列表完全匹配。'
- en: 'When CPP is processing a macro invocation, it usually separates actual parameters
    by scanning for commas. It ignores commas appearing in string or character constants,
    or in expressions surrounded by parentheses or square brackets:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPP处理宏调用时，通常通过扫描逗号来分隔实际参数。它会忽略出现在字符串或字符常量中的逗号，或出现在由圆括号或方括号括起来的表达式中的逗号：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From CPP’s perspective, each of these macro invocations has a single argument.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从CPP的角度来看，这些宏调用中的每一个都只有一个参数。
- en: 13.2.5.3 Macro Argument Expansion Issues
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.3 宏参数展开问题
- en: 'As any experienced C programmer knows, you must be careful when specifying
    macro parameters to avoid unintended consequences during expansion, especially
    if they involve arithmetic expressions. Consider the following macro:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如任何有经验的C程序员所知道的，你在指定宏参数时必须小心，以避免在展开过程中产生意外结果，尤其是当它们涉及算术表达式时。考虑以下宏：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now consider the following macro invocation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下宏调用：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The expectation here is to reserve twice as much space as the reserve() macro
    would normally specify. However, consider the actual expansion of this macro:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的预期是保留的空间是reserve()宏通常指定的两倍。然而，考虑一下这个宏的实际展开：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Gas’s arithmetic rules specify that multiplication has a higher precedence
    than addition, so this expands to Size + 2 rather than (Size + 1) × 2, the desired
    expansion. C programmers work around this issue by always surrounding macro expansions
    (that expand to arithmetic expressions) with parentheses, and they always surround
    the macro parameters themselves with parentheses, as shown in the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Gas的算术规则指定乘法的优先级高于加法，因此这将展开为Size + 2，而不是(Size + 1) × 2，这是期望的展开。C程序员通过总是用括号将宏展开（展开为算术表达式）括起来，并且他们总是将宏参数本身用括号括起来，从而绕过这个问题，如下例所示：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This usually resolves the issue of a macro expansion in the middle of an arithmetic
    expression.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常解决了算术表达式中间宏展开的问题。
- en: 'For the same reason, it’s generally a good idea to enclose any expression you
    pass as a macro argument in parentheses:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，通常建议将你传递作为宏参数的任何表达式用括号括起来：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because the expansion could produce unintended consequences based on operator
    precedence (for example, suppose the reserve definition were amt * 2, which would
    expand to Size + 5 * 2 if you didn’t surround the actual parameter expression
    with parentheses).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为展开可能会根据运算符优先级产生意外的结果（例如，假设reserve定义为amt * 2，如果你没有用括号将实际参数表达式括起来，它将展开为Size
    + 5 * 2）。
- en: 13.2.5.4 Variable Argument Lists
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.4 可变参数列表
- en: 'CPP provides a mechanism for specifying a variable number of parameters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CPP提供了一种指定可变数量参数的机制：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To reference the arguments, use the predefined __VA_ARGS__ symbol (which begins
    and ends with two underscores). The CPP will substitute the entire set of arguments
    in place of __VA_ARGS__. *This includes all the commas appearing in the varying
    argument list*. Consider the following macro definition and invocation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用参数，请使用预定义的__VA_ARGS__符号（它以两个下划线开始和结束）。CPP会将整个参数集替换为__VA_ARGS__。*这包括可变参数列表中所有出现的逗号*。考虑以下宏定义和调用：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The .byte statement expands to the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: .byte语句展开为以下内容：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A varying argument list allows zero actual parameters, so the invocation bytes()
    is perfectly legal (and will expand to the empty string, given the previous definition).
    Therefore
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数列表允许零个实际参数，因此调用bytes()是完全合法的（并且根据之前的定义，它会展开为空字符串）。因此
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: will expand to
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将展开为
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: which, interestingly enough, will not produce an error (Gas does not generate
    any code for this statement).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这不会产生错误（Gas不会为此语句生成任何代码）。
- en: Although the expansion of the entire argument list is sometimes useful, you’ll
    much more often need to pick off individual arguments in the varying argument
    list, as discussed in the following two sections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管整个参数列表的展开有时很有用，但你更常见的需求是从可变参数列表中提取单个参数，正如接下来的两节所讨论的那样。
- en: 13.2.5.5 Macro Composition and Recursive Macros
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.5 宏组合和递归宏
- en: CPP does not support recursive macro invocations. If a macro’s name appears
    in the expansion text, CPP will simply emit that name as text to be assembled
    by Gas. This is unfortunate because recursion would be very useful for handling
    iteration, as CPP doesn’t provide any looping constructs. In section 13.2.5.9,
    “Iteration with Macros,” on [page 757](chapter13.xhtml#pg_757), I’ll provide a
    workaround; in the meantime, I will discuss how CPP handles macro expansion when
    one macro invokes another.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CPP不支持递归宏调用。如果宏的名称出现在展开文本中，CPP将简单地将该名称作为文本输出，以便由Gas汇编。这是遗憾的，因为递归在处理迭代时非常有用，而CPP并不提供任何循环结构。在第13.2.5.9节“使用宏进行迭代”中，我将在[第757页](chapter13.xhtml#pg_757)提供一个解决方法；与此同时，我将讨论CPP如何处理宏展开，当一个宏调用另一个宏时。
- en: 'Consider the following macro definitions and invocations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下宏定义和调用：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When CPP encounters a macro invocation within the parameter list of another
    macro invocation, it will expand the parameter before passing that text on to
    the enclosing macro invocation. The expansion of the .byte statement happens in
    two steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPP遇到另一个宏调用的参数列表中的宏调用时，它将在将该文本传递给外层宏调用之前，先展开该参数。`.byte`语句的展开发生在两个步骤中：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: and then
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'which, of course, is equal to:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然等于：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now consider the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下示例：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When CPP encounters the macro invocation at the end of this example, it will
    expand callingMacro(5) to the following text:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPP遇到此示例末尾的宏调用时，它会将callingMacro(5)展开为以下文本：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'CPP will then expand this macro to the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后CPP将展开此宏为以下内容：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As long as CPP continues to find a macro invocation in the expanded text (except
    for a recursive invocation), it will continue to expand those invocations, regardless
    of how many iterations this process requires.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只要CPP继续在展开文本中找到宏调用（除非是递归调用），它将继续展开这些调用，无论该过程需要多少次迭代。
- en: NOTE
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* #define calledMacro(x) mov w0, x *macro should really be* #define calledMacro(x)
    mov w0, #x *using the syntax presented thus far in this book. However, the* #
    *is a CPP operator (stringify, described a little later) that will turn the actual
    parameter* 5 *into the string* "5"*. Fortunately, Gas accepts a plain constant
    in place of* #constant *for the immediate addressing mode in this example.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*该* #define calledMacro(x) mov w0, x *宏应该真正是* #define calledMacro(x) mov w0,
    #x *，使用本书中迄今为止介绍的语法。然而，*#* 是一个CPP操作符（字符串化，稍后会描述），它将实际参数*5*转换为字符串*“5”*。幸运的是，Gas在这个例子中接受一个普通常量来代替*#constant*，用于立即寻址模式。*'
- en: 13.2.5.6 Macro Definition Limitations
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.6 宏定义的限制
- en: The syntax for a CPP macro is the following
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: CPP宏的语法如下：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: where (parameters) is optional and \n represents a newline character. CPP does
    not allow any newline characters within text to expand. Therefore, a macro can
    expand only to a single line of text.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其中（参数）是可选的，\n表示换行符。CPP不允许在展开的文本中包含任何换行符。因此，宏只能展开为一行文本。
- en: CPP does allow macro definitions like the following
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: CPP确实允许如下所示的宏定义：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: which spreads a macro definition across *n* lines in the source file. Each line,
    except the last, must be terminated with a backslash character (\) immediately
    followed by a newline character.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把宏定义分布到源文件中的*n*行中。除了最后一行外，每一行必须以反斜杠字符（\）结束，并紧接着一个换行符。
- en: 'Although this macro is physically split across multiple source lines, it is
    still a single line of text because the CPP will delete all the newline characters
    following the backslash characters. Therefore, you cannot create a macro like
    the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个宏在物理上跨越了多行源代码，但它仍然是单行文本，因为CPP会删除所有反斜杠后面的换行符。因此，你不能创建如下的宏：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This macro definition won’t work because CPP will expand all the assembly language
    statements on a single line (with spaces between them), generating a syntax error.
    Sadly, Gas doesn’t seem to provide a general mechanism for supplying multiple
    assembly statements on the same line. Therefore, you cannot use CPP macros that
    expand to multiple assembly language statements. (Fortunately, Gas macros do allow
    this, as you’ll learn in section 13.3.4, “Gas Macros,” on [page 765](chapter13.xhtml#pg_765).)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏定义无法工作，因为CPP将把所有汇编语言语句展开成一行（它们之间用空格隔开），从而产生语法错误。遗憾的是，Gas似乎没有提供一种通用机制来在同一行上提供多个汇编语句。因此，你不能使用展开为多个汇编语言语句的CPP宏。（幸运的是，Gas宏允许这样做，你将在第13.3.4节“Gas宏”中了解，位于[第765页](chapter13.xhtml#pg_765)）。
- en: NOTE
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*On some CPUs, Gas allows the use of the semicolon (*;*) character to put multiple
    statements on the same line. However, the ARM treats semicolons as line comment
    characters; one semicolon is equivalent to two forward slashes (*//*). Your mileage
    may vary with Gas; for example, under Pi OS you can use the semicolon as a statement
    separator.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*在某些 CPU 上，Gas 允许使用分号 (*;*) 字符将多个语句放在同一行。然而，ARM 将分号视为行注释字符；一个分号等价于两个正斜杠 (*//*)。在
    Gas 中的表现可能会有所不同；例如，在 Pi OS 下，你可以使用分号作为语句分隔符。*'
- en: 'CPP’s single-line macro definitions have another serious drawback: you cannot
    incorporate CPP’s conditional compilation statements (such as #if) into a macro,
    since the conditional compilation statements must appear at the beginning of a
    source line. This is unfortunate, as the ability to make decisions in a macro
    would be useful. Fortunately, there are a couple of workarounds.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'CPP 的单行宏定义有另一个严重的缺陷：你不能将 CPP 的条件编译语句（例如 #if）嵌入到宏中，因为条件编译语句必须出现在源代码行的开头。这很不幸，因为在宏中做决策的能力是非常有用的。幸运的是，仍然有几个解决方法。'
- en: 'First, you can put macro definitions within conditional compilation sequences,
    as shown in the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以将宏定义放在条件编译序列中，如下例所示：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This sequence has two macros, only one of which will be defined within a given
    assembly. You can therefore put the (presumably) macOS-only code in the first
    macro definition and the Linux code in the second definition.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列有两个宏，其中只有一个宏会在给定的汇编中被定义。因此，你可以将（推测是）仅限 macOS 的代码放入第一个宏定义中，将 Linux 代码放入第二个宏定义中。
- en: Using two separate macro definitions like this will work in some, but not all,
    instances; sometimes you really do need the ability to put conditional text within
    a macro expansion. I’ll provide a second workaround to address this need in section
    13.2.5.8, “Conditional Macros,” on [page 756](chapter13.xhtml#pg_756).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个单独的宏定义在某些情况下是有效的，但并不是所有情况下都行得通；有时你确实需要在宏展开中插入条件文本。我将在第 13.2.5.8 节“条件宏”中提供第二个解决方法，以解决这个问题，详见[第
    756 页](chapter13.xhtml#pg_756)。
- en: 13.2.5.7 Text Concatenation and the Stringify Operator
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.7 文本连接和字符串化操作符
- en: 'CPP provides two special operators for manipulating textual data: the concatenation
    operator and the stringify operator. This section describes those two operators.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: CPP 提供了两个用于操作文本数据的特殊操作符：连接操作符和字符串化操作符。本节将介绍这两个操作符。
- en: 'A *token* is an entity, such as an identifier or operator, recognized by the
    C/C++ language. The CPP *concatenation operator* (##) combines two tokens in a
    macro, forming a single token. For example, within a macro body, the following
    text produces the single token identifier:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*标记*是 C/C++ 语言识别的实体，例如标识符或操作符。CPP *连接操作符* (##) 将两个标记组合成一个宏，形成一个单一的标记。例如，在宏体内，以下文本会生成单一的标识符标记：'
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Any amount of whitespace may appear between the tokens and the ## operator.
    CPP will remove all the whitespace and join the two tokens together—as long as
    the result is a legal C/C++ token. If a macro parameter identifier appears on
    either side of the ## operator, CPP will expand that parameter to the actual parameter’s
    text before doing the concatenation. Alas, if you pass another macro as the parameter,
    CPP does not properly expand the parameter:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '标记和 ## 操作符之间可以有任意数量的空白字符。CPP 会删除所有空白字符，并将两个标记连接在一起——只要结果是一个合法的 C/C++ 标记。如果宏参数标识符出现在
    ## 操作符的任一侧，CPP 会在进行连接之前展开该参数为实际参数的文本。可惜的是，如果你将另一个宏作为参数传递，CPP 不会正确地展开该参数：'
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As a sneaky workaround to this problem, you can create a concatenation macro
    to create the identifier for later expansion:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个巧妙的解决方法，你可以创建一个连接宏来为后续展开创建标识符：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will generate the statement
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成语句
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'which then expands to this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会展开为：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Section 13.8, “For More Information,” on [page 792](chapter13.xhtml#pg_792)
    includes links to sites that describe CPP’s text concatenation operator more fully.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13.8 节“更多信息”在[第 792 页](chapter13.xhtml#pg_792)包含了描述 CPP 文本连接操作符的更多网站链接。
- en: NOTE
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The concatenation operator is legal only within a CPP macro. The CPP will
    ignore* ## *everywhere else in the source file, leaving it up to Gas to handle
    it (which generally produces an error, as* ## *is not a legal token in ARM assembly
    language).*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接操作符仅在 CPP 宏中合法。CPP 会忽略* ## *在源文件中的其他地方，由 Gas 来处理它（这通常会产生错误，因为* ## *在 ARM
    汇编语言中不是一个合法的标记）。*'
- en: The second CPP operator is the *stringify operator* (#), which you can use within
    a macro body as follows
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 CPP 操作符是 *字符串化操作符*（#），你可以在宏体内按如下方式使用它
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'where parmID is the name of one of the macro parameters. The stringify operator
    will expand the parameter and convert it to a string by surrounding the text with
    quotes. This is why the earlier #define calledMacro(x) mov w0, #x macro did not
    work properly—it stringified the argument rather than leaving it as an integer
    constant.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '其中 parmID 是宏参数之一的名称。字符串化操作符将扩展该参数并将其转换为字符串，通过在文本周围加上引号。这就是为什么之前的 #define calledMacro(x)
    mov w0, #x 宏无法正常工作——它将参数字符串化了，而不是将其作为整数常量处理。'
- en: 13.2.5.8 Conditional Macros
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.8 条件宏
- en: 'Although you cannot include conditional compilation directives (#if, #else,
    and so on) inside macro bodies, it is possible to create conditional macros by
    pulling some tricks with the CPP (otherwise known as *abusing CPP*). Here’s an
    example of a conditional macro that implements an if ... then macro expansion
    you can use to select a particular expansion based on other definitions in your
    source code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不能在宏体内包含条件编译指令（#if、#else 等），但通过一些技巧，你可以使用 CPP 创建条件宏（这也被称为 *滥用 CPP*）。以下是一个条件宏的示例，它实现了一个
    if ... then 宏扩展，你可以根据源代码中的其他定义选择特定的扩展：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The (true expansion) and (false expansion) are compile-time expressions. The
    if_else macro will evaluate expression; if it evaluates to a nonzero value, this
    statement will be replaced by (true expansion). If expression evaluates to false,
    this statement will be replaced by (false expression). Here’s a simple example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: （真扩展）和（假扩展）是编译时表达式。if_else 宏将评估表达式；如果表达式评估为非零值，该语句将被（真扩展）替代。如果表达式评估为假，该语句将被（假扩展）替代。以下是一个简单示例：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If MacOS is nonzero, this produces the string "macOS"; otherwise, it produces
    the string "LinuxOS".
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MacOS 非零，这将产生字符串 "macOS"；否则，它将产生字符串 "LinuxOS"。
- en: 'The if_else macro is quite complex, and I won’t describe how it works here;
    it is C rather than assembly language, which puts it beyond the scope of this
    text. See section 13.8, “For More Information,” on [page 792](chapter13.xhtml#pg_792)
    for resources on this topic. Here’s the implementation of if_else from one of
    those resources, by Jonathan Heathcote:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: if_else 宏相当复杂，我不会在这里描述它是如何工作的；它是 C 语言而非汇编语言，因此超出了本书的范围。有关此主题的资源，请参见第 13.8 节，"更多信息"，见
    [第 792 页](chapter13.xhtml#pg_792)。以下是来自 Jonathan Heathcote 的其中一项资源中的 if_else 实现：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Unlike the conditional compilation directives, you can embed the if_else macro
    into the bodies of other macros. Consider the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与条件编译指令不同，你可以将 if_else 宏嵌入到其他宏的主体中。考虑以下代码：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Invoking this macro yields the string "macOS" or "Linux", depending on the compile-time
    value of the parameter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此宏将根据参数的编译时值产生字符串 "macOS" 或 "Linux"。
- en: 13.2.5.9 Iteration with Macros
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.9 使用宏进行迭代
- en: The __VA_ARGS__ feature in CPP is useful for passing a group of arguments as
    a single argument. However, it would be nicer if we could process each argument
    in a varying parameter list one at a time by iterating through the list in order.
    Unfortunately, the CPP doesn’t provide any statements to support iteration. Because
    CPP doesn’t support recursion, we can’t even (directly) use recursion to handle
    iteration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: CPP 中的 __VA_ARGS__ 特性对于将一组参数作为单个参数传递非常有用。然而，如果我们能够通过迭代列表中的参数逐个处理每个参数，而不是一次性处理所有参数，那就更好了。不幸的是，CPP
    并不提供支持迭代的语句。由于 CPP 不支持递归，我们甚至不能（直接）使用递归来处理迭代。
- en: However, if you abuse the CPP a bit, a limited form of recursion is possible,
    as this section demonstrates. The ultimate goal of this section is to create a
    macro, let’s call it map, that will execute a single-argument macro on each argument
    in a varying parameter list. Ideally, you’d call map thusly
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你稍微滥用 CPP，本节展示了一种有限形式的递归是可能的。本节的最终目标是创建一个宏，我们称之为 map，该宏将在变长参数列表中的每个参数上执行一个单参数宏。理想情况下，你会像这样调用
    map
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'and the map function would generate *n* calls to macroName:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 map 函数将生成 *n* 次对 macroName 的调用：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following set of macros, along with the if_else macro from the previous
    section, provides this functionality (also from Heathcote; see section 13.8, “For
    More Information,” on [page 792](chapter13.xhtml#pg_792) for implementation details):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这组宏以及上一节中的 if_else 宏提供了这一功能（同样来自 Heathcote；有关实现细节，请参见第 13.8 节，"更多信息"，见 [第
    792 页](chapter13.xhtml#pg_792)）：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The eval macro provides a limited amount of recursion on the macro you pass
    as an argument (up to 1,024 levels of recursion, which will allow for a varying
    parameter listing containing up to 1,024 entries). In order for the map macro
    to recurse, you must enclose it in an eval invocation. Consider the following
    example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: eval宏提供了对你作为参数传递的宏进行有限递归的功能（最多可递归1,024层，这允许列出最多1,024个条目的可变参数）。为了使map宏能够递归，必须将其封装在eval调用中。考虑以下示例：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The comma at the end of the inc macro is required because the invocations of
    inc will emit expressions of the form (1 + 1), (2 + 1), ..., (7 + 1) on the same
    line. The .byte directive requires commas between these expressions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: inc宏末尾的逗号是必要的，因为调用inc时将会在同一行输出形式为(1 + 1)，(2 + 1)，...，(7 + 1)的表达式。`.byte`指令要求这些表达式之间用逗号分隔。
- en: Also note that the value 9 appears after the eval invocation. This is because
    the last expression, (7 + 1), will have a comma after it, so this statement must
    supply the last value manually. It would be possible to modify the map macro to
    emit this comma for all but the last argument, or you could modify the inc macro
    to check for a special sentinel value (such as a negative number) to terminate
    the list (without emitting the value or the comma).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意，值9出现在eval调用之后。这是因为最后的表达式（7 + 1）后会有一个逗号，因此这个语句必须手动提供最后一个值。可以修改map宏使其对除了最后一个参数以外的所有参数都添加逗号，或者可以修改inc宏来检查特殊的哨兵值（例如负数），以便终止列表（而不输出值或逗号）。
- en: 13.2.5.10 Command Line Defines
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.10 命令行定义
- en: 'If you look back at the *build* shell script in section 1.10.1, “Assembling
    Programs Under Multiple OSes,” on [page 36](chapter1.xhtml#pg_36), you’ll see
    that GCC has a command line parameter that specifies the OS in use:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下第1.10.1节中*build* shell脚本的内容，标题为“在多个操作系统下组装程序”，并参考[第36页](chapter1.xhtml#pg_36)，你会看到GCC有一个命令行参数指定了正在使用的操作系统：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'These command line parameters are roughly equivalent to the following two statements:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令行参数大致等同于以下两个语句：
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In many instances, you can refer to these definitions in your source file exactly
    as though you had placed these #define statements at the beginning of the file.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可以像在文件开头放置这些#define语句一样，直接在源文件中引用这些定义。
- en: 'As noted, these parameters are *roughly* equivalent—not exactly equivalent—to
    the #define statements. Within macro bodies, these symbols might not be expanded
    as normal defined symbols would be. To use these symbols in macro bodies, it’s
    generally a good idea to explicitly create some #define symbols by using code
    such as the following, then refer to myIsLinux and myIsMacOS within your macros:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些参数是*大致*等同的——而非完全等同——于#define语句。在宏体内，这些符号可能不会像正常的定义符号那样展开。为了在宏体内使用这些符号，通常最好通过以下代码显式地创建一些#define符号，然后在宏中引用myIsLinux和myIsMacOS：
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you are compiling your Gas source files directly from the command line via
    gcc, you can define other symbols by using the -D command line option. See the
    GCC documentation for details. Note that the *build* script will not pass -D arguments
    to GCC, but you can easily modify *build* if you want to define other symbols.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是通过gcc直接从命令行编译Gas源文件，可以通过使用-D命令行选项来定义其他符号。有关详细信息，请参阅GCC文档。请注意，*build*脚本不会将-D参数传递给GCC，但你可以轻松修改*build*，如果你想定义其他符号的话。
- en: '13.2.5.11 The CPP #undef Statement'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.5.11 CPP中的#undef语句
- en: 'The CPP allows you to forget a defined symbol by using the #undef statement'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CPP允许你通过使用#undef语句忘记一个已定义的符号
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'where identifier is a symbol previously defined with a #define statement. (If
    the symbol is undefined upon #undef execution, CPP will simply ignore the statement.)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，identifier是之前用#define语句定义的符号。（如果在执行#undef时该符号未定义，CPP将简单地忽略该语句。）
- en: 'Undefining a symbol allows you to redefine it (for example, to give it another
    value). If you attempt to redefine a symbol without first undefining it, CPP will
    report an error.  ### 13.3 Components of the Gas CTL'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 取消符号定义可以让你重新定义它（例如，给它赋予另一个值）。如果在未先取消定义的情况下尝试重新定义符号，CPP将报告错误。### 13.3 Gas CTL的组成部分
- en: Gas’s CTL facilities are closer (than CPP) to what most assembly language programmers
    expect from a macro expansion system. Although CPP’s macro facilities are useful
    for certain purposes, macro assembly programming generally requires a much more
    powerful macro system. Therefore, learning Gas’s macro facilities is essential.
    This section covers the components of the Gas CTL.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 的控制设施比 CPP 更接近大多数汇编语言程序员对宏扩展系统的期望。尽管 CPP 的宏功能对于某些目的很有用，但宏汇编编程通常需要一个更强大的宏系统。因此，学习
    Gas 的宏功能是至关重要的。本节将介绍 Gas 控制设施的组成部分。
- en: 13.3.1 Errors and Warnings During Assembly
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1 汇编期间的错误和警告
- en: 'The Gas .err directive is similar to CPP #error. During assembly, Gas will
    display an error message (printing the source line containing the .err statement).
    Gas will not generate an object file if it encounters an .err directive. For example,
    the following generates an error message at runtime:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'Gas 的 .err 指令类似于 CPP 的 #error。汇编过程中，Gas 将显示一条错误消息（打印包含 .err 语句的源代码行）。如果 Gas
    遇到 .err 指令，它将不会生成目标文件。例如，以下代码将在运行时生成错误消息：'
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Gas also supports the .error directive. Its syntax is shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 还支持 .error 指令。其语法如下所示：
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The operand must be a string constant surrounded by quotes. During assembly,
    Gas will display the specified error message and will not generate an object file
    if it encounters an .error directive in the source file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数必须是一个用引号括起来的字符串常量。在汇编过程中，如果 Gas 遇到源文件中的 .error 指令，它将显示指定的错误消息，并且不会生成目标文件。
- en: 'Gas also supports a .warning directive similar to the CPP #warning statement,
    with the following syntax:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'Gas 还支持一个类似于 CPP #warning 语句的 .warning 指令，其语法如下：'
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Again, the operand must be a string constant surrounded by quotes. If Gas encounters
    the .warning directive during assembly, it will display the specified warning
    message. If no errors are in the source files, only warnings, Gas will generate
    an object file. You can therefore use the .warning directive as an assembly-time
    print statement.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，操作数必须是一个用引号括起来的字符串常量。如果 Gas 在汇编过程中遇到 .warning 指令，它将显示指定的警告消息。如果源文件中没有错误，仅有警告，Gas
    将生成一个目标文件。因此，你可以将 .warning 指令作为汇编时的打印语句。
- en: 'Keep in mind the difference between the CPP #warning and #error statements
    and the Gas .warning and .error directives: the CPP statements execute during
    the preprocessor pass, prior to the assembly process, while the Gas directives
    execute after the preprocessor pass, during assembly. If there are any #error
    statements that execute, CPP will terminate the assembly process without running
    the assembler (so the Gas directives won’t execute in that situation).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，CPP 的 #warning 和 #error 语句与 Gas 的 .warning 和 .error 指令之间的区别：CPP 语句在预处理阶段执行，即在汇编过程之前，而
    Gas 指令在预处理阶段之后、汇编过程中执行。如果执行了任何 #error 语句，CPP 会终止汇编过程，而不会运行汇编器（因此在这种情况下 Gas 指令不会执行）。'
- en: 13.3.2 Conditional Assembly
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2 条件汇编
- en: 'Gas also supports a set of conditional assembly (or conditional compilation)
    directives similar to CPP’s #if/#endif statements. The basic directives are as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'Gas 还支持一组类似于 CPP 的 #if/#endif 语句的条件汇编（或条件编译）指令。基本指令如下：'
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As a general rule, you should prefer Gas’s conditional assembly directives
    in your source file over the CPP conditional compilation statements. Only use
    CPP’s conditional compilation statements when conditionally processing source
    code that contains other CPP statements (such as #define statements), or testing
    whether a symbol has been defined in CPP with the #ifdef or #ifndef statement.
    You cannot test whether a CPP symbol has been defined by using Gas’s conditional
    assembly statements because all CPP symbols will be expanded (and won’t be present)
    when Gas is assembling the source file.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '一般来说，你应该优先在源文件中使用 Gas 的条件汇编指令，而不是 CPP 的条件编译语句。只有在处理包含其他 CPP 语句（如 #define 语句）的源代码时，或者在测试是否在
    CPP 中使用 #ifdef 或 #ifndef 语句定义了符号时，才使用 CPP 的条件编译语句。你不能通过使用 Gas 的条件汇编语句来测试 CPP 符号是否已定义，因为所有
    CPP 符号在 Gas 汇编源文件时都会被扩展（并且不存在）。'
- en: The Boolean expression appearing after .if or .elseif must be an absolute expression
    (see “Relocatable and Absolute Expressions” on [page 176](chapter4.xhtml#pg_176)).
    Within conditional assembly expressions, false is a zero result and true is anything
    else.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟 .if 或 .elseif 后的布尔表达式必须是一个绝对表达式（参见 [第176页](chapter4.xhtml#pg_176) 的“可重定位和绝对表达式”）。在条件汇编表达式中，false
    为零结果，true 为其他任何值。
- en: 'Gas supports several variants of the .if directive:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 支持 .if 指令的几个变体：
- en: '.ifdef symbol    Assembles the following section if symbol is defined prior
    to that point in the source file. CPP symbols (created with #define) are expanded
    prior to assembly, so their use may not work as expected in this directive.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '.ifdef symbol    如果 symbol 在源文件中该点之前已定义，则组装以下部分。CPP 符号（通过 #define 创建）在汇编之前被展开，因此在此指令中的使用可能无法按预期工作。'
- en: .ifb text    Assembles the following section if the operand field is blank.
    You generally use this directive to test for a blank macro parameter (text is
    typically a macro parameter name that could expand to the empty string).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: .ifb text    如果操作数字段为空白，则组装以下部分。通常使用此指令测试一个空白的宏参数（text 通常是一个宏参数名，可能展开为空字符串）。
- en: .ifc text1**,** text2    Compares text1 to text2 and assembles the following
    section if they are equal. The string comparison ignores any whitespace around
    the text. The string text1 comprises all characters from the first non-whitespace
    character after .ifc up to the first comma. The string text2 is all text after
    the comma (ignoring leading whitespace) up to the end of the line (also ignoring
    whitespace at the end of the line). If you need to include whitespace in the string,
    you may optionally surround the strings with apostrophes (single quotes). Generally,
    you would use this statement to compare two macro parameter expansions to see
    if the parameters are equal.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: .ifc text1**,** text2    比较 text1 和 text2，如果它们相等，则组装以下部分。字符串比较会忽略文本周围的任何空白字符。字符串
    text1 包括从 .ifc 后第一个非空白字符到第一个逗号之间的所有字符。字符串 text2 是逗号后（忽略前导空白）到行尾（也忽略行尾空白）之间的所有文本。如果需要在字符串中包含空白字符，可以选择用撇号（单引号）将字符串括起来。通常，你会使用此语句比较两个宏参数展开结果，以检查参数是否相等。
- en: .ifeq expression    Assembles the following code if expression is equal to 0.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: .ifeq 表达式    如果表达式等于 0，则组装以下代码。
- en: .ifeqs "string1"**,** "string2"    Assembles the following code if the two strings
    are equal. The strings must be surrounded by double quotes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: .ifeqs "string1"**,** "string2"    如果两个字符串相等，则组装以下代码。字符串必须用双引号括起来。
- en: .ifge expression    Assembles the following code if expression is greater than
    or equal to 0.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: .ifge 表达式    如果表达式大于或等于 0，则组装以下代码。
- en: .ifgt expression    Assembles the following code if expression is greater than
    0.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: .ifgt 表达式    如果表达式大于 0，则组装以下代码。
- en: .ifle expression    Assembles the following code if expression is less than
    or equal to 0.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: .ifle 表达式    如果表达式小于或等于 0，则组装以下代码。
- en: .iflt expression    Assembles the following code if expression is less than
    0.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: .iflt 表达式    如果表达式小于 0，则组装以下代码。
- en: .ifnb text    Assembles the following section if the operand field is not blank.
    You generally use this directive to test for a nonblank macro parameter (text
    is typically a macro parameter name).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: .ifnb text    如果操作数字段不为空白，则组装以下部分。通常使用此指令测试一个非空白的宏参数（text 通常是一个宏参数名）。
- en: .ifnc text1**,** text2    Compares text1 to text2 and assembles the following
    section if they are not equal. The string comparison ignores any whitespace around
    the text. The string text1 comprises all characters from the first non-whitespace
    character after .ifnc up to the first comma. The string text2 is all text after
    the comma (ignoring leading whitespace) up to the end of the line (also ignoring
    whitespace at the end of the line). If you need to include whitespace in the string,
    you may optionally surround the strings with apostrophes (single quotes). Generally,
    you would use this statement to compare two macro parameter expansions to see
    if the parameters are not equal.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: .ifnc text1**,** text2    比较 text1 和 text2，如果它们不相等，则组装以下部分。字符串比较会忽略文本周围的任何空白字符。字符串
    text1 包括从 .ifnc 后第一个非空白字符到第一个逗号之间的所有字符。字符串 text2 是逗号后（忽略前导空白）到行尾（也忽略行尾空白）之间的所有文本。如果需要在字符串中包含空白字符，可以选择用撇号（单引号）将字符串括起来。通常，你会使用此语句比较两个宏参数展开结果，以检查参数是否不相等。
- en: '.ifndef symbol**,** .ifnotdef symbol    Assembles the following section if
    symbol is not defined prior to that point in the source file. Note that CPP symbols
    (created with #define) get expanded prior to assembly, so their use may not work
    as expected in this directive. The .ifnotdef directive is a synonym for .ifndef.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '.ifndef symbol**,** .ifnotdef symbol    如果 symbol 在源文件中该点之前未定义，则组装以下部分。注意，CPP
    符号（通过 #define 创建）在汇编之前会展开，因此在此指令中的使用可能无法按预期工作。 .ifnotdef 指令是 .ifndef 的同义词。'
- en: .ifne expression    Assembles the following code if expression is not equal
    to 0\. This directive is a synonym for .if.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: .ifne expression    当表达式不等于 0 时，组装以下代码。这个指令是 .if 的同义词。
- en: .ifnes "string1"**,** "string2"    Assembles the following code if the two strings
    are not equal. The strings must be surrounded by double quotes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: .ifnes "string1"**,** "string2"    当两个字符串不相等时，组装以下代码。这两个字符串必须用双引号括起来。
- en: Conditional assembly statements in Gas may appear anywhere an instruction mnemonic
    is legal. Typically, they appear on a line by themselves, though it is legal (if
    unusual) for a label to appear on the same line. In that case, the label will
    be associated with the next instruction or directive that emits code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 中的条件汇编语句可以出现在任何指令助记符合法的地方。通常，它们会单独占一行，尽管在同一行上出现标签也是合法的（尽管不常见）。在这种情况下，标签将与发出代码的下一条指令或指令关联。
- en: As you can see, Gas provides a wide variety of conditional assembly statements
    that are quite a bit more powerful and flexible than the CPP conditional compilation
    statements. This is another reason to use Gas’s conditional assembly statements
    over CPP’s.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Gas 提供了多种条件汇编语句，它们比 CPP 的条件编译语句更强大、更灵活。这也是为什么选择使用 Gas 的条件汇编语句而非 CPP
    的另一个原因。
- en: '#### 13.3.3 Compile-Time Loops'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 13.3.3 编译时循环'
- en: 'Unlike CPP, Gas’s CTL provides three looping constructs to easily generate
    data and unroll loops: .rept, .irp, and .irpc. The following subsections describe
    these directives.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CPP 不同，Gas 的 CTL 提供了三种循环构造，用于轻松生成数据并展开循环：.rept、.irp 和 .irpc。以下小节将描述这些指令。
- en: 13.3.3.1 .rept....endr
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.3.1 .rept....endr
- en: 'The .rept directive repeats a block of statements a fixed number of times.
    The syntax for this compile-time loop is the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: .rept 指令会将一块语句重复指定次数。这个编译时循环的语法如下：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Gas will evaluate expression and repeat the block of statements between the
    .rept and .endr directives the specified number of times. If expression evaluates
    to 0, Gas will ignore all the statements up to the .endr, generating no code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 将评估表达式，并重复 .rept 和 .endr 指令之间的语句块，重复指定的次数。如果表达式的值为 0，Gas 将忽略所有语句，直到 .endr，不生成任何代码。
- en: 'The following example will initialize a 32-element byte array with the values
    0 through 31:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将初始化一个包含 32 个元素的字节数组，值从 0 到 31：
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You aren’t limited to data values in a .rept loop but can use .rept to unroll
    loops as well:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 .rept 循环中不仅限于数据值，还可以使用 .rept 来展开循环：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is equivalent to the following code
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下代码
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: which unrolls the loop eight times.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它会将循环展开八次。
- en: '##### 13.3.3.2 .irp....endr'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 13.3.3.2 .irp....endr'
- en: 'The .irp (indefinite repeat) looping directive takes the following form:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: .irp（不定次重复）循环指令采用以下形式：
- en: '[PRE71]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This loop repeats for each item in comma-separated-list-of-values. In the body
    of the loop, you can refer to the current value by using \identifier; the following
    example
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会对逗号分隔的值列表中的每一项重复。在循环体内，你可以通过使用 \identifier 来引用当前值；以下示例
- en: '[PRE72]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: is equivalent to
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于
- en: '[PRE73]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: which unrolls the loop for each .irp argument.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 它会为每个 .irp 参数展开循环。
- en: 13.3.3.3 .irpc....endr
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.3.3 .irpc....endr
- en: 'The third compile-time looping construct, .irpc, is similar to .irp but processes
    a string of text rather than a list of values:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个编译时循环构造 .irpc 类似于 .irp，但它处理的是文本字符串，而不是值列表：
- en: '[PRE74]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, identifier is a symbol that will take on the value of each character in
    the string specified by text. Note that text is a bare sequence of characters;
    do not surround it by double or single quotes unless you want the .irpc loop to
    process those punctuation marks along with the other characters in the string.
    The .irpc loop will execute once for each character in the string, and \identifier
    will expand to that character on each iteration. For example
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，identifier 是一个符号，它将获取指定文本字符串中每个字符的值。注意，text 是一个裸序列的字符；除非你希望 .irpc 循环将这些标点符号与字符串中的其他字符一起处理，否则不要用双引号或单引号括起来。该
    .irpc 循环将对字符串中的每个字符执行一次，\identifier 会在每次迭代时扩展为该字符。例如
- en: '[PRE75]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'expands to this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展为如下内容：
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that \identifier expands even within character and string constants (as
    '\x' did in this example). In this example, had you not enclosed \x in single
    quotes, the .irpc loop would have expanded to
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，\identifier 即使在字符和字符串常量中也会展开（就像本例中的 '\x'）。在这个例子中，如果你没有把 \x 用单引号括起来，.irpc
    循环会展开成
- en: '[PRE77]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: which would have generated an error if the symbols a, c, d, and e were not defined
    somewhere in the program (I conveniently skipped b, which would have expanded
    to a branch instruction mnemonic).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序中没有定义符号 a、c、d 和 e，那么就会产生错误（我故意省略了 b，它本应展开为一个分支指令助记符）。
- en: 13.3.4 Gas Macros
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.4 Gas 宏
- en: Gas provides macro facilities via the .macro and .endm directives. The syntax
    for a macro definition is as follows
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 通过 .macro 和 .endm 指令提供宏功能。宏定义的语法如下
- en: '[PRE78]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: where the {and} characters mean the parameter list is optional (you don’t include
    these characters in the macro definition). The following subsections describe
    the various components of a Gas macro, along with important semantic information
    concerning macros.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 {and} 字符表示参数列表是可选的（你在宏定义中不需要包含这些字符）。以下小节描述了 Gas 宏的各种组成部分，以及与宏相关的重要语义信息。
- en: 13.3.4.1 Macro Parameters
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.4.1 宏参数
- en: 'Macro parameters can take one of the following four forms:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 宏参数可以采用以下四种形式之一：
- en: identifier    This first form, just a simple identifier, is the most common.
    Unless you supply one of the suffixes appearing in the other three options, this
    syntax tells Gas that the parameter is optional. If you do not supply an appropriate
    actual parameter value when invoking the macro, Gas will substitute the empty
    string (a blank parameter) when expanding the parameter in the macro’s body.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: identifier    这种第一种形式，仅仅是一个简单的标识符，是最常见的。除非你提供其他三种选项中出现的后缀，否则这种语法告诉 Gas 参数是可选的。如果你在调用宏时没有提供适当的实际参数值，Gas
    在宏体中展开参数时会用空字符串（一个空的参数）代替。
- en: identifier=expression    Like the first form, this specifies a parameter that
    can be optional, except that Gas will give the identifier the value of the expression
    rather than an empty string if the macro invocation doesn’t supply a parameter
    value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: identifier=expression    与第一种形式类似，这指定了一个可以是可选的参数，只不过如果宏调用时没有提供参数值，Gas 会将标识符赋值为表达式的值，而不是空字符串。
- en: identifier:req    Specifies that the macro argument must be supplied when invoking
    the macro; if it is missing, Gas will respond with an error message.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: identifier:req    指定在调用宏时必须提供宏参数；如果缺失，Gas 会返回错误信息。
- en: identifier:vararg    Allows for a varying parameter list (zero or more arguments
    separated by commas). Gas will expand this macro parameter to the entire list
    of values, including the commas separating the values.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: identifier:vararg    允许使用一个可变参数列表（零个或多个由逗号分隔的参数）。Gas 会将这个宏参数展开为整个值列表，包括分隔这些值的逗号。
- en: In standard Gas syntax, a space separates the macro name and the first parameter
    (if any). I’ve found that with the ARM assembler, sneaking in a comma works fine
    too (your mileage may vary).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 Gas 语法中，宏名称和第一个参数（如果有的话）之间用空格分隔。我发现，在 ARM 汇编器中，偷偷加个逗号也能正常工作（你的实际情况可能有所不同）。
- en: 'Within a macro body, use a token of the form \identifier—where identifier is
    one of the macro’s declared formal parameters—to expand a parameter. For example,
    the following macro demonstrates the expansion of the value argument:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏体内，使用形如 \identifier 的标记——其中 identifier 是宏声明的正式参数之一——来展开一个参数。例如，以下宏演示了值参数的展开：
- en: '[PRE79]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'A macro definition can have zero or more parameters. If you supply more than
    one parameter, you must separate each formal parameter with a comma. Additionally,
    if you specify a vararg parameter, it must be the last parameter declared in the
    .macro statement. Here’s an example of a slightly complex macro:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个宏定义可以有零个或多个参数。如果你提供多个参数，必须用逗号分隔每个正式参数。此外，如果你指定了 vararg 参数，它必须是 .macro 语句中声明的最后一个参数。下面是一个稍复杂的宏示例：
- en: '[PRE80]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When you invoke this macro, you must supply at least one actual parameter (because
    yy is a required parameter). For example
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用这个宏时，必须至少提供一个实际参数（因为 yy 是一个必需的参数）。例如
- en: '[PRE81]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'expands to this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 展开为：
- en: '[PRE82]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note that if a data directive such as .byte does not have any operands, Gas
    will ignore that statement and not generate any code to the object file.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果像 .byte 这样的数据指令没有操作数，Gas 会忽略该语句，并且不会向目标文件生成任何代码。
- en: Here’s another invocation of bytes that demonstrates full argument expansion
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 bytes 的另一个调用，演示了完整的参数展开。
- en: '[PRE83]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'which expands to:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 其展开为：
- en: '[PRE84]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This example worked out well because the .byte directive allows comma-separated
    operands. However, what if you want to expand a vararg parameter where comma-separated
    operands are not legal? Consider the following macro:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子运行得很顺利，因为 .byte 指令允许逗号分隔的操作数。然而，如果你想扩展一个不可逗号分隔的可变参数怎么办？请考虑以下宏：
- en: '[PRE85]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: An invocation of addVals such as
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `addVals` 这样的调用例如
- en: '[PRE86]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: will generate an error because
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 会生成一个错误，因为
- en: '[PRE87]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'is syntactically incorrect. You can solve this problem by using an .irp loop
    inside the macro to process a vararg parameter:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是语法错误。你可以通过在宏内部使用 .irp 循环来处理一个可变参数，来解决这个问题：
- en: '[PRE88]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The addVals 1, 2 invocation will now emit the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`addVals 1, 2` 的调用现在会生成以下内容：'
- en: '[PRE89]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Gas will expand a macro just about anywhere it appears within a macro body.
    Consider the following macro:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 会在宏体中的任何地方扩展宏。请考虑以下宏：
- en: '[PRE90]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Assuming you’ve defined the var0 and var1 symbols somewhere, the invocation
    select 0 generates the following
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在某个地方定义了 `var0` 和 `var1` 符号，调用 `select 0` 会生成如下内容
- en: '[PRE91]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'while the invocation select 1 generates this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 而调用 `select 1` 会生成如下内容：
- en: '[PRE92]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Suppose you want to supply the prefix of the name, rather than the suffix,
    as the macro argument in this example. A first attempt at this won’t work:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望提供名称的前缀，而不是后缀，作为这个例子中的宏参数。第一次尝试将不起作用：
- en: '[PRE93]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The problem, of course, is that Gas interprets \whichvar as the expansion of
    a parameter named whichvar. To separate a parameter name from the following text,
    use the \() token:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 问题当然在于，Gas 会将 `\whichvar` 解释为名为 whichvar 的参数的展开。要将参数名与后面的文本分开，请使用 `\()` 符号：
- en: '[PRE94]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: An invocation such as select2 my will now properly expand to
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像 `select2 my` 这样的调用会正确扩展为
- en: '[PRE95]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: which creates the name myvar, as intended.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建预期中的名称 `myvar`。
- en: 13.3.4.2 Macro Parameters with String Constants
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.4.2 宏参数与字符串常量
- en: 'Gas’s macros have a “feature” that can bite you if you’re not careful: if you
    pass a string constant as a formal parameter, Gas will strip the quotes from the
    string when expanding that parameter. For example, consider the following macro
    and invocation:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 的宏有一个“特性”，如果你不小心可能会被它咬：如果你将字符串常量作为正式参数传递，Gas 会在扩展该参数时去掉字符串的引号。例如，请考虑以下宏和调用：
- en: '[PRE96]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This expands to the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这会扩展为以下内容：
- en: '[PRE97]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Unless you’ve defined the symbol hello with an appropriate value, this will
    generate an error. The correct way to do this is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你已经定义了符号 hello 并赋予了适当的值，否则这将生成一个错误。正确的做法如下：
- en: '[PRE98]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This code properly generates the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正确生成了以下内容：
- en: '[PRE99]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: One possible use for this is passing parameters that contain commas and whitespace
    as a single argument to a macro. I will leave it up to you to figure out other
    abuses of this “feature” in Gas. Personally, I consider it a bug, and I’d be afraid
    to use this feature because Gas could remove this behavior in a future version
    of the assembler.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种可能的用途是将包含逗号和空格的参数作为单个参数传递给宏。我将留给你自己去发掘 Gas 中这种“特性”的其他滥用情况。就我个人而言，我认为它是一个
    bug，我不敢使用这个功能，因为 Gas 可能会在未来的汇编器版本中移除此行为。
- en: 13.3.4.3 Recursive Macros
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.4.3 递归宏
- en: 'Unlike CPP, Gas fully supports recursive macros. Consider the following example
    (adapted from the Gas manual):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CPP 不同，Gas 完全支持递归宏。请考虑以下示例（摘自 Gas 手册）：
- en: '[PRE100]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A macro invocation of the form sum 0, 5 generates the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 `sum 0, 5` 的宏调用会生成以下代码：
- en: '[PRE101]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The sum macro uses conditional assembly statements to prevent endless recursion.
    Though you could more easily iterate over five values by using the .rept (or .irp)
    directives, sometimes recursion is a better solution than iteration.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: sum 宏使用条件汇编语句来防止无限递归。虽然你可以通过使用 .rept（或 .irp）指令更容易地遍历五个值，但有时递归比迭代更适合解决问题。
- en: The .irp and .rept directives are a better fit for simple iteration. Recursion
    is better for processing recursive data structures, such as lists and trees, passed
    as macro arguments, or if you need to reverse the arguments passed to a macro
    (I give an example of this in the next section).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: .irp 和 .rept 指令更适合简单的迭代。递归更适合处理作为宏参数传递的递归数据结构，如列表和树，或者如果你需要反转传递给宏的参数（我在下一节给出了这个例子）。
- en: 13.3.4.4 The .exitm Directive
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.4.4 .exitm 指令
- en: 'The .exitm directive allows you to prematurely terminate the expansion of a
    macro. Its syntax is as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: .exitm 指令允许你提前终止宏的扩展。其语法如下：
- en: '[PRE102]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When Gas encounters .exitm during a macro expansion, it immediately stops the
    expansion and ignores the rest of the macro’s body. Of course, just placing an
    .exitm directive in the middle of a macro body (other than for testing purposes)
    is not especially useful—why write the rest of the macro body if it’s going to
    be ignored? Instead, you’ll generally find an .exitm macro inside a conditional
    assembly block like the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Gas 在宏扩展过程中遇到.exitm 时，它会立即停止扩展并忽略宏体的其余部分。当然，单纯地将 .exitm 指令放在宏体的中间（除非用于测试目的）并不特别有用——既然剩余部分会被忽略，那为什么要写宏体的其余部分呢？相反，您通常会在条件汇编块中找到
    .exitm 宏，如下所示：
- en: '[PRE103]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The .exitm directive terminates recursion when the argument list is empty. The
    recursive invocation passes all but the first argument to reverse. As you may
    already have guessed, this macro will generate the bytes specified as parameters
    in reverse order to the file. For example, reverse 0, 1, 2, 3 generates
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: .exitm 指令在参数列表为空时终止递归。递归调用将传递除第一个参数外的所有参数给 reverse。如您可能已经猜到，这个宏会按反向顺序生成指定为参数的字节到文件中。例如，reverse
    0, 1, 2, 3 会生成
- en: '[PRE104]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: reversing the arguments passed to the reverse macro.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 反转传递给反向宏的参数。
- en: 13.3.4.5 The \@ Operator
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.4.5 \@ 运算符
- en: 'Within a macro, Gas will convert the token \@ to a string of digits specifying
    the total number of macros it has expanded during assembly. You can use this operator,
    typically along with the \() token, to create macro-local symbols. The following
    macro provides a trivial example of this usage:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏内部，Gas 会将令牌 \@ 转换为一串数字，指定它在汇编过程中扩展的宏总数。您可以将此运算符与 \() 令牌一起使用，以创建宏局部符号。以下宏提供了一个简单的例子：
- en: '[PRE105]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Multiple expansions of this macro generate a unique symbol by suffixing a string
    of digits to the end of a.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏的多次扩展通过在 a 的末尾附加一串数字来生成一个唯一的符号。
- en: 13.3.4.6 The .purgem Directive
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.3.4.6 .purgem 指令
- en: 'The .purgem directive deletes a previously defined Gas macro. It is similar
    to the CPP #undef statement. Normally, if you try to redefine a Gas macro, Gas
    will generate an error. Use the .purgem directive to delete the macro if you want
    to redefine it.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '.purgem 指令删除一个已定义的 Gas 宏。它类似于 CPP 的 #undef 语句。通常，如果您尝试重新定义一个 Gas 宏，Gas 会生成一个错误。如果您想重新定义该宏，请使用
    .purgem 指令删除该宏。'
- en: Note that Gas will generate an error if you attempt to purge a macro that has
    not already been defined. Unfortunately, the .ifdef (and comparable) conditional
    assembly statement does not recognize macro symbols; so there is no way to check
    whether a macro has been defined before using the .purgem directive; you have
    to ensure that the macro symbol exists prior to using this directive.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您尝试清除一个尚未定义的宏，Gas 将会报错。不幸的是，.ifdef（和类似的）条件汇编语句无法识别宏符号；因此，在使用.purgem指令之前无法检查一个宏是否已定义；您必须确保在使用该指令之前宏符号已经存在。
- en: 13.4 The aoaa.inc Header File
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4 *aoaa.inc* 头文件
- en: Throughout this book, I’ve used the *aoaa.inc* header file in examples without
    discussing what it contains. Now that you’ve been introduced to CPP and Gas macro
    and CTL facilities, the time has come to fulfill my promise in [Chapter 1](chapter1.xhtml)
    that I would explain, section by section, how this header file works.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我在示例中使用了 *aoaa.inc* 头文件，但并没有讨论它的内容。现在，您已经了解了 CPP 和 Gas 宏以及 CTL 功能，是时候兑现我在[第一章](chapter1.xhtml)中承诺的，逐节解释这个头文件是如何工作的。
- en: 'I’ll go over the source code for *aoaa.inc* piece by piece, in order to annotate
    and explain each of its components. The first section is the usual header that
    appears at the beginning of an include file:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我将一一讲解 *aoaa.inc* 的源代码，逐步注释并解释每个组成部分。第一部分是通常出现在包含文件开头的头部：
- en: '[PRE106]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'To begin, the *aoaa.inc* header file assumes that the source file that includes
    *aoaa.inc* is being assembled using the *build* shell script. Among other things,
    the *build* script will include one of the following command line options on the
    gcc command line that assembles the source file, as appropriate for the OS under
    which you’re running GCC (and Gas):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*aoaa.inc* 头文件假设包含 *aoaa.inc* 的源文件是通过 *build* 脚本进行汇编的。除了其他内容外，*build* 脚本会根据您运行
    GCC（和 Gas）的操作系统，适当地在 gcc 命令行上包括以下选项之一来汇编源文件：
- en: -D isMacOS=1
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: -D isMacOS=1
- en: -D isLinux=1
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: -D isLinux=1
- en: Because these symbols are defined for use by CPP (not Gas), the source file
    must have a *.S* suffix, and you must run the CPP on this file, meaning you need
    to assemble the file by running the gcc executable rather than the as (Gas) executable.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些符号是为 CPP 使用而定义的（而非 Gas），源文件必须具有 *.S* 后缀，并且必须对该文件运行 CPP，这意味着你需要通过运行 gcc 可执行文件来汇编该文件，而不是通过
    as（Gas）可执行文件。
- en: 'The next section of the source file handles multiple inclusions:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件的下一部分处理了多次包含的问题：
- en: '[PRE107]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This #ifndef and #define sequence is the standard way to prevent problems if
    a program includes a header file more than once. The first time CPP includes this
    file, the symbol aoaa_inc will not be defined; therefore, CPP will process the
    text after the #ifndef statement. The very next statement defines the aoaa_inc
    symbol. Should the assembly source file that included *aoaa.inc* include it a
    second time, the aoaa_inc symbol will be defined, so CPP will ignore everything
    up to the matching #endif (which happens to be at the end of the source file).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '这个 #ifndef 和 #define 序列是防止程序多次包含头文件时出现问题的标准方式。第一次 CPP 包含此文件时，符号 aoaa_inc 尚未定义；因此，CPP
    会处理 #ifndef 语句之后的内容。紧接着的语句定义了 aoaa_inc 符号。如果包含了 *aoaa.inc* 的汇编源文件第二次包含了该文件，aoaa_inc
    符号将已定义，CPP 将忽略直到匹配的 #endif（恰好位于源文件末尾）。'
- en: 'As the earlier comment states, you must include the *aoaa.inc* header file
    by using the CPP statement #include, rather than Gas’s .include directive. This
    is because the *aoaa.inc* file contains several CPP statements (including #ifndef),
    and CPP will never see the *aoaa.inc* file if you include it via .include. Remember,
    Gas statements are processed long after CPP has executed and quit.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '如前面的注释所述，你必须通过 CPP 语句 #include 来包含 *aoaa.inc* 头文件，而不是使用 Gas 的 .include 指令。因为
    *aoaa.inc* 文件包含了几个 CPP 语句（包括 #ifndef），如果通过 .include 包含，CPP 永远无法看到 *aoaa.inc* 文件。记住，Gas
    语句的处理是在 CPP 执行完并退出之后进行的。'
- en: 'Next, the *aoaa.inc* header file sets up defines for various symbols to handle
    macOS- and Linux-specific code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*aoaa.inc* 头文件为处理 macOS 和 Linux 特定代码设置了多个符号的定义：
- en: '[PRE108]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This block of conditional compilation statements ensures that both isLinux and
    isMacOS are defined and are given appropriate values for the OS. The command line
    parameters supplied by the *build* script will define only one of these two symbols.
    These statements ensure that both are defined and are assigned appropriate Boolean
    values (0 for false, 1 for true).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这一块条件编译语句确保了 both isLinux 和 isMacOS 被定义，并且为操作系统赋予了适当的值。*build* 脚本提供的命令行参数只会定义这两个符号中的一个。这些语句确保了两个符号都被定义，并且赋予了适当的布尔值（0
    表示假，1 表示真）。
- en: 'Next up, the *aoaa.inc* header file defines some symbols required under macOS:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*aoaa.inc* 头文件定义了 macOS 下所需的一些符号：
- en: '[PRE109]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Under macOS, external symbols like the C stdlib function names have a leading
    underscore. Under Linux, the symbols appear without the underscore. The #define
    statements in the previous code snippet replace several common C stdlib function
    names with the underscore-prefixed version. This allows calls in this book to
    use consistent names under both macOS and Linux.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '在 macOS 下，像 C 标准库函数名称这样的外部符号有一个前导下划线。而在 Linux 下，这些符号没有下划线。前面的代码片段中的 #define
    语句将一些常见的 C 标准库函数名称替换成了带下划线前缀的版本。这使得本书中的函数调用在 macOS 和 Linux 下都能使用一致的名称。'
- en: 'These defines work only for the C stdlib functions appearing in this list.
    If you decide to call other stdlib functions (or use other external symbols),
    you’ll have to explicitly supply the underscore prefix character or add additional
    #define statements to this list.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '这些定义仅适用于出现在此列表中的 C 标准库函数。如果你决定调用其他标准库函数（或使用其他外部符号），你需要显式地为其提供下划线前缀字符，或将额外的
    #define 语句添加到此列表中。'
- en: 'The lea macro also has a macOS-specific implementation:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: lea 宏也有一个特定于 macOS 的实现：
- en: '[PRE110]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As noted in [Chapters 1](chapter1.xhtml) and [7](chapter7.xhtml), the lea macro
    expands to two instructions that load the address of a symbol into a 64-bit register.
    The main reason for including this macro (rather than explicitly writing these
    two instructions everywhere lea appears in this book) is that the two instructions
    are slightly different, depending on whether the code is being assembled for macOS
    or Linux. This version of the lea macro generates the code for macOS.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](chapter1.xhtml) 和 [第 7 章](chapter7.xhtml) 中所述，lea 宏展开为两条指令，这些指令将符号的地址加载到一个
    64 位寄存器中。包含这个宏（而不是在本书中每次出现 lea 时显式地写出这两条指令）的主要原因是，这两条指令略有不同，具体取决于代码是为 macOS 还是
    Linux 汇编的。这个版本的 lea 宏生成了 macOS 的代码。
- en: 'Next up are the mstr, mstrb, and mstrh macros, which also have macOS-specific
    implementations:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 mstr、mstrb 和 mstrh 宏，它们也有 macOS 特定的实现：
- en: '[PRE111]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Linux and macOS handle varying parameter lists differently. Under Linux, you
    continue to pass the first eight parameters in X0 through X7, while under macOS,
    you pass them both in the registers and on the stack. The mstr, mstrb, and mstrh
    macros expand to code that stores a register onto the stack when operating under
    macOS (as you’ll see shortly, the Linux versions expand to nothing).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 macOS 对变长参数列表的处理方式不同。在 Linux 下，你继续将前八个参数通过 X0 到 X7 传递，而在 macOS 下，你同时通过寄存器和堆栈传递它们。mstr、mstrb
    和 mstrh 宏在 macOS 下展开为将寄存器存储到堆栈上的代码（稍后你将看到，Linux 版本展开后什么也不做）。
- en: 'The Clang assembler (the macOS version of Gas) does not support the .dword
    directive; the following macro implements this for macOS. Under macOS, the *aoaa.inc*
    header file therefore includes a macro to supply this missing directive, mapping
    it to the equivalent .quad directive:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 汇编器（macOS 版的 Gas）不支持 .dword 指令；以下宏为 macOS 实现了这一点。因此，在 macOS 下，*aoaa.inc*
    头文件包含一个宏来提供这个缺失的指令，并将其映射到等效的 .quad 指令：
- en: '[PRE112]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Earlier chapters used the vparmn macros to pass variables to the printf() function.
    Because the API for varying parameters differs between macOS and Linux, there
    are separate definitions for the two OSes. Here is their macOS implementation:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 早期章节使用 vparmn 宏将变量传递给 printf() 函数。由于变长参数的 API 在 macOS 和 Linux 之间有所不同，因此对这两个操作系统有不同的定义。这是它们的
    macOS 实现：
- en: '[PRE113]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next come the Linux-specific implementations of these macros:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是这些宏的 Linux 特定实现：
- en: '[PRE114]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'There are no #define statements for stdlib functions because Linux doesn’t
    require the underscore prefix character on external names. As for the parameter-related
    functions, Linux passes the first eight arguments of a varying parameter list
    only in the registers, not on the stack. The mstr, mstrb, and mstrh macros thus
    expand to nothing, while the vparmn macros expand to code without storing data
    on the stack.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 stdlib 函数没有 #define 语句，因为 Linux 不要求外部名称带下划线前缀字符。至于与参数相关的函数，Linux 仅通过寄存器传递变长参数列表的前八个参数，而不是通过堆栈。因此，mstr、mstrb
    和 mstrh 宏展开后什么也不做，而 vparmn 宏则展开为不将数据存储在堆栈上的代码。'
- en: 'The remainder of the source file is common to both macOS and Linux. First,
    the *aoaa.inc* header file contains a few .global directives to specify public
    names for use by the C/C++ program that calls the assembly file:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件的其余部分对 macOS 和 Linux 都是通用的。首先，*aoaa.inc* 头文件包含一些 .global 指令，用于为调用汇编文件的 C/C++
    程序指定公共名称：
- en: '[PRE115]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The printf definition, strictly speaking, isn’t necessary; it’s really just
    an external declaration, and undefined symbols are external by default. I added
    it simply because almost every sample program in this book calls the printf()
    function.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: printf 的定义严格来说并不是必需的；它实际上只是一个外部声明，而未定义的符号默认就是外部符号。我之所以添加它，是因为本书几乎每个示例程序都会调用
    printf() 函数。
- en: 'Gas doesn’t actually provide a .qword directive. The .qword macro renames .octa
    to .qword to be consistent with .word and .dword:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 实际上并不提供 .qword 指令。 .qword 宏将 .octa 重命名为 .qword，以便与 .word 和 .dword 保持一致：
- en: '[PRE116]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Next up in *aoaa.inc* are the definitions needed for the structure definition
    macros:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 *aoaa.inc* 中结构体定义宏所需的定义：
- en: '[PRE117]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The __inStruct, __inArgs, __inLocals, and __dir compile-time variables maintain
    information needed to declare structure fields, parameters, and local variables
    by using the struct, args, and locals macros. The __in* variables are Booleans
    that track whether the program is currently defining a structure, a parameter
    list, or a set of local variables. Only one of these fields may contain true (nonzero)
    at a time, though they can all be 0 if you’re not declaring the field of any of
    these objects.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: __inStruct、__inArgs、__inLocals 和 __dir 编译时变量维护着声明结构字段、参数和局部变量所需的信息，使用 struct、args
    和 locals 宏。__in* 变量是布尔值，用于跟踪程序当前是否在定义结构、参数列表或一组局部变量。一次只能有一个字段包含 true（非零），但如果不声明这些对象的字段，则它们都可以是
    0。
- en: The __dir variable is either 1 or –1\. This determines whether successive declarations
    in these objects have increasing (when __dir is +1) or decreasing (when __dir
    is –1) offsets. Structures and parameters have increasing offsets, while locals
    have decreasing offsets.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: __dir 变量的值要么是 1，要么是 -1。它决定了这些对象中连续声明的偏移量是递增（当 __dir 为 +1 时）还是递减（当 __dir 为 -1
    时）。结构体和参数的偏移量是递增的，而局部变量的偏移量是递减的。
- en: 'With those compile-time constants out of the way, here are the actual struct,
    args, and locals macros:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译时常量设置完毕后，接下来是实际的 struct、args 和 locals 宏：
- en: '[PRE118]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The struct, args, and locals macros allow you to define structures (records),
    parameter lists (arguments), and local variables. These macros set up some compile-time
    variables that track the base address of the object, as well as the direction,
    positive or negative, by which offsets are assigned to fields of the object.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: struct、args 和 locals 宏允许你定义结构体（记录）、参数列表（参数）和局部变量。这些宏设置了一些编译时变量，用于跟踪对象的基地址，以及分配给对象字段的偏移量的方向（正向或负向）。
- en: The struct macro ❶ creates structures (records) by associating a field offset
    with each member of the structure. The struct macro itself simply initializes
    the __inStruct, __dir, and name.base compile-time variables that maintain information
    needed when declaring fields of the structure (where name is the user-supplied
    structure name). The __struct_offset CTL maintains a “location counter” within
    the structure. By default, the struct macro initializes this with 0\. However,
    the person invoking struct can specify a negative value if they would like to
    specify that the first fields of the structure appear in memory before the structure’s
    base address. The __dir CTL is initialized with 1 because successive fields in
    a structure have increasing offsets within the structure.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: struct 宏 ❶ 通过将字段偏移与结构体的每个成员关联来创建结构体（记录）。struct 宏本身仅初始化 __inStruct、__dir 和 name.base
    这三个编译时变量，它们保持声明结构体字段时所需的信息（其中 name 是用户提供的结构体名称）。__struct_offset CTL 维护结构体内的“位置计数器”。默认情况下，struct
    宏将其初始化为 0。然而，调用 struct 的人可以指定一个负值，如果他们希望指定结构体的第一个字段在内存中出现在结构体基地址之前。__dir CTL 被初始化为
    1，因为结构体中的连续字段在结构体内有递增的偏移量。
- en: The args macro ❷ declares parameter lists for a function or procedure, fundamentally
    the same operation as creating a structure; you are defining part of the activation
    record, after all. The only real difference is that the starting offset is 16
    (this is the offset of the first parameter in the activation record, using the
    base address specified by the FP register; the saved FP value and the return address
    consume the double words at offsets 0 and 8, respectively). Because parameters
    follow in higher addresses, the __dir field is initialized with 1.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: args 宏 ❷ 声明函数或过程的参数列表，本质上与创建结构体相同；毕竟，你是在定义激活记录的一部分。唯一的真正区别是起始偏移量为 16（这是在激活记录中第一个参数的偏移量，使用
    FP 寄存器指定的基地址；保存的 FP 值和返回地址分别占用偏移量为 0 和 8 的双字）。因为参数在较高地址处，因此 __dir 字段被初始化为 1。
- en: The locals macro ❸ declares local variables allocated on the stack below the
    address held in the FP register. Because successive declarations appear at lower
    addresses in memory, this macro initializes the __dir field with –1.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: locals 宏 ❸ 声明在堆栈上分配的局部变量，这些变量位于 FP 寄存器所持有的地址下方。由于连续声明的变量会出现在内存中的较低地址处，因此该宏将
    __dir 字段初始化为 -1。
- en: 'The macros for the matching ends, enda, and endl statements appear later in
    the listing. The following sections describe the data declaration macros that
    can appear inside a structure:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 与匹配的结束语、enda 和 endl 语句相关的宏稍后会出现在列表中。接下来的部分描述了可以出现在结构体内部的数据声明宏：
- en: '[PRE119]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The salign macro, which should appear only in a struct, args, or locals declaration,
    adjusts the __struct_offset value (the location counter) so that it is aligned
    at an offset that is a power of 2 (the power of 2 is specified by the parameter).
    This macro achieves its purpose by creating a bitmask containing size 0s in the
    LO bits and 1s in the remaining HO bits. Logically ANDing __struct_offset with
    this value produces an offset that is aligned to the designed value.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: salign 宏只能出现在 struct、args 或 locals 声明中，它调整 __struct_offset 值（位置计数器），使其在一个是 2
    的幂次方的偏移量上对齐（2 的幂次方由参数指定）。这个宏通过创建一个位掩码来实现其目的，该位掩码在低位包含 0，在剩余的高位包含 1。将 __struct_offset
    与此值进行逻辑与运算，产生一个对齐到设计值的偏移量。
- en: 'The following macros provide the byte, hword, word, dword, qword, oword, single,
    and double directives for use in structures:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下宏提供了用于结构体中的 byte、hword、word、dword、qword、oword、single 和 double 指令：
- en: '[PRE120]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Each macro declares a single scalar or array variable of the specified type
    (you can specify an array by providing a second argument with the number of elements).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 每个宏声明一个指定类型的单一标量或数组变量（可以通过提供第二个参数并指定元素个数来定义数组）。
- en: These macros will bump the current location counter, __struct_offset, by the
    size of the variable and assign that offset to the declared name. If __dir is
    negative (locals declarations), the macro first decrements the location counter,
    then assigns the offset to the name; if __dir is positive, the macro assigns the
    offset and increments the location counter value.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the ends, enda, and endl macros:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The ends, enda, and endl macros complete a declaration begun by struct, args,
    or locals. They set to false the Boolean variable that is tracking an open structure,
    parameter list, or local variables declaration, then set the name.size equate
    to the total size of the declarations. The ends macro also defines a macro that
    you can use to declare structure objects in your code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'The wastr macro emits a word-aligned string to memory. Here is its implementation:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This macro is mainly used in .text sections because you must keep all code and
    labels word-aligned within those sections. Quotes must surround the macro parameter
    expansion because Gas will strip off the quotes you supply in the actual parameter
    (see section 13.3.4.2, “Macro Parameters with String Constants,” on [page 768](chapter13.xhtml#pg_768)).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'The proc and endp macros provide syntactical sugar for declaring procedures
    in an assembly language source file. Here is their implementation:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Other than emitting the procedure name and (if isPublic is 1) the .global directive,
    this macro doesn’t really do much.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The public equate allows you to specify public as a second argument to this
    macro to tell the assembler to make the symbol global (that is, public). Technically,
    you could just pass 1 as the second argument, but public is more readable.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'The .code macro simply expands to .text and ensures that the location counter
    is aligned on a word (4-byte) boundary:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The enter and leave macros provide the standard entry and standard exit sequences
    for a procedure (see section 5.4.4, “Standard Entry Sequence,” on [page 248](chapter5.xhtml#pg_248)
    and section 5.4.5, “Standard Exit Sequence,” on [page 250](chapter5.xhtml#pg_250)
    for more details):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In rare circumstances, the b (branch) and b.al (branch always) instructions
    may generate an out-of-range error when the target location is too far away from
    the instruction. In those situations, you can use the goto macro to transfer control
    anywhere in the 64-bit address range of the ARM CPU:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The goto macro modifies the values held in the X16 and X17 registers. The ARM
    API reserves these registers for exactly this purpose, so this is permissible.
    However, you should always remember that this macro modifies X16 and X17.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'The C stdlib provides the magic pointer __errno_location to return a pointer
    to C’s errno variable in X0\. The getErrno macro expands to a function call that
    retrieves this value and returns it in W0:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The ccne through ccnle equates define useful bit patterns for use by the ccmp
    instruction:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The opposite branches are useful when writing code to simulate HLL-like control
    structures such as if/then/else statements:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The #endif statement terminates the #ifndef statement appearing at the very
    beginning of the source file.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Generating Macros by Another Macro
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use one macro to write another, as the following code demonstrates:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'As the comment states, this variant of the proc macro creates a new varProc
    macro you can use to invoke the procedure with HLL-like syntax. Consider the following
    invocation of this macro:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This expands to the following code:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Invoke the _someFunc macro as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This generates the following code
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: and then generates someFunc branches to printf, essentially making this a call
    to the printf() function.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: You could have written a macro to invoke printf() directly (handling the arguments),
    but you’d have to write such a macro for every function you want to call using
    HLL-like syntax. Having the varProc macro automatically write this macro spares
    you this repetitive task.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: The varProc macro has the severe limitation that its parameters must be global
    memory locations (no register, local variables, or other types of memory operands).
    While this macro may not be especially useful, it serves to demonstrate how one
    macro can write another. I’ll leave it as an exercise for you to expand this macro
    to handle other types of operands.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if a macro creates another macro, it must use an undefined name when
    creating the new macro. The examples in this section achieved this by having the
    invoker supply the new macro name as an argument to the macro that creates the
    new macro. It is also possible to use the .purgem directive to delete the new
    macro’s name prior to creating it. However, keep in mind that the macro name must
    already exist when using .purgem to delete it. On the first invocation of the
    creating macro, this could be a problem since the macro to create might not exist
    on the first invocation. This is easily remedied by providing an empty macro prior
    to the first invocation of the creating macro:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Because createdMacro already exists on the first invocation of createMacro,
    the .purgem statement will not generate an error message. After the first invocation,
    future invocations of createMacro will delete the version of createdMacro created
    in the previous invocation.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Choosing Between Gas Macros and CPP Macros
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Glancing at the GNU CPP documentation (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/cpp<wbr>/](https://gcc.gnu.org/onlinedocs/cpp/)*),
    you’ll find that the GNU folks suggest using the Gas built-in macro facilities
    rather than the CPP. If the people who wrote CPP and Gas suggest using the Gas
    macro processor rather than CPP, shouldn’t you take that suggestion seriously?
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: If you could use only one macro processor, you could make a strong case for
    using the Gas macro processor rather than CPP. CPP is not a very powerful macro
    processor, and macro abuse by C/C++ programmers has given it a bad reputation.
    Gas’s macro processor, in many respects, is clearly superior. Gas’s macro facilities
    would make the better choice between the two.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: However, who says you have to use only one or the other? Why not both? CPP and
    Gas each have strengths and weaknesses that tend to be complementary. Although
    Gas’s macro facilities are more powerful than CPP’s, compared with other assemblers
    out there—such as the Microsoft Macro Assembler (MASM) or the High-Level Assembler
    (HLA)—Gas’s macro facilities aren’t particularly impressive. Anything you can
    use to boost the power of Gas’s macros is a good thing. CPP also has some neat
    features that Gas lacks (such as functional-style macro invocations), and Gas,
    of course, has many features that CPP lacks (such as multiline macro definitions).
    If you’re careful, using both macro processors gives you abilities above and beyond
    those of either. That’s a good thing, so combining the power of CPP and Gas is
    something I wholeheartedly recommend.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Given that you have two CTLs available to you when compiling a Gas source file
    (at least when using a *.S* suffix), which CTL constructs should you use? Most
    of the time, it doesn’t matter much; if either CTL would work, the choice is up
    to you, though sticking with Gas’s CTL is probably the safest choice if all other
    factors are equal. However, because the two have differing capabilities, at times
    you might need to pick one over the other.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, CPP’s macro definitions look like functions and can appear almost
    anywhere (outside of comments) in the source file. They are great for writing
    address expression functions. The following code demonstrates the use of functional-style
    CPP macros:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In this example, a Gas macro wouldn’t work because Gas macros don’t support
    functional-style invocations.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, CPP macros are limited to producing a single line of text.
    Therefore, Gas macros are necessary when you want to emit a sequence of instructions:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Also note that CPP macros can cause you problems if you attempt to use the
    # symbol (stringify in CPP, immediate operand in Gas) in your macro expansion.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Gas also supports a richer set of conditional assembly statements, along with
    CTL looping statements. This makes Gas more appropriate for macros that emit a
    large amount of data or a large number of statements. I generally prefer CPP macros
    for simple address expression functions and use Gas macros when I need to expand
    the macro to actual statements.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Deciding whether to use CPP statements versus Gas’s .set, .equ, and = directives
    for simple constant declarations is less clear-cut. For simple integer constants,
    Gas’s equate directives work fine. For nonintegral values, CPP works better. The
    following example demonstrates defining string constants with CPP macros:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'For integer expressions, Gas’s equates tend to work better:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Finally, always keep in mind that CPP processes its CTL statements in a preprocessing
    pass before assembly takes place, meaning CPP is blissfully unaware of symbols
    and other tokens specific to the assembly language source file. For example:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The #ifdef symbol would believe that the symbol a is undefined (even though
    it was defined earlier in the Gas source file). Remember, CPP conditional compilation
    statements know only about symbols created with #define statements.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 13.7 Moving On
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Gas and CPP CTLs greatly expand the capabilities of the Gas assembler. Using
    these facilities, including constant definitions, macro definitions, conditional
    compilation and assembly, and so on, can reduce the effort you need to write assembly
    language source code.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered the basic information you need to employ the Gas and CPP
    CTLs in your assembly language source files, beginning with a discussion of CPP.
    The second half of this chapter discussed the Gas CTL, including the error and
    warning directives, conditional assembly, compile-time looping directives, and
    Gas macros. Next, this chapter described the internal source code for the *aoaa.inc*
    header file that you’ve used extensively since [Chapter 1](chapter1.xhtml). The
    chapter concluded by contrasting the CPP CTL and the Gas macro facilities, discussing
    when you should pick one system over the other.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Now that this book has described the Gas CTL, its example code will begin to
    use the macro facilities, starting in the next chapter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 13.8 For More Information
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can review the GNU CPP documentation at *[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/cpp<wbr>/](https://gcc.gnu.org/onlinedocs/cpp/)*.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the Gas documentation (including macros) at *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_node<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_toc.html)*.
    For more on Gas macros in particular, see *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_node<wbr>/as<wbr>_107<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_107.html)*.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information on advanced CPP macros, check out “C Pre-Processor Magic” by
    Jonathan Heathcote at *[http://<wbr>jhnet<wbr>.co<wbr>.uk<wbr>/articles<wbr>/cpp<wbr>_magic](http://jhnet.co.uk/articles/cpp_magic)*
    and *[https://<wbr>github<wbr>.com<wbr>/18sg<wbr>/uSHET<wbr>/blob<wbr>/master<wbr>/lib<wbr>/cpp<wbr>_magic<wbr>.h](https://github.com/18sg/uSHET/blob/master/lib/cpp_magic.h)*.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check the C Preprocessor Tricks, Tips, and Idioms GitHub site to find
    CPP tricks: *[https://<wbr>github<wbr>.com<wbr>/pfultz2<wbr>/Cloak<wbr>/wiki<wbr>/C<wbr>-Preprocessor<wbr>-tricks,<wbr>-tips,<wbr>-and<wbr>-idioms](https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms)*.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the Boost CPP library at *[https://<wbr>www<wbr>.boost<wbr>.org<wbr>/doc<wbr>/libs<wbr>/1<wbr>_57<wbr>_0<wbr>/libs<wbr>/preprocessor<wbr>/doc<wbr>/index<wbr>.html](https://www.boost.org/doc/libs/1_57_0/libs/preprocessor/doc/index.html)*.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Embedded Artistry has an article on “Exploiting the Preprocessor for Fun and
    Profit” by Klemens Morgenstern: *[https://<wbr>embeddedartistry<wbr>.com<wbr>/blog<wbr>/2020<wbr>/07<wbr>/27<wbr>/exploiting<wbr>-the<wbr>-preprocessor<wbr>-for<wbr>-fun<wbr>-and<wbr>-profit<wbr>/](https://embeddedartistry.com/blog/2020/07/27/exploiting-the-preprocessor-for-fun-and-profit/)*.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about macro metaprogramming from Thomas Mailund’s blog at *[https://<wbr>mailund<wbr>.dk<wbr>/posts<wbr>/macro<wbr>-metaprogramming<wbr>/](https://mailund.dk/posts/macro-metaprogramming/)*.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
