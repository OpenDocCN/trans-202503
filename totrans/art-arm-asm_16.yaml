- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 13 MACROS AND THE GAS COMPILE-TIME LANGUAGE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the Gas compile-time language (CTL), including its macro
    expansion facilities. A *macro*, the CTL equivalent of a procedure, is an identifier
    that the assembler will expand into additional text. This allows you to abbreviate
    large amounts of code with a single identifier. Gas’s macro facility is a computer
    language inside a computer language; that is, you can write short programs inside
    a Gas source file whose purpose is to generate other Gas source code to be assembled
    by Gas.
  prefs: []
  type: TYPE_NORMAL
- en: The Gas CTL consists of macros, conditionals (if statements), loops, and other
    statements. This chapter covers many Gas CTL features and how you can use them
    to reduce the effort needed to write assembly language code.
  prefs: []
  type: TYPE_NORMAL
- en: '### 13.1 The Gas Compile-Time Language Interpreter'
  prefs: []
  type: TYPE_NORMAL
- en: Gas is actually two languages rolled into a single program. The *runtime language*
    is the standard ARM/Gas assembly language you’ve been reading about in the previous
    chapters. This is called the runtime language because the programs you write execute
    when you run the executable file. Gas contains an interpreter for a second language,
    the *Gas CTL*.
  prefs: []
  type: TYPE_NORMAL
- en: Gas source files contain instructions for both the Gas CTL and the runtime program,
    and Gas executes the CTL program during assembly (compilation). Once Gas completes
    assembly, the CTL program terminates. [Figure 13-1](chapter13.xhtml#fig13-1) shows
    the relationship between compile-time and runtime with respect to the Gas assembler
    and your assembly language source code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: Compile-time versus runtime execution'
  prefs: []
  type: TYPE_NORMAL
- en: The CTL application is not a part of the runtime executable that Gas emits,
    although the CTL application can write part of the runtime program for you. In
    fact, this is the major purpose of the CTL. Using automatic code generation, the
    CTL gives you the ability to emit repetitive code easily and elegantly. By learning
    how to use the Gas CTL and applying it properly, you can potentially develop assembly
    language applications as rapidly as HLL applications (even faster because Gas’s
    CTL lets you create very HLL, or VHLL, constructs).
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 The C/C++ Preprocessor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Gas CTL consists of two separate language processors: the Gas built-in
    macro processor and the C/C++ preprocessor (CPP). As noted in [Chapter 1](chapter1.xhtml),
    standard Gas assembly language source files use the *.s* suffix. However, if you
    specify *.S* as the suffix, Gas will run the source file through the CPP prior
    to processing the file (see [Figure 13-2](chapter13.xhtml#fig13-2)). The CPP emits
    a temporary source file (with the *.s* suffix), which the Gas assembler then assembles
    into object code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: C preprocessor processing by Gas'
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely important to remember that the CPP runs independently of Gas
    and prior to it assembling the assembly language source file. In particular, Gas’s
    macro processing takes place *after* the CPP runs. Therefore, you cannot use Gas
    statements, symbols, or Gas macros to affect the operation of the CPP. Later in
    this chapter, I’ll point out the areas where you must take care when mixing the
    macro facilities of the two languages. This section describes the various features
    of the CPP.
  prefs: []
  type: TYPE_NORMAL
- en: '13.2.1 The #warning and #error Directives'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When writing macros by using CPP, you’ll sometimes encounter a problem (such
    as a bad parameter argument) that you’ll want to report as an error or a diagnostic
    message during the assembly process. To do so, you can use the #warning and #error
    diagnostic statements with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These statements must appear on a source line by themselves; nothing other
    than whitespace (spaces and tabs) should appear on the line before the # character.
    (Technically, whitespace is allowed to appear between the # and the error or the
    warning tokens, but good programming style dictates keeping them together.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'During assembly (or, more precisely, while CPP is processing the source file),
    the system should display a diagnostic message and print the line containing the
    #error or #warning statement, including all the arbitrary text up to the end of
    the line. By convention, most programmers surround the error or warning message
    (the arbitrary text) in quotes, but this isn’t absolutely necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If CPP encounters any #error statements, it will terminate the assembly after
    CPP is done scanning the source file, without running the Gas assembler to assemble
    that file. In this case, you will need to modify the source file as necessary
    to eliminate the error message before Gas even gets a chance to process the file
    (and, for example, report on any errors in the assembly language source code).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the CPP encounters any #warning statements, it will print the appropriate
    message during assembly but will allow assembly to proceed after the CPP is done
    preprocessing the source file. Hence, you can use the #warning statement to display
    arbitrary text during the assembly and preprocessing process.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.2 Compile-Time Constant Definition with CPP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the CPP #define statement to create constant definitions in your
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When CPP processes the source file, it will replace any following occurrences
    of identifier by arbitrary_text. Programmers commonly use this statement, for
    example, to define manifest (named) constants in their source file, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In an assembly language program, you would normally use the .equ, .set, or
    = directives to define named constants, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, various bugs in Gas might not allow you to use these constants the
    way you like. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you try to assemble this, Gas will complain that 3.14159 is not a valid constant
    and that pi is not a valid floating-point constant. (The Clang assembler under
    macOS will accept pi = 3.14159 but will still complain that pi is not a valid
    floating-point constant.) However, if you replace this with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: then Gas will assemble the code just fine because CPP will preprocess the source
    file and replace each occurrence of pi with 3.14159. Therefore, when Gas actually
    sees the source file, it will find
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'which is perfectly acceptable. This is a good example of why it helps to use
    CPP in your Gas source files: it provides you with capabilities, such as real
    constant definitions, that you wouldn’t normally have with Gas alone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because CPP does a textual replacement of the defined identifier wherever it
    finds that identifier (outside of a string or character constant), you’re not
    limited to using #define for numeric constants. You can supply character constants,
    string constants, or even arbitrary text (including nothing) after the #define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You could even do something like the following if you really prefer the xor
    mnemonic over the eor mnemonic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Although redefining instruction mnemonics like this is generally considered
    poor programming practice, ARM does it all over the place with its “instruction
    aliases.” If it’s good enough for the ARM, there is no reason you can’t do it
    if it makes your code more readable to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important use of the #define statement is to create symbols that the
    CPP can recognize. The CPP is blissfully unaware of all identifiers appearing
    in your source file, except those you create with the #define statement. As you’ll
    see starting in the next section, you’ll sometimes want to use various expressions
    in a CPP CTL statement involving named constants. Those named constants must be
    defined with the #define statement, not one of Gas’s equate directives.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.3 CPP Compile-Time Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Certain CPP statements allow simple arithmetic expressions involving constants.
    The arithmetic operators are the usual C arithmetic operators, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that CPP supports only (signed) 64-bit integer and character expressions
    and will report an error if you attempt to use floating-point or string constants.
    You can use a named constant in a CPP CTL expression as long as you’ve previously
    declared that name with a #define statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following CPP built-in function in CPP CTL expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns 1 if the identifier was previously defined in a #define
    statement; it returns 0 if no such definition exists (note that you can also use
    the GCC -D identifier=value command line option to define symbols). The defined()
    function recognizes only symbols defined in a #define statement, a good example
    of the “important use” mentioned in the preceding section. If you pass a normal
    Gas assembly language identifier here, the function will return 0 even if the
    definition occurred earlier in the source file.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.4 Conditional Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The CPP provides several statements that allow you to make decisions when processing
    the source file. Here are those directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'During preprocessing, CPP will evaluate expression. If it yields a nonzero
    value (true), the #if or #elif (else if) statements will process the text up to
    the next #elif, #else, or #endif statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If expression evaluates to false, CPP will skip over the following text (up
    to the next #elif, #else, or #endif statement) and will not write that text to
    the temporary output file. Therefore, Gas will not assemble that text during the
    assembly phase.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this conditional processing happens during preprocessing (assembly),
    not at runtime. This is not a generic if/then/elseif/else/endif statement you’d
    find in an HLL. The conditional compilation statements control whether the instructions
    will actually appear in the final object code, activity that should be familiar
    to anyone who has used conditional compilation in an HLL such as C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The #ifdef statement is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The CPP checks the identifier to see whether it was previously defined with
    a #define statement (or the -D command line option). If so, CPP processes the
    text after the #if (or #ifdef) and up to the #endif (or up to an #elif or #else
    statement, if present).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The #ifndef (if not defined) statement is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The #ifdef and #ifndef statements are common in code that is written for different
    execution environments. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to this point, if the following statement appeared, then the former code
    would compile the section for macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Had this definition not appeared, the code would compile the Linux or Pi OS
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Another common use of conditional assembly is to introduce debugging and testing
    code into your programs. As a typical debugging technique, many Gas programmers
    insert print statements at strategic points, enabling them to trace through their
    code and display important values at various checkpoints. A big problem with this
    technique, however, is that they must remove the debugging code prior to completing
    the project. Moreover, programmers often forget to remove some debugging statements,
    creating defects in the final program. Finally, after removing a debugging statement,
    these programmers often discover that they need that same statement to debug a
    different problem at a later time. Hence, they must constantly insert and remove
    the same statements over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional assembly provides a solution to this problem. By defining a symbol
    (say, debug) to control debugging output in your program, you can activate or
    deactivate *all* debugging output by modifying a single line of source code, as
    the following code fragment demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as you surround all debugging output statements with an #if statement
    like the one in the preceding code, you don’t have to worry about debugging output
    accidentally appearing in your final application. Commenting out the debug symbol
    definition will automatically disable all such output (or, better yet, just use
    the -D debug command line option to turn on output when you want it). Likewise,
    you can leave the debugging statements from your programs in your code even after
    they’ve served their immediate purpose, since conditional assembly makes them
    easy to deactivate. Later, if you decide you need to view this same debugging
    information during assembly, you can reactivate it by defining the debug symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### 13.2.5 CPP Macros'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, this chapter used the #define statement to define compile-time
    constants, a special case of a *macro definition*. This section describes CPP
    macro definitions and expansion in more depth, including a discussion of macro
    parameters, variable argument lists, and other CPP macro definition features.
    By using this information, you will be able to create and use CPP macros in your
    Gas assembly language source files.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.1 Functional Macros
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A macro is a mechanism that CPP uses to replace an identifier with arbitrary
    text. When defining constants with #define, you’re telling CPP to replace every
    following occurrence of that identifier with the text, which happens to be the
    constant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, CPP provides a second type of macro, the *functional macro*, which
    behaves more like a (compile-time) function supporting an arbitrary number of
    arguments. The following example demonstrates a single-argument macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This last statement expands to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'because the macro lcl expands to [fp, #varName]. The CPP calls these *functional
    macros* because their invocation resembles a function call in the C programming
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.2 CPP Macro Arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Functional macros support an arbitrary number of arguments. You can specify
    zero arguments thusly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: where zeroArgs() will expand into the specified text.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a difference between the following two macro declarations that manifests
    when you invoke them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You invoke the first macro with noArgs and the second macro with zeroArgs().
    If the macro declaration has an empty set of parentheses, the macro invocation
    must also include the empty parentheses. You can use this declaration scheme to
    differentiate between constant declarations and macro declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify two or more arguments in a #define statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a twoArgs() invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When invoking twoArgs(), you must supply exactly two parameters, or Gas will
    report an error. In general, the number of arguments you supply in a macro invocation
    must exactly match the parameter list in the #define declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When CPP is processing a macro invocation, it usually separates actual parameters
    by scanning for commas. It ignores commas appearing in string or character constants,
    or in expressions surrounded by parentheses or square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From CPP’s perspective, each of these macro invocations has a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.3 Macro Argument Expansion Issues
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As any experienced C programmer knows, you must be careful when specifying
    macro parameters to avoid unintended consequences during expansion, especially
    if they involve arithmetic expressions. Consider the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the following macro invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The expectation here is to reserve twice as much space as the reserve() macro
    would normally specify. However, consider the actual expansion of this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Gas’s arithmetic rules specify that multiplication has a higher precedence
    than addition, so this expands to Size + 2 rather than (Size + 1) × 2, the desired
    expansion. C programmers work around this issue by always surrounding macro expansions
    (that expand to arithmetic expressions) with parentheses, and they always surround
    the macro parameters themselves with parentheses, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This usually resolves the issue of a macro expansion in the middle of an arithmetic
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, it’s generally a good idea to enclose any expression you
    pass as a macro argument in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Because the expansion could produce unintended consequences based on operator
    precedence (for example, suppose the reserve definition were amt * 2, which would
    expand to Size + 5 * 2 if you didn’t surround the actual parameter expression
    with parentheses).
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.4 Variable Argument Lists
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'CPP provides a mechanism for specifying a variable number of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To reference the arguments, use the predefined __VA_ARGS__ symbol (which begins
    and ends with two underscores). The CPP will substitute the entire set of arguments
    in place of __VA_ARGS__. *This includes all the commas appearing in the varying
    argument list*. Consider the following macro definition and invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The .byte statement expands to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A varying argument list allows zero actual parameters, so the invocation bytes()
    is perfectly legal (and will expand to the empty string, given the previous definition).
    Therefore
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: will expand to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: which, interestingly enough, will not produce an error (Gas does not generate
    any code for this statement).
  prefs: []
  type: TYPE_NORMAL
- en: Although the expansion of the entire argument list is sometimes useful, you’ll
    much more often need to pick off individual arguments in the varying argument
    list, as discussed in the following two sections.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.5 Macro Composition and Recursive Macros
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: CPP does not support recursive macro invocations. If a macro’s name appears
    in the expansion text, CPP will simply emit that name as text to be assembled
    by Gas. This is unfortunate because recursion would be very useful for handling
    iteration, as CPP doesn’t provide any looping constructs. In section 13.2.5.9,
    “Iteration with Macros,” on [page 757](chapter13.xhtml#pg_757), I’ll provide a
    workaround; in the meantime, I will discuss how CPP handles macro expansion when
    one macro invokes another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following macro definitions and invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When CPP encounters a macro invocation within the parameter list of another
    macro invocation, it will expand the parameter before passing that text on to
    the enclosing macro invocation. The expansion of the .byte statement happens in
    two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: and then
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'which, of course, is equal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When CPP encounters the macro invocation at the end of this example, it will
    expand callingMacro(5) to the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'CPP will then expand this macro to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As long as CPP continues to find a macro invocation in the expanded text (except
    for a recursive invocation), it will continue to expand those invocations, regardless
    of how many iterations this process requires.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* #define calledMacro(x) mov w0, x *macro should really be* #define calledMacro(x)
    mov w0, #x *using the syntax presented thus far in this book. However, the* #
    *is a CPP operator (stringify, described a little later) that will turn the actual
    parameter* 5 *into the string* "5"*. Fortunately, Gas accepts a plain constant
    in place of* #constant *for the immediate addressing mode in this example.*'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.6 Macro Definition Limitations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The syntax for a CPP macro is the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: where (parameters) is optional and \n represents a newline character. CPP does
    not allow any newline characters within text to expand. Therefore, a macro can
    expand only to a single line of text.
  prefs: []
  type: TYPE_NORMAL
- en: CPP does allow macro definitions like the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: which spreads a macro definition across *n* lines in the source file. Each line,
    except the last, must be terminated with a backslash character (\) immediately
    followed by a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this macro is physically split across multiple source lines, it is
    still a single line of text because the CPP will delete all the newline characters
    following the backslash characters. Therefore, you cannot create a macro like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This macro definition won’t work because CPP will expand all the assembly language
    statements on a single line (with spaces between them), generating a syntax error.
    Sadly, Gas doesn’t seem to provide a general mechanism for supplying multiple
    assembly statements on the same line. Therefore, you cannot use CPP macros that
    expand to multiple assembly language statements. (Fortunately, Gas macros do allow
    this, as you’ll learn in section 13.3.4, “Gas Macros,” on [page 765](chapter13.xhtml#pg_765).)
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*On some CPUs, Gas allows the use of the semicolon (*;*) character to put multiple
    statements on the same line. However, the ARM treats semicolons as line comment
    characters; one semicolon is equivalent to two forward slashes (*//*). Your mileage
    may vary with Gas; for example, under Pi OS you can use the semicolon as a statement
    separator.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'CPP’s single-line macro definitions have another serious drawback: you cannot
    incorporate CPP’s conditional compilation statements (such as #if) into a macro,
    since the conditional compilation statements must appear at the beginning of a
    source line. This is unfortunate, as the ability to make decisions in a macro
    would be useful. Fortunately, there are a couple of workarounds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can put macro definitions within conditional compilation sequences,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This sequence has two macros, only one of which will be defined within a given
    assembly. You can therefore put the (presumably) macOS-only code in the first
    macro definition and the Linux code in the second definition.
  prefs: []
  type: TYPE_NORMAL
- en: Using two separate macro definitions like this will work in some, but not all,
    instances; sometimes you really do need the ability to put conditional text within
    a macro expansion. I’ll provide a second workaround to address this need in section
    13.2.5.8, “Conditional Macros,” on [page 756](chapter13.xhtml#pg_756).
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.7 Text Concatenation and the Stringify Operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'CPP provides two special operators for manipulating textual data: the concatenation
    operator and the stringify operator. This section describes those two operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *token* is an entity, such as an identifier or operator, recognized by the
    C/C++ language. The CPP *concatenation operator* (##) combines two tokens in a
    macro, forming a single token. For example, within a macro body, the following
    text produces the single token identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Any amount of whitespace may appear between the tokens and the ## operator.
    CPP will remove all the whitespace and join the two tokens together—as long as
    the result is a legal C/C++ token. If a macro parameter identifier appears on
    either side of the ## operator, CPP will expand that parameter to the actual parameter’s
    text before doing the concatenation. Alas, if you pass another macro as the parameter,
    CPP does not properly expand the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As a sneaky workaround to this problem, you can create a concatenation macro
    to create the identifier for later expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'which then expands to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Section 13.8, “For More Information,” on [page 792](chapter13.xhtml#pg_792)
    includes links to sites that describe CPP’s text concatenation operator more fully.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The concatenation operator is legal only within a CPP macro. The CPP will
    ignore* ## *everywhere else in the source file, leaving it up to Gas to handle
    it (which generally produces an error, as* ## *is not a legal token in ARM assembly
    language).*'
  prefs: []
  type: TYPE_NORMAL
- en: The second CPP operator is the *stringify operator* (#), which you can use within
    a macro body as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'where parmID is the name of one of the macro parameters. The stringify operator
    will expand the parameter and convert it to a string by surrounding the text with
    quotes. This is why the earlier #define calledMacro(x) mov w0, #x macro did not
    work properly—it stringified the argument rather than leaving it as an integer
    constant.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.8 Conditional Macros
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Although you cannot include conditional compilation directives (#if, #else,
    and so on) inside macro bodies, it is possible to create conditional macros by
    pulling some tricks with the CPP (otherwise known as *abusing CPP*). Here’s an
    example of a conditional macro that implements an if ... then macro expansion
    you can use to select a particular expansion based on other definitions in your
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The (true expansion) and (false expansion) are compile-time expressions. The
    if_else macro will evaluate expression; if it evaluates to a nonzero value, this
    statement will be replaced by (true expansion). If expression evaluates to false,
    this statement will be replaced by (false expression). Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If MacOS is nonzero, this produces the string "macOS"; otherwise, it produces
    the string "LinuxOS".
  prefs: []
  type: TYPE_NORMAL
- en: 'The if_else macro is quite complex, and I won’t describe how it works here;
    it is C rather than assembly language, which puts it beyond the scope of this
    text. See section 13.8, “For More Information,” on [page 792](chapter13.xhtml#pg_792)
    for resources on this topic. Here’s the implementation of if_else from one of
    those resources, by Jonathan Heathcote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the conditional compilation directives, you can embed the if_else macro
    into the bodies of other macros. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Invoking this macro yields the string "macOS" or "Linux", depending on the compile-time
    value of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.9 Iteration with Macros
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The __VA_ARGS__ feature in CPP is useful for passing a group of arguments as
    a single argument. However, it would be nicer if we could process each argument
    in a varying parameter list one at a time by iterating through the list in order.
    Unfortunately, the CPP doesn’t provide any statements to support iteration. Because
    CPP doesn’t support recursion, we can’t even (directly) use recursion to handle
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you abuse the CPP a bit, a limited form of recursion is possible,
    as this section demonstrates. The ultimate goal of this section is to create a
    macro, let’s call it map, that will execute a single-argument macro on each argument
    in a varying parameter list. Ideally, you’d call map thusly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'and the map function would generate *n* calls to macroName:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following set of macros, along with the if_else macro from the previous
    section, provides this functionality (also from Heathcote; see section 13.8, “For
    More Information,” on [page 792](chapter13.xhtml#pg_792) for implementation details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The eval macro provides a limited amount of recursion on the macro you pass
    as an argument (up to 1,024 levels of recursion, which will allow for a varying
    parameter listing containing up to 1,024 entries). In order for the map macro
    to recurse, you must enclose it in an eval invocation. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The comma at the end of the inc macro is required because the invocations of
    inc will emit expressions of the form (1 + 1), (2 + 1), ..., (7 + 1) on the same
    line. The .byte directive requires commas between these expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the value 9 appears after the eval invocation. This is because
    the last expression, (7 + 1), will have a comma after it, so this statement must
    supply the last value manually. It would be possible to modify the map macro to
    emit this comma for all but the last argument, or you could modify the inc macro
    to check for a special sentinel value (such as a negative number) to terminate
    the list (without emitting the value or the comma).
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5.10 Command Line Defines
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you look back at the *build* shell script in section 1.10.1, “Assembling
    Programs Under Multiple OSes,” on [page 36](chapter1.xhtml#pg_36), you’ll see
    that GCC has a command line parameter that specifies the OS in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'These command line parameters are roughly equivalent to the following two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In many instances, you can refer to these definitions in your source file exactly
    as though you had placed these #define statements at the beginning of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, these parameters are *roughly* equivalent—not exactly equivalent—to
    the #define statements. Within macro bodies, these symbols might not be expanded
    as normal defined symbols would be. To use these symbols in macro bodies, it’s
    generally a good idea to explicitly create some #define symbols by using code
    such as the following, then refer to myIsLinux and myIsMacOS within your macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If you are compiling your Gas source files directly from the command line via
    gcc, you can define other symbols by using the -D command line option. See the
    GCC documentation for details. Note that the *build* script will not pass -D arguments
    to GCC, but you can easily modify *build* if you want to define other symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '13.2.5.11 The CPP #undef Statement'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The CPP allows you to forget a defined symbol by using the #undef statement'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'where identifier is a symbol previously defined with a #define statement. (If
    the symbol is undefined upon #undef execution, CPP will simply ignore the statement.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Undefining a symbol allows you to redefine it (for example, to give it another
    value). If you attempt to redefine a symbol without first undefining it, CPP will
    report an error.  ### 13.3 Components of the Gas CTL'
  prefs: []
  type: TYPE_NORMAL
- en: Gas’s CTL facilities are closer (than CPP) to what most assembly language programmers
    expect from a macro expansion system. Although CPP’s macro facilities are useful
    for certain purposes, macro assembly programming generally requires a much more
    powerful macro system. Therefore, learning Gas’s macro facilities is essential.
    This section covers the components of the Gas CTL.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.1 Errors and Warnings During Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Gas .err directive is similar to CPP #error. During assembly, Gas will
    display an error message (printing the source line containing the .err statement).
    Gas will not generate an object file if it encounters an .err directive. For example,
    the following generates an error message at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Gas also supports the .error directive. Its syntax is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The operand must be a string constant surrounded by quotes. During assembly,
    Gas will display the specified error message and will not generate an object file
    if it encounters an .error directive in the source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gas also supports a .warning directive similar to the CPP #warning statement,
    with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Again, the operand must be a string constant surrounded by quotes. If Gas encounters
    the .warning directive during assembly, it will display the specified warning
    message. If no errors are in the source files, only warnings, Gas will generate
    an object file. You can therefore use the .warning directive as an assembly-time
    print statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind the difference between the CPP #warning and #error statements
    and the Gas .warning and .error directives: the CPP statements execute during
    the preprocessor pass, prior to the assembly process, while the Gas directives
    execute after the preprocessor pass, during assembly. If there are any #error
    statements that execute, CPP will terminate the assembly process without running
    the assembler (so the Gas directives won’t execute in that situation).'
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.2 Conditional Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gas also supports a set of conditional assembly (or conditional compilation)
    directives similar to CPP’s #if/#endif statements. The basic directives are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As a general rule, you should prefer Gas’s conditional assembly directives
    in your source file over the CPP conditional compilation statements. Only use
    CPP’s conditional compilation statements when conditionally processing source
    code that contains other CPP statements (such as #define statements), or testing
    whether a symbol has been defined in CPP with the #ifdef or #ifndef statement.
    You cannot test whether a CPP symbol has been defined by using Gas’s conditional
    assembly statements because all CPP symbols will be expanded (and won’t be present)
    when Gas is assembling the source file.'
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean expression appearing after .if or .elseif must be an absolute expression
    (see “Relocatable and Absolute Expressions” on [page 176](chapter4.xhtml#pg_176)).
    Within conditional assembly expressions, false is a zero result and true is anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gas supports several variants of the .if directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '.ifdef symbol    Assembles the following section if symbol is defined prior
    to that point in the source file. CPP symbols (created with #define) are expanded
    prior to assembly, so their use may not work as expected in this directive.'
  prefs: []
  type: TYPE_NORMAL
- en: .ifb text    Assembles the following section if the operand field is blank.
    You generally use this directive to test for a blank macro parameter (text is
    typically a macro parameter name that could expand to the empty string).
  prefs: []
  type: TYPE_NORMAL
- en: .ifc text1**,** text2    Compares text1 to text2 and assembles the following
    section if they are equal. The string comparison ignores any whitespace around
    the text. The string text1 comprises all characters from the first non-whitespace
    character after .ifc up to the first comma. The string text2 is all text after
    the comma (ignoring leading whitespace) up to the end of the line (also ignoring
    whitespace at the end of the line). If you need to include whitespace in the string,
    you may optionally surround the strings with apostrophes (single quotes). Generally,
    you would use this statement to compare two macro parameter expansions to see
    if the parameters are equal.
  prefs: []
  type: TYPE_NORMAL
- en: .ifeq expression    Assembles the following code if expression is equal to 0.
  prefs: []
  type: TYPE_NORMAL
- en: .ifeqs "string1"**,** "string2"    Assembles the following code if the two strings
    are equal. The strings must be surrounded by double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: .ifge expression    Assembles the following code if expression is greater than
    or equal to 0.
  prefs: []
  type: TYPE_NORMAL
- en: .ifgt expression    Assembles the following code if expression is greater than
    0.
  prefs: []
  type: TYPE_NORMAL
- en: .ifle expression    Assembles the following code if expression is less than
    or equal to 0.
  prefs: []
  type: TYPE_NORMAL
- en: .iflt expression    Assembles the following code if expression is less than
    0.
  prefs: []
  type: TYPE_NORMAL
- en: .ifnb text    Assembles the following section if the operand field is not blank.
    You generally use this directive to test for a nonblank macro parameter (text
    is typically a macro parameter name).
  prefs: []
  type: TYPE_NORMAL
- en: .ifnc text1**,** text2    Compares text1 to text2 and assembles the following
    section if they are not equal. The string comparison ignores any whitespace around
    the text. The string text1 comprises all characters from the first non-whitespace
    character after .ifnc up to the first comma. The string text2 is all text after
    the comma (ignoring leading whitespace) up to the end of the line (also ignoring
    whitespace at the end of the line). If you need to include whitespace in the string,
    you may optionally surround the strings with apostrophes (single quotes). Generally,
    you would use this statement to compare two macro parameter expansions to see
    if the parameters are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: '.ifndef symbol**,** .ifnotdef symbol    Assembles the following section if
    symbol is not defined prior to that point in the source file. Note that CPP symbols
    (created with #define) get expanded prior to assembly, so their use may not work
    as expected in this directive. The .ifnotdef directive is a synonym for .ifndef.'
  prefs: []
  type: TYPE_NORMAL
- en: .ifne expression    Assembles the following code if expression is not equal
    to 0\. This directive is a synonym for .if.
  prefs: []
  type: TYPE_NORMAL
- en: .ifnes "string1"**,** "string2"    Assembles the following code if the two strings
    are not equal. The strings must be surrounded by double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional assembly statements in Gas may appear anywhere an instruction mnemonic
    is legal. Typically, they appear on a line by themselves, though it is legal (if
    unusual) for a label to appear on the same line. In that case, the label will
    be associated with the next instruction or directive that emits code.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Gas provides a wide variety of conditional assembly statements
    that are quite a bit more powerful and flexible than the CPP conditional compilation
    statements. This is another reason to use Gas’s conditional assembly statements
    over CPP’s.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 13.3.3 Compile-Time Loops'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike CPP, Gas’s CTL provides three looping constructs to easily generate
    data and unroll loops: .rept, .irp, and .irpc. The following subsections describe
    these directives.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.3.1 .rept....endr
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The .rept directive repeats a block of statements a fixed number of times.
    The syntax for this compile-time loop is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Gas will evaluate expression and repeat the block of statements between the
    .rept and .endr directives the specified number of times. If expression evaluates
    to 0, Gas will ignore all the statements up to the .endr, generating no code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will initialize a 32-element byte array with the values
    0 through 31:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You aren’t limited to data values in a .rept loop but can use .rept to unroll
    loops as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: which unrolls the loop eight times.
  prefs: []
  type: TYPE_NORMAL
- en: '##### 13.3.3.2 .irp....endr'
  prefs: []
  type: TYPE_NORMAL
- en: 'The .irp (indefinite repeat) looping directive takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This loop repeats for each item in comma-separated-list-of-values. In the body
    of the loop, you can refer to the current value by using \identifier; the following
    example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: which unrolls the loop for each .irp argument.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.3.3 .irpc....endr
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The third compile-time looping construct, .irpc, is similar to .irp but processes
    a string of text rather than a list of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, identifier is a symbol that will take on the value of each character in
    the string specified by text. Note that text is a bare sequence of characters;
    do not surround it by double or single quotes unless you want the .irpc loop to
    process those punctuation marks along with the other characters in the string.
    The .irpc loop will execute once for each character in the string, and \identifier
    will expand to that character on each iteration. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'expands to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note that \identifier expands even within character and string constants (as
    '\x' did in this example). In this example, had you not enclosed \x in single
    quotes, the .irpc loop would have expanded to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: which would have generated an error if the symbols a, c, d, and e were not defined
    somewhere in the program (I conveniently skipped b, which would have expanded
    to a branch instruction mnemonic).
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4 Gas Macros
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gas provides macro facilities via the .macro and .endm directives. The syntax
    for a macro definition is as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: where the {and} characters mean the parameter list is optional (you don’t include
    these characters in the macro definition). The following subsections describe
    the various components of a Gas macro, along with important semantic information
    concerning macros.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4.1 Macro Parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Macro parameters can take one of the following four forms:'
  prefs: []
  type: TYPE_NORMAL
- en: identifier    This first form, just a simple identifier, is the most common.
    Unless you supply one of the suffixes appearing in the other three options, this
    syntax tells Gas that the parameter is optional. If you do not supply an appropriate
    actual parameter value when invoking the macro, Gas will substitute the empty
    string (a blank parameter) when expanding the parameter in the macro’s body.
  prefs: []
  type: TYPE_NORMAL
- en: identifier=expression    Like the first form, this specifies a parameter that
    can be optional, except that Gas will give the identifier the value of the expression
    rather than an empty string if the macro invocation doesn’t supply a parameter
    value.
  prefs: []
  type: TYPE_NORMAL
- en: identifier:req    Specifies that the macro argument must be supplied when invoking
    the macro; if it is missing, Gas will respond with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: identifier:vararg    Allows for a varying parameter list (zero or more arguments
    separated by commas). Gas will expand this macro parameter to the entire list
    of values, including the commas separating the values.
  prefs: []
  type: TYPE_NORMAL
- en: In standard Gas syntax, a space separates the macro name and the first parameter
    (if any). I’ve found that with the ARM assembler, sneaking in a comma works fine
    too (your mileage may vary).
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a macro body, use a token of the form \identifier—where identifier is
    one of the macro’s declared formal parameters—to expand a parameter. For example,
    the following macro demonstrates the expansion of the value argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'A macro definition can have zero or more parameters. If you supply more than
    one parameter, you must separate each formal parameter with a comma. Additionally,
    if you specify a vararg parameter, it must be the last parameter declared in the
    .macro statement. Here’s an example of a slightly complex macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: When you invoke this macro, you must supply at least one actual parameter (because
    yy is a required parameter). For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'expands to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Note that if a data directive such as .byte does not have any operands, Gas
    will ignore that statement and not generate any code to the object file.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another invocation of bytes that demonstrates full argument expansion
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'which expands to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This example worked out well because the .byte directive allows comma-separated
    operands. However, what if you want to expand a vararg parameter where comma-separated
    operands are not legal? Consider the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: An invocation of addVals such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: will generate an error because
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'is syntactically incorrect. You can solve this problem by using an .irp loop
    inside the macro to process a vararg parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The addVals 1, 2 invocation will now emit the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Gas will expand a macro just about anywhere it appears within a macro body.
    Consider the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Assuming you’ve defined the var0 and var1 symbols somewhere, the invocation
    select 0 generates the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'while the invocation select 1 generates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to supply the prefix of the name, rather than the suffix,
    as the macro argument in this example. A first attempt at this won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem, of course, is that Gas interprets \whichvar as the expansion of
    a parameter named whichvar. To separate a parameter name from the following text,
    use the \() token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: An invocation such as select2 my will now properly expand to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: which creates the name myvar, as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4.2 Macro Parameters with String Constants
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Gas’s macros have a “feature” that can bite you if you’re not careful: if you
    pass a string constant as a formal parameter, Gas will strip the quotes from the
    string when expanding that parameter. For example, consider the following macro
    and invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This expands to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you’ve defined the symbol hello with an appropriate value, this will
    generate an error. The correct way to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This code properly generates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: One possible use for this is passing parameters that contain commas and whitespace
    as a single argument to a macro. I will leave it up to you to figure out other
    abuses of this “feature” in Gas. Personally, I consider it a bug, and I’d be afraid
    to use this feature because Gas could remove this behavior in a future version
    of the assembler.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4.3 Recursive Macros
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unlike CPP, Gas fully supports recursive macros. Consider the following example
    (adapted from the Gas manual):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'A macro invocation of the form sum 0, 5 generates the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The sum macro uses conditional assembly statements to prevent endless recursion.
    Though you could more easily iterate over five values by using the .rept (or .irp)
    directives, sometimes recursion is a better solution than iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The .irp and .rept directives are a better fit for simple iteration. Recursion
    is better for processing recursive data structures, such as lists and trees, passed
    as macro arguments, or if you need to reverse the arguments passed to a macro
    (I give an example of this in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4.4 The .exitm Directive
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The .exitm directive allows you to prematurely terminate the expansion of a
    macro. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'When Gas encounters .exitm during a macro expansion, it immediately stops the
    expansion and ignores the rest of the macro’s body. Of course, just placing an
    .exitm directive in the middle of a macro body (other than for testing purposes)
    is not especially useful—why write the rest of the macro body if it’s going to
    be ignored? Instead, you’ll generally find an .exitm macro inside a conditional
    assembly block like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The .exitm directive terminates recursion when the argument list is empty. The
    recursive invocation passes all but the first argument to reverse. As you may
    already have guessed, this macro will generate the bytes specified as parameters
    in reverse order to the file. For example, reverse 0, 1, 2, 3 generates
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: reversing the arguments passed to the reverse macro.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4.5 The \@ Operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Within a macro, Gas will convert the token \@ to a string of digits specifying
    the total number of macros it has expanded during assembly. You can use this operator,
    typically along with the \() token, to create macro-local symbols. The following
    macro provides a trivial example of this usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Multiple expansions of this macro generate a unique symbol by suffixing a string
    of digits to the end of a.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4.6 The .purgem Directive
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The .purgem directive deletes a previously defined Gas macro. It is similar
    to the CPP #undef statement. Normally, if you try to redefine a Gas macro, Gas
    will generate an error. Use the .purgem directive to delete the macro if you want
    to redefine it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that Gas will generate an error if you attempt to purge a macro that has
    not already been defined. Unfortunately, the .ifdef (and comparable) conditional
    assembly statement does not recognize macro symbols; so there is no way to check
    whether a macro has been defined before using the .purgem directive; you have
    to ensure that the macro symbol exists prior to using this directive.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4 The aoaa.inc Header File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, I’ve used the *aoaa.inc* header file in examples without
    discussing what it contains. Now that you’ve been introduced to CPP and Gas macro
    and CTL facilities, the time has come to fulfill my promise in [Chapter 1](chapter1.xhtml)
    that I would explain, section by section, how this header file works.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll go over the source code for *aoaa.inc* piece by piece, in order to annotate
    and explain each of its components. The first section is the usual header that
    appears at the beginning of an include file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'To begin, the *aoaa.inc* header file assumes that the source file that includes
    *aoaa.inc* is being assembled using the *build* shell script. Among other things,
    the *build* script will include one of the following command line options on the
    gcc command line that assembles the source file, as appropriate for the OS under
    which you’re running GCC (and Gas):'
  prefs: []
  type: TYPE_NORMAL
- en: -D isMacOS=1
  prefs: []
  type: TYPE_NORMAL
- en: -D isLinux=1
  prefs: []
  type: TYPE_NORMAL
- en: Because these symbols are defined for use by CPP (not Gas), the source file
    must have a *.S* suffix, and you must run the CPP on this file, meaning you need
    to assemble the file by running the gcc executable rather than the as (Gas) executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of the source file handles multiple inclusions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'This #ifndef and #define sequence is the standard way to prevent problems if
    a program includes a header file more than once. The first time CPP includes this
    file, the symbol aoaa_inc will not be defined; therefore, CPP will process the
    text after the #ifndef statement. The very next statement defines the aoaa_inc
    symbol. Should the assembly source file that included *aoaa.inc* include it a
    second time, the aoaa_inc symbol will be defined, so CPP will ignore everything
    up to the matching #endif (which happens to be at the end of the source file).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the earlier comment states, you must include the *aoaa.inc* header file
    by using the CPP statement #include, rather than Gas’s .include directive. This
    is because the *aoaa.inc* file contains several CPP statements (including #ifndef),
    and CPP will never see the *aoaa.inc* file if you include it via .include. Remember,
    Gas statements are processed long after CPP has executed and quit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the *aoaa.inc* header file sets up defines for various symbols to handle
    macOS- and Linux-specific code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This block of conditional compilation statements ensures that both isLinux and
    isMacOS are defined and are given appropriate values for the OS. The command line
    parameters supplied by the *build* script will define only one of these two symbols.
    These statements ensure that both are defined and are assigned appropriate Boolean
    values (0 for false, 1 for true).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, the *aoaa.inc* header file defines some symbols required under macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Under macOS, external symbols like the C stdlib function names have a leading
    underscore. Under Linux, the symbols appear without the underscore. The #define
    statements in the previous code snippet replace several common C stdlib function
    names with the underscore-prefixed version. This allows calls in this book to
    use consistent names under both macOS and Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These defines work only for the C stdlib functions appearing in this list.
    If you decide to call other stdlib functions (or use other external symbols),
    you’ll have to explicitly supply the underscore prefix character or add additional
    #define statements to this list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lea macro also has a macOS-specific implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: As noted in [Chapters 1](chapter1.xhtml) and [7](chapter7.xhtml), the lea macro
    expands to two instructions that load the address of a symbol into a 64-bit register.
    The main reason for including this macro (rather than explicitly writing these
    two instructions everywhere lea appears in this book) is that the two instructions
    are slightly different, depending on whether the code is being assembled for macOS
    or Linux. This version of the lea macro generates the code for macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up are the mstr, mstrb, and mstrh macros, which also have macOS-specific
    implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Linux and macOS handle varying parameter lists differently. Under Linux, you
    continue to pass the first eight parameters in X0 through X7, while under macOS,
    you pass them both in the registers and on the stack. The mstr, mstrb, and mstrh
    macros expand to code that stores a register onto the stack when operating under
    macOS (as you’ll see shortly, the Linux versions expand to nothing).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Clang assembler (the macOS version of Gas) does not support the .dword
    directive; the following macro implements this for macOS. Under macOS, the *aoaa.inc*
    header file therefore includes a macro to supply this missing directive, mapping
    it to the equivalent .quad directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier chapters used the vparmn macros to pass variables to the printf() function.
    Because the API for varying parameters differs between macOS and Linux, there
    are separate definitions for the two OSes. Here is their macOS implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Next come the Linux-specific implementations of these macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no #define statements for stdlib functions because Linux doesn’t
    require the underscore prefix character on external names. As for the parameter-related
    functions, Linux passes the first eight arguments of a varying parameter list
    only in the registers, not on the stack. The mstr, mstrb, and mstrh macros thus
    expand to nothing, while the vparmn macros expand to code without storing data
    on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the source file is common to both macOS and Linux. First,
    the *aoaa.inc* header file contains a few .global directives to specify public
    names for use by the C/C++ program that calls the assembly file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The printf definition, strictly speaking, isn’t necessary; it’s really just
    an external declaration, and undefined symbols are external by default. I added
    it simply because almost every sample program in this book calls the printf()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gas doesn’t actually provide a .qword directive. The .qword macro renames .octa
    to .qword to be consistent with .word and .dword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up in *aoaa.inc* are the definitions needed for the structure definition
    macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The __inStruct, __inArgs, __inLocals, and __dir compile-time variables maintain
    information needed to declare structure fields, parameters, and local variables
    by using the struct, args, and locals macros. The __in* variables are Booleans
    that track whether the program is currently defining a structure, a parameter
    list, or a set of local variables. Only one of these fields may contain true (nonzero)
    at a time, though they can all be 0 if you’re not declaring the field of any of
    these objects.
  prefs: []
  type: TYPE_NORMAL
- en: The __dir variable is either 1 or –1\. This determines whether successive declarations
    in these objects have increasing (when __dir is +1) or decreasing (when __dir
    is –1) offsets. Structures and parameters have increasing offsets, while locals
    have decreasing offsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those compile-time constants out of the way, here are the actual struct,
    args, and locals macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The struct, args, and locals macros allow you to define structures (records),
    parameter lists (arguments), and local variables. These macros set up some compile-time
    variables that track the base address of the object, as well as the direction,
    positive or negative, by which offsets are assigned to fields of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The struct macro ❶ creates structures (records) by associating a field offset
    with each member of the structure. The struct macro itself simply initializes
    the __inStruct, __dir, and name.base compile-time variables that maintain information
    needed when declaring fields of the structure (where name is the user-supplied
    structure name). The __struct_offset CTL maintains a “location counter” within
    the structure. By default, the struct macro initializes this with 0\. However,
    the person invoking struct can specify a negative value if they would like to
    specify that the first fields of the structure appear in memory before the structure’s
    base address. The __dir CTL is initialized with 1 because successive fields in
    a structure have increasing offsets within the structure.
  prefs: []
  type: TYPE_NORMAL
- en: The args macro ❷ declares parameter lists for a function or procedure, fundamentally
    the same operation as creating a structure; you are defining part of the activation
    record, after all. The only real difference is that the starting offset is 16
    (this is the offset of the first parameter in the activation record, using the
    base address specified by the FP register; the saved FP value and the return address
    consume the double words at offsets 0 and 8, respectively). Because parameters
    follow in higher addresses, the __dir field is initialized with 1.
  prefs: []
  type: TYPE_NORMAL
- en: The locals macro ❸ declares local variables allocated on the stack below the
    address held in the FP register. Because successive declarations appear at lower
    addresses in memory, this macro initializes the __dir field with –1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The macros for the matching ends, enda, and endl statements appear later in
    the listing. The following sections describe the data declaration macros that
    can appear inside a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The salign macro, which should appear only in a struct, args, or locals declaration,
    adjusts the __struct_offset value (the location counter) so that it is aligned
    at an offset that is a power of 2 (the power of 2 is specified by the parameter).
    This macro achieves its purpose by creating a bitmask containing size 0s in the
    LO bits and 1s in the remaining HO bits. Logically ANDing __struct_offset with
    this value produces an offset that is aligned to the designed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following macros provide the byte, hword, word, dword, qword, oword, single,
    and double directives for use in structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Each macro declares a single scalar or array variable of the specified type
    (you can specify an array by providing a second argument with the number of elements).
  prefs: []
  type: TYPE_NORMAL
- en: These macros will bump the current location counter, __struct_offset, by the
    size of the variable and assign that offset to the declared name. If __dir is
    negative (locals declarations), the macro first decrements the location counter,
    then assigns the offset to the name; if __dir is positive, the macro assigns the
    offset and increments the location counter value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the ends, enda, and endl macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The ends, enda, and endl macros complete a declaration begun by struct, args,
    or locals. They set to false the Boolean variable that is tracking an open structure,
    parameter list, or local variables declaration, then set the name.size equate
    to the total size of the declarations. The ends macro also defines a macro that
    you can use to declare structure objects in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wastr macro emits a word-aligned string to memory. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This macro is mainly used in .text sections because you must keep all code and
    labels word-aligned within those sections. Quotes must surround the macro parameter
    expansion because Gas will strip off the quotes you supply in the actual parameter
    (see section 13.3.4.2, “Macro Parameters with String Constants,” on [page 768](chapter13.xhtml#pg_768)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The proc and endp macros provide syntactical sugar for declaring procedures
    in an assembly language source file. Here is their implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Other than emitting the procedure name and (if isPublic is 1) the .global directive,
    this macro doesn’t really do much.
  prefs: []
  type: TYPE_NORMAL
- en: The public equate allows you to specify public as a second argument to this
    macro to tell the assembler to make the symbol global (that is, public). Technically,
    you could just pass 1 as the second argument, but public is more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .code macro simply expands to .text and ensures that the location counter
    is aligned on a word (4-byte) boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The enter and leave macros provide the standard entry and standard exit sequences
    for a procedure (see section 5.4.4, “Standard Entry Sequence,” on [page 248](chapter5.xhtml#pg_248)
    and section 5.4.5, “Standard Exit Sequence,” on [page 250](chapter5.xhtml#pg_250)
    for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'In rare circumstances, the b (branch) and b.al (branch always) instructions
    may generate an out-of-range error when the target location is too far away from
    the instruction. In those situations, you can use the goto macro to transfer control
    anywhere in the 64-bit address range of the ARM CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The goto macro modifies the values held in the X16 and X17 registers. The ARM
    API reserves these registers for exactly this purpose, so this is permissible.
    However, you should always remember that this macro modifies X16 and X17.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C stdlib provides the magic pointer __errno_location to return a pointer
    to C’s errno variable in X0\. The getErrno macro expands to a function call that
    retrieves this value and returns it in W0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The ccne through ccnle equates define useful bit patterns for use by the ccmp
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite branches are useful when writing code to simulate HLL-like control
    structures such as if/then/else statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The #endif statement terminates the #ifndef statement appearing at the very
    beginning of the source file.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Generating Macros by Another Macro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use one macro to write another, as the following code demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'As the comment states, this variant of the proc macro creates a new varProc
    macro you can use to invoke the procedure with HLL-like syntax. Consider the following
    invocation of this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'This expands to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the _someFunc macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: This generates the following code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: and then generates someFunc branches to printf, essentially making this a call
    to the printf() function.
  prefs: []
  type: TYPE_NORMAL
- en: You could have written a macro to invoke printf() directly (handling the arguments),
    but you’d have to write such a macro for every function you want to call using
    HLL-like syntax. Having the varProc macro automatically write this macro spares
    you this repetitive task.
  prefs: []
  type: TYPE_NORMAL
- en: The varProc macro has the severe limitation that its parameters must be global
    memory locations (no register, local variables, or other types of memory operands).
    While this macro may not be especially useful, it serves to demonstrate how one
    macro can write another. I’ll leave it as an exercise for you to expand this macro
    to handle other types of operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if a macro creates another macro, it must use an undefined name when
    creating the new macro. The examples in this section achieved this by having the
    invoker supply the new macro name as an argument to the macro that creates the
    new macro. It is also possible to use the .purgem directive to delete the new
    macro’s name prior to creating it. However, keep in mind that the macro name must
    already exist when using .purgem to delete it. On the first invocation of the
    creating macro, this could be a problem since the macro to create might not exist
    on the first invocation. This is easily remedied by providing an empty macro prior
    to the first invocation of the creating macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Because createdMacro already exists on the first invocation of createMacro,
    the .purgem statement will not generate an error message. After the first invocation,
    future invocations of createMacro will delete the version of createdMacro created
    in the previous invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Choosing Between Gas Macros and CPP Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Glancing at the GNU CPP documentation (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/cpp<wbr>/](https://gcc.gnu.org/onlinedocs/cpp/)*),
    you’ll find that the GNU folks suggest using the Gas built-in macro facilities
    rather than the CPP. If the people who wrote CPP and Gas suggest using the Gas
    macro processor rather than CPP, shouldn’t you take that suggestion seriously?
  prefs: []
  type: TYPE_NORMAL
- en: If you could use only one macro processor, you could make a strong case for
    using the Gas macro processor rather than CPP. CPP is not a very powerful macro
    processor, and macro abuse by C/C++ programmers has given it a bad reputation.
    Gas’s macro processor, in many respects, is clearly superior. Gas’s macro facilities
    would make the better choice between the two.
  prefs: []
  type: TYPE_NORMAL
- en: However, who says you have to use only one or the other? Why not both? CPP and
    Gas each have strengths and weaknesses that tend to be complementary. Although
    Gas’s macro facilities are more powerful than CPP’s, compared with other assemblers
    out there—such as the Microsoft Macro Assembler (MASM) or the High-Level Assembler
    (HLA)—Gas’s macro facilities aren’t particularly impressive. Anything you can
    use to boost the power of Gas’s macros is a good thing. CPP also has some neat
    features that Gas lacks (such as functional-style macro invocations), and Gas,
    of course, has many features that CPP lacks (such as multiline macro definitions).
    If you’re careful, using both macro processors gives you abilities above and beyond
    those of either. That’s a good thing, so combining the power of CPP and Gas is
    something I wholeheartedly recommend.
  prefs: []
  type: TYPE_NORMAL
- en: Given that you have two CTLs available to you when compiling a Gas source file
    (at least when using a *.S* suffix), which CTL constructs should you use? Most
    of the time, it doesn’t matter much; if either CTL would work, the choice is up
    to you, though sticking with Gas’s CTL is probably the safest choice if all other
    factors are equal. However, because the two have differing capabilities, at times
    you might need to pick one over the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, CPP’s macro definitions look like functions and can appear almost
    anywhere (outside of comments) in the source file. They are great for writing
    address expression functions. The following code demonstrates the use of functional-style
    CPP macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a Gas macro wouldn’t work because Gas macros don’t support
    functional-style invocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, CPP macros are limited to producing a single line of text.
    Therefore, Gas macros are necessary when you want to emit a sequence of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that CPP macros can cause you problems if you attempt to use the
    # symbol (stringify in CPP, immediate operand in Gas) in your macro expansion.'
  prefs: []
  type: TYPE_NORMAL
- en: Gas also supports a richer set of conditional assembly statements, along with
    CTL looping statements. This makes Gas more appropriate for macros that emit a
    large amount of data or a large number of statements. I generally prefer CPP macros
    for simple address expression functions and use Gas macros when I need to expand
    the macro to actual statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deciding whether to use CPP statements versus Gas’s .set, .equ, and = directives
    for simple constant declarations is less clear-cut. For simple integer constants,
    Gas’s equate directives work fine. For nonintegral values, CPP works better. The
    following example demonstrates defining string constants with CPP macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'For integer expressions, Gas’s equates tend to work better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, always keep in mind that CPP processes its CTL statements in a preprocessing
    pass before assembly takes place, meaning CPP is blissfully unaware of symbols
    and other tokens specific to the assembly language source file. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The #ifdef symbol would believe that the symbol a is undefined (even though
    it was defined earlier in the Gas source file). Remember, CPP conditional compilation
    statements know only about symbols created with #define statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.7 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Gas and CPP CTLs greatly expand the capabilities of the Gas assembler. Using
    these facilities, including constant definitions, macro definitions, conditional
    compilation and assembly, and so on, can reduce the effort you need to write assembly
    language source code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered the basic information you need to employ the Gas and CPP
    CTLs in your assembly language source files, beginning with a discussion of CPP.
    The second half of this chapter discussed the Gas CTL, including the error and
    warning directives, conditional assembly, compile-time looping directives, and
    Gas macros. Next, this chapter described the internal source code for the *aoaa.inc*
    header file that you’ve used extensively since [Chapter 1](chapter1.xhtml). The
    chapter concluded by contrasting the CPP CTL and the Gas macro facilities, discussing
    when you should pick one system over the other.
  prefs: []
  type: TYPE_NORMAL
- en: Now that this book has described the Gas CTL, its example code will begin to
    use the macro facilities, starting in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 13.8 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can review the GNU CPP documentation at *[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/cpp<wbr>/](https://gcc.gnu.org/onlinedocs/cpp/)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the Gas documentation (including macros) at *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_node<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_toc.html)*.
    For more on Gas macros in particular, see *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_node<wbr>/as<wbr>_107<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_107.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For information on advanced CPP macros, check out “C Pre-Processor Magic” by
    Jonathan Heathcote at *[http://<wbr>jhnet<wbr>.co<wbr>.uk<wbr>/articles<wbr>/cpp<wbr>_magic](http://jhnet.co.uk/articles/cpp_magic)*
    and *[https://<wbr>github<wbr>.com<wbr>/18sg<wbr>/uSHET<wbr>/blob<wbr>/master<wbr>/lib<wbr>/cpp<wbr>_magic<wbr>.h](https://github.com/18sg/uSHET/blob/master/lib/cpp_magic.h)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check the C Preprocessor Tricks, Tips, and Idioms GitHub site to find
    CPP tricks: *[https://<wbr>github<wbr>.com<wbr>/pfultz2<wbr>/Cloak<wbr>/wiki<wbr>/C<wbr>-Preprocessor<wbr>-tricks,<wbr>-tips,<wbr>-and<wbr>-idioms](https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the Boost CPP library at *[https://<wbr>www<wbr>.boost<wbr>.org<wbr>/doc<wbr>/libs<wbr>/1<wbr>_57<wbr>_0<wbr>/libs<wbr>/preprocessor<wbr>/doc<wbr>/index<wbr>.html](https://www.boost.org/doc/libs/1_57_0/libs/preprocessor/doc/index.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Embedded Artistry has an article on “Exploiting the Preprocessor for Fun and
    Profit” by Klemens Morgenstern: *[https://<wbr>embeddedartistry<wbr>.com<wbr>/blog<wbr>/2020<wbr>/07<wbr>/27<wbr>/exploiting<wbr>-the<wbr>-preprocessor<wbr>-for<wbr>-fun<wbr>-and<wbr>-profit<wbr>/](https://embeddedartistry.com/blog/2020/07/27/exploiting-the-preprocessor-for-fun-and-profit/)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about macro metaprogramming from Thomas Mailund’s blog at *[https://<wbr>mailund<wbr>.dk<wbr>/posts<wbr>/macro<wbr>-metaprogramming<wbr>/](https://mailund.dk/posts/macro-metaprogramming/)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
