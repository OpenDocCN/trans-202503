- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    WINDOWS KERNEL</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    内核</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: Windows is a secure, multiuser operating system. However, it’s also one of the
    most challenging modern operating systems to understand in detail. Before we delve
    into the intricacies of its security, in this part of the book I’ll provide you
    with an overview of the operating system’s structure. We’ll also take this opportunity
    to understand how to use the PowerShell module that will form the core of this
    book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 是一个安全的多用户操作系统。然而，它也是现代操作系统中最难以深入理解的系统之一。在我们深入探讨其安全性之前，本书的这一部分将为你提供操作系统结构的概述。我们还将借此机会了解如何使用本书核心的
    PowerShell 模块。
- en: 'We’ll consider the two parts of the running operating system: the kernel and
    the user-mode applications. The kernel makes the security decisions that determine
    what a user can do on the system. However, most of the applications you use on
    a Windows machine run in user mode. This chapter will focus on the kernel; the
    next chapter will focus on user-mode applications.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑运行中的操作系统的两个部分：内核和用户模式应用程序。内核做出决定，确定用户在系统上能做什么。然而，你在 Windows 机器上使用的大多数应用程序都运行在用户模式下。本章将重点介绍内核；下一章将重点讨论用户模式应用程序。
- en: In the following sections, we’ll examine the various subsystems that make up
    the Windows kernel. For each subsystem, I’ll explain its purpose and how it’s
    used. We’ll begin with the object manager, where we’ll also explore system calls,
    which allow a user-mode application to access kernel objects. We’ll then discuss
    the input/output manager, how applications are created through the process and
    thread manager, and how memory is represented with the memory manager. Throughout,
    I’ll outline how you can inspect the behavior of these subsystems using PowerShell.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论构成 Windows 内核的各个子系统。对于每个子系统，我将解释其用途以及如何使用它。我们将从对象管理器开始，同时探索系统调用，它们允许用户模式的应用程序访问内核对象。接着我们将讨论输入/输出管理器、通过进程和线程管理器创建应用程序的方式，以及内存管理器如何表示内存。整个过程中，我将概述如何使用
    PowerShell 检查这些子系统的行为。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows Kernel Executive</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Windows 内核执行</samp>
- en: The *Windows NTOS kernel executive*, or *kernel* for short, is the heart of
    Windows. It provides all the operating system’s privileged functionality, as well
    as interfaces through which the user applications can communicate with the hardware.
    The kernel is split into multiple subsystems, each with a dedicated purpose. [Figure
    2-1](chapter2.xhtml#fig2-1) shows a diagram of the components in which we’ll be
    most interested in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Windows NTOS 内核执行*，简称*内核*，是 Windows 的核心。它提供了操作系统的所有特权功能，并通过接口使用户应用程序能够与硬件进行通信。内核被划分为多个子系统，每个子系统都有其专门的功能。[图
    2-1](chapter2.xhtml#fig2-1)展示了我们在本书中最为关注的组件的示意图。'
- en: '![](../images/Figure2-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The Windows kernel
    executive modules</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：Windows 内核执行模块</samp>
- en: Each subsystem in the kernel executive exposes APIs for other subsystems to
    call. If you are looking at kernel code, you can quickly determine what subsystem
    each API belongs to using its two-character prefix. The prefixes for the subsystems
    in [Figure 2-1](chapter2.xhtml#fig2-1) are shown in [Table 2-1](chapter2.xhtml#tab2-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内核执行中的每个子系统都暴露了供其他子系统调用的 API。如果你正在查看内核代码，可以通过每个 API 的两个字符前缀迅速确定它属于哪个子系统。[图 2-1](chapter2.xhtml#fig2-1)中子系统的前缀在[表
    2-1](chapter2.xhtml#tab2-1)中有所展示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">API
    Prefix-to-Subsystem Mapping</samp>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-1：</samp> <samp class="SANS_Futura_Std_Book_11">API
    前缀与子系统映射</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Subsystem</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp> |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">前缀</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">子系统</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">示例</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> | <samp class="SANS_Futura_Std_Book_11">System
    call interface</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenFile</samp><samp
    class="SANS_Futura_Std_Book_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">ZwOpenFile</samp>
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Se</samp> | <samp class="SANS_Futura_Std_Book_11">Security
    Reference Monitor</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ob</samp> | <samp class="SANS_Futura_Std_Book_11">Object
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ps</samp> | <samp class="SANS_Futura_Std_Book_11">Process
    and thread manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PsGetCurrentProcess</samp>
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp> | <samp class="SANS_Futura_Std_Book_11">Configuration
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mm</samp> | <samp class="SANS_Futura_Std_Book_11">Memory
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MmMapIoSpace</samp>
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Io</samp> | <samp class="SANS_Futura_Std_Book_11">Input/output
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateFile</samp>
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ci</samp> | <samp class="SANS_Futura_Std_Book_11">Code
    integrity</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">CiValidateFileObject</samp>
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: We’ll explore all of these subsystems in the sections that follow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Security Reference Monitor</samp>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this book, the *Security Reference Monitor (SRM)* is the
    most important subsystem in the kernel. It implements the security mechanisms
    that restrict which users can access different resources. Without the SRM, you
    wouldn’t be able to prevent other users from accessing your files. [Figure 2-2](chapter2.xhtml#fig2-2)
    shows the SRM and its related system components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Components of the
    Security Reference Monitor</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Every process running on the system is assigned an *access token* when it’s
    created. This access token is managed by the SRM and defines the identity of the
    user associated with that process. The SRM can then perform an operation called
    an *access check*. This operation queries a resource’s security descriptor, compares
    it to the process’s access token, and either calculates the level of granted access
    or indicates that access is denied to the caller.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The SRM is also responsible for generating audit events whenever a user accesses
    a resource. Auditing is disabled by default due to the volume of events it can
    produce, so an administrator must enable it first. These audit events can be used
    to identify malicious behavior on a system as well as to diagnose security misconfigurations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SRM 还负责在用户访问资源时生成审计事件。由于它可能产生大量事件，默认情况下审计功能是禁用的，因此管理员必须首先启用它。这些审计事件可以用于识别系统上的恶意行为，并帮助诊断安全配置错误。
- en: The SRM expects users and groups to be represented as binary structures called
    *security identifiers (SIDs)*. However, passing around raw binary SIDs isn’t very
    convenient for users, who normally refer to users and groups by meaningful names
    (for example, the user *bob* or the *Users* group). These names need to be converted
    to SIDs before the SRM can use them. The task of name–SID conversion is handled
    by the *Local Security Authority Subsystem (LSASS)*, which runs inside a privileged
    process independent from any logged-in users.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SRM 期望用户和组被表示为称为*安全标识符 (SIDs)* 的二进制结构。然而，传递原始二进制 SID 对用户并不方便，因为用户通常通过有意义的名称（例如，用户
    *bob* 或 *Users* 组）来引用用户和组。在 SRM 使用这些名称之前，需要将它们转换为 SID。名称到 SID 的转换任务由 *本地安全权限子系统
    (LSASS)* 处理，它在一个与任何登录用户独立的特权进程中运行。
- en: It’s infeasible to represent every possible SID as a name, so Microsoft defines
    the *Security Descriptor Definition Language (SDDL)* format to represent a SID
    as a string. SDDL can represent the entire security descriptor of a resource,
    but for now we’ll just use it to represent the SID. In [Listing 2-1](chapter2.xhtml#Lis2-1),
    we use PowerShell to look up the *Users* group name using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    command; this should retrieve the SDDL string for the SID.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法将每个可能的 SID 表示为名称，因此 Microsoft 定义了*安全描述符定义语言 (SDDL)* 格式，用于将 SID 表示为字符串。SDDL
    可以表示资源的整个安全描述符，但目前我们仅使用它来表示 SID。在[列表 2-1](chapter2.xhtml#Lis2-1)中，我们使用 PowerShell
    通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> 命令查找 *Users*
    组的名称；这应该会检索该 SID 的 SDDL 字符串。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: Querying the SID of the <samp class="SANS_Futura_Std_Book_11">Users</samp>
    group using Get-NtSid'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-1：使用 Get-NtSid 查询 *Users* 组的 SID
- en: 'We pass the name of the *Users* group to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>,
    which returns the fully qualified name, with the local domain *BUILTIN* attached.
    The *BUILTIN\Users* SID is always the same between different Windows systems.
    The output also contains the SID in SDDL format, which can be broken down into
    the following dash-separated parts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 *Users* 组的名称传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>，它返回完全限定的名称，并附加上本地域
    *BUILTIN*。*BUILTIN\Users* SID 在不同的 Windows 系统之间始终相同。输出还包含 SID 的 SDDL 格式，它可以分解为以下破折号分隔的部分：
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp> character prefix.
    This indicates that what follows is an SDDL SID.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp>字符前缀。这表示接下来的内容是一个 SDDL
    SID。
- en: The version of the SID structure in decimal. This has a fixed value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SID 结构的十进制版本。其固定值为<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。
- en: The security authority. Authority <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    indicates the built-in NT authority.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全权限。权限<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>表示内置的 NT 权限。
- en: Two relative identifiers (RIDs), in decimal. The RIDs (here, <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">545</samp>) represent the NT
    authority group.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个相对标识符 (RIDs)，以十进制表示。RIDs（这里是 <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">545</samp>）表示 NT 权限组。
- en: We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    to perform the reverse operation, converting an SDDL SID back to a name, as shown
    in [Listing 2-2](chapter2.xhtml#Lis2-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> 执行反向操作，将
    SDDL SID 转换回名称，如[列表 2-2](chapter2.xhtml#Lis2-2)所示。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: Using Get-NtSid to find the name associated with a SID'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-2：使用 Get-NtSid 查找与 SID 关联的名称
- en: I’ll describe the SRM and its functions in much greater depth in [Chapters 4](chapter4.xhtml)
    through [9](chapter9.xhtml), and we’ll revisit the SID structure in [Chapter 5](chapter5.xhtml),
    when we discuss security descriptors. For now, remember that SIDs represent users
    and groups and that we can represent them as strings in SDDL form. Next, we’ll
    move on to another of the core Windows kernel executive subsystems, the object
    manager.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第4章](chapter4.xhtml)到[第9章](chapter9.xhtml)中更深入地描述SRM及其功能，并且在[第5章](chapter5.xhtml)中，我们会在讨论安全描述符时重新访问SID结构。现在，请记住，SID代表用户和组，我们可以将其表示为SDDL格式的字符串。接下来，我们将继续介绍Windows内核执行子系统中的另一个核心组件——对象管理器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Object Manager</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象管理器</samp>
- en: On Unix-like operating systems, everything is a file. On Windows, everything
    is an object, meaning that every file, process, and thread is represented in kernel
    memory as an object structure. Importantly for security, each of these objects
    can have an assigned security descriptor, which restricts which users can access
    the object and determines the type of access they have (for example, read or write).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix操作系统中，一切都是文件。而在Windows中，一切都是对象，这意味着每个文件、进程和线程都在内核内存中作为对象结构表示。对于安全性来说非常重要的是，每个对象都可以有一个分配的安全描述符，它限制了哪些用户可以访问该对象，并确定他们的访问权限类型（例如，读或写）。
- en: The *object manager* is the component of the kernel responsible for managing
    these resource objects, their memory allocations, and their lifetimes. In this
    section, we’ll first discuss the types of objects the object manager supports.
    Then, we’ll explore how kernel objects can be opened through a naming convention
    using a system call. Finally, we’ll look at how to use a handle returned by the
    system call to access the object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象管理器*是内核中负责管理这些资源对象、它们的内存分配和生命周期的组件。在本节中，我们将首先讨论对象管理器支持的对象类型。然后，我们将探讨如何通过命名约定使用系统调用打开内核对象。最后，我们将看看如何使用系统调用返回的句柄访问该对象。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Types</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象类型</samp>
- en: The kernel maintains a list of all the types of objects it supports. This is
    necessary, as each object type has different supported operations and security
    properties. [Listing 2-3](chapter2.xhtml#Lis2-3) shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>
    command to list all supported types in the kernel.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护着它支持的所有对象类型的列表。这是必要的，因为每种对象类型具有不同的支持操作和安全属性。[列表 2-3](chapter2.xhtml#Lis2-3)展示了如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>命令列出内核中所有支持的类型。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: Executing Get-NtType'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：执行 Get-NtType
- en: I’ve truncated the list of types (the machine I’m using supports 72 of them),
    but there are some noteworthy entries even in this short section. The first entry
    in the generated list is <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>;
    even the list of kernel types is built from objects! Other types of note here
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>,
    which represent the kernel objects for a process and a thread, respectively. We’ll
    examine other object types in more detail later in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经截断了类型列表（我使用的机器支持72种类型），但即使在这个简短的部分中，也有一些值得注意的条目。生成的列表中的第一个条目是<samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>；即使是内核类型的列表也是由对象构建的！这里还有其他值得注意的类型，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>，分别表示进程和线程的内核对象。我们将在本章稍后部分更详细地探讨其他对象类型。
- en: You can display the properties of a type with <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>,
    which returns additional information about that type. We’ll look at an example
    later, but for now the question is how to access each of these types. To answer
    it, we’ll need to talk about the object manager namespace.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>显示类型的属性，它会返回该类型的附加信息。稍后我们会看一个例子，但现在的问题是如何访问这些类型。为了回答这个问题，我们需要讨论对象管理器命名空间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Object Manager
    Namespace</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象管理器命名空间</samp>
- en: As a user of Windows, you typically see your filesystem drives in Explorer.
    But underneath the user interface is a whole additional filesystem just for kernel
    objects. Access to this filesystem, referred to as the *object manager namespace
    (OMNS)*, isn’t very well documented or exposed to most developers, which makes
    it even more interesting.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Windows 用户，你通常在资源管理器中看到你的文件系统驱动。然而，在用户界面下方，实际上还有一个专门为内核对象设计的额外文件系统。对这个文件系统的访问，称为
    *对象管理器命名空间 (OMNS)*，大多数开发人员都没有详细文档或直接访问权限，这使得它更加有趣。
- en: The OMNS is built out of <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects. The objects act as if they were in a filesystem, so each directory contains
    other objects, which you can consider to be files. However, they are distinct
    from the file directories you’re used to. Each directory is configured with a
    security descriptor that determines which users can list its contents and which
    users can create new subdirectories and objects inside it. You can specify the
    full path to an object with a backslash-separated string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OMNS 是由 <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> 对象构建的。这些对象的行为类似于文件系统，因此每个目录都包含其他对象，你可以将它们视为文件。然而，它们与你熟悉的文件目录不同。每个目录都配置了一个安全描述符，用于确定哪些用户可以列出其内容，哪些用户可以在其中创建新的子目录和对象。你可以使用反斜杠分隔的字符串指定对象的完整路径。
- en: We can enumerate the OMNS by using a drive provider that is part of this book’s
    PowerShell module. As shown in [Listing 2-4](chapter2.xhtml#Lis2-4), this exposes
    the OMNS as if it were a filesystem by listing the *NtObject* drive.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用本书 PowerShell 模块中的驱动提供程序来枚举 OMNS。如[示例 2-4](chapter2.xhtml#Lis2-4)所示，这将
    OMNS 显示为一个文件系统，通过列出 *NtObject* 驱动。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: Listing the root OMNS directory'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-4：列出根 OMNS 目录
- en: '[Listing 2-4](chapter2.xhtml#Lis2-4) shows a short snippet of the root OMNS
    directory. By default, this output includes the name of each object and its type.
    We can see a few <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects; you can list them if you have permission to do so. We can also see another
    important type, <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>.
    You can use symbolic links to redirect one OMNS path to another. A <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>
    object contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    property, which itself contains the target that the link should open. For example,
    [Listing 2-5](chapter2.xhtml#Lis2-5) shows the target for a symbolic link in the
    root of the OMNS.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-4](chapter2.xhtml#Lis2-4)展示了根 OMNS 目录的简短片段。默认情况下，输出包括每个对象的名称及其类型。我们可以看到几个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> 对象；如果你有权限，可以列出它们。我们还可以看到另一个重要的类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>。你可以使用符号链接将一个 OMNS
    路径重定向到另一个路径。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>
    对象包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    属性，它本身包含该链接应打开的目标。例如，[示例 2-5](chapter2.xhtml#Lis2-5)展示了 OMNS 根目录中符号链接的目标。'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: Showing the target of a symbolic link'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-5：显示符号链接的目标
- en: Here, we list the *\Dfs* OMNS path, then extract the <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    property to get the real target. Next, we check the target path, *Device\DfsClient*,
    to show it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> type,
    which is what the symbolic link can be used to access.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出 *\Dfs* OMNS 路径，然后提取 <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    属性以获取实际目标。接着，我们检查目标路径 *Device\DfsClient*，以展示它是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    类型，这也是符号链接可以用来访问的内容。
- en: Windows preconfigures several important object directories, shown in [Table
    2-2](chapter2.xhtml#tab2-2).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 预先配置了几个重要的对象目录，见[表 2-2](chapter2.xhtml#tab2-2)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</samp> <samp class="SANS_Futura_Std_Book_11">Well-Known
    Object Directories and Descriptions</samp>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-2：</samp> <samp class="SANS_Futura_Std_Book_11">已知对象目录及描述</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">路径</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\BaseNamedObjects</samp>
    | <samp class="SANS_Futura_Std_Book_11">Global directory for user objects</samp>
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\BaseNamedObjects</samp>
    | <samp class="SANS_Futura_Std_Book_11">用户对象的全局目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Device</samp> | <samp class="SANS_Futura_Std_Book_11">Directory
    containing devices such as mounted filesystems</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Device</samp> | <samp class="SANS_Futura_Std_Book_11">包含诸如已挂载文件系统等设备的目录</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\GLOBAL??</samp> | <samp
    class="SANS_Futura_Std_Book_11">Global directory for symbolic links, including
    drive mappings</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\GLOBAL??</samp> | <samp
    class="SANS_Futura_Std_Book_11">符号链接的全局目录，包括驱动器映射</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\KnownDlls</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory containing special, known DLL mappings</samp>
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\KnownDlls</samp> | <samp
    class="SANS_Futura_Std_Book_11">包含特殊已知 DLL 映射的目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\ObjectTypes</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory containing named object types</samp>
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\ObjectTypes</samp> | <samp
    class="SANS_Futura_Std_Book_11">包含命名对象类型的目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Sessions</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory for separate console sessions</samp>
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Sessions</samp> | <samp
    class="SANS_Futura_Std_Book_11">用于单独控制台会话的目录</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Windows</samp> | <samp class="SANS_Futura_Std_Book_11">Directory
    for objects related to the Window Manager</samp> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Windows</samp> | <samp class="SANS_Futura_Std_Book_11">与窗口管理器相关的对象目录</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\RPC Control</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory for remote procedure call endpoints</samp>
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\RPC Control</samp> | <samp
    class="SANS_Futura_Std_Book_11">远程过程调用端点的目录</samp> |'
- en: The first directory in [Table 2-2](chapter2.xhtml#tab2-2), *BaseNamedObjects
    (BNO)*, is important in the context of the object manager. It allows any user
    to create named kernel objects. This single directory allows the sharing of resources
    between different users on the local system. Note that you don’t have to create
    objects in the BNO directory; it’s only a convention.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](chapter2.xhtml#tab2-2) 中的第一个目录，*BaseNamedObjects (BNO)*，在对象管理器的上下文中非常重要。它允许任何用户创建命名的内核对象。这个单一的目录允许在本地系统的不同用户之间共享资源。请注意，你不必在
    BNO 目录中创建对象；这仅仅是一种约定。'
- en: I’ll describe the other object directories in more detail later in this chapter.
    For now, you can list them in PowerShell by prefixing the path with *NtObject:*,
    as I’ve shown in [Listing 2-5](chapter2.xhtml#Lis2-5).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章稍后更详细地描述其他对象目录。现在，你可以通过在路径前加上*NtObject:*来列出它们，正如我在[示例 2-5](chapter2.xhtml#Lis2-5)中所示。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">System Calls</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">系统调用</samp>
- en: How can we access the named objects in the OMNS from a user-mode application?
    If we’re in a user-mode application, we need the kernel to access the objects,
    and we can call kernel-mode code in a user-mode application using the system call
    interface. Most system calls perform some operation on a specific type of kernel
    object exposed by the object manager. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, a mutual exclusion primitive used for locking and thread synchronization.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在用户模式应用程序中访问 OMNS 中的命名对象？如果我们处于用户模式应用程序中，需要通过内核来访问这些对象，我们可以通过系统调用接口在用户模式应用程序中调用内核模式代码。大多数系统调用会对对象管理器暴露的特定类型的内核对象执行某些操作。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp> 系统调用创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    对象，这是一个用于锁定和线程同步的互斥原语。
- en: The name of a system call follows a common pattern. It starts with either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>.
    For user-mode callers, the two prefixes are equivalent; however, if the system
    call is invoked by code executing in the kernel, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    prefix changes the security checking process. We’ll come back to the implications
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> prefix in [Chapter
    7](chapter7.xhtml), when we talk about access modes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用的名称遵循一种常见的模式。它以<samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>开头。对于用户模式调用者，这两个前缀是等效的；然而，如果系统调用由在内核中执行的代码调用，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>前缀会改变安全检查过程。我们将在[第7章](chapter7.xhtml)中讨论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>前缀的影响，届时我们会讲到访问模式。
- en: 'After the prefix comes the operation’s verb: <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp>,
    in the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>.
    The rest of the name relates to the kernel object type the system call operates
    on. Common system-call verbs that perform an operation on a kernel object include:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀之后是操作的动词：在<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>的情况下是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Create</samp>。名称的其余部分与系统调用操作的内核对象类型相关。常见的系统调用动词包括：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Create  </samp>Creates a new object.
    Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Nt</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp>
    PowerShell commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Create  </samp>创建一个新对象。映射到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">New-Nt</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp>
    PowerShell命令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Open  </samp>Opens an existing
    object. Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Nt</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp> PowerShell commands.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Open  </samp>打开现有对象。映射到<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Nt</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp> PowerShell命令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryInformation  </samp>Queries
    object information and properties.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryInformation  </samp>查询对象信息和属性。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetInformation  </samp>Sets object
    information and properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetInformation  </samp>设置对象信息和属性。
- en: Certain system calls perform type-specific operations. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryFile</samp>
    is used to query the entries in a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object directory. Let’s look at the C-language prototype for the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call to understand what parameters need to be passed to a typical call.
    As shown in [Listing 2-6](chapter2.xhtml#Lis2-6), the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 某些系统调用执行特定类型的操作。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryFile</samp>用于查询<samp
    class="SANS_TheSansMonoCd_W5Regular_11">File</samp>对象目录中的条目。让我们看一下<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>系统调用的C语言原型，以理解典型调用需要传递哪些参数。如[清单2-6](chapter2.xhtml#Lis2-6)所示，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>系统调用创建一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象。
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: The C prototype for NtCreateMutant'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-6：NtCreateMutant的C语言原型
- en: The first parameter for the system call is an outbound pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>.
    Common in many system calls, this parameter is used to retrieve an opened handle
    to the object (in this case, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>)
    when the function succeeds. We use handles along with other system calls to access
    properties and perform operations. In the case of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, the handle allows us to acquire and release the lock to synchronize threads.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用的第一个参数是指向<samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>的输出指针。许多系统调用中都常见此参数，它用于在函数成功时检索已打开的对象句柄（在此情况下是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>）。我们使用句柄与其他系统调用一起访问属性并执行操作。在我们的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>对象的例子中，句柄允许我们获取和释放锁，以便同步线程。
- en: Next is <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>,
    which represents the operations the caller wants to be able to perform on the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> using the handle.
    For example, we could request access that allows us to wait for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    to be unlocked. If we didn’t request that access, any application that tried to
    wait on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> would
    immediately fail. The access granted depends on the results of the SRM’s access
    check. We’ll discuss handles and <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    in more detail in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>，它表示调用者希望对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 句柄执行的操作。例如，我们可以请求允许我们等待
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 解锁的访问权限。如果我们没有请求该权限，任何尝试等待
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> 的应用程序将立即失败。授予的访问权限取决于
    SRM 访问检查的结果。我们将在下一节中更详细地讨论句柄和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>。
- en: Third is the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAttributes</samp>
    parameter, which defines the attributes for the object to open or create. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> structure
    is defined as shown in [Listing 2-7](chapter2.xhtml#Lis2-7).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAttributes</samp>，它定义了要打开或创建的对象的属性。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> 结构的定义请参见 [列表
    2-7](chapter2.xhtml#Lis2-7)。
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-7: The OBJECT_ATTRIBUTES structure'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-7：OBJECT_ATTRIBUTES 结构
- en: This C-language structure starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>,
    which represents the length of the structure. Specifying the structure length
    at the start is a common C-style idiom to ensure that the correct structure has
    been passed to the system call.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 C 语言结构从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> 开始，表示结构的长度。在开始时指定结构长度是
    C 风格常见的写法，用来确保正确的结构已经传递到系统调用中。
- en: Next come <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These are
    taken together, as they indicate how the system call should look up the resource
    being accessed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    is a handle to an opened kernel object to use as the base for looking up the object.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> field is a
    pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    structure. This is a counted string, defined in [Listing 2-8](chapter2.xhtml#Lis2-8)
    as a C-language structure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>。这两个参数一起使用，因为它们指示系统调用应该如何查找正在访问的资源。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> 是一个已打开内核对象的句柄，用作查找对象的基准。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> 字段是指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    结构的指针。该结构是一个计数字符串，定义在 [列表 2-8](chapter2.xhtml#Lis2-8) 中，作为 C 语言结构。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 2-8: The UNICODE_STRING structure'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-8：UNICODE_STRING 结构
- en: The structure references the string data through <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>,
    which is a pointer to an array of 16-bit Unicode characters. The string is represented
    in UCS-2 encoding; Windows predates many of the changes to Unicode, such as UTF-8
    and UTF-16.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 引用字符串数据，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 是指向 16 位 Unicode 字符数组的指针。该字符串以
    UCS-2 编码表示；Windows 在 Unicode 许多变化（如 UTF-8 和 UTF-16）之前就已经存在。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> structure
    also contains two length fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumLength</samp>. The first
    length field represents the total valid length of the string pointed to by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes (not in Unicode
    characters). If you’re coming from a C programming background, this length does
    not include any NUL terminating character. In fact, a NUL character is permitted
    in object names.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> 结构还包含两个长度字段：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumLength</samp>。第一个长度字段表示由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 指向的字符串的有效总长度，以字节为单位（而不是
    Unicode 字符）。如果你有 C 语言编程背景，注意这个长度不包括任何 NUL 终止字符。事实上，NUL 字符在对象名称中是允许的。
- en: The second length field represents the maximum length of the string pointed
    to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes. Because
    the structure has two separate lengths, it’s possible to allocate an empty string
    with a large maximum length and a valid length of zero, then update the string
    value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> pointer.
    Note that the lengths are stored as <samp class="SANS_TheSansMonoCd_W5Regular_11">USHORT</samp>
    values, which are unsigned 16-bit integers. Coupled with the length-representing
    bytes, this means a string can be at most 32,767 characters long.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个长度字段表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 所指向的字符串的最大长度（以字节为单位）。由于结构体有两个独立的长度字段，因此可以分配一个空字符串，具有较大的最大长度和有效长度为零，然后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 指针更新字符串值。请注意，长度以 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">USHORT</samp> 值存储，这是无符号的16位整数。结合表示长度的字节，这意味着字符串的最大长度为
    32,767 个字符。
- en: 'To specify the name of an object, you have two options: you can set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    to an absolute path of, for example, *\BaseNamedObjects\ABC*, or you can set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object for *\BaseNamedObjects* and then pass <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These
    two actions will open the same object.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定一个对象的名称，您有两种选择：您可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    设置为绝对路径，例如 *\BaseNamedObjects\ABC*，或者您可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp> 对象，为 *\BaseNamedObjects*，然后将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    传递。这两种操作都会打开相同的对象。
- en: Returning to [Listing 2-7](chapter2.xhtml#Lis2-7), after the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    parameter comes <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>,
    which is a set of flags to modify the object name lookup process or change the
    returned handle’s properties. [Table 2-3](chapter2.xhtml#tab2-3) shows the valid
    values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    field.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 [清单 2-7](chapter2.xhtml#Lis2-7)，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    参数之后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>，它是一组标志，用于修改对象名称查找过程或更改返回句柄的属性。[表
    2-3](chapter2.xhtml#tab2-3) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    字段的有效值。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">Object
    Attribute Flags and Descriptions</samp>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">对象属性标志和描述</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell 名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as inheritable.</samp> |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> | <samp class="SANS_Futura_Std_Book_11">将句柄标记为可继承。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Permanent</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as permanent.</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Permanent</samp> | <samp class="SANS_Futura_Std_Book_11">将句柄标记为永久。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Exclusive</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as exclusive if creating a new object. Only the same process can open
    a handle to the object.</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Exclusive</samp> | <samp class="SANS_Futura_Std_Book_11">如果创建新对象，则将句柄标记为独占。只有相同的进程可以打开该对象的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseInsensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Looks up the object name in a case-insensitive
    manner.</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseInsensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">以不区分大小写的方式查找对象名称。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenIf</samp> | <samp class="SANS_Futura_Std_Book_11">If
    using a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp> <samp
    class="SANS_Futura_Std_Book_11">call, opens a handle to an existing object if
    available.</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenIf</samp> | <samp class="SANS_Futura_Std_Book_11">如果使用</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp> <samp class="SANS_Futura_Std_Book_11">调用，则如果存在，则打开现有对象的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenLink</samp> | <samp class="SANS_Futura_Std_Book_11">Opens
    the object if it’s a link to another object; otherwise, follows the link. This
    is used only by the configuration manager.</samp> |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp> | <samp
    class="SANS_Futura_Std_Book_11">Opens the handle as a kernel handle when used
    in kernel mode. This prevents user-mode applications from accessing the handle
    directly.</samp> |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp> | <samp
    class="SANS_Futura_Std_Book_11">When used in kernel mode, ensures all access checks
    are performed, even if calling the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    <samp class="SANS_Futura_Std_Book_11">version of the system call.</samp> |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IgnoreImpersonatedDeviceMap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Disables the device map when impersonating.</samp>
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DontReparse</samp> | <samp
    class="SANS_Futura_Std_Book_11">Indicates not to follow any path that contains
    a symbolic link.</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: The final two fields in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure allow the caller to specify the Security Quality of Service (SQoS) and
    security descriptor for the object. We’ll come back to SQoS in [Chapter 4](chapter4.xhtml)
    and the security descriptor in [Chapter 5](chapter5.xhtml).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Next in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call in [Listing 2-6](chapter2.xhtml#Lis2-6) is the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp>
    Boolean parameter, which is specific to this type. In this case, it represents
    whether the created <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    is owned by the caller or not. Many other system calls, especially for files,
    have more complex parameters, which we’ll discuss in more detail later in the
    book.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTSTATUS Codes</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All system calls return a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code. This status code is composed of multiple components packed into the 32 bits,
    as shown in [Figure 2-3](chapter2.xhtml#fig2-3).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The NT status code
    structure</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The most significant two bits (31 and 30) indicate the *severity* of the status
    code. [Table 2-4](chapter2.xhtml#tab2-4) shows the available values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-4:</samp> <samp class="SANS_Futura_Std_Book_11">NT
    Status Severity Codes</samp>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Severity name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_SUCCESS</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_SUCCESS</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_INFORMATIONAL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_INFORMATIONAL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_WARNING</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_WARNING</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_ERROR</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_ERROR</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> |'
- en: If the severity level indicates a warning or error, then bit 31 of the status
    code will be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. If
    the status code is treated as a signed 32-bit integer, this bit represents a negative
    value. It’s a common coding practice to assume that if the status code is negative
    it represents an error, and if it’s positive it represents a success. As we can
    see from the table, this assumption isn’t completely true—the negative status
    code could also be a warning—but it works well enough in practice.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果严重性级别指示一个警告或错误，则状态码的第31位将被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。如果状态码被视为一个带符号的32位整数，这一位表示一个负值。常见的编码实践是认为，如果状态码为负，则表示错误；如果为正，则表示成功。从表格中可以看出，这个假设并不完全正确——负状态码也可能是警告——但在实践中通常足够有效。
- en: The next component in [Figure 2-3](chapter2.xhtml#fig2-3), *CC*, is the customer
    code. This is a single-bit flag that indicates whether the status code is defined
    by Microsoft (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>)
    or defined by a third party (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    Third parties are not obliged to follow this specification, so don’t treat it
    as fact.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-3](chapter2.xhtml#fig2-3)中的下一个组件，*CC*，是客户代码。它是一个单比特标志，用于指示状态码是由微软定义的（值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>），还是由第三方定义的（值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>）。第三方并没有义务遵循这个规范，因此不能将其视为事实。'
- en: Following the customer code is the *R* bit, a reserved bit that must be set
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随客户代码的是 *R* 位，这是一个保留位，必须设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: The next 12 bits indicate the *facility*—that is, the component or subsystem
    associated with the status code. Microsoft has predefined around 50 facilities
    for its own purposes. Third parties should define their own facility and combine
    it with the customer code to distinguish themselves from Microsoft. [Table 2-5](chapter2.xhtml#tab2-5)
    shows a few commonly encountered facilities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的12位表示 *facility* ——即与状态码相关的组件或子系统。微软已经为自己的目的预定义了约50个facility。第三方应定义自己的facility，并将其与客户代码结合，以便与微软区分开来。[表2-5](chapter2.xhtml#tab2-5)展示了一些常见的facility。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-5:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Status Facility Values</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表2-5：</samp> <samp class="SANS_Futura_Std_Book_11">常见状态facility值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Facility name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Facility名称</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">值</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEFAULT</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">The
    default used for common status codes</samp> |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEFAULT</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">用于常见状态码的默认值</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEBUGGER</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">Used
    for codes associated with the debugger</samp> |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEBUGGER</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">用于与调试器相关的代码</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_NTWIN32</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Used
    for codes that originated from the Win32 APIs</samp> |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: The final component, the *status code*, is a 16-bit number chosen to be unique
    for the facility. It’s up to the implementer to define what each number means.
    The PowerShell module contains a list of known status codes, which we can query
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp> command
    with no parameters ([Listing 2-9](chapter2.xhtml#Lis2-9)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 2-9: Example output from Get-NtStatus'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Notice how some status values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PENDING</samp>,
    have a human-readable message. This message isn’t embedded in the PowerShell module;
    instead, it’s stored inside a Windows library and can be extracted at runtime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: When we call a system call via a PowerShell command, its status code is surfaced
    through a .NET exception. For example, if we try to open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object that doesn’t exist, we’ll see the exception shown in [Listing 2-10](chapter2.xhtml#Lis2-10)
    displayed in the console.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 2-10: An NTSTATUS exception generated when trying to open a nonexistent
    directory'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-10](chapter2.xhtml#Lis2-10), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp>
    to open the nonexistent path *THISDOESNOTEXIST*. This generates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS
    0xC0000034</samp> exception, shown here along with the decoded message ❶. If you
    want more information about the status code, you can pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp>
    and format the output as a list to view all its properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Facility</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Severity</samp>. The NT status
    code is an unsigned integer value; however, it’s common to also see it printed
    (incorrectly) as a signed value ❷.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Handles</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The object manager deals with pointers to kernel memory. A user-mode application
    cannot directly read or write to kernel memory, so how can it access an object?
    It does this using the handle returned by a system call, as discussed in the previous
    section. Each running process has an associated *handle table* containing three
    pieces of information:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The handle’s numeric identifier
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The granted access to the handle; for example, read or write
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pointer to the object structure in kernel memory
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the kernel can use a handle, the system call implementation must look
    up the kernel object pointer from the handle table using a kernel API such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>.
    By providing this handle indirectly, a kernel component can return the handle
    number to the user-mode application without exposing the kernel object directly.
    [Figure 2-4](chapter2.xhtml#fig2-4) shows the handle lookup process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-4.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: The handle table
    lookup process</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-4](chapter2.xhtml#fig2-4), the user process is trying to perform
    some operation on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object. When a user process wants to use a handle, it must first pass the handle’s
    value to the system call we defined in the previous section ❶. The system call
    implementation then calls a kernel API to convert the handle to a kernel pointer
    by referencing the handle’s numeric value in the process’s handle table ❷.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether to grant the access, the conversion API considers the type
    of access that the user has requested for the system call’s operation, as well
    as the type of object being accessed. If the requested access doesn’t match the
    granted access recorded in the handle table entry, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>
    and the conversion operation will fail. Likewise, if the object types don’t match
    ❸, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_OBJECT_TYPE_MISMATCH</samp>.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: These two checks are crucial for security. The access check ensures that the
    user can’t perform an operation on a handle to which they don’t have access (for
    example, writing to a file for which they have only read access). The type check
    ensures the user hasn’t passed an unrelated kernel object type, which might result
    in type confusion in the kernel, causing security issues such as memory corruption.
    If the conversion succeeds, the system call now has a kernel pointer to the object,
    which it can use to perform the user’s requested operation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Access Masks</samp>
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The granted access value in the handle table is a 32-bit bitfield called an
    *access mask*. This is the same bitfield used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    parameter specified in the system call. We’ll discuss how <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    and the access check process determine the granted access in more detail in [Chapter
    7](chapter7.xhtml).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: An access mask has four components, as shown in [Figure 2-5](chapter2.xhtml#fig2-5).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-5.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: The access mask
    structure</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The most important one is the 16-bit *type-specific access component*, which
    defines the operations that are allowed on a particular kernel object type. For
    example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object might
    have separate bits to specify whether the file is allowed to be read or written
    to when using the handle. In contrast, a synchronization <samp class="SANS_TheSansMonoCd_W5Regular_11">Event</samp>
    might only have a single bit that allows the event to be signaled.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Working backward, the *standard access* component of the access mask defines
    operations that can apply to any object type. These operations include:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Delete  </samp>Removes the object;
    for example, by deleting it from disk or from the registry
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadControl  </samp>Reads the security
    descriptor information for the object
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteDac  </samp>Writes the security
    descriptor’s discretionary access control (DAC) to the object
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOwner  </samp>Writes the owner
    information to the object
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Synchronize  </samp>Waits on the
    object; for example, waits for a process to exit or a mutant to be unlocked
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover security-related access in more detail in [Chapters 5](chapter5.xhtml)
    and [6](chapter6.xhtml).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Before this are the *reserved* and *special access* bits. Most of these bits
    are reserved, but they include two access values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AccessSystemSecurity  </samp>Reads
    or writes audit information on the object
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MaximumAllowed  </samp>Requests
    the maximum access to an object when performing an access check
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access in [Chapter 9](chapter9.xhtml) and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumAllowed</samp>
    access in [Chapter 7](chapter7.xhtml).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the four high-order bits of the access mask (the *generic access*
    component) are used only when requesting access to a kernel object using the system
    call’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> parameter.
    There are four broad categories of access: <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: When you request one of these generic access rights, the SRM will first convert
    the access into the corresponding type-specific access. This means you’ll never
    receive access to a handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>;
    instead, you’ll be granted access to the specific access mask that represents
    read operations for that type. To facilitate the conversion, each type contains
    a *generic mapping table*, which maps the four generic categories to type-specific
    access. We can display the mapping table using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>,
    as shown in [Listing 2-11](chapter2.xhtml#Lis2-11).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 2-11: Displaying the generic mapping table for object types'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The type data doesn’t provide names for each specific access mask. However,
    for all common types, the PowerShell module provides an enumerated type that represents
    the type-specific access. We can access this type through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>
    command. [Listing 2-12](chapter2.xhtml#Lis2-12) shows an example for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">File</samp> type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 2-12: Displaying the access mask for the File object type'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>
    command shows the access mask value, the name of the access as known to the PowerShell
    module, and the generic access from which it will be mapped. Note how some access
    types are granted only to <samp class="SANS_TheSansMonoCd_W5Regular_11">All</samp>;
    this means that even if you requested generic read, write, and execute access,
    you wouldn’t be granted access to those rights.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: You can convert between a numeric access mask and specific object types using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp> command,
    as shown in [Listing 2-13](chapter2.xhtml#Lis2-13).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 2-13: Converting access masks using Get-NtAccessMask'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-13](chapter2.xhtml#Lis2-13), we first request the access mask
    from a set of <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> access
    names and receive the numeric access mask in hexadecimal. Next, we get the access
    mask for the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    access; as you can see, the value returned is just the numeric value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>. We then request the
    access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    but specify that we want to map the generic access to a specific access by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGenericRights</samp> parameter.
    As we’ve specified the access for the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    type, this command uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    type’s generic mapping to convert to the specific access mask. Finally, we convert
    the raw access mask back to a type access using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsTypeAccess</samp>
    parameter, specifying the kernel type to use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 2-14](chapter2.xhtml#Lis2-14), you can query an object
    handle’s granted access mask through the PowerShell object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp>
    property. This returns the enumerated type format for the access mask. To retrieve
    the numeric value, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccessMask</samp>
    property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 2-14: Displaying the numeric value of the access mask using GrantedAccessMask'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The kernel provides a facility to dump all handle table entries on the system
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    system call. We can access the handle table from PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command, as illustrated in [Listing 2-15](chapter2.xhtml#Lis2-15).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 2-15: Displaying the handle table for the current process using Get-NtHandle'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Each handle entry contains the type of the object, the address of the kernel
    object in kernel memory, and the granted access mask.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Once an application has finished with a handle, it can be closed using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp> API. If you’ve received
    a PowerShell object from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> call, then you can
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> method on
    the object to close the handle. You can also close an object handle automatically
    in PowerShell by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Use-NtObject</samp>
    command to invoke a script block that closes the handle once it finishes executing.
    [Listing 2-16](chapter2.xhtml#Lis2-16) provides examples of both approaches.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 2-16: Closing an object handle'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: If you do not close handles manually, the .NET garbage collector will close
    them automatically for objects that are not referenced (for example, held in a
    PowerShell variable). You should get into the habit of manually closing handles,
    though; otherwise, you might have to wait a long time for the resources to be
    released, as the garbage collector could run at any time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If the kernel object structure is no longer referenced, either through a handle
    or by a kernel component, then the object will also be destroyed. Once an object
    is destroyed, all its allocated memory is cleaned up and, if it exists, its name
    in the OMNS is removed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handle Duplication</samp>
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can duplicate handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>
    system call. The primary reason you might want to do this is to allow a process
    to take an additional reference to a kernel object. The kernel object won’t be
    destroyed until all handles to it are closed, so creating a new handle maintains
    the kernel object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Handle duplication can additionally be used to transfer handles between processes
    if the source and destination process handles have <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access. You can also use handle duplication to reduce the access rights on a handle.
    For example, when you pass a file handle to a new process, you could grant the
    duplicated handle only read access, preventing the new process from writing to
    the object. However, you should not rely on this approach for reducing the handle’s
    granted access; if the process with the handle has access to the resource, it
    can just reopen it to get write access.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-17](chapter2.xhtml#Lis2-17) shows some examples of using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> command, which wraps
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>, to perform
    some duplication in the same process. We’ll come back to handle duplication and
    security checks in [Chapter 8](chapter8.xhtml).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 2-17: Using Copy-NtObject to duplicate handles'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object to test handle duplication and extract the current granted access, which
    shows six access rights ❶. For the initial duplication, we’ll keep the same granted
    access ❷. You can see in the first column of the output that the handles are different.
    However, our call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>
    to determine whether the two handles refer to the same underlying kernel object
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Next, we get
    an access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant ModifyState</samp>
    access and duplicate the handle, requesting that access ❸. We can see in the output
    that the granted access is now only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>.
    However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>
    return value still indicates the handles refer to the same object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Also relevant to handle duplication are the handle attributes <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>. Setting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> allows a new process
    to inherit the handle when it’s created. This allows you to pass handles to a
    new process to perform tasks such as redirecting console output text to a file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Setting <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>
    protects the handle from being closed. You can set this attribute by setting the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp> property
    on the object, which will set the attribute on the native handle. [Listing 2-18](chapter2.xhtml#Lis2-18)
    shows an example of its use.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 2-18: Testing the ProtectFromClose handle attribute'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Any attempt to close the handle will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_HANDLE_NOT_CLOSABLE</samp>
    status code, and the handle will stay open.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Query and Set Information
    System Calls</samp>
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A kernel object typically stores information about its state. For example, a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object stores a timestamp
    of when it was created. To allow us to retrieve this information, the kernel could
    have implemented a specific “get process creation time” system call. However,
    due to the volume of information stored for the various types of objects, this
    approach would quickly become unworkable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the kernel implements generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information system
    calls whose parameters follow a common pattern for all kernel object types. [Listing
    2-19](chapter2.xhtml#Lis2-19) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    information system call’s pattern, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    type as an example; for other types, just replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    with the name of the kernel type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 2-19: An example Query information system call for the Process type'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: All <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information system
    calls take an object handle as the first parameter. The second parameter, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InformationClass</samp>, describes the
    type of process information to query. The information class is an enumerated value;
    the SDK specifies the names of the information classes, which we can extract and
    implement in PowerShell. Querying certain kinds of information might require special
    privileges or administrator access.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'For every information class, we need to specify an opaque buffer to receive
    the queried information, as well as the length of the buffer. The system call
    also returns a length value, which serves two purposes: it indicates how much
    of the buffer was populated if the system call was successful, and if the system
    call failed, it indicates how big the buffer needs to be with <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INFO_LENGTH_MISMATCH</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: You should be careful about relying on the returned length to determine how
    big a buffer to pass to the query, however. Some information classes and types
    do not correctly set the length needed if you supply a buffer that is too small.
    This makes it difficult to query data without knowing its format in advance. Unfortunately,
    even the SDK rarely documents the exact sizes required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 2-20](chapter2.xhtml#Lis2-20), the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>
    information call follows a similar pattern. The main differences are that there’s
    no return length parameter, and in this case the buffer is an input to the system
    call rather than an output.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 2-20: An example Set information system call for the Process type'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In the PowerShell module, you can query a type’s information class names using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>
    command, as shown in [Listing 2-21](chapter2.xhtml#Lis2-21). Bear in mind that
    some information class names might be missing from the list, as Microsoft doesn’t
    always document them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 2-21: Listing the information classes for the Process type'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information
    system call, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>,
    specifying an open object handle and the information class. To call <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>,
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtObjectInformation</samp>.
    [Listing 2-22](chapter2.xhtml#Lis2-22) shows an example of how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 2-22: Querying a Process object for basic information'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> type doesn’t
    set the return length for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTimes</samp>
    information class, so if you don’t specify any length, the operation generates
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>
    error ❶. However, through inspection or brute force, you can discover that the
    length of the data is 32 bytes. Specifying this value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>
    parameter ❷ allows the query to succeed and return the data as an array of bytes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: For many information classes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>
    command knows the size and structure of the query data. If you specify the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AsObject</samp> parameter ❸, you can get
    a preformatted object rather than an array of bytes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Also, for many information classes the handle object already exposes properties
    and methods to set or query values. The values will be decoded into a usage format;
    for example, in [Listing 2-22](chapter2.xhtml#Lis2-22), the times are in an internal
    format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>
    property on the object will take this internal format and convert it to a human-readable
    date and time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: You can easily inspect properties by accessing them on the object or using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp> command. For
    example, [Listing 2-23](chapter2.xhtml#Lis2-23) lists all the properties on a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object, then queries
    for the formatted <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 2-23: Querying a handle object for properties and inspecting the CreationTime'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp> classes for
    a type typically have the same enumerated values. The kernel can restrict the
    information class’s enumerated values to one type of operation, returning the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID _INFO_CLASS</samp>
    status code if it’s not a valid value. For some types, such as registry keys,
    the information class differs between querying and setting, as you can see in
    [Listing 2-24](chapter2.xhtml#Lis2-24).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 2-24: Inspecting the QueryInformation and SetInformation classes for
    the Key type'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>
    with just the type name returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp>
    class. If you specify the type name and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>
    parameter, you get the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>
    class. Notice how the two entries shown have different names and therefore represent
    different information.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Input/Output Manager</samp>
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The input/output (I/O) manager provides access to I/O devices through *device
    drivers*. The primary purpose of these drivers is to implement a filesystem. For
    example, when you open a document on your computer, the file is made available
    through a filesystem driver. The I/O manager supports other kinds of drivers,
    for devices such as keyboards and video cards, but these other drivers are really
    just filesystem drivers in disguise.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: You can manually load a new driver through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp>
    system call or do so automatically using the Plug and Play (PnP) manager. For
    every driver, the I/O manager creates an entry in the *Driver* directory. You
    can list the contents of this directory only if you’re an administrator. Fortunately,
    as a normal user, you don’t need to access anything in the *Driver* directory.
    Instead, you can interact with the driver through a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object, normally created in the *Device* directory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Drivers are responsible for creating new <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateDevice</samp>
    API. A driver can have more than one <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object associated with it; it may also have zero associated <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    objects if it doesn’t require user interaction. As [Listing 2-25](chapter2.xhtml#Lis2-25)
    shows, we can list the contents of the *Device* directory as a normal user through
    the OMNS.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 2-25: Displaying the Device objects'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see that the objects’ type names are all <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>.
    However, if you go looking for a system call with <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    in the name, you’ll come up empty. That’s because we don’t interact with the I/O
    manager using dedicated system calls; rather, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object system calls such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>.
    We can access these system calls through <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp>, which create
    and open files, respectively, as shown in [Listing 2-26](chapter2.xhtml#Lis2-26).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 2-26: Opening a device object and displaying its volume path'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we open *notepad.exe* from the *Windows* directory. The *SystemRoot*
    symbolic link points to the *Windows* directory on the system drive. As the *SystemRoot*
    symbolic link is part of the OMNS, the OMNS initially handles file access. With
    an open handle, we can select the full path to the file and the type name.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the result, we can see that the full path starts with *Device\HarddiskVolume3\*,
    followed by *Windows\notepad.exe* ❶. If we try to display the device, we find
    it’s of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>. Once
    the object manager finds the <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object, it hands off responsibility for the rest of the path to the I/O manager,
    which calls an appropriate method inside the kernel driver.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We can list the drivers loaded into the kernel using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKernelModule</samp>
    command ([Listing 2-27](chapter2.xhtml#Lis2-27)).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 2-27: Enumerating all loaded kernel drivers'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other operating systems, such as Linux, Windows does not implement core
    network protocols like TCP/IP using built-in system calls. Instead, Windows has
    an I/O manager driver, the *Ancillary Function Driver (AFD)*, which provides access
    to networking services for an application. You don’t need to deal with the driver
    directly; Win32 provides a BSD sockets-style API, called *WinSock*, to handle
    access to it. In addition to the standard internet protocol suite, such as TCP/IP,
    AFD also implements other network socket types, such as Unix sockets and bespoke
    Hyper-V sockets for communication with virtual machines.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: That’s all we’ll say for now about the I/O manager. Next, let’s turn to another
    important subsystem, the process and thread manager.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Process and Thread Manager</samp>
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All user-mode code lives in the context of a *process*, each of which has one
    or more *threads* that control the execution of the code. Processes and threads
    are both securable resources. This makes sense: if you could access a process,
    you could modify its code and execute it in the context of a different user identity.
    So, unlike most other kernel objects, you can’t open a process or thread by name.
    Instead, you must open them via a unique, numeric *process ID (PID)* or *thread
    ID (TID)*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: To get a list of running processes and threads you could brute-force the ID
    space by calling the open system call with every possible ID, but that would take
    a while. Fortunately, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    system call provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemProcessInformation</samp>
    information class, which lets us enumerate processes and threads without having
    access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We can access the list of processes and threads by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands
    and passing them the <samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp>
    parameter, as shown in [Listing 2-28](chapter2.xhtml#Lis2-28). We can also use
    the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Process</samp>
    command to produce a similar output. Each of the returned objects has a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Threads</samp> property that we can query
    for the thread information.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 2-28: Displaying processes and threads without high privilege'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The first two processes listed in the output are special. The first is the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idle</samp> process, with PID <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    This process contains threads that execute when the operating system is idle,
    hence its name. It’s not a process you’ll need to deal with regularly. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">System</samp> process, with PID <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, is important because it runs
    entirely in kernel mode. When the kernel or a driver needs to execute a background
    thread, the thread is associated with the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    process.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: To open a process or thread, we can pass <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> the PID or
    TID we want to open. The command will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object that we
    can then interact with. For example, [Listing 2-29](chapter2.xhtml#Lis2-29) shows
    how to query the command line and executable path of the current process.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-29: Opening the current process by its process ID'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: When you open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object using its
    ID, you’ll receive a handle. For convenience, the kernel also supports two *pseudo
    handles* that refer to the current process and the current thread. The current
    process’s pseudo handle is the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    converted to a handle, and for the current thread, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>.
    You can access these pseudo handles by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp>
    parameter instead of an ID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Note that the security of a process and its threads is independent. If you know
    the ID of a thread, it’s possible to access the thread handle inside a process
    even if you can’t access the process itself.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Memory Manager</samp>
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every process has its own virtual memory address space for a developer to use
    as they see fit. A 32-bit process can access up to 2GB of virtual memory address
    space (4GB on 64-bit Windows), while a 64-bit process can access up to 128TB.
    The kernel’s *memory manager* subsystem controls the allocation of this address
    space.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: You’re unlikely to have 128TB of physical memory in your computer, but the memory
    manager has ways of making it look like you have more physical memory than you
    do. For example, it can use a dedicated file on your filesystem, called a *pagefile*,
    to temporarily store memory when it’s not currently needed. As your filesystem’s
    available storage space is much larger than your computer’s physical memory, this
    can provide the appearance of a large amount of memory.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The virtual memory space is shared by memory allocations, and it stores each
    process’s running state as well as its executable code. Each memory allocation
    can have a range of protection states, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>, which must
    be set according to the memory’s purpose. For example, for code to be executed,
    the memory must have a protection state of <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: You can query all memory status information for a process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>,
    if you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access right on the process handle. However, reading and writing the memory data
    requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmRead</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VmWrite</samp> access rights, respectively,
    and a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to allocate new memory and free memory in a process using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFreeVirtualMemory</samp>, which both
    require the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp> access
    right. Finally, you can change the protection on memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>,
    which also requires <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp>
    access.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NtVirtualMemory Commands</samp>
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PowerShell wraps these system calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtVirtualMemory</samp> commands.
    Note that these commands all accept an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    parameter that lets you access memory in a different process from the current
    one. [Listing 2-30](chapter2.xhtml#Lis2-30) shows the commands in action.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 2-30: Performing various memory operations on a process'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we perform several operations. First we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    to list all the memory regions being used by the current process ❶. The returned
    list will be large, but the excerpt shown here should give you a rough idea of
    how the information is presented. It includes the address of the memory region,
    its size, its protection, and its state. There are three possible state values:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Commit  </samp>Indicates that the
    virtual memory region is allocated and available for use.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reserve  </samp>Indicates that
    the virtual memory region has been allocated but there is currently no backing
    memory. Using a reserved memory region will cause a crash.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Free  </samp>Indicates that the
    virtual memory region is unused. Using a free memory region will cause a crash.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder what the difference is between <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>, if using both reserved
    and free memory regions will cause a crash. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>
    state allows you to reserve virtual memory regions for later use so that nothing
    else can allocate memory within that range of memory addresses. You can later
    convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp> state
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Commit</samp> by re-calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Free</samp> state indicates regions freely
    available for allocation. We’ll cover what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> columns indicate
    later in this section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Next, we allocate a 1,000-byte read/write region and capture the address in
    a variable ❷. Passing the address to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    allows us to query only that specific virtual memory region. You might notice
    that although we requested a 1,000-byte region, the size of the region returned
    is 4,096 bytes. This is because all virtual memory allocations on Windows have
    a minimum allocation size; on the system I’m using, the minimum is 4,096 bytes.
    It’s therefore not possible to allocate a smaller region. For this reason, these
    system calls are not particularly useful for general program allocations; rather,
    they’re primitives on which “heap” memory managers are built, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    from the C library.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Next, we read and write to the memory region we just allocated. First we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-NtVirtualMemory</samp> to read
    out 4 bytes of the memory region and find that the bytes are all zeros ❸. Next,
    we write the bytes 1, 2, 3, and 4 to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>
    ❹. We read the bytes to confirm that the write operation succeeded ❺; the two
    values should match, as shown in the output.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: With the memory allocated, we can change the protection using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set
    -NtVirtualMemory</samp>. In this case, we make the allocated memory executable
    by specifying the protection as <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    ❻. Querying the current state of the memory region using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    command ❼ shows that the protection has changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>. Also notice
    that although we requested to change the protection of only 4 bytes, the entire
    4,096-byte region is now executable. This is again due to the minimum memory allocation
    size.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we free the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtVirtualMemory</samp>
    and verify that the memory is now in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>
    state ❽. Memory allocated using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    is considered private, as indicated by the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    property shown in [Listing 2-30](chapter2.xhtml#Lis2-30).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Section Objects</samp>
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another way of allocating virtual memory is through <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object
    is a kernel type that implements memory-mapped files. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects for two related purposes:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Reading or writing a file as if it were all read into memory
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing memory between processes so that the modification in one process is
    reflected in the other
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object via the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSection</samp>
    PowerShell command. We must specify the size of the mapping, the protection for
    the memory, and an optional file handle; in return, we get a handle to the section.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: However, creating a section doesn’t automatically allow us to access the memory;
    we first need to map it into the virtual memory address space using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>. [Listing
    2-31](chapter2.xhtml#Lis2-31) provides an example in which we create an anonymous
    section and map it into memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 2-31: Creating a section and mapping it into memory'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: To start, we create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object with a size of 4,096 bytes and protection of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    ❶. We don’t specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    parameter, which means it’s anonymous and not backed by any file. If we gave the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object an OMNS path,
    the anonymous memory it represents could be shared with other processes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: We then map the section into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>,
    specifying the protection we want for the memory, and query the mapped address
    to verify that the operation succeeded ❷. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>. When we’re
    done with the mapping, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>
    to unmap the section and then verify that it’s now free ❸.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we demonstrate that we can’t map a section with different protection
    than that granted when we created the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object ❹. When we try to map the section with read and execute permissions, which
    aren’t compatible, we see an exception.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The protection you’re allowed to use to map a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object into memory depends on two things. The first is the protection specified
    when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object was
    created. For example, if the section was created with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    protection, you can never map it to be writable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The second dependency is the access granted to the section handle you’re mapping.
    If you want to map the section as readable, then the handle must have <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>
    access. To map it to be writable, you need both <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. (And,
    of course, having just <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access isn’t sufficient to map the section as writable if the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object was not specified with a writable protection.)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to map a section into another process by specifying a process
    handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>.
    We don’t need to specify the process to <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>,
    as the mapping object knows what process it was mapped in. In the memory information
    output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column would
    be populated by the name of the backing file, if it exists.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The section we created was anonymous, so we don’t see anything in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column, but we can perform
    a query to find mapped sections that are backed by files using the command shown
    in [Listing 2-32](chapter2.xhtml#Lis2-32).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 2-32: Listing mapped files with names'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp> types, there is
    a third section type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>
    type. When provided with a file handle to a Windows executable, the kernel will
    automatically parse the format and generate multiple subsections that represent
    the various components of the executable. To create a mapped image from a file,
    we need only <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp> access
    on the file handle; the file doesn’t need to be readable for us.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Windows uses image sections extensively to simplify the mapping of executables
    into memory. We can specify an image section by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>
    flag when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object or by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSectionImage</samp>
    command, as shown in [Listing 2-33](chapter2.xhtml#Lis2-33).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 2-33: Mapping <samp class="SANS_Futura_Std_Book_11">notepad.exe</samp>
    and viewing the loaded image'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we don’t need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp> protection
    when mapping the image section. Any protection, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>,
    will work ❶. When we get the memory information for a map-based address, we see
    that there is no executable memory there and that the allocation is only 4,096
    bytes ❷, which seems far too small for *notepad.exe*. This is because the section
    is made up of multiple smaller mapped regions. If we filter out the memory information
    for the mapped name ❸, we can see the executable memory. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>
    command, we can print the contents of the mapped file buffer ❹.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Integrity</samp>
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important security task is ensuring that the code running on your computer
    is the same code the manufacturer intended you to run. If a malicious user has
    modified operating system files, you might encounter security issues such as the
    leaking of private data.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft considers the integrity of code running on Windows to be so important
    that there is an entire subsystem to deal with it. This *code integrity* subsystem
    verifies and restricts what files can execute in the kernel, and optionally in
    user mode, by checking the code’s integrity. The memory manager can consult with
    the code integrity subsystem when it loads an image file if it needs to check
    whether the executable is correctly signed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Almost every executable on a default Windows installation is signed using a
    mechanism called *Authenticode*. This mechanism allows a cryptographic signature
    to be embedded in the executable file or collected inside a catalog file. The
    code integrity subsystem can read this signature, verify that it’s valid, and
    make trust decisions based on it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AuthenticodeSignature</samp>
    command to query the signing status of an executable, as shown in [Listing 2-34](chapter2.xhtml#Lis2-34).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 2-34: Displaying the Authenticode signature for a kernel driver'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Here, we query the signing status of the *notepad.exe* executable file, formatting
    the command’s output as a list. The output starts with information about the signer’s
    X.509 certificate. Here, I’ve shown only the subject name, which clearly indicates
    that this file is signed by Microsoft.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Next is the status of the signature; in this case, the status indicates that
    the file is valid and that the signature has been verified. It’s possible to have
    a signed file whose signature is invalid; for example, when the certificate has
    been revoked. In that case, the status is likely to show an error, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NotSigned</samp>.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SignatureType</samp> property
    shows that this signature was based on a catalog file rather than being embedded
    in the file. We can also see that this file is an operating system binary, as
    determined by information embedded in the signature.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The most common trust decision the code integrity subsystem makes is checking
    whether a kernel driver can load. Each driver file must have a signature that
    derives its trust from a Microsoft-issued key. If the signature is invalid or
    doesn’t derive from a Microsoft-issued key, then the kernel can block loading
    of the driver to preserve system integrity.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Advanced Local Procedure Call</samp>
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *advanced local procedure call (ALPC)* subsystem implements local, cross-process
    communication. To use ALPC, you must first create a server ALPC port using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateAlpcPort</samp> system call
    and specify a name for it inside the OMNS. A client can then use this name by
    calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtConnectAlpcPort</samp>
    system call to connect to the server port.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: At a basic level, the ALPC port allows the secure transmission of discrete messages
    between a server and a client. ALPC provides the underlying transport for local
    remote procedure call APIs implemented in Windows.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Configuration Manager</samp>
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *configuration manager*, known more commonly as the *registry*, is an important
    component for configuring the operating system. It stores a variety of configuration
    information, ranging from the system-critical list of available I/O manager device
    drivers to the (less critical) last position on the screen of your text editor’s
    window.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the registry as a filesystem in which *keys* are like folders
    and *values* are like files. You can access it through the OMNS, although you
    must use registry-specific system calls. The root of the registry is the OMNS
    path *REGISTRY*. You can list the registry in PowerShell using the *NtObject*
    drive, as shown in [Listing 2-35](chapter2.xhtml#Lis2-35).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 2-35: Enumerating the registry root key'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: You can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObject:\REGISTRY</samp>
    in [Listing 2-35](chapter2.xhtml#Lis2-35) with <samp class="SANS_TheSansMonoCd_W5Regular_11">NtKey:\</samp>
    to make accessing the registry simpler.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The kernel pre-creates the four keys shown here when it initializes. Each of
    the keys is a special *attachment point* at which you can attach a registry hive.
    A *hive* is a hierarchy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    objects underneath a single root key. An administrator can load new hives from
    a file and attach them to these preexisting keys.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Note that PowerShell already comes with a drive provider that you can use to
    access the registry. However, this drive provider exposes only the Win32 view
    of the registry, which hides the internal details about the registry from view.
    We’ll cover the Win32 view of the registry separately in [Chapter 3](chapter3.xhtml).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: You can interact with the registry directly, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp> commands to
    open and create <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> objects,
    respectively. You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtKeyValue</samp> to get
    and set key values. To remove keys or values, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKey</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKeyValue</samp>. [Listing
    2-36](chapter2.xhtml#Lis2-36) shows a few of these commands in action.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 2-36: Opening a registry key and querying its values'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> object using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> command. We
    can then query the values stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>
    command. Each entry in the output shows the name of the value, the type of data
    stored, and a string representation of the data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using PowerShell, you can easily change this book’s example scripts to do many
    different things. To encourage experimentation, each chapter wraps up with a set
    of worked examples repurposing the various commands you’ve learned.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, I’ll also highlight times where I’ve discovered security
    vulnerabilities using this tooling. This should give you a clear indication of
    what to look for in Microsoft or third-party applications if you’re a security
    researcher; likewise, for developers, it will help you avoid certain pitfalls.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Open Handles
    by Name</samp>
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The objects returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command have additional properties that allow you to query the object’s name and
    security descriptor. These properties are not shown by default, as they’re expensive
    to look up; doing so requires opening the process containing the handle for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access, duplicating the
    handle back to the calling PowerShell instance, and finally querying the property.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: If performance doesn’t matter to you, then you can use the code in [Listing
    2-37](chapter2.xhtml#Lis2-37) to find all open files matching a specific filename.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 2-37: Finding File object handles that match a specific name'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: This script queries for all <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object handles and filters them to only the ones with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Windows</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> property, which
    represents the filepath. Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    property has been queried, it’s cached so you can then display it to the console
    with a custom selection.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Note that because it duplicates the handle from the process, this script can
    only show handles in processes the caller can open. To get the best results, run
    it as an administrator user who can open the maximum number of processes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Shared Objects</samp>
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you query the list of handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command, you also get the address of the object in kernel memory. When you open
    the same kernel object, you’ll get different handles, but they will still point
    to the same kernel object address.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: You can use the object address to find processes that share handles. This can
    be interesting for security in cases where an object is shared between two processes
    with different privileges. The lower-privileged process might be able to modify
    the properties of the object to bypass security checks in the higher-privileged
    process, enabling it to gain additional privileges.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: In fact, I used this technique to find security issue CVE-2019-0943 in Windows.
    At the root of the issue was a privileged process, the Windows Font Cache, that
    shared section handles with a low-privileged process. The low-privileged process
    could map the shared section to be writable and modify contents that the privileged
    process assumed couldn’t be modified. This effectively allowed the low-privileged
    process to modify arbitrary memory in the privileged process, resulting in privileged
    code execution.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-38](chapter2.xhtml#Lis2-38) gives an example of finding writable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects shared between
    two processes.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 2-38: Finding shared Section handles'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: We first get the handles, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    parameter. This returns a list of groups organized based on the kernel object
    address, instead of a list of handles. You can also group handles using the built-in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Group-Object</samp> command; however,
    the groups returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    have additional properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ShareCount</samp>,
    which indicates the number of unique processes an object is shared with. Here,
    we filter to include only handles that are shared between two processes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to find <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects that can be mapped as writable. We first check that all the handles have
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. As mentioned
    earlier, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s
    protection must also be writable for us to be able to map it as writable. Oddly,
    we can’t query for the original protection that was assigned when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object was created, but checking for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access is a simple proxy. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessIntersection</samp>
    property, which contains the granted access rights shared among all the handles.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have potential candidates for shared sections, we need to work
    out which meet the criterion that we can access only one of the processes containing
    the section handle. We’re making another assumption here: if we can open only
    one of the two processes that share the handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access, then we’ve got a section shared between a privileged and a low-privileged
    process. After all, if you had <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access to both processes, you could already compromise the processes by stealing
    all their handles or duplicating their process handles, and if you couldn’t get
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access to either
    process, then you couldn’t get access to the section handle at all.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The result shown in [Listing 2-38](chapter2.xhtml#Lis2-38) is a section shared
    between Chrome and the Audio Device Graph process. The shared section is used
    to play audio from the browser, and it’s probably not a security issue. However,
    if you run the script on your own system, you might find shared sections that
    are.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Note that once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object is mapped into memory, the handle is no longer required. Therefore, you
    might miss some shared sections that were mapped when the original handle closed.
    It’s also highly likely you’ll get false positives, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects that are intentionally writable by everyone. The goal here is to find
    a potential attack surface on Windows. You must then go and inspect the handles
    to see if sharing them has introduced a security issue.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modifying a Mapped
    Section</samp>
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you find an interesting <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object to modify, you can map it into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>.
    But how do you modify the mapped memory? The simplest approach from the command
    line is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>
    command, which supports passing a mapped section and an array of bytes to write.
    [Listing 2-39](chapter2.xhtml#Lis2-39) demonstrates this technique by assuming
    you have a handle of interest in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$handle</samp>
    variable.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 2-39: Mapping and modifying a Section object'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: We first call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetObject</samp>
    method on the handle to duplicate it into the current process and return a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object. For this to succeed,
    the process in which we’re running this command must be able to access the process
    with the handle. We then map the handle as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    into the current process’s memory.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a random array of bytes up to the size of the mapped section
    and write them to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>.
    This is a quick and dirty fuzzer for the shared memory. The hope is that by modifying
    the memory, the privileged process will mishandle the contents of the memory region.
    If the privileged process crashes, we should investigate to determine whether
    we can control the crash using a more targeted modification of the shared memory.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: We can display the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>.
    One of the useful features of this command over the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp>
    is that it’ll print the address in memory based on the mapped file, whereas <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp> just prints an offset
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a GUI hex editor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtSection</samp>
    command, specifying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object to edit. As the section can be mapped into any process, writing it in the
    GUI hex editor will also modify all other mappings of that section. Here is the
    command to display the hex editor:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Figure 2-6](chapter2.xhtml#fig2-6) shows an example of the editor generated
    by running the previous command.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-6.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The section editor
    GUI</samp>'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The GUI shown in [Figure 2-6](chapter2.xhtml#fig2-6) maps the section into memory
    and then displays it in a hex editor form. If the section is writable, you can
    modify the contents of the memory through the editor.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Writable
    and Executable Memory</samp>
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Windows, for a process to execute instructions, the memory must be marked
    as executable. However, it’s also possible to map the memory as both writable
    and executable. Malware sometimes uses this combination of permissions to inject
    shell code into a process and run malicious code using the host process’s identity.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-40](chapter2.xhtml#Lis2-40) shows how to check for memory in a process
    that is both writable and executable. Finding such memory might indicate that
    something malicious is going on, although in most cases this memory will be benign.
    For example, the .NET runtime creates writable and executable memory to perform
    just-in-time (JIT) compilation of the .NET byte code into native instructions.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 2-40: Finding executable and writable memory in a process'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: We start by opening a process for <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access, which is all we need to enumerate the virtual memory regions. Here, we’re
    opening the current PowerShell process; as PowerShell is .NET, we know it will
    have some writable and executable memory regions, but the process you open can
    be anything you want to check.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: We then enumerate all the memory regions using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    and filter on the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>
    protection type. We need to use a bitwise AND operation as there are additional
    flags that can be added to the protection, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Guard</samp>,
    which creates a guard page that prevents doing a direct equality check.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter provided a tour through the Windows kernel and its internals. The
    kernel consists of many separate subsystems, such as the Security Reference Monitor,
    the object manager, the configuration manager (or registry), the I/O manager,
    and the process and thread manager.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: You learned about how the object manager manages kernel resources and types,
    how to access kernel resources through system calls, and how handles are allocated
    with specific access rights. You also accessed object manager resources through
    the *NtObject* drive provider as well as through individual commands.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: I then discussed the basics of process and thread creation and demonstrated
    the use of commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    to query for process information on the system. I explained how to inspect the
    virtual memory of a process, as well as some of the individual memory types.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: A user doesn’t directly interact with the kernel; instead, user-mode applications
    power the user experience. In the next chapter, we’ll discuss the user-mode components
    in more detail.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
