- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    WINDOWS KERNEL</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Windows is a secure, multiuser operating system. However, it’s also one of the
    most challenging modern operating systems to understand in detail. Before we delve
    into the intricacies of its security, in this part of the book I’ll provide you
    with an overview of the operating system’s structure. We’ll also take this opportunity
    to understand how to use the PowerShell module that will form the core of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll consider the two parts of the running operating system: the kernel and
    the user-mode applications. The kernel makes the security decisions that determine
    what a user can do on the system. However, most of the applications you use on
    a Windows machine run in user mode. This chapter will focus on the kernel; the
    next chapter will focus on user-mode applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll examine the various subsystems that make up
    the Windows kernel. For each subsystem, I’ll explain its purpose and how it’s
    used. We’ll begin with the object manager, where we’ll also explore system calls,
    which allow a user-mode application to access kernel objects. We’ll then discuss
    the input/output manager, how applications are created through the process and
    thread manager, and how memory is represented with the memory manager. Throughout,
    I’ll outline how you can inspect the behavior of these subsystems using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows Kernel Executive</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Windows NTOS kernel executive*, or *kernel* for short, is the heart of
    Windows. It provides all the operating system’s privileged functionality, as well
    as interfaces through which the user applications can communicate with the hardware.
    The kernel is split into multiple subsystems, each with a dedicated purpose. [Figure
    2-1](chapter2.xhtml#fig2-1) shows a diagram of the components in which we’ll be
    most interested in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The Windows kernel
    executive modules</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each subsystem in the kernel executive exposes APIs for other subsystems to
    call. If you are looking at kernel code, you can quickly determine what subsystem
    each API belongs to using its two-character prefix. The prefixes for the subsystems
    in [Figure 2-1](chapter2.xhtml#fig2-1) are shown in [Table 2-1](chapter2.xhtml#tab2-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">API
    Prefix-to-Subsystem Mapping</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Subsystem</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Example</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> | <samp class="SANS_Futura_Std_Book_11">System
    call interface</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenFile</samp><samp
    class="SANS_Futura_Std_Book_11">/</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">ZwOpenFile</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Se</samp> | <samp class="SANS_Futura_Std_Book_11">Security
    Reference Monitor</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAccessCheck</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ob</samp> | <samp class="SANS_Futura_Std_Book_11">Object
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ps</samp> | <samp class="SANS_Futura_Std_Book_11">Process
    and thread manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PsGetCurrentProcess</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Cm</samp> | <samp class="SANS_Futura_Std_Book_11">Configuration
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">CmRegisterCallback</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mm</samp> | <samp class="SANS_Futura_Std_Book_11">Memory
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MmMapIoSpace</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Io</samp> | <samp class="SANS_Futura_Std_Book_11">Input/output
    manager</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateFile</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ci</samp> | <samp class="SANS_Futura_Std_Book_11">Code
    integrity</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">CiValidateFileObject</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We’ll explore all of these subsystems in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Security Reference Monitor</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this book, the *Security Reference Monitor (SRM)* is the
    most important subsystem in the kernel. It implements the security mechanisms
    that restrict which users can access different resources. Without the SRM, you
    wouldn’t be able to prevent other users from accessing your files. [Figure 2-2](chapter2.xhtml#fig2-2)
    shows the SRM and its related system components.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Components of the
    Security Reference Monitor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Every process running on the system is assigned an *access token* when it’s
    created. This access token is managed by the SRM and defines the identity of the
    user associated with that process. The SRM can then perform an operation called
    an *access check*. This operation queries a resource’s security descriptor, compares
    it to the process’s access token, and either calculates the level of granted access
    or indicates that access is denied to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: The SRM is also responsible for generating audit events whenever a user accesses
    a resource. Auditing is disabled by default due to the volume of events it can
    produce, so an administrator must enable it first. These audit events can be used
    to identify malicious behavior on a system as well as to diagnose security misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: The SRM expects users and groups to be represented as binary structures called
    *security identifiers (SIDs)*. However, passing around raw binary SIDs isn’t very
    convenient for users, who normally refer to users and groups by meaningful names
    (for example, the user *bob* or the *Users* group). These names need to be converted
    to SIDs before the SRM can use them. The task of name–SID conversion is handled
    by the *Local Security Authority Subsystem (LSASS)*, which runs inside a privileged
    process independent from any logged-in users.
  prefs: []
  type: TYPE_NORMAL
- en: It’s infeasible to represent every possible SID as a name, so Microsoft defines
    the *Security Descriptor Definition Language (SDDL)* format to represent a SID
    as a string. SDDL can represent the entire security descriptor of a resource,
    but for now we’ll just use it to represent the SID. In [Listing 2-1](chapter2.xhtml#Lis2-1),
    we use PowerShell to look up the *Users* group name using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    command; this should retrieve the SDDL string for the SID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: Querying the SID of the <samp class="SANS_Futura_Std_Book_11">Users</samp>
    group using Get-NtSid'
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the name of the *Users* group to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>,
    which returns the fully qualified name, with the local domain *BUILTIN* attached.
    The *BUILTIN\Users* SID is always the same between different Windows systems.
    The output also contains the SID in SDDL format, which can be broken down into
    the following dash-separated parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp> character prefix.
    This indicates that what follows is an SDDL SID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of the SID structure in decimal. This has a fixed value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The security authority. Authority <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    indicates the built-in NT authority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two relative identifiers (RIDs), in decimal. The RIDs (here, <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">545</samp>) represent the NT
    authority group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    to perform the reverse operation, converting an SDDL SID back to a name, as shown
    in [Listing 2-2](chapter2.xhtml#Lis2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: Using Get-NtSid to find the name associated with a SID'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll describe the SRM and its functions in much greater depth in [Chapters 4](chapter4.xhtml)
    through [9](chapter9.xhtml), and we’ll revisit the SID structure in [Chapter 5](chapter5.xhtml),
    when we discuss security descriptors. For now, remember that SIDs represent users
    and groups and that we can represent them as strings in SDDL form. Next, we’ll
    move on to another of the core Windows kernel executive subsystems, the object
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Object Manager</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Unix-like operating systems, everything is a file. On Windows, everything
    is an object, meaning that every file, process, and thread is represented in kernel
    memory as an object structure. Importantly for security, each of these objects
    can have an assigned security descriptor, which restricts which users can access
    the object and determines the type of access they have (for example, read or write).
  prefs: []
  type: TYPE_NORMAL
- en: The *object manager* is the component of the kernel responsible for managing
    these resource objects, their memory allocations, and their lifetimes. In this
    section, we’ll first discuss the types of objects the object manager supports.
    Then, we’ll explore how kernel objects can be opened through a naming convention
    using a system call. Finally, we’ll look at how to use a handle returned by the
    system call to access the object.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The kernel maintains a list of all the types of objects it supports. This is
    necessary, as each object type has different supported operations and security
    properties. [Listing 2-3](chapter2.xhtml#Lis2-3) shows how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>
    command to list all supported types in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: Executing Get-NtType'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve truncated the list of types (the machine I’m using supports 72 of them),
    but there are some noteworthy entries even in this short section. The first entry
    in the generated list is <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>;
    even the list of kernel types is built from objects! Other types of note here
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>,
    which represent the kernel objects for a process and a thread, respectively. We’ll
    examine other object types in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can display the properties of a type with <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp>,
    which returns additional information about that type. We’ll look at an example
    later, but for now the question is how to access each of these types. To answer
    it, we’ll need to talk about the object manager namespace.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Object Manager
    Namespace</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a user of Windows, you typically see your filesystem drives in Explorer.
    But underneath the user interface is a whole additional filesystem just for kernel
    objects. Access to this filesystem, referred to as the *object manager namespace
    (OMNS)*, isn’t very well documented or exposed to most developers, which makes
    it even more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The OMNS is built out of <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects. The objects act as if they were in a filesystem, so each directory contains
    other objects, which you can consider to be files. However, they are distinct
    from the file directories you’re used to. Each directory is configured with a
    security descriptor that determines which users can list its contents and which
    users can create new subdirectories and objects inside it. You can specify the
    full path to an object with a backslash-separated string.
  prefs: []
  type: TYPE_NORMAL
- en: We can enumerate the OMNS by using a drive provider that is part of this book’s
    PowerShell module. As shown in [Listing 2-4](chapter2.xhtml#Lis2-4), this exposes
    the OMNS as if it were a filesystem by listing the *NtObject* drive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: Listing the root OMNS directory'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-4](chapter2.xhtml#Lis2-4) shows a short snippet of the root OMNS
    directory. By default, this output includes the name of each object and its type.
    We can see a few <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    objects; you can list them if you have permission to do so. We can also see another
    important type, <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>.
    You can use symbolic links to redirect one OMNS path to another. A <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLink</samp>
    object contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    property, which itself contains the target that the link should open. For example,
    [Listing 2-5](chapter2.xhtml#Lis2-5) shows the target for a symbolic link in the
    root of the OMNS.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: Showing the target of a symbolic link'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we list the *\Dfs* OMNS path, then extract the <samp class="SANS_TheSansMonoCd_W5Regular_11">SymbolicLinkTarget</samp>
    property to get the real target. Next, we check the target path, *Device\DfsClient*,
    to show it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> type,
    which is what the symbolic link can be used to access.
  prefs: []
  type: TYPE_NORMAL
- en: Windows preconfigures several important object directories, shown in [Table
    2-2](chapter2.xhtml#tab2-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</samp> <samp class="SANS_Futura_Std_Book_11">Well-Known
    Object Directories and Descriptions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Path</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\BaseNamedObjects</samp>
    | <samp class="SANS_Futura_Std_Book_11">Global directory for user objects</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Device</samp> | <samp class="SANS_Futura_Std_Book_11">Directory
    containing devices such as mounted filesystems</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\GLOBAL??</samp> | <samp
    class="SANS_Futura_Std_Book_11">Global directory for symbolic links, including
    drive mappings</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\KnownDlls</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory containing special, known DLL mappings</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\ObjectTypes</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory containing named object types</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Sessions</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory for separate console sessions</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\Windows</samp> | <samp class="SANS_Futura_Std_Book_11">Directory
    for objects related to the Window Manager</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">\RPC Control</samp> | <samp
    class="SANS_Futura_Std_Book_11">Directory for remote procedure call endpoints</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The first directory in [Table 2-2](chapter2.xhtml#tab2-2), *BaseNamedObjects
    (BNO)*, is important in the context of the object manager. It allows any user
    to create named kernel objects. This single directory allows the sharing of resources
    between different users on the local system. Note that you don’t have to create
    objects in the BNO directory; it’s only a convention.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll describe the other object directories in more detail later in this chapter.
    For now, you can list them in PowerShell by prefixing the path with *NtObject:*,
    as I’ve shown in [Listing 2-5](chapter2.xhtml#Lis2-5).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">System Calls</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can we access the named objects in the OMNS from a user-mode application?
    If we’re in a user-mode application, we need the kernel to access the objects,
    and we can call kernel-mode code in a user-mode application using the system call
    interface. Most system calls perform some operation on a specific type of kernel
    object exposed by the object manager. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, a mutual exclusion primitive used for locking and thread synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: The name of a system call follows a common pattern. It starts with either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>.
    For user-mode callers, the two prefixes are equivalent; however, if the system
    call is invoked by code executing in the kernel, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    prefix changes the security checking process. We’ll come back to the implications
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> prefix in [Chapter
    7](chapter7.xhtml), when we talk about access modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the prefix comes the operation’s verb: <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp>,
    in the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>.
    The rest of the name relates to the kernel object type the system call operates
    on. Common system-call verbs that perform an operation on a kernel object include:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Create  </samp>Creates a new object.
    Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Nt</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp>
    PowerShell commands.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Open  </samp>Opens an existing
    object. Maps to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Nt</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><Type></samp> PowerShell commands.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryInformation  </samp>Queries
    object information and properties.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetInformation  </samp>Sets object
    information and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Certain system calls perform type-specific operations. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryDirectoryFile</samp>
    is used to query the entries in a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object directory. Let’s look at the C-language prototype for the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call to understand what parameters need to be passed to a typical call.
    As shown in [Listing 2-6](chapter2.xhtml#Lis2-6), the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: The C prototype for NtCreateMutant'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter for the system call is an outbound pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>.
    Common in many system calls, this parameter is used to retrieve an opened handle
    to the object (in this case, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>)
    when the function succeeds. We use handles along with other system calls to access
    properties and perform operations. In the case of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object, the handle allows us to acquire and release the lock to synchronize threads.
  prefs: []
  type: TYPE_NORMAL
- en: Next is <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>,
    which represents the operations the caller wants to be able to perform on the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> using the handle.
    For example, we could request access that allows us to wait for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    to be unlocked. If we didn’t request that access, any application that tried to
    wait on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp> would
    immediately fail. The access granted depends on the results of the SRM’s access
    check. We’ll discuss handles and <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Third is the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAttributes</samp>
    parameter, which defines the attributes for the object to open or create. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> structure
    is defined as shown in [Listing 2-7](chapter2.xhtml#Lis2-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: The OBJECT_ATTRIBUTES structure'
  prefs: []
  type: TYPE_NORMAL
- en: This C-language structure starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>,
    which represents the length of the structure. Specifying the structure length
    at the start is a common C-style idiom to ensure that the correct structure has
    been passed to the system call.
  prefs: []
  type: TYPE_NORMAL
- en: Next come <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These are
    taken together, as they indicate how the system call should look up the resource
    being accessed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp>
    is a handle to an opened kernel object to use as the base for looking up the object.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp> field is a
    pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    structure. This is a counted string, defined in [Listing 2-8](chapter2.xhtml#Lis2-8)
    as a C-language structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: The UNICODE_STRING structure'
  prefs: []
  type: TYPE_NORMAL
- en: The structure references the string data through <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>,
    which is a pointer to an array of 16-bit Unicode characters. The string is represented
    in UCS-2 encoding; Windows predates many of the changes to Unicode, such as UTF-8
    and UTF-16.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp> structure
    also contains two length fields, <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumLength</samp>. The first
    length field represents the total valid length of the string pointed to by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes (not in Unicode
    characters). If you’re coming from a C programming background, this length does
    not include any NUL terminating character. In fact, a NUL character is permitted
    in object names.
  prefs: []
  type: TYPE_NORMAL
- en: The second length field represents the maximum length of the string pointed
    to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp>, in bytes. Because
    the structure has two separate lengths, it’s possible to allocate an empty string
    with a large maximum length and a valid length of zero, then update the string
    value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> pointer.
    Note that the lengths are stored as <samp class="SANS_TheSansMonoCd_W5Regular_11">USHORT</samp>
    values, which are unsigned 16-bit integers. Coupled with the length-representing
    bytes, this means a string can be at most 32,767 characters long.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the name of an object, you have two options: you can set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    to an absolute path of, for example, *\BaseNamedObjects\ABC*, or you can set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">RootDirectory</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object for *\BaseNamedObjects* and then pass <samp class="SANS_TheSansMonoCd_W5Regular_11">ABC</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>. These
    two actions will open the same object.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to [Listing 2-7](chapter2.xhtml#Lis2-7), after the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectName</samp>
    parameter comes <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>,
    which is a set of flags to modify the object name lookup process or change the
    returned handle’s properties. [Table 2-3](chapter2.xhtml#tab2-3) shows the valid
    values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    field.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</samp> <samp class="SANS_Futura_Std_Book_11">Object
    Attribute Flags and Descriptions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as inheritable.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Permanent</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as permanent.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Exclusive</samp> | <samp class="SANS_Futura_Std_Book_11">Marks
    the handle as exclusive if creating a new object. Only the same process can open
    a handle to the object.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseInsensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Looks up the object name in a case-insensitive
    manner.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenIf</samp> | <samp class="SANS_Futura_Std_Book_11">If
    using a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Create</samp> <samp
    class="SANS_Futura_Std_Book_11">call, opens a handle to an existing object if
    available.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenLink</samp> | <samp class="SANS_Futura_Std_Book_11">Opens
    the object if it’s a link to another object; otherwise, follows the link. This
    is used only by the configuration manager.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp> | <samp
    class="SANS_Futura_Std_Book_11">Opens the handle as a kernel handle when used
    in kernel mode. This prevents user-mode applications from accessing the handle
    directly.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceAccessCheck</samp> | <samp
    class="SANS_Futura_Std_Book_11">When used in kernel mode, ensures all access checks
    are performed, even if calling the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    <samp class="SANS_Futura_Std_Book_11">version of the system call.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IgnoreImpersonatedDeviceMap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Disables the device map when impersonating.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DontReparse</samp> | <samp
    class="SANS_Futura_Std_Book_11">Indicates not to follow any path that contains
    a symbolic link.</samp> |'
  prefs: []
  type: TYPE_TB
- en: The final two fields in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure allow the caller to specify the Security Quality of Service (SQoS) and
    security descriptor for the object. We’ll come back to SQoS in [Chapter 4](chapter4.xhtml)
    and the security descriptor in [Chapter 5](chapter5.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Next in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateMutant</samp>
    system call in [Listing 2-6](chapter2.xhtml#Lis2-6) is the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitialOwner</samp>
    Boolean parameter, which is specific to this type. In this case, it represents
    whether the created <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    is owned by the caller or not. Many other system calls, especially for files,
    have more complex parameters, which we’ll discuss in more detail later in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTSTATUS Codes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All system calls return a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    code. This status code is composed of multiple components packed into the 32 bits,
    as shown in [Figure 2-3](chapter2.xhtml#fig2-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The NT status code
    structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The most significant two bits (31 and 30) indicate the *severity* of the status
    code. [Table 2-4](chapter2.xhtml#tab2-4) shows the available values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-4:</samp> <samp class="SANS_Futura_Std_Book_11">NT
    Status Severity Codes</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Severity name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_SUCCESS</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_INFORMATIONAL</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_WARNING</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_SEVERITY_ERROR</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> |'
  prefs: []
  type: TYPE_TB
- en: If the severity level indicates a warning or error, then bit 31 of the status
    code will be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. If
    the status code is treated as a signed 32-bit integer, this bit represents a negative
    value. It’s a common coding practice to assume that if the status code is negative
    it represents an error, and if it’s positive it represents a success. As we can
    see from the table, this assumption isn’t completely true—the negative status
    code could also be a warning—but it works well enough in practice.
  prefs: []
  type: TYPE_NORMAL
- en: The next component in [Figure 2-3](chapter2.xhtml#fig2-3), *CC*, is the customer
    code. This is a single-bit flag that indicates whether the status code is defined
    by Microsoft (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>)
    or defined by a third party (a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    Third parties are not obliged to follow this specification, so don’t treat it
    as fact.
  prefs: []
  type: TYPE_NORMAL
- en: Following the customer code is the *R* bit, a reserved bit that must be set
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The next 12 bits indicate the *facility*—that is, the component or subsystem
    associated with the status code. Microsoft has predefined around 50 facilities
    for its own purposes. Third parties should define their own facility and combine
    it with the customer code to distinguish themselves from Microsoft. [Table 2-5](chapter2.xhtml#tab2-5)
    shows a few commonly encountered facilities.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-5:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Status Facility Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Facility name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEFAULT</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">The
    default used for common status codes</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_DEBUGGER</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">Used
    for codes associated with the debugger</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FACILITY_NTWIN32</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Used
    for codes that originated from the Win32 APIs</samp> |'
  prefs: []
  type: TYPE_TB
- en: The final component, the *status code*, is a 16-bit number chosen to be unique
    for the facility. It’s up to the implementer to define what each number means.
    The PowerShell module contains a list of known status codes, which we can query
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp> command
    with no parameters ([Listing 2-9](chapter2.xhtml#Lis2-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: Example output from Get-NtStatus'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how some status values, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PENDING</samp>,
    have a human-readable message. This message isn’t embedded in the PowerShell module;
    instead, it’s stored inside a Windows library and can be extracted at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When we call a system call via a PowerShell command, its status code is surfaced
    through a .NET exception. For example, if we try to open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Directory</samp>
    object that doesn’t exist, we’ll see the exception shown in [Listing 2-10](chapter2.xhtml#Lis2-10)
    displayed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-10: An NTSTATUS exception generated when trying to open a nonexistent
    directory'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-10](chapter2.xhtml#Lis2-10), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp>
    to open the nonexistent path *THISDOESNOTEXIST*. This generates the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS
    0xC0000034</samp> exception, shown here along with the decoded message ❶. If you
    want more information about the status code, you can pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtStatus</samp>
    and format the output as a list to view all its properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Facility</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Severity</samp>. The NT status
    code is an unsigned integer value; however, it’s common to also see it printed
    (incorrectly) as a signed value ❷.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Handles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The object manager deals with pointers to kernel memory. A user-mode application
    cannot directly read or write to kernel memory, so how can it access an object?
    It does this using the handle returned by a system call, as discussed in the previous
    section. Each running process has an associated *handle table* containing three
    pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The handle’s numeric identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The granted access to the handle; for example, read or write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pointer to the object structure in kernel memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the kernel can use a handle, the system call implementation must look
    up the kernel object pointer from the handle table using a kernel API such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ObReferenceObjectByHandle</samp>.
    By providing this handle indirectly, a kernel component can return the handle
    number to the user-mode application without exposing the kernel object directly.
    [Figure 2-4](chapter2.xhtml#fig2-4) shows the handle lookup process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: The handle table
    lookup process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-4](chapter2.xhtml#fig2-4), the user process is trying to perform
    some operation on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object. When a user process wants to use a handle, it must first pass the handle’s
    value to the system call we defined in the previous section ❶. The system call
    implementation then calls a kernel API to convert the handle to a kernel pointer
    by referencing the handle’s numeric value in the process’s handle table ❷.
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether to grant the access, the conversion API considers the type
    of access that the user has requested for the system call’s operation, as well
    as the type of object being accessed. If the requested access doesn’t match the
    granted access recorded in the handle table entry, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_ACCESS_DENIED</samp>
    and the conversion operation will fail. Likewise, if the object types don’t match
    ❸, the API will return <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_OBJECT_TYPE_MISMATCH</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: These two checks are crucial for security. The access check ensures that the
    user can’t perform an operation on a handle to which they don’t have access (for
    example, writing to a file for which they have only read access). The type check
    ensures the user hasn’t passed an unrelated kernel object type, which might result
    in type confusion in the kernel, causing security issues such as memory corruption.
    If the conversion succeeds, the system call now has a kernel pointer to the object,
    which it can use to perform the user’s requested operation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Access Masks</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The granted access value in the handle table is a 32-bit bitfield called an
    *access mask*. This is the same bitfield used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    parameter specified in the system call. We’ll discuss how <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp>
    and the access check process determine the granted access in more detail in [Chapter
    7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: An access mask has four components, as shown in [Figure 2-5](chapter2.xhtml#fig2-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: The access mask
    structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The most important one is the 16-bit *type-specific access component*, which
    defines the operations that are allowed on a particular kernel object type. For
    example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> object might
    have separate bits to specify whether the file is allowed to be read or written
    to when using the handle. In contrast, a synchronization <samp class="SANS_TheSansMonoCd_W5Regular_11">Event</samp>
    might only have a single bit that allows the event to be signaled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working backward, the *standard access* component of the access mask defines
    operations that can apply to any object type. These operations include:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Delete  </samp>Removes the object;
    for example, by deleting it from disk or from the registry
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadControl  </samp>Reads the security
    descriptor information for the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteDac  </samp>Writes the security
    descriptor’s discretionary access control (DAC) to the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOwner  </samp>Writes the owner
    information to the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Synchronize  </samp>Waits on the
    object; for example, waits for a process to exit or a mutant to be unlocked
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover security-related access in more detail in [Chapters 5](chapter5.xhtml)
    and [6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before this are the *reserved* and *special access* bits. Most of these bits
    are reserved, but they include two access values:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AccessSystemSecurity  </samp>Reads
    or writes audit information on the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MaximumAllowed  </samp>Requests
    the maximum access to an object when performing an access check
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access in [Chapter 9](chapter9.xhtml) and <samp class="SANS_TheSansMonoCd_W5Regular_11">MaximumAllowed</samp>
    access in [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the four high-order bits of the access mask (the *generic access*
    component) are used only when requesting access to a kernel object using the system
    call’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> parameter.
    There are four broad categories of access: <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericWrite</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericExecute</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericAll</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: When you request one of these generic access rights, the SRM will first convert
    the access into the corresponding type-specific access. This means you’ll never
    receive access to a handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>;
    instead, you’ll be granted access to the specific access mask that represents
    read operations for that type. To facilitate the conversion, each type contains
    a *generic mapping table*, which maps the four generic categories to type-specific
    access. We can display the mapping table using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtType</samp>,
    as shown in [Listing 2-11](chapter2.xhtml#Lis2-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-11: Displaying the generic mapping table for object types'
  prefs: []
  type: TYPE_NORMAL
- en: The type data doesn’t provide names for each specific access mask. However,
    for all common types, the PowerShell module provides an enumerated type that represents
    the type-specific access. We can access this type through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>
    command. [Listing 2-12](chapter2.xhtml#Lis2-12) shows an example for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">File</samp> type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-12: Displaying the access mask for the File object type'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTypeAccess</samp>
    command shows the access mask value, the name of the access as known to the PowerShell
    module, and the generic access from which it will be mapped. Note how some access
    types are granted only to <samp class="SANS_TheSansMonoCd_W5Regular_11">All</samp>;
    this means that even if you requested generic read, write, and execute access,
    you wouldn’t be granted access to those rights.
  prefs: []
  type: TYPE_NORMAL
- en: You can convert between a numeric access mask and specific object types using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp> command,
    as shown in [Listing 2-13](chapter2.xhtml#Lis2-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-13: Converting access masks using Get-NtAccessMask'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-13](chapter2.xhtml#Lis2-13), we first request the access mask
    from a set of <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp> access
    names and receive the numeric access mask in hexadecimal. Next, we get the access
    mask for the <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    access; as you can see, the value returned is just the numeric value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>. We then request the
    access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">GenericRead</samp>
    but specify that we want to map the generic access to a specific access by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">MapGenericRights</samp> parameter.
    As we’ve specified the access for the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    type, this command uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    type’s generic mapping to convert to the specific access mask. Finally, we convert
    the raw access mask back to a type access using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsTypeAccess</samp>
    parameter, specifying the kernel type to use.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 2-14](chapter2.xhtml#Lis2-14), you can query an object
    handle’s granted access mask through the PowerShell object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccess</samp>
    property. This returns the enumerated type format for the access mask. To retrieve
    the numeric value, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">GrantedAccessMask</samp>
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-14: Displaying the numeric value of the access mask using GrantedAccessMask'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel provides a facility to dump all handle table entries on the system
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    system call. We can access the handle table from PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command, as illustrated in [Listing 2-15](chapter2.xhtml#Lis2-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-15: Displaying the handle table for the current process using Get-NtHandle'
  prefs: []
  type: TYPE_NORMAL
- en: Each handle entry contains the type of the object, the address of the kernel
    object in kernel memory, and the granted access mask.
  prefs: []
  type: TYPE_NORMAL
- en: Once an application has finished with a handle, it can be closed using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp> API. If you’ve received
    a PowerShell object from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Get</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">New</samp> call, then you can
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> method on
    the object to close the handle. You can also close an object handle automatically
    in PowerShell by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Use-NtObject</samp>
    command to invoke a script block that closes the handle once it finishes executing.
    [Listing 2-16](chapter2.xhtml#Lis2-16) provides examples of both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-16: Closing an object handle'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not close handles manually, the .NET garbage collector will close
    them automatically for objects that are not referenced (for example, held in a
    PowerShell variable). You should get into the habit of manually closing handles,
    though; otherwise, you might have to wait a long time for the resources to be
    released, as the garbage collector could run at any time.
  prefs: []
  type: TYPE_NORMAL
- en: If the kernel object structure is no longer referenced, either through a handle
    or by a kernel component, then the object will also be destroyed. Once an object
    is destroyed, all its allocated memory is cleaned up and, if it exists, its name
    in the OMNS is removed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handle Duplication</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can duplicate handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>
    system call. The primary reason you might want to do this is to allow a process
    to take an additional reference to a kernel object. The kernel object won’t be
    destroyed until all handles to it are closed, so creating a new handle maintains
    the kernel object.
  prefs: []
  type: TYPE_NORMAL
- en: Handle duplication can additionally be used to transfer handles between processes
    if the source and destination process handles have <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access. You can also use handle duplication to reduce the access rights on a handle.
    For example, when you pass a file handle to a new process, you could grant the
    duplicated handle only read access, preventing the new process from writing to
    the object. However, you should not rely on this approach for reducing the handle’s
    granted access; if the process with the handle has access to the resource, it
    can just reopen it to get write access.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-17](chapter2.xhtml#Lis2-17) shows some examples of using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> command, which wraps
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateObject</samp>, to perform
    some duplication in the same process. We’ll come back to handle duplication and
    security checks in [Chapter 8](chapter8.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-17: Using Copy-NtObject to duplicate handles'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant</samp>
    object to test handle duplication and extract the current granted access, which
    shows six access rights ❶. For the initial duplication, we’ll keep the same granted
    access ❷. You can see in the first column of the output that the handles are different.
    However, our call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>
    to determine whether the two handles refer to the same underlying kernel object
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Next, we get
    an access mask for <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutant ModifyState</samp>
    access and duplicate the handle, requesting that access ❸. We can see in the output
    that the granted access is now only <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyState</samp>.
    However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtObject</samp>
    return value still indicates the handles refer to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Also relevant to handle duplication are the handle attributes <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>. Setting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Inherit</samp> allows a new process
    to inherit the handle when it’s created. This allows you to pass handles to a
    new process to perform tasks such as redirecting console output text to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp>
    protects the handle from being closed. You can set this attribute by setting the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectFromClose</samp> property
    on the object, which will set the attribute on the native handle. [Listing 2-18](chapter2.xhtml#Lis2-18)
    shows an example of its use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-18: Testing the ProtectFromClose handle attribute'
  prefs: []
  type: TYPE_NORMAL
- en: Any attempt to close the handle will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_HANDLE_NOT_CLOSABLE</samp>
    status code, and the handle will stay open.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Query and Set Information
    System Calls</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A kernel object typically stores information about its state. For example, a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object stores a timestamp
    of when it was created. To allow us to retrieve this information, the kernel could
    have implemented a specific “get process creation time” system call. However,
    due to the volume of information stored for the various types of objects, this
    approach would quickly become unworkable.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the kernel implements generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information system
    calls whose parameters follow a common pattern for all kernel object types. [Listing
    2-19](chapter2.xhtml#Lis2-19) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    information system call’s pattern, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    type as an example; for other types, just replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    with the name of the kernel type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-19: An example Query information system call for the Process type'
  prefs: []
  type: TYPE_NORMAL
- en: All <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information system
    calls take an object handle as the first parameter. The second parameter, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InformationClass</samp>, describes the
    type of process information to query. The information class is an enumerated value;
    the SDK specifies the names of the information classes, which we can extract and
    implement in PowerShell. Querying certain kinds of information might require special
    privileges or administrator access.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every information class, we need to specify an opaque buffer to receive
    the queried information, as well as the length of the buffer. The system call
    also returns a length value, which serves two purposes: it indicates how much
    of the buffer was populated if the system call was successful, and if the system
    call failed, it indicates how big the buffer needs to be with <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INFO_LENGTH_MISMATCH</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: You should be careful about relying on the returned length to determine how
    big a buffer to pass to the query, however. Some information classes and types
    do not correctly set the length needed if you supply a buffer that is too small.
    This makes it difficult to query data without knowing its format in advance. Unfortunately,
    even the SDK rarely documents the exact sizes required.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 2-20](chapter2.xhtml#Lis2-20), the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>
    information call follows a similar pattern. The main differences are that there’s
    no return length parameter, and in this case the buffer is an input to the system
    call rather than an output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-20: An example Set information system call for the Process type'
  prefs: []
  type: TYPE_NORMAL
- en: In the PowerShell module, you can query a type’s information class names using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>
    command, as shown in [Listing 2-21](chapter2.xhtml#Lis2-21). Bear in mind that
    some information class names might be missing from the list, as Microsoft doesn’t
    always document them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-21: Listing the information classes for the Process type'
  prefs: []
  type: TYPE_NORMAL
- en: To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> information
    system call, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>,
    specifying an open object handle and the information class. To call <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>,
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtObjectInformation</samp>.
    [Listing 2-22](chapter2.xhtml#Lis2-22) shows an example of how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-22: Querying a Process object for basic information'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> type doesn’t
    set the return length for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessTimes</samp>
    information class, so if you don’t specify any length, the operation generates
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BUFFER_TOO_SMALL</samp>
    error ❶. However, through inspection or brute force, you can discover that the
    length of the data is 32 bytes. Specifying this value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>
    parameter ❷ allows the query to succeed and return the data as an array of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: For many information classes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformation</samp>
    command knows the size and structure of the query data. If you specify the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AsObject</samp> parameter ❸, you can get
    a preformatted object rather than an array of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, for many information classes the handle object already exposes properties
    and methods to set or query values. The values will be decoded into a usage format;
    for example, in [Listing 2-22](chapter2.xhtml#Lis2-22), the times are in an internal
    format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>
    property on the object will take this internal format and convert it to a human-readable
    date and time.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily inspect properties by accessing them on the object or using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-List</samp> command. For
    example, [Listing 2-23](chapter2.xhtml#Lis2-23) lists all the properties on a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object, then queries
    for the formatted <samp class="SANS_TheSansMonoCd_W5Regular_11">CreationTime</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-23: Querying a handle object for properties and inspecting the CreationTime'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp> classes for
    a type typically have the same enumerated values. The kernel can restrict the
    information class’s enumerated values to one type of operation, returning the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_INVALID _INFO_CLASS</samp>
    status code if it’s not a valid value. For some types, such as registry keys,
    the information class differs between querying and setting, as you can see in
    [Listing 2-24](chapter2.xhtml#Lis2-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-24: Inspecting the QueryInformation and SetInformation classes for
    the Key type'
  prefs: []
  type: TYPE_NORMAL
- en: Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtObjectInformationClass</samp>
    with just the type name returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryInformation</samp>
    class. If you specify the type name and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp>
    parameter, you get the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetInformation</samp>
    class. Notice how the two entries shown have different names and therefore represent
    different information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Input/Output Manager</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The input/output (I/O) manager provides access to I/O devices through *device
    drivers*. The primary purpose of these drivers is to implement a filesystem. For
    example, when you open a document on your computer, the file is made available
    through a filesystem driver. The I/O manager supports other kinds of drivers,
    for devices such as keyboards and video cards, but these other drivers are really
    just filesystem drivers in disguise.
  prefs: []
  type: TYPE_NORMAL
- en: You can manually load a new driver through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp>
    system call or do so automatically using the Plug and Play (PnP) manager. For
    every driver, the I/O manager creates an entry in the *Driver* directory. You
    can list the contents of this directory only if you’re an administrator. Fortunately,
    as a normal user, you don’t need to access anything in the *Driver* directory.
    Instead, you can interact with the driver through a <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object, normally created in the *Device* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Drivers are responsible for creating new <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">IoCreateDevice</samp>
    API. A driver can have more than one <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object associated with it; it may also have zero associated <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    objects if it doesn’t require user interaction. As [Listing 2-25](chapter2.xhtml#Lis2-25)
    shows, we can list the contents of the *Device* directory as a normal user through
    the OMNS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-25: Displaying the Device objects'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see that the objects’ type names are all <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>.
    However, if you go looking for a system call with <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    in the name, you’ll come up empty. That’s because we don’t interact with the I/O
    manager using dedicated system calls; rather, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object system calls such as <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>.
    We can access these system calls through <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtFile</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtFile</samp>, which create
    and open files, respectively, as shown in [Listing 2-26](chapter2.xhtml#Lis2-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-26: Opening a device object and displaying its volume path'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we open *notepad.exe* from the *Windows* directory. The *SystemRoot*
    symbolic link points to the *Windows* directory on the system drive. As the *SystemRoot*
    symbolic link is part of the OMNS, the OMNS initially handles file access. With
    an open handle, we can select the full path to the file and the type name.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the result, we can see that the full path starts with *Device\HarddiskVolume3\*,
    followed by *Windows\notepad.exe* ❶. If we try to display the device, we find
    it’s of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>. Once
    the object manager finds the <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp>
    object, it hands off responsibility for the rest of the path to the I/O manager,
    which calls an appropriate method inside the kernel driver.
  prefs: []
  type: TYPE_NORMAL
- en: We can list the drivers loaded into the kernel using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKernelModule</samp>
    command ([Listing 2-27](chapter2.xhtml#Lis2-27)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-27: Enumerating all loaded kernel drivers'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other operating systems, such as Linux, Windows does not implement core
    network protocols like TCP/IP using built-in system calls. Instead, Windows has
    an I/O manager driver, the *Ancillary Function Driver (AFD)*, which provides access
    to networking services for an application. You don’t need to deal with the driver
    directly; Win32 provides a BSD sockets-style API, called *WinSock*, to handle
    access to it. In addition to the standard internet protocol suite, such as TCP/IP,
    AFD also implements other network socket types, such as Unix sockets and bespoke
    Hyper-V sockets for communication with virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all we’ll say for now about the I/O manager. Next, let’s turn to another
    important subsystem, the process and thread manager.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Process and Thread Manager</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All user-mode code lives in the context of a *process*, each of which has one
    or more *threads* that control the execution of the code. Processes and threads
    are both securable resources. This makes sense: if you could access a process,
    you could modify its code and execute it in the context of a different user identity.
    So, unlike most other kernel objects, you can’t open a process or thread by name.
    Instead, you must open them via a unique, numeric *process ID (PID)* or *thread
    ID (TID)*.'
  prefs: []
  type: TYPE_NORMAL
- en: To get a list of running processes and threads you could brute-force the ID
    space by calling the open system call with every possible ID, but that would take
    a while. Fortunately, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    system call provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemProcessInformation</samp>
    information class, which lets us enumerate processes and threads without having
    access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp> object.
  prefs: []
  type: TYPE_NORMAL
- en: We can access the list of processes and threads by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands
    and passing them the <samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp>
    parameter, as shown in [Listing 2-28](chapter2.xhtml#Lis2-28). We can also use
    the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Process</samp>
    command to produce a similar output. Each of the returned objects has a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Threads</samp> property that we can query
    for the thread information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-28: Displaying processes and threads without high privilege'
  prefs: []
  type: TYPE_NORMAL
- en: The first two processes listed in the output are special. The first is the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idle</samp> process, with PID <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    This process contains threads that execute when the operating system is idle,
    hence its name. It’s not a process you’ll need to deal with regularly. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">System</samp> process, with PID <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, is important because it runs
    entirely in kernel mode. When the kernel or a driver needs to execute a background
    thread, the thread is associated with the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    process.
  prefs: []
  type: TYPE_NORMAL
- en: To open a process or thread, we can pass <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> the PID or
    TID we want to open. The command will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object that we
    can then interact with. For example, [Listing 2-29](chapter2.xhtml#Lis2-29) shows
    how to query the command line and executable path of the current process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-29: Opening the current process by its process ID'
  prefs: []
  type: TYPE_NORMAL
- en: When you open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object using its
    ID, you’ll receive a handle. For convenience, the kernel also supports two *pseudo
    handles* that refer to the current process and the current thread. The current
    process’s pseudo handle is the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    converted to a handle, and for the current thread, it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>.
    You can access these pseudo handles by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Current</samp>
    parameter instead of an ID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtThread</samp> commands.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the security of a process and its threads is independent. If you know
    the ID of a thread, it’s possible to access the thread handle inside a process
    even if you can’t access the process itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Memory Manager</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every process has its own virtual memory address space for a developer to use
    as they see fit. A 32-bit process can access up to 2GB of virtual memory address
    space (4GB on 64-bit Windows), while a 64-bit process can access up to 128TB.
    The kernel’s *memory manager* subsystem controls the allocation of this address
    space.
  prefs: []
  type: TYPE_NORMAL
- en: You’re unlikely to have 128TB of physical memory in your computer, but the memory
    manager has ways of making it look like you have more physical memory than you
    do. For example, it can use a dedicated file on your filesystem, called a *pagefile*,
    to temporarily store memory when it’s not currently needed. As your filesystem’s
    available storage space is much larger than your computer’s physical memory, this
    can provide the appearance of a large amount of memory.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual memory space is shared by memory allocations, and it stores each
    process’s running state as well as its executable code. Each memory allocation
    can have a range of protection states, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>, which must
    be set according to the memory’s purpose. For example, for code to be executed,
    the memory must have a protection state of <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can query all memory status information for a process by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>,
    if you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access right on the process handle. However, reading and writing the memory data
    requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmRead</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">VmWrite</samp> access rights, respectively,
    and a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to allocate new memory and free memory in a process using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFreeVirtualMemory</samp>, which both
    require the <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp> access
    right. Finally, you can change the protection on memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>,
    which also requires <samp class="SANS_TheSansMonoCd_W5Regular_11">VmOperation</samp>
    access.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NtVirtualMemory Commands</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PowerShell wraps these system calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtVirtualMemory</samp> commands.
    Note that these commands all accept an optional <samp class="SANS_TheSansMonoCd_W5Regular_11">Process</samp>
    parameter that lets you access memory in a different process from the current
    one. [Listing 2-30](chapter2.xhtml#Lis2-30) shows the commands in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-30: Performing various memory operations on a process'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we perform several operations. First we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    to list all the memory regions being used by the current process ❶. The returned
    list will be large, but the excerpt shown here should give you a rough idea of
    how the information is presented. It includes the address of the memory region,
    its size, its protection, and its state. There are three possible state values:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Commit  </samp>Indicates that the
    virtual memory region is allocated and available for use.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reserve  </samp>Indicates that
    the virtual memory region has been allocated but there is currently no backing
    memory. Using a reserved memory region will cause a crash.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Free  </samp>Indicates that the
    virtual memory region is unused. Using a free memory region will cause a crash.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder what the difference is between <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>, if using both reserved
    and free memory regions will cause a crash. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp>
    state allows you to reserve virtual memory regions for later use so that nothing
    else can allocate memory within that range of memory addresses. You can later
    convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserve</samp> state
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Commit</samp> by re-calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Free</samp> state indicates regions freely
    available for allocation. We’ll cover what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> columns indicate
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we allocate a 1,000-byte read/write region and capture the address in
    a variable ❷. Passing the address to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    allows us to query only that specific virtual memory region. You might notice
    that although we requested a 1,000-byte region, the size of the region returned
    is 4,096 bytes. This is because all virtual memory allocations on Windows have
    a minimum allocation size; on the system I’m using, the minimum is 4,096 bytes.
    It’s therefore not possible to allocate a smaller region. For this reason, these
    system calls are not particularly useful for general program allocations; rather,
    they’re primitives on which “heap” memory managers are built, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    from the C library.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we read and write to the memory region we just allocated. First we use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-NtVirtualMemory</samp> to read
    out 4 bytes of the memory region and find that the bytes are all zeros ❸. Next,
    we write the bytes 1, 2, 3, and 4 to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>
    ❹. We read the bytes to confirm that the write operation succeeded ❺; the two
    values should match, as shown in the output.
  prefs: []
  type: TYPE_NORMAL
- en: With the memory allocated, we can change the protection using <samp class="SANS_TheSansMonoCd_W5Regular_11">Set
    -NtVirtualMemory</samp>. In this case, we make the allocated memory executable
    by specifying the protection as <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    ❻. Querying the current state of the memory region using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    command ❼ shows that the protection has changed from <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>. Also notice
    that although we requested to change the protection of only 4 bytes, the entire
    4,096-byte region is now executable. This is again due to the minimum memory allocation
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we free the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtVirtualMemory</samp>
    and verify that the memory is now in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Free</samp>
    state ❽. Memory allocated using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    is considered private, as indicated by the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    property shown in [Listing 2-30](chapter2.xhtml#Lis2-30).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Section Objects</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another way of allocating virtual memory is through <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object
    is a kernel type that implements memory-mapped files. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects for two related purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading or writing a file as if it were all read into memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing memory between processes so that the modification in one process is
    reflected in the other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object via the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSection</samp>
    PowerShell command. We must specify the size of the mapping, the protection for
    the memory, and an optional file handle; in return, we get a handle to the section.
  prefs: []
  type: TYPE_NORMAL
- en: However, creating a section doesn’t automatically allow us to access the memory;
    we first need to map it into the virtual memory address space using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>. [Listing
    2-31](chapter2.xhtml#Lis2-31) provides an example in which we create an anonymous
    section and map it into memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-31: Creating a section and mapping it into memory'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object with a size of 4,096 bytes and protection of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    ❶. We don’t specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    parameter, which means it’s anonymous and not backed by any file. If we gave the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object an OMNS path,
    the anonymous memory it represents could be shared with other processes.
  prefs: []
  type: TYPE_NORMAL
- en: We then map the section into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>,
    specifying the protection we want for the memory, and query the mapped address
    to verify that the operation succeeded ❷. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp>. When we’re
    done with the mapping, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>
    to unmap the section and then verify that it’s now free ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we demonstrate that we can’t map a section with different protection
    than that granted when we created the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object ❹. When we try to map the section with read and execute permissions, which
    aren’t compatible, we see an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The protection you’re allowed to use to map a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object into memory depends on two things. The first is the protection specified
    when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object was
    created. For example, if the section was created with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>
    protection, you can never map it to be writable.
  prefs: []
  type: TYPE_NORMAL
- en: The second dependency is the access granted to the section handle you’re mapping.
    If you want to map the section as readable, then the handle must have <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>
    access. To map it to be writable, you need both <samp class="SANS_TheSansMonoCd_W5Regular_11">MapRead</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. (And,
    of course, having just <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access isn’t sufficient to map the section as writable if the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object was not specified with a writable protection.)
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to map a section into another process by specifying a process
    handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>.
    We don’t need to specify the process to <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSection</samp>,
    as the mapping object knows what process it was mapped in. In the memory information
    output, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column would
    be populated by the name of the backing file, if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: The section we created was anonymous, so we don’t see anything in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> column, but we can perform
    a query to find mapped sections that are backed by files using the command shown
    in [Listing 2-32](chapter2.xhtml#Lis2-32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-32: Listing mapped files with names'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anonymous</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Mapped</samp> types, there is
    a third section type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>
    type. When provided with a file handle to a Windows executable, the kernel will
    automatically parse the format and generate multiple subsections that represent
    the various components of the executable. To create a mapped image from a file,
    we need only <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp> access
    on the file handle; the file doesn’t need to be readable for us.
  prefs: []
  type: TYPE_NORMAL
- en: Windows uses image sections extensively to simplify the mapping of executables
    into memory. We can specify an image section by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>
    flag when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object or by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSectionImage</samp>
    command, as shown in [Listing 2-33](chapter2.xhtml#Lis2-33).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-33: Mapping <samp class="SANS_Futura_Std_Book_11">notepad.exe</samp>
    and viewing the loaded image'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we don’t need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteRead</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp> protection
    when mapping the image section. Any protection, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadOnly</samp>,
    will work ❶. When we get the memory information for a map-based address, we see
    that there is no executable memory there and that the allocation is only 4,096
    bytes ❷, which seems far too small for *notepad.exe*. This is because the section
    is made up of multiple smaller mapped regions. If we filter out the memory information
    for the mapped name ❸, we can see the executable memory. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>
    command, we can print the contents of the mapped file buffer ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Integrity</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important security task is ensuring that the code running on your computer
    is the same code the manufacturer intended you to run. If a malicious user has
    modified operating system files, you might encounter security issues such as the
    leaking of private data.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft considers the integrity of code running on Windows to be so important
    that there is an entire subsystem to deal with it. This *code integrity* subsystem
    verifies and restricts what files can execute in the kernel, and optionally in
    user mode, by checking the code’s integrity. The memory manager can consult with
    the code integrity subsystem when it loads an image file if it needs to check
    whether the executable is correctly signed.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every executable on a default Windows installation is signed using a
    mechanism called *Authenticode*. This mechanism allows a cryptographic signature
    to be embedded in the executable file or collected inside a catalog file. The
    code integrity subsystem can read this signature, verify that it’s valid, and
    make trust decisions based on it.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AuthenticodeSignature</samp>
    command to query the signing status of an executable, as shown in [Listing 2-34](chapter2.xhtml#Lis2-34).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-34: Displaying the Authenticode signature for a kernel driver'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we query the signing status of the *notepad.exe* executable file, formatting
    the command’s output as a list. The output starts with information about the signer’s
    X.509 certificate. Here, I’ve shown only the subject name, which clearly indicates
    that this file is signed by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the status of the signature; in this case, the status indicates that
    the file is valid and that the signature has been verified. It’s possible to have
    a signed file whose signature is invalid; for example, when the certificate has
    been revoked. In that case, the status is likely to show an error, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NotSigned</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SignatureType</samp> property
    shows that this signature was based on a catalog file rather than being embedded
    in the file. We can also see that this file is an operating system binary, as
    determined by information embedded in the signature.
  prefs: []
  type: TYPE_NORMAL
- en: The most common trust decision the code integrity subsystem makes is checking
    whether a kernel driver can load. Each driver file must have a signature that
    derives its trust from a Microsoft-issued key. If the signature is invalid or
    doesn’t derive from a Microsoft-issued key, then the kernel can block loading
    of the driver to preserve system integrity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Advanced Local Procedure Call</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *advanced local procedure call (ALPC)* subsystem implements local, cross-process
    communication. To use ALPC, you must first create a server ALPC port using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateAlpcPort</samp> system call
    and specify a name for it inside the OMNS. A client can then use this name by
    calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtConnectAlpcPort</samp>
    system call to connect to the server port.
  prefs: []
  type: TYPE_NORMAL
- en: At a basic level, the ALPC port allows the secure transmission of discrete messages
    between a server and a client. ALPC provides the underlying transport for local
    remote procedure call APIs implemented in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Configuration Manager</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *configuration manager*, known more commonly as the *registry*, is an important
    component for configuring the operating system. It stores a variety of configuration
    information, ranging from the system-critical list of available I/O manager device
    drivers to the (less critical) last position on the screen of your text editor’s
    window.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the registry as a filesystem in which *keys* are like folders
    and *values* are like files. You can access it through the OMNS, although you
    must use registry-specific system calls. The root of the registry is the OMNS
    path *REGISTRY*. You can list the registry in PowerShell using the *NtObject*
    drive, as shown in [Listing 2-35](chapter2.xhtml#Lis2-35).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-35: Enumerating the registry root key'
  prefs: []
  type: TYPE_NORMAL
- en: You can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObject:\REGISTRY</samp>
    in [Listing 2-35](chapter2.xhtml#Lis2-35) with <samp class="SANS_TheSansMonoCd_W5Regular_11">NtKey:\</samp>
    to make accessing the registry simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel pre-creates the four keys shown here when it initializes. Each of
    the keys is a special *attachment point* at which you can attach a registry hive.
    A *hive* is a hierarchy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    objects underneath a single root key. An administrator can load new hives from
    a file and attach them to these preexisting keys.
  prefs: []
  type: TYPE_NORMAL
- en: Note that PowerShell already comes with a drive provider that you can use to
    access the registry. However, this drive provider exposes only the Win32 view
    of the registry, which hides the internal details about the registry from view.
    We’ll cover the Win32 view of the registry separately in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: You can interact with the registry directly, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtKey</samp> commands to
    open and create <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> objects,
    respectively. You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtKeyValue</samp> to get
    and set key values. To remove keys or values, use <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKey</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtKeyValue</samp>. [Listing
    2-36](chapter2.xhtml#Lis2-36) shows a few of these commands in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-36: Opening a registry key and querying its values'
  prefs: []
  type: TYPE_NORMAL
- en: We open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp> object using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKey</samp> command. We
    can then query the values stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key</samp>
    object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtKeyValue</samp>
    command. Each entry in the output shows the name of the value, the type of data
    stored, and a string representation of the data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using PowerShell, you can easily change this book’s example scripts to do many
    different things. To encourage experimentation, each chapter wraps up with a set
    of worked examples repurposing the various commands you’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, I’ll also highlight times where I’ve discovered security
    vulnerabilities using this tooling. This should give you a clear indication of
    what to look for in Microsoft or third-party applications if you’re a security
    researcher; likewise, for developers, it will help you avoid certain pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Open Handles
    by Name</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The objects returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command have additional properties that allow you to query the object’s name and
    security descriptor. These properties are not shown by default, as they’re expensive
    to look up; doing so requires opening the process containing the handle for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access, duplicating the
    handle back to the calling PowerShell instance, and finally querying the property.
  prefs: []
  type: TYPE_NORMAL
- en: If performance doesn’t matter to you, then you can use the code in [Listing
    2-37](chapter2.xhtml#Lis2-37) to find all open files matching a specific filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-37: Finding File object handles that match a specific name'
  prefs: []
  type: TYPE_NORMAL
- en: This script queries for all <samp class="SANS_TheSansMonoCd_W5Regular_11">File</samp>
    object handles and filters them to only the ones with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Windows</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> property, which
    represents the filepath. Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    property has been queried, it’s cached so you can then display it to the console
    with a custom selection.
  prefs: []
  type: TYPE_NORMAL
- en: Note that because it duplicates the handle from the process, this script can
    only show handles in processes the caller can open. To get the best results, run
    it as an administrator user who can open the maximum number of processes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Shared Objects</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you query the list of handles using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp>
    command, you also get the address of the object in kernel memory. When you open
    the same kernel object, you’ll get different handles, but they will still point
    to the same kernel object address.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the object address to find processes that share handles. This can
    be interesting for security in cases where an object is shared between two processes
    with different privileges. The lower-privileged process might be able to modify
    the properties of the object to bypass security checks in the higher-privileged
    process, enabling it to gain additional privileges.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, I used this technique to find security issue CVE-2019-0943 in Windows.
    At the root of the issue was a privileged process, the Windows Font Cache, that
    shared section handles with a low-privileged process. The low-privileged process
    could map the shared section to be writable and modify contents that the privileged
    process assumed couldn’t be modified. This effectively allowed the low-privileged
    process to modify arbitrary memory in the privileged process, resulting in privileged
    code execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-38](chapter2.xhtml#Lis2-38) gives an example of finding writable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects shared between
    two processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-38: Finding shared Section handles'
  prefs: []
  type: TYPE_NORMAL
- en: We first get the handles, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    parameter. This returns a list of groups organized based on the kernel object
    address, instead of a list of handles. You can also group handles using the built-in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Group-Object</samp> command; however,
    the groups returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">GroupByAddress</samp>
    have additional properties, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ShareCount</samp>,
    which indicates the number of unique processes an object is shared with. Here,
    we filter to include only handles that are shared between two processes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to find <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects that can be mapped as writable. We first check that all the handles have
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp> access. As mentioned
    earlier, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object’s
    protection must also be writable for us to be able to map it as writable. Oddly,
    we can’t query for the original protection that was assigned when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object was created, but checking for <samp class="SANS_TheSansMonoCd_W5Regular_11">MapWrite</samp>
    access is a simple proxy. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessIntersection</samp>
    property, which contains the granted access rights shared among all the handles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have potential candidates for shared sections, we need to work
    out which meet the criterion that we can access only one of the processes containing
    the section handle. We’re making another assumption here: if we can open only
    one of the two processes that share the handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access, then we’ve got a section shared between a privileged and a low-privileged
    process. After all, if you had <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp>
    access to both processes, you could already compromise the processes by stealing
    all their handles or duplicating their process handles, and if you couldn’t get
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DupHandle</samp> access to either
    process, then you couldn’t get access to the section handle at all.'
  prefs: []
  type: TYPE_NORMAL
- en: The result shown in [Listing 2-38](chapter2.xhtml#Lis2-38) is a section shared
    between Chrome and the Audio Device Graph process. The shared section is used
    to play audio from the browser, and it’s probably not a security issue. However,
    if you run the script on your own system, you might find shared sections that
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Note that once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object is mapped into memory, the handle is no longer required. Therefore, you
    might miss some shared sections that were mapped when the original handle closed.
    It’s also highly likely you’ll get false positives, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    objects that are intentionally writable by everyone. The goal here is to find
    a potential attack surface on Windows. You must then go and inspect the handles
    to see if sharing them has introduced a security issue.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modifying a Mapped
    Section</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you find an interesting <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object to modify, you can map it into memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSection</samp>.
    But how do you modify the mapped memory? The simplest approach from the command
    line is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>
    command, which supports passing a mapped section and an array of bytes to write.
    [Listing 2-39](chapter2.xhtml#Lis2-39) demonstrates this technique by assuming
    you have a handle of interest in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$handle</samp>
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-39: Mapping and modifying a Section object'
  prefs: []
  type: TYPE_NORMAL
- en: We first call the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetObject</samp>
    method on the handle to duplicate it into the current process and return a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> object. For this to succeed,
    the process in which we’re running this command must be able to access the process
    with the handle. We then map the handle as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadWrite</samp>
    into the current process’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a random array of bytes up to the size of the mapped section
    and write them to the memory region using <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-NtVirtualMemory</samp>.
    This is a quick and dirty fuzzer for the shared memory. The hope is that by modifying
    the memory, the privileged process will mishandle the contents of the memory region.
    If the privileged process crashes, we should investigate to determine whether
    we can control the crash using a more targeted modification of the shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: We can display the memory using <samp class="SANS_TheSansMonoCd_W5Regular_11">Out-HexDump</samp>.
    One of the useful features of this command over the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp>
    is that it’ll print the address in memory based on the mapped file, whereas <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-Hex</samp> just prints an offset
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a GUI hex editor with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtSection</samp>
    command, specifying a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    object to edit. As the section can be mapped into any process, writing it in the
    GUI hex editor will also modify all other mappings of that section. Here is the
    command to display the hex editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-6](chapter2.xhtml#fig2-6) shows an example of the editor generated
    by running the previous command.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The section editor
    GUI</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The GUI shown in [Figure 2-6](chapter2.xhtml#fig2-6) maps the section into memory
    and then displays it in a hex editor form. If the section is writable, you can
    modify the contents of the memory through the editor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Writable
    and Executable Memory</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Windows, for a process to execute instructions, the memory must be marked
    as executable. However, it’s also possible to map the memory as both writable
    and executable. Malware sometimes uses this combination of permissions to inject
    shell code into a process and run malicious code using the host process’s identity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-40](chapter2.xhtml#Lis2-40) shows how to check for memory in a process
    that is both writable and executable. Finding such memory might indicate that
    something malicious is going on, although in most cases this memory will be benign.
    For example, the .NET runtime creates writable and executable memory to perform
    just-in-time (JIT) compilation of the .NET byte code into native instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-40: Finding executable and writable memory in a process'
  prefs: []
  type: TYPE_NORMAL
- en: We start by opening a process for <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access, which is all we need to enumerate the virtual memory regions. Here, we’re
    opening the current PowerShell process; as PowerShell is .NET, we know it will
    have some writable and executable memory regions, but the process you open can
    be anything you want to check.
  prefs: []
  type: TYPE_NORMAL
- en: We then enumerate all the memory regions using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtVirtualMemory</samp>
    and filter on the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecuteReadWrite</samp>
    protection type. We need to use a bitwise AND operation as there are additional
    flags that can be added to the protection, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Guard</samp>,
    which creates a guard page that prevents doing a direct equality check.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter provided a tour through the Windows kernel and its internals. The
    kernel consists of many separate subsystems, such as the Security Reference Monitor,
    the object manager, the configuration manager (or registry), the I/O manager,
    and the process and thread manager.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about how the object manager manages kernel resources and types,
    how to access kernel resources through system calls, and how handles are allocated
    with specific access rights. You also accessed object manager resources through
    the *NtObject* drive provider as well as through individual commands.
  prefs: []
  type: TYPE_NORMAL
- en: I then discussed the basics of process and thread creation and demonstrated
    the use of commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    to query for process information on the system. I explained how to inspect the
    virtual memory of a process, as well as some of the individual memory types.
  prefs: []
  type: TYPE_NORMAL
- en: A user doesn’t directly interact with the kernel; instead, user-mode applications
    power the user experience. In the next chapter, we’ll discuss the user-mode components
    in more detail.
  prefs: []
  type: TYPE_NORMAL
