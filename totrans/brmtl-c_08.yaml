- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Local Variables and Procedures
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we’ve been using a design pattern called “one big mess.” All code is
    dumped into `main`, and all variables are defined at the beginning of the program.
    This method works fine when your program is 100 or fewer lines long, but when
    you’re dealing with a 500,000-line program, you’re going to need some organization.
    This chapter discusses ways of limiting the scope of variables and instructions
    so you can make long, unmanageable blocks of code easier to understand, manage,
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can use a *global variable* anywhere in a program. To know
    where and how it’s used in a 500,000-line program, however, you have to scan all
    500,000 lines. A *local variable* has limited scope. To understand where and how
    a local variable is used, all you need to do is examine the, say, 50 to 200 lines
    of code where it is valid.
  prefs: []
  type: TYPE_NORMAL
- en: As your programs get longer and longer, you’ll learn how to divide the code
    into easily understood sections called *procedures*. Global variables will be
    available to every procedure, but you can define local variables that are available
    only to a single procedure. You’ll also learn how local variables are organized
    internally into stack frames. Given the limited amount of memory on our STM microcontroller,
    it’s very important to understand how much stack memory we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll learn about *recursion*, which is where a procedure refers to
    itself. Recursion is complex in what it can do but simple if you understand the
    rules and follow them.
  prefs: []
  type: TYPE_NORMAL
- en: Local Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we’ve been using only global variables that are available
    everywhere in the program, from the line they are declared to the end of the program.
    Local variables are available to a much smaller, or local, area of a program.
    This area where a variable is valid is called its *scope*. [Listing 7-1](#listing7-1)
    demonstrates the declaration of local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***local.c***'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Local variables'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a local variable starts where it is declared and goes to the end
    of the enclosing curly brackets (`{}`). The variable `localToProcedure` is valid
    for the entire `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at smaller scopes, starting with the declaration of the `local`
    variable 1. The scope of this variable doesn’t end at the very next closing curly
    bracket 2, which is for a different block (section of code enclosed in curly brackets).
    Instead, it goes to the end bracket 3 for the block that started right before
    `local` was declared. The `veryLocal` variable has an even smaller scope. It starts
    with the declaration `int veryLocal = 7;` and ends when the block ends 2.
  prefs: []
  type: TYPE_NORMAL
- en: When a variable’s scope ends, the program can’t use the variable anymore. For
    example, trying to return the value of `veryLocal` at the end of `main` using
    the `return(veryLocal);` statement wouldn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, all the local variables had different names in addition
    to having different scope. However, variables can also have the same name in different
    scopes. If multiple variables have the same name, C will use the value of the
    one in the current scope and hide the others. (Please don’t do this because it
    makes code confusing. It’s mentioned here so you know what to avoid.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at [Listing 7-2](#listing7-2), which demonstrates a very badly
    written program.
  prefs: []
  type: TYPE_NORMAL
- en: '**hidden.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Hidden variables'
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we define three variables, all named `var`. When the second
    one is defined 2, it hides the first one 1. Similarly, the `int var = 16;` declaration
    hides the second variable `var` 2, which hides the first one 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we were to add the following statement after the third declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Which `var` are we assigning? The one declared at 1, 2, or 3? The fact that
    we have to ask this question is a good indicator that this code is confusing.
    I’m not going to leave it as an exercise for the reader to find the answer because
    the proper solution is to never do this in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *procedure* is a way to define code so it can be used again. Let’s look at
    [Listing 7-3](#listing7-3), which provides a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: '**hello3.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: A procedure demonstration'
  prefs: []
  type: TYPE_NORMAL
- en: This program prints `Hello` three times, then `World!`. The procedure starts
    with a comment block, which isn’t strictly necessary, but if you’re going to write
    quality code, you should put one in before each procedure. The beginning (`/**`)
    of the comment block indicates that the Doxygen documentation tool should process
    it. To be compatible with the format of the STM libraries, we are using the same
    commenting convention.
  prefs: []
  type: TYPE_NORMAL
- en: The statement `void sayHello(void)` 1 tells C that our procedure’s name is `sayHello`.
    It returns nothing (first `void`) and takes no parameters (second `void`). The
    `{}` block that follows this statement defines the body of the procedure and contains
    all the instructions executed by the procedure 2. The three `sayHello();` lines
    3 are calls to the `sayHello` procedure. They tell the processor to save the location
    of the next statement (either another call to `sayHello` or the call to `puts`)
    and then start execution with the first line of `sayHello`. When the procedure
    finishes (or hits a `return` statement), execution continues at the point saved
    during the call.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procedures have their own local variables. The compiler’s job is to organize
    memory so it can hold those variables. For global variables (not in a procedure),
    the compiler says something like, “I need 4 bytes to hold the integer named `Total`.”
    The linker then sees that and assigns the variable a physical location in memory
    (for example, `0xffffec04`). Global variables are allocated statically at compile
    time, meaning the compiler allocates space for the variables and that’s it. The
    variables are never destroyed, and their memory is not reallocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables that are local to a procedure are more complex. They have to be allocated
    dynamically at runtime. When a procedure starts, all the local variables for that
    procedure are allocated. (Note: there is a `static` local variable that’s allocated
    at compile time, but we haven’t covered that yet.) When the procedure ends, they
    are deallocated. The compiler accomplishes this by creating a *stack frame* when
    the procedure starts and destroying it when the procedure ends. The stack frame
    holds all the temporary information the procedure needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at [Listing 7-4](#listing7-4), which shows a sample program.
  prefs: []
  type: TYPE_NORMAL
- en: '**proc.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: A stack frame demonstration'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a project for this program and start debugging it. Run the program
    in the debugger, then step through it using the command **Run**▶**Step Into**
    (F5) until you reach 1. Your screen should look like [Figure 7-1](#figure7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07001](image_fi/501621c07/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: Debugging *proc.c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a program is loaded, all the statically allocated variables get their
    own memory locations. In the STM32 chip, they are assigned to the lower portion
    of the random access memory (RAM). The leftover memory is reserved for dynamic
    allocation. Specifically, two memory areas are used dynamically: the *stack*,
    which holds local variables, and the *heap*. We won’t worry about the heap for
    now; our microprocessor doesn’t have enough memory to use it. (We’ll discuss the
    heap in Chapter 13, when we talk about programming for larger systems.)'
  prefs: []
  type: TYPE_NORMAL
- en: The name *stack* comes from the fact that data is stacked on top of each other
    in memory. When your program starts, the `main` function allocates a stack frame
    for its local variables and temporary values. When `outer` is called, it allocates
    another stack frame on top of the one for `main`. The call to `inner` adds a third
    stack frame to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: To see where the stack is in each procedure, click the **Registers** tab in
    the upper-right panel and scroll down until you see the `rsp` register. [Figure
    7-2](#figure7-2) shows that it contains `0x7fffffffd0e0`.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002](image_fi/501621c07/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: Displaying the registers'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the machine, the stack may either start at a low memory address
    and grow up or at a high memory address and grow down. On this machine (the x86),
    it starts high and goes down.
  prefs: []
  type: TYPE_NORMAL
- en: The stack from the `outer` frame is at `0x7fffffffd0f0`. Because our stack grows
    down, this number is lower than the stack frame for `main`. The `inner` frame
    is at `0x7fffffffd110` (see [Table 7-1](#table7-1)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-1: Stack Usage'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Procedure** | **Contents** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0x7fffffffd110` | `main` | <overhead> | Bottom of stack |'
  prefs: []
  type: TYPE_TB
- en: '| `0x7fffffffd0f0` | `outer` | <overhead> `i`'
  prefs: []
  type: TYPE_NORMAL
- en: '`j` |  |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `0x7fffffffd0e0` | `inner` | <overhead> `i`'
  prefs: []
  type: TYPE_NORMAL
- en: '`k` | Top of stack |'
  prefs: []
  type: TYPE_NORMAL
- en: One key concept to understand is that stack frames are allocated in last in,
    first out (LIFO) order. When we are done with `inner`, its stack frame will be
    destroyed and then the `outer` frame will be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The Variables panel (shown in [Figure 7-1](#figure7-1), upper right) displays
    the `i` and `k` variables. The debugger is displaying the variables in the stack
    frame for `inner`, indicated by the fact that the stack frame for `inner` is highlighted
    in the Debug panel (upper left). Click the `outer` stack frame in the Debug panel,
    and you’ll see the Variables panel change and show the variables for `outer`,
    as in [Figure 7-3](#figure7-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07003](image_fi/501621c07/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: The `outer` stack frame'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue debugging the program by stepping past the last instruction of
    `inner`. When we exit `inner`, the stack frame for that function disappears, because
    we are no longer executing `inner` and have no need for a place to store its variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4](#figure7-4) shows the stack after we exit the `inner` stack frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f07004](image_fi/501621c07/f07004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: The stack after exiting the `inner` stack frame'
  prefs: []
  type: TYPE_NORMAL
- en: Notice there are now only two stack frames on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve been dealing with basic procedure calls; each procedure was given
    a different name, and the calling process was simple. Now we’re going to focus
    on *recursion*, which is when a function calls itself. Recursion can be a powerful
    tool, but it’s tricky to use if you don’t understand the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic recursive problem is computing a factorial. The factorial function
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: f(*n*) = 1, when *n* is 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: otherwise, f(*n*) = *n* × f(*n* – 1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turning this into code gives us [Listing 7-5](#listing7-5).
  prefs: []
  type: TYPE_NORMAL
- en: '**factor.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: A program to compute factorials'
  prefs: []
  type: TYPE_NORMAL
- en: First, we call `factor(5)` to get the factorial of 5\. For that, we need `factor(4)`,
    so we suspend `factor(5)` while we call `factor(4)`. But `factor(4)` needs `factor(3)`,
    so we suspend work and call `factor(3)`. Now `factor(3)` needs `factor(2)`, and,
    again, `factor(2)` needs `factor(1)`. Finally, `factor(1)` doesn’t need anything,
    so it returns 1 to its caller, `factor(2)`. The function `factor(2)` is running,
    so it computes 2 × 1 and returns 2 to its caller, `factor(3)`. Next, `factor(3)`
    takes the return value (2), computes 2 × 3, and returns 6 to its caller, `factor(4)`.
    Nearing the end, `factor(4)` computes 6 × 4 and returns 24\. Finally, `factor(5)`
    computes 24 × 5 and returns 120.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute this program in the debugger, you should see the stack grow
    and shrink as the program computes the factorial. You also should see a stack
    with five stack frames allocated for the `factor` procedure, one for each instance:
    `factor(1)`, `factor(2)`, `factor(3)`, `factor(4)`, and `factor(5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two rules determine when you can use recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: Each call to the procedure must make the problem simpler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There must be an end point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s see how those rules work with our factorial program. In order to compute
    `factor(5)`, we need to compute `factor(4)`. The first rule is satisfied because
    `factor(4)` is simpler than `factor(5)`. Sooner or later, we reach `factor(1)`,
    and that’s the end point, which satisfies the second rule.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s violate the rules to see what happens; we’ll modify the program and try
    to compute `factor(-1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Does this satisfy the two rules? Well, `factor(-1)` needs `factor(-2)`, which
    needs `factor(-3)`, and so on, until we reach 1\. But there is no way to go from
    –1 to 1 by subtraction, so we have no way of ending the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run this program on my little Linux box, I see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The system ran out of stack memory, and the program aborted because it violated
    the constraints of the memory protection of the x86 processor. On other systems,
    the results may be different. For example, on ARM processors, the stack can run
    into the heap and trash it (more on the heap in Chapter 13), or something else
    can get clobbered. In any case, running out of stack is not a good thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the program got all the way to `x=-262007` before it aborted.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book, we try to use good programming style whenever we can. For example,
    we’ve made sure to include a comment block at the top of every procedure, and
    we always include a comment after each variable declaration. Good programming
    style is designed the way it is for two reasons: to give the programmer who comes
    after you a clear idea of what you did and to make it difficult to make errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We violated one of those rules in the factorial example. This is the offending
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s wrong with it? The `int` type is signed, but you can compute the factorial
    only on positive numbers. We could have written our function as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Writing it that way would make it impossible to pass in a negative number. Note
    that the compiler will helpfully change –1 to an unsigned number (4294967295)
    without warning, unless you include the compiler switch `-Wconversion`. GCC has
    hundreds of options, and finding out which to use is its own art form. The first
    version of that line did have two advantages, however; it’s a good example of
    bad style, and it allowed us to demonstrate stack overflow with `factor(-1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed something about this book. It’s divided into chapters.
    Why? To make it easier to read, of course. A chapter provides the reader with
    an understandable unit of information that can be absorbed in one sitting.
  prefs: []
  type: TYPE_NORMAL
- en: Computer programs need to be divided into bite-size chunks as well. It’s impossible
    to keep track of a 750,000-line program. It is possible to understand everything
    about a 300-line procedure. Local variables also help in this organization. If
    you have a variable that’s local to a 300-line procedure, you know it will be
    used only in those 300 lines. On the other hand, a global variable can be used
    anywhere in a 750,000-line program.
  prefs: []
  type: TYPE_NORMAL
- en: The key to writing good code is to make it understandable and simple. Procedures
    help you divide your program into simple, understandable units, which helps you
    write code that’s more reliable and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a function to compute the area of a triangle and a small main program
    to test it with three different sets of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a procedure called `max` that returns the maximum of two numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that computes the fifth Fibonacci number. Bonus points for doing
    it recursively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that adds up the digits in a number. For example, 123 results
    in 6 (in other words, 1 + 2 + 3). If the result is 10 or greater, the process
    should repeat until the result is a single digit. For example, 987 is 9 + 8 +
    7 = 24\. That’s bigger than 10, so 24 is 2 + 4, which yields 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
