- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Same-Origin Policy Vulnerabilities
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略漏洞
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 3 introduced the same-origin policy (SOP), one of the fundamental defenses
    deployed in modern web applications. The SOP restricts how a script originating
    from one site can interact with the resources of a different site, and it’s critical
    in preventing many common web vulnerabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章介绍了同源策略（SOP），这是现代web应用中部署的基本防御之一。SOP限制了来自一个站点的脚本如何与另一个站点的资源进行交互，并且它在防止许多常见的web漏洞中起着至关重要的作用。
- en: But websites often loosen the SOP in order to have more flexibility. These controlled
    and intended SOP bypasses can have adverse effects, as attackers can sometimes
    exploit misconfigurations in these techniques to bypass the SOP. These exploits
    can cause private information leaks and often lead to more vulnerabilities, such
    as authentication bypass, account takeover, and large data breaches. In this chapter,
    we’ll discuss how applications relax or work around the SOP and how attackers
    can exploit these features to endanger the application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，网站通常会放松SOP以获得更多灵活性。这些受控和有意的SOP绕过可能会带来不利影响，因为攻击者有时会利用这些技术中的配置错误来绕过SOP。这些漏洞可能导致私人信息泄露，并常常导致更多的漏洞，如身份验证绕过、账户接管和大规模数据泄露。在本章中，我们将讨论应用如何放宽或规避SOP，以及攻击者如何利用这些功能来危及应用程序。
- en: Mechanisms
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: Here’s a quick review of how the SOP works. Because of the SOP, a script from
    page A can access data from page B only if the pages are of the same origin. Two
    URLs are said to have the *same origin* if they share the same protocol, hostname,
    and port number. Modern web applications often base their authentication on HTTP
    cookies, and servers take action based on the cookies included automatically by
    the browser. This makes the SOP especially important. When the SOP is implemented,
    malicious web pages won’t be able to take advantage of the cookies stored in your
    browser to access your private information. You can read more about the details
    of the SOP in Chapter 3.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是SOP如何工作的简要回顾。由于SOP的存在，来自页面A的脚本只能在页面B的来源相同的情况下访问数据。两个URL被认为具有*相同来源*，如果它们共享相同的协议、主机名和端口号。现代web应用通常基于HTTP
    cookies进行身份验证，服务器根据浏览器自动包含的cookies采取行动。这使得SOP尤其重要。当SOP被实施时，恶意网页无法利用存储在你浏览器中的cookies来访问你的私人信息。你可以在第3章中阅读更多关于SOP的详细信息。
- en: Practically, the SOP is often too restrictive for modern web applications. For
    example, multiple subdomains or multiple domains of the same organization wouldn’t
    be able to share information if they followed the policy. Since the SOP is inflexible,
    most websites find ways to relax it. This is often where things go wrong.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，SOP对现代web应用来说通常过于严格。例如，如果遵循该策略，同一组织的多个子域或多个域将无法共享信息。由于SOP缺乏灵活性，大多数网站会找到放宽它的方法。这通常是问题出现的地方。
- en: For instance, imagine that you are an attacker trying to smuggle information
    out of a banking site, *a.example.com*, and find a user’s account number. You
    know that a user’s banking details are located at *a.example.com/user_info*. Your
    victim is logged into the banking site at *a.example.com* and is also visiting
    your site, *attacker.com*, in the same browser.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设你是一个攻击者，试图从一个银行网站窃取信息，*a.example.com*，并找出一个用户的账户号码。你知道用户的银行信息位于 *a.example.com/user_info*。你的受害者已经登录到银行网站
    *a.example.com*，并且在同一个浏览器中也访问了你的站点 *attacker.com*。
- en: Your site issues a GET request to *a.example.com/user_info* to retrieve the
    victim’s personal information. Since your victim is logged into the bank, their
    browser automatically includes their cookies in every request it sends to *a.example.com*,
    even if the request is generated by a script on your malicious site. Unfortunately,
    because of the SOP, the victim’s browser won’t allow your site to read data returned
    from *a.example.com*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的站点向 *a.example.com/user_info* 发起一个GET请求，试图获取受害者的个人信息。由于受害者已经登录银行，浏览器会在每个请求中自动包括他们的cookies，即使请求是由你恶意站点上的脚本生成的。不幸的是，由于SOP的存在，受害者的浏览器不会允许你的站点读取从
    *a.example.com* 返回的数据。
- en: But now, say you realize that *a.example.com* passes information to *b.example.com*
    via SOP bypass techniques. If you can find out the technique used and exploit
    it, you might be able to steal the victim’s private information on the banking
    site.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，假设你意识到 *a.example.com* 通过SOP绕过技术将信息传递给 *b.example.com*。如果你能够找出使用的技术并加以利用，你可能能够窃取受害者在银行网站上的私人信息。
- en: 'The simplest way for websites to work around the SOP is to change the origin
    of a page via JavaScript. Setting the origin of two pages to the same domain using
    `document.domain` in the pages’ JavaScript will enable the pages to share resources.
    For example, you can set the domain of both *a.example.com* and *b.example.com*
    to *example.com* so that they can interact:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网站绕过 SOP（同源策略）的最简单方法是通过 JavaScript 更改页面的来源。通过在页面的 JavaScript 中使用 `document.domain`
    将两个页面的来源设置为相同的域名，可以让页面共享资源。例如，你可以将 *a.example.com* 和 *b.example.com* 的域名都设置为 *example.com*，这样它们就可以进行交互：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, this approach has its limitations. First, you can only set the *document.domain*
    of a page to a superdomain; for example, you can set the origin of *a.example.com*
    to *example.com*, but not to *example2.com*. Therefore, this method will work
    only if you want to share resources with superdomains or sibling subdomains.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有其局限性。首先，你只能将页面的 *document.domain* 设置为超域名；例如，你可以将 *a.example.com* 的来源设置为
    *example.com*，但不能设置为 *example2.com*。因此，如果你想与超域名或同级子域共享资源，这种方法才会奏效。
- en: Exploiting Cross-Origin Resource Sharing
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用跨源资源共享
- en: Because of these limitations, most sites use Cross-Origin Resource Sharing (CORS)
    to relax the SOP instead. CORS is a mechanism that protects the data of the server.
    It allows servers to explicitly specify a list of origins that are allowed to
    access its resources via the HTTP response header `Access-Control-Allow-Origin`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些局限性，大多数网站改为使用跨源资源共享（CORS）来放宽 SOP。CORS 是一种保护服务器数据的机制。它允许服务器通过 HTTP 响应头 `Access-Control-Allow-Origin`
    明确指定允许访问其资源的来源列表。
- en: 'For example, let’s say we’re trying to send the following JSON blob located
    at *a.example.com/user_info* to *b.example.com*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在尝试将位于 *a.example.com/user_info* 的以下 JSON 数据发送到 *b.example.com*：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Under the SOP, *b.example.com* won’t be able to access the JSON file, because
    *a.example.com* and *b.example.com* are of different origins. But using CORS,
    the user’s browser will send an `Origin` header on behalf of *b.example.com*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SOP 下，*b.example.com* 无法访问 JSON 文件，因为 *a.example.com* 和 *b.example.com* 的来源不同。但使用
    CORS 时，用户的浏览器会代表 *b.example.com* 发送一个 `Origin` 头部：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If *b.example.com* is part of an allowlist of URLs with permission to access
    resources on *a.example.com*, *a.example.com* will send the browser the requested
    resource along with an `Access-Control-Allow-Origin` header. This header will
    indicate to the browser that a specific origin is allowed to access the resource:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *b.example.com* 是允许访问 *a.example.com* 上资源的允许列表中的一部分，*a.example.com* 将发送请求的资源以及
    `Access-Control-Allow-Origin` 头部。该头部将告诉浏览器，特定的来源被允许访问该资源：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The application can also return the `Access-Control-Allow-Origin` header with
    a wildcard character (`*`) to indicate that the resource on that page can be accessed
    by any domain:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序也可以返回带有通配符字符（`*`）的 `Access-Control-Allow-Origin` 头部，表示该页面上的资源可以被任何域名访问：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the other hand, if the origin of the requesting page isn’t allowed to access
    the resource, the user’s browser will block the requesting page from reading the
    data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果请求页面的来源未被允许访问资源，用户的浏览器将阻止请求页面读取数据。
- en: CORS is a great way to implement cross-origin communication. However, CORS is
    safe only when the list of allowed origins is properly defined. If CORS is misconfigured,
    attackers can exploit the misconfiguration and access the protected resources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 是实现跨源通信的一个好方法。然而，CORS 只有在允许的来源列表正确定义的情况下才是安全的。如果 CORS 配置错误，攻击者可能利用配置漏洞访问受保护的资源。
- en: The most basic misconfiguration of CORS involves allowing the `null` origin.
    If the server sets `Access-Control-Allow-Origin` to `null`, the browser will allow
    any site with a `null` origin header to access the resource. This isn’t safe because
    any origin can create a request with a `null` origin. For instance, cross-site
    requests generated from a document using the `data:` URL scheme will have a `null`
    origin.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 配置的最基本错误是允许 `null` 来源。如果服务器将 `Access-Control-Allow-Origin` 设置为 `null`，浏览器将允许任何具有
    `null` 来源头部的站点访问资源。这是不安全的，因为任何来源都可以创建一个 `null` 来源的请求。例如，使用 `data:` URL 方案生成的跨站请求将具有
    `null` 来源。
- en: Another misconfiguration is to set the `Access-Control-Allow-Origin` header
    to the origin of the requesting page without validating the requestor’s origin.
    If the server doesn’t validate the origin and returns an `Access-Control-Allow-Origin`
    for any origin, the header will completely bypass the SOP, removing all limitations
    on cross-origin communication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误配置是将`Access-Control-Allow-Origin`头设置为请求页面的来源，而不验证请求者的来源。如果服务器没有验证来源并且返回任何来源的`Access-Control-Allow-Origin`，那么该头部将完全绕过SOP，移除跨源通信的所有限制。
- en: 'In summary, if the server sets the `Access-Control-Allow-Origin` header to
    `null` or to arbitrary origins of the requesting page, it allows attackers to
    smuggle information offsite:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果服务器将`Access-Control-Allow-Origin`头设置为`null`或任意来源的请求页面，它允许攻击者窃取站外信息：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another exploitable misconfiguration occurs when a site uses weak regexes to
    validate origins. For example, if the policy checks only if an origin URL starts
    with *www.example.com*, the policy can be bypassed using an origin like *www.example.com.attacker.com*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可被利用的错误配置是站点使用弱正则表达式来验证来源。例如，如果策略仅检查来源URL是否以*www.example.com*开头，攻击者可以使用*www.example.com.attacker.com*这样的来源来绕过该策略。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An interesting configuration that isn’t exploitable is setting the allowed
    origins to the wildcard (`*`). This isn’t exploitable because CORS doesn’t allow
    credentials, including cookies, authentication headers, or client-side certificates,
    to be sent with requests to these pages. Since credentials cannot be sent in requests
    to these pages, no private information can be accessed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的但不可被利用的配置是将允许的来源设置为通配符（`*`）。这不可被利用，因为CORS不允许凭据（包括Cookies、认证头或客户端证书）与请求一起发送到这些页面。由于凭据不能发送到这些页面，因此无法访问任何私人信息：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Developers can prevent CORS misconfigurations by creating a well-defined CORS
    policy with a strict allowlist and robust URL validation. For pages containing
    sensitive information, the server should return the requesting page’s origin in
    the `Access-Control-Allow-Origin` header only if that origin is in the allowlist.
    For public information, the server can simply use the wildcard `*` designation
    for `Access-Control-Allow-Origin`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以通过创建一个定义明确的CORS策略，设置严格的白名单和强大的URL验证来防止CORS错误配置。对于包含敏感信息的页面，服务器应该仅在请求来源在白名单中时，在`Access-Control-Allow-Origin`头中返回请求页面的来源。对于公共信息，服务器可以简单地使用通配符`*`来表示`Access-Control-Allow-Origin`。
- en: Exploiting postMessage()
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用postMessage()
- en: 'Some sites work around SOP by using `postMessage()`. This method is a web API
    that uses JavaScript syntax. You can use it to send text-based messages to another
    window:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些站点通过使用`postMessage()`来绕过SOP。这个方法是一个使用JavaScript语法的Web API。你可以用它向另一个窗口发送基于文本的消息：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The receiving window would then handle the message by using an event handler
    that will be triggered when the receiving window receives a message:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接收窗口将通过使用一个事件处理器来处理消息，当接收窗口接收到消息时，该事件处理器将被触发：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since using `postMessage()` requires the sender to obtain a reference to the
    receiver’s window, messages can be sent only between a window and its iframes
    or pop-ups. That’s because only windows that open each other will have a way to
    reference each other. For example, a window can use `window.open` to refer to
    a new window it opened. Alternatively, it can use `window.opener` to reference
    the window that spawned the current window. It can use `window.frames` to reference
    embedded iframes, and `window.parent` to reference the parent window of the current
    iframe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`postMessage()`需要发送方获得接收方窗口的引用，因此消息只能在窗口及其iframe或弹出窗口之间发送。这是因为只有相互打开的窗口才会有相互引用的方式。例如，一个窗口可以使用`window.open`来引用它打开的新窗口。或者，它可以使用`window.opener`来引用生成当前窗口的窗口。它可以使用`window.frames`来引用嵌入的iframe，并且使用`window.parent`来引用当前iframe的父窗口。
- en: 'For example, say we’re trying to pass the following JSON blob located at *a.example.com/user_info*
    to *b.example.com*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们试图将位于*a.example.com/user_info*的JSON数据传递给*b.example.com*：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*a.example.com* can open *b.example.com* and send a message to its window.
    The `window.open()` function opens the window of a particular URL and returns
    a reference to it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*a.example.com*可以打开*b.example.com*并向其窗口发送消息。`window.open()`函数打开一个特定URL的窗口，并返回该窗口的引用：'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the same time, *b.example.com* would set up an event listener to process
    the data it receives:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，*b.example.com*会设置事件监听器来处理它接收到的数据：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, `postMessage()` does not bypass SOP directly but provides a
    way for pages of different origins to send data to each other.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`postMessage()` 并不会直接绕过 SOP，而是提供了一种不同来源页面之间互相传递数据的方式。
- en: The `postMessage()` method can be a reliable way to implement cross-origin communication.
    However, when using it, both the sender and the receiver of the message should
    verify the origin of the other side. Vulnerabilities happen when pages enforce
    weak origin checks or lack origin checks altogether.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`postMessage()` 方法可以是实现跨来源通信的可靠方式。然而，在使用它时，消息的发送者和接收者都应该验证对方的来源。当页面执行弱来源检查或完全没有来源检查时，就会出现漏洞。'
- en: 'First, the `postMessage()` method allows the sender to specify the receiver’s
    origin as a parameter. If the sender page doesn’t specify a target origin and
    uses a wildcard target origin instead, it becomes possible to leak information
    to other sites:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`postMessage()` 方法允许发送者将接收者的来源指定为参数。如果发送者页面没有指定目标来源，而是使用通配符目标来源，那么信息泄露到其他网站就变得可能：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, an attacker can create a malicious HTML page that listens for
    events coming from the sender page. They can then trick users into triggering
    the `postMessage()` by using a malicious link or fake image and make the victim
    page send data to the attacker’s page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者可以创建一个恶意 HTML 页面，监听来自发送者页面的事件。然后，他们可以通过恶意链接或假图像诱使用户触发 `postMessage()`，使受害者页面将数据发送到攻击者的页面。
- en: 'To prevent this issue, developers should always set the `TARGET_ORIGIN` parameter
    to the target site’s URL instead of using a wildcard origin:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，开发者应该始终将 `TARGET_ORIGIN` 参数设置为目标网站的 URL，而不是使用通配符来源：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other hand, if the message receiver doesn’t validate the page where
    the `postMessage()` is coming from, it becomes possible for attackers to send
    arbitrary data to the website and trigger unwanted actions on the victim’s behalf.
    For example, let’s say that *b.example.com* allows *a.example.com* to trigger
    a password change based on a `postMessage()`, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果消息接收者没有验证 `postMessage()` 来源的页面，那么攻击者就有可能向网站发送任意数据，并代表受害者触发不必要的操作。例如，假设
    *b.example.com* 允许 *a.example.com* 基于 `postMessage()` 触发密码更改，如下所示：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The page *b.example.com* would then receive the message and process the request:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 页面 *b.example.com* 然后会接收到消息并处理请求：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice here that any window can send messages to *b.example.com*, so any page
    can initiate a password change on *b.example.com*! To exploit this behavior, the
    attacker can embed or open the victim page to obtain its window reference. Then
    they’re free to send arbitrary messages to that window.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何窗口都可以向 *b.example.com* 发送消息，因此任何页面都可以在 *b.example.com* 上发起密码更改！为了利用这一行为，攻击者可以嵌入或打开受害者页面，以获得其窗口引用。然后，他们就可以自由地向该窗口发送任意消息。
- en: 'To prevent this issue, pages should verify the origin of the sender of a message
    before processing it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，页面应该在处理消息之前验证消息发送者的来源：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This line 1 verifies the origin of the sender by checking it against an acceptable
    origin.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行 1 通过将发送者的来源与可接受的来源进行比较，验证发送者的来源。
- en: Exploiting JSON with Padding
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用带填充的 JSON
- en: '*JSON with Padding (**JSONP)* is another technique that works around the SOP.
    It allows the sender to send JSON data as JavaScript code. A page of a different
    origin can read the JSON data by processing the JavaScript.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*带填充的 JSON（**JSONP**）* 是另一种绕过 SOP 的技术。它允许发送者将 JSON 数据作为 JavaScript 代码发送。不同来源的页面可以通过处理
    JavaScript 来读取 JSON 数据。'
- en: 'To see how this works, let’s continue with our previous example, where we’re
    trying to pass the following JSON blob located at *a.example.com/user_info* to
    *b.example.com*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个如何运作，让我们继续之前的示例，在这个示例中，我们尝试将位于 *a.example.com/user_info* 的以下 JSON 块传递到
    *b.example.com*：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The SOP allows the HTML `<script>` tag to load scripts across origins, so an
    easy way for *b.example.com* to retrieve data across origins is to load the data
    as a script in a `<script>` tag:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SOP 允许 HTML 的 `<script>` 标签跨来源加载脚本，因此 *b.example.com* 获取跨来源数据的一个简单方法是将数据作为脚本加载在
    `<script>` 标签中：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This way, *b.example.com* would essentially be including the JSON data block
    in a script tag. But this would cause a syntax error because JSON data is not
    valid JavaScript:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，*b.example.com* 本质上会在一个脚本标签中包含 JSON 数据块。但这将导致语法错误，因为 JSON 数据不是有效的 JavaScript。
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: JSONP works around this issue by wrapping the data in a JavaScript function,
    and sending the data as JavaScript code instead of a JSON file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP 通过将数据包装在一个 JavaScript 函数中来解决这个问题，并将数据作为 JavaScript 代码而非 JSON 文件发送。
- en: 'The requesting page includes the resource as a script and specifies a callback
    function, typically in a URL parameter named `callback` or `jsonp`. This callback
    function is a predefined function on the receiving page ready to process the data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请求页面将资源作为脚本包含，并指定一个回调函数，通常在名为`callback`或`jsonp`的 URL 参数中。这个回调函数是接收页面上的预定义函数，准备处理数据：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The page at *a.example.com* will return the data wrapped in the specified callback
    function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 *a.example.com* 的页面将返回包含在指定回调函数中的数据：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The receiving page would essentially be including this script, which is valid
    JavaScript code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接收页面将实际上包含这个脚本，它是有效的 JavaScript 代码：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The receiving page can then extract the data by running the JavaScript code
    and processing the `parseinfo()` function. By sending data as scripts instead
    of JSON data, JSONP allows resources to be read across origins. Here’s a summary
    of what happens during a JSONP workflow:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接收页面随后可以通过运行 JavaScript 代码并处理`parseinfo()`函数来提取数据。通过将数据作为脚本发送，而不是 JSON 数据，JSONP
    允许跨源读取资源。以下是 JSONP 工作流中发生的步骤总结：
- en: The data requestor includes the data’s URL in a script tag, along with the name
    of a callback function.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据请求者将数据的 URL 包含在脚本标签中，并附上回调函数的名称。
- en: The data provider returns the JSON data wrapped within the specified callback
    function.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据提供者返回包含在指定回调函数中的 JSON 数据。
- en: The data requestor receives the function and processes the data by running the
    returned JavaScript code.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据请求者接收该功能并通过运行返回的 JavaScript 代码处理数据。
- en: You can usually find out if a site uses JSONP by looking for script tags that
    include URLs with the terms *jsonp* or *callback*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以通过查找包含带有*jsonp*或*callback*字样的 URL 的脚本标签，来判断一个站点是否使用了 JSONP。
- en: 'But JSONP comes with risks. When JSONP is enabled on an endpoint, an attacker
    can simply embed the same script tag on their site and request the data wrapped
    in the JSONP payload, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 JSONP 存在风险。当在某个端点启用 JSONP 时，攻击者只需在他们的网站上嵌入相同的脚本标签并请求 JSONP 负载中包装的数据，像这样：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If a user is browsing the attacker’s site while logged into *a.example.com*
    at the same time, the user’s browser will include their credentials in this request
    and allow attackers to extract confidential data belonging to the victim.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在浏览攻击者网站的同时，已经登录 *a.example.com*，则用户的浏览器会将他们的凭据包含在此请求中，允许攻击者提取受害者的机密数据。
- en: This is why JSONP is suitable for transmitting only public data. While JSONP
    can be hardened by using CSRF tokens or maintaining an allowlist of referer headers
    for JSONP requests, these protections can often be bypassed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 JSONP 适用于仅传输公共数据的原因。虽然可以通过使用 CSRF 令牌或为 JSONP 请求保持允许列表的 Referer 标头来增强
    JSONP 的安全性，但这些保护措施通常可以被绕过。
- en: Another issue with JSONP is that site *b.example.com* would have to trust site
    *a.example.com* completely, because it’s running arbitrary JavaScript from *a.example.com*.
    If *a.example.com* is compromised, the attacker could run whatever JavaScript
    they wanted on *b.example.com*, because *b.example.com* is including the file
    from *a.example.com* in a `<script>` tag. This is equivalent to an XSS attack.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JSONP 的另一个问题是，站点 *b.example.com* 必须完全信任站点 *a.example.com*，因为它正在运行来自 *a.example.com*
    的任意 JavaScript。如果 *a.example.com* 被攻破，攻击者就可以在 *b.example.com* 上执行他们想要的 JavaScript，因为
    *b.example.com* 在 `<script>` 标签中包含了来自 *a.example.com* 的文件。这相当于一次 XSS 攻击。
- en: Now that CORS is a reliable option for cross-origin communication, sites no
    longer use JSONP as often.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于 CORS 是一种可靠的跨源通信选项，网站不再像以前那样频繁使用 JSONP。
- en: Bypassing SOP by Using XSS
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用 XSS 绕过 SOP
- en: Finally, XSS is essentially a full SOP bypass, because any JavaScript that runs
    on a page operates under the security context of that page. If an attacker can
    get a malicious script executed on the victim page, the script can access the
    victim page’s resources and data. Therefore, remember that if you can find an
    XSS, you’ve essentially bypassed the SOP protecting that page.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，XSS 本质上是一次完全的 SOP 绕过，因为在页面上运行的任何 JavaScript 都在该页面的安全上下文下操作。如果攻击者能够在受害者页面上执行恶意脚本，该脚本就可以访问受害者页面的资源和数据。因此，记住，如果你能找到
    XSS，就相当于绕过了保护该页面的 SOP。
- en: Hunting for SOP Bypasses
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找 SOP 绕过
- en: Let’s start hunting for SOP bypass vulnerabilities by using what you’ve learned!
    SOP bypass vulnerabilities are caused by the faulty implementation of SOP relaxation
    techniques. So the first thing you need to do is to determine whether the target
    application relaxes the SOP in any way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始通过你所学到的知识来寻找 SOP 绕过漏洞！SOP 绕过漏洞是由于 SOP 放宽技术的错误实现导致的。因此，首先需要做的是确定目标应用是否以某种方式放宽了
    SOP。
- en: 'Step 1: Determine If SOP Relaxation Techniques Are Used'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：确定是否使用了 SOP 放宽技术
- en: You can determine whether the target is using an SOP-relaxation technique by
    looking for the signatures of each SOP-relaxation technique. When you’re browsing
    a web application, open your proxy and look for any signs of cross-origin communication.
    For example, CORS sites will often return HTTP responses that contain an `Access-Control-Allow-Origin`
    header. A site could be using `postMessage()` if you inspect a page (for example,
    by right-clicking it in Chrome and choosing **Inspect**, then navigating to **Event
    Listeners**) and find a `message` event listener ([Figure 19-1](#figure19-1)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过寻找每种 SOP 放宽技术的特征来确定目标是否正在使用 SOP 放宽技术。在浏览网页应用时，打开代理并寻找任何跨源通信的迹象。例如，CORS
    站点通常会返回包含 `Access-Control-Allow-Origin` 头部的 HTTP 响应。如果站点使用 `postMessage()`，你可以通过检查页面（例如，在
    Chrome 中右键点击它并选择 **检查**，然后导航到 **事件监听器**）并找到 `message` 事件监听器（[图 19-1](#figure19-1)）。
- en: 'And a site could be using JSONP if you see a URL being loaded in a `<script>`
    tag with a callback function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个 URL 被加载在 `<script>` 标签中并带有回调函数，那么该站点可能正在使用 JSONP：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you see clues of cross-origin communication, try the techniques mentioned
    in this chapter to see if you can bypass the SOP and steal sensitive info from
    the site!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到跨源通信的线索，尝试本章提到的技术，看看你是否能够绕过 SOP 并从站点窃取敏感信息！
- en: '![f19001](image_fi/501546c19/f19001.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![f19001](image_fi/501546c19/f19001.png)'
- en: 'Figure 19-1: Finding the event listeners of a page in the Chrome browser'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19-1：在 Chrome 浏览器中查找页面的事件监听器
- en: 'Step 2: Find CORS Misconfiguration'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：查找 CORS 配置错误
- en: If the site is using CORS, check whether the `Access-Control-Allow-Origin` response
    header is set to `null`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果站点使用 CORS，检查 `Access-Control-Allow-Origin` 响应头部是否设置为 `null`。
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If not, send a request to the site with the origin header `attacker.com`, and
    see if the `Access-Control-Allow-Origin` in the response is set to `attacker.com`.
    (You can add an Origin header by intercepting the request and editing it in a
    proxy.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，向该站点发送带有源头头部 `attacker.com` 的请求，看看响应中的 `Access-Control-Allow-Origin` 是否设置为
    `attacker.com`。（你可以通过拦截请求并在代理中编辑它来添加一个 Origin 头部。）
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, test whether the site properly validates the origin URL by submitting
    an Origin header that contains an allowed site, such as *www.example.com.attacker.com*.
    See if the `Access-Control-Allow-Origin` header returns the origin of the attacker’s
    domain.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过提交包含允许站点的 Origin 头部（如 *www.example.com.attacker.com*）来测试该站点是否正确验证了源 URL。查看
    `Access-Control-Allow-Origin` 头部是否返回攻击者域的源。
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If one of these `Access-Control-Allow-Origin` header values is returned, you
    have found a CORS misconfiguration. Attackers will be able to bypass the SOP and
    smuggle information offsite ([Figure 19-2](#figure19-2)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回了这些 `Access-Control-Allow-Origin` 头部值中的一个，则说明你已经找到了 CORS 配置错误。攻击者将能够绕过 SOP
    并将信息偷偷带出站点（[图 19-2](#figure19-2)）。
- en: '![f19002](image_fi/501546c19/f19002.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f19002](image_fi/501546c19/f19002.png)'
- en: 'Figure 19-2: Is the site vulnerable to a CORS misconfiguration vulnerability?'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19-2：该站点是否易受 CORS 配置错误漏洞的影响？
- en: 'Step 3: Find postMessage Bugs'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：查找 postMessage 漏洞
- en: 'If the site is using `postMessage`, see if you can send or receive messages
    as an untrusted site. Create an HTML page with an iframe that frames the targeted
    page accepting messages. Try to send messages to that page that trigger a state-changing
    behavior. If the target cannot be framed, open it as a new window instead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果站点使用 `postMessage`，检查你是否可以作为一个不受信任的站点发送或接收消息。创建一个包含 iframe 的 HTML 页面，iframe
    嵌入接受消息的目标页面。尝试向该页面发送触发状态变化行为的消息。如果目标页面无法被嵌入，改为作为新窗口打开：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can also create an HTML page that listens for events coming from the target
    page, and trigger the postMessage from the target site. See if you can receive
    sensitive data from the target page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个 HTML 页面，监听来自目标页面的事件，并触发目标站点的 postMessage。看看你是否能够从目标页面接收到敏感数据。
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Step 4: Find JSONP Issues'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：查找 JSONP 问题
- en: 'Finally, if the site is using JSONP, see if you can embed a script tag on your
    site and request the sensitive data wrapped in the JSONP payload:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果该站点使用JSONP，请查看是否可以在您的站点上嵌入一个脚本标签，并请求包裹在JSONP有效负载中的敏感数据：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Step 5: Consider Mitigating Factors'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤5：考虑缓解因素
- en: When the target site does not rely on cookies for authentication, these SOP
    bypass misconfigurations might not be exploitable. For instance, when the site
    uses custom headers or secret request parameters to authenticate requests, you
    might need to find a way to forge those to exfiltrate sensitive data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标站点不依赖于cookie进行身份验证时，这些SOP绕过配置错误可能无法被利用。例如，当站点使用自定义头或秘密请求参数来验证请求时，您可能需要找到一种方法伪造这些头信息，以便提取敏感数据。
- en: Escalating the Attack
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: An SOP-bypass bug often means that attackers can read private information or
    execute action as other users. This means that these vulnerabilities are often
    of high severity before any escalation attempts. But you can still escalate SOP-bypass
    issues by automation or by pivoting the attack using the information you’ve found.
    Can you harvest large amounts of user data by automating the exploitation of the
    SOP bypass? Can you use the information you’ve found to cause more damage? For
    example, if you can extract the security questions of a victim, can you use that
    information to completely take over the user’s account?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SOP绕过漏洞通常意味着攻击者可以读取私人信息或以其他用户的身份执行操作。这意味着这些漏洞在任何升级尝试之前通常具有较高的严重性。但是，您仍然可以通过自动化或使用您找到的信息进行攻击的转折来升级SOP绕过问题。您能通过自动化SOP绕过漏洞的利用来收集大量用户数据吗？您能使用找到的信息造成更大的损害吗？例如，如果您能够提取受害者的安全问题，您是否可以利用这些信息完全接管用户的帐户？
- en: Many researchers will simply report CORS misconfigurations without showing the
    impact of the vulnerability. Consider the impact of the issue before sending the
    report. For instance, if a publicly readable page is served with a null `Access-Control-Allow-Origin`
    header, it would not cause damage to the application since that page does not
    contain any sensitive info. A good SOP-bypass report will include potential attack
    scenarios and indicate how attackers can exploit the vulnerability. For instance,
    what data can the attacker steal, and how easy would it be?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 许多研究人员仅仅报告CORS配置错误，而没有展示漏洞的影响。在发送报告之前，请考虑问题的影响。例如，如果一个公开可读的页面与空的`Access-Control-Allow-Origin`头一起提供，那么它不会对应用程序造成损害，因为该页面不包含任何敏感信息。一份好的SOP绕过报告将包括潜在的攻击场景，并表明攻击者如何利用该漏洞。例如，攻击者能窃取什么数据，容易程度如何？
- en: Finding Your First SOP Bypass Vulnerability!
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找您的第一个SOP绕过漏洞！
- en: Go ahead and start looking for your first SOP bypass. To find SOP-bypass vulnerabilities,
    you will need to understand the SOP relaxation techniques the target is using.
    You may also want to become familiar with JavaScript in order to craft effective
    POCs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并开始寻找您的第一个SOP绕过漏洞。要发现SOP绕过漏洞，您需要了解目标站点使用的SOP放松技术。您可能还需要熟悉JavaScript，以便制作有效的POC（概念证明）。
- en: Find out if the application uses any SOP relaxation techniques. Is the application
    using CORS, `postMessage`, or JSONP?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找应用程序是否使用了任何SOP放松技术。该应用程序是否使用了CORS、`postMessage`或JSONP？
- en: If the site is using CORS, test the strength of the CORS allowlist by submitting
    test `Origin` headers.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果站点使用CORS，请通过提交测试的`Origin`头来测试CORS白名单的强度。
- en: If the site is using `postMessage`, see if you can send or receive messages
    as an untrusted site.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果站点使用`postMessage`，查看您是否可以作为不受信任的站点发送或接收消息。
- en: If the site is using JSONP, try to embed a script tag on your site and request
    the sensitive data wrapped in the JSONP payload.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果站点使用JSONP，请尝试在您的站点上嵌入一个脚本标签，并请求包裹在JSONP有效负载中的敏感数据。
- en: Determine the sensitivity of the information you can steal using the vulnerability,
    and see if you can do something more.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定您可以使用漏洞窃取的信息的敏感性，并查看您是否可以做更多的事情。
- en: Submit your bug report to the program!
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向程序提交您的漏洞报告！
