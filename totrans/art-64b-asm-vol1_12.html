<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="583" id="Page_583"/>10</span><br/>
<span class="ChapterTitle">Table Lookups</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter discusses how to speed up or reduce the complexity of computations by using table lookups. Back in the early days of x86 programming, replacing expensive computations with table lookups was a common way to improve program performance. Today, memory speeds in modern systems limit performance gains that can be obtained by using table lookups. However, for complex calculations, this is still a viable technique for writing high-performance code. This chapter demonstrates the space/speed trade-offs when using table lookups.</p>
<h2 id="h1-501089c10-0001">	10.1	Tables</h2>
<p class="BodyFirst">To an assembly language programmer, a <em>table</em> is an array containing initialized values that do not change once created. In assembly language, you can use tables for a variety of purposes: computing functions, controlling <span epub:type="pagebreak" title="584" id="Page_584"/>program flow, or simply looking things up. In general, tables provide a fast mechanism for performing an operation at the expense of space in your program (the extra space holds the tabular data). In this section, we’ll explore some of the many possible uses of tables in an assembly language program.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Because tables typically contain initialized data that does not change during program execution, the <code>.const</code> section is a good place to put your table objects.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501089c10-0001">10.1.1	Function Computation via Table Lookup</h3>
<p class="BodyFirst">A simple-looking high-level-language arithmetic expression can be equivalent to a considerable amount of x86-64 assembly language code and, therefore, could be expensive to compute. Assembly language programmers often precompute many values and use a table lookup of those values to speed up their programs. This has the advantage of being easier, and it’s often more efficient as well.</p>
<p>Consider the following Pascal statement:</p>
<pre><code>if (character &gt;= 'a') and (character &lt;= 'z') then 
      character := chr(ord(character) - 32);</code></pre>
<p>This Pascal <code>if</code> statement converts the <code>character</code> variable’s value from lowercase to uppercase if <code>character</code> is in the range <code>a</code> to <code>z</code>. The MASM code that does the same thing requires a total of seven machine instructions, as follows:</p>
<pre><code>        mov al, character
        cmp al, 'a'
        jb  notLower
        cmp al, 'z'
        ja  notLower

        and al, 5fh  ; Same as sub(32, al) in this code
        mov character, al
notLower:</code></pre>
<p>Using a table lookup, however, allows you to reduce this sequence to just four instructions:</p>
<pre><code>mov   al, character
lea   rbx, CnvrtLower
xlat
mov   character, al</code></pre>
<p>The <code>xlat</code>, or translate, instruction does the following:</p>
<pre><code>mov al, [rbx + al * 1]</code></pre>
<p>This instruction uses the current value of the AL register as an index into the array whose base address is found in RBX. It fetches the byte at that index in the array and copies that byte into the AL register. Intel calls <span epub:type="pagebreak" title="585" id="Page_585"/>this instruction <em>translate</em> because programmers typically use it to translate characters from one form to another by using a lookup table, exactly the way we are using it here.</p>
<p>In the previous example, <code>CnvrtLower</code> is a 256-byte table that contains the values 0 to 60h at indices 0 to 60h, 41h to 5Ah at indices 61h to 7Ah, and 7Bh to 0FFh at indices 7Bh to 0FFh. Therefore, if AL contains a value in the range 0 to 60h or 7Ah to 0FFh, the <code>xlat</code> instruction returns the same value, effectively leaving AL unchanged. However, if AL contains a value in the range 61h to 7Ah (the ASCII codes for a to z), then the <code>xlat</code> instruction replaces the value in AL with a value in the range 41h to 5Ah (the ASCII codes for A to Z), thereby converting lowercase to uppercase. </p>
<p>As the complexity of a function increases, the performance benefits of the table-lookup method increase dramatically. While you would almost never use a lookup table to convert lowercase to uppercase, consider what happens if you want to swap cases; for example, via computation:</p>
<pre><code>        mov al, character
        cmp al, 'a'
        jb  notLower
        cmp al, 'z'
        ja  allDone

        and al, 5fh
        jmp allDone

notLower:
        cmp al, 'A'
        jb  allDone
        cmp al, 'Z'
        ja  allDone

        or  al, 20h
allDone:
        mov character, al</code></pre>
<p>This code has 13 machine instructions.</p>
<p>The table-lookup code to compute this same function is as follows:</p>
<pre><code>mov   al, character
lea   rbx, SwapUL
xlat
mov   character, al</code></pre>
<p>As you can see, when using a table lookup to compute a function, only the table changes; the code remains the same. </p>
<h4 id="h3-501089c10-0001">10.1.1.1	Function Domains and Range</h4>
<p class="BodyFirst">Functions computed via table lookup have a limited <em>domain</em> (the set of possible input values they accept), because each element in the domain of a function requires an entry in the lookup table. For example, our previous <span epub:type="pagebreak" title="586" id="Page_586"/>uppercase/lowercase conversion functions have the 256-character extended ASCII character set as their domain. A function such as <code>sin</code> or <code>cos</code> accepts the (infinite) set of real numbers as possible input values. You won’t find it very practical to implement a function via table lookup whose domain is the set of real numbers, because you must limit the domain to a small set. </p>
<p>Most lookup tables are quite small, usually 10 to 256 entries. Rarely do lookup tables grow beyond 1000 entries. Most programmers don’t have the patience to create (and verify the correctness) of a 1000-entry table (though see <span class="xref" itemid="xref_target_“Generating Tables” on page 590 ">“Generating Tables” on page 590 </span>for a discussion of generating tables programmatically).</p>
<p>Another limitation of functions based on lookup tables is that the elements in the domain must be fairly contiguous. Table lookups use the input value to a function as an index into the table, and return the value at that entry in the table. A function that accepts values 0, 100, 1000, and 10,000 would require 10,001 different elements in the lookup table because of the range of input values. Therefore, you cannot efficiently create such a function via a table lookup. Throughout this section on tables, we’ll assume that the domain of the function is a fairly contiguous set of values.</p>
<p>The <em>range</em> of a function is the set of possible output values it produces. From the perspective of a table lookup, a function’s range determines the size of each table entry. For example, if a function’s range is the integer values 0 through 255, then each table entry requires a single byte; if the range is 0 through 65,535, each table entry requires 2 bytes, and so on.</p>
<p>The best functions you can implement via table lookups are those whose domain and range are always 0 to 255 (or a subset of this range). Any such function can be computed using the same two instructions: <code>lea rbx, table</code> and <code>xlat</code>. The only thing that ever changes is the lookup table. The uppercase/lowercase conversion routines presented earlier are good examples of such a function.</p>
<p>You cannot (conveniently) use the <code>xlat</code> instruction to compute a function value once the range or domain of the function takes on values outside 0 to 255. There are three situations to consider:</p>
<ul>
<li>The domain is outside 0 to 255, but the range is within 0 to 255.</li>
<li>The domain is inside 0 to 255, but the range is outside 0 to 255.</li>
<li>Both the domain and range of the function take on values outside 0 to 255.</li>
</ul>
<p>We will consider these cases in the following sections.</p>
<h4 id="h3-501089c10-0002">10.1.1.2	Domain Outside 0 to 255, Range Within 0 to 255</h4>
<p class="BodyFirst">If the domain of a function is outside 0 to 255, but the range of the function falls within this set of values, our lookup table will require more than 256 entries, but we can represent each entry with a single byte. Therefore, the lookup table can be an array of bytes. Other than those lookups that <span epub:type="pagebreak" title="587" id="Page_587"/>can use the <code>xlat</code> instruction, functions falling into this class are the most efficient. The following Pascal function invocation</p>
<pre><code>B := Func(X); </code></pre>
<p class="BodyContinued">where <code>Func</code> is</p>
<pre><code>function Func(X:dword):byte; </code></pre>
<p class="BodyContinued">is easily converted to the following MASM code:</p>
<pre><code>mov edx, X    ; Zero-extends into RDX!
lea rbx, FuncTable
mov al, [rbx][rdx * 1]
mov B, al</code></pre>
<p>This code loads the function parameter into RDX, uses this value (in the range 0 to ??) as an index into the <code>FuncTable</code> table, fetches the byte at that location, and stores the result into <code>B</code>. Obviously, the table must contain a valid entry for each possible value of <code>X</code>. For example, suppose you wanted to map a cursor position on an 80×25 text-based video display in the range 0 to 1999 (there are 2000 character positions on an 80×25 video display) to its <code>X</code> (0 to 79) or <code>Y</code> (0 to 24) coordinate on the screen. You could compute the <code>X</code> coordinate via the function</p>
<pre><code>X = Posn % 80;</code></pre>
<p class="BodyContinued">and the <code>Y</code> coordinate with the formula </p>
<pre><code>Y = Posn / 80;</code></pre>
<p class="BodyContinued">(where <code>Posn</code> is the cursor position on the screen). This can be computed using this x86-64 code:</p>
<pre><code>mov ax, Posn
mov cl, 80
div cl

; X is now in AH, Y is now in AL.</code></pre>
<p>However, the <code>div</code> instruction on the x86-64 is very slow. If you need to do this computation for every character you write to the screen, you will seriously degrade the speed of your video-display code. The following code, which realizes these two functions via table lookup, may improve the performance of your code considerably:</p>
<pre><code>lea   rbx, yCoord
movzx ecx, Posn           ; Use a plain mov instr if Posn 
mov   al, [rbx][rcx * 1]  ; is uns32 rather than an 
lea   rbx, xCoord         ; uns16 value
mov   ah, [rbx][rcx * 1]</code></pre>
<p><span epub:type="pagebreak" title="588" id="Page_588"/>Keep in mind that loading a value into ECX automatically zero-extends that value into RCX. Therefore, the <code>movzx</code> instruction in this code sequence actually zero-extends <code>Posn</code> into RCX, not just ECX.</p>
<p>If you’re willing to live with the limitations of the <code>LARGEADDRESSAWARE:NO</code> linking option (see <span class="xref" itemid="xref_target_“Large Address Unaware Applications” in Chapter 3">“Large Address Unaware Applications” in Chapter 3</span>), you can simplify this code somewhat:</p>
<pre><code>movzx ecx, Posn           ; Use a plain mov instr if Posn
mov   al, yCoord[rcx * 1] ; is uns32 rather than an
mov   ah, xCoord[rcx * 1] ; uns16 value</code></pre>
<h4 id="h3-501089c10-0003">10.1.1.3	Domain in 0 to 255 and Range Outside 0 to 255, or Both Outside 0 to 255</h4>
<p class="BodyFirst">If the domain of a function is within 0 to 255, but the range is outside this set, the lookup table will contain 256 or fewer entries, but each entry will require 2 or more bytes. If both the range and domains of the function are outside 0 to 255, each entry will require 2 or more bytes and the table will contain more than 256 entries.</p>
<p>Recall from <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> that the formula for indexing into a single-dimensional array (of which a <code>table</code> is a special case) is as follows:</p>
<pre><code><var>element_address</var><em> = </em><var>Base</var><em> + </em><var>index</var><em> </em>*<em> </em><var>element_size</var></code></pre>
<p>If elements in the range of the function require 2 bytes, you must multiply the index by 2 before indexing into the table. Likewise, if each entry requires 3, 4, or more bytes, the index must be multiplied by the size of each table entry before being used as an index into the table. For example, suppose you have a function, <code>F(</code><var>x</var><code>)</code>, defined by the following (pseudo) Pascal declaration:</p>
<pre><code>function F(<var>x</var>:dword):word;</code></pre>
<p>You can create this function by using the following x86-64 code (and, of course, the appropriate table named <code>F</code>):</p>
<pre><code>movzx ebx, <var>x</var>
lea   r8, F
mov   ax, [r8][rbx * 2]</code></pre>
<p>If you can live with the limitations of <code>LARGEADDRESSAWARE:NO</code>, you can reduce this as follows:</p>
<pre><code>movzx ebx, <var>x</var>
mov   ax, F[rbx * 2]</code></pre>
<p>Any function whose domain is small and mostly contiguous is a good candidate for computation via table lookup. In some cases, noncontiguous domains are acceptable as well, as long as the domain can be coerced into an appropriate set of values (an example you’ve already seen is processing <code>switch</code> statement expressions). Such operations, called <em>conditioning</em>, are the subject of the next section.</p>
<h4 id="h3-501089c10-0004"><span epub:type="pagebreak" title="589" id="Page_589"/>10.1.1.4	Domain Conditioning</h4>
<p class="BodyFirst"><em>Domain conditioning</em> is taking a set of values in the domain of a function and massaging them so that they are more acceptable as inputs to that function. Consider the following function:</p>
<pre><code>sin <var>x</var> = sin <var>x</var>|(x<span class="NSSymbol"/>∈[–2<span class="NSSymbol"/>π,2<span class="NSSymbol"/>π])</code></pre>
<p>This says that the (computer) function <code>sin(</code><var>x</var><code>)</code> is equivalent to the (mathematical) function sin <em>x</em> where</p>
<pre><code>–2<span class="NSSymbol">π</span> &lt;= <var>x</var> &lt;= 2<span class="NSSymbol">π</span></code></pre>
<p>As we know, sine is a circular function, which will accept any real-value input. The formula used to compute sine, however, accepts only a small set of these values.</p>
<p>This range limitation doesn’t present any real problems; by simply computing <code>sin(</code><var>x</var><code> mod (2 * pi))</code>, we can compute the sine of any input value. Modifying an input value so that we can easily compute a function is called <em>conditioning the input</em>. In the preceding example, we computed <var>x</var> <code>mod 2 * pi</code> and used the result as the input to the <code>sin</code> function. This truncates <var>x</var> to the domain <code>sin</code> needs without affecting the result. We can apply input conditioning to table lookups as well. In fact, scaling the index to handle word entries is a form of input conditioning. Consider the following Pascal function:</p>
<pre><code>function val(<var>x</var>:word):word; begin
    case <var>x</var> of
        0: val := 1;
        1: val := 1;
        2: val := 4;
        3: val := 27;
        4: val := 256;
        otherwise val := 0;
    end;
end; </code></pre>
<p>This function computes a value for <var>x</var> in the range 0 to 4 and returns 0 if <var>x</var> is outside this range. Since <var>x</var> can take on 65,536 different values (being a 16-bit word), creating a table containing 65,536 words where only the first five entries are nonzero seems to be quite wasteful. However, we can still compute this function by using a table lookup if we use input conditioning. The following assembly language code presents this principle:</p>
<pre><code>        mov   ax, 0      ; AX = 0, assume <var>x</var> &gt; 4
        movzx ebx, <var>x</var>     ; Note that HO bits of RBX must be 0!
        lea   r8, val
        cmp   bx, 4
        ja    defaultResult

<span epub:type="pagebreak" title="590" id="Page_590"/>        mov   ax, [r8][rbx * 2]

defaultResult:</code></pre>
<p>This code checks to see if <var>x</var><code/> is outside the range 0 to 4. If so, it manually sets AX to 0; otherwise, it looks up the function value through the <code>val</code> table. With input conditioning, you can implement several functions that would otherwise be impractical to do via table lookup.</p>
<h3 id="h2-501089c10-0002">10.1.2	Generating Tables</h3>
<p class="BodyFirst">One big problem with using table lookups is creating the table in the first place. This is particularly true if the table has many entries. Figuring out the data to place in the table, then laboriously entering the data and, finally, checking that data to make sure it is valid, is very time-consuming and boring. For many tables, there is no way around this process. For other tables, there is a better way: using the computer to generate the table for you.</p>
<p>An example is probably the best way to describe this. Consider the following modification to the sine function:</p>
<figure class="graphic center">
<img src="image_fi/501089c10/eq1001.png" alt="eq1001"/>
</figure>
<p>This states that <em>x</em> is an integer in the range 0 to 359 and <em>r</em> must be an integer. The computer can easily compute this with the following code:</p>
<pre><code>Thousand dword 1000
    .
    .
    .
lea   r8, Sines
movzx ebx, x
mov   eax, [r8][rbx * 2] ; Get sin(<var>x</var>) * 1000
imul  r                  ; Note that this extends EAX into EDX
idiv  Thousand           ; Compute (<var>r</var> *(sin(<var>x</var>) * 1000)) / 1000</code></pre>
<p>(This provides the usual improvement if you can live with the limitations of <code>LARGEADDRESSAWARE:NO</code>.)</p>
<p>Note that integer multiplication and division are not associative. You cannot remove the multiplication by 1000 and the division by 1000 because they appear to cancel each other out. Furthermore, this code must compute this function in exactly this order.</p>
<p>All that we need to complete this function is <code>Sines</code>, a table containing 360 different values corresponding to the sine of the angle (in degrees) times 1000. The C/C++ program in <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a> generates this table for you.</p>
<pre><code>// Listing 10-1: GenerateSines
 
// A C program that generates a table of sine values for
// an assembly language lookup table.

<span epub:type="pagebreak" title="591" id="Page_591"/>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(int argc, char **argv)
{
    FILE *outFile;
    int angle;
    int r;

    // Open the file:
    
    outFile = fopen("sines.asm", "w");

    // Emit the initial part of the declaration to 
    // the output file:

    fprintf
    ( 
        outFile, 
        "Sines:"  // sin(0) = 0
    );

    // Emit the sines table:
    
    for(angle = 0; angle &lt;= 359; ++angle)
    {
        // Convert angle in degrees to an angle in 
        // radians using:
        
        // radians = angle * 2.0 * pi / 360.0;
        
        // Multiply by 1000 and store the rounded 
        // result into the integer variable r.

        double theSine = 
            sin
            ( 
                angle * 2.0 * 
                3.14159265358979323846 / 
                360.0 
            );
        r = (int) (theSine * 1000.0); 

        // Write out the integers eight per line to the 
        // source file.
        // Note: If (angle AND %111) is 0, then angle 
        // is divisible by 8 and we should output a 
        // newline first.

        if((angle &amp; 7) == 0)
        {
            fprintf(outFile, "\n\tword\t");
        }
        fprintf(outFile, "%5d", r);
<span epub:type="pagebreak" title="592" id="Page_592"/>        if ((angle &amp; 7) != 7)
        {
            fprintf(outFile, ",");
        }

    } // endfor
    fprintf(outFile, "\n");

    fclose(outFile);
    return 0;

} // end main</code></pre>
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: A C program that generates a table of sines</p>
<p>This program produces the following output (truncated for brevity):</p>
<pre><code>Sines:
      word        0,   17,   34,   52,   69,   87,  104,  121
      word      139,  156,  173,  190,  207,  224,  241,  258
      word      275,  292,  309,  325,  342,  358,  374,  390
      word      406,  422,  438,  453,  469,  484,  499,  515
      word      529,  544,  559,  573,  587,  601,  615,  629
      word      642,  656,  669,  681,  694,  707,  719,  731
      word      743,  754,  766,  777,  788,  798,  809,  819
      word      829,  838,  848,  857,  866,  874,  882,  891
      word      898,  906,  913,  920,  927,  933,  939,  945
      word      951,  956,  961,  965,  970,  974,  978,  981
      word      984,  987,  990,  992,  994,  996,  997,  998
      word      999,  999, 1000,  999,  999,  998,  997,  996
      word      994,  992,  990,  987,  984,  981,  978,  974
      word      970,  965,  961,  956,  951,  945,  939,  933
      word      927,  920,  913,  906,  898,  891,  882,  874
                                      .
                                      .
                                      .
      word     -898, -891, -882, -874, -866, -857, -848, -838
      word     -829, -819, -809, -798, -788, -777, -766, -754
      word     -743, -731, -719, -707, -694, -681, -669, -656
      word     -642, -629, -615, -601, -587, -573, -559, -544
      word     -529, -515, -500, -484, -469, -453, -438, -422
      word     -406, -390, -374, -358, -342, -325, -309, -292
      word     -275, -258, -241, -224, -207, -190, -173, -156
      word     -139, -121, -104,  -87,  -69,  -52,  -34,  -17</code></pre>
<p>Obviously, it’s much easier to write the C program that generated this data than to enter (and verify) this data by hand. Of course, you don’t even have to write the table-generation program in C (or Pascal/Delphi, Java, C#, Swift, or another high-level language). Because the program will execute only once, the performance of the table-generation program is not an issue. </p>
<p><span epub:type="pagebreak" title="593" id="Page_593"/>Once you run your table-generation program, all that remains to be done is to cut and paste the table from the file (<em>sines.asm</em> in this example) into the program that will actually use the table.</p>
<h3 id="h2-501089c10-0003">10.1.3	Table-Lookup Performance</h3>
<p class="BodyFirst">In the early days of PCs, table lookups were a preferred way to do high-performance computations. Today, it is not uncommon for a CPU to be 10 to 100 times faster than main memory. As a result, using a table lookup may not be faster than doing the same calculation with machine instructions. However, the on-chip CPU cache memory subsystems operate at near CPU speeds. Therefore, table lookups can be cost-effective if your table resides in cache memory on the CPU. This means that the way to get good performance using table lookups is to use small tables (because there’s only so much room on the cache) and use tables whose entries you reference frequently (so the tables stay in the cache).</p>
<p>See <em>Write Great Code</em>, Volume 1 (No Starch Press, 2020) or the electronic version of <em>The Art of Assembly Language </em>at <a href="https://www.randallhyde.com/" class="LinkURL">https://www.randallhyde.com/</a> for details concerning the operation of cache memory and how you can optimize your use of cache memory.</p>
<h2 id="h1-501089c10-0002">	10.2	For More Information</h2>
<p class="BodyFirst">Donald Knuth’s <em>The Art of Computer Programming</em>, Volume 3: <em>Searching and Sorting</em> (Addison-Wesley Professional, 1998) contains a lot of useful information about searching for data in tables. Searching for data is an alternative when a straight array access won’t work in a given situation.</p>
<h2 id="h1-501089c10-0003">	10.3	Test Yourself</h2>
<ol class="decimal">
<li value="1">What is the domain of a function?</li>
<li value="2">What is the range of a function?</li>
<li value="3">What does the <code>xlat</code> instruction do?</li>
<li value="4">Which domain and range values allow you to use the <code>xlat</code> instruction?</li>
<li value="5">Provide the code that implements the following functions (using pseudo-C prototypes and <code>f</code> as the table name):
<ol class="lower-alpha">
<li value="1"><code>byte f(byte input)</code></li>
<li value="2"><code>word f(byte input)</code></li>
<li value="3"><code>byte f(word input)</code></li>
<li value="4"><code>word f(word input)</code></li>
</ol></li>
<li value="6">What is domain conditioning?</li>
<li value="7">Why might table lookups not be effective on modern processors?</li>
</ol>
</section>
</body></html>