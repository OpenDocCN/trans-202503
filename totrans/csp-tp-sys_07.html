<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch7" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch7">
<span class="CN"><span aria-label=" Page 211. " epub:type="pagebreak" id="pg_211" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">VALUE TYPES AND POLYMORPHISM</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">As an object-oriented programming (OOP) language, C# has good support for features that allow us to capture complex ideas and express them intuitively, such as classes, virtual methods, and inheritance. However, the language support for inheritance doesn’t extend to value types. Structs and record structs implicitly derive from the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class, which is derived directly from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,</p>
<p class="TNI">but they can’t inherit any other type and can’t themselves be inherited; that is, structs and record structs are implicitly sealed. Inheritance is a central feature of OOP that enables us to treat a reference to a derived class as though it refers to the base class, overriding the base class’s properties and methods to have new behavior as needed. These features don’t apply to value types, but that doesn’t mean value types are inferior.</p>
<p class="TX">Using the term <i>polymorphism</i> interchangeably with <i>inheritance</i> is common, but polymorphism is a more general concept; it relates to writing <span aria-label=" Page 212. " epub:type="pagebreak" id="pg_212" role="doc-pagebreak"/>code that works uniformly for a variety of types to reduce duplication. As this chapter discusses, inheritance is just one kind of polymorphism, and while there are sound technical and semantic reasons for why value types can’t employ inheritance relationships, they can take advantage of other kinds of polymorphism.</p>
<p class="TX">We’ll explore the following:</p>
<ul class="BL">
<li class="BL">Why value types are sealed and why value-like types in general shouldn’t use inheritance</li>
<li class="BL">How subtyping differs from subclassing and why it matters</li>
<li class="BL">What <i>type substitutability</i> means and how it relates to inheritance</li>
<li class="BL">Where to use other kinds of polymorphism, rather than inheritance, to model relationships between objects</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-156"/><samp class="SANS_Futura_Std_Bold_B_11">Why Value Types Are Sealed</samp></h2>
<p class="TNI">The principal technical reason for prohibiting inheritance for structs, and by extension record structs, is that they have different lifetime and storage characteristics than reference types. The restriction is more than an arbitrary rule: it results directly from how value type variables behave in memory, and how that behavior differs from reference types.</p>
<p class="TX">Inheritance between classes allows us to use a reference to a base class type to refer to an instance of a derived class, so the static, compile-time type of a reference variable isn’t necessarily the same as the dynamic, run-time instance type. This characteristic permits <i>virtual dispatch</i> for method calls—the mechanism whereby the appropriate method implementation will be called based on the actual type of the object at run time—and relies on the extra level of indirection afforded by references; therefore, inheritance is appropriate only for reference types.</p>
<p class="TX">Value type variables directly contain their data, so we can’t declare a variable as one type to represent an instance of a different type, other than via boxing. Inheriting from a struct thus makes no sense, and the compiler forbids it.</p>
<p class="TX">Remember, though, that we can use classes to model value-like behavior. As you saw in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> behaves like a value but is implemented as a reference type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> type uses a value-based (rather than identity-based) equality comparison, is immutable, and has various other characteristics that identify it as a value. Being a class, <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> could support virtual method dispatch, but we can’t derive from the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class because it’s explicitly sealed. This means we can’t create our own augmented subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> any more than we could inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>, or any other value type.</p>
<p class="TX">Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class, records are reference types but have value-like equality behavior. Records can derive from other records and can also have virtual methods, so they seemingly unify the ideas of values and <span aria-label=" Page 213. " epub:type="pagebreak" id="pg_213" role="doc-pagebreak"/>inheritance. However, using records is not that straightforward. We need to note the subtleties and avoid the pitfalls when using any inheritance, whether between classes or records.</p>
<p class="TX">When we allow our types to participate in inheritance relationships, we need to be mindful of what deriving from those types might entail. There’s a difference between <i>implementation</i> and <i>interface</i> inheritance. Inheriting an implementation presents some of the same difficulties as deriving from a value type. To explore why doing so is ill-advised, let’s look at a class with value-like characteristics and use implementation inheritance to demonstrate some of the problems that can result.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-157"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation Inheritance</samp></h3>
<p class="TNI">Anytime we inherit from a concrete class—that is, one that’s not fully abstract—we are, by definition, inheriting its implementation. <a href="#list7-1">Listing 7-1</a> shows a simple inheritance relationship: a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class derives from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> base class and adds a new feature of its own.</p>
<pre id="list7-1"><code>public class Color&#13;
{&#13;
    public Color(int red, int green, int blue)&#13;
        =&gt; (Red, Green, Blue) = (red, green, blue);&#13;
    public int Red   {get;}&#13;
    public int Green {get;}&#13;
    public int Blue  {get;}&#13;
}&#13;
public class TranslucentColor : Color&#13;
{&#13;
    public TranslucentColor(int red, int green, int blue, int alpha)&#13;
        : base(red, green, blue) =&gt; Alpha = alpha;&#13;
    <b>public int Alpha {get;}</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Creating a derived class, TranslucentColor, that inherits the implementation of Color</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class subclasses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class and inherits all of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s structural representation, along with its methods and properties. Both classes have automatic properties, which are each given a backing field of the same type as the property—<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this example—and every field of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.</p>
<p class="TX">Even if we’d used private fields in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and returned their values via the properties, those fields would be inherited by the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class, although they’d still be accessible only via the inherited <i>public</i> properties.</p>
<p class="TX">The implementation inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> depends on those private fields. An instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> requires its own <span aria-label=" Page 214. " epub:type="pagebreak" id="pg_214" role="doc-pagebreak"/>copies of all the fields declared by its base class so that the properties inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> work correctly. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties via a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> variable as if they were declared as members of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, as shown here:</p>
<pre><code>var foreground = new TranslucentColor(red: 0xFF, green: 0, blue: 0, alpha: 0x77);&#13;
Assert.That(foreground.Red, Is.EqualTo(0xFF));&#13;
Assert.That(foreground.Alpha, Is.EqualTo(0x77));</code></pre>
<p class="TX">In this simple test, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp> property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> variable, which inherited that property from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. We can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property, which was declared as a member of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.</p>
<p class="TX">Using inheritance like this—to reuse the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>—is attractive, because it means that the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> type definition doesn’t duplicate <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties. By deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class gets those properties for free.</p>
<p class="TX">Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> look like good candidates to be value types because an equality comparison should compare each instance’s state. However, making value-based equality behave correctly in an inheritance hierarchy hides complexity that can easily result in undesirable behavior. To demonstrate that, let’s give <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> value semantics by following the recommendations from <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> to override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and its companions for both classes.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-158"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value-Based Equality for Classes</samp></h3>
<p class="TNI">We begin with the base class, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. With the implementation in <a href="#list7-2">Listing 7-2</a>, we can compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances to see whether their properties are equal.</p>
<pre id="list7-2"><code>public class Color : IEquatable&lt;Color&gt;&#13;
{&#13;
    public int Red   {get;}&#13;
    public int Green {get;}&#13;
    public int Blue  {get;}&#13;
    public bool Equals(Color? other)&#13;
        =&gt; (object?)this == (object?)other ||&#13;
           other is not null &amp;&amp;&#13;
           GetType() == other.GetType() &amp;&amp;&#13;
           Red == other.Red &amp;&amp; Green == other.Green &amp;&amp; Blue == other.Blue;&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; Equals(obj as Color);&#13;
    public override int GetHashCode()&#13;
        =&gt; HashCode.Combine(Red, Green, Blue);&#13;
    public static bool operator==(Color? left, Color? right)&#13;
        =&gt; left?.Equals(right) ?? right is null;&#13;
<span aria-label=" Page 215. " epub:type="pagebreak" id="pg_215" role="doc-pagebreak"/>&#13;
    public static bool operator!=(Color? left, Color? right)&#13;
        =&gt; !left?.Equals(right) ?? right is not null;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Defining value equality in the base class, Color</samp></p>
<p class="TX">This implementation of equality follows common practice for implementing value-based equality for classes, including the guidelines given in the Microsoft documentation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Color&gt;</samp> interface, which requires an overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method specifically for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. We use this overload to provide the full implementation, which we can call from any other method, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method overridden from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class. Since we’ve overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>, we also override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to ensure that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> produce the same hash code if they compare equal. Finally, we provide implementations for the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> equality operators.</p>
<p class="TX">Let’s examine each step in detail.</p>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Canonical Form of Equals</samp></h4>
<p class="TNI">First we have to override the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, as shown in <a href="#list7-3">Listing 7-3</a>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a class, by default <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> compares object identities, so we need to override that behavior to give <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> a value-based implementation.</p>
<pre id="list7-3"><code>public override bool Equals(object? obj)&#13;
    =&gt; Equals(obj as Color);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Overriding Equals</samp></p>
<p class="TX">The override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> must match the base-class signature. In this example, we declare the types within a nullable context, so we use <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> as the parameter type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, indicating that we know the parameter could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> and can handle that circumstance safely. Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> operator to cast <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> in order to call the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. If <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> isn’t a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> or is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, the argument passed will be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which is explicitly handled by the type-safe overload in <a href="#list7-4">Listing 7-4</a>.</p>
<pre id="list7-4"><code>public bool Equals(Color? other)&#13;
    =&gt; (object?)this == (object?)other ||&#13;
       other is not null &amp;&amp;&#13;
       GetType() == other.GetType() &amp;&amp;&#13;
       Red == other.Red &amp;&amp; Green == other.Green &amp;&amp; Blue == other.Blue;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: Implementing IEquatable</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">Color</span><span class="TheSansMonoCd_W5Regular_11">&gt;</span></p>
<p class="TX">The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Color&gt;</samp> interface takes a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter. This overload will always be preferred over the method taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter when we’re comparing two variables whose static type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, including when we call it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> methods.</p>
<p class="TX"><span aria-label=" Page 216. " epub:type="pagebreak" id="pg_216" role="doc-pagebreak"/>One implication of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> being a reference type is that it’s possible for the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter to refer to the same instance as <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>. To handle this scenario, <a href="#list7-4">Listing 7-4</a> casts both <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> to make it clear that we intend a reference comparison. While the cast we used in <a href="#list7-3">Listing 7-3</a> from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> to a more derived type is a relatively costly run-time conversion, the conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to its <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class is very efficient and allows the comparison to be made with the intrinsic <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction introduced in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. One alternative would be to use <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals(this, other)</samp> here, making the reference-based comparison explicit.</p>
<p class="TX">Comparing the two variables to see whether they reference the same object is a simple but not mandatory optimization. The logical <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operator short-circuits if its left-hand expression is true, so the rest of the comparisons are attempted only if <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> are references to different instances. Note that the order of comparisons in this code relies on operator precedence; the logical <samp class="SANS_TheSansMonoCd_W5Regular_11">AND</samp> operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp>) has a higher precedence than logical <samp class="SANS_TheSansMonoCd_W5Regular_11">OR</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>), so the comparisons on the right side of <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> all bind together as if they were explicitly grouped within a pair of parentheses. Although redundant, the extra parentheses don’t affect the behavior in any way, and some programmers prefer to add them to avoid having to remember the operator precedence rules.</p>
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a reference type, the argument passed could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">is not</samp> constant pattern to compare <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> and avoid the common trap of calling our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method recursively.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class is intentionally not sealed, so we also check that the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> value is exactly the same type as <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> method, defined on the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class. This method returns the run-time type of an instance, and the types won’t match if <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> is a reference to a more derived type such as <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. Objects of different types don’t normally compare equal, even if their types are related by inheritance.</p>
<p class="TX">Finally, if the types match, we compare each property’s value in turn. If they all match, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> here because all the properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are simple <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values. Built-in values such as these can be compared intrinsically, and much more compactly than calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for each of them.</p>
<p class="TX">To make comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances natural, we also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, which both defer to the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, like this:</p>
<pre><code>public static bool operator==(Color? left, Color? right)&#13;
    =&gt; left?.Equals(right) ?? right is null;&#13;
public static bool operator!=(Color? left, Color? right)&#13;
    =&gt; !left?.Equals(right) ?? right is not null;</code></pre>
<p class="TX"><span aria-label=" Page 217. " epub:type="pagebreak" id="pg_217" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator will return the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> if the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> parameter is not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>; otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if both the parameters are <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator returns the opposite of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> by inverting the comparisons.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Contract for Equality</samp></h4>
<p class="TNI">Implementing equality in a way that is self-consistent is critical. It would be a strange state of affairs if we had two references to the same instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that did <i>not</i> compare equal, and stranger still if <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> when comparing a value with itself. Equality has a contract similar to the one you saw for less-than comparisons in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. Namely, equality has the following characteristics:</p>
<p class="ListHead"><b>Reflexive</b></p>
<p class="ListPlainFirst"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is always <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.</p>
<p class="ListHead"><b>Symmetric</b></p>
<p class="ListPlainFirst">If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.</p>
<p class="ListHead"><b>Transitive</b></p>
<p class="ListPlainFirst">If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <i>and</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, then it follows that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>.</p>
<p class="ListHead"><b>Safe</b></p>
<p class="ListPlainFirst">Non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values are never equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="ListHead"><b>Stable</b></p>
<p class="ListPlain">The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> doesn’t change as long as <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> don’t change.</p>
<p class="TX">In <a href="#list7-5">Listing 7-5</a>, we write some tests to prove that we’ve met the requirements of the equality contract.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>These tests are presented this way for emphasis, not to demonstrate a good style of assertion writing.</i></p>
<p class="TX">The first test also ensures that we’re comparing the variables by value, not merely comparing references.</p>
<pre id="list7-5"><code>var pencil = new Color(0xFF, 0, 0);&#13;
var crayon = new Color(0xFF, 0, 0);&#13;
var brush =  new Color(0xFF, 0, 0);&#13;
// Reflexive, value-based equality&#13;
Assert.That(pencil == pencil, Is.True);&#13;
Assert.That(pencil == new Color(0xFF, 0, 0), Is.True);&#13;
// Symmetric&#13;
Assert.That(pencil == crayon, Is.True);&#13;
Assert.That(crayon == pencil, Is.True);&#13;
// Transitive&#13;
Assert.That(pencil == crayon, Is.True);<span aria-label=" Page 218. " epub:type="pagebreak" id="pg_218" role="doc-pagebreak"/>&#13;
Assert.That(crayon == brush, Is.True);&#13;
Assert.That(pencil == brush, Is.True);&#13;
// Safe with null&#13;
Assert.That(pencil != null, Is.True);&#13;
Assert.That(null != pencil, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Testing the contract for equality for Color</samp></p>
<p class="TX">Writing a test for comparison stability is more difficult, so in <a href="#list7-6">Listing 7-6</a> we test the opposite: that if one of the values changes, the instances are no longer equal.</p>
<pre id="list7-6"><code>var pencil = new Color(0xFF, 0, 0);&#13;
var crayon = new Color(0xFF, 0, 0);&#13;
Assert.That(pencil == crayon, Is.True);&#13;
pencil = new Color(0, 0xFF, 0);&#13;
Assert.That(pencil != crayon, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Testing that equality is stable</samp></p>
<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties are immutable, we can change the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> only by assigning it to a new instance. However, the effect is the same as if we had mutated one or more of the properties, because we have arranged for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances to be compared by value.</p>
<p class="TX">We have one other requirement for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and its operator counterparts: they must never throw an exception. Our implementation has no danger of that, since we have already tested that it is safe with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h-159"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality Behavior in Derived Classes</samp></h3>
<p class="TNI">The next step is to implement equality for the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class, which, as we know, inherits all the methods and properties from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> is a value-like type, it should implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface for itself, substituting the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. As <a href="#list7-7">Listing 7-7</a> shows, implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; TranslucentColor&gt;</samp> is a little simpler than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> base class, which already does most of the work.</p>
<pre id="list7-7"><code>public class TranslucentColor : Color, IEquatable&lt;TranslucentColor&gt;&#13;
{&#13;
    public int Alpha {get;}&#13;
    public bool Equals(TranslucentColor? other) <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>&#13;
        =&gt; base.Equals(other) &amp;&amp; Alpha == other.Alpha;&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; Equals(obj as TranslucentColor);&#13;
<span aria-label=" Page 219. " epub:type="pagebreak" id="pg_219" role="doc-pagebreak"/>&#13;
    public override int GetHashCode()&#13;
        =&gt; HashCode.Combine(Alpha, base.GetHashCode());&#13;
    public static bool operator==(TranslucentColor? left, TranslucentColor? right) <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>&#13;
        =&gt; left?.Equals(right) ?? right is null;&#13;
    public static bool operator!=(TranslucentColor? left, TranslucentColor? right)&#13;
        =&gt; !left?.Equals(right) ?? right is not null;&#13;
}</code></pre>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Behavior inheritance in the derived class, TranslucentColor</samp></p>
<p class="TX">As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> implementation, <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> method, converting the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> in order to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp> method <span aria-label="annotation1" class="CodeAnnotation">❶</span>. That method also checks whether we’re comparing two references to a single instance and ensures that the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> already performs the check for identical references, the comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, and the type check, as well as comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> properties, we don’t need to duplicate those comparisons and can simply invoke the base class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method before finally comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> properties that are specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. Passing <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">base.Equals</samp> is fine because a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> reference will convert implicitly to its <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> base class type.</p>
<p class="TX">We also give <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> its own implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, and they, too, follow the same pattern as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, except that they take two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> parameters <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
<p class="TX">The contract for equality applies not only to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> but also to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. We can use a test similar to the one from <a href="#list7-5">Listing 7-5</a> to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> meets the contract’s requirements. <a href="#list7-8">Listing 7-8</a> shows a variation on <a href="#list7-6">Listing 7-6</a>’s stability check for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as we test that differences in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property value will cause instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> to compare unequal.</p>
<pre id="list7-8"><code>var pencil = new TranslucentColor(0xFF, 0, 0xFF, 0x77);&#13;
var crayon = new TranslucentColor(0xFF, 0, 0xFF, 0x77);&#13;
Assert.That(pencil == crayon, Is.True);&#13;
pencil = new TranslucentColor(0xFF, 0, 0xFF, 0);&#13;
<b>Assert.That(pencil !=</b> <b>crayon, Is.True);</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Testing the equality contract for TranslucentColor</samp></p>
<p class="TX">In this example, the two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property and correctly compare <i>not</i> equal. We might conclude, then, that all is right with the world—but we’d be wrong.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-160"/><span aria-label=" Page 220. " epub:type="pagebreak" id="pg_220" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality Comparisons and Type Substitution</samp></h3>
<p class="TNI">We’ve used a suite of tests to reassure us that the equality contract is intact for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> when we’re using variables whose dynamic (run-time) instance type is the same as their static (compile-time) variable type. However, the types might not always match. The compiler allows us to pass a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> anywhere a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference is required because <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a direct base class of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. In other words, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type can be <i>substituted</i> by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. At run time, any <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference may, in fact, refer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instance.</p>
<p class="TX">To illustrate the effect on equality of using a base class reference to a derived class instance, <a href="#list7-9">Listing 7-9</a> explicitly uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> base class reference to declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> values that aren’t equal because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> properties differ.</p>
<pre id="list7-9"><code><b>Color</b> pencil = new TranslucentColor(0xFF, 0, 0xFF, <b>0x77</b>);&#13;
<b>Color</b> crayon = new TranslucentColor(0xFF, 0, 0xFF, <b>0</b>);&#13;
Assert.That(pencil == crayon, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Testing equality from the base class</samp></p>
<p class="TX">This test fails: the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables compare equal even though the instances have different values. It makes no difference whether we compare the variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> or call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method; the outcome is the same.</p>
<p class="TX">The static types being compared are <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variables, so what’s invoked here is the base class implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, which in turn calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> knows nothing about the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> determines equality by using only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> properties. Those properties are all identical, so according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp>, the two objects are equal.</p>
<p class="TX">Those are the mechanics that explain why our <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables incorrectly compare equal, but type substitution isn’t always so easy to spot, and its consequences are far-reaching.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Effects of Type Substitution</samp></h4>
<p class="TNI">We would rarely explicitly use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference for a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> object, but we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> reference as an argument to a method with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter. We can substitute a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> when a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is expected.</p>
<p class="TX"><a href="#list7-10">Listing 7-10</a> shows that if we pass two references to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> objects that differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> values to a method with <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameters, those parameter variables compare equal within the method. If we pass the same two references to a method that takes <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> parameters, the values won’t compare equal even though they haven’t changed.</p>
<pre id="list7-10"><code><b>bool EqualViaBase(Color left, Color right)</b>&#13;
    =&gt; left.Equals(right);&#13;
bool EqualViaDerived(TranslucentColor left, TranslucentColor right)&#13;
    =&gt; left.Equals(right);&#13;
<span aria-label=" Page 221. " epub:type="pagebreak" id="pg_221" role="doc-pagebreak"/>&#13;
var pencil = new TranslucentColor(0xFF, 0, 0xFF, 0x77);&#13;
var crayon = new TranslucentColor(0xFF, 0, 0xFF, 0);&#13;
<b>Assert.That(EqualViaBase(pencil, crayon), Is.True);</b>&#13;
Assert.That(EqualViaDerived(pencil, crayon), Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Testing the stability promise</samp></p>
<p class="TX">In the first assertion, the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> references are automatically converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> references when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp> method because a reference to a derived class is implicitly convertible to a reference to any of its base classes. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> within <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp> invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s implementation, which incorrectly determines the parameter variables to be equal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp> method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor.Equals</samp> directly, which correctly reports that the parameter variables are not equal.</p>
<p class="TX">The equality implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> isn’t stable: it can produce a different result for the same two instances depending on the static type of the variable used to refer to those instances, even when their underlying state remains unchanged.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Breach of Contract</samp></h4>
<p class="TNI">The behavior of the tests in <a href="#list7-10">Listing 7-10</a> demonstrates that <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> breaks the promise of stability established by the contract for equality— namely, that the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> doesn’t change if the values being compared don’t change. When we compare two variables that have different values, they should compare not equal, and as long as no changes are made to either variable’s state, the result of the comparison shouldn’t change.</p>
<p class="TX">One problem with our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation is that the type-specific overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class isn’t virtual, and therefore it can’t be overridden in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. The virtual version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, which takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter, isn’t considered in overload resolution because the overload with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter is a much better match, even when the run-time type is derived from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<p class="TX">To get the test in <a href="#list7-9">Listing 7-9</a> to pass, we could make the type-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method virtual in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and add an override for it in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. Another possibility would be to remove the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> so that the only <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method would be virtual. We’d lose the facility for type-specific comparisons, with a small performance cost, but this option would address the problem of stability. However, either approach would be solving the wrong problem.</p>
<p class="TX">The real underlying problem is that we’ve used inheritance inappropriately, not that our implementation of equality is incorrect. To fully appreciate why, we need to be clear on the difference between subclasses and subtypes.</p>
</section>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h2 class="H1" id="sec10"><span id="h-161"/><span aria-label=" Page 222. " epub:type="pagebreak" id="pg_222" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Inclusion Polymorphism and Subtyping</samp></h2>
<p class="TNI">We think of the classes, structs, records, and record structs we write as being user-defined types. By extension, then, it’s natural to think that the definition of a class is its type. That perception is partially true, but a more formal distinction between <i>type</i> and <i>class</i> exists.</p>
<p class="TX">The polymorphism afforded by using inheritance is known as <i>inclusion</i> polymorphism. If we were to group all the objects in a system by type, each group of any specific type would <i>include</i> all the types that inherit from it, known as <i>subtypes</i>. In our example, the group for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type includes both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> types.</p>
<p class="TX">An object’s type is a contract for its interface and describes the allowable operations on the object. The operations defined by a type are, therefore, valid for any subtypes in its group. Practically speaking, if we derive from a given type, all the operations that are valid for an object of the base type must be valid—and behave correctly—for an object of the derived type.</p>
<p class="TX">In our example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> object is an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type as well as being a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. This relationship means we can invoke any <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> operation on a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, which in turn means we can pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instance to a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter. As far as the compiler is concerned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> must be able to support all the operations of its base type, so it allows the substitution.</p>
<p class="TX">The type of an object establishes which operations a subtype must support, but it doesn’t specify any structural details or specific implementation. We’re free to implement the same interface in different ways, using various classes. However, while the contract for a type doesn’t mandate a specific implementation, it does define the expected behavior of any of its operations. When we inherit from a concrete class, we inherit its implementation, and this sets an expectation for that behavior. When implementing a type as a class or record, we must be mindful of the distinction between subtyping and subclassing, since we can inherit from reference types unless they’re explicitly sealed. For value types in C#, this isn’t an issue, because they’re implicitly sealed and so can’t have derived types.</p>
<p class="TX">As noted earlier in this chapter, implementation and interface inheritance differ. In other words, simply inheriting from a class isn’t the same as actually respecting its behavioral characteristics. Code written in terms of the more general <i>type</i>, which defines the interface, may well depend on the specific characteristics of the <i>class</i>, which represents a particular implementation. If the derived class doesn’t respect the behavioral aspect of the type’s contract, when we use an instance of the derived class in code written for the base type, that code will very likely have unexpected behavior.</p>
<p class="TX">When we inherit from a class, we inherit its behavior, characteristics, and expectations. A class that inherits from another concrete class is, then, a subclass, and only a true subtype if code using the base class <i>type</i> can use the derived class transparently with no change in observable behavior. When we inherit only the type, we have no implementation behavior to consider.</p>
<p class="TX">Mechanically speaking, we can substitute a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> where a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is required because we can use a reference to the derived type <span aria-label=" Page 223. " epub:type="pagebreak" id="pg_223" role="doc-pagebreak"/>as an argument to a method expecting the base type. However, as you’ve seen with the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances interchangeably is not really possible.</p>
<p class="TX">The lack of substitutability between <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> arises because <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> is a <i>subclass</i> but not a true <i>subtype</i> of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-162"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Input and Output Types of Virtual Methods</samp></h3>
<p class="TNI">The difference between a subtype and a subclass has implications that go beyond how an inherited <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is implemented. We can override any virtual method with an implementation that is appropriate for the derived class. If the observable effects, including any side effects, of calling the more derived method are identical to the effects of the base class, then the derived type is a good substitute for its base type—that is, the derived type is a proper subtype. Side effects might include writing to a file or to the screen, or perhaps updating the value of a variable visible outside the method. If a derived class does any of these things when its base class doesn’t, it’s not a true subtype.</p>
<p class="TX">A method’s behavior includes what the method considers to be valid inputs and outputs—that is, what parameters a method accepts and what it may return—each of which directly affects the method caller. To illustrate, suppose we add a virtual method to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class like the one in <a href="#list7-11">Listing 7-11</a> to subtract one <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value from another.</p>
<pre id="list7-11"><code>public virtual Color Subtract(Color? other)&#13;
{&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-11: Adding a virtual Subtract method to Color</samp></p>
<p class="TX">Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method is virtual, we can specialize its implementation in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> to handle subtraction appropriately for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances. Regardless of the actual algorithm used to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>, its return value is the observable behavior of the method, as long as it has no side effects.</p>
<p class="TX">If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> implementation in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> never returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference but the overridden version in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> might, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> method has a weaker behavioral contract than the base class method. Allowing the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> implementation to return a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value requires extra checking in the calling code to avoid <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>-reference exceptions. The calling code, knowing only about the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type, might reasonably expect only non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values. The weaker requirements on the return type mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> isn’t substitutable for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<p class="TX">A corresponding situation arises when we <i>strengthen</i> requirements on the parameters in an overridden method. If we insist on non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values in the derived type but the base class accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> references, we break the contract established by the base class method. Once again, code written in terms of the base class has no notion of those requirements in derived classes and can easily violate them.</p>
<p class="TX"><span aria-label=" Page 224. " epub:type="pagebreak" id="pg_224" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method shown in <a href="#list7-11">Listing 7-11</a> mitigates both of these potential problems by using the nullable reference type feature available since C# v8.0. The return type of the base <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method is non-nullable, and the compiler will warn us if we override it with a method having a nullable reference type or if that method attempts to return a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference. Similarly, the parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Subtract</samp> method is a nullable reference, indicating that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is an acceptable argument. If we override the method with a non-nullable reference type, the compiler will warn us that the method signature doesn’t match the base declaration.</p>
<p class="TX">Note that if the base method returns a nullable reference and we override it to return a non-nullable reference, the compiler won’t give a warning. That is because in this case we’re strengthening the behavioral contract in the derived method, and it’s entirely reasonable for the more derived method to prohibit <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, even if the base method allows it. The requirements on any code calling the method from a base type reference aren’t affected.</p>
<p class="TX">Likewise, the compiler is silent if the base method has a non-nullable parameter and we override it to allow a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference to be passed to the derived method, because weakening the parameter’s contract in the more derived type is safe and reasonable. The change is visible only to code using the more derived type <i>directly</i> rather than via a base type reference.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-163"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Upholding a Type’s Contract</samp></h3>
<p class="TNI">Our test for equality using base class references in <a href="#list7-9">Listing 7-9</a> fails because the contract for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp> isn’t properly fulfilled by the derived class. The expectations set out by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> aren’t met by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, which imposes a new requirement on <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> because equality between <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances must also compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property. Our test fails as a direct result of our using implementation inheritance and expecting type substitutability, when in fact <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> isn’t substitutable for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. The implications of implementation inheritance apply to all inheritance relationships, not just when we’re modeling value semantics.</p>
<p class="TX">Upholding a type’s contract matters in practical ways. The behavior of an inherited method is part of that contract, and failing to uphold it can result in extremely hard-to-diagnose errors. If we fail to meet the <i>interface</i> contract of a base class—for instance, by using a different signature in an overridden method—the compiler will inform us with an error. However, the compiler can’t check that we’ve also kept the behavioral promises of a base class. Here we must use our own judgment, and that’s not necessarily as straightforward as it might seem.</p>
<p class="TX">One rule of thumb is to avoid implementation inheritance whenever we use inheritance. The simplest way to be certain of that is to never derive from a class that has any concrete behavior—including abstract classes with any nonabstract methods. Types defined with the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp> keyword can’t have any implementation, and any class implementing an interface is a true subtype.</p>
<p class="TX">Another rule is that value types implemented as classes shouldn’t inherit from anything and should be sealed. In fact, this second rule <span aria-label=" Page 225. " epub:type="pagebreak" id="pg_225" role="doc-pagebreak"/>arises as a result of the first: it makes little sense for a value type to be fully abstract, since a defining feature of value and value-like types is that we compare them according to the value they represent. It follows, then, that value types are concrete types. The built-in value-like class <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> leads the way with this advice, which is why <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> is intentionally a sealed class.</p>
<p class="TX">Similar to strings, records are reference types that have value semantics for the purpose of comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. Unlike strings, records can inherit from other records, but just as when we derive from a concrete class, a derived record inherits all the base record’s behavior. Therefore, we must still take care to uphold the base record’s promises in a derived record; however, as with classes, doing so isn’t always as simple as it might seem. Even though records permit inheritance, they’re specifically intended to model value types, so the advice to seal value types applies equally to them.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-164"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inheriting Record Types</samp></h3>
<p class="TNI">When compiled, a record type is a class with some compiler-generated methods, including everything required for value-based equality. Moreover, records defined using the positional syntax are immutable by default. Using records instead of classes for creating value-like types, then, saves us from having to write a lot of boilerplate code.</p>
<p class="TX">Records, unlike structs, can inherit from other records, although they can’t be part of an inheritance relationship with a class. We might therefore recast our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> types as records, as in <a href="#list7-12">Listing 7-12</a>.</p>
<pre id="list7-12"><code>public record Color(int Red, int Green, int Blue);&#13;
public record TranslucentColor(int Red, int Green, int Blue, int Alpha)&#13;
            : Color(Red, Green, Blue);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-12: Inheriting record types</samp></p>
<p class="TX">Here we define <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> as positional records with positional parameters that represent read-only properties with those names, and a constructor taking parameters of the same type. The inheritance syntax for records differs slightly from that for classes because we need to initialize the positional parameters in the base record. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> record derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and passes its <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> parameter values to the respective positional parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<p class="TX">As we explored in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, the compiler generates the implementations of the constructor and properties for us, along with implementations for various overrides of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and a few methods, including a value-based implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, and others. Equality comparisons between record variables compare the value of each property, so two record variables are equal if all their properties are equal.</p>
<p class="TX">We can write our own implementation of the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method created by the compiler if we wish. However, the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by the compiler is specially crafted to take inheritance into account.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H3" id="sec14"><span aria-label=" Page 226. " epub:type="pagebreak" id="pg_226" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Records and the Equality Contract</samp></h4>
<p class="TNI">The contract for equality applies to records just as for any other type, and the code provided by the compiler ensures that every aspect of the contract is respected, including the stability of comparisons via base class references. The test in <a href="#list7-13">Listing 7-13</a> differs from the test in <a href="#list7-10">Listing 7-10</a> in that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> types are records rather than classes. Here we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> record values with different <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> properties and assert that they compare unequal whether we compare them directly using their concrete type or indirectly via a base class reference.</p>
<pre id="list7-13"><code>bool EqualViaBase(Color left, Color right)&#13;
    =&gt; left.Equals(right);&#13;
bool EqualViaDerived(TranslucentColor left, TranslucentColor right)&#13;
    =&gt; left.Equals(right);&#13;
var pencil = new TranslucentColor(0xFF, 0, 0xFF, 0x77);&#13;
var crayon = new TranslucentColor(0xFF, 0, 0xFF, 0);&#13;
<b>Assert.That(EqualViaBase(pencil, crayon), Is.False);</b>&#13;
<b>Assert.That(EqualViaDerived(pencil, crayon), Is.False);</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-13: Equality between record types</samp></p>
<p class="TX">This test passes, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables compare not equal whichever method we call, <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>.</p>
<p class="TX">Because the compiler-generated implementation of equality pays particular attention to the equality contract, the variables compare not equal whether we use a base <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record reference or the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> reference. In particular, the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Color)</samp> is virtual in a record implementation and is overridden in the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> record. As mentioned, doing this for our class implementations would make the test behave correctly. With records, the compiler injects those implementations for us.</p>
<p class="TX">We can override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> methods ourselves, in which case the compiler won’t synthesize methods whose signature matches our own custom implementations. However, if we do so, we must pay the same attention to the equality contract as the compiler would in its generated version.</p>
<p class="TX">In nonsealed records, the compiler creates a virtual property named <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>, which uses <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> to report the static (compile-time) type of its containing record. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record shown in <a href="#list7-14">Listing 7-14</a> is equivalent to the one generated by the compiler, although, as you saw in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, some implementation details differ.</p>
<pre id="list7-14"><code>public class Color : IEquatable&lt;Color&gt;&#13;
{&#13;
    <var>--snip--</var>&#13;
    <b>protected virtual Type EqualityContract</b>&#13;
        <b>=&gt;</b> <b>typeof(Color);</b>&#13;
<span aria-label=" Page 227. " epub:type="pagebreak" id="pg_227" role="doc-pagebreak"/>&#13;
    public virtual bool Equals(Color? other)&#13;
        =&gt; (object?)this == (object?)other ||&#13;
           other is not null &amp;&amp;&#13;
           <b>EqualityContract</b> <b>==</b> <b>other.EqualityContract &amp;&amp;</b>&#13;
           Red == other.Red &amp;&amp; Green == other.Green &amp;&amp; Blue == other.Blue;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-14: Using the equality contract in a nonsealed record</samp></p>
<p class="TX">When one record derives from another, as <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> does from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, the compiler adds an override of <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> in the derived record to report its static type. The compiler-generated implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in the base class checks that the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> properties match for both objects. If they don’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.</p>
<p class="TX">Notwithstanding the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property, the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> follows the canonical form shown in <a href="#list7-4">Listing 7-4</a>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter could refer to an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. If we attempt to compare a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record with a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> properties won’t match, and the objects will (correctly) compare not equal. Checking the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property is analogous to our original <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class in <a href="#list7-4">Listing 7-4</a> checking that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> returned the same type for both objects. Using the static type as <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> does has a slight benefit over <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> because <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> is evaluated at compile time, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> is evaluated at run time.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property is <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp> so that it can be overridden by the derived type, but it can’t be called publicly. As <a href="#list7-15">Listing 7-15</a> shows, the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property is overridden in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> record to return the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.</p>
<pre id="list7-15"><code>public class TranslucentColor : Color, IEquatable&lt;TranslucentColor&gt;&#13;
{&#13;
    <var>--snip--</var>&#13;
    protected override Type EqualityContract&#13;
        =&gt; typeof(TranslucentColor);&#13;
    <b>public override bool Equals(Color? obj)</b>&#13;
        <b>=&gt;</b> <b>Equals(obj as TranslucentColor);</b>&#13;
    public virtual bool Equals(TranslucentColor? other)&#13;
        =&gt; base.Equals(other) &amp;&amp; Alpha == other.Alpha;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-15: Overriding the equality contract in the TranslucentColor record</samp></p>
<p class="TX">The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> calls the base class implementation before comparing the local properties of each object, ensuring that the contract properties are always compared. Crucially, the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> method is overridden in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> and casts its argument to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. If that cast fails, the argument passed will be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> <span aria-label=" Page 228. " epub:type="pagebreak" id="pg_228" role="doc-pagebreak"/>reference variables, as when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp> method in <a href="#list7-13">Listing 7-13</a>, it’s this override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> that’s executed via virtual dispatch.</p>
<p class="TX">If we write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, it must also compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> properties because it rarely makes sense for instances of different types to compare equal.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property alone doesn’t solve the problem of comparing two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> references. Our test in <a href="#list7-13">Listing 7-13</a> passes because the compiler generates a virtual type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and overrides it in the derived record. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable, if the run-time instance is a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, we call the more derived implementation. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp> method is also virtual, because <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> can itself be inherited. A record deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> will have compiler-generated overrides of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> alongside its own type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.</p>
<p class="TX">However, equality isn’t the only implementation we can inherit from a class or a record. We can define our own virtual and nonvirtual methods for a record exactly as we do for a class.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Contracts Other Than Equality</samp></h4>
<p class="TNI">The behavioral contract established by a base class or record applies to all its methods, not just <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The compiler generates the right implementations to compare two record instances for equality, but we have to supply any other implementations for ourselves. One common interface implemented by value types is <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp>, which, as you saw in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, allows us to sort collections of value types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> records in <a href="#list7-16">Listing 7-16</a> are related by inheritance, and each implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp> interface by defining a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> method.</p>
<pre id="list7-16"><code>public record Area(double Width, double Height)&#13;
    : IComparable&lt;Area&gt;&#13;
{&#13;
    public int CompareTo(Area? other)&#13;
    {&#13;
        if(other is null) return 1;&#13;
        return (int)(Width * Height - other.Width * other.Height);&#13;
    }&#13;
    public static bool operator&lt;(Area left, Area right)&#13;
        =&gt; left.CompareTo(right) &lt; 0;&#13;
    public static bool operator&gt;(Area left, Area right)&#13;
        =&gt; left.CompareTo(right) &gt; 0;&#13;
}&#13;
public record Volume(double Width, double Height, double Depth)&#13;
    : Area(Width, Height), IComparable&lt;Volume&gt;&#13;
{&#13;
    public int CompareTo(Volume? other)&#13;
    {<span aria-label=" Page 229. " epub:type="pagebreak" id="pg_229" role="doc-pagebreak"/>&#13;
        if(other is null) return 1;&#13;
        return (int)(Width * Height * Depth -&#13;
                     other.Width * other.Height * other.Depth);&#13;
    }&#13;
    public static bool operator&lt;(Volume left, Volume right)&#13;
       =&gt; left.CompareTo(right) &lt; 0;&#13;
    public static bool operator&gt;(Volume left, Volume right)&#13;
       =&gt; left.CompareTo(right) &gt; 0;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-16: Sorting Area and Volume records with IComparable</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">T</span> <span class="TheSansMonoCd_W5Regular_11">&gt;</span></p>
<p class="TX">The compiler will generate the code to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, although we should keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values in each case, leading to possible problems, as we discovered in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. However, the compiler doesn’t provide the implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp>, so we must write our own. Here, we define the ordering for <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> so that one object is less than another if its total area is smaller. Similarly, for <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, one is less than another if its total volume is smaller. We also add <samp class="SANS_TheSansMonoCd_W5Regular_11">operator&lt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator&gt;</samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, implemented in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> method.</p>
<p class="TX">As we explored in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, ordering comparisons have their own contract, and the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp> in <a href="#list7-16">Listing 7-16</a> effectively suffer the same problems as our original implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> classes.</p>
<p class="TX">Although we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> in the declarations, we’re still employing implementation inheritance. Subclassing is as much an issue for records as it is for classes. We can demonstrate this with a new test in the same vein as checking whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances compare not equal when their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> properties differ. In <a href="#list7-17">Listing 7-17</a>, two <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> instances differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> property, but we compare them with <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp> by using references to the base record type.</p>
<pre id="list7-17"><code>Area door =   new Volume(Width: 100, Height: 200, Depth: 25);&#13;
Area window = new Volume(Width: 100, Height: 200, Depth: 5);&#13;
Assert.That(window &lt; door, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-17: Testing the contract for CompareTo in two Volume instances</samp></p>
<p class="TX">This test <i>fails</i> because the static, compile-time types of the <samp class="SANS_TheSansMonoCd_W5Regular_11">door</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp> variables differ from their dynamic, run-time types. When we compare them using the base class static type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> property of the derived record is ignored, giving an incorrect result.</p>
<p class="TX">As with the compiler implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp>, we could make the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> virtual in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> record and override it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> type. While doing so would address the immediate problem of this failing test, it wouldn’t solve every problem with our implementation. For example, when we compare an <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, what should <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> <span aria-label=" Page 230. " epub:type="pagebreak" id="pg_230" role="doc-pagebreak"/>return? An equality comparison between instances that aren’t the same type simply returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, but it’s not so straightforward for <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>. We might choose to compare any <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> as less than any <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, but that too may lead to confusion.</p>
<p class="TX">The question of whether an <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> is less than a <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> is not a meaningful one, but disallowing ordering comparisons for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> types individually would be extremely prohibitive; it makes perfect sense to see if one <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> is less than another, and likewise for <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>. We can arrange for <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> to throw an exception if the objects being compared have different run-time types, but this will add complexity to the calling code and may surprise some users.</p>
<p class="TX">This demonstrates first that records are not a “silver bullet,” and second—and more importantly—that we might still be trying to solve the wrong problem.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H2" id="sec16"><span id="h-165"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding Implementation Inheritance</samp></h3>
<p class="TNI">Our problems with inheriting <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> demonstrate why value types don’t make good base types, regardless of whether we use <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp> to define them.</p>
<p class="TX">More generally, inheriting any implemented behavior makes it challenging to ensure that code written for the base type will work correctly if we substitute an inherited type. Even if we don’t override the base type’s methods, we can’t easily guarantee that those methods will work correctly for any derived type. While inheritance is a popular mechanism for reusing a base type’s implementation, fulfilling the base type behavioral contract in a derived type is often much more difficult than it appears.</p>
<p class="TX">One way to ensure that one type can be substituted for another is to avoid implementation inheritance entirely. Remember, when we implement an interface, the implementing class is truly a subtype of the interface type; there’s no behavioral contract to consider because interfaces have no implementation. An interface type defines what an implementing type must be able to do but doesn’t prescribe any specific implementation. An interface, in effect, defines <i>only</i> a type, not a class.</p>
<p class="TX">An interface type can be substituted by any implementing type, so we can use different implementations under different circumstances. Code that depends only on an interface type—whether as a parameter in a method or a field in a type—is completely decoupled from the way that interface is implemented. This means that interfaces are <i>seams</i>—customization points in our code where we can swap one implementation for another.</p>
<p class="TX">Code that’s written in terms of interface types rather than concrete implementations is more flexible because it doesn’t depend on a particular implementation. It’s also easier to test because we can switch out concrete implementations of an interface with our own <i>test double</i>, sometimes known as a <i>stub</i>, <i>fake</i>, or <i>mock object</i>.</p>
<p class="TX">It’s common to see interface types represent the controllers and services described in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, sometimes with several implementations. A specific <span aria-label=" Page 231. " epub:type="pagebreak" id="pg_231" role="doc-pagebreak"/>concrete implementation may be selected at run time, perhaps according to configuration parameters or the run-time environment. However, code <i>using</i> the controller or service—frequently in the entity types—doesn’t need to change because its behavior depends only on the interface, not the specific concrete type. The controllers and services are also where we’re most likely to want a fake implementation during testing so that the testing doesn’t need access to an external or expensive resource, such as a real database.</p>
<p class="TX">When value types implement one or more interfaces, it’s to define specific protocols, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable&lt; T &gt;</samp>, rather than to allow client code to use different implementations. Value types, no matter the mechanism we use to implement them, should stand alone and be largely, if not wholly, independent of other types in an application.</p>
<p class="TX">The advice to avoid implementation inheritance leads to the recommendation that records should <i>always</i> be sealed, because they’re specifically designed for modeling value types. Classes should also be sealed by default, whether or not we’re using them to model values, and inheritance enabled only when we have a specific design rationale for it.</p>
<p class="TX">Although this advice might seem to limit the flexibility of our designs, we can use other ways to define relationships in our code without deriving new types from existing ones. Inheritance isn’t the only option for reusing the implementation of an existing type to extend its capabilities.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H2" id="sec17"><span id="h-166"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Containing Instead of Inheriting Types</samp></h3>
<p class="TNI">One way we can use the behavior of one concrete type to implement another is to simply <i>contain</i> (or <i>compose</i>) an instance of the type as a field or property. This is especially true when we need a value type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, that’s easily implemented in terms of a simpler type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, but without implying any type substitutability between them. While value types should generally be stand-alone, containing another value as a field is one exception that’s frequently beneficial.</p>
<p class="TX">We implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as a class and then as a record so we could take advantage of inheritance. Modeling values with a <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> is not unreasonable—and, as we know, records are specifically provided for that purpose. But if we contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instead of deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, using <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> to implement both types is much simpler. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">record struct</samp> is even simpler still, as we do in <a href="#list7-18">Listing 7-18</a>, where a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> contains an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<pre id="list7-18"><code>public readonly record struct Color(int Red, int Green, int Blue);&#13;
public readonly record struct TranslucentColor<b>(Color Color, int Alpha)</b>&#13;
{&#13;
    public TranslucentColor(int red, int green, int blue, int alpha)&#13;
        : this(new Color(red, green, blue), alpha)&#13;
    {&#13;
    }&#13;
<span aria-label=" Page 232. " epub:type="pagebreak" id="pg_232" role="doc-pagebreak"/>&#13;
    public int Red =&gt; Color.Red;&#13;
    public int Green =&gt; Color.Green;&#13;
    public int Blue =&gt; Color.Blue;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-18: Containing Color rather than inheriting from it</samp></p>
<p class="TX">Here, the compiler provides the implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> for each type, leaving us to define just the properties and behavior for them. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> type contains a read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance, and we add a new constructor as a convenience for our users, who can either create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value to pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>’s generated constructor or call our new constructor with each component part separately. We also mirror <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> and forward them to the contained <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value. We don’t get those properties for free, but they afford users of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> a much more natural interface, like this:</p>
<pre><code>var bg = new TranslucentColor(0xFF, 0xA0, 0, 0x77);&#13;
Assert.That(bg.Red,   Is.EqualTo(0xFF));&#13;
Assert.That(bg.Green, Is.EqualTo(0xA0));&#13;
Assert.That(bg.Blue,  Is.EqualTo(0));&#13;
Assert.That(bg.Alpha, Is.EqualTo(0x77));&#13;
<var>--snip--</var></code></pre>
<p class="TX">The alternative would force users to explicitly obtain the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property in order to access its properties, like so:</p>
<pre><code>Assert.That(bg.Color.Red,   Is.EqualTo(0xFF));&#13;
Assert.That(bg.Color.Green, Is.EqualTo(0xA0));&#13;
Assert.That(bg.Color.Blue,  Is.EqualTo(0));&#13;
Assert.That(bg.Alpha,       Is.EqualTo(0x77));&#13;
<var>--snip--</var></code></pre>
<p class="TX">Whether we use structs or define our value types with sealed records or classes, or record structs, testing our new types is much simpler to reason about now, as we don’t need to consider cases where <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instances are referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> references. That in itself is a large consideration because those tests will be not only easier to write but also easier to read by the next programmers who visit the code.</p>
<p class="TX">Composing types isn’t a perfect match for the version that employed inheritance, because we can’t use a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instance as an argument to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. As you’ve seen, sometimes that substitutability isn’t appropriate.</p>
<p class="TX">Inheritance isn’t the only form of polymorphism nor the only mechanism that exhibits type substitutability, but other approaches allow the compiler to inform us when we incorrectly substitute one type for another. Let’s take a look at some of them.</p>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h2 class="H1" id="sec18"><span id="h-167"/><span aria-label=" Page 233. " epub:type="pagebreak" id="pg_233" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Parametric Polymorphism with Generics</samp></h2>
<p class="TNI">C# generics offer <i>parametric polymorphism</i>, a form of polymorphism that allows us to write code once that works for multiple types by using generic type parameters instead of actual types. This approach provides a common form and purpose for all the types that can be substituted for those parameters.</p>
<p class="TX">This is most clearly demonstrated by the generic collection classes in the Standard Library, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; T &gt;</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a generic parameter type that can be substituted by <i>any</i> run-time type, including any types we define ourselves. For example, in <a href="#list7-19">Listing 7-19</a> we declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; T &gt;</samp> variables parameterized with different, unrelated types.</p>
<pre id="list7-19"><code>var colors = new List&lt;Color&gt;();&#13;
var names = new List&lt;string&gt;();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-19: Using a generic type</samp></p>
<p class="TX">Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> implementation’s behavior doesn’t change, a <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; Color&gt;</samp> is a distinct type from <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; string&gt;</samp>, and there’s no relationship between the two types. The generic <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; T &gt;</samp> code is written in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> generic parameter, and since <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; T &gt;</samp> doesn’t need to know anything about the structural or behavioral characteristics of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, it can be used with any type.</p>
<p class="TX">To put that another way, in the context of <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; T &gt;</samp>, any type can be substituted for the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter without implying any subtype relationship. We have no behavioral contract to take into account, because <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; T &gt;</samp> makes no assumptions about <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.</p>
<p class="TX">If we need to be more selective about the types that are suitable for a generic parameter type in our own generic code, or if we require the generic code to use methods and properties beyond those provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, we can constrain the parameter to allow only types having specific behavior.</p>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H2" id="sec19"><span id="h-168"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Constraints and Protocol Interfaces</samp></h3>
<p class="TNI">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> is the base class of every type, generics can use its methods via a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, but to access anything else, the compiler needs more information on what <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> can be. We provide that information through generic type constraints. One example is an interface constraint, which restricts <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> to a type that implements the specified interface, ensuring that all interface operations are legal for a variable of that generic type. Consider, for instance, the interface shown in <a href="#list7-20">Listing 7-20</a>.</p>
<pre id="list7-20"><code>public interface IParser&lt;T&gt;&#13;
{&#13;
    public T Parse(string input);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-20: A contract interface</samp></p>
<p class="TX"><span aria-label=" Page 234. " epub:type="pagebreak" id="pg_234" role="doc-pagebreak"/>The generic <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface defines a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method for turning a string value into an object instance of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter in <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> is unconstrained, so this interface can be implemented by any type. In <a href="#list7-21">Listing 7-21</a>, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface to constrain the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> generic class.</p>
<pre id="list7-21"><code>public sealed class DataAdapter&lt;<b>TParser</b>, TResult&gt;&#13;
    <b>where TParser : IParser&lt;TResult&gt;</b>&#13;
{&#13;
    public DataAdapter(TParser parser, IEnumerable&lt;string&gt; source)&#13;
        =&gt; (this.parser, items) = (parser, source);&#13;
    public IEnumerable&lt;TResult&gt; Read()&#13;
    {&#13;
        foreach (var item in items)&#13;
        {&#13;
            yield return <b>parser.Parse(item);</b>&#13;
        }&#13;
    }&#13;
    private readonly TParser parser;&#13;
    private readonly IEnumerable&lt;string&gt; items;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-21: Constraining a type for its API</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class has two generic parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter is constrained to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface in the <samp class="SANS_TheSansMonoCd_W5Regular_11">where</samp> clause following the type definition. <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> is constrained using the second generic parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>, which also corresponds to the return type from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method, meaning that <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> can be substituted by an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; TResult &gt;</samp>. The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter, so the argument passed must be an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp>, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> substituted by the same type as the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.</p>
<p class="TX">For simplicity, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> constructor takes a sequence of string values to represent the input values, but in a real application, <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> might be obtaining its data from a database or more elaborate source.</p>
<p class="TX">The interface type constraint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> generic type parameter enables us to call <samp class="SANS_TheSansMonoCd_W5Regular_11">parser.Parse</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method, which returns a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> elements. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">where</samp> constraint for <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method would fail to compile because <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> has no <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface in <a href="#list7-20">Listing 7-20</a> isn’t intended to be used as the type of a variable; rather, it’s a contract interface whose purpose is to describe the <i>protocol</i> for parsing a string into an object. We even use <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> as the type of a field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class rather than declaring the field as <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp>.</p>
<p class="TX">The presence of the constraint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> generic parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> means that we can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> only by providing an implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> protocol. The constraint guarantees that <span aria-label=" Page 235. " epub:type="pagebreak" id="pg_235" role="doc-pagebreak"/>whatever type is substituted for <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> at run time will have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method whose signature matches the operation defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface.</p>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the IParser&lt;T&gt; Protocol</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface is itself generic, allowing an implementing type to specify the return type from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class in <a href="#list7-22">Listing 7-22</a> implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; Color&gt;</samp> to convert a string to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> object. In this example, the input string represents each color component as a two-digit hexadecimal value, so the entire value is in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>.</p>
<pre id="list7-22"><code>public interface IParser&lt;T&gt;&#13;
{&#13;
    public T Parse(string input);&#13;
}&#13;
public sealed class ColorParser : <b>IParser&lt;Color&gt;</b>&#13;
{&#13;
    public static int FromHex(string part)&#13;
        =&gt; int.Parse(part, NumberStyles.HexNumber);&#13;
    <b>public Color Parse(string input)</b>&#13;
        =&gt; new(Red:   FromHex(input[0..2]),&#13;
               Green: FromHex(input[2..4]),&#13;
               Blue:  FromHex(input[4..6]));&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-22: Implementing a contract interface</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class uses the range operator syntax, introduced in C# v8.0, on the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> parameter to split the string into three parts of two characters each. A range like <samp class="SANS_TheSansMonoCd_W5Regular_11">[begin..end]</samp>, also called a <i>slice</i>, specifies a substring from the <samp class="SANS_TheSansMonoCd_W5Regular_11">begin</samp> index up to but not including the <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> index. Ranges can also be used with arrays to specify a subrange of the array.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>A</i> <span class="Roman">range</span> <i>is a half-open interval of indices and would more properly be written [begin..end), but C# syntax doesn’t allow nonmatching brackets or parentheses. Be careful not to confuse this syntax with the Enumerable.Range method, which takes the starting index and a count of items to include as its parameters.</i></p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parameterizing the DataAdapter Class</samp></h4>
<p class="TNI">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface, we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class, as shown in <a href="#list7-23">Listing 7-23</a>.</p>
<pre id="list7-23"><code>string messages = "FFA000 A0FF00 00F0F0"; …&#13;
var provider = new DataAdapter&lt;ColorParser, <b>Color</b>&gt;&#13;
                        (new ColorParser(), messages.Split(' '));&#13;
foreach(Color color in provider.Read())<span aria-label=" Page 236. " epub:type="pagebreak" id="pg_236" role="doc-pagebreak"/>&#13;
{&#13;
    <var>--snip--</var>&#13;
    // Do something with a color&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-23: Using the generic type</samp></p>
<p class="TX">While the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class itself is written in a polymorphic way (inasmuch as it works on any type implementing the required <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> protocol), using it requires us to explicitly indicate the concrete type we’re substituting for both the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter type to be returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method.</p>
<p class="TX">This prevents us from accidentally using <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> along with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class like this:</p>
<pre><code>var other = new DataAdapter&lt;ColorParser, <b>TranslucentColor</b>&gt;&#13;
                    (new ColorParser(), messages.Split(' '));</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class is specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> types because it implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; Color&gt;</samp> interface. The compiler will catch such transgressions and report an error:</p>
<pre><code>[CS0311] The type 'ColorParser' cannot be used as type parameter 'TParser' in the generic&#13;
type or method 'DataAdapter&lt;TParser, T&gt;'. There is no implicit reference conversion from&#13;
'ColorParser' to 'IParser&lt;TranslucentColor&gt;'.</code></pre>
<p class="TX">However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> generic parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> is already implied by the concrete type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> implementation we provide, as it must be the same type that’s returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Parse</samp>. The type constraint we used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> generic parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> in <a href="#list7-21">Listing 7-21</a> makes this relationship explicit:</p>
<pre><code>public sealed class DataAdapter&lt;TParser, TResult&gt;&#13;
    where TParser : IParser&lt;TResult&gt;&#13;
<var>--snip--</var></code></pre>
<p class="TX">Since we’ve gone to the trouble of ensuring that the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class can work with any <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> implementation, having to specify which implementation we mean seems superfluous. Instead, we can have the compiler deduce the correct type for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter based on the actual type we use.</p>
</section>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h3 class="H2" id="sec22"><span id="h-169"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Method Parameters and Type Deduction</samp></h3>
<p class="TNI">Although the compiler doesn’t infer the actual type for any parameters of a generic class, it may do so for a generic method if a generic parameter type is used in the method’s formal parameters. Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> type parameter is used only by the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter.Read</samp> method, we can move it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class and add it instead to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method, making <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> a generic method, as shown in <a href="#list7-24">Listing 7-24</a>.</p>
<pre id="list7-24"><code><span aria-label=" Page 237. " epub:type="pagebreak" id="pg_237" role="doc-pagebreak"/>public sealed class DataAdapter&lt;TResult&gt;&#13;
{&#13;
    public DataAdapter(IEnumerable&lt;string&gt; source)&#13;
        =&gt; items = source;&#13;
    <b>public IEnumerable&lt;TResult&gt;</b> <b>Read&lt;TParser&gt;(TParser parser)</b>&#13;
        <b>where TParser : IParser&lt;TResult&gt;</b>&#13;
    {&#13;
        foreach (var item in items)&#13;
        {&#13;
            yield return parser.Parse(item);&#13;
        }&#13;
    }&#13;
    private readonly IEnumerable&lt;string&gt; items;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-24: Defining DataAdapter.Read as a generic method</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> no longer needs a field to store a <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> object since it’s passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method. The generic method still requires the interface constraint so that we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method via the <samp class="SANS_TheSansMonoCd_W5Regular_11">parser</samp> variable, but we don’t need to specify the type of the parser argument when passing it; the compiler infers the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> based on the argument we pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>, as shown in <a href="#list7-25">Listing 7-25</a>.</p>
<pre id="list7-25"><code>var provider = new DataAdapter&lt;Color&gt;(messages);&#13;
foreach (Color color in provider.Read(new ColorParser()))&#13;
{&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-25: Parameter type inference</samp></p>
<p class="TX">We mention the <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> type just once, when we create an instance of it to pass to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method. Compare this with <a href="#list7-23">Listing 7-23</a>, where we not only required an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> but also needed to specify its type for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>. By taking advantage of the type inference afforded by a generic method, we avoid the redundant code.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h3 class="H2" id="sec23"><span id="h-170"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parameterized Types</samp></h3>
<p class="TNI">We still need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> in <a href="#list7-25">Listing 7-25</a>, even though <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> is used only by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method. The compiler can only infer the real type of a generic parameter from the arguments we pass to a method, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> isn’t used as the type for any parameter in <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>. If a method has generic parameters, they must all be either explicitly specified or deduced from the arguments; the compiler won’t partially deduce the types just from available arguments.</p>
<p class="TX">However, this is a benefit of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class, because it ensures that the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>. <span aria-label=" Page 238. " epub:type="pagebreak" id="pg_238" role="doc-pagebreak"/>If we want a different type to stand in for <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>, we need a different parser implementation. In <a href="#list7-26">Listing 7-26</a>, we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> interface in a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> type and create a <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> for the new type.</p>
<pre id="list7-26"><code>public sealed class <b>TranslucentColorParser : IParser&lt;TranslucentColor&gt;</b>&#13;
{&#13;
    <b>public TranslucentColor Parse(string input)</b>&#13;
        =&gt; new(Color: color.Parse(input[0..6]),&#13;
              Alpha: ColorParser.FromHex(input[6..8]));&#13;
    private readonly ColorParser color = new();&#13;
}&#13;
<var>--snip--</var>&#13;
var provider = new DataAdapter&lt;TranslucentColor&gt;(messages);&#13;
var colors = provider.Read(new TranslucentColorParser()).ToList();</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-26: Parameterizing DataAdapter with a different type</samp></p>
<p class="TX">We specify <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp> class, and we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> as the type for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp> implementation uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> object to parse the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> portion of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> as a convenience, but otherwise it’s an entirely new type. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter&lt; TranslucentColor&gt;</samp> type is unrelated to <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter&lt; Color&gt;</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class is polymorphic according to the type we provide as an argument for its <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter because that type affects what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method is itself polymorphic, as it has its own generic parameter. We need to write the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method only once, and it works for any type that implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser&lt; T &gt;</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> type of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.</p>
<p class="TX">We can think of a generic method as representing multiple method overloads, each with different parameter types but all having an identical implementation. Even without generics, overloaded methods represent their own kind of polymorphism, known as <i>ad hoc polymorphism</i>.</p>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h2 class="H1" id="sec24"><span id="h-171"/><samp class="SANS_Futura_Std_Bold_B_11">Ad Hoc Polymorphism with Overloading</samp></h2>
<p class="TNI">Ad hoc polymorphism, or <i>method overloading</i>, is how we define a family of operations that have the same name but differ in the type or number of their parameters. The compiler selects the correct method overload based on the method name and the arguments we use to call it. Each method can have a different implementation, so the method <i>name</i> is polymorphic with respect to its parameters.</p>
<p class="TX">You’ve seen a few examples of overloading instance methods in this and other chapters, where we’ve overridden the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and then overloaded it with a type-safe implementation. The compiler will select the <span aria-label=" Page 239. " epub:type="pagebreak" id="pg_239" role="doc-pagebreak"/>type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> if the static type of the argument matches the implementing type rather than being an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or another type. In a record struct, the compiler provides implementations for both methods, although we can provide our own type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> if we wish. <a href="#list7-27">Listing 7-27</a> shows how using different arguments changes which method is called when the variables being compared are value types.</p>
<pre id="list7-27"><code>public readonly record struct Color(int Red, int Green, int Blue);&#13;
var plum = new Color(0xDD, 0xA0, 0xDD);&#13;
var other = new Color(0xDD, 0xA0, 0xDD);&#13;
Assert.That(plum.Equals(<b>null</b>), Is.False);&#13;
Assert.That(plum.Equals(<b>other</b>), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-27: Selecting method overloads</samp></p>
<p class="TX">The first assertion, which compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method override with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter because <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> is a reference type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> will automatically convert to a reference parameter. In the second assertion, the method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as its parameter is a better match for the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> argument because the types match exactly, so the type-specific overload is called. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> were a record instead of a record struct, both assertions would directly invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp> overload, since in that case <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> would be a reference type but a more specific one than <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, making it a better conversion target for overload resolution when the argument is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="TX">When we call an overloaded instance method, the compiler identifies the candidate methods by using the static type of the variable used to invoke the method. The candidate methods may include extension methods with the same name if they’re in scope where the method is called. It’s always the invoking variable that determines how the list of possible overloads is selected, and the arguments passed determine the specific overload from that candidate list. In <a href="#list7-28">Listing 7-28</a>, we change the static type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> variable to be <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> before calling its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.</p>
<pre id="list7-28"><code><b>object plum</b> = new Color(0xDD, 0xA0, 0xDD);&#13;
Color other = new Color(0xDD, 0xA0, 0xDD);&#13;
Assert.That(plum.Equals(other), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-28: Argument type versus invoking type</samp></p>
<p class="TX">The candidates for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> are selected from the methods defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> because that’s the compile-time type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> variable. We have only one such method, which takes a parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>, so that’s automatically a match, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> argument is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> is still a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that has an overloaded <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter. The same would be true if <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> were a reference type: the type-specific overload isn’t even considered during overload <span aria-label=" Page 240. " epub:type="pagebreak" id="pg_240" role="doc-pagebreak"/>resolution because it’s not a member of the type of the variable used to call the method.</p>
<p class="TX">Static methods can be overloaded too, although the candidate overloads are identified from the type name used by the caller. In either case, from this list of candidates, called a <i>method group</i>, the compiler chooses the best match according to the arguments being passed.</p>
<p class="TX">If no match is found—that is, the arguments aren’t implicitly convertible to any of the parameter types—or there are multiple equally good candidates with no single best match, our program fails to compile.</p>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H2" id="sec25"><span id="h-172"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symbolic Polymorphism with Overloaded Operators</samp></h3>
<p class="TNI">Overloading can be especially powerful in conjunction with custom operators. It’s common for value types to overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to correspond with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. Not only is this more compact, but it also looks more natural to compare values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> than to compare them by calling a method.</p>
<p class="TX">We have to write our own operator implementations for structs, but the compiler provides <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for records and record structs, making it convenient to compare two variables of the same type like this:</p>
<pre><code>var plum = new Color(0xDD, 0xA0, 0xDD);&#13;
var pink = new Color(0xFF, 0xCC, 0xCC);&#13;
Assert.That(plum != pink, Is.True);</code></pre>
<p class="TX">We’re not permitted to alter the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> synthesized by the compiler for records and record structs, but we can add overloads of them to accept different types, just as we can with other methods. For instance, in <a href="#list7-29">Listing 7-29</a>, we overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to permit comparisons between a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>
<pre id="list7-29"><code>public static bool operator==(Color left, int right)&#13;
    =&gt; left.Equals(new (right));&#13;
public static bool operator==(int left, Color right)&#13;
    =&gt; right.Equals(new (left));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-29: Overloading operators</samp></p>
<p class="TX">We need to add a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for each overload (not shown here). These overloads are a convenience for users, who don’t need to explicitly construct <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances in order to compare them with their raw <samp class="SANS_TheSansMonoCd_W5Regular_11">RGB</samp> value and who can compare values like this:</p>
<pre><code>var plum = new Color(Red: 0xDD, Green: 0xA0, Blue: 0xDD);&#13;
Assert.That(plum == 0xDDA0DD, Is.True);&#13;
Assert.That(0xDDA0DD == plum, Is.True);</code></pre>
<p class="TX"><span aria-label=" Page 241. " epub:type="pagebreak" id="pg_241" role="doc-pagebreak"/>Overloading operators isn’t essentially different from overloading other methods, but rather than using named methods, we’re overloading <i>symbols</i> to behave in a polymorphic way with our types. A good example of symbolic polymorphism is embodied in the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class, which defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> symbol to mean concatenation rather than addition. This is a widely accepted convention familiar to most programmers.</p>
<p class="TX">We should be cautious of introducing our own operations that don’t follow the usual rules. Overloading methods, and especially operators, requires careful thought and a hefty dose of what we might call “good taste.” Families of methods overloaded for different types give the impression of type substitutability by giving one common name to an operation that may be implemented differently for each type.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class doesn’t, for example, allow us to add a number with a string, for the simple reason that the type of the result may be misinterpreted: should <samp class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> be the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp>? The designers of the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class decided to disallow either use to avoid any potential confusion.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h3 class="H2" id="sec26"><span id="h-173"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Delegates for Polymorphism</samp></h3>
<p class="TNI">A <i>delegate</i> is a type that represents a method with a specific signature—the type and number of parameters—and a delegate object can be constructed from different methods as long as the signature matches the delegate type. Delegates are a central feature of the LINQ libraries; for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method takes a delegate parameter to represent the method for transforming one element of a sequence into a different type. We most commonly see lambdas being used as the arguments for methods with delegate type parameters, as shown in <a href="#list7-30">Listing 7-30</a>.</p>
<pre id="list7-30"><code>var colors = new List&lt;Color&gt;&#13;
    {&#13;
        <var>--snip--</var>&#13;
    };&#13;
var formatted = colors.Select(&#13;
    color =&gt; $"{color.Red:X2}{color.Green:X2}{color.Blue:X2}");</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-30: Passing a lambda for a delegate parameter</samp></p>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> is an extension method for <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable&lt; T &gt;</samp>, and here we call it via the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> variable, passing a lambda to represent a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter, since that’s the element type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> sequence. The lambda is invoked for each element in the sequence and returns a hexadecimal representation of the value as a string formatted to <samp class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>—the reverse operation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method defined in <a href="#list7-22">Listing 7-22</a>.</p>
<p class="TX">Inline lambdas like the one in <a href="#list7-30">Listing 7-30</a> are convenient but generally lack the flexibility offered by method overloads. For example, if we change the element type of <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> to be <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, our code still compiles, and the lambda implementation will continue to work with the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> type defined in <a href="#list7-18">Listing 7-18</a>, but the result won’t have the extra 2 bytes for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property. We have to write a new lambda for <span aria-label=" Page 242. " epub:type="pagebreak" id="pg_242" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, and if we need to support both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> elements, we have to handle them separately.</p>
<p class="TX">Overloaded methods are a perfect way to capture the common purpose we need while simultaneously enabling us to encapsulate the different implementations required. Consider the two static methods in <a href="#list7-31">Listing 7-31</a>.</p>
<pre id="list7-31"><code>public static class Formatter&#13;
{&#13;
    public static string Format(Color color)&#13;
        =&gt; $"{color.Red:X2}{color.Green:X2}{color.Blue:X2}";&#13;
    public static string Format(TranslucentColor color)&#13;
        =&gt; $"{<b>Format(color.Color)</b>}{color.Alpha:X2}";&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-31: Overloaded methods for different types</samp></p>
<p class="TX">Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp> method’s implementation calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp> overload—something we couldn’t do with separate anonymous lambda expressions.</p>
<p class="TX">Rather than passing a lambda as the argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>, we can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format</samp> method group, as shown in <a href="#list7-32">Listing 7-32</a>.</p>
<pre id="list7-32"><code>var colors = new List&lt;TranslucentColor&gt;&#13;
{&#13;
    <var>--snip--</var>&#13;
};&#13;
var formatted = colors.Select(<b>Formatter.Format</b>);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-32: A method group as an argument</samp></p>
<p class="TX">Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp> is the common name for two method overloads and represents a method group. The compiler selects the correct overload in the group based on the element type of the sequence used to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>. The delegate parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> is a generic delegate—that is, one that has its own generic type parameters. Like generic methods, the compiler will infer the actual types based on the arguments passed to the delegate.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp> method group is polymorphic according to the arguments that are passed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method internally. Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp> method from <a href="#list7-31">Listing 7-31</a> is called because the element type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> sequence is <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. If we changed the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> variable to be a <samp class="SANS_TheSansMonoCd_W5Regular_11">List&lt; Color&gt;</samp> instead, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method would call <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp>, but without us needing to change the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> expression in any way.</p>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h2 class="H1" id="sec27"><span id="h-174"/><samp class="SANS_Futura_Std_Bold_B_11">Coercion Polymorphism Using Conversions</samp></h2>
<p class="TNI">As you’ve seen, inheritance allows us to use a reference to an instance of one type when a different type is expected, as long as the first type inherits <span aria-label=" Page 243. " epub:type="pagebreak" id="pg_243" role="doc-pagebreak"/>from the second type. A derived class is syntactically substitutable for its base class because there’s a natural implicit conversion from a specific type to any of its parent types.</p>
<p class="TX">We can implement our own type conversions to mimic substitutability between two otherwise unrelated types. Casting—or <i>coercing</i>—a variable to a different type can be convenient, whether via implicit or explicit conversions, but doing so may mask problems beneath the surface. However, applied carefully, conversions between unrelated types can be an effective and concise way to express a design.</p>
<p class="TX">To demonstrate some of the problems with implicit conversions that we haven’t yet explored, <a href="#list7-33">Listing 7-33</a> implements an implicit conversion operator in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> to convert an instance to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type.</p>
<pre id="list7-33"><code>public readonly record struct TranslucentColor(Color Color, int Alpha)&#13;
{&#13;
    <var>--snip--</var>&#13;
    public static implicit operator Color(TranslucentColor color)&#13;
        =&gt; color.Color;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-33: Implicit conversion operator</samp></p>
<p class="TX">The conversion operator in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> is an <i>outward</i> conversion: we’re converting from an instance of the implementing type to something else. It will allow us to call a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value when we have a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> at hand, as we do when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp> method in <a href="#list7-34">Listing 7-34</a>.</p>
<pre id="list7-34"><code>public bool EqualViaColor(Color left, Color right)&#13;
    =&gt; left.Equals(right);&#13;
var red = new TranslucentColor(0xFF, 0, 0, 0);&#13;
var blue = new TranslucentColor(0, 0, 0xFF, 0);&#13;
<b>Assert.That(EqualViaColor(red, blue), Is.False);</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-34: Implicit conversions in action</samp></p>
<p class="TX">Owing to the implicit conversion operator, the <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">blue</samp> variables are converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances when we pass them as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp> method. The conversion happens invisibly because the conversion operator is defined as <samp class="SANS_TheSansMonoCd_W5Regular_11">implicit</samp>.</p>
<p class="TX">We could achieve the same effect by defining an inward conversion operator on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> parameter. The difference is merely about where we choose to define the operator. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> already depends on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> otherwise has no knowledge of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, the outward conversion defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> makes better sense here.</p>
<p class="TX">However, we must be careful with all conversions, especially implicit ones. As you saw in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, implicit conversions may hide complexity <span aria-label=" Page 244. " epub:type="pagebreak" id="pg_244" role="doc-pagebreak"/>and can even lead to undesired behavior. A user-defined coercion is not quite the same as the implicit reference conversion from a derived type to its base type.</p>
<section aria-labelledby="sec28" epub:type="division">
<h3 class="H2" id="sec28"><span id="h-175"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Widening vs. Narrowing Conversions</samp></h3>
<p class="TNI">When <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we could pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> reference to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, but it was still a reference to the same instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, and only a copy of the reference would be made. In <a href="#list7-33">Listing 7-33</a>, <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are record structs and therefore value types. When we invoke the conversion operator of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, we’re simply creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance, so the copy has lost some of the information specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>—namely, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property.</p>
<p class="TX">A conversion from a derived class reference to a base class reference is a <i>widening</i> conversion. We can refer to a specific instance by using a more general (base) type, but no loss of information occurs. We’re still able to explicitly cast the base class reference back to the original derived instance, although that’s a relatively expensive run-time operation. Our implicit conversion from a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> struct to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> via our own operator method is <i>narrowing</i>: neither type is really more specific or general than the other, and they’re independent values, but the act of conversion loses information.</p>
<p class="TX">While we’ve replicated the behavior of converting from a derived class to a base class, it doesn’t give us the same flexibility. The converted value really <i>is</i> just a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and we need other means of capturing the extra properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> if we need to reinstate them.</p>
<p class="TX">Conversions aren’t appropriate for trying to replicate the characteristics of inheritance, but they can be useful for other scenarios.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h3 class="H2" id="sec29"><span id="h-176"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">For Representation</samp></h3>
<p class="TNI">Conversions between unrelated types make more sense when the types have a common meaning with different representation. For instance, we might need to use an external API that uses the common <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> representation of the hexadecimal RGB value of colors. Changing a value’s representation is usually better implemented as an explicit rather than implicit conversion, as shown in <a href="#list7-35">Listing 7-35</a>. However, any conversions—whether explicit or implicit—require careful consideration of alternate approaches.</p>
<pre id="list7-35"><code>public readonly struct Color&#13;
{&#13;
    <var>--snip--</var>&#13;
    public static explicit operator int(Color color)&#13;
        =&gt; color.Red &lt;&lt; 16 | color.Green &lt;&lt; 8 | color.Blue;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-35: Converting to a different type representation</samp></p>
<p class="TX"><span aria-label=" Page 245. " epub:type="pagebreak" id="pg_245" role="doc-pagebreak"/>In <a href="#list7-36">Listing 7-36</a>, we test the explicit conversion operator’s implementation by casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> value to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in order to pass it as an argument for a method taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameter.</p>
<pre id="list7-36"><code>int Converted(int color)&#13;
{&#13;
    return color;&#13;
}&#13;
var plum = new Color(0xDD, 0xA0, 0xDD);&#13;
Assert.That(Converted(<b>(int)plum</b>), Is.EqualTo(0xDDA0DD));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-36: Testing an explicit conversion</samp></p>
<p class="TX">This local <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp> function takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameter and, for the purposes of the test, simply returns its parameter value. Since the conversion operator is explicit, we must cast the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp> method; the compiler will complain if we try to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value directly as an argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp>. The compiler will also catch any unintentionally inappropriate expressions like this:</p>
<pre><code>var blue = new Color(0, 0, 0xFF);&#13;
var green = new Color(0, 0xFF, 0);&#13;
Assert.That(blue &lt; green, Is.True);</code></pre>
<p class="TX">If we had made the conversion operator implicit in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, this code would compile but would compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values, probably with unexpected results.</p>
<p class="TX">The cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in <a href="#list7-36">Listing 7-36</a>, while explicit and obvious in the code, doesn’t say much about the intention behind the conversion, which is implied to some extent by the use. We might consider replacing an explicit outward conversion like this with a method or property that more definitively describes the intent of the conversion, perhaps by calling it <samp class="SANS_TheSansMonoCd_W5Regular_11">ToWebColor</samp>.</p>
<p class="TX">Naming the conversion allows us to better express what we mean and why, making the code more self-documenting without being overly intrusive or syntax-heavy compared to an explicit cast. One frequently overlooked consequence of using a named property instead of a cast is that the property name is easier to search for, should we need to find everywhere it’s used.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h3 class="H2" id="sec30"><span id="h-177"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">For Purpose</samp></h3>
<p class="TNI">Conversion operators, even implicit conversions, aren’t exclusively a bad choice. Conversions are commonly used to allow a value to be represented by unrelated types that support different operations, although the value itself has a common representation. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is an immutable value type, but we might want to build up its value incrementally. A <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> has multiple properties, and sometimes setting them individually might be more convenient than setting them all at once in a constructor.</p>
<p class="TX"><span aria-label=" Page 246. " epub:type="pagebreak" id="pg_246" role="doc-pagebreak"/>Rather than compromising the immutable nature of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for its properties, we introduce a new companion type that looks very much like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, except that it allows its properties to be changed. When the values are in their final state, we can then materialize an instance of the mutable type into an immutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. Key to this is that we can easily convert from the companion type to the target value type. <a href="#list7-37">Listing 7-37</a> shows such a <i>mutable companion</i> type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that allows an implicit conversion to the immutable target value.</p>
<pre id="list7-37"><code>public class ColorBuilder&#13;
{&#13;
    public int Red {get; set;}&#13;
    public int Green {get; set;}&#13;
    public int Blue {get; set;}&#13;
    public static implicit operator Color(ColorBuilder color)&#13;
        =&gt; new Color(color.Red, color.Green, color.Blue);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-37: A mutable companion for Color</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> type isn’t itself a value type; its sole purpose is to provide a kind of factory for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.</p>
<p class="TX">Applications of the <i>Mutable Companion</i> pattern are fairly common, and we see it in the Standard Library with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> type is immutable, and when we need to build up a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variable from several parts, using its mutable companion, <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>, is efficient. When we’ve finished “building” the string, we turn it into its <i>immutable</i> state.</p>
<p class="TX">Unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>, we must call the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> method of <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> to turn it into a string, but an implicit conversion can be used to good effect here. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> is implicitly convertible to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we can call a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> value, as we see in <a href="#list7-38">Listing 7-38</a>, where we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">RelativeLuminance</samp> method with both a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value.</p>
<pre id="list7-38"><code>public static double <b>RelativeLuminance(Color color)</b>&#13;
    =&gt; 0.2126 * color.Red + 0.7152 * color.Green + 0.0722 * color.Blue;&#13;
var background = new Color(0, 0, 0);&#13;
var builder = new ColorBuilder();&#13;
builder.Red = 0xFF;&#13;
builder.Green = 0xFF;&#13;
builder.Blue = 0;&#13;
if(<b>RelativeLuminance(builder)</b> <b>&lt;</b> <b>RelativeLuminance(background)</b>)&#13;
    background = builder;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-38: Converting a companion type</samp></p>
<p class="TX">The implicit conversion operator we defined for <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> in <a href="#list7-37">Listing 7-37</a> permits us to pass the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">builder</samp> variable as an argument <span aria-label=" Page 247. " epub:type="pagebreak" id="pg_247" role="doc-pagebreak"/>to any method that expects a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. Any code written for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances won’t be expecting to be able to use the mutating properties of the companion class, so the conversion is safe and convenient.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> can be substituted for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> courtesy of the implicit conversion. No information is lost because the two types share a common representation; however, a narrowing of the interface occurs, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> target type has no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for its properties.</p>
<p class="TX">Conversions represent a form of polymorphism, as we explicitly allow a variable of one type to be coerced to a variable of a different but unrelated type. Like parametric polymorphism using generics, and ad hoc polymorphism with overloading, coercion polymorphism is a compile-time activity, in contrast to the dynamic, run-time characteristic of inclusion polymorphism using inheritance. Inclusion polymorphism is a powerful tool, but because the type relationships are resolved at run time, the compiler can’t identify many of the errors that may occur. When we improperly use generics, overloading, or coercions, we can rely on the compiler to tell us about most errors in our code.</p>
</section>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h2 class="H1" id="sec31"><span id="h-178"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP"><i>Trying to outsmart a compiler defeats much of the purpose of using one.</i></p>
<footer class="EPS">—Brian Kernighan and P.J. Plauger, <i>The Elements of Programming Style</i></footer></blockquote>
<p class="BodyContinued">Asking how to make value types behave correctly when used polymorphically is the wrong question: polymorphism itself takes many forms! Combining value types and inheritance can cause hard-to-diagnose errors, but inheritance is only one kind of polymorphism. The dynamic nature of inclusion polymorphism with virtual dispatch brings an expectation of type substitutability and doesn’t sit well with value-based equality.</p>
<p class="TX">Inheriting one type from another imposes a responsibility on the derived type to respect the contract established by the base class. Failing to uphold that contract can lead to undesirable behavior. One type is genuinely substitutable for another only if they share the same behavioral contract, which is something the compiler can’t enforce. It’s up to us, the programmers, to judge whether inheritance is appropriate. In the case of structs, it’s not even permitted, freeing us from that particular responsibility.</p>
<p class="TX">With records, we need to pay just as much attention to the base class contract as we do with classes. Although the compiler carefully crafts its implementation of equality to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> behaves correctly for records, it doesn’t do the same for any of our own virtual and overridden methods in those types.</p>
<p class="TX">Records aren’t necessarily appropriate for everything, and as noted earlier, making <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> “just work” for values using inheritance is an incomplete solution to the wrong problem. In particular, records are reference types and thus subject to garbage collection. The implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> are all virtual, as is the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property, and they all carry <span aria-label=" Page 248. " epub:type="pagebreak" id="pg_248" role="doc-pagebreak"/>an associated cost. Records are a very compact way of declaring immutable value-like types, but programming is more than the amount of typing required of us.</p>
<p class="TX">Value types do combine much better with the other ways of representing polymorphic behavior: coercion, overloading, and generic. These three forms of polymorphism are static in nature; that is, they are resolved by the compiler. Although type parameters in generic classes and methods are resolved at run time, we must still provide compile-time guarantees about which operations those parameters support.</p>
<p class="TX">It can be tempting to use inheritance in order to reuse code from a base class. This is a bad idea because inheriting a class implies that the base class can be substituted by the inheriting class, but it can be difficult to ensure that the base class’s behavioral characteristics are properly met. We can still reuse another type’s implementation by containing an instance of the type and using the contained instance privately to implement our new type.</p>
<p class="TX">Inheriting from concrete types—that is, nonabstract classes—in general presents us with the challenges of respecting the contracts established by those base classes. When we override an abstract method or implement an interface, we don’t suffer from those issues because there is no base class implementation to respect. In those cases, we’re inheriting only the interface contract, which is much easier to uphold.</p>
<p class="TX">The moral of the story is that if we always implement true interfaces or inherit from fully abstract classes, the problems we’ve encountered in this chapter will never cause us difficulties. Correspondingly, we should seal any class or record that models a value type and ensure that it has no user-defined base types. We can still write code that behaves polymorphically with the value types we use and create, but we should express it differently by employing generics, overloading methods, and permitting type conversions.</p>
</section>
</section>
</div></body></html>