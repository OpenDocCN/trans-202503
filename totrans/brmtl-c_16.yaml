- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buffered File I/O
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first part of this book, we struggled to get even the simplest output
    to the console. But for this part of the book, we have an operating system, and
    that makes dealing with output and input a lot easier. That’s because the operating
    system hides a great deal of the complexity from you: you just write `"Hello World\n"`,
    and the operating system sends the data to the appropriate place.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll learn about C’s I/O system, which includes not only the
    `printf` function but also functions to read and write disk files in a manner
    that is both efficient and very flexible.
  prefs: []
  type: TYPE_NORMAL
- en: The printf Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already used the `printf` function a couple of times for simple output.
    The basic format of the function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The format string tells `printf` what to print. Any character other than percent
    (`%`) is printed. The `%` character starts a field specification, which tells
    `printf` to go to the argument list and print the next argument according to the
    field specification that follows. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%d` field specification can be modified with a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, `%3d` tells `printf` to use at least three characters to
    print the number. The `%-3d` field tells `printf` to print the number with at
    least three characters and to left-justify it.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve discussed only the `d` conversion character, which is used to covert
    an integer argument to text for printing. [Table 14-1](#table14-1) lists the major
    conversion characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-1: Major C Conversion Characters'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Conversion character** | **Argument type** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Integer | The `char` and `short int` types are promoted to `int` when
    passed as parameters, so this format also works for those three types. |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | Character | Because of promotion, this conversion character actually
    takes an integer argument and prints it as a character. |'
  prefs: []
  type: TYPE_TB
- en: '| `%o` | Integer | Prints in octal. |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | Integer | Prints in hexadecimal. |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Double | Works for both `float` and `double` types because all `float`
    parameters are promoted to `double` when passed as an argument. |'
  prefs: []
  type: TYPE_TB
- en: '| `%l` | Long integer | The `long int` type requires its own conversion because
    the `int` type is not automatically promoted to `long int`. |'
  prefs: []
  type: TYPE_TB
- en: Writing the ASCII Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s write a short program to create a table containing the printable characters
    with their hex and octal values, which will provide a practical demonstration
    of the formatting strings. This program ([Listing 14-1](#listing14-1)) gives us
    a chance to express the same data four different ways and to try out different
    formats inside a `printf` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**ascii.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: A program to create an ASCII table'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `%c` format string prints out the character as a character. Next,
    we print out the character as a three-digit decimal number (`%3d`). To be precise,
    the type of the argument is a character, and it’s promoted to an integer. The
    number will be three characters long because of the `3` in the argument specification.
    After that, we print in hexadecimal using the `%02x` format. The zero (`0`) tells
    `printf` to pad the result with zeros if needed to match the desired width (the
    width is, of course, `2`). Finally, we print in octal with the `%03o` string.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-2](#listing14-2) shows the output of this program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-2: The output of [Listing 14-1](#listing14-1) (*ascii.c*)'
  prefs: []
  type: TYPE_NORMAL
- en: The `printf` function is the workhorse of the C I/O system. It helps us get
    lots of different types of data printed to the console. But that’s not the only
    place we can write, as we’ll see in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to Predefined Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a program starts, the operating system opens three predefined files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stdin` Standard in, the normal input of the program'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stdout` Standard out, for normal program output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stderr` Standard error, for error output'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default these files are connected to the console, but your command line interpreter
    can connect them to disk files, pipes, or other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fprintf` function sends data to a given file. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `printf` function is merely a convenience function that replaces `fprintf(stdout,
    ...)`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functions that read data are designed to be simple, but unfortunately,
    they aren’t. The `printf` function has a counterpart called `scanf` that reads
    data. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, note the ampersands (`&`) in front of the arguments, which are used because
    `scanf` needs to modify the arguments; therefore, the arguments must be passed
    by address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format string passed to `scanf` looks a lot like the one for `printf`,
    but there is one big problem with `scanf`: unless you are an extreme expert, you
    never know how it’s going to deal with whitespace. So, we don’t use it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we use the `fgets` function to get a single line from the input, and
    then we use `sscanf` to parse the resulting string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The general form of `fgets` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: where `result` is a pointer to the string that was just read (`buffer`), or
    `NULL` if we’ve reached the end of the file (EOF). The `buffer` is a character
    array where the line is to be placed, and `file` is a file handle indicating which
    file to read (`stdin` is the only file we know about at this point).
  prefs: []
  type: TYPE_NORMAL
- en: The `buffer` will always be null-terminated (`\0`), so at most `size``-1` characters
    will be put in `buffer`. (An entire line will be read, even if `buffer` is not
    large enough to contain it.)
  prefs: []
  type: TYPE_NORMAL
- en: The `sscanf` function is much like the `scanf` function, only the first argument
    is now a string. The rest of the arguments are the same. The `sscanf` function
    returns the number of items it converted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code assumes that everything works. Let’s rewrite it, and this
    time check for errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the first call to `fgets` returns `NULL`, something went wrong. We then print
    an error message to the predefined file for errors (`stderr`) and return an error
    code to the caller. Next, we perform an `sscanf`, which should find two integers.
    If it doesn’t, we again print an error message and return an error code.
  prefs: []
  type: TYPE_NORMAL
- en: The Evil gets Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fgets` function has a corresponding shorthand function to read data from
    `stdin`. It’s called `gets` and has this general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `gets` function reads in a line of data and puts it in the `buffer`, *whether
    or not the* `buffer` *can hold it.*
  prefs: []
  type: TYPE_NORMAL
- en: The current GCC compiler makes `gets` hard to use. First, *stdio.h* won’t define
    it unless you properly define a conditional compilation macro. When you compile
    the program, the compiler will warn you, and then when the program is linked,
    the linker will warn you.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-3](#listing14-3) shows what happens when you compile a program
    using `gets`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-3: Attempting to use `gets`'
  prefs: []
  type: TYPE_NORMAL
- en: From the volume of output, you can see how much trouble the GCC compiler goes
    to in order to persuade you not to use `gets`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken a look at a few things we shouldn’t use, let’s look at
    some things we should.
  prefs: []
  type: TYPE_NORMAL
- en: Opening Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The predefined files `stdin`, `stdout`, and `stdout` are file handles. The `fopen`
    function allows you to create file handles. [Listing 14-4](#listing14-4) shows
    a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: '**file.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-4: A file version of “Hello World”'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `FILE*` declaration 1 declares a new file handle. All file operations
    require a file handle. Next we have the `fopen` call 2, which has this general
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mode` can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r` Read only'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`w` Write only'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`r+` Read and write'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` Append (write but start at the end of file)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`b` Used in combination with the other modes for binary files (discussed in
    the next section)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the files open, we can read and write to them. Text can be
    written by `fprintf` and read by `fgets`. Next, let’s take a look at the other
    type of file: binary files.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we’ve limited ourselves to text files, but the C I/O system can handle
    binary files through the use of the `fread` and `fwrite` functions. The general
    form of the `fread` function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, `buffer` is a pointer to the data buffer in which the data will be placed.
    The `elementSize` is always `1` (see the following box for an explanation). The
    `size` is the size of the buffer, which is usually `sizeof(``buffer``)`, and `inFile`
    is the file to read.
  prefs: []
  type: TYPE_NORMAL
- en: The function returns the number of items read, which because `elementSize` is
    `1` is the number of bytes read. It returns `0` for the end of file and a negative
    number if there is an I/O error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fwrite` function has a similar structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Everything is the same, except the data is written instead of read.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll use `fread` and `fwrite` calls to copy a file. Since we don’t know how
    to pass arguments on the command line yet (see Chapter 15), the filenames are
    hardcoded to *infile.bin* and *outfile.bin*. [Listing 14-5](#listing14-5) contains
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**copy.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-5: Copying a file'
  prefs: []
  type: TYPE_NORMAL
- en: First, note the `fopen` call 1. We open the file using the `rb` mode, which
    tells the system we’re going to read the file (`r`) and that the file is binary
    (`b`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the `fread` call 2. The return value for this function
    is `ssize_t`, which is a standard type that’s big enough to hold the size of the
    largest object (structure, array, union) that can possibly exist. It also can
    hold `–1` to indicate an error condition.
  prefs: []
  type: TYPE_NORMAL
- en: If we’ve read all the data from the file, `fread` returns `0`. When that happens,
    we’re done, so we exit the main loop 3.
  prefs: []
  type: TYPE_NORMAL
- en: Now we come to the `fwrite` call 4, which returns a `size_t` value. This is
    an unsigned type that holds the size of the largest object you can put in a program,
    but because it’s unsigned, it cannot hold an error value. What happens when `fwrite`
    gets an error when writing something? It writes as much as it can and returns
    the number of bytes written, so it will never return an error code, just a short
    write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `fread` returns an `ssize_t` result and `fwrite` returns a `size_t`
    result. There are good reasons for this, but it means that if we check to see
    whether the number of bytes we tried to write is the same as the number we actually
    asked `fwrite` to write, we get a compiler warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To get rid of the warning, we need to insert a cast, thus telling C, “Yes,
    I know we are mixing signed and unsigned types, but we have to do it because of
    the stupid way `fread` and `fwrite` are defined”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also note that on the last read we probably won’t get a full 512 bytes. That’s
    why we are using `readSize` in the `fwrite` statement instead of `sizeof(``buffer``)`.
  prefs: []
  type: TYPE_NORMAL
- en: Buffering and Flushing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C I/O system uses *buffered I/O*, which means that when you do a `printf`
    or `fwrite`, the data may not be sent to the output device immediately. Instead,
    it will be stored in memory until the system has enough data to make things efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Data going to the console is *line buffered*, which means that if you print
    part of a line, it might not go out until the rest of the line is sent. Let’s
    see how this can get us into trouble with the program in [Listing 14-6](#listing14-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-6: Dividing by zero'
  prefs: []
  type: TYPE_NORMAL
- en: 'When running this program, you would expect to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But what you actually see is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Your first thought might be that `printf` did not execute, but it did. The data
    went into a buffer and was sitting in the buffer when the program aborted, giving
    a false indication that `printf` did not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we need to tell the I/O system “write the buffered data
    out now,” which is done with the `fflush` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Flushing out the data ensures that we can see it. On the other hand, we don’t
    want to flush after every write, as that would defeat the purpose of buffering,
    which is to make I/O more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, after we’re done with a file, we need to tell C that we’re finished
    with it. We do this using the `fclose` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: where `file` is the `FILE*` to close and `result` is `0` if it worked or nonzero
    if it didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the embedded world, I/O is difficult because you have to write code to deal
    directly with the device, and you need to write different code for every different
    type of device.
  prefs: []
  type: TYPE_NORMAL
- en: The C I/O system is designed to hide all those details from you. It also provides
    a lot of nice features, such as formatting, buffering, and device independence.
    The buffered I/O system works well for most general applications.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See what happens when you put too many or too few parameters in a `printf` statement.
    What happens when you put the wrong type (for example, `double` instead of `int`)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that asks the user for a temperature in Centigrade and converts
    it to Fahrenheit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that counts the number of words in a file. Be sure you document
    the definition of “word,” as some people’s idea of a word may be different from
    yours.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that compares two files line by line and writes out the lines
    that differ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
