<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>8 THE STATE MACHINE</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch8">
<span class="CN"><span aria-label=" Page 147. " epub:type="pagebreak" id="pg_147" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">THE STATE MACHINE</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">A <i>state machine</i> is a model for controlling a sequence of actions. In a state machine, a task is broken down into a series of stages, or <i>states</i>. The system flows through these states along prescribed routes, transitioning from one state to another based on inputs or other triggers. State machines are widely used to organize the operations in an FPGA, so understanding how they work is crucial to developing sophisticated FPGA designs.</p>
<p class="TX">Some common examples of state machines control behaviors in elevators, traffic lights, and vending machines. Each of these devices can only be in one unique state at any given time and can perform different actions as a result of inputs. In the case of an elevator, for example, the elevator car remains on its current floor until someone pushes a button to request a ride. The floor that the elevator is on is its state, and pushing a button is <span aria-label=" Page 148. " epub:type="pagebreak" id="pg_148" role="doc-pagebreak"/>the input that triggers a change in that state. In the case of a traffic light, the possible states are red, yellow, and green, and the light changes based on some kind of input—perhaps a timer or a motion sensor. Certain transitions are possible, such as going from red to green or from yellow to red, while other transitions, such as yellow to green, are not.</p>
<p class="TX">Within an FPGA, you might have several state machines performing different independent tasks, all running simultaneously. You might have one state machine that initializes an LPDDR memory, another that receives data from an external sensor, and a third for communicating with an external microcontroller, for example. And since an FPGA is a parallel device, these state machines will all be running in parallel, with each state machine coordinating its own complicated series of actions.</p>
<p class="TX">In this chapter, you’ll learn the basic concepts behind state machines and see how to design them with Verilog and VHDL. You’ll learn strategies for keeping your state machines clear and concise, which reduces the likelihood of bugs in your designs. Finally, you’ll gain hands-on experience with state machines by designing a Simon-style memory game for your development board.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-98"/><samp class="SANS_Futura_Std_Bold_B_11">States, Transitions, and Events</samp></h2>
<p class="TNI1">State machines revolve around three interrelated concepts: states, transitions, and events. A <i>state</i> describes the status of a system when it’s waiting to execute a transition. Going back to the elevator example, if a button is never pressed, the elevator will simply remain in its current state; that is, waiting on its current floor. A state machine can only ever be in one state at a time (an elevator can’t be on two floors at once), and there are only so many possible states that it can be in (we haven’t yet figured out how to build a building with an infinite number of floors). For this reason, state machines are also called <i>finite state machines (FSMs)</i>.</p>
<p class="TX">A <i>transition</i> is the action of moving from one state to another. For an elevator, that would include opening and closing the doors, running a motor to raise or lower the car, and so on. Transitions are usually caused by <i>events</i>, which can include inputs like a button press or a timer expiring. Transitions between states can also occur without an external event, which would be an internal transition. The same event might trigger a different transition, depending on the current state of the state machine. For example, pushing the 5 button will make an elevator go down if it’s on the tenth floor, or go up if it’s on the first floor. The elevator’s next state is influenced by both its current state and the input event.</p>
<p class="TX">Designing a state machine entails determining all the possible states, planning out the transitions between the states, and identifying the events that can trigger those transitions. The easiest way to do this is to draw a diagram. To demonstrate, let’s explore an example of a simple state machine, one that controls a coin-operated turnstile like you might use to enter a subway station. <a href="#fig8-1">Figure 8-1</a> shows a diagram of this state machine.</p>
<span aria-label=" Page 149. " epub:type="pagebreak" id="pg_149" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img50" id="fig8-1" src="../images/Figure8-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: A state machine for a turnstile</samp></p></figcaption>
</figure>
<p class="TX">In a state machine diagram, states are traditionally represented as labeled circles, transitions are represented as arrows between circles, and events are represented as text alongside the transitions they trigger. Our turnstile state machine has two possible states: Locked and Unlocked. The black dot beneath the Locked state indicates that Locked is the <i>initial state</i> of the machine. This is where the state machine will go when power is first applied, or if the user hits a reset button.</p>
<p class="TX">Let’s consider what happens once we’re in the Locked state. There are two possible events that can trigger a transition: pushing on the turnstile, or depositing a coin. A Push event causes a transition from Locked back to Locked, represented by the arrow on the left of the diagram. In this case, the state machine stays in the Locked state. It’s not until a user deposits a coin (the Coin event) that we transition to the Unlocked state. At this point, if the user pushes the turnstile, it will let them through, then transition back to the Locked state for the next user. Finally, notice that if a user deposits a coin into a system that’s already Unlocked, it transitions back into the Unlocked state.</p>
<p class="TX">It may seem trivial to define the behavior of a subway turnstile this way, but it’s good practice for getting to know how state machines are organized and represented. For systems that have a large sequence of states, events, and transitions, explicitly documenting the state machine is critical for generating the desired behavior. Even something as simple as a calculator can require a surprisingly complex state machine.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h-99"/><samp class="SANS_Futura_Std_Bold_B_11">Implementing a State Machine</samp></h2>
<p class="TNI1">Let’s look at how to implement our basic subway turnstile state machine in an FPGA using Verilog or VHDL. We’ll consider two common approaches: the first uses two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks, while the second uses just one. It’s important to understand both of these approaches to implementing a state machine, since they’re both widely used. However, as you’ll see, there are reasons to prefer the latter approach.</p>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Two always or process Blocks</samp></h3>
<p class="TNI1">Using two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks is a more traditional way of implementing a state machine. Historically, FPGA synthesis tools weren’t very good. They could make mistakes when trying to synthesize state machines. The two-block approach was devised to get around these limitations. One <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block controls the synchronous logic, using a register to keep track <span aria-label=" Page 150. " epub:type="pagebreak" id="pg_150" role="doc-pagebreak"/>of the current state. The other <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block controls the combinational logic; it looks for transition-triggering events and determines what the next state should be. <a href="#fig8-2">Figure 8-2</a> illustrates this arrangement.</p>
<figure class="IMG"><img alt="" class="img50" id="fig8-2" src="../images/Figure8-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: A block diagram of a state machine with two always or process blocks</samp></p></figcaption>
</figure>
<p class="TX">Notice that the next state logic in this diagram doesn’t have a clock as an input. It determines the next state immediately, based on the current state and any inputs (events). Only the current state register has a clock input, which it uses to register the output of the next state logic. In this way, it stores the current state of the machine.</p>
<p class="TX">Here’s how to implement the turnstile state machine using this two-block approach:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Turnstile_Example
 (input i_Reset,
  input i_Clk,
  input i_Coin,
  input i_Push,
  output o_Locked);
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> localparam LOCKED   = 1'b0;
  localparam UNLOCKED = 1'b1;
  reg r_Curr_State, r_Next_State;
  // Current state register
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> always @(posedge i_Clk or posedge i_Reset)
  begin
    if (i_Reset)
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> r_Curr_State &lt;= LOCKED;
    else
    <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Curr_State &lt;= r_Next_State;
  end
  // Next state determination
<span aria-label="annotation5" class="CodeAnnotationCode-1">❺</span> always @(r_Curr_State or i_Coin or i_Push)
  begin
     r_Next_State &lt;= r_Curr_State;
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> case (r_Curr_State)
       LOCKED:
         if (i_Coin)
         <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> r_Next_State &lt;= UNLOCKED;
       UNLOCKED:
         if (i_Push)
            r_Next_State &lt;= LOCKED;
       <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>
     endcase
  end
<span aria-label="annotation9" class="CodeAnnotationCode-1">❾</span> assign o_Locked = (r_Curr_State == LOCKED);
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity Turnstile_Example is
  port (
    i_Reset  : in std_logic;
    i_Clk    : in std_logic;
    i_Coin   : in std_logic;
    i_Push   : in std_logic;
    o_Locked : out std_logic);
end entity Turnstile_Example;
architecture RTL of Turnstile_Example is
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> type t_State is (LOCKED, UNLOCKED);
  signal r_Curr_State, r_Next_State : t_State;
begin
  -- Current state register
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> process (i_Clk, i_Reset) is
  begin
    if i_Reset = '1' then
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> r_Curr_State &lt;= LOCKED;
    elsif rising_edge(i_Clk) then
    <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Curr_State &lt;= r_Next_State;
    end if;
  end process;
  -- Next state determination
<span aria-label="annotation5" class="CodeAnnotationCode-1">❺</span> process (r_Curr_State, i_Coin, i_Push)
  begin
    r_Next_State &lt;= r_Curr_State;
 <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> case r_Curr_State is
      when LOCKED =&gt;
        if i_Coin = '1' then
        <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> r_Next_State &lt;= UNLOCKED;
        end if;
      when UNLOCKED =&gt;
        if i_Push = '1' then
          r_Next_State &lt;= LOCKED;
        end if;
     <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>
    end case;
  end process;
<span aria-label="annotation9" class="CodeAnnotationCode-1">❾</span> o_Locked &lt;= '1' when r_Curr_State = LOCKED else '0';
end RTL;</code></pre>
<p class="TX"><span aria-label=" Page 152. " epub:type="pagebreak" id="pg_152" role="doc-pagebreak"/>We create the states using enumeration <span aria-label="annotation1" class="CodeAnnotation">❶</span>, meaning each state name has an assigned number. In Verilog, you need to create the list of states manually. I like to use <samp class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp> to define each state, assigning them numbers in an incrementing order. In VHDL, you instead create a user-defined type for your state machine (<samp class="SANS_TheSansMonoCd_W5Regular_11">t_State</samp>). Then you list the states in order, and VHDL automatically assigns them numbers. If you’re familiar with C programming, the VHDL method is similar to how enumerations work in C.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>SystemVerilog supports automatic enumeration, but it doesn’t exist in regular Verilog, so we just number the states manually in the Verilog code.</i></p>
<p class="TX">The first <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block <span aria-label="annotation2" class="CodeAnnotation">❷</span>, the current state register, is driven by a clock. It keeps track of the current state by assigning <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp> on every rising clock edge <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Notice that this block also has the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> signal in its sensitivity list, and that this signal is checked in the block. It’s important to include a way to get the state machine to its initial condition, and we use <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> for that. The block’s <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statement (Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">if…elsif</samp> statement (VHDL) checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> is high <i>before</i> checking to see if we have a rising edge of the clock. This means we’re using an <i>asynchronous reset</i>; the reset can occur at any time, not necessarily on the rising edge of the clock. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> is high, we set the current state to <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. This is in keeping with the initial state indication in <a href="#fig8-1">Figure 8-1</a>.</p>
<p class="TX">The second <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block <span aria-label="annotation5" class="CodeAnnotation">❺</span> is the combinational one. It contains the logic for determining how to set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>. Notice that the sensitivity list <span aria-label="annotation5" class="CodeAnnotation">❺</span> and the block itself don’t include a clock, so this block won’t generate any flip-flops, just LUTs. We set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> using a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement tied to the current state <span aria-label="annotation6" class="CodeAnnotation">❻</span>, and by looking at our inputs. For example, if the state is currently <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Coin</samp> input is high, then the next state will be <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp> <span aria-label="annotation7" class="CodeAnnotation">❼</span>. Compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement and conditional logic with the state machine diagram in <a href="#fig8-1">Figure 8-1</a>, and you’ll see that we’ve addressed all the transitions and events shown in the diagram that result in an actual change of state. We don’t need to write code for transitions that don’t cause the signal to change. For example, if the current state is <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp> is high, we’ll just stay in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> state. We could add a check for <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> case and write <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> to make this explicit, but that’s unnecessary. Adding this line can make the designer’s intent clearer, but it also clutters up the code with additional assignments. It’s up to you which style you prefer.</p>
<p class="TX"><span aria-label=" Page 153. " epub:type="pagebreak" id="pg_153" role="doc-pagebreak"/>We could also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> case (in Verilog) or a <samp class="SANS_TheSansMonoCd_W5Regular_11">when others</samp> case (in VHDL) above the <samp class="SANS_TheSansMonoCd_W5Regular_11">endcase</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">end case</samp> statement <span aria-label="annotation8" class="CodeAnnotation">❽</span>, to cover any conditions not explicitly called out in the state machine. Again, this is not required, but it can be a good idea; if you forget or omit a case, the default case will catch it. In this instance, I chose not to include a default. In fact, my code editor displays a suggestion for the VHDL when I try to include it:</p>
<pre><code>Case statement contains all choices explicitly. You can safely remove the
redundant 'others'(13).</code></pre>
<p class="TX">The code ends by assigning the module’s single output, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Locked</samp> <span aria-label="annotation9" class="CodeAnnotation">❾</span>. It will be high when we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> state, or low otherwise. If this code were really controlling a physical turnstile, we’d use changes in this output to trigger the actions that occur during state transitions, such as enabling or disabling the mechanism that locks the turnstile.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using One always or process Block</samp></h3>
<p class="TNI1">The other approach to implementing a state machine combines all the logic into a single <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. As synthesis tools have improved over the years, they’ve gotten much better at understanding when you want to create a state machine, and where this one-block approach may once have been hard to synthesize, it’s now perfectly viable (and arguably more straightforward to code). Here’s the same turnstile state machine implemented with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Turnstile_Example
 (input i_Reset,
  input i_Clk,
  input i_Coin,
  input i_Push,
  output o_Locked);
  localparam LOCKED   = 1'b0;
  localparam UNLOCKED = 1'b1;
  reg r_Curr_State;
  // Single always block approach
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> always @(posedge i_Clk or posedge i_Reset)
  begin
    if (i_Reset)
      r_Curr_State &lt;= LOCKED;
    else
    begin
    <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> case (r_Curr_State)
        LOCKED:
          if (i_Coin)
            r_Curr_State &lt;= UNLOCKED;
        UNLOCKED:
          if (i_Push)
            r_Curr_State &lt;= LOCKED;
      endcase
    end
  end
  assign o_Locked = (r_Curr_State == LOCKED);
endmodule</code></pre>
<p class="Label"><span aria-label=" Page 154. " epub:type="pagebreak" id="pg_154" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity Turnstile_Example is
  port (
    i_Reset  : in std_logic;
    i_Clk    : in std_logic;
    i_Coin   : in std_logic;
    i_Push   : in std_logic;
    o_Locked : out std_logic);
end entity Turnstile_Example;
architecture RTL of Turnstile_Example is
  type t_State is (LOCKED, UNLOCKED);
  signal r_Curr_State : t_State;
begin
  -- Single always block approach
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> process (i_Clk, i_Reset) is
  begin
    if (i_Reset) then
      r_Curr_State &lt;= LOCKED;
    elsif rising_edge(i_Clk) then
  <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> case r_Curr_State is
      when LOCKED =&gt;
         if i_Coin = '1' then
           r_Curr_State &lt;= UNLOCKED;
         end if;
      when UNLOCKED =&gt;
         if i_Push = '1' then
           r_Curr_State &lt;= LOCKED;
         end if;
    end case;
  end if;
end process;
<span aria-label=" Page 155. " epub:type="pagebreak" id="pg_155" role="doc-pagebreak"/>   o_Locked &lt;= '1' when r_Curr_State = LOCKED else '0';
end RTL;</code></pre>
<p class="TX">Everything works the same in the two approaches; the differences are purely stylistic, not functional. In this version of the state machine, we have a single <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block <span aria-label="annotation1" class="CodeAnnotation">❶</span> that’s sensitive to the clock and the reset signal. Rather than having both <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> to worry about, we now only have <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp>. None of the actual logic has changed, however. All we’ve done is move the work that was being done in the combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block into the sequential one, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement will be evaluated at every rising clock edge <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
<p class="TX">I’m not a big fan of the first approach we looked at, with the two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks. There are a few reasons for this. First, separating the LUT-based logic and the flip-flop-based logic into two separate blocks can be confusing, especially for beginners. Compared to the single-block solution, the design is more complicated and less intuitive, and it’s easier to make mistakes. Second, as I said back in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, I prefer not to use combinational-only <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks if I can avoid them. They can generate latches if you’re not careful, which can result in unwanted behavior. I recommend keeping your state machine logic within a single <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. The code is easier to read and understand, and the tools are good enough now to build the state machine correctly.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-102"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Design</samp></h3>
<p class="TNI1">Let’s generate a testbench for this state machine to ensure that we’re getting the output we desire:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Turnstile_Example_TB();
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> reg r_Reset = 1'b1, r_Clk = 1'b0, r_Coin = 1'b0, r_Push = 1'b0;
  wire w_Locked;
  Turnstile_Example UUT
   (.i_Reset(r_Reset),
   .i_Clk(r_Clk),
   .i_Coin(r_Coin),
   .i_Push(r_Push),
   .o_Locked(w_Locked));
  always #1 r_Clk &lt;= !r_Clk;
  initial begin
    $dumpfile("dump.vcd");
    $dumpvars;
    #10;
 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Reset &lt;= 1'b0;
    #10;
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> assert (w_Locked == 1'b1);
 <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Coin &lt;= 1'b1;
    #10;
    assert (w_Locked == 1'b0);
    r_Push &lt;= 1'b1;
    #10;
    assert (w_Locked == 1'b1);
    r_Coin &lt;= 1'b0;
    #10;
    assert (w_Locked == 1'b1);
    r_Push &lt;= 1'b0;
    #10;
    assert (w_Locked == 1'b1);
    $finish();
  end
endmodule</code></pre>
<p class="Label"><span aria-label=" Page 156. " epub:type="pagebreak" id="pg_156" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use std.env.finish;
entity Turnstile_Example_TB is
end entity Turnstile_Example_TB;
architecture test of Turnstile_Example_TB is
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> signal r_Reset : std_logic := '1';
  signal r_Clk, r_Coin, r_Push : std_logic := '0';
  signal w_Locked : std_logic;
begin
  UUT : entity work.Turnstile_Example
  port map (
    i_Reset  =&gt; r_Reset,
    i_Clk    =&gt; r_Clk,
    i_Coin   =&gt; r_Coin,
    i_Push   =&gt; r_Push,
    o_Locked =&gt; w_Locked);
  r_Clk &lt;= not r_Clk after 1 ns;
  process is
  begin
    wait for 10 ns;
  <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> r_Reset &lt;= '0';
    wait for 10 ns;
  <span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> assert w_Locked = '1' severity failure;
  <span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> r_Coin &lt;= '1';
    wait for 10 ns;
    assert w_Locked = '0' severity failure;
    r_Push &lt;= '1';
    wait for 10 ns;
    assert w_Locked = '1' severity failure;
    r_Coin &lt;= '0';
    wait for 10 ns;
    assert w_Locked = '1' severity failure;
    r_Push &lt;= '0';
    wait for 10 ns;
    assert w_Locked = '1' severity failure;
    finish;  -- need VHDL-2008
  end process;
end test;</code></pre>
<p class="TX"><span aria-label=" Page 157. " epub:type="pagebreak" id="pg_157" role="doc-pagebreak"/>This testbench drives the inputs in all possible combinations and monitors the single output (<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp>) to see how it behaves. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp> is initialized to high at the outset <span aria-label="annotation1" class="CodeAnnotation">❶</span>, which should put us in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> state. Then, after 10 ns, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp> low <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This should have no effect on the state, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> keyword in both VHDL and Verilog to verify that we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> state (indicated by a <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp> value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>) <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We then continue manipulating the other inputs and asserting the expected output (for instance, driving <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Coin</samp> high <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> should put us in an <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp> state). Our use of <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> statements to automatically alert us to any failures makes this a self-checking testbench.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>For Verilog users, remember that assert only exists in SystemVerilog. Be sure to tell the simulator that your testbench is a SystemVerilog file, rather than regular Verilog.</i></p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h-103"/><samp class="SANS_Futura_Std_Bold_B_11">State Machine Best Practices</samp></h2>
<p class="TNI1">Before moving on, I want to share some recommendations for developing successful state machines. These are guidelines that I find helpful when I write my own FPGA state machines, and they’re all modeled in the turnstile example we reviewed in the previous section:</p>
<p class="ListHead"><b>Include one state machine per file.</b></p>
<p class="ListPlainFirst">It’s certainly possible to write many state machines within a single file, but I strongly suggest that you limit the scope of any given Verilog or VHDL file to a single state machine. When you put two or more state machines in the same file, it can be hard to keep them from getting logically intertwined. It might require more typing to break things into multiple files, but it will save you time in the debugging stage.</p>
<p class="ListHead"><span aria-label=" Page 158. " epub:type="pagebreak" id="pg_158" role="doc-pagebreak"/><b>Use the single-block approach.</b></p>
<p class="ListPlainFirst">As I’ve stated, I find that it’s easier to write cleaner and less error-prone state machines if you only have one <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block to worry about, rather than two. The one-block approach also avoids the need for combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks, which can generate latches if you’re not careful.</p>
<p class="ListHead"><b>Give your states meaningful names.</b></p>
<p class="ListPlainFirst">It’s much easier to read a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement that has actual words associated with each of the cases, provided you’ve named your states thoughtfully. For example, use descriptive names like <samp class="SANS_TheSansMonoCd_W5Regular_11">IDLE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">START_COUNT</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>, and so on, rather than generic names like <samp class="SANS_TheSansMonoCd_W5Regular_11">S0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">S1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">S2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">S3</samp>. Meaningful state names will help other people reading the code understand what’s going on. Additionally, you’ll thank yourself for descriptive state naming when you come back to your code after not looking at it for months. Enumeration allows you to do this. Enumeration is a common programming technique that allows you to use words in place of integers in your code. This is done either through <samp class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp> in Verilog or a user-defined type in VHDL.</p>
<p class="ListHead"><b>Draw your state machine flow before coding.</b></p>
<p class="ListPlainFirst">Diving headfirst into coding a state machine is a recipe for disaster. Begin by drawing a diagram of the state machine that you want to implement, like the one you saw in <a href="#fig8-1">Figure 8-1</a>. This will help you ensure that you’ve thought through the entire flow, from the initial transition through all the possible permutations. If you realize that you’ve missed something once you start working on the code, that’s fine; just be sure to go back and update your diagram to keep it in sync with the code you’re writing. Your future self will thank you if you have this documentation.</p>
<p class="TX">It is by no means mandatory to follow these suggestions, but doing so will help you avoid some common pitfalls and create state machines within your FPGAs that are bug-free, easy to understand, and easy to maintain. The more complex your state machines become, the more helpful these best practices will be.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h2 class="H1" id="sec7"><span id="h-104"/><span class="NoteHead"><samp class="SANS_Futura_Std_Heavy_B_21">Project #6: Creating a Memory Game</samp></span></h2>
<p class="TNI1">We’ll now put what you’ve learned about state machines into action by creating a memory game that runs on your development board. The player will have to remember and reproduce a pattern that grows longer as the game progresses, similar to a game like Simon. If the player can remember the entire pattern, they win.</p>
<p class="TX">The pattern is displayed using four LEDs. It starts simply, with just one LED lighting up. Then it’s the player’s turn to re-create the pattern by pressing the switch that matches the LED. If they push the wrong switch, the game is over. If they push the correct switch, the game continues, <span aria-label=" Page 159. " epub:type="pagebreak" id="pg_159" role="doc-pagebreak"/>with the pattern expanding to a sequence of two LED blinks. The pattern keeps expanding until it’s seven blinks long (although you’ll be able to adjust the code to make it longer if you want). If the player re-creates the last pattern correctly, they may choose to play another round with a new pattern.</p>
<p class="TX">This project takes advantage of a peripheral that we haven’t used before: a <i>seven-segment display</i>. This device uses an arrangement of seven LEDs to display the digits 0 through 9 (and a selection of letters), like something you’d see on a digital clock. It will serve as a scoreboard, keeping track of the player’s progress through the pattern. We’ll also use it to display an F (for <i>failure</i>) if the player makes a mistake, or an A when the game is won.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If your development board doesn’t have four LEDs and switches, you can adapt the project’s code to work with the resources available. If it doesn’t have a seven-segment display, try connecting one to your board, for example using a Pmod connector.</i></p>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-105"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning the State Machine</samp></h3>
<p class="TNI1">To create the game, we’ll need to control the FPGA’s flow through various states of operation, such as displaying the pattern and waiting for the player’s response. Sounds like a perfect opportunity to use a state machine! In keeping with our best practices, we’ll use a diagram to plan out the state machine before we write any code. <a href="#fig8-3">Figure 8-3</a> shows a diagram for a state machine that satisfies the description of the game.</p>
<figure class="IMG"><img alt="" class="img80" id="fig8-3" src="../images/Figure8-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The memory game state machine diagram</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 160. " epub:type="pagebreak" id="pg_160" role="doc-pagebreak"/>Starting from the top-left corner, we have a reset/initial condition, which will jump into the Start state from any other state. I didn’t draw arrows from every state back to Start, to avoid cluttering the diagram; just remember that you can always jump back to Start from any state when the reset condition occurs. We remain in the Start state until the reset is cleared, at which point we transition into the Pattern Off state. We wait here with all LEDs off for a set amount of time, and then we transition into the Pattern Show state, where we illuminate a single LED from the pattern, again for a set amount of time. If it’s the last LED in the pattern (the pattern is done), we then transition to the Wait Player state to await the player’s response. If the LED pattern is not done, we transition back to Pattern Off. We keep cycling between Pattern Show and Pattern Off, lighting up the LEDs in the pattern one at a time, until the pattern is done. The transitions back to Pattern Off add a pause between each blink, which avoids ambiguity in cases where the pattern includes the same LED twice in a row. This is the part of the game where the LED pattern is being shown to the player, for them to try to re-create later on.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>The diamond in the diagram between the Pattern Show and Wait Player states represents a</i> <span class="Roman">guard condition</span><i>, a Boolean expression that determines the state machine flow. In this case, the guard condition is checking whether the pattern is done.</i></p>
<p class="TX">Once we’re in the Wait Player state, the FPGA monitors the input from the buttons until one of two things happens. If the player pushes an incorrect button in the sequence, then we transition to the Loser state and show an F on the seven-segment display. If the player successfully re-creates the entire pattern, then we transition to the Incr Score (Increment Score) state. Here we check if the game is done, in which case the player has won and we transition to the Winner state, where we show an A on the seven-segment display. If the game isn’t done, then we go back to Pattern Off to get ready to display the pattern again, this time with one additional LED blink added to the sequence.</p>
<p class="TX">There are nearly endless possibilities for designing state machines, so by no means is the arrangement shown in <a href="#fig8-3">Figure 8-3</a> the only option. For example, we could have combined Pattern Off and Pattern Show into a single state that handles turning the LEDs both on and off. Our design, however, strikes a balance between the number of states and the complexity of each individual state. As a general rule, if one state is responsible for several actions, it might be an indication that the state should be broken into two or more states.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-106"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Organizing the Design</samp></h3>
<p class="TNI1">Next, we’ll take a look at the overall organization of the project. <a href="#fig8-4">Figure 8-4</a> shows a block diagram of the design.</p>
<span aria-label=" Page 161. " epub:type="pagebreak" id="pg_161" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img70" id="fig8-4" src="../images/Figure8-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: The Project #6 block diagram</samp></p></figcaption>
</figure>
<p class="TX">Let’s trace the flow of data through the block diagram. First, we have four switches (buttons) that are used to control the entire game. Remember that these are mechanical switches, so they’re subject to bouncing. To get reliable button responses, these inputs must be debounced, which is the first thing that we do to each switch’s signal as it enters the FPGA. We’ll use the debounce filter module we implemented in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> for this. The FPGA also has a clock input, which we’ll use to drive all the flip-flops in this design.</p>
<p class="TX">Next, we have the memory game module itself, which is where the state machine lives. We’ll explore this code in detail shortly. Notice that this module instantiates two submodules: <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> and the LFSR module, both of which you saw in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. Remember that LFSRs are pseudorandom pattern generators, so we’ll use one here to create a random pattern for the game. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module to keep track of how long to display each LED in the pattern sequence; the toggling of this module will trigger transitions between states.</p>
<p class="TX">Finally, we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp> module, which takes a binary input representing the player’s score and drives the seven-segment display to light up that score. We’ll look at how this works next.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-107"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Seven-Segment Display</samp></h3>
<p class="TNI1">A seven-segment display consists of an arrangement of seven LEDs that can be lit in various combinations to produce different patterns. <a href="#fig8-5">Figure 8-5</a> shows the seven segments of the display, labeled A through G. We’ll use one of these displays to keep track of the score in this project, incrementing it each time the player successfully repeats the pattern.</p>
<span aria-label=" Page 162. " epub:type="pagebreak" id="pg_162" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img20" id="fig8-5" src="../images/Figure8-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: A seven-segment display</samp></p></figcaption>
</figure>
<p class="TX">Conventionally, seven-segment displays are used to show the decimal numbers 0 through 9, but we can extend our display’s range further by showing the hexadecimal numbers A through F (for 10 through 15) as well. We can’t simply tell the display to light up a particular number, however, since each segment in the display is controlled separately. Instead, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary _To_7Segment</samp> module takes in the number to be shown and translates it into the appropriate signals for driving the display. Let’s take a look at the code:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Binary_To_7Segment
  (input      i_Clk,
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> input [3:0] i_Binary_Num,
  output      o_Segment_A,
  output      o_Segment_B,
  output      o_Segment_C,
  output      o_Segment_D,
  output      o_Segment_E,
  output      o_Segment_F,
  output      o_Segment_G);
  reg [6:0]   r_Hex_Encoding;
  always @(posedge i_Clk)
    begin
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> case (i_Binary_Num)
         4'b0000 : r_Hex_Encoding &lt;= 7'b1111110; // 0x7E
         4'b0001 : r_Hex_Encoding &lt;= 7'b0110000; // 0x30
         4'b0010 : r_Hex_Encoding &lt;= 7'b1101101; // 0x6D
         4'b0011 : r_Hex_Encoding &lt;= 7'b1111001; // 0x79
         4'b0100 : r_Hex_Encoding &lt;= 7'b0110011; // 0x33
         4'b0101 : r_Hex_Encoding &lt;= 7'b1011011; // 0x5B
         4'b0110 : r_Hex_Encoding &lt;= 7'b1011111; // 0x5F
      <span aria-label="annotation3" class="CodeAnnotationCode1">❸</span> 4'b0111 : r_Hex_Encoding &lt;= 7'b1110000; // 0x70
         4'b1000 : r_Hex_Encoding &lt;= 7'b1111111; // 0x7F
         4'b1001 : r_Hex_Encoding &lt;= 7'b1111011; // 0x7B
         4'b1010 : r_Hex_Encoding &lt;= 7'b1110111; // 0x77
         4'b1011 : r_Hex_Encoding &lt;= 7'b0011111; // 0x1F
         4'b1100 : r_Hex_Encoding &lt;= 7'b1001110; // 0x4E
         4'b1101 : r_Hex_Encoding &lt;= 7'b0111101; // 0x3D
         4'b1110 : r_Hex_Encoding &lt;= 7'b1001111; // 0x4F
         4'b1111 : r_Hex_Encoding &lt;= 7'b1000111; // 0x47
         default : r_Hex_Encoding &lt;= 7'b0000000; // 0x00
      endcase
    end
<span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> assign o_Segment_A = r_Hex_Encoding[6];
  assign o_Segment_B = r_Hex_Encoding[5];
  assign o_Segment_C = r_Hex_Encoding[4];
  assign o_Segment_D = r_Hex_Encoding[3];
  assign o_Segment_E = r_Hex_Encoding[2];
  assign o_Segment_F = r_Hex_Encoding[1];
  assign o_Segment_G = r_Hex_Encoding[0];
endmodule</code></pre>
<p class="Label"><span aria-label=" Page 163. " epub:type="pagebreak" id="pg_163" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity Binary_To_7Segment is
  port (
    i_Clk        : in std_logic;
 <span aria-label="annotation1" class="CodeAnnotationCode1">❶</span> i_Binary_Num : in std_logic_vector(3 downto 0);
    o_Segment_A  : out std_logic;
    o_Segment_B  : out std_logic;
    o_Segment_C  : out std_logic;
    o_Segment_D  : out std_logic;
    o_Segment_E  : out std_logic;
    o_Segment_F  : out std_logic;
    o_Segment_G  : out std_logic
    );
end entity Binary_To_7Segment;
architecture RTL of Binary_To_7Segment is
  signal r_Hex_Encoding : std_logic_vector(6 downto 0);
begin
  process (i_Clk) is
  begin
     if rising_edge(i_Clk) then
     <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> case i_Binary_Num is
          when "0000" =&gt;
            r_Hex_Encoding &lt;= "1111110"; -- 0x7E
          when "0001" =&gt;
            r_Hex_Encoding &lt;= "0110000"; -- 0x30
          when "0010" =&gt;
            r_Hex_Encoding &lt;= "1101101"; -- 0x6D
          when "0011" =&gt;
            r_Hex_Encoding &lt;= "1111001"; -- 0x79
          when "0100" =&gt;
            r_Hex_Encoding &lt;= "0110011"; -- 0x33
          when "0101" =&gt;
            r_Hex_Encoding &lt;= "1011011"; -- 0x5B
          when "0110" =&gt;
            r_Hex_Encoding &lt;= "1011111"; -- 0x5F
        <span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> when "0111" =&gt;
            r_Hex_Encoding &lt;= "1110000"; -- 0x70
          when "1000" =&gt;
            r_Hex_Encoding &lt;= "1111111"; -- 0x7F
          when "1001" =&gt;
            r_Hex_Encoding &lt;= "1111011"; -- 0x7B
          when "1010" =&gt;
            r_Hex_Encoding &lt;= "1110111"; -- 0x77
          when "1011" =&gt;
            r_Hex_Encoding &lt;= "0011111"; -- 0x1F
          when "1100" =&gt;
            r_Hex_Encoding &lt;= "1001110"; -- 0x4E
          when "1101" =&gt;
            r_Hex_Encoding &lt;= "0111101"; -- 0x3D
          when "1110" =&gt;
            r_Hex_Encoding &lt;= "1001111"; -- 0x4F
          when "1111" =&gt;
            r_Hex_Encoding &lt;= "1000111"; -- 0x47
          when others =&gt;
            r_Hex_Encoding &lt;= "0000000"; -- 0x00
      end case;
    end if;
  end process;
<span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> o_Segment_A &lt;= r_Hex_Encoding(6);
  o_Segment_B &lt;= r_Hex_Encoding(5);
  o_Segment_C &lt;= r_Hex_Encoding(4);
  o_Segment_D &lt;= r_Hex_Encoding(3);
  o_Segment_E &lt;= r_Hex_Encoding(2);
  o_Segment_F &lt;= r_Hex_Encoding(1);
  o_Segment_G &lt;= r_Hex_Encoding(0);
end architecture RTL;</code></pre>
<p class="TX"><span aria-label=" Page 164. " epub:type="pagebreak" id="pg_164" role="doc-pagebreak"/>This module takes a 4-bit binary input <span aria-label="annotation1" class="CodeAnnotation">❶</span> and uses seven outputs to light up the appropriate segments in the display, given the input. The <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement <span aria-label="annotation2" class="CodeAnnotation">❷</span> captures all possible inputs, from <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp> (0 through 15), and translates each number into the correct output pattern using the 7-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp> register. Each bit in the register maps to one of the segments in the display: bit 6 maps to segment A, bit 5 maps to segment B, and so on. To see how this works, let’s consider a specific input—say, <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>, which is the digit 7—as an example. <a href="#fig8-6">Figure 8-6</a> illustrates how to illuminate a seven-segment display to show this digit.</p>
<figure class="IMG"><img alt="" class="img20" id="fig8-6" src="../images/Figure8-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: Illuminating a 7 on a seven- segment display</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 165. " epub:type="pagebreak" id="pg_165" role="doc-pagebreak"/>As you can see in the figure, we need to illuminate segments A, B, and C, while keeping the other segments turned off, to show the digit 7. In the code at <span aria-label="annotation3" class="CodeAnnotation">❸</span>, we therefore set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">1110000</samp> in binary, putting 1s on the three bits corresponding to segments A, B, and C. Then, outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement, we extract each individual bit from the register and pass it to the appropriate output using a continuous assignment <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. This approach of encoding the pattern into the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp> register saves a lot of typing; we don’t have to assign all seven outputs in every single branch of the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-108"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coding the Top-Level Module</samp></h3>
<p class="TNI1">Next, let’s jump into the top module of the project to see how everything is wired up at the highest level. If you refer back to the block diagram in <a href="#fig8-4">Figure 8-4</a>, you’ll see this module represented by the square with the dotted line:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module State_Machine_Project_Top
 (input i_Clk,
  // Input switches for entering pattern
  input i_Switch_1,
  input i_Switch_2,
  input i_Switch_3,
  input i_Switch_4,
  // Output LEDs for displaying pattern
  output o_LED_1,
  output o_LED_2,
  output o_LED_3,
  output o_LED_4,
  // Scoreboard, 7-segment display
  output o_Segment2_A,
  output o_Segment2_B,
  output o_Segment2_C,
  output o_Segment2_D,
  output o_Segment2_E,
  output o_Segment2_F,
  output o_Segment2_G);
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> localparam GAME_LIMIT     = 7;        // Increase to make game harder
  localparam CLKS_PER_SEC   = 25000000; // 25 MHz clock
  localparam DEBOUNCE_LIMIT = 250000;  // 10 ms debounce filter
  wire w_Switch_1, w_Switch_2, w_Switch_3, w_Switch_4;
  wire w_Segment2_A, w_Segment2_B, w_Segment2_C, w_Segment2_D;
  wire w_Segment2_E, w_Segment2_F, w_Segment2_G;
  wire [3:0] w_Score;
  // Debounce all switch inputs to remove mechanical glitches
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW1
  (.i_Clk(i_Clk),
   .i_Bouncy(i_Switch_1),
   .o_Debounced(w_Switch_1));<span aria-label=" Page 166. " epub:type="pagebreak" id="pg_166" role="doc-pagebreak"/>
  Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW2
  (.i_Clk(i_Clk),
   .i_Bouncy(i_Switch_2),
   .o_Debounced(w_Switch_2));
  Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW3
  (.i_Clk(i_Clk),
   .i_Bouncy(i_Switch_3),
   .o_Debounced(w_Switch_3));
  Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW4
  (.i_Clk(i_Clk),
   .i_Bouncy(i_Switch_4),
   .o_Debounced(w_Switch_4));
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> State_Machine_Game #(.CLKS_PER_SEC(CLKS_PER_SEC),
                       .GAME_LIMIT(GAME_LIMIT)) Game_Inst
  (.i_Clk(i_Clk),
   .i_Switch_1(w_Switch_1),
   .i_Switch_2(w_Switch_2),
   .i_Switch_3(w_Switch_3),
   .i_Switch_4(w_Switch_4),
   .o_Score(w_Score),
   .o_LED_1(o_LED_1),
   .o_LED_2(o_LED_2),
   .o_LED_3(o_LED_3),
   .o_LED_4(o_LED_4));
<span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> Binary_To_7Segment Scoreboard
  (.i_Clk(i_Clk),
   .i_Binary_Num(w_Score),
   .o_Segment_A(w_Segment2_A),
   .o_Segment_B(w_Segment2_B),
   .o_Segment_C(w_Segment2_C),
   .o_Segment_D(w_Segment2_D),
   .o_Segment_E(w_Segment2_E),
   .o_Segment_F(w_Segment2_F),
   .o_Segment_G(w_Segment2_G));
<span aria-label="annotation5" class="CodeAnnotationCode-1">❺</span> assign o_Segment2_A = !w_Segment2_A;
  assign o_Segment2_B = !w_Segment2_B;
  assign o_Segment2_C = !w_Segment2_C;
  assign o_Segment2_D = !w_Segment2_D;
  assign o_Segment2_E = !w_Segment2_E;
  assign o_Segment2_F = !w_Segment2_F;
  assign o_Segment2_G = !w_Segment2_G;
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library IEEE;
use IEEE.std_logic_1164.all;
entity State_Machine_Project_Top is<span aria-label=" Page 167. " epub:type="pagebreak" id="pg_167" role="doc-pagebreak"/>
  port (
    i_Clk : in std_logic;
    -- Input switches for entering pattern
    i_Switch_1 : in std_logic;
    i_Switch_2 : in std_logic;
    i_Switch_3 : in std_logic;
    i_Switch_4 : in std_logic;
    -- Output LEDs for displaying pattern
    o_LED_1 : out std_logic;
    o_LED_2 : out std_logic;
    o_LED_3 : out std_logic;
    o_LED_4 : out std_logic;
    -- Scoreboard, 7-segment display
    o_Segment2_A : out std_logic;
    o_Segment2_B : out std_logic;
    o_Segment2_C : out std_logic;
    o_Segment2_D : out std_logic;
    o_Segment2_E : out std_logic;
    o_Segment2_F : out std_logic;
    o_Segment2_G : out std_logic);
end entity State_Machine_Project_Top;
architecture RTL of State_Machine_Project_Top is
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> constant GAME_LIMIT      : integer := 7;       -- Increase to make game harder
   constant CLKS_PER_SEC   : integer := 25000000; -- 25 MHz clock
   constant DEBOUNCE_LIMIT : integer := 250000;   -- 10 ms debounce filter
   signal w_Switch_1, w_Switch_2, w_Switch_3, w_Switch_4 : std_logic;
   signal w_Score : std_logic_vector(3 downto 0);
   signal w_Segment2_A, w_Segment2_B, w_Segment2_C, w_Segment2_D : std_logic;
   signal w_Segment2_E, w_Segment2_F, w_Segment2_G : std_logic;
begin
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Debounce_SW1 : entity work.Debounce_Filter
     generic map (
       DEBOUNCE_LIMIT =&gt; DEBOUNCE_LIMIT)
     port map (
       i_Clk       =&gt; i_Clk,
       i_Bouncy    =&gt; i_Switch_1,
       o_Debounced =&gt; w_Switch_1);
   Debounce_SW2 : entity work.Debounce_Filter
     generic map (
       DEBOUNCE_LIMIT =&gt; DEBOUNCE_LIMIT)
     port map (
       i_Clk       =&gt; i_Clk,
       i_Bouncy    =&gt; i_Switch_2,
       o_Debounced =&gt; w_Switch_2);
   Debounce_SW3 : entity work.Debounce_Filter
     generic map (
       DEBOUNCE_LIMIT =&gt; DEBOUNCE_LIMIT)<span aria-label=" Page 168. " epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/>
     port map (
       i_Clk       =&gt; i_Clk,
       i_Bouncy    =&gt; i_Switch_3,
       o_Debounced =&gt; w_Switch_3);
   Debounce_SW4 : entity work.Debounce_Filter
     generic map (
       DEBOUNCE_LIMIT =&gt; DEBOUNCE_LIMIT)
     port map (
       i_Clk =&gt; i_Clk,
       i_Bouncy =&gt; i_Switch_4,
       o_Debounced =&gt; w_Switch_4);
<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> Game_Inst : entity work.State_Machine_Game
   generic map (
     CLKS_PER_SEC =&gt; CLKS_PER_SEC,
     GAME_LIMIT   =&gt; GAME_LIMIT)
   port map (
     i_Clk      =&gt; i_Clk,
     i_Switch_1 =&gt; w_Switch_1,
     i_Switch_2 =&gt; w_Switch_2,
     i_Switch_3 =&gt; w_Switch_3,
     i_Switch_4 =&gt; w_Switch_4,
     o_Score    =&gt; w_Score,
     o_LED_1    =&gt; o_LED_1,
     o_LED_2    =&gt; o_LED_2,
     o_LED_3    =&gt; o_LED_3,
     o_LED_4    =&gt; o_LED_4);
<span aria-label="annotation4" class="CodeAnnotationCode">❹</span> Scoreboard : entity work.Binary_To_7Segment
     port map (
       i_Clk        =&gt; i_Clk,
       i_Binary_Num =&gt; w_Score,
       o_Segment_A  =&gt; w_Segment2_A,
       o_Segment_B  =&gt; w_Segment2_B,
       o_Segment_C  =&gt; w_Segment2_C,
       o_Segment_D  =&gt; w_Segment2_D,
       o_Segment_E  =&gt; w_Segment2_E,
       o_Segment_F  =&gt; w_Segment2_F,
       o_Segment_G  =&gt; w_Segment2_G);
<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> o_Segment2_A &lt;= not w_Segment2_A;
   o_Segment2_B &lt;= not w_Segment2_B;
   o_Segment2_C &lt;= not w_Segment2_C;
   o_Segment2_D &lt;= not w_Segment2_D;
   o_Segment2_E &lt;= not w_Segment2_E;
   o_Segment2_F &lt;= not w_Segment2_F;
   o_Segment2_G &lt;= not w_Segment2_G;
end RTL;</code></pre>
<p class="TX">My goal for writing the top module of a design, especially as the design becomes more complicated, is to minimize the amount of functional code within it. Ideally, code that performs functionality should be pushed into <span aria-label=" Page 169. " epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/>lower levels, so the highest level is just wires and module instantiation. This helps keep the code clean and ensures that each module is focused on performing what’s needed of it, without spreading the functionality across multiple layers.</p>
<p class="TX">For this project, we first instantiate four debounce filter modules, one for each push button <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Then we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module, which contains the logic for the state machine and the game itself <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The inputs to this module, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_4</samp>, are the outputs of the debounce filters, so this module can trust that the input signals are stable. Notice that the module has two parameters (Verilog) or generics (VHDL), <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>, both of which were set earlier <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The former specifies the number of clock cycles per second (needed for keeping track of time), and is there in case the design is run at a different clock frequency. The latter controls the maximum length of the pattern.</p>
<p class="TX">Next we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp> module <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, which takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Score</samp> output from the game as an input so the score will be displayed to the player. Notice, however, that we invert all the outputs from the display module before outputting them at the top level <span aria-label="annotation5" class="CodeAnnotation">❺</span>. A low on the output may be needed, rather than a high, to light up each segment, depending on the way the seven-segment display is connected on your development board’s PCB. If your display isn’t behaving as expected, try removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>s from the Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>s from the VHDL to avoid inverting the outputs.</p>
<p class="TX">Our top-level module doesn’t instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> modules directly: those are instantiated within the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module. You’re starting to see here how a hierarchy can be established inside an FPGA, and how a complex design can be built up from relatively simple modules.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H2" id="sec12"><span id="h-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coding the State Machine</samp></h3>
<p class="TNI1">Now let’s get to the meat of the project: the state machine itself. We’ll examine the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module in sections, but remember that you can view the complete code listing in the book’s GitHub repository (<a href="https://github.com/nandland/getting-started-with-fpgas"><i>https://<wbr/>github<wbr/>.com<wbr/>/nandland<wbr/>/getting<wbr/>-started<wbr/>-with<wbr/>-fpgas</i></a>). The module starts, as usual, by declaring the inputs, outputs, and internal signals:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module State_Machine_Game # (parameter CLKS_PER_SEC = 25000000,
                             parameter GAME_LIMIT = 6)
 (input i_Clk,
  input i_Switch_1,
  input i_Switch_2,
  input i_Switch_3,
  input i_Switch_4,
  output reg [3:0] o_Score,
  output o_LED_1,
  output o_LED_2,
  output o_LED_3,
  output o_LED_4
  );<span aria-label=" Page 170. " epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> localparam START        = 3'd0;
  localparam PATTERN_OFF  = 3'd1;
  localparam PATTERN_SHOW = 3'd2;
  localparam WAIT_PLAYER  = 3'd3;
  localparam INCR_SCORE   = 3'd4;
  localparam LOSER        = 3'd5;
  localparam WINNER       = 3'd6;
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> reg [2:0] r_SM_Main;
  reg r_Toggle, r_Switch_1, r_Switch_2, r_Switch_3;
  reg r_Switch_4, r_Button_DV;
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> reg [1:0] r_Pattern[0:10]; // 2D array: 2 bits wide x 11 deep
  wire [21:0] w_LFSR_Data;
  reg [$clog2(GAME_LIMIT)-1:0] r_Index; // Display index
  reg [1:0] r_Button_ID;
  wire w_Count_En, w_Toggle;
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
entity State_Machine_Game is
  generic (
    CLKS_PER_SEC : integer := 25000000;
    GAME_LIMIT   : integer := 6);
  port(
    i_Clk      : in std_logic;
    i_Switch_1 : in std_logic;
    i_Switch_2 : in std_logic;
    i_Switch_3 : in std_logic;
    i_Switch_4 : in std_logic;
    o_Score    : out std_logic_vector(3 downto 0);
    o_LED_1    : out std_logic;
    o_LED_2    : out std_logic;
    o_LED_3    : out std_logic;
    o_LED_4    : out std_logic);
end entity State_Machine_Game;
architecture RTL of State_Machine_Game is
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> type t_SM_Main is (START, PATTERN_OFF, PATTERN_SHOW,
                     WAIT_PLAYER, INCR_SCORE, LOSER, WINNER);
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> signal r_SM_Main : t_SM_Main;
  signal w_Count_En, w_Toggle, r_Toggle, r_Switch_1 : std_logic;
  signal r_Switch_2, r_Switch_3, r_Switch_4, r_Button_DV : std_logic;
  type t_Pattern is array (0 to 10) of std_logic_vector(1 downto 0);
<span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> signal r_Pattern : t_Pattern; -- 2D Array: 2-bit wide x 11 deep<span aria-label=" Page 171. " epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/>
  signal w_LFSR_Data : std_logic_vector(21 downto 0);
  signal r_Index : integer range 0 to GAME_LIMIT;
  signal w_Index_SLV : std_logic_vector(7 downto 0);
  signal r_Button_ID : std_logic_vector(1 downto 0);
  signal r_Score : unsigned(3 downto 0);
<var>--snip--</var></code></pre>
<p class="TX">We use the enumeration approach described earlier in the chapter to name each state <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> signal <span aria-label="annotation2" class="CodeAnnotation">❷</span> will keep track of the current state. It needs to have enough bits to convey all the possible states. In this case, we have seven total states, which can fit inside a 3-bit-wide register. In Verilog, we explicitly declare the signal as having 3 bits. In VHDL, however, we just create the state machine signal to be of the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">t_SM_Main</samp> data type (the enumeration that we created <span aria-label="annotation1" class="CodeAnnotation">❶</span>), and it will be sized automatically.</p>
<p class="TX">Another important signal we’re creating is <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>, which stores the pattern for the game <span aria-label="annotation3" class="CodeAnnotation">❸</span>. This is the second time that we’ve created a two-dimensional signal within our FPGA (the first time was back in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, when we were creating RAM). Specifically, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp> is 2 bits wide by 11 items deep, for a total storage of 22 bits. Each pair of bits in this signal corresponds to one of the four LEDs (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> indicates LED1, <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> indicates LED2, and so on), giving us a sequence of LEDs to light up (and a sequence of switches to press). <a href="#tab8-1">Table 8-1</a> shows an example of what the data in this 2D register might look like.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab8-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Pattern Storage Example</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Index</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">LED/switch</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">In this example, the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, which correlates to the second LED/switch, the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, which correlates to the fourth LED/switch, and so on. We’ll be able to use the index to increment through the register, getting 2 bits for each index. The binary pattern itself comes from the LFSR, and will be random each time. The LFSR is 22 bits wide, so each bit of the LFSR output is mapped to a bit in this 2D register. This means that <span aria-label=" Page 172. " epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>the maximum length of the memory pattern that we can create is 11 LED blinks long. After playing this game several times, however, I can tell you that it gets quite challenging to remember patterns that go that high. As I noted earlier, the actual limit for the game is set by the parameter/generic <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>, which can be overridden from the top module. If you want to set the game to the maximum difficulty, try changing <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>.</p>
<p class="TX">The module continues by handling reset conditions:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
  always @(posedge i_Clk)
  begin
    // Reset game from any state
  <span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> if (i_Switch_1 &amp; i_Switch_2)
       r_SM_Main &lt;= START;
    else
    begin
       // Main state machine switch statement
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> case (r_SM_Main)
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
begin
  process (i_Clk) is
  begin
    if rising_edge(i_Clk) then
       -- Reset game from any state
    <span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> if i_Switch_1 = '1' and i_Switch_2 = '1' then
        r_SM_Main &lt;= START;
      else
         -- Main state machine switch statement
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> case r_SM_Main is
<var>--snip--</var></code></pre>
<p class="TX">The player must push switch 1 and switch 2 at the same time to trigger the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp> state. We check for this with an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Notice that this check occurs outside the state machine’s main <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement, which we initiate in the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> branch <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This means that on every clock cycle we’ll check if both switches are pressed, and enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp> state if they are or run the state machine for the game if they aren’t. It would have been easier if we had a fifth button that was dedicated to resetting the state machine, but alas, I did not, so I had to be a bit creative here.</p>
<p class="TX">Now let’s look at the first few states in the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
     // Main state machine switch statement
        case (r_SM_Main)<span aria-label=" Page 173. " epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/>
           // Stay in START state until user releases buttons
        <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> START:
           begin
              // Wait for reset condition to go away
           <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (!i_Switch_1 &amp; !i_Switch_2 &amp; r_Button_DV)
              begin
                o_Score   &lt;= 0;
                r_Index   &lt;= 0;
                r_SM_Main &lt;= PATTERN_OFF;
              end
           end
        <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> PATTERN_OFF:
           begin
             if (!w_Toggle &amp; r_Toggle) // Falling edge found
                r_SM_Main &lt;= PATTERN_SHOW;
           end
           // Show the next LED in the pattern
        <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> PATTERN_SHOW:
           begin
             if (!w_Toggle &amp; r_Toggle) // Falling edge found
             <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> if (o_Score == r_Index)
                begin
                <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> r_Index   &lt;= 0;
                   r_SM_Main &lt;= WAIT_PLAYER;
                end
                else
                begin
                <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> r_Index   &lt;= r_Index + 1;
                   r_SM_Main &lt;= PATTERN_OFF;
                end
           end
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
      -- Main state machine switch statement
      case r_SM_Main is
      -- Stay in START state until user releases buttons
   <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> when START =&gt;
         -- Wait for reset condition to go away
         <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (i_Switch_1 = '0' and i_Switch_2 = '0' and
                r_Button_DV = '1') then
              r_Score   &lt;= to_unsigned(0, r_Score'length);
              r_Index   &lt;= 0;
              r_SM_Main &lt;= PATTERN_OFF;
            end if;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> when PATTERN_OFF =&gt;
            if w_Toggle = '0' and r_Toggle = '1' then -- Falling edge found<span aria-label=" Page 174. " epub:type="pagebreak" id="pg_174" role="doc-pagebreak"/>
               r_SM_Main &lt;= PATTERN_SHOW;
            end if;
         -- Show the next LED in the pattern
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> when PATTERN_SHOW =&gt;
           if w_Toggle = '0' and r_Toggle = '1' then -- Falling edge found
           <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> if r_Score = r_Index then
              <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> r_Index   &lt;= 0;
                 r_SM_Main &lt;= WAIT_PLAYER;
              else
              <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> r_Index   &lt;= r_Index + 1;
                 r_SM_Main &lt;= PATTERN_OFF;
              end if;
            end if;
<var>--snip--</var></code></pre>
<p class="TX">First we handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp> state <span aria-label="annotation1" class="CodeAnnotation">❶</span>, where we wait for the reset condition to be removed. This happens when switches 1 and 2 are released <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Notice that we’re looking not only for a low on the two switches, but also for a high on <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>. We use this signal throughout the module to detect falling edges—that is, releases—on the four switches. You’ll see how this works later in the code. When the reset is cleared, we set the score and the pattern index to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, then go into the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> state.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> state <span aria-label="annotation3" class="CodeAnnotation">❸</span> simply waits for a timer, driven by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And _Toggle</samp> module, to expire. When this happens we transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN _SHOW</samp> state <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, during which we’ll be illuminating one of the LEDs (you’ll see the code for illuminating the LEDs later). The transition out of <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> is also triggered by the timer in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module. When the timer expires we need to decide if we’re done displaying the pattern, which we do by checking whether the player’s score (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp>) equals the current index into the pattern (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>) <span aria-label="annotation5" class="CodeAnnotation">❺</span>. If it doesn’t, we aren’t done, so we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> to get ready to light up the next LED in the pattern <span aria-label="annotation7" class="CodeAnnotation">❼</span> and we go back to the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> state. If we are done, we reset <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <span aria-label="annotation6" class="CodeAnnotation">❻</span> and transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> state. Let’s look at that now:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
       WAIT_PLAYER:
       begin
       <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if (r_Button_DV)
          <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (r_Pattern[r_Index] == r_Button_ID &amp;&amp; r_Index == o_Score)
             begin
               r_Index   &lt;= 0;
               r_SM_Main &lt;= INCR_SCORE;
             end
          <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> else if (r_Pattern[r_Index] != r_Button_ID)
               r_SM_Main &lt;= LOSER;
          <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> else
               r_Index &lt;= r_Index + 1;
       end
<var>--snip--</var></code></pre>
<p class="Label"><span aria-label=" Page 175. " epub:type="pagebreak" id="pg_175" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
        when WAIT_PLAYER =&gt;
        <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if r_Button_DV = '1' then
           <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (r_Pattern(r_Index) = r_Button_ID and
                <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> unsigned(w_Index_SLV) = r_Score) then
                r_Index   &lt;= 0;
                r_SM_Main &lt;= INCR_SCORE;
           <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> elsif r_Pattern(r_Index) /= r_Button_ID then
                r_SM_Main &lt;= LOSER;
           <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> else
                r_Index &lt;= r_Index + 1;
              end if;
           end if;
<var>--snip--</var></code></pre>
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> state, we wait for <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp> to go high, indicating the player has pressed and released a switch <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we check if the player has correctly pressed the next switch in the pattern. As you’ll see later, each time any switch is released, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp> is set to indicate which switch it was (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> for switch 1, <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> for switch 2, and so on), so we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp> with a value in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>, using <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> as an index into the 2D array. There are three possibilities. If the switch is correct and we’re at the end of the pattern <span aria-label="annotation2" class="CodeAnnotation">❷</span>, we reset <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> and transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> state. If the switch is incorrect, we transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp> state <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Otherwise, the switch is correct but we aren’t done with the pattern, so we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> and wait for the next press <span aria-label="annotation5" class="CodeAnnotation">❺</span>. Notice in this last case that we don’t explicitly assign the state, so <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> will just retain its previous assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>). We could add a line at the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement that says <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER;</samp> but it’s not necessary. If <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> isn’t assigned, then we know that path doesn’t cause a state change.</p>
<p class="TX">One difference between the Verilog and the VHDL is that in the latter we need to be very explicit about the types we’re comparing. In the VHDL only, we need to cast <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> type <span aria-label="annotation3" class="CodeAnnotation">❸</span> so that we can compare it to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>, which is also of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>. Verilog is much more forgiving, so we don’t need this extra conversion. We’ll discuss numerical data types in detail in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>.</p>
<p class="TX">Now let’s look at the remaining states in the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
         // Used to increment score counter
      <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> INCR_SCORE:
         begin
           o_Score &lt;= o_Score + 1;
           if (o_Score == GAME_LIMIT-1)
             r_SM_Main &lt;= WINNER;
           else
             r_SM_Main &lt;= PATTERN_OFF;
         end
         // Display 0xA on 7-segment display, wait for new game
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> WINNER:
         begin
           o_Score &lt;= 4'hA; // Winner!
         end
         // Display 0xF on 7-segment display, wait for new game
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> LOSER:
         begin
           o_Score &lt;= 4'hF; // Loser!
         end
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> default:
           r_SM_Main &lt;= START;
      endcase
    end
  end
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
          -- Used to increment score counter
       <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> when INCR_SCORE =&gt;
            r_Score &lt;= r_Score + 1;
            if r_Score = GAME_LIMIT then
              r_SM_Main &lt;= WINNER;
            else
              r_SM_Main &lt;= PATTERN_OFF;
            end if;
          -- Display 0xA on 7-segment display, wait for new game
       <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> when WINNER =&gt;
            r_Score &lt;= X"A"; -- Winner!
          -- Display 0xF on 7-segment display, wait for new game
       <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> when LOSER =&gt;
            r_Score &lt;= X"F"; -- Loser!
       <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> when others =&gt;
            r_SM_Main &lt;= START;
       end case;
     end if;
   end if;
  end process;
<var>--snip--</var></code></pre>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>, we increment the score variable and compare it with <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp> to check if the game is over. If so, we go to the <samp class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp> state, and if not, we go back to <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> to continue the memory sequence. Notice that we’ll only be in this state for a single clock cycle. You could perhaps make the argument that <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> isn’t a necessary state, and that this logic should happen in <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> instead. I chose to treat <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> as a separate state to avoid making <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> too complicated.</p>
<p class="TX"><span aria-label=" Page 177. " epub:type="pagebreak" id="pg_177" role="doc-pagebreak"/>For the <samp class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span> states, we simply set the score value to show an A or F on the seven-segment display and remain in the current state. The state machine can only leave these states in the event of a reset condition, in which switches 1 and 2 are both pressed at the same time.</p>
<p class="TX">We also include a default clause at the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, which specifies what behavior to take in the event that <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> isn’t one of the previously defined states. This shouldn’t ever happen, but it’s good practice to create a default case where we go back to <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> statements at the end of this listing close out the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement, <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statement, and <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block that the state machine was wrapped in.</p>
<p class="TX">We’ve now finished coding the state machine itself. The rest of the code in the module handles logic for helping with the tasks that occur during the various states. First we have the code for randomly generating the pattern:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
  // Register in the LFSR to r_Pattern when game starts
  // Each 2 bits of LFSR is one value for r_Pattern 2D array
  always @(posedge i_Clk)
  begin
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if (r_SM_Main == START)
     begin
       r_Pattern[0]  &lt;= w_LFSR_Data[1:0];
       r_Pattern[1]  &lt;= w_LFSR_Data[3:2];
       r_Pattern[2]  &lt;= w_LFSR_Data[5:4];
       r_Pattern[3]  &lt;= w_LFSR_Data[7:6];
       r_Pattern[4]  &lt;= w_LFSR_Data[9:8];
       r_Pattern[5]  &lt;= w_LFSR_Data[11:10];
       r_Pattern[6]  &lt;= w_LFSR_Data[13:12];
       r_Pattern[7]  &lt;= w_LFSR_Data[15:14];
       r_Pattern[8]  &lt;= w_LFSR_Data[17:16];
       r_Pattern[9]  &lt;= w_LFSR_Data[19:18];
       r_Pattern[10] &lt;= w_LFSR_Data[21:20];
     end
  end
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
  -- Register in the LFSR to r_Pattern when game starts
  -- Each 2 bits of LFSR is one value for r_Pattern 2D array
  process (i_Clk) is
  begin
     if rising_edge(i_Clk) then
     <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if r_SM_Main = START then
          r_Pattern(0)  &lt;= w_LFSR_Data(1 downto 0);
          r_Pattern(1)  &lt;= w_LFSR_Data(3 downto 2);
          r_Pattern(2)  &lt;= w_LFSR_Data(5 downto 4);
          r_Pattern(3)  &lt;= w_LFSR_Data(7 downto 6);
          r_Pattern(4)  &lt;= w_LFSR_Data(9 downto 8);
          r_Pattern(5)  &lt;= w_LFSR_Data(11 downto 10);
          r_Pattern(6)  &lt;= w_LFSR_Data(13 downto 12);
          r_Pattern(7)  &lt;= w_LFSR_Data(15 downto 14);
          r_Pattern(8)  &lt;= w_LFSR_Data(17 downto 16);<span aria-label=" Page 178. " epub:type="pagebreak" id="pg_178" role="doc-pagebreak"/>
          r_Pattern(9)  &lt;= w_LFSR_Data(19 downto 18);
          r_Pattern(10) &lt;= w_LFSR_Data(21 downto 20);
        end if;
     end if;
  end process;
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> w_Index_SLV &lt;= std_logic_vector(to_unsigned(r_Index, w_Index_SLV'length));
<var>--snip--</var></code></pre>
<p class="TX">We need to generate a different pattern each time the game is played, while also making sure the pattern gets “locked in” once the game is underway. To do this, we first check if we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp> state <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If so, the game isn’t currently in progress, so we use the LFSR to create a new pattern. Recall that the output of our LFSR is a pseudorandom string of bits, which changes on every clock cycle. We take 2-bit sections from the LFSR output and place them into the 11 slots in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>. This will keep happening every clock cycle until the player releases switches 1 and 2, triggering the transition out of <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>. At that point, the current values of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp> will be locked in for the duration of the game.</p>
<p class="TX">In VHDL, we also need to create an intermediary signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, which is just the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> representation of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>. Again, since VHDL is strongly typed, you’ll often see intermediary signals used for generating the “correct” signal types. I could have put this line anywhere since it’s a combinational assignment; as long as it’s outside of a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, its precise location in the file makes no functional difference.</p>
<p class="TX">Next comes the code for illuminating the four LEDs:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
  assign o_LED_1 = (r_SM_Main == PATTERN_SHOW &amp;&amp;
                    r_Pattern[r_Index] == 2'b00) ? 1'b1 : i_Switch_1;
  assign o_LED_2 = (r_SM_Main == PATTERN_SHOW &amp;&amp;
                    r_Pattern[r_Index] == 2'b01) ? 1'b1 : i_Switch_2;
  assign o_LED_3 = (r_SM_Main == PATTERN_SHOW &amp;&amp;
                    r_Pattern[r_Index] == 2'b10) ? 1'b1 : i_Switch_3;
  assign o_LED_4 = (r_SM_Main == PATTERN_SHOW &amp;&amp;
                    r_Pattern[r_Index] == 2'b11) ? 1'b1 : i_Switch_4;
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
  o_LED_1 &lt;= '1' when (r_SM_Main = PATTERN_SHOW and
                       r_Pattern(r_Index) = "00") else i_Switch_1;
  o_LED_2 &lt;= '1' when (r_SM_Main = PATTERN_SHOW and
                       r_Pattern(r_Index) = "01") else i_Switch_2;
  o_LED_3 &lt;= '1' when (r_SM_Main = PATTERN_SHOW and
                       r_Pattern(r_Index) = "10") else i_Switch_3;
  o_LED_4 &lt;= '1' when (r_SM_Main = PATTERN_SHOW and
                       r_Pattern(r_Index) = "11") else i_Switch_4;
<var>--snip--</var></code></pre>
<p class="TX">Here we have four continuous assignment statements, one for each LED. In each one, we use the ternary operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>) in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">when/else</samp> in VHDL to <span aria-label=" Page 179. " epub:type="pagebreak" id="pg_179" role="doc-pagebreak"/>illuminate the LED in one of two cases. First, we’ll drive the LED high if we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> state and the value at the current index of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp> matches the current LED. This will only ever be true for one LED at a time, so only one LED can be illuminated during each <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>. Second, if we aren’t in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> state, the LED will be driven based on the input from its associated switch. This way the LED will light up when the player presses the corresponding switch, giving them visual feedback about the pattern they’re entering.</p>
<p class="TX">The next part of the code uses falling edge detection to identify timeouts and button presses:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
  // Create registers to enable falling edge detection
  always @(posedge i_Clk)
  begin
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> r_Toggle   &lt;= w_Toggle;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Switch_1 &lt;= i_Switch_1;
     r_Switch_2 &lt;= i_Switch_2;
     r_Switch_3 &lt;= i_Switch_3;
     r_Switch_4 &lt;= i_Switch_4;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if (r_Switch_1 &amp; !i_Switch_1)
     begin
       r_Button_DV &lt;= 1'b1;
       r_Button_ID &lt;= 0;
     end
     else if (r_Switch_2 &amp; !i_Switch_2)
     begin
       r_Button_DV &lt;= 1'b1;
       r_Button_ID &lt;= 1;
     end
     else if (r_Switch_3 &amp; !i_Switch_3)
     begin
       r_Button_DV &lt;= 1'b1;
       r_Button_ID &lt;= 2;
     end
     else if (r_Switch_4 &amp; !i_Switch_4)
     begin
       r_Button_DV &lt;= 1'b1;
       r_Button_ID &lt;= 3;
     end
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> else
     begin
       r_Button_DV &lt;= 1'b0;
       r_Button_ID &lt;= 0;
     end
  end
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
  -- Create registers to enable falling edge detection
  process (i_Clk) is
  begin<span aria-label=" Page 180. " epub:type="pagebreak" id="pg_180" role="doc-pagebreak"/>
    if rising_edge(i_Clk) then
    <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> r_Toggle   &lt;= w_Toggle;
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Switch_1 &lt;= i_Switch_1;
       r_Switch_2 &lt;= i_Switch_2;
       r_Switch_3 &lt;= i_Switch_3;
       r_Switch_4 &lt;= i_Switch_4;
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if r_Switch_1 = '1' and i_Switch_1 = '0' then
         r_Button_DV &lt;= '1';
         r_Button_ID &lt;= "00";
       elsif r_Switch_2 = '1' and i_Switch_2 = '0' then
         r_Button_DV &lt;= '1';
         r_Button_ID &lt;= "01";
       elsif r_Switch_3 = '1' and i_Switch_3 = '0' then
         r_Button_DV &lt;= '1';
         r_Button_ID &lt;= "10";
       elsif r_Switch_4 = '1' and i_Switch_4 = '0' then
         r_Button_DV &lt;= '1';
         r_Button_ID &lt;= "11";
    <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> else
         r_Button_DV &lt;= '0';
         r_Button_ID &lt;= "00";
       end if;
    end if;
  end process;
<var>--snip--</var></code></pre>
<p class="TX">Notice we are still using the rising edge of the clock; we’re just looking for falling edges for our timeouts and button presses. Recall that this falling edge is used to progress through the state machine. We perform falling edge detection on the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module, where the output represents the timer expiring. We do this by first registering its output, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp>, and assigning it to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. (The actual instantiation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module will be handled momentarily.) This creates a one-clock-cycle-delayed version of <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp> on <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>. Then, as shown previously, we look for the condition where the current value (<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp>) is low, but the previous value (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>) is high. We used this earlier to trigger transitions out of <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>.</p>
<p class="TX">For our switches, when a switch is pressed, it has the value 1; when a switch is not pressed, it has the value 0. We are looking for the situation in which the switch goes from a 1 to a 0, which is the falling edge of the switch, representing the switch being released. We register each switch <span aria-label="annotation2" class="CodeAnnotation">❷</span> in order to detect the falling edge from the switch being released. This is followed by the actual edge detection logic <span aria-label="annotation3" class="CodeAnnotation">❸</span>. For each switch, when we see a falling edge, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp> high. As you’ve seen elsewhere in the code, this signal serves as a flag to indicate that some switch, any switch, has been released. We also set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp> to the switch’s 2-bit binary code, so we’ll know which switch it was. The <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> clears <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp> to get ready for the next falling edge.</p>
<p class="NOTE"><span aria-label=" Page 181. " epub:type="pagebreak" id="pg_181" role="doc-pagebreak"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>I’ve chosen to make the state machine react to button releases rather than button presses. You could try inverting the test cases</i> <span aria-label="annotation3" class="CodeAnnotation">❸</span> <i>to see the difference. I think you’ll find it a bit unnatural if the game responds the moment a button is pressed instead of the moment it’s released.</i></p>
<p class="TX">The final section of the code instantiates the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR_22</samp> modules. Remember, you’ve seen the code for these modules before, in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
   // w_Count_En is high when state machine is in
   // PATTERN_SHOW state or PATTERN_OFF state, else low
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> assign w_Count_En = (r_SM_Main == PATTERN_SHOW ||
                        r_SM_Main == PATTERN_OFF);
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Count_And_Toggle #(.COUNT_LIMIT(CLKS_PER_SEC/4)) Count_Inst
    (.i_Clk(i_Clk),
     .i_Enable(w_Count_En),
     .o_Toggle(w_Toggle));
   // Generates 22-bit-wide random data
<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> LFSR_22 LFSR_Inst
    (.i_Clk(i_Clk),
     .o_LFSR_Data(w_LFSR_Data),
   <span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> .o_LFSR_Done()); // leave unconnected
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
   -- w_Count_En is high when state machine is in
   -- PATTERN_SHOW state or PATTERN_OFF state, else low
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> w_Count_En &lt;= '1' when (r_SM_Main = PATTERN_SHOW or
                           r_SM_Main = PATTERN_OFF) else '0';
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Count_Inst : entity work.Count_And_Toggle
   generic map (
     COUNT_LIMIT =&gt; CLKS_PER_SEC/4)
   port map (
     i_Clk   =&gt; i_Clk,
     i_Enable =&gt; w_Count_En,
     o_Toggle =&gt; w_Toggle);
   -- Generates 22-bit-wide random data
<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> LFSR_Inst : entity work.LFSR_22
   port map (
     i_Clk       =&gt; i_Clk,
     o_LFSR_Data =&gt; w_LFSR_Data,
   <span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> o_LFSR_Done =&gt; open); -- leave unconnected
<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> o_Score &lt;= std_logic_vector(r_Score);
end RTL;</code></pre>
<p class="TX"><span aria-label=" Page 182. " epub:type="pagebreak" id="pg_182" role="doc-pagebreak"/>First we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module <span aria-label="annotation2" class="CodeAnnotation">❷</span>. As you saw in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, it measures out a set amount of time by incrementing a register on each clock cycle until it reaches the <samp class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp> parameter/generic. Here we’ve set <samp class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp> to make each <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> state last a quarter of a second, but feel free to change this to make the game run faster or slower. Keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp> is a constant (in this case, 25,000,000 / 4 = 6,250,000) that the synthesis tools will calculate in advance, so the division operation (which would require a lot of resources) won’t have to be performed inside the FPGA itself. The continuous assignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Count_En</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span> only enables the counter during the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> states, since we don’t want it running during other phases of the game.</p>
<p class="TX">Next, we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR_22</samp> module <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Recall from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> that this module has two outputs: <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> for the data itself, and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp> to signal each repetition of the LFSR’s cycle. For this project we don’t need <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp>, so we leave the unused output unconnected in Verilog, or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> keyword in VHDL <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. When we write general-purpose modules like this, we won’t always need every single output in every single application. When we don’t use an output, the synthesis tools are intelligent enough to remove the associated logic, so there’s no hit to our resource utilization when we have unused code.</p>
<p class="TX">Finally, in VHDL we need to perform one more action: converting <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>, which is an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> type, to a <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> so we can assign that value to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp> <span aria-label="annotation5" class="CodeAnnotation">❺</span>. Because VHDL is strongly typed, you’ll frequently see type conversions like this when looking at VHDL code.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Memory Game</samp></h3>
<p class="TNI1">The code and state machine diagram that we’ve been looking at here represent the final version of this game, but it went through some improvements and fixes as I developed it. A lot of the changes were a result of me actually playing the game and experimenting to see what I liked and didn’t like. For example, when I was first designing the state machine, I went straight from <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> without passing through <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>. This made the first LED come on immediately, which was confusing; it was hard to tell whether the game had started or not. So, I switched the order to add a delay at the outset.</p>
<p class="TX">Most of the changes that I made followed this same pattern: program the board, play the game, see behavior I don’t like, change the code, play the game. Another example is that the LED on-time was too long initially, so I decreased it to make the gameplay snappier. These sorts of issues are more about feel; running a simulation wouldn’t have identified them.</p>
<p class="TX">Simulations and testbenches are valuable for understanding where and why bugs are occurring and how to fix them. Most of my “problems” weren’t bugs, but behaviors that I wanted to change based on my experience playing the game. I did create a testbench that allowed me to simulate button presses, however, to see how the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module <span aria-label=" Page 183. " epub:type="pagebreak" id="pg_183" role="doc-pagebreak"/>responded. That code is available in the book’s GitHub repository, if you’d like to look at it. It’s a simple testbench, not one that performs any self-checking, but it did help me find a few bugs when I was initially writing this state machine.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2" id="sec14"><span id="h-111"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Pin Constraints</samp></h3>
<p class="TNI1">Since we’ve added a new interface at the highest level (the seven-segment display), we need to add those signals to our physical constraints file. If we forget this step, the place and route tool will likely automatically choose pins for us, which will almost certainly be incorrect. You’ll have to refer to the schematic for your development board to trace the signal paths from the seven-segment display back to your FPGA for each signal. Here are the constraints needed for the Go Board, for example:</p>
<pre><code>set_io o_Segment2_A 100
set_io o_Segment2_B 99
set_io o_Segment2_C 97
set_io o_Segment2_D 95
set_io o_Segment2_E 94
set_io o_Segment2_F 8
set_io o_Segment2_G 96</code></pre>
<p class="TX">See <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> for a reminder on how to add physical constraints to your iCEcube2 project.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H2" id="sec15"><span id="h-112"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming the FPGA</samp></h3>
<p class="TNI1">At this point, we’re ready to build the code for the FPGA. Let’s take a look at the synthesis results of both the Verilog and the VHDL. Your report should look similar to the following:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
Register bits not including I/Os: 164 (12%)
<var>--snip--</var>
Total LUTs: 239 (18%)</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
Register bits not including I/Os: 163 (12%)
<var>--snip--</var>
Total LUTs: 225 (17%)</code></pre>
<p class="TX">The results are pretty close between the Verilog and VHDL versions; we’re using about 12 percent of the available flip-flops and 18 percent of the available LUTs for this project. We have an entire memory game consisting of a few hundred lines of code, and we’ve used less than 20 percent of the FPGA’s main resources. Not bad!</p>
<p class="TX">Program your development board and play the game. See if you can beat it, and if you can, try increasing the difficulty by changing <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp> up to its maximum difficulty of 11. I found it quite challenging!</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h2 class="H1" id="sec16"><span id="h-113"/><span aria-label=" Page 184. " epub:type="pagebreak" id="pg_184" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">In this chapter you’ve learned about state machines, which are critical building blocks in many programming disciplines, including FPGAs. State machines are used to precisely control the flow through a sequence of operations. The operations are organized into a network of states, with events that trigger transitions between those states. After reviewing a simple example, you designed and implemented a sophisticated state machine to control a memory game for your development board. The project combined many elements that we’ve discussed throughout the book, including debounce logic to clean up the inputs from the switches, an LFSR for pseudorandom number generation, and a counter to keep track of time. You also learned to use a seven-segment display to create the game’s scoreboard.</p>
</section>
</section>
</body>
</html>