- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UML ACTIVITY DIAGRAMS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: UML *activity diagrams*, traditionally known as *flowcharts*, illustrate the
    workflow between different components of a system. Flowcharts were prevalent in
    the early days of software development and were still used in software design
    just before the rise of object-oriented programming (OOP). Although the UML object-oriented
    notation supersedes old-fashioned flowcharting to a large extent, OOP still relies
    on small methods, functions, and procedures to implement the low-level, nitty-gritty
    details, and flowcharting is useful for describing control flow in those cases.
    Hence, UML’s designers created activity diagrams as an updated version of flowcharting.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.1 UML Activity State Symbols**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UML activity diagrams use state symbols based on traditional flowchart symbols.
    This section describes some of the ones you’ll commonly use.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want information on general flowcharting, any web search should yield
    decent results.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.1 Start and Stop States***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UML diagrams always contain a single *start state*, which represents the start
    terminal object. This consists of a solid circle with a single arrow (*transition*
    in UML parlance) coming from it. You might associate the start state with a label,
    which would be the name of the whole activity diagram.
  prefs: []
  type: TYPE_NORMAL
- en: UML also usually contains *end state* and *end flow* symbols. An end state symbol
    terminates an entire process, while an end flow symbol terminates a single thread,
    useful for processes that involve multiple threads of execution. You might associate
    the end state symbol with a label that indicates the system’s state at the end
    of the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1](ch05.xhtml#ch5fig1) shows the start state, end state, and end
    flow symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: UML starting and ending states*'
  prefs: []
  type: TYPE_NORMAL
- en: While an activity diagram has only one starting state symbol, it might have
    multiple ending state symbols (think of a method returning from several points
    in the code). The labels attached to the various ending states will likely be
    different, such as “exception exit” and “normal exit.”
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.2 Activities***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Activity symbols in UML are rectangles with semicircular ends (like the terminal
    symbol in a flowchart) that represent some action, as shown in [Figure 5-2](ch05.xhtml#ch5fig2).^([1](ch19_footnote.xhtml#ch05fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: UML activities*'
  prefs: []
  type: TYPE_NORMAL
- en: Activities, as a general rule, correspond to one or more statements (actions)
    in a programming language that execute sequentially. The text inside the symbol
    describes the action to perform, such as “read data” or “compute CRC.” Generally,
    a UML activity doesn’t include much low-level detail; it’s the programmer’s job
    to provide that.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.3 States***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UML activity diagrams also provide intermediate states, in addition to start
    and end states, which effectively act as milestones indicating some existing condition(s)
    at the point of the state symbol. State symbols are rounded rectangles (*roundangles*),
    as shown in [Figure 5-3](ch05.xhtml#ch5fig3), although the rounded corners are
    much smaller than those of activity symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: UML states*'
  prefs: []
  type: TYPE_NORMAL
- en: The text in the state symbol should describe the state of the system at that
    given point. For example, if the activity is “compute CRC,” you might label the
    state immediately following it as “CRC computed” or “CRC available.” States don’t
    incorporate any action, only the current condition of the system at a given point.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.4 Transitions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Transitions indicate a flow of control from one point in an activity diagram
    (for example, a state or activity) to another. If a transition flows out of some
    activity, it means the system makes that transition upon completing most of the
    actions associated with that activity. If a pair of transitions flows into and
    out of a state, control flow transfers immediately to wherever the outgoing arrow
    points. A UML state is effectively a marker in the middle of a transition, and
    so no action takes place in a UML state, as shown in [Figure 5-4](ch05.xhtml#ch5fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Control flow through a state*'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.5 Conditionals***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can handle conditionals in a couple of different ways in a UML activity
    diagram: transition guards and decision points.'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.1.5.1 Transition Guards**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In conditionals, a Boolean expression is attached to a transition symbol. UML
    calls these Boolean expressions *guards*. A conditional UML symbol must have at
    least two guarded transitions, which are labeled with expressions surrounded by
    square brackets, but might have more than two, as in [Figure 5-5](ch05.xhtml#ch5fig5)
    (where the hexagon shape represents an arbitrary UML symbol).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: Transition guards*'
  prefs: []
  type: TYPE_NORMAL
- en: The set of Boolean expressions must be mutually exclusive; that is, only one
    expression can be `true` at all times. Furthermore, the expression coverage must
    be *complete*, which in this context means that for all possible combinations
    of input values, at least one Boolean expression in a set of guarded transitions
    must evaluate to `true` (which, combined with the first condition, means *exactly
    one* Boolean condition must evaluate to `true`).
  prefs: []
  type: TYPE_NORMAL
- en: If you want a “catch-all” transition to handle any input values that the existing
    guards don’t handle, just attach a word like *else*, *otherwise*, or *default*
    to a transition (see [Figure 5-6](ch05.xhtml#ch5fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: Catch-all transition guard*'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.1.5.2 Decision Points**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Transitions with guards can exit just about any UML symbol; state and action
    symbols often contain them. Problems can occur, however, if you have several actions
    or states merging into a single point at which a decision can create divergent
    paths. For this, UML provides a special symbol, the *decision point*, to cleanly
    collect and join paths where a decision branch occurs. Decision points use a diamond-shaped
    symbol, as shown in [Figure 5-7](ch05.xhtml#ch5fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: A UML decision point*'
  prefs: []
  type: TYPE_NORMAL
- en: Although UML allows guarded transitions to emanate from any UML symbol, it’s
    good practice to always use a decision point to begin a set of related guarded
    transitions.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.6 Merge Points***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In UML we can also use the diamond shape to collect several incoming transitions
    into a single outgoing transition, as shown in [Figure 5-8](ch05.xhtml#ch5fig8);
    we call this a *merge point*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: A UML merge point*'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, a merge point and a decision point are the same object type. Essentially,
    a merge point is an unnamed state object; it takes no action other than passing
    control from all the incoming transitions to the outgoing transition. A decision
    point is just a special case of a merge point that has multiple outgoing guarded
    transitions.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, a merge point could have both multiple incoming and outgoing guarded
    transitions. However, the result would be so ugly that the common convention is
    instead to divide the single point into separate merge and decision points, as
    shown in [Figure 5-9](ch05.xhtml#ch5fig9). Most of the time, this separation is
    clearer and easier to read than the alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-9: UML merge and decision points*'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.7 Events and Triggers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Events and triggers are actions outside the current flow of control, typically
    from some other thread of execution or hardware input, that cause some change
    in it.^([2](ch19_footnote.xhtml#ch05fn2)) In UML, event and trigger transitions
    are syntactically similar to guarded transitions in that they consist of a labeled
    transition. The difference is that a guarded transition immediately evaluates
    some Boolean expression and transfers control to the UML symbol at the other end
    of the transition, whereas an event or trigger transition waits for the event
    or trigger to occur before transferring control.
  prefs: []
  type: TYPE_NORMAL
- en: Event and trigger transitions are labeled with the name of the event or trigger
    along with any necessary parameters provided to the control flow when it occurs
    (see [Figure 5-10](ch05.xhtml#ch5fig10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-10: UML events or triggers*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the system is waiting for input from the user (perhaps clicking
    a UI button on the display). When the user activates the save, exit, or load operation,
    control transfers to the specified action at the end of the event or trigger transition
    (Save file, Quit program, or Load file, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: You can also attach guard conditions to an event or trigger transition, consisting
    of a Boolean expression inside square brackets immediately following the trigger
    or event, as shown in [Figure 5-11](ch05.xhtml#ch5fig11). When you do so, the
    transition occurs only when the event or trigger occurs and the guard expression
    evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-11: Guard conditions on events or triggers*'
  prefs: []
  type: TYPE_NORMAL
- en: UML events and triggers also support action expressions and multiple actions,
    which are beyond the scope of this chapter. To find out more, check out examples
    in Tom Pender’s *UML Bible* (see “[For More Information](ch05.xhtml#lev-5.3)”
    on [page 100](ch05.xhtml#page_100)).
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.8 Forks and Joins (Synchronization)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UML offers support for concurrent processing by providing symbols to split a
    single thread of execution into multiple threads as well as to join multiple threads
    of execution into a single thread (see [Figure 5-12](ch05.xhtml#ch5fig12)).^([3](ch19_footnote.xhtml#ch05fn3))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-12: Forks and joins*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UML *fork* operation (a thin, solid rectangle) splits a single thread of
    execution into two or more concurrent operations. The *join* operation (also represented
    by a thin, solid rectangle) merges multiple sets of threads into a single thread
    of execution. The join operation also synchronizes the threads: the diagram assumes
    that all but the last thread entering the join operation will halt until the final
    thread arrives, at which point a single thread of execution continues on output.'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.9 Call Symbols***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A call symbol in UML, which looks like a small rake, attaches to an activity
    to explicitly declare it as an invocation of another UML sequence. You include
    the call symbol inside the UML activity along with the name of the sequence to
    invoke, as shown in [Figure 5-13](ch05.xhtml#ch5fig13).
  prefs: []
  type: TYPE_NORMAL
- en: Elsewhere in your UML document, you’ll define that sequence (or *subroutine*)
    using the invocation name as the activity diagram name, as shown in [Figure 5-14](ch05.xhtml#ch5fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-13: A UML sequence invocation*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-14: A UML subroutine*'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.10 Partitions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Partitions, which organize the steps of a process, consist of several side-by-side
    rectangular boxes, each labeled at the top with an actor, object, or domain name.^([4](ch19_footnote.xhtml#ch05fn4))
    The activity diagram transitions between the boxes as each part of the process
    comes under the control of the owner of a given box, as shown in [Figure 5-15](ch05.xhtml#ch5fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-15: A UML partition*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process in [Figure 5-15](ch05.xhtml#ch5fig15) shows some code under test.
    An operator selects a test to run, passing control to the test software. An event
    or trigger then transfers control to the “Run test #1” action. The test software
    calls the code under test (in the third partition). After the code under test
    executes, control returns to the test software, which determines whether the test
    passed or failed. If the test passes, the test code displays “Pass” to the operator;
    other­wise, the test code runs a diagnostic routine.'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.11 Comments and Annotations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Comments and annotations in UML use an icon that looks like a small page with
    a folded corner, as shown in [Figure 5-16](ch05.xhtml#ch5fig16). You draw a dashed
    line from one side of the box to the UML item you want to annotate.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-16: A UML comment or annotation*'
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.12 Connectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Connectors are circles with an internal label, typically a number, that indicate
    that control transfers to some other point in the diagram with the same label
    (see [Figure 5-17](ch05.xhtml#ch5fig17)). You’d use the same symbol for on-page
    and off-page connectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-17: UML connectors*'
  prefs: []
  type: TYPE_NORMAL
- en: When used properly, UML connectors can make an activity diagram easier to read
    by reducing long or overlapping transition lines. However, keep in mind that connectors
    are the UML equivalent of a `goto` statement in a programming language, and overuse
    can make diagrams more difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: '***5.1.13 Additional Activity Diagram Symbols***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The full UML 2.0 specification provides many additional symbols you can use
    in activity diagrams, such as structured activities, expansion regions/nodes,
    conditional nodes, loop nodes, and more. We don’t have space to discuss them all
    in this book’s basic introduction to UML, but if you’re interested in more details,
    see the sources listed in “For More Information” on [page 100](ch05.xhtml#page_100)
    or search online for “UML.”
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2 Extending UML Activity Diagrams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the UML activity diagram notation just doesn’t cut it. In such cases,
    you might be tempted to come up with your own custom symbols. This is almost always
    a bad idea, for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: UML is a *standard*. If you extend UML, you’re no longer using a well-defined
    standard. That means all the people who’ve learned UML won’t be able to read your
    activity diagrams unless they first read your documentation (and will that documentation
    be available to them in your nonstandard activity diagrams?).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many UML diagramming tools available for creating and editing UML
    activity diagrams, and most of them can’t handle nonstandard symbols and objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many computer-aided software engineering (CASE) tools can generate code directly
    from a UML diagram. Again, these CASE tools work only with standard UML and probably
    won’t be able to handle your nonstandard extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can’t figure out how to do something in a UML activity diagram, you may
    be able to use some other scheme. Using a nonstandard way to do a task that you
    can easily do with standard tools may come across to other UML users as an amateur
    approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All that being said, UML is far from perfect. In rare cases, developing some
    nonstandard activity diagram objects can vastly simplify your activity diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a concurrent programming *critical section*, a region
    of code in which only one thread of execution can take place at a time. UML sequence
    diagrams (the subject of [Chapter 7](ch07.xhtml)) use *sequence fragment* notation
    to describe concurrency with critical regions. Although you could adapt sequence
    fragment notation to activity diagrams, the result is messy and hard to read and
    understand. In some activity diagrams I’ve created for personal projects, I used
    the custom notation in [Figure 5-18](ch05.xhtml#ch5fig18) to indicate critical
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-18: A nonstandard critical region diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: Arrows coming in to the pentagon on the left indicate transitions (generally
    from different threads) competing for a critical section. The single line out
    of the pentagon represents the single thread of execution that takes place in
    the critical section. The pentagon on the right accepts that single thread of
    execution and routes it back to the original thread (for example, if T1 was the
    thread that entered the critical section, the close of the critical section routes
    control back to the T1 transition/flow).
  prefs: []
  type: TYPE_NORMAL
- en: This diagram doesn’t imply that there are only five threads that can use this
    critical section. Instead, it conveys that there are five activity diagram flows
    (T1–T5) that could compete for the critical resource. In fact, there could be
    multiple threads executing any one of these flows that are also competing for
    the critical region. For example, there could be three threads all executing the
    T1 flow and waiting for the critical region to be available.
  prefs: []
  type: TYPE_NORMAL
- en: Because multiple threads could be executing on the same flow in the critical
    section diagram, it’s quite possible to have only a single flow entering the critical
    region (see [Figure 5-19](ch05.xhtml#ch5fig19)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig5-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-19: A single-flow critical region diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: This example requires that multiple threads execute the same flow (T1) for this
    diagram to make any sense.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even a simple diagram like this requires a fair amount of documentation
    to describe and validate it. If that documentation isn’t readily available (that
    is, if it’s not embedded directly in your UML activity diagrams), readers probably
    won’t find it when they’re trying to understand your diagram. Annotating a nonstandard
    object directly within the diagram is the only reasonable approach. Placing meaningful
    documentation in a separate section of the document containing the activity diagrams
    (such as the SDD document), or in a separate document altogether, makes this information
    unavailable when someone cuts and pastes your diagram into a different document.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The critical region diagram in [Figure 5-19](ch05.xhtml#ch5fig19) is simply
    an example of how you might extend UML activity diagrams. In general, I don’t
    recommend adopting it in your own diagrams, nor do I recommend extending UML notation.
    However, you should know that the option is available if you really need it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2004.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pilone, Dan, and Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    2nd ed. Sebastopol, CA: O’Reilly Media, 2005.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  prefs: []
  type: TYPE_NORMAL
- en: Tutorials Point. “UML Tutorial.” [*https://www.tutorialspoint.com/uml/*](https://www.tutorialspoint.com/uml/).
  prefs: []
  type: TYPE_NORMAL
