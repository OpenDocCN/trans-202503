- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTROLLING
    AC MAINS POWER OUTLETS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn to safely control mains AC power outlets using
    various forms of automation and remote control. This technique lets you easily
    manipulate devices such as lamps, fans, and pumps from a distance, without any
    direct connection to the mains power wiring.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use optocouplers to isolate electrical signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hack a wireless AC mains remote-control transmitter and connect it to an Arduino
    circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a timer-controlled wireless AC mains outlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control AC mains outlets remotely with SMS text messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Optocouplers</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *optocoupler* is a small device that allows the transmission of a signal
    between parts of a circuit while keeping those two parts electrically isolated.
    Inside a typical optocoupler are an LED and a phototransistor, a device that responds
    to light by amplifying an electric current. When a current runs through the LED,
    it switches on; the phototransistor detects the light and allows another current
    to flow through it. When the LED is off, current cannot flow through the phototransistor.
    The two currents are completely electrically isolated throughout the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](chapter7.xhtml#fig7-1) shows the schematic symbol for an optocoupler.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC SYMBOL FOR A TYPICAL OPTOCOUPLER](../images/fig7-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The schematic symbol
    for a typical optocoupler</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the schematic, an LED is connected to pins 1 (the anode) and 2 (the cathode).
    Pins 4, 5, and 6 are the phototransistor, while pin 3 is not used. The optocoupler
    model you’ll use, the 4N28, is in a six-pin dual in-line (DIL) package, as shown
    in [Figure 7-2](chapter7.xhtml#fig7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A 4N28 OPTOCOUPLER INSERTED INTO A SOLDERLESS BREADBOARD](../images/fig7-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: A 4N28 optocoupler
    inserted into a solderless breadboard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To use the optocoupler, you’ll need a current-limiting resistor for the LED.
    You’ll use 1 kΩ for this chapter. Connect the circuit to switch on or off across
    pins 4 and 5\. If you’d like to experiment with an optocoupler, build the circuit
    shown in [Figure 7-3](chapter7.xhtml#fig7-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR AN OPTOCOUPLER DEMONSTRATION CIRCUIT](../images/fig7-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: An optocoupler
    demonstration circuit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When SW[1] is closed, current runs through the resistor R[1], and the LED inside
    the optocoupler illuminates. This in turn triggers the photoresistor, which allows
    current to flow through from pin 5 to pin 4, turning on LED D[1]. Pin 3 on the
    optocoupler is not electrically connected. This makes the optocoupler a switch
    of sorts, without any electrical or mechanical contact between the two sides of
    the switch.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use optocouplers to interface with the transmitter of the wireless remote
    AC outlet in the following projects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Remote-Control AC Outlets</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inexpensive wireless remote-control AC outlets, like the one shown in [Figure
    7-4](chapter7.xhtml#fig7-4), allow you to safely control mains power. In [Figure
    7-4](chapter7.xhtml#fig7-4), the transmitter is on the right, and the receiver
    outlet is on the left.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE EXAMPLE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER AND
    RECEIVER](../images/fig7-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: A typical wireless
    remote-control AC outlet</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The transmitter needs separate on and off buttons for control. Try to find
    one with as much space as possible between the buttons; the farther apart they
    are, the easier it will be to hack into the transmitter unit in Project #22, allowing
    you to connect it to an Arduino circuit to control the power outlet. You can find
    these units from the usual retailers, such as Amazon, Walmart, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Under no circumstances are you to open or modify the receiver unit containing
    the mains outlet, as exposing yourself to mains wiring can be lethal.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work through this chapter, I recommend buying two sets of controls: one
    to experiment with (so you don’t need to worry too much about breaking it) and
    another to use for the project.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hacking the Outlet Transmitter</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explains how to hack into your wireless transmitter to control
    it via an Arduino. I’ll show you with a series of photographs how I hacked into
    my remote, and you can use these guidelines to experiment with your remote to
    achieve the same goal. This requires some soldering and de-soldering, so be sure
    you’re equipped with a hobbyist 20 to 50 W soldering iron, hand tools such as
    side-cutters, and some de-soldering wick.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitters will be slightly different in shape, size, and so on, but make
    sure the one you purchase runs from a little 12 V A23-style battery and has separate
    on and off buttons, as noted earlier. Before doing any damage to the unit, insert
    the battery and test it to get an idea of how far between the transmitter and
    receiver in which you can use the outlet. [Figure 7-5](chapter7.xhtml#fig7-5)
    shows the battery in my transmitter.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A BATTERY INSIDE A WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER](../images/fig7-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: The battery in
    a wireless remote-control transmitter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Check for any screws or tabs you can use to pop the transmitter enclosure apart,
    and open it, as shown in [Figure 7-6](chapter7.xhtml#fig7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF INSIDE THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER](../images/fig7-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The wiring inside
    the wireless remote-control transmitter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This should reveal the PCB for the circuit, along with the buttons used to control
    the outputs. Carefully remove the PCB to check whether it looks possible to de-solder
    some of the buttons; if not, reassemble the unit and return it to your retailer.
    You should be able to de-solder buttons on any transmitters that fit the specs
    described earlier in this section, but it’s best to make sure, for example, that
    they’re the type that have buttons with through-hole pins.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to connect power. If there are already wires running from the
    battery holder to the PCB, like those shown in [Figure 7-7](chapter7.xhtml#fig7-7),
    carefully cut off or de-solder them using the solder wick from the battery holder
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF INSIDE THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER AND THE
    PCB PULLED OUT](../images/fig7-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: The power wires
    in the PCB</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, identify the PCB pads that contain the pins of the on and off buttons
    for the first (or only) outlet in the system by locating the buttons and then
    finding their matching pins on the other side of the PCB. Viewing the buttons
    from the bottom of the PCB (the side with the copper tracks), match the buttons’
    pins to the PCB pads.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the PCB uses standard tactile buttons with four legs, two for
    each contact. In [Figure 7-8](chapter7.xhtml#fig7-8), I’ve drawn lines between
    the pads of each side of the tactile switch to note which PCB pads I needed to
    de-solder.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB MARKED TO
    SHOW WHICH PCB TRACKS TO MODIFY](../images/fig7-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: The transmitter
    PCB with button pins separated out with a black marker</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve located the PCB pads for the on and off buttons, de-solder the pins,
    ideally using some solder wick, as shown in [Figure 7-9](chapter7.xhtml#fig7-9).
    Be careful not to overheat and destroy the pads.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF DE-SOLDERING BUTTONS FROM THE WIRELESS REMOTE CONTROL AC OUTLET
    TRANSMITTER PCB](../images/fig7-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: De-soldering buttons
    from the transmitter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now gently pry the buttons out from the PCB. This will leave you with some blank
    button spaces, as shown in [Figure 7-10](chapter7.xhtml#fig7-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB WITH TWO
    BUTTONS REMOVED](../images/fig7-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-10: The transmitter
    PCB with control buttons removed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In these empty holes, solder in some jumper wires long enough to reach from
    the transmitter PCB to a solderless breadboard. I’ve chopped the ends from some
    preformed jumpers for easy connections to external circuitry, as shown in [Figure
    7-11](chapter7.xhtml#fig7-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE WIRELESS REMOTE CONTROL AC OUTLET TRANSMITTER PCB WITH NEW
    WIRES REPLACING BUTTONS](../images/fig7-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-11: Modified wiring
    on the transmitter PCB</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to check the operation of the transmitter PCB. Connect 12 V to the
    power leads and short out the on and off wire pairs in turn to check the receiver
    still switches on and off. If it doesn’t, the (now removed) buttons may have formed
    part of the circuit—that is, both button contacts for each side were used as a
    PCB track connection. This happened with my example buttons, so I placed a short
    wire across the side of the button and soldered it into the PCB, as shown in [Figure
    7-12](chapter7.xhtml#fig7-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF WIRES BRIDGING PCB PADS ON THE REMOTE CONTROL AC OUTLET TRANSMITTER
    PCB](../images/fig7-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-12: Adding links to
    the transmitter’s button pads</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Give the system another test if necessary. If it’s successful, cover the link
    wires’ joints with some hot glue so they don’t come off by accident later, as
    shown in [Figure 7-13](chapter7.xhtml#fig7-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF HOT GLUE PUT OVER THE SOLDER JOINTS ON THE WIRELESS REMOTE CONTROL
    PCB](../images/fig7-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-13: Protecting the
    extra soldered links with hot glue</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a transmitter PCB that can be controlled by an Arduino and an external
    optocoupler circuit. Let’s put it to work.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #22: Controlling the Transmitter
    Board</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project briefly demonstrates controlling a hacked transmitter board, which
    will give you the framework to control the outlet in your own projects. You’ll
    need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A 12 V DC, 1A power supply, wall wart, or plugpack (if you like, you can use
    the DC socket breakout described for Project #19 in [Chapter 6](chapter6.xhtml))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hacked wireless outlet transmitter and receiver from the previous section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 4N28 optocouplers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 7-14](chapter7.xhtml#fig7-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![SCHEMATIC FOR PROJECT #22](../images/fig7-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-14: The schematic
    for Project #22</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The TX_On and TX_Off pairs in the schematic represent the wiring to the transmitter
    PCB control buttons, and TX_12VDC+ and <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    represent the 12 V power leads to the transmitter PCB. As the 12 V DC is supplying
    the entire circuit, the power to the Arduino is via the Vin pin. Arduino pins
    D2 and D3 are used to turn the transmitter on and off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now upload the Project #22 sketch. After a few moments, the mains outlet should
    repeatedly switch on and off around every five seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To control the transmitter, the sketch simply closes the contacts for the on
    and off switches, now represented by the optocouplers, with the functions at ❶
    and ❷. The delay in these functions ensures the transmitter has activated long
    enough to trigger the receiver unit.
  prefs: []
  type: TYPE_NORMAL
- en: The delay in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>
    helps to test the circuit, as otherwise the transmitter would sometimes turn on
    immediately when power was applied to the Arduino. You should leave this delay
    in your own projects to avoid unnecessary or unwanted outlet activation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code demonstrates the control by turning the AC on and off slowly
    ❸ ❹. You might connect a lamp or a small fan to the AC outlet to see the effects.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this project’s hardware together, as you’ll expand upon it in the next
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #23: Controlling the Mains
    Outlet with a Timer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use the DS1307 or DS3231 real-time clock IC to build
    an AC mains outlet that turns on or off at the required point(s) in time. This
    is a great way to control small irrigation pumps, night lights, alarms, or similar
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this project, you’ll need the same hardware setup used in Project
    #22, along with a DS3231 or DS1307 RTC module or the logging shield used with
    Project #21 in [Chapter 6](chapter6.xhtml). Assemble the circuit as shown in [Figure
    7-15](chapter7.xhtml#fig7-15).'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #23](../images/fig7-15.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-15: The schematic
    for Project #23</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now upload the Project #23 sketch (which should work for either RTC IC you’ve
    used). Don’t forget to set the time with your current time data using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">setDS3231time()</samp> function in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>. Once you’ve updated
    the time values, uncomment the function, upload the sketch, and then re-comment
    the function and upload the sketch again. I’ve used the DS3231 library as demonstrated
    with Project #21 in [Chapter 6](chapter6.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes the I²C and RTC libraries and then creates an instance
    of the real-time clock to reference ❶. It then declares the required variables
    to hold the time and data information ❷. These include three Boolean variables,
    which are left as false by default, since the sketch uses 24-hour time.
  prefs: []
  type: TYPE_NORMAL
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">setTimeData()</samp>
    function contains the functions to set all the time and date parameters. The variables
    declared earlier are placed in each matching function. This function needs to
    be called only once ❸, as you initially set the time and date and then comment
    out the function before re-uploading the sketch; otherwise, the clock will reset
    to the value of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">mainsOff()</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mainsOn()</samp> functions also use the
    Arduino’s LED on D13 to indicate the system’s on or off status. For outlet control
    at a certain time, the two <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">turnoff()</samp> functions each
    accept an hour and minute and compare them against the current time.
  prefs: []
  type: TYPE_NORMAL
- en: If there’s a match, the outlet is turned on or off, respectively, as shown with
    the examples in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>.
    You can include as many on or off functions as required; the sketch will continually
    loop about the functions checking to turn on or off. There is a long delay in
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOn()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOff()</samp>
    to stop multiple activations of the transmitter during the times when there is
    a match of time for on or off.
  prefs: []
  type: TYPE_NORMAL
- en: For a challenge, you can modify the sketch to allow the user to select the date
    or day of the week along with the time to turn on or off.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #24: Controlling the Mains
    Outlet with SMS</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project takes wireless control to the next level, using the Project #22
    hardware in conjunction with a 3G cellular shield to create an AC mains outlet
    controllable by text message (wherever there’s cell phone service). Doing so is
    surprisingly simple.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You may have built similar projects to this in Chapter 22 of* Arduino Workshop*,
    2nd edition.*'
  prefs: []
  type: TYPE_NORMAL
- en: For this project to work, you’ll need access to a cellular network that operates
    at UMTS (3G) 850 MHz, 900 MHz, 1900 MHz, or 2100 MHz and allows the use of devices
    not supplied by the network provider. This information should be available from
    your cellular provider. You will also need a SIM card for your network—prepaid
    or otherwise—for this shield, in addition to the one already in your phone. Also
    make sure the requirement to enter a PIN to use the SIM card is turned off. (You
    should be able to do this by inserting the SIM card into a regular cell phone
    and changing the setting in the Security menu.)
  prefs: []
  type: TYPE_NORMAL
- en: This project uses the SIM5320-type 3G GSM shield and antenna shown in [Figure
    7-16](chapter7.xhtml#fig7-16). This shield is available from TinySine ([*https://<wbr>www<wbr>.tinyosshop<wbr>.com*](https://www.tinyosshop.com))
    and its distributors. There are two types of SIM5320 shield, the SIM5320A and
    SIM5320E. The latter uses the UMTS/HSDPA 900/2100MHz frequency bands (mainly for
    European users), and the former uses the UMTS/HSDPA 850/1900MHz frequency band
    (mainly for US-based users and Australians using the Telstra network).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO WITH ANTENNA](../images/fig7-16.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-16: A 3G shield with
    an antenna</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since these shields require 12 V external power, begin by connecting the power
    supply you used in earlier projects in this chapter via the Vin and GND pins.
    To configure pins D2 and D3, which the shield uses with SoftwareSerial to communicate
    with the Arduino, connect the jumpers over the RX 3 and TX 2 pins, as shown in
    [Figure 7-17](chapter7.xhtml#fig7-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO CONFIGURATION JUMPERS](../images/fig7-17.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-17: Shield serial
    configuration jumpers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, turn the shield over and insert your carrier SIM card into the holder,
    as shown in [Figure 7-18](chapter7.xhtml#fig7-18).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A SIM CARD HOLDER ON THE 3G SHIELD](../images/fig7-18.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-18: A SIM card in
    its holder</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Gently insert the 3G shield into the Arduino. Connect the external power and
    the USB cable between the Arduino and the PC, then screw in the external antenna.
    Finally, turn the SIM module on using the power button on the top left of the
    shield, as shown in [Figure 7-19](chapter7.xhtml#fig7-19). Press the button for
    two seconds, then let go.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF A 3G CELLULAR SHIELD FOR ARDUINO. ALL THREE LEDS ARE ON FOR POWER,
    STATUS AND NETWORK ACTIVITY](../images/fig7-19.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-19: The 3G shield
    power button and status LEDs, which are on for power, status, and network activity</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The P (for power) and S (for status) LEDs should come on. The blue W (for network
    activity) LED should start blinking once the 3G shield has registered with the
    cellular network, meaning you’re ready to use the shield and all is well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this project, you’ll need the 3G shield you’ve just put together,
    along with the hardware setup you built in Project #22\. Assemble the circuit
    as shown in [Figure 7-20](chapter7.xhtml#fig7-20). Note that the optocoupler inputs
    have changed from the pins used in Project #22 to Arduino pins D4 and D5, as we
    use D2 and D3 for the 3G shield’s serial communications.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #24](../images/fig7-20.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-20: The schematic
    for Project #24</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Enter and upload the following sketch. Once the shield turns on and the blue
    LED starts blinking, send <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#1</samp>
    as an SMS to the SIM card’s cellular number. The mains outlet should turn on;
    send <samp class="SANS_TheSansMonoCd_W7Bold_B_11">#0</samp> to turn it off again.
    I hope this inspires a brief sense of wonder—these moments make learning and building
    projects quite enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The sketch initializes the software serial port for communication with the 3G
    shield ❶ and then declares the variable used to interrogate incoming data from
    the shield. The transmitter control functions appear at ❷ and ❸, and the code
    configures the digital pins in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at ❺, the sketch turns on and configures the 3G shield for use, using
    the AT command <samp class="SANS_TheSansMonoCd_W5Regular_11">AT+CMGF=1</samp>
    to convert incoming SMS messages to text and send them to the software serial
    port ❻. Whenever the 3G shield receives a text message, the details are sent to
    the Arduino via the software serial port, one character at a time ❼. The sketch
    tests each incoming character to see if it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    ❽; if so, it checks for a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and then turns the transmitter
    off ❾ or on ❿ respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The shield’s power button is connected to digital pin 8, so you can also control
    the power from the project sketch, instead of manually turning the button on or
    off.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to safely control mains AC power outlets using
    various forms of automation and remote control. You can use the knowledge gained
    to control the AC mains outlet using various sensors, switches, or other inputs
    or code in your own projects. As long as your input device can control an LED,
    it can control the AC mains outlet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll use high-power shift registers to build even more
    interesting control applications.
  prefs: []
  type: TYPE_NORMAL
