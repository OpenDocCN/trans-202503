- en: Chapter 7. Selectively Printing and Deleting Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine various one-liners that print and delete certain
    lines. These one-liners will, for example, print repeated lines, print the shortest
    line in a file, and print lines that match certain patterns.
  prefs: []
  type: TYPE_NORMAL
- en: But every one-liner that prints certain lines can also be viewed as one that
    deletes the lines that aren’t printed. For example, a one-liner that prints all
    unique lines deletes all repeated lines. I’ll discuss only the one-liners that
    print something, rather than delete something, because one is always the inverse
    of the other.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Print the first line of a file (emulate head -1)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner is quite simple. Perl reads the first line into the `$_` variable,
    thanks to the `-n` option, and then calls `print` to print the contents of the
    `$_` variable. Then it just exits. That’s it. The first line is printed and that’s
    what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also say that this one-liner deletes all lines except the first one.
    But don’t worry. This particular one-liner won’t delete the contents of the file
    unless you also specify the `-i` command-line argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As I explained in [Chapter 1](ch01.html "Chapter 1. Introduction to Perl One-Liners")
    and in one-liner 6.1 on page 59, the `-i` argument edits the file in-place. In
    this case, all the lines in the file would be deleted except for the first. When
    using `-i`, always specify a backup extension to it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will create a backup file *file.bak* before the contents are overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: You can add the `-i` command-line argument to any of the one-liners to change
    the file content. If you don’t use the `-i` argument, the one-liners simply print
    the new content of the file to screen rather than modifying the file.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Print the first 10 lines of a file (emulate head -10)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner uses the `$.` special variable, which stands for “the current
    line number.” Each time Perl reads in a line, it increments `$.` by 1, so clearly
    this one-liner simply prints the first 10 lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This one-liner can also be written without the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `print` is called only if the Boolean expression `$. <= 10` is true, and
    this expression is true only if the current line number is less than or equal
    to 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, though somewhat trickier, way to do this is with the range operator
    (`..`) in the scalar context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The range operator in the scalar context returns a Boolean value. The operator
    is *bistable*, like a flip-flop, and emulates the *line-range* (comma) operator
    in sed, awk, and various text editors. Its value is false as long as its left
    operand is false. Once the left operand is true, the range operator is true until
    the right operand is true, after which the range operator becomes false again.
    As a result, this bistable operator becomes true at the first line, stays true
    until the tenth line, and then becomes and remains false.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fourth option is to follow the first example in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, I put a condition on `exit`, which is that the current line (which I just
    printed) is number 10.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Print the last line of a file (emulate tail -1)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Printing the last line of a file is trickier than printing the first line, because
    you never know which is the last line. As a result, you always have to keep the
    line you just read in memory. In this one-liner, you always save the current line
    held in `$_` into the `$last` variable. When the Perl program ends, it executes
    the code in the `END` block, which prints the last line read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner uses the `eof` (or end-of-file) function, which returns 1 if
    the next read returns the end-of-file. Because the next read after the last line
    in the file will return the end-of-file, this one-liner does the job. The next
    read means that Perl will attempt to read a character from the current file, and
    if reading the character fails, it will signal that the end-of-file has been reached,
    meaning the whole file has been read. If the read succeeds, Perl secretly puts
    the character back in the input stream as if nothing had happened.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Print the last 10 lines of a file (emulate tail -10)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner is a bit tricky. Here, you push each line to the `@a` array and
    then replace `@a` with a slice of itself if the list contains more than 10 elements.
    The phrase `@a = @a[@a-10..$#a]` means “replace `@a` with the last 10 elements
    of `@a`.” The bit `@a-10` causes `@a` to be evaluated in the scalar context, and
    thus it returns the number of elements in the array minus 10\. The expression
    `$#a` is the last index in the `@a` array. And finally, `@a[@a-10..$#a]` slices
    (returns) the last 10 elements of the array, with which it overwrites `@a` itself
    so it always contains only the last 10 elements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose `@a` contains `(line1, line2, line3, line4)`, and you want
    to print the last four lines of the file. When you read the fifth line, the array
    becomes `(line1, line2, line3, line4, line5)`, and the value of `@a-4` is 1 because
    `@a` in the scalar context is 5\. But the value of `$#a` is 4 because it’s the
    last index in the array. Therefore when you take the slice `@a[@a-4..$#a]`, it
    becomes `@a[1..4]`, which drops the front element from the array, and the `@a`
    array becomes `(line2, line3, line4, line5)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simpler way to write this is with `shift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner doesn’t need to slice `@a` because you can guarantee that if
    `@a > 10`, then `@a == 11`. `shift` is an operator that removes the first element
    of an array. So in this loop, you can simply shift off the first stored line when
    you have more than 10 lines.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Print only lines that match a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner tests to see whether the current line matches `/regex/`. If so,
    the `/regex/` match succeeds and `print` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using `&&`, you can also use `if` to reverse the `/regex/` and `print`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 7.6 Print only lines that do not match a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner inverts the previous one-liner. Here, I test to see that the
    line doesn’t match `/regex/` by inverting the match via the `!` operator. If the
    line doesn’t match, I call `print` to print the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write this the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can also use `unless` instead of `if !`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to write this is to apply De Morgan’s law to `!/regex/ && print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 7.7 Print every line preceding a line that matches a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner prints a line when it is above a line that matches `/regex/`.
    Let’s walk through it, beginning at the last statement, `$last = $_`, which saves
    each line in the `$last` variable. Suppose the next line is read and it matches
    `/regex/`. Because the previous line is saved in `$last`, the one-liner simply
    prints it. The series of `&&` means first that the regular expression must match
    and second that `$last` must be a true value. (Blank lines are still printed because
    they contain the newline character.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have a file with four lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to print all lines above those that match `magic`. You can do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'and the one-liner will print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 7.8 Print every line following a line that matches a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, I set the variable `$p` to 1 if the current line matches the regular expression.
    The fact that the variable `$p` is 1 indicates that the next line should be printed.
    Now, when the next line is read in and `$p` is set, that line is printed and `$p`
    is reset to 0\. Quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have this four-line file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to print all lines below those that match `science`. Do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The one-liner will print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to write this with `&&` and avoid using `if` and curly brackets,
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also be very smart about this and simplify this one-liner to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the current line matches `science`, then variable `$p` is set to a true value
    and the next line gets printed. If the current line doesn’t match `science`, then
    `$p` becomes undefined and the next line doesn’t get printed.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Print lines that match regular expressions AAA and BBB in any order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner tests to see whether a line matches two regular expressions.
    If a line matches `/AAA/` and `/BBB/`, it’s printed. Specifically, this one-liner
    prints the line *foo AAA bar BBB baz* because it contains both *AAA* and *BBB*,
    but it won’t print the line *foo AAA bar AAA* because it doesn’t contain *BBB*.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Print lines that don’t match regular expressions AAA and BBB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner is almost the same as the previous one. Here, I test to see if
    a line doesn’t match both regular expressions. If it doesn’t match `/AAA/` or
    `/BBB/`, it prints.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11 Print lines that match regular expression AAA followed by BBB followed
    by CCC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, I simply chain the regular expressions `AAA`, `BBB`, and `CCC` with `.*`,
    which means “match anything or nothing at all.” If `AAA` is followed by `BBB`,
    which is followed by `CCC`, the line prints. For example, this one-liner matches
    and prints strings like *123**AAA**880**BBB**222**CCC**, x**AAA**y**BBB**z**CCC***,
    and ***AAABBBCCC***.
  prefs: []
  type: TYPE_NORMAL
- en: 7.12 Print lines that are at least 80 characters long
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner prints all lines that are at least 80 characters long. In Perl,
    you can sometimes omit the parentheses `()` for function calls, so here I’ve omitted
    them for the `length` function call. In fact, the invocations `length`, `length()`,
    and `length($_)` are all the same as far as Perl is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to count line endings, you can turn on automatic handling
    of line endings with `-l`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This switch ensures that a blank line has zero length, whereas it usually has
    length 1 or 2, depending on the file format. (UNIX newlines have length 1; Windows
    newlines have length 2.)
  prefs: []
  type: TYPE_NORMAL
- en: 7.13 Print lines that are fewer than 80 characters long
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner reverses the previous one. It checks to see whether the length
    of a line is less than 80 characters. Again, you use `-l` if you don’t want the
    line endings to be counted.
  prefs: []
  type: TYPE_NORMAL
- en: 7.14 Print only line 13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As I explained in one-liner 7.2 on page 70, the `$.` special variable stands
    for “the current line number.” Therefore, if `$.` has a value of 13, this one-liner
    prints the line and exits.
  prefs: []
  type: TYPE_NORMAL
- en: 7.15 Print all lines except line 27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous one-liner, this one checks to see whether the line number
    of the current line is 27\. If a line is not 27, it prints; if it is, it doesn’t
    print.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can accomplish the same thing by reversing `print` and `$. != 27` and using
    the `if` statement modifier—just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use `unless`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 7.16 Print only lines 13, 19, and 67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-liner prints only lines 13, 19, and 67\. It doesn’t print any other
    lines. Here’s how it works: It calls `print` if the current line number, stored
    in the `$.` variable, is 13, 19, or 67\. You can use any line numbers to print
    specific lines. For example, to print the lines 13, 19, 88, 290, and 999, you
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to print more lines, you can put them in a separate array and then
    test whether `$.` is in this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner uses `grep` to test if the current line `$.` is in the `@lines`
    array. If the current line number is found in the `@lines` array, the `grep` function
    returns a list of one element that contains the current line number and this list
    evaluates to true. If the current line number is not found in the `@lines` array,
    the `grep` function returns an empty list that evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: 7.17 Print all lines from 17 to 30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this one-liner, the `$.` variable stands for the current line number. As
    a result, the one-liner checks to see whether the current line number is greater
    than or equal to 17 and less than or equal to 30.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do the same thing using the flip-flop operator, which is explained
    in one-liner 7.2 on page 70\. The flip-flop operator operates on `$.` when used
    with integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 7.18 Print all lines between two regular expressions (including the lines that
    match)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner uses the flip-flop operator (explained in one-liner 7.2 on page
    70). When used with integers, the operands are tested against the `$.` variable.
    When used with regular expressions, the operands are tested against the current
    line, stored in the `$_` variable. Initially the operator returns false. When
    a line matches `regex1`, the operator flips and starts returning true until another
    line matches `regex2`. At that point, the operator returns true for the last time
    and then flips to the false state. From now on the operator returns false. This
    one-liner, therefore, prints all lines between (and including) the lines that
    match `regex1` and `regex2`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.19 Print the longest line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner keeps the longest line seen so far in the `$l` variable. If the
    length of the current line `$_` exceeds the length of the longest line, the value
    in `$l` is replaced with the value of the current line. Before exiting, the `END`
    block is executed, and it prints the longest line value that’s held in `$l`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to use `-l` if you want to prevent the newline characters from counting
    toward the line length.
  prefs: []
  type: TYPE_NORMAL
- en: 7.20 Print the shortest line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner is the opposite of the previous one. Because it’s finding the
    shortest line and `$s` is not defined for the first line, you have to set its
    value to the first line explicitly through `$s = $_ if $. == 1`. Then it simply
    does the opposite of the previous one-liner. That is, it checks to see whether
    the current line is the shortest line so far and, if so, assigns it to `$s`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.21 Print all lines containing digits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This one-liner uses the regular expression `\d` (which stands for “a digit”)
    to see whether a line contains a digit. If so, the check succeeds, and the line
    is printed. For example, this line would be printed because it contains digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this line wouldn’t be printed because it doesn’t contain digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 7.22 Print all lines containing only digits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In this one-liner, the regular expression `^\d+$` means “match a line if it
    contains only digits from the beginning until the end.” For example, this line
    would be printed because it contains only digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this line wouldn’t be printed because it also contains some characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also invert the `^\d$` regular expression and use `\D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner is great for developing your logical reasoning because it uses
    logical negation twice. Here, the line prints only if it does *not* contain a
    non-numeric character. In other words, it prints only if all the characters are
    numeric. (Notice that I used the `-l` command-line argument for this one-liner
    because of the newline character at the end of the line. If I didn’t use `-l`,
    the line would contain the newline character—a non-numeric character—and it wouldn’t
    be printed.)
  prefs: []
  type: TYPE_NORMAL
- en: 7.23 Print all lines containing only alphabetic characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner checks to see whether a line contains only alphabetic characters.
    If so, it prints the line. The `[[:alpha:]]` stands for “any alphabetic character.”
    And `[[:alpha:]]+` stands for “all alphabetic characters.”
  prefs: []
  type: TYPE_NORMAL
- en: 7.24 Print every second line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner prints the first, third, fifth, and seventh lines (and so on).
    It does so because `$. % 2` is true when the current line number is odd and false
    when the current line number is even.
  prefs: []
  type: TYPE_NORMAL
- en: 7.25 Print every second line, beginning with the second line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner is like previous one, except it prints the second, fourth, sixth,
    and eighth lines (and so on) because `$. % 2 == 0` is true when the current line
    number is even.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can simply invert the test from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 7.26 Print all repeated lines only once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner tracks the lines it has seen so far and counts the number of
    times it has seen the lines previously. If it sees a line a second time, it prints
    the line because `++$a{$_} == 2` is true. If it sees a line more than two times,
    it does nothing because the count for this line is greater than 2.
  prefs: []
  type: TYPE_NORMAL
- en: 7.27 Print all unique lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This one-liner prints a line only if the hash value `$a{$_}` for that line is
    false. Every time Perl reads in a line, it increments `$a{$_}`, which ensures
    that this one-liner prints only never-before-seen lines.
  prefs: []
  type: TYPE_NORMAL
