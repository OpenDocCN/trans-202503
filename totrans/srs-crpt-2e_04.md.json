["```\n$ **openssl rand `<number of bytes>`** **-out `<output file>`**\n```", "```\n$ **dd if=/dev/urandom of=****`<output file>`** **bs=1M count=10**\n```", "```\nint random_bytes_insecure(void *buf, size_t len)\n{\n    int fd = open(\"/dev/urandom\", O_RDONLY);\n    read(fd, buf, len);\n    close(fd);\n    return 0;\n}\n```", "```\nint random_bytes_safer(void *buf, size_t len)\n{\n    struct stat st;\n    size_t i;\n    int fd, cnt, flags;\n    int save_errno = errno;\n\nstart:\n    flags = O_RDONLY;\n#ifdef O_NOFOLLOW\n    flags |= O_NOFOLLOW;\n#endif\n#ifdef O_CLOEXEC\n    flags |= O_CLOEXEC;\n#endif\n  ❶ fd = open(\"/dev/urandom\", flags, 0);\n    if (fd == -1) {\n        if (errno == EINTR)\n            goto start;\n        goto nodevrandom;\n    }\n#ifndef O_CLOEXEC\n    fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n#endif\n\n    /* Lightly verify that the device node looks sane. */\n    if (fstat(fd, &st) == -1 || !S_ISCHR(st.st_mode)) {\n        close(fd);\n        goto nodevrandom;\n    }\n    if (ioctl(fd, RNDGETENTCNT, &cnt) == -1) {\n        close(fd);\n        goto nodevrandom;\n    }\n    for (i = 0; i < len;) {\n        size_t wanted = len - i;\n      ❷ ssize_t ret = read(fd, (char *)buf + i, wanted);\n\n        if (ret == -1) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            close(fd);\n            goto nodevrandom;\n        }\n        i += ret;\n    }\n    close(fd);\n    if (gotdata(buf, len) == 0) {\n        errno = save_errno;\n        return 0; /* Satisfied */\n    }\nnodevrandom:\n    errno = EIO;\n    return -1;\n}\n```", "```\nint random_bytes(unsigned char *out, size_t outlen)\n{\n    static HCRYPTPROV handle = 0; /* Only freed when the program ends */\n    if(!handle) {\n        if(!CryptAcquireContext(&handle, 0, 0, PROV_RSA_FULL,\n                                CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n            return -1;\n        }\n    }\n    while(outlen > 0) {\n        const DWORD len = outlen > 1048576UL ? 1048576UL : outlen;\n        if(!CryptGenRandom(handle, len, out)) {\n            return -2;\n        }\n        out    += len;\n        outlen -= len;\n    }\n    return 0;\n}\n```", "```\nglobal variable seed;\n\nRNG_CreateContext()\n    (seconds, microseconds) = time of day; /* Time elapsed since 1970 */\n    pid = process ID;  ppid = parent process ID;\n    a = mklcpr(microseconds);\n  ❶ b = mklcpr(pid + seconds + (ppid << 12));\n    seed = MD5(a, b); /* Derivation of a 128-bit value using the hash MD5 */\n\nmklcpr(x) /* Not cryptographically significant; shown for completeness */\n    return ((0xDEECE66D * x + 0x2BBB62DC) >> 1);\nMD5() /* A very good standard mixing function, source omitted */\n```", "```\nprng.seed(seed)\np = prng.generate_random_prime()\nq = prng.generate_random_prime()\nn = p*q\n```", "```\nprng.seed(seed)\np = prng.generate_random_prime()\nprng.add_entropy()\nq = prng.generate_random_prime()\nn = p*q\n```", "```\n /**\n         * Generate a hex-y looking random token for various uses.\n         * Could be made more cryptographically sure if someone cares.\n         * @return string\n         */\nfunction generateToken($salt = '') {\n    $token = dechex(mt_rand()).dechex(mt_rand());\n    return md5($token . $salt);\n}\n```", "```\nCryptocat.random = function() {\n    var x, o = '';\n    while (o.length < 16) {\n        x = state.getBytes(1);\n        if (x[0] <= 250) {\n            o += x[0] % 10;\n        }\n    }\n    return parseFloat('0.' + o)\n}\n```"]