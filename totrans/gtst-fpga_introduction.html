<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Introduction</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="int" epub:type="introduction" role="doc-introduction">
<header>
<h1 class="FMH" id="int"><span aria-label=" Page xix. " epub:type="pagebreak" id="pg_xix" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp></h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">In my first job out of college as an entry-level electrical engineer, I once worked on an old design that had a timer circuit on it. Using a simple resistor and capacitor, the circuit would wait for 50 milliseconds (ms) to elapse, then trigger an action. We needed to change that 50 ms timer to 60 ms, but this small change required a monumental effort: we would have to physically remove the capacitors and resistors from hundreds of circuit boards and replace them with new ones.</p>
<p class="TX">Fortunately, we had a team of field programmable gate array (FPGA) designers who came to the rescue. With their help, we were able to implement the same functionality inside an FPGA. Then, in a matter of minutes, we could change code to set the timer to any arbitrary value we wanted, <span aria-label=" Page xx. " epub:type="pagebreak" id="pg_xx" role="doc-pagebreak"/>without having to touch a soldering iron. This faster pace of progress excited me, and I quickly got hooked on FPGAs.</p>
<p class="TX">Eventually I transitioned to working with FPGAs full-time, and it was around then that I started reading and responding to FPGA-related questions on Stack Overflow. Often these questions came from FPGA beginners who were confused about basic concepts. I saw the same types of questions asked again and again, and realized there wasn’t a single place where people could learn about FPGAs in a simple, easy-to-understand way. Sure, there were many online references for Verilog and VHDL, the two most popular FPGA programming languages, but there was relatively little information on what those languages were actually <i>doing</i>. What components are really being created within your FPGA when you write a certain line of code? How are things being wired up? What does it mean to run operations in parallel versus serially?</p>
<p class="TX">Rather than continuing to answer the same questions over and over, I started my own website, <a href="https://nandland.com"><i>https://<wbr/>nandland<wbr/>.com</i></a>, where I began writing longer articles about FPGAs. As traffic grew, I started making YouTube videos as well. I even created my own FPGA development board to provide hands-on experience for beginners. In all these endeavors, my goal has been to demystify FPGAs while making the information approachable and engaging for those just starting out. Writing this book has allowed me to delve even deeper into the subject, to build a solid foundation for anyone interested in exploring the exciting world of FPGA design.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-1"/><samp class="SANS_Futura_Std_Bold_B_11">Who Is This Book For?</samp></h2>
<p class="TNI1">I’ve tried to make this book as accessible as possible so that a broad range of people will be able to read and understand the material. The intended audience is anyone who is curious about how digital programmable logic works and how FPGAs can be used to solve a wide variety of problems. Maybe you’re a college student who encountered FPGAs in a class and was left intrigued but confused, or someone in the electronics industry who has been exposed to FPGAs at work. Perhaps you’re a tinkerer or hardware hacker, or a software developer interested in programming at a much lower level than you’re used to. This book is very approachable for all of these groups.</p>
<p class="TX">I’m assuming you’ve had at least some exposure to a conventional programming language, like Python, C, or JavaScript. It will be helpful if you understand concepts like functions, conditional statements (<samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp>), loops, and other basic programming techniques. You don’t need any prior experience with Verilog or VHDL, however; this book will introduce the basics of these languages.</p>
<p class="TX">FPGAs lie at the intersection of hardware and software, so having some interest in electronics is helpful. We’ll sometimes discuss concepts like voltage and current within the FPGA. Here again, it will be useful if you’ve had some basic introduction to these terms, but it won’t be required to get value out of those sections.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h-2"/><span aria-label=" Page xxi. " epub:type="pagebreak" id="pg_xxi" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">What This Book Isn’t</samp></h2>
<p class="TNI1">This book isn’t intended to teach you every facet of Verilog or VHDL. As I said earlier, there are many online resources if that’s your goal. Instead, my aim is to teach you how FPGAs work so you can understand what your Verilog or VHDL is doing, and thus make more intelligent choices about your designs. That said, we <i>will</i> look at a large amount of code throughout the book. All of it is thoroughly explained, so you won’t need prior experience with these programming languages to follow along. You’ll gain a strong base of Verilog and VHDL knowledge as you read, and the confidence to augment that knowledge through independent study.</p>
<p class="TX">The book includes various projects that you’ll be able to carry out on real hardware using the iCE40 line of FPGAs from Lattice Semiconductor. I’ve focused on these comparatively cheap, simple FPGAs to make the hands-on parts of the book as accessible as possible. More expensive FPGAs have many extra bells and whistles; they’re very cool, but they can be overwhelming for beginners. iCE40 FPGAs are still highly capable, but with fewer of these high-end features available. As such, this book won’t explore sophisticated features like SerDes and hard-core processors in a hands-on way, nor will we dwell on the more complicated FPGA tools required to use them. We <i>will</i> discuss some of these features at a high level, however, so you’ll gain the background knowledge to work with them if you choose to upgrade to a fancier FPGA.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h-3"/><samp class="SANS_Futura_Std_Bold_B_11">What’s in the Book?</samp></h2>
<p class="TNI1">This book combines high-level discussion, detailed code examples, and hands-on projects. Each code listing is shown in both Verilog and VHDL, so whichever language you want to use for FPGA development, you’ll be able to follow along. There’s also an extensive glossary at the end of the book for your reference. Here’s what you’ll find in each chapter:</p>
<p class="EX"><b><a href="chapter1.xhtml">Chapter 1</a>: Meet the FPGA</b>   Introduces FPGAs and talks about their strengths and weaknesses. Being an engineer is about knowing which tool to use in which scenario. Understanding when to use an FPGA—and when not to—is crucial.</p>
<p class="EX"><b><a href="chapter2.xhtml">Chapter 2</a>: Setting Up Your Hardware and Tools</b>   Gets you set up with the Lattice iCE40 series of FPGAs. You’ll download and install the FPGA tools and learn how to run them to program your FPGA.</p>
<p class="EX"><b><a href="chapter3.xhtml">Chapter 3</a>: Boolean Algebra and the Look-Up Table</b>   Explores one of the two most fundamental FPGA components: the look-up table (LUT). You’ll learn how LUTs perform Boolean algebra and take the place of dedicated logic gates.</p>
<p class="EX"><b><a href="chapter4.xhtml">Chapter 4</a>: Storing State with the Flip-Flop</b>   Introduces the second fundamental FPGA component: the flip-flop. You’ll see how flip-flops store state within an FPGA, giving the device memory of what happened previously.</p>
<p class="EX"><span aria-label=" Page xxii. " epub:type="pagebreak" id="pg_xxii" role="doc-pagebreak"/><b><a href="chapter5.xhtml">Chapter 5</a>: Testing Your Code with Simulation</b>   Discusses how to write testbenches to simulate your FPGA designs and make sure they work correctly. It’s hard to see what’s going on inside a real physical FPGA, but simulations let you investigate how your code is behaving, find bugs, and understand strange behaviors.</p>
<p class="EX"><b><a href="chapter6.xhtml">Chapter 6</a>: Common FPGA Modules</b>   Shows how to create some basic building blocks common to most FPGA designs, including multiplexers, demultiplexers, shift registers, and first in, first out (FIFO) and other memory structures. You’ll learn how they work and how to combine them to solve complex problems.</p>
<p class="EX"><b><a href="chapter7.xhtml">Chapter 7</a>: Synthesis, Place and Route, and Crossing Clock Domains</b>    Expands on the FPGA build process, with details about synthesis and the place and route stage. You’ll learn about timing errors and how to avoid them, and how to safely cross between clock domains within your FPGA design.</p>
<p class="EX"><b><a href="chapter8.xhtml">Chapter 8</a>: The State Machine</b>   Introduces the state machine, a common model for keeping track of the logical flow through a sequence of events in an FPGA. You’ll use a state machine to implement an interactive memory game.</p>
<p class="EX"><b><a href="chapter9.xhtml">Chapter 9</a>: Useful FPGA Primitives</b>   Discusses other important FPGA components besides the LUT and the flip-flop, including the block RAM, the DSP block, and the phase-locked loop (PLL). You’ll learn different strategies for harnessing these components and see how they solve common problems.</p>
<p class="EX"><b><a href="chapter10.xhtml">Chapter 10</a>: Numbers and Math</b>   Outlines simple rules for working with numbers and implementing math operations in an FPGA. You’ll learn the difference between signed and unsigned numbers, fixed-point and floating-point operations, and more.</p>
<p class="EX"><b><a href="chapter11.xhtml">Chapter 11</a>: Getting Data In and Out with I/O and SerDes</b>   Examines the input/output (I/O) capabilities of an FPGA. You’ll learn the pros and cons of different types of interfaces and be introduced to SerDes, a powerful FPGA feature for high-speed data transmission.</p>
<p class="EX"><b><a href="appendix_A.xhtml">Appendix A</a>: FPGA Development Boards</b>   Suggests some FPGA development boards that you can use for this book’s projects.</p>
<p class="EX"><b><a href="appendix_B.xhtml">Appendix B</a>: Tips for a Career in FPGA Engineering</b>   Outlines strategies for finding an FPGA-related job, in case you want to pursue FPGA design professionally. I’ll make suggestions on how to build a good resume, prepare for interviews, and negotiate for the best-possible job offer.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h-4"/><samp class="SANS_Futura_Std_Bold_B_11">What You’ll Need</samp></h2>
<p class="TNI1">Although not strictly required, I recommend having a development board with a Lattice iCE40 FPGA so you can complete the book’s hands-on projects. There’s nothing more satisfying than learning about a concept and <span aria-label=" Page xxiii. " epub:type="pagebreak" id="pg_xxiii" role="doc-pagebreak"/>then being able to implement that concept on real hardware. <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> discusses what to look for in a development board and exactly what you’ll need for the book’s projects in more detail. Briefly, the development board should have a USB connection and peripherals like LEDs, push-button switches, and a seven-segment display. <span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span> describes some development boards that will work.</p>
<p class="TX">The software tools for working with iCE40 FPGAs run best on Windows. If you don’t have a Windows computer, I recommend running the tools inside a Windows virtual machine. We’ll discuss installing these tools in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h2 class="H1" id="sec5"><span id="h-5"/><samp class="SANS_Futura_Std_Bold_B_11">Online Resources</samp></h2>
<p class="TNI1">The code presented in this book is available online via a GitHub repository. You can access it at <a href="https://github.com/nandland/getting-started-with-fpgas"><i>https://<wbr/>github<wbr/>.com<wbr/>/nandland<wbr/>/getting<wbr/>-started<wbr/>-with<wbr/>-fpgas</i></a>. You’ll also find more information and FPGA project ideas online at <a href="https://nandland.com"><i>https://<wbr/>nandland<wbr/>.com</i></a>.</p>
</section>
</section>
</body>
</html>