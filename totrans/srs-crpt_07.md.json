["```\nfind-preimage(H) {\n    repeat {\n        M = random_message()\n        if Hash(M) == H then return M\n     }\n}\n```", "```\nsolve-second-preimage(M) {\n    H = Hash(M)\n    return solve-preimage(H)\n}\n```", "```\nsolve-collision() {\n    M = random_message()\n    return (M, solve-second-preimage(M))\n}\n```", "```\nSHA1-compress(H, M) {\n    (a0, b0, c0, d0, e0) = H   // parsing H as five 32-bit big endian words\n    (a, b, c, d, e) = SHA1-blockcipher(a0, b0, c0, d0, e0, M)\n    return (a + a0, b + b0, c + c0, d + d0, e + e0)\n}\n```", "```\nSHA1-blockcipher(a, b, c, d, e, M) {\n    W = expand(M)\n    for i = 0 to 79 {\n        new = (a <<< 5) + f(i, b, c, d) + e + K[i] + W[i]\n        (a, b, c, d, e) = (new, a, b >>> 2, c, d)\n    }\n    return (a, b, c, d, e)\n}\n```", "```\nexpand(M) {\n    // the 512-bit M is seen as an array of sixteen 32-bit words\n    W = empty array of eighty 32-bit words\n    for i = 0 to 79 {\n        if i < 16 then W[i] = M[i]\n        else\n            W[i] = (W[i – 3] ⊕ W[i – 8] ⊕ W[i – 14] ⊕ W[i – 16]) <<< 1\n    }\n    return W\n}\n```", "```\nf(i, b, c, d) {\n    if i < 20 then return ((b & c) ⊕ (~b & d))\n    if i < 40 then return (b ⊕ c ⊕ d)\n    if i < 60 then return ((b & c) ⊕ (b & d) ⊕ (c & d))\n    if i < 80 then return (b ⊕ c ⊕ d)\n}\n```", "```\nexpand256(M) {\n    // the 512-bit M is seen as an array of sixteen 32-bit words\n    W = empty array of sixty-four 32-bit words\n    for i = 0 to 63 {\n        if i < 16 then W[i] = M[i]\n        else {\n            // the \">>\" shifts instead of a \">>>\" rotates and is not a typo\n            s0 = (W[i – 15] >>> 7) ⊕ (W[i – 15] >>> 18) ⊕ (W[i – 15] >> 3)\n            s1 = (W[i – 2] >>> 17) ⊕ (W[i – 2] >>> 19) ⊕ (W[i – 2] >> 10)\n            W[i] = W[i – 16] + s0 + W[i – 7] + s1\n        }\n    }\n    return W\n}\n```", "```\nstatic void sha3_keccakf(uint64_t st[25], int rounds)\n{\n    (⊕)\n    for (r = 0; r < rounds; r++) {\n\n     ❶ // Theta \n        for (i = 0; i < 5; i++)\n            bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];\n\n        for (i = 0; i < 5; i++) {\n            t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);\n            for (j = 0; j < 25; j += 5)\n                st[j + i] ^= t;\n        }\n\n     ❷ // Rho Pi\n        t = st[1];\n        for (i = 0; i < 24; i++) {\n            j = keccakf_piln[i];\n            bc[0] = st[j];\n            st[j] = ROTL64(t, keccakf_rotc[i]);\n            t = bc[0];\n        }\n\n     ❸ // Chi\n        for (j = 0; j < 25; j += 5) {\n            for (i = 0; i < 5; i++)\n                bc[i] = st[j + i];\n            for (i = 0; i < 5; i++)\n                st[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];\n        }\n\n     ❹ // Iota\n        st[0] ^= keccakf_rndc[r];\n    }\n    (⊕)\n}\n```"]