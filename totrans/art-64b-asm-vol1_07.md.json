["```\ncall printf\n```", "```\n`proc_name` proc `options`\n          `Procedure statements`\n`proc_name` endp\n```", "```\nzeroBytes proc\n          mov eax, 0\n          mov edx, 256\nrepeatlp: mov [rcx+rdx*4-4], eax\n          dec rdx\n          jnz repeatlp\n          ret\nzeroBytes endp\n```", "```\n; Listing 5-1\n\n; Simple procedure call example.\n\n         option  casemap:none\n\nnl       =       10\n\n         .const\nttlStr   byte    \"Listing 5-1\", 0\n\n        .data\ndwArray dword   256 dup (1)\n\n        .code\n\n; Return program title to C++ program:\n\n         public getTitle\ngetTitle proc\n         lea rax, ttlStr\n         ret\ngetTitle endp\n\n; Here is the user-written procedure\n; that zeroes out a buffer.\n\nzeroBytes proc\n          mov eax, 0\n          mov edx, 256\nrepeatlp: mov [rcx+rdx*4-4], eax\n          dec rdx\n          jnz repeatlp\n          ret\nzeroBytes endp\n\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n        sub     rsp, 48\n\n lea     rcx, dwArray\n        call    zeroBytes \n\n        add     rsp, 48     ; Restore RSP\n        ret                 ; Returns to caller\nasmMain endp\n        end\n```", "```\nminimal proc\n        ret\nminimal endp\n```", "```\n; Listing 5-2\n\n; A procedure without a ret instruction.\n\n               option  casemap:none\n\nnl             =       10\n\n              .const\nttlStr        byte    \"Listing 5-2\", 0\nfpMsg         byte    \"followingProc was called\", nl, 0\n\n              .code\n              externdef printf:proc\n\n; Return program title to C++ program:\n\n              public getTitle\ngetTitle      proc\n              lea rax, ttlStr\n              ret\ngetTitle      endp\n\n; noRet - Demonstrates what happens when a procedure\n;         does not have a return instruction.\n\nnoRet         proc\nnoRet         endp\n\nfollowingProc proc\n              sub  rsp, 28h\n              lea  rcx, fpMsg\n              call printf\n              add  rsp, 28h\n              ret\nfollowingProc endp\n\n; Here is the \"asmMain\" function.\n\n              public  asmMain\nasmMain       proc\n              push    rbx\n\n              sub     rsp, 40   ; \"Magic\" instruction\n\n              call    noRet\n\n              add     rsp, 40   ; \"Magic\" instruction\n              pop     rbx\n              ret               ; Returns to caller\nasmMain       endp\n              end\n```", "```\nglobalSymbol:: mov eax, 0\n```", "```\noption scoped\noption noscoped\n```", "```\n; Listing 5-3\n\n; Preserving registers (failure) example.\n\n               option  casemap:none\n\nnl             =       10\n\n              .const\nttlStr        byte    \"Listing 5-3\", 0\nspace         byte    \" \", 0\nasterisk      byte    '*, %d', nl, 0\n\n              .code\n              externdef printf:proc\n\n; Return program title to C++ program:\n\n              public getTitle\ngetTitle      proc\n              lea rax, ttlStr\n              ret\ngetTitle      endp\n\n; print40Spaces - Prints out a sequence of 40 spaces\n;                 to the console display.\n\nprint40Spaces proc\n              sub  rsp, 48   ; \"Magic\" instruction\n              mov  ebx, 40\nprintLoop:    lea  rcx, space\n              call printf\n              dec  ebx\n              jnz  printLoop ; Until EBX == 0\n              add  rsp, 48   ; \"Magic\" instruction\n              ret\nprint40Spaces endp\n\n; Here is the \"asmMain\" function.\n\n              public  asmMain\nasmMain       proc\n              push    rbx\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n              sub     rsp, 40   ; \"Magic\" instruction\n\n              mov     rbx, 20\nastLp:        call    print40Spaces\n              lea     rcx, asterisk\n              mov     rdx, rbx\n              call    printf\n dec     rbx\n              jnz     astLp\n\n              add     rsp, 40   ; \"Magic\" instruction\n              pop     rbx\n              ret     ; Returns to caller\nasmMain       endp\n              end\n```", "```\nprint40Spaces proc\n              push rbx\n              sub  rsp, 40   ; \"Magic\" instruction\n              mov  ebx, 40\nprintLoop:    lea  rcx, space\n              call printf\n              dec  ebx\n              jnz  printLoop ; Until EBX == 0\n              add  rsp, 40   ; \"Magic\" instruction\n              pop  rbx\n              ret\nprint40Spaces endp\n```", "```\n; Listing 5-4\n\n; Preserving registers (caller) example.\n\n               option  casemap:none\n\nnl             =       10\n\n              .const\nttlStr        byte    \"Listing 5-4\", 0\nspace         byte    \" \", 0\nasterisk      byte    '*, %d', nl, 0\n\n              .data\nsaveRBX       qword   ?\n\n .code\n              externdef printf:proc\n\n; Return program title to C++ program:\n\n              public getTitle\ngetTitle      proc\n              lea rax, ttlStr\n              ret\ngetTitle      endp\n\n; print40Spaces - Prints out a sequence of 40 spaces\n;                 to the console display.\n\nprint40Spaces proc\n              sub  rsp, 48   ; \"Magic\" instruction\n              mov  ebx, 40\nprintLoop:    lea  rcx, space\n              call printf\n              dec  ebx\n              jnz  printLoop ; Until EBX == 0\n              add  rsp, 48   ; \"Magic\" instruction\n              ret\nprint40Spaces endp\n\n; Here is the \"asmMain\" function.\n\n              public  asmMain\nasmMain       proc\n              push    rbx\n\n; \"Magic\" instruction offered without\n; explanation at this point:\n\n              sub     rsp, 40\n\n              mov     rbx, 20\nastLp:        mov     saveRBX, rbx\n              call    print40Spaces\n              lea     rcx, asterisk\n              mov     rdx, saveRBX\n              call    printf\n              mov     rbx, saveRBX\n              dec     rbx\n              jnz     astLp\n\n              add     rsp, 40\n              pop     rbx\n              ret     ; Returns to caller\nasmMain       endp\n              end\n```", "```\nMessedUp   proc\n\n           push rax\n           ret\n\nMessedUp   endp\n```", "```\nMessedUp2  proc\n\n           pop rax\n           ret\n\nMessedUp2  endp\n```", "```\n; Listing 5-5\n\n; Popping a return address by mistake.\n\n               option  casemap:none\n\nnl             =       10\n\n              .const\nttlStr        byte    \"Listing 5-5\", 0\ncalling       byte    \"Calling proc2\", nl, 0\ncall1         byte    \"Called proc1\", nl, 0\nrtn1          byte    \"Returned from proc 1\", nl, 0\nrtn2          byte    \"Returned from proc 2\", nl, 0\n\n              .code\n              externdef printf:proc\n\n; Return program title to C++ program:\n\n              public getTitle\ngetTitle      proc\n              lea rax, ttlStr\n              ret\ngetTitle      endp\n\n; proc1 - Gets called by proc2, but returns\n;         back to the main program.\n\nproc1         proc\n              pop   rcx     ; Pops return address off stack\n              ret\nproc1         endp\n\nproc2         proc\n              call  proc1   ; Will never return\n\n; This code never executes because the call to proc1\n; pops the return address off the stack and returns\n; directly to asmMain.\n\n              sub   rsp, 40\n              lea   rcx, rtn1\n              call  printf\n              add   rsp, 40\n              ret\nproc2         endp\n\n; Here is the \"asmMain\" function.\n\n              public asmMain\nasmMain       proc\n\n              sub   rsp, 40\n\n              lea   rcx, calling\n              call  printf\n\n              call  proc2\n              lea   rcx, rtn2\n              call  printf\n\n              add   rsp, 40\n              ret           ; Returns to caller\nasmMain       endp\n              end\n```", "```\nvoid ARDemo(unsigned i, int j, unsigned k)\n{\n     int a;\n     float r;\n     char c;\n     bool b;\n     short w\n     .\n     .\n     .\n}\n```", "```\npush rbp          ; Save a copy of the old RBP value\nmov rbp, rsp      ; Get ptr to activation record into RBP\nsub rsp, `num_vars` ; Allocate local variable storage plus padding\n```", "```\npush rbp\nmov rbp, rsp\nsub rsp, `num_vars`  ; Make room for local variables\nand rsp, -16       ; Force qword stack alignment\n```", "```\nmov rsp, rbp   ; Deallocate locals and clean up stack\npop rbp        ; Restore pointer to caller's activation record\nret            ; Return to the caller\n```", "```\nmov rsp, rbp    ; Deallocate locals and clean up stack\npop rbp         ; Restore pointer to caller's activation record\nret `parm_bytes`  ; Return to the caller and pop the parameters\n```", "```\nmov rsp, rbp\npop rbp\nret 24\n```", "```\nleave\nret `optional_const`\n```", "```\n; Listing 5-6\n\n; Accessing local variables.\n\n               option  casemap:none\n               .code\n\n; sdword a is at offset -4 from RBP.\n; sdword b is at offset -8 from RBP.\n\n; On entry, ECX and EDX contain values to store\n; into the local variables a and b (respectively):\n\nlocalVars     proc\n              push rbp\n              mov  rbp, rsp\n              sub  rsp, 16       ; Make room for a and b\n\n              mov  [rbp-4], ecx  ; a = ECX\n              mov  [rbp-8], edx  ; b = EDX\n\n    ; Additional code here that uses a and b:\n\n              mov   rsp, rbp\n              pop   rbp\n              ret\nlocalVars     endp\n```", "```\n; Listing 5-7\n\n; Accessing local variables #2.\n\n            option  casemap:none\n            .code\n\n; localVars - Demonstrates local variable access.\n\n; sdword a is at offset -4 from RBP.\n; sdword b is at offset -8 from RBP.\n\n; On entry, ECX and EDX contain values to store\n; into the local variables a and b (respectively):\n\na           equ     <[rbp-4]>\nb           equ     <[rbp-8]>\nlocalVars   proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 16  ; Make room for a and b\n\n            mov     a, ecx\n            mov     b, edx\n\n    ; Additional code here that uses a and b:\n\n            mov     rsp, rbp\n            pop     rbp\n ret\nlocalVars   endp\n```", "```\na  equ <[rbp-4]>\nb  equ a-4\nd  equ b-4\ne  equ d-4\n```", "```\nlocal  `list_of_declarations`\n```", "```\n`identifier`:`type`\n`identifier` [`elements`]:`type`\n```", "```\nprocWithLocals proc\n               local  var1:byte, local2:word, dVar:dword\n               local  qArray[4]:qword, rlocal:real4\n local  ptrVar:qword\n               local  userTypeVar:userType\n                 .\n                 .   ; Other statements in the procedure.\n                 .\nprocWithLocals endp\n```", "```\nvar1 . . . . . . . . . . . . .        byte     rbp - 00000001\nlocal2 . . . . . . . . . . . .        word     rbp - 00000004\ndVar . . . . . . . . . . . . .        dword    rbp - 00000008\nqArray . . . . . . . . . . . .        qword    rbp - 00000028\nrlocal . . . . . . . . . . . .        dword    rbp - 0000002C\nptrVar . . . . . . . . . . . .        qword    rbp - 00000034\nuserTypeVar  . . . . . . . . .        qword    rbp - 0000003C\n```", "```\noption prologue:PrologueDef\noption prologue:none\noption epilogue:EpilogueDef\noption epilogue:none\n```", "```\npush  rbp\nmov   rbp, rsp\nsub   rsp, `local_size`\n```", "```\nleave\nret\n```", "```\ncall ProcA\ncall ProcB\ncall ProcC\n```", "```\nCallProc(I);\n```", "```\n; Listing 5-8\n\n; Demonstrate obtaining the address\n; of a static variable using offset\n; operator.\n\n            option  casemap:none\n\n            .data\nstaticVar   dword   ?\n\n            .code\n            externdef someFunc:proc\n\ngetAddress  proc\n\n mov     rcx, offset staticVar\n            call    someFunc\n\n            ret\ngetAddress  endp\n\n            end\n```", "```\n00000000  48/ B9                mov    rcx, offset staticVar\n           0000000000000000 R\n0000000A  E8 00000000 E        call    someFunc\n```", "```\n; Listing 5-9\n\n; Demonstrate obtaining the address\n; of a variable using the lea instruction.\n\n            option  casemap:none\n\n            .data\nstaticVar   dword   ?\n\n            .code\n            externdef someFunc:proc\n\ngetAddress  proc\n\n            lea     rcx, staticVar\n            call    someFunc\n\n            ret\ngetAddress  endp\n            end\n```", "```\n00000000  48/ 8D 0D       lea     rcx, staticVar\n           00000000 R\n00000007  E8 00000000 E   call    someFunc\n```", "```\nlea rcx, staticVar[rdx*4]  ; Assumes LARGEADDRESSAWARE:NO\n```", "```\nFirst                                           Last\nRCX, RDX, R8, R9, R10, R11, RAX, XMM0/YMM0-XMM5/YMM5\n```", "```\n; Listing 5-10\n\n; Demonstrate passing parameters in registers.\n\n            option  casemap:none\n\n            .data\nstaticVar   dword   ?\n\n            .code\n            externdef someFunc:proc\n\n; strfill - Overwrites the data in a string with a character.\n\n;     RDI -  Pointer to zero-terminated string\n;            (for example, a C/C++ string).\n;      AL -  Character to store into the string.\n\nstrfill     proc\n            push    rdi     ; Preserve RDI because it changes\n\n; While we haven't reached the end of the string:\n\nwhlNot0:    cmp     byte ptr [rdi], 0\n            je      endOfStr\n\n; Overwrite character in string with the character\n; passed to this procedure in AL:\n\n            mov     [rdi], al\n\n; Move on to the next character in the string and\n; repeat this process:\n\n            inc     rdi\n            jmp     whlNot0\n\nendOfStr:   pop     rdi\n            ret\nstrfill     endp\n            end\n```", "```\nlea  rdi, stringData ; Load address of string into RDI\nmov  al, ' '         ; Fill string with spaces\ncall strfill\n```", "```\ncall print\nbyte \"This parameter is in the code stream.\",0\n```", "```\n; Listing 5-11\n\n; Demonstration passing parameters in the code stream.\n\n        option  casemap:none\n\nnl          =       10\nstdout      =       -11\n\n            .const\nttlStr      byte    \"Listing 5-11\", 0\n\n            .data\nsoHandle    qword   ?\nbWritten    dword   ?\n\n            .code\n\n            ; Magic equates for Windows API calls:\n\n            extrn __imp_GetStdHandle:qword\n            extrn __imp_WriteFile:qword\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; Here's the print procedure.\n; It expects a zero-terminated string\n; to follow the call to print.\n\nprint       proc\n            push    rbp\n            mov     rbp, rsp\n            and     rsp, -16         ; Ensure stack is 16-byte-aligned\n            sub     rsp, 48          ; Set up stack for MS ABI\n\n; Get the pointer to the string immediately following the\n; call instruction and scan for the zero-terminating byte.\n\n            mov     rdx, [rbp+8]     ; Return address is here\n            lea     r8, [rdx-1]      ; R8 = return address - 1\nsearch4_0:  inc     r8               ; Move on to next char\n            cmp     byte ptr [R8], 0 ; At end of string?\n            jne     search4_0\n\n; Fix return address and compute length of string:\n\n            inc     r8               ; Point at new return address\n            mov     [rbp+8], r8      ; Save return address\n            sub     r8, rdx          ; Compute string length\n            dec     r8               ; Don't include 0 byte\n\n; Call WriteFile to print the string to the console:\n\n; WriteFile(fd, bufAdrs, len, &bytesWritten);\n\n; Note: pointer to the buffer (string) is already\n; in RDX. The len is already in R8\\. Just need to\n; load the file descriptor (handle) into RCX:\n\n            mov     rcx, soHandle    ; Zero-extends!\n            lea     r9, bWritten     ; Address of \"bWritten\" in R9\n            call    __imp_WriteFile\n\n            leave\n            ret\nprint       endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 40\n\n; Call getStdHandle with \"stdout\" parameter\n; in order to get the standard output handle\n; we can use to call write. Must set up\n; soHandle before first call to print procedure.\n\n            mov     ecx, stdout      ; Zero-extends!\n            call    __imp_GetStdHandle\n            mov     soHandle, rax    ; Save handle\n\n; Demonstrate passing parameters in code stream\n; by calling the print procedure:\n\n            call    print\n            byte    \"Hello, world!\", nl, 0\n\n; Clean up, as per Microsoft ABI:\n\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end \n```", "```\nlea  r8, [rdx-1]\n```", "```\nCallProc(i,j,k);\n```", "```\npush  k  ; Assumes i, j, and k are all 32-bit\npush  j  ; variables\npush  i  \ncall  CallProc\n```", "```\npush  qword ptr k\npush  qword ptr j\npush  qword ptr i\ncall  CallProc\n```", "```\ni    dword ?\nj    dword ?\nk    dword ?\npad  qword ?  ; Ensures that there are at least 64 bits\n              ; beyond the k variable\n```", "```\nsub  rsp, 12\nmov  eax, k\nmov  [rsp+8], eax\nmov  eax, j\nmov  [rsp+4], eax\nmov  eax, i\nmov  [rsp], eax\ncall CallProc\n```", "```\nsub  rsp, 16   ; Allocate a multiple of 8 bytes\nmov  eax, k\nmov  [rsp+8], eax\nmov  eax, j\nmov  [rsp+4], eax\nmov  eax, i\nmov  [rsp], eax\ncall CallProc\n```", "```\nsub  rsp, 24   ; Allocate a multiple of 8 bytes\nmov  eax, k\nmov  [rsp+16], eax\nmov  eax, j\nmov  [rsp+8], eax\nmov  eax, i\nmov  [rsp], eax\ncall CallProc\n```", "```\nCallProc proc\n         push  rbp      ; This is the standard entry sequence\n         mov   rbp, rsp ; Get base address of activation record into RBP\n          .\n          .\n          .\n         leave\n         ret   24\n```", "```\nmov eax, [rbp+32]    ; Accesses the k parameter\nmov ebx, [rbp+24]    ; Accesses the j parameter\nmov ecx, [rbp+16]    ; Accesses the i parameter\n```", "```\n; Listing 5-12\n\n; Accessing a parameter on the stack.\n\n        option  casemap:none\n\nnl          =       10\nstdout      =       -11\n\n            .const\nttlStr      byte    \"Listing 5-12\", 0\nfmtStr1     byte    \"Value of parameter: %d\", nl, 0\n\n            .data\nvalue1      dword   20\nvalue2      dword   30\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\ntheParm     equ     <[rbp+16]>\nValueParm   proc\n            push    rbp\n            mov     rbp, rsp\n\n            sub     rsp, 32         ; \"Magic\" instruction\n\n            lea     rcx, fmtStr1\n            mov     edx, theParm\n            call    printf\n\n            leave\n            ret\nValueParm   endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 40\n\n            mov     eax, value1\n            mov     [rsp], eax      ; Store parameter on stack\n            call    ValueParm\n\n            mov     eax, value2\n            mov     [rsp], eax\n            call    ValueParm\n\n; Clean up, as per Microsoft ABI:\n\n            leave\n            ret                     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\n`proc_name`  proc  `parameter_list`\n```", "```\n`parm_name`:`type`\n```", "```\nprocWithParms proc  k:byte, j:word, i:dword\n                .\n                .\n                .\nprocWithParms endp\n```", "```\nmov   eax, dwordValue\npush  rax             ; Parms are always 64 bits\nmov   ax, wordValue\npush  rax\nmov   al, byteValue\npush  rax\ncall  procWithParms\n```", "```\nsub   rsp, 24         ; Reserve storage for parameters\nmov   eax, dwordValue ; i\nmov   [rsp+16], eax\nmov   ax, wordValue\nmov   [rsp+8], ax     ; j\nmov   al, byteValue\nmov   [rsp], al       ; k\ncall  procWithParms\n```", "```\n; Listing 5-13\n\n; Accessing a reference parameter on the stack.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 5-13\", 0\nfmtStr1     byte    \"Value of parameter: %d\", nl, 0\n\n            .data\nvalue1      dword   20\nvalue2      dword   30\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\ntheParm     equ     <[rbp+16]> \nRefParm     proc\n            push    rbp\n            mov     rbp, rsp\n\n            sub     rsp, 32         ; \"Magic\" instruction\n\n            lea     rcx, fmtStr1\n            mov     rax, theParm    ; Dereference parameter\n            mov     edx, [rax]\n            call    printf\n\n            leave\n            ret\nRefParm     endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 40\n\n            lea     rax, value1\n            mov     [rsp], rax      ; Store address on stack\n            call    RefParm\n\n lea     rax, value2\n            mov     [rsp], rax\n            call    RefParm\n\n; Clean up, as per Microsoft ABI:\n\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing5-13**\n\nC:\\>**echo off**\n Assembling: listing5-13.asm\nc.cpp\n\nC:\\>**listing5-13**\nCalling Listing 5-13:\nValue of parameter: 20\nValue of parameter: 30\nListing 5-13 terminated\n```", "```\n; Listing 5-14\n\n; Passing a large object by reference.\n\n option  casemap:none\n\nnl          =       10\nNumElements =       24\n\nPt          struct\nx           byte    ?\ny           byte    ?\nPt          ends\n\n            .const\nttlStr      byte    \"Listing 5-14\", 0\nfmtStr1     byte    \"RefArrayParm[%d].x=%d \", 0\nfmtStr2     byte    \"RefArrayParm[%d].y=%d\", nl, 0\n\n            .data\nindex       dword   ?\nPts         Pt      NumElements dup ({})\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\nptArray     equ     <[rbp+16]> \nRefAryParm  proc\n            push    rbp\n            mov     rbp, rsp\n\n            mov     rdx, ptArray\n            xor     rcx, rcx        ; RCX = 0\n\n; While ECX < NumElements, initialize each\n; array element. x = ECX/8, y = ECX % 8.\n\nForEachEl:  cmp     ecx, NumElements\n            jnl     LoopDone\n\n            mov     al, cl\n            shr     al, 3           ; AL = ECX / 8\n            mov     [rdx][rcx*2].Pt.x, al\n\n            mov     al, cl\n            and     al, 111b        ; AL = ECX % 8\n            mov     [rdx][rcx*2].Pt.y, al\n            inc     ecx\n            jmp     ForEachEl\n\nLoopDone:   leave\n ret\nRefAryParm  endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 40\n\n; Initialize the array of points:\n\n            lea     rax, Pts\n            mov     [rsp], rax      ; Store address on stack\n            call    RefAryParm\n\n; Display the array:\n\n            mov     index, 0\ndispLp:     cmp     index, NumElements\n            jnl     dispDone\n\n            lea     rcx, fmtStr1\n            mov     edx, index              ; Zero-extends!\n            lea     r8, Pts                 ; Get array base\n            movzx   r8, [r8][rdx*2].Pt.x    ; Get x field\n            call    printf\n\n            lea     rcx, fmtStr2\n            mov     edx, index              ; Zero-extends!\n            lea     r8, Pts                 ; Get array base\n            movzx   r8, [r8][rdx*2].Pt.y    ; Get y field\n            call    printf\n\n            inc     index\n            jmp     dispLp\n\n; Clean up, as per Microsoft ABI:\n\ndispDone:\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing5-14**\n\nC:\\>**echo off**\n Assembling: listing5-14.asm\nc.cpp\n\nC:\\>**listing5-14**\nCalling Listing 5-14:\nRefArrayParm[0].x=0 RefArrayParm[0].y=0\nRefArrayParm[1].x=0 RefArrayParm[1].y=1\nRefArrayParm[2].x=0 RefArrayParm[2].y=2\nRefArrayParm[3].x=0 RefArrayParm[3].y=3\nRefArrayParm[4].x=0 RefArrayParm[4].y=4\nRefArrayParm[5].x=0 RefArrayParm[5].y=5\nRefArrayParm[6].x=0 RefArrayParm[6].y=6\nRefArrayParm[7].x=0 RefArrayParm[7].y=7\nRefArrayParm[8].x=1 RefArrayParm[8].y=0\nRefArrayParm[9].x=1 RefArrayParm[9].y=1\nRefArrayParm[10].x=1 RefArrayParm[10].y=2\nRefArrayParm[11].x=1 RefArrayParm[11].y=3\nRefArrayParm[12].x=1 RefArrayParm[12].y=4\nRefArrayParm[13].x=1 RefArrayParm[13].y=5\nRefArrayParm[14].x=1 RefArrayParm[14].y=6\nRefArrayParm[15].x=1 RefArrayParm[15].y=7\nRefArrayParm[16].x=2 RefArrayParm[16].y=0\nRefArrayParm[17].x=2 RefArrayParm[17].y=1\nRefArrayParm[18].x=2 RefArrayParm[18].y=2\nRefArrayParm[19].x=2 RefArrayParm[19].y=3\nRefArrayParm[20].x=2 RefArrayParm[20].y=4\nRefArrayParm[21].x=2 RefArrayParm[21].y=5\nRefArrayParm[22].x=2 RefArrayParm[22].y=6\nRefArrayParm[23].x=2 RefArrayParm[23].y=7\nListing 5-14 terminated\n```", "```\nvoid someFunc(int a, double b, char *c, double d)\n```", "```\nsomeProc  proc\n          push  rbp\n          mov   rbp, rsp\n          mov   [rbp+16], rbx    ; Save RBX in parm 1's shadow\n           .\n           .  ; Procedure's code\n           .\n          mov    rbx, [rbp+16]   ; Restore RBX from shadow\n          leave\n          ret\nsomeProc  endp\n```", "```\nsomeProc  proc        ; Save RBX via push\n          push  rbx   ; Note that this affects parm offsets\n          push  rbp\n          mov   rbp, rsp\n           .\n           .  ; Procedure's code\n           .\n          leave\n          pop   rbx   ; Restore RBX from stack\n          ret\nsomeProc  endp\n\nsomeProc2 proc        ; Save RBX in a local\n          push  rbp\n          mov   rbp, rsp\n          sub   rsp, 16       ; Keep stack aligned\n          mov   [rbp-8], rbx  ; Save RBX\n           .\n           .  ; Procedure's code\n           .\n mov   rbx, [rbp-8]  ; Restore RBX\n          leave\n          ret\nsomeProc2 endp\n```", "```\nand rsp, -16\n```", "```\n sub rsp, 40  ; Make room for 4 shadow parms plus a 5th parm\n  and rsp, -16 ; Guarantee RSP is now 16-byte-aligned\n\n; Code to move four parameters into registers and the\n; 5th parameter to location [RSP+32]:\n\n  mov rcx, parm1\n  mov rdx, parm2\n  mov r8,  parm3\n  mov r9,  parm4\n  mov rax, parm5\n  mov [rsp+32], rax\n  call procWith5Parms\n```", "```\n; Make room for parameters. `parm_size` is a constant\n; with the number of bytes of parameters required\n; (including 32 bytes for the shadow parameters).\n\n  sub rsp, `parm_size`\n\n  `Code that copies parameters to the stack`\n\n  call procedure\n\n; Clean up the stack after the call:\n\n  add rsp, `parm_size`\n```", "```\n; 1st procedure call:\n\n  sub rsp, `parm_size`   ; Allocate storage for proc1 parms\n  `Code that copies parameters to the registers and stack`\n  call proc1\n  add  rsp, `parm_size`  ; Clean up the stack\n\n; 2nd procedure call:\n\n  sub rsp, `parm_size2`  ; Allocate storage for proc2 parms\n  `Code that copies parameters to the registers and stack`\n  call proc2\n  add rsp, `parm_size2`  ; Clean up the stack\n```", "```\n; 1st procedure call:\n\n  sub rsp, `max_parm_size`   ; Allocate storage for all parms\n  `Code that copies parameters to the registers and stack for proc1`\n  call proc1\n\n  `Code that copies parameters to the registers and stack for proc2`\n  call proc2\n  add rsp, `max_parm_size`   ; Clean up the stack\n```", "```\nrbxSave  equ   [rbp-8]\nsomeProc proc\n         push  rbp\n         mov   rbp, rsp\n         sub   rsp, 48       ; Also leave stack 16-byte-aligned\n         mov   rbxSave, rbx  ; Preserve RBX\n          .\n          .\n          .\n         lea   rcx, fmtStr\n         mov   rdx, rbx      ; Print value in RBX (presumably)\n         call  printf\n          .\n          .\n          .\n         mov   rbx, rbxSave  ; Restore RBX\n         leave               ; Clean up stack\n         ret\nsomeProc endp\n```", "```\nRecursive proc\n\n          call Recursive\n          ret\n\nRecursive endp\n```", "```\nRecursive proc\n\n          dec  eax\n          jz   allDone\n          call Recursive\nallDone:\n          ret\n\nRecursive endp\n```", "```\nRecursive proc\niterLp:\n          dec  eax\n          jnz  iterLp\n          ret\nRecursive endp\n```", "```\n; Listing 5-15\n\n; Recursive quicksort.\n\n        option  casemap:none\n\nnl          =       10\nnumElements =       10\n\n            .const\nttlStr      byte    \"Listing 5-15\", 0\nfmtStr1     byte    \"Data before sorting: \", nl, 0\nfmtStr2     byte    \"%d \"   ; Use nl and 0 from fmtStr3\nfmtStr3     byte    nl, 0\nfmtStr4     byte    \"Data after sorting: \", nl, 0\n\n            .data\ntheArray    dword   1,10,2,9,3,8,4,7,5,6\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; quicksort - Sorts an array using the\n;             quicksort algorithm.\n\n; Here's the algorithm in C, so you can follow along:\n\n  void quicksort(int a[], int low, int high)\n  {\n      int i,j,Middle;\n      if(low < high)\n      {\n          Middle = a[(low+high)/2];\n          i = low;\n          j = high;\n          do\n          {\n              while(a[i] <= Middle) i++;\n              while(a[j] > Middle) j--;\n              if(i <= j)\n              {\n                  swap(a[i],a[j]);\n                  i++;\n                  j--;\n              }\n          } while(i <= j);\n\n          // Recursively sort the two subarrays.\n\n          if(low < j) quicksort(a,low,j-1);\n          if(i < high) quicksort(a,j+1,high);\n      }\n  }\n\n; Args:\n    ; RCX (_a):      Pointer to array to sort\n    ; RDX (_lowBnd): Index to low bound of array to sort\n    ; R8 (_highBnd): Index to high bound of array to sort\n\n_a          equ     [rbp+16]        ; Ptr to array\n_lowBnd     equ     [rbp+24]        ; Low bounds of array\n_highBnd    equ     [rbp+32]        ; High bounds of array\n\n; Local variables (register save area):\n\nsaveR9      equ     [rbp+40]        ; Shadow storage for R9\nsaveRDI     equ     [rbp-8]\nsaveRSI     equ     [rbp-16]\nsaveRBX     equ     [rbp-24]\nsaveRAX     equ     [rbp-32]\n\n; Within the procedure body, these registers\n; have the following meaning:\n\n; RCX: Pointer to base address of array to sort.\n; EDX: Lower bound of array (32-bit index).\n; R8D: Higher bound of array (32-bit index).\n\n; EDI: index (i) into array.\n; ESI: index (j) into array.\n; R9D: Middle element to compare against.\n\nquicksort   proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 32\n\n; This code doesn't mess with RCX. No\n; need to save it. When it does mess\n; with RDX and R8, it saves those registers\n; at that point.\n\n; Preserve other registers we use:\n\n            mov     saveRAX, rax\n            mov     saveRBX, rbx\n            mov     saveRSI, rsi\n            mov     saveRDI, rdi\n            mov     saveR9, r9\n\n            mov     edi, edx          ; i = low\n            mov     esi, r8d          ; j = high\n\n; Compute a pivotal element by selecting the\n; physical middle element of the array.\n\n            lea     rax, [rsi+rdi*1]  ; RAX = i+j\n            shr     rax, 1            ; (i + j)/2\n            mov     r9d, [rcx][rax*4] ; Middle = ary[(i + j)/2]\n\n; Repeat until the EDI and ESI indexes cross one\n; another (EDI works from the start toward the end\n; of the array, ESI works from the end toward the\n; start of the array).\n\nrptUntil:\n\n; Scan from the start of the array forward\n; looking for the first element greater or equal\n; to the middle element):\n\n            dec     edi     ; To counteract inc, below\nwhile1:     inc     edi     ; i = i + 1\n            cmp     r9d, [rcx][rdi*4] ; While Middle > ary[i]\n            jg      while1\n\n; Scan from the end of the array backward, looking\n; for the first element that is less than or equal\n; to the middle element.\n\n            inc     esi     ; To counteract dec, below\nwhile2:     dec     esi     ; j = j - 1\n cmp     r9d, [rcx][rsi*4] ; While Middle < ary[j]\n            jl      while2 \n\n; If we've stopped before the two pointers have\n; passed over one another, then we've got two\n; elements that are out of order with respect\n; to the middle element, so swap these two elements.\n\n            cmp     edi, esi  ; If i <= j\n            jnle    endif1\n\n            mov     eax, [rcx][rdi*4] ; Swap ary[i] and ary[j]\n            mov     r9d, [rcx][rsi*4]\n            mov     [rcx][rsi*4], eax\n            mov     [rcx][rdi*4], r9d\n\n            inc     edi       ; i = i + 1\n            dec     esi       ; j = j - 1\n\nendif1:     cmp     edi, esi  ; Until i > j\n            jng     rptUntil\n\n; We have just placed all elements in the array in\n; their correct positions with respect to the middle\n; element of the array. So all elements at indexes\n; greater than the middle element are also numerically\n; greater than this element. Likewise, elements at\n; indexes less than the middle (pivotal) element are\n; now less than that element. Unfortunately, the\n; two halves of the array on either side of the pivotal\n; element are not yet sorted. Call quicksort recursively\n; to sort these two halves if they have more than one\n; element in them (if they have zero or one elements, then\n; they are already sorted).\n\n            cmp     edx, esi  ; If lowBnd < j\n            jnl     endif2\n\n            ; Note: a is still in RCX,\n            ; low is still in RDX.\n            ; Need to preserve R8 (high).\n            ; Note: quicksort doesn't require stack alignment.\n\n            push    r8\n            mov     r8d, esi\n            call    quicksort ; (a, low, j)\n            pop     r8\n\nendif2:     cmp     edi, r8d  ; If i < high\n            jnl     endif3\n\n            ; Note: a is still in RCX,\n            ; High is still in R8D.\n            ; Need to preserve RDX (low).\n            ; Note: quicksort doesn't require stack alignment.\n\n push    rdx\n            mov     edx, edi\n            call    quicksort ; (a, i, high)\n            pop     rdx\n\n; Restore registers and leave:\n\nendif3:\n            mov     rax, saveRAX\n            mov     rbx, saveRBX\n            mov     rsi, saveRSI\n            mov     rdi, saveRDI\n            mov     r9, saveR9\n            leave\n            ret\nquicksort   endp\n\n; Little utility to print the array elements:\n\nprintArray  proc\n            push    r15\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 40   ; Shadow parameters\n\n            lea     r9, theArray\n            mov     r15d, 0\nwhileLT10:  cmp     r15d, numElements\n            jnl     endwhile1\n\n            lea     rcx, fmtStr2\n            lea     r9, theArray\n            mov     edx, [r9][r15*4]\n            call    printf\n\n            inc     r15d\n            jmp     whileLT10\n\nendwhile1:  lea     rcx, fmtStr3\n            call    printf\n            leave\n            pop     r15\n            ret\nprintArray  endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 32   ; Shadow storage\n\n; Display unsorted array:\n\n            lea     rcx, fmtStr1\n            call    printf\n            call    printArray\n\n; Sort the array:\n\n            lea     rcx, theArray\n            xor     rdx, rdx                ; low = 0\n            mov     r8d, numElements-1      ; high = 9\n            call    quicksort               ; (theArray, 0, 9)\n\n; Display sorted results:\n\n            lea     rcx, fmtStr4\n            call    printf\n            call    printArray\n\n            leave\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing5-15**\n\nC:\\>**echo off**\n Assembling: listing5-15.asm\nc.cpp\n\nC:\\>**listing5-15**\nCalling Listing 5-15:\nData before sorting:\n1\n10\n2\n9\n3\n8\n4\n7\n5\n6\n\nData after sorting:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nListing 5-15 terminated\n```", "```\ncall `proc_name`  ; Direct call to procedure `proc_name`\ncall reg64      ; Indirect call to procedure whose address\n                ; appears in the reg[64]\ncall qwordVar   ; Indirect call to the procedure whose address\n                ; appears in the qwordVar quad-word variable\n```", "```\ncall `proc_name`\n .\n .\n .\nmov  rax, offset `proc_name`\ncall rax\n .\n .\n .\nlea   rax, `proc_name`\ncall  rax\n```", "```\np     proc\n        .\n        .\n        .\np     endp\n        .\n        .\n        .\n       .data\nptrToP qword   offset p\n        .\n        .\n        .\n     call ptrToP ; Calls p if ptrToP has not changed\n```", "```\n .data\nProcPointer  qword  offset p   ; Initialize ProcPointer with \n                               ; the address of p\n              .\n              .\n              .\n             call ProcPointer  ; First invocation calls p\n\n; Reload ProcPointer with the address of q.\n\n             lea   rax, q\n             mov  ProcPointer, rax\n              .\n              .\n              .\n             call  ProcPointer ; This invocation calls q\n```", "```\nprocWithProcParm proc  parm1:word, procParm:proc\n```", "```\ncall procParm\n```", "```\npreserveRegs proc\n             push   rax\n             push   rbx\n             push   rcx\n               .\n               .\n               .\n             pop    rcx\n             pop    rbx\n             pop    rax\n             ret\npreserveRegs endp\n```", "```\npreserveRegs proc\nsaveRAX      textequ <[rsp+16]>\nsaveRBX      textequ <[rsp+8]>\nsaveRCX      textequ <[rsp]>\n\n             sub     rsp, 24      ; Make room for locals\n             mov     saveRAX, rax\n             mov     saveRBX, rbx\n             mov     saveRCX, rcx\n               .\n               .\n               .\n             mov     rcx, saveRCX\n             mov     rbx, saveRBX\n             mov     rax, saveRAX\n             add     rsp, 24      ; Deallocate locals\n             ret\npreserveRegs endp\n```", "```\n option  prologue:PrologueDef\n             option  epilogue:EpilogueDef\npreserveRegs proc    parm1:byte, parm2:dword\n local   localVar1:dword, localVar2:qword\n             local   saveRAX:qword, saveRBX:qword\n             local   saveRCX:qword\n\n             mov     saveRAX, rax\n             mov     saveRBX, rbx\n             mov     saveRCX, rcx\n               .\n               .\n               .\n             mov     rcx, saveRCX\n             mov     rbx, saveRBX\n             mov     rax, saveRAX\n             ret\npreserveRegs endp\n```", "```\ncallsFuncs   proc\nsaveRAX      textequ <[rbp-8]>\nsaveRBX      textequ <[rbp-16]>\nsaveRCX      textequ <[rbp-24]>\n             push    rbp\n             mov     rbp, rsp\n             sub     rsp, 48      ; Make room for locals and parms\n             mov     saveRAX, rax ; Preserve registers in\n             mov     saveRBX, rbx ; local variables\n             mov     saveRCX, rcx\n\n               .\n               .\n               .\n             mov    [rsp], rax    ; Store parm1\n             mov    [rsp+8], rbx  ; Store parm2\n             mov    [rsp+16], rcx ; Store parm3\n             call   theFunction\n               .\n               .\n               .\n             mov     rcx, saveRCX ; Restore registers\n             mov     rbx, saveRBX\n             mov     rax, saveRAX\n             leave                ; Deallocate locals\n             ret\ncallsFuncs   endp\n```", "```\n    procWithLocals proc\n                   local  var1:word, local2:dword, dVar:byte\n                   local  qArray[2]:qword, rlocal[2]:real4\n                   local  ptrVar:qword\n                     .\n                     .   ; Other statements in the procedure.\n                     .\n              procWithLocals endp\n    ```", "```\n    procWithParms proc  parm1:byte, parm2:word, parm3:dword, parm4:qword\n    ```", "```\n    procWithLocals proc\n                   local lclVar1:byte, lclVar2:word, lclVar3:dword, lclVar4:qword\n    ```"]