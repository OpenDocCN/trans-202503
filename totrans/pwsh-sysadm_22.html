<html><head></head><body>
<h2 class="h2" id="ch19"><span epub:type="pagebreak" id="page_265"/><span class="big">19</span><br/>REFACTORING YOUR CODE</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">In the preceding chapter, you built a VM with a running SQL server using nothing besides an existing hypervisor, an operating system ISO file, and a little bit of code. Doing so meant linking together many of the functions you created in the previous chapters. Here, you’ll do</span> something different: instead of adding new functionality to your PowerLab module, you’ll dig into your code and see if you can make your module a little more modular.</p>&#13;
<p class="indent">When I say <em>modular</em>, I’m talking about separating the functionality of the code into reusable functions that can handle many situations. The more modular the code, the more generally applicable it will be. And the more generally applicable your code, the more useful it will be. With modular code, you can reuse functions such as <code>New-PowerLabVM</code> or <code>Install-PowerLabOperatingSystem</code> to install many kinds of servers (which you’ll see in the next chapter).</p>&#13;
<h3 class="h3" id="ch19lev1"><span epub:type="pagebreak" id="page_266"/>A Second Look at New-PowerLabSqlServer</h3>&#13;
<p class="noindent">You created two main functions in <a href="ch18.xhtml#ch18">Chapter 18</a>: <code>New-PowerLabSqlServer</code> and <code>Install-PowerLabSqlServer</code>. You did so with the goal of setting up an SQL server. But what if you want to make your functions more generally applicable? After all, different servers share a lot of components with SQL ones: virtual machine, virtual disk, Windows OS, and so forth. You could simply copy the function you have and swap out all the specific SQL references for references to the server type you want.</p>&#13;
<p class="indent">But I’m going to have to advise against this. There’s no need for all that extra code. Instead, you’ll simply refactor your existing code. <em>Refactoring</em> refers to the process of changing a code’s insides without changing its functionality; in other words, refactoring is something for you, the programmer. It helps code be more readable, and it makes sure that you can keep growing your project without running into too many headache-inducing organizational issues.</p>&#13;
<p class="indent">Let’s start by taking a look at that <code>New-PowerLabSqlServer</code> function you created, shown in <a href="ch19.xhtml#ch19list1">Listing 19-1</a>.</p>&#13;
<pre>function New-PowerLabSqlServer { &#13;
    [CmdletBinding()] &#13;
 <span class="ent">❶</span> param &#13;
    ( &#13;
        [Parameter(Mandatory)] &#13;
        [string]$Name, &#13;
 &#13;
        [Parameter(Mandatory)] &#13;
        [pscredential]$DomainCredential, &#13;
 &#13;
        [Parameter(Mandatory)] &#13;
        [pscredential]$VMCredential, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$VMPath = 'C:\PowerLab\VMs', &#13;
 &#13;
        [Parameter()] &#13;
        [int64]$Memory = 4GB, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$Switch = 'PowerLab', &#13;
 &#13;
        [Parameter()] &#13;
        [int]$Generation = 2, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$DomainName = 'powerlab.local', &#13;
 &#13;
        [Parameter()] &#13;
     <span class="ent">❷</span> [string]$AnswerFilePath = "C:\Program Files\WindowsPowerShell\Modules&#13;
           \PowerLab\SqlServer.ini"&#13;
    ) &#13;
&#13;
<span epub:type="pagebreak" id="page_267"/> <span class="ent">❸</span> ## Build the VM &#13;
    $vmparams = @{  &#13;
        Name       = $Name &#13;
        Path       = $VmPath &#13;
        Memory     = $Memory &#13;
        Switch     = $Switch &#13;
        Generation = $Generation &#13;
    } &#13;
    New-PowerLabVm @vmParams &#13;
 &#13;
    Install-PowerLabOperatingSystem -VmName $Name &#13;
    Start-VM -Name $Name &#13;
 &#13;
    Wait-Server -Name $Name -Status Online -Credential $VMCredential &#13;
 &#13;
  $addParams = @{ &#13;
        DomainName = $DomainName &#13;
        Credential = $DomainCredential &#13;
        Restart    = $true &#13;
        Force      = $true &#13;
    } &#13;
    Invoke-Command -VMName $Name -ScriptBlock { Add-Computer&#13;
    @using:addParams } -Credential $VMCredential &#13;
 &#13;
    Wait-Server -Name $Name -Status Offline -Credential $VMCredential &#13;
 &#13;
 <span class="ent">❹</span> Wait-Server -Name $Name -Status Online -Credential $DomainCredential &#13;
 &#13;
    $tempFile = Copy-Item -Path $AnswerFilePath -Destination "C:\Program&#13;
    Files\WindowsPowerShell\Modules\PowerLab\temp.ini" -PassThru &#13;
     &#13;
    Install-PowerLabSqlServer -ComputerName $Name -AnswerFilePath $tempFile&#13;
    .FullName -DomainCredential $DomainCredential &#13;
}</pre>&#13;
<p class="caption" id="ch19list1"><em>Listing 19-1: <code>New-PowerLabSqlServer</code> function</em></p>&#13;
<p class="indent">How would you go about refactoring this code? Well for starters, you know that every server needs a virtual machine, a virtual disk, and an operating system; you handle these needs in the code block between <span class="ent">❸</span> and <span class="ent">❹</span>.</p>&#13;
<p class="indent">If you look at this code, though, you’ll see that you can’t just pull it out and paste it into a new function. Parameters are defined in the <code>New-PowerLabSqlServer</code> function <span class="ent">❶</span> that you use in those lines. Notice that the only parameter that’s specific to SQL here is <code>AnswerFilePath</code> <span class="ent">❷</span>.</p>&#13;
<p class="indent">Now that you’ve identified the code that isn’t SQL specific, let’s pull it out and use it to create the new function <code>New-PowerLabServer</code> (<a href="ch19.xhtml#ch19list2">Listing 19-2</a>).</p>&#13;
<pre>function New-PowerLabServer { &#13;
    [CmdletBinding()] &#13;
    param &#13;
    ( &#13;
        [Parameter(Mandatory)] &#13;
        [string]$Name, &#13;
 &#13;
<span epub:type="pagebreak" id="page_268"/>        [Parameter(Mandatory)] &#13;
        [pscredential]$DomainCredential, &#13;
 &#13;
        [Parameter(Mandatory)] &#13;
        [pscredential]$VMCredential, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$VMPath = 'C:\PowerLab\VMs', &#13;
 &#13;
        [Parameter()] &#13;
        [int64]$Memory = 4GB, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$Switch = 'PowerLab', &#13;
 &#13;
        [Parameter()] &#13;
        [int]$Generation = 2, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$DomainName = 'powerlab.local' &#13;
    ) &#13;
 &#13;
    ## Build the VM &#13;
    $vmparams = @{  &#13;
        Name       = $Name &#13;
        Path       = $VmPath &#13;
        Memory     = $Memory &#13;
        Switch     = $Switch &#13;
        Generation = $Generation &#13;
    } &#13;
    New-PowerLabVm @vmParams &#13;
 &#13;
    Install-PowerLabOperatingSystem -VmName $Name &#13;
    Start-VM -Name $Name &#13;
 &#13;
    Wait-Server -Name $Name -Status Online -Credential $VMCredential &#13;
 &#13;
    $addParams = @{ &#13;
        DomainName = $DomainName &#13;
        Credential = $DomainCredential &#13;
        Restart    = $true &#13;
        Force      = $true &#13;
    } &#13;
    Invoke-Command -VMName $Name&#13;
    -ScriptBlock { Add-Computer @using:addParams } -Credential $VMCredential &#13;
 &#13;
    Wait-Server -Name $Name -Status Offline -Credential $VMCredential &#13;
 &#13;
    Wait-Server -Name $Name -Status Online -Credential $DomainCredential &#13;
}</pre>&#13;
<p class="caption" id="ch19list2"><em>Listing 19-2: A more generic <code>New-PowerLabServer</code> function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_269"/>At this point, you have a general server-provisioning function, but no way to indicate the kind of server you’re creating. Let’s fix that by using another parameter called <code>ServerType</code>:</p>&#13;
<pre>[Parameter(Mandatory)] &#13;
[ValidateSet('SQL', 'Web', 'Generic')] &#13;
[string]$ServerType</pre>&#13;
<p class="indent">Notice the new <code>ValidateSet</code> parameter. I’ll give an in-depth explanation of what this does later in the chapter; for now, you just need to know that this ensures that the user can pass in only a server type contained within this set.</p>&#13;
<p class="indent">Now that you have this parameter, let’s use it. Insert a <code>switch</code> statement at the end of the function to execute different code depending on which server type the user enters:</p>&#13;
<pre>switch ($ServerType) { &#13;
    'Web' { &#13;
        Write-Host 'Web server deployments are not supported at this time' &#13;
        break &#13;
    } &#13;
    'SQL' { &#13;
        $tempFile = Copy-Item -Path $AnswerFilePath -Destination "C:\Program&#13;
        Files\WindowsPowerShell\Modules\PowerLab\temp.ini" -PassThru &#13;
        Install-PowerLabSqlServer -ComputerName $Name -AnswerFilePath&#13;
        $tempFile.FullName -DomainCredential $DomainCredential &#13;
        break &#13;
    } &#13;
    'Generic' { &#13;
        break &#13;
    } &#13;
 <span class="ent">❶</span> default { &#13;
        throw "Unrecognized server type: [$_]" &#13;
    } &#13;
}</pre>&#13;
<p class="indent">As you can see, you handle the three types of server input (and use the <code>default</code> case to handle any exceptions <span class="ent">❶</span>). But there’s a problem. To fill out the SQL code, you copied and pasted code from the <code>New-PowerLabSqlServer</code> function, and now you’re using something you don’t have: the <code>AnswerFilePath</code> variable. Recall that when you moved your generic code to a new function, you left this variable behind, meaning that you can’t use it here . . . or can you?</p>&#13;
<h3 class="h3" id="ch19lev2">Using Parameter Sets</h3>&#13;
<p class="noindent">In situations like the preceding one, when you have one parameter that determines which other parameter you need, PowerShell has a handy feature called <em>parameter sets</em>. You can think of parameter sets as letting you use conditional logic to control which parameters a user inputs.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_270"/>In this example, you’ll use three parameter sets: a set for provisioning SQL servers, a set for provisioning web servers, and a default set.</p>&#13;
<p class="indent">You can define parameter sets by using the <code>ParameterSetName</code> attribute followed by a name. Here’s an example:</p>&#13;
<pre>[Parameter(Mandatory)] &#13;
[ValidateSet('SQL', 'Web', 'Generic')] &#13;
[string]$ServerType, &#13;
 &#13;
[Parameter(ParameterSetName = 'SQL')] &#13;
[string]$AnswerFilePath = "C:\Program Files\WindowsPowerShell\Modules\PowerLab\SqlServer.ini", &#13;
 &#13;
[Parameter(ParameterSetName = 'Web')] &#13;
[switch]$NoDefaultWebsite</pre>&#13;
<p class="indent">Notice that you haven’t assigned <code>ServerType</code> a parameter set. Parameters that are not part of a parameter set can be used with any set. Because of this, you can use <code>ServerType</code> with either <code>AnswerFilePath</code> or the newly created parameter you’ll be using for web server provisioning: <code>CreateDefaultWebsite</code>.</p>&#13;
<p class="indent">You can see here that the majority of the parameters stay the same, but you add a final one based on what you pass in for <code>ServerType</code>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabServer -Name WEBSRV -DomainCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"> -VMCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"/> &#13;
<span class="codestrong1">-ServerType 'Web' -NoDefaultWebsite</span> &#13;
PS&gt; <span class="codestrong1">New-PowerLabServer -Name SQLSRV -DomainCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"> -VMCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"/> &#13;
<span class="codestrong1">-ServerType 'SQL' -AnswerFilePath 'C:\OverridingTheDefaultPath\SqlServer.ini'</span></pre>&#13;
<p class="indent">If you try to mix and match, and use parameters from two different parameter sets at the same time, you’ll fail:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabServer -Name SQLSRV -DomainCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"> -VMCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"/> &#13;
<span class="codestrong1">-ServerType 'SQL' -NoDefaultWebsite -AnswerFilePath 'C:\OverridingTheDefaultPath\SqlServer.ini'</span>&#13;
 &#13;
New-PowerLabServer : Parameter set cannot be resolved using the specified named parameters. &#13;
At line:1 char:1 &#13;
+ New-PowerLabServer -Name SQLSRV -ServerType 'SQL' -NoDefaultWebsite - ... &#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &#13;
    + CategoryInfo          : InvalidArgument: (:) [New-PowerLabServer], ParameterBindingException &#13;
    + FullyQualifiedErrorId : AmbiguousParameterSet,New-PowerLabServer</pre>&#13;
<p class="indent">What would happen if you did the opposite and used neither the <code>NoDefaultWebsite</code> parameter nor the <code>AnswerFilePath</code> parameter?</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabServer -Name SQLSRV -DomainCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"> -VMCredential</span> <span class="codeitalicst1">CredentialHere</span>&#13;
<span class="codestrong1">-ServerType 'SQL'</span> &#13;
New-PowerLabServer : Parameter set cannot be resolved using the specified named parameters. &#13;
At line:1 char:1 &#13;
+ New-PowerLabServer -Name SQLSRV -DomainCredential $credential... &#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &#13;
    + CategoryInfo          : InvalidArgument: (:) [New-PowerLabServer], ParameterBindingException&#13;
    + FullyQualifiedErrorId : AmbiguousParameterSet,New-PowerLabServer&#13;
<span epub:type="pagebreak" id="page_271"/>PS&gt; <span class="codestrong1">New-PowerLabServer -Name WEBSRV -DomainCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"> -VMCredential</span> <span class="codeitalicst1">CredentialHere</span><span class="codestrong1"/> &#13;
<span class="codestrong1">-ServerType 'Web'</span>&#13;
New-PowerLabServer : Parameter set cannot be resolved using the specified named parameters. &#13;
At line:1 char:1 &#13;
+ New-PowerLabServer -Name WEBSRV -DomainCredential $credential... &#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &#13;
    + CategoryInfo          : InvalidArgument: (:) [New-PowerLabServer], ParameterBindingException&#13;
    + FullyQualifiedErrorId : AmbiguousParameterSet,New-PowerLabServer</pre>&#13;
<p class="indent">You get the same error about not being able to resolve the parameter set as before. Why? PowerShell doesn’t know which parameter set to use! Earlier, I said you’d be using three sets, but you defined only two. You need to set a default parameter set. As you saw earlier, parameters that are not explicitly assigned to a parameter set can be used in conjunction with any in a set. However, if you do define a default parameter set, PowerShell will use those parameters if no parameters in any set are being used.</p>&#13;
<p class="indent">As for your default set, you could pick the defined SQL or web parameter set to be your default, or you could simply define a nonspecific parameter set like <code>blah blah</code>, which would create an inherent set for all parameters that do not have an explicit set defined:</p>&#13;
<pre>[CmdletBinding(DefaultParameterSetName = 'blah blah')]</pre>&#13;
<p class="indent">If you don’t want to set a defined parameter set as default, you can set it to anything, and PowerShell will ignore both parameter sets <em>if no parameter in a parameter set is used</em>. This is what you need to do in this case; it’s perfectly okay to not use a defined parameter set because you have the <code>ServerType</code> parameter to indicate whether or not you’re going to deploy a web server or SQL server.</p>&#13;
<p class="indent">With your new parameter sets, the parameter portion of <code>New-PowerLabServer</code> looks like <a href="ch19.xhtml#ch19list3">Listing 19-3</a>.</p>&#13;
<pre>function New-PowerLabServer { &#13;
    [CmdletBinding(DefaultParameterSetName = 'Generic')] &#13;
    param &#13;
    ( &#13;
        [Parameter(Mandatory)] &#13;
        [string]$Name, &#13;
 &#13;
        [Parameter(Mandatory)] &#13;
        [pscredential]$DomainCredential, &#13;
 &#13;
        [Parameter(Mandatory)] &#13;
        [pscredential]$VMCredential, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$VMPath = 'C:\PowerLab\VMs', &#13;
 &#13;
        [Parameter()] &#13;
        [int64]$Memory = 4GB, &#13;
 &#13;
<span epub:type="pagebreak" id="page_272"/>        [Parameter()] &#13;
        [string]$Switch = 'PowerLab', &#13;
        [Parameter()]&#13;
        [int]$Generation = 2, &#13;
 &#13;
        [Parameter()] &#13;
        [string]$DomainName = 'powerlab.local', &#13;
 &#13;
        [Parameter()] &#13;
        [ValidateSet('SQL', 'Web')] &#13;
        [string]$ServerType, &#13;
 &#13;
        [Parameter(ParameterSetName = 'SQL')] &#13;
        [string]$AnswerFilePath = "C:\Program Files\WindowsPowerShell\Modules&#13;
        \PowerLab\SqlServer.ini",&#13;
 &#13;
        [Parameter(ParameterSetName = 'Web')] &#13;
        [switch]$NoDefaultWebsite &#13;
    )</pre>&#13;
<p class="caption" id="ch19list3"><em>Listing 19-3: The new <code>New-PowerLabServer</code> function</em></p>&#13;
<p class="indent">Notice that you have a reference to the function <code>Install-PowerLabSqlServer</code>. This looks similar to the function (<code>New-PowerLabSqlServer</code>) that got us into this mess. Instead of creating the virtual machine and installing the operating system, <code>Install-PowerLabSqlServer</code> takes over from <code>New-PowerLabServer</code>, installs the SQL server software, and performs basic configuration. You might be inclined to perform this same round of refactoring on this function. You could do this, but as soon as you look at the code that’s inside <code>Install-PowerLabSqlServer</code>, you’ll soon realize there are nearly no commonalities between the installation phase of SQL server and that of other types of servers. It’s a unique process and would be hard to “genericize” for other server deployments.</p>&#13;
<h3 class="h3" id="ch19lev3">Summary</h3>&#13;
<p class="noindent">Well, now that the code is nice and refactored, you’re left with a function capable of . . . provisioning a SQL server. So back where you started, right? I hope not! Even though you haven’t changed anything about the functionality of the code, you’ve built the foundation you need to easily insert the code for creating a web server (which you’ll do in the next chapter).</p>&#13;
<p class="indent">As you saw in this chapter, refactoring PowerShell code isn’t a cut-and-dried process. Knowing the ways you can refactor your code, and which of those ways is the best for your present situation, is a skill that comes with experience. But as long as you keep what programmers call <em>the DRY principle</em> (don’t repeat yourself) in mind, you’ll be on the right path. More than anything, abiding by DRY means avoiding duplicate code and redundant <span epub:type="pagebreak" id="page_273"/>functionality. You saw this in this chapter when you chose to create a general function that created new servers, as opposed to another <code>New-PowerLab</code><span class="codeitalic">InsertServerTypeHere</span><code>Server</code> function.</p>&#13;
<p class="indent">Your hard work wasn’t for nothing. In the next chapter, you’ll get back to automating, adding the code you need to create IIS web servers.<span epub:type="pagebreak" id="page_274"/></p>&#13;
</body></html>