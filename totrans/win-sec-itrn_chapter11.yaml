- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ACTIVE
    DIRECTORY</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ACTIVE
    DIRECTORY</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: The previous chapter described the authentication configuration of a local domain.
    In this chapter, we’ll detail how Active Directory stores user and group configurations
    on an enterprise network domain. We’ll begin by inspecting the domain configuration,
    using various PowerShell commands that can enumerate the configured trust relationships,
    users, and groups. We’ll then dig into the structure of Active Directory and how
    you can access its raw information over the network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章描述了本地域的身份验证配置。在本章中，我们将详细介绍 Active Directory 如何在企业网络域上存储用户和组配置。我们将从检查域配置开始，使用各种
    PowerShell 命令列出已配置的信任关系、用户和组。然后，我们将深入探讨 Active Directory 的结构，以及如何通过网络访问其原始信息。
- en: Once you understand how Active Directory is structured, we’ll explore how Windows
    determines who can inspect and modify it. As you’ll see, like most Windows platforms,
    Active Directory uses security descriptors to grant or deny access to the configuration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了 Active Directory 的结构，我们将探讨 Windows 如何确定谁可以检查和修改它。正如你将看到的，和大多数 Windows
    平台一样，Active Directory 使用安全描述符来授予或拒绝对配置的访问权限。
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Brief History of Active Directory</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Active Directory 简史</samp>
- en: Prior to Windows 2000, the user configuration for an enterprise network was
    stored in a SAM database on the network’s domain controller. The domain controller
    authenticated users with the Netlogon protocol, which relied on the MD4 password
    hash format. To modify the SAM database, you could use the SAM remote service,
    as described in the previous chapter. This service allowed an administrator to
    add or remove users and groups on the domain controller.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 2000 之前，企业网络的用户配置存储在网络域控制器上的 SAM 数据库中。域控制器通过 Netlogon 协议对用户进行身份验证，该协议依赖于
    MD4 密码哈希格式。要修改 SAM 数据库，你可以使用之前章节中提到的 SAM 远程服务。该服务允许管理员在域控制器上添加或删除用户和组。
- en: As enterprise networks became more complex, the SAM database format proved to
    be limited. Windows 2000, which overhauled enterprise networking, moved the user
    configuration to Active Directory and changed the primary authentication protocol
    from Netlogon to Kerberos.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着企业网络变得越来越复杂，SAM 数据库格式证明了其局限性。Windows 2000 对企业网络进行全面改革，将用户配置转移到 Active Directory，并将主要的身份验证协议从
    Netlogon 更改为 Kerberos。
- en: Active Directory provides several advantages over the SAM database, as it is
    extensible and can store arbitrary data. For example, an administrator can store
    additional information with a user’s configuration to represent their security
    clearance, and an application can check this information when granting or denying
    access to a resource. Active Directory also has fine-grained security, allowing
    administrators to delegate parts of the configuration to different users more
    easily than the SAM can.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Active Directory 相对于 SAM 数据库提供了几个优势，因为它是可扩展的，并且可以存储任意数据。例如，管理员可以将额外的信息与用户的配置一起存储，以表示他们的安全许可级别，应用程序可以在授予或拒绝访问资源时检查这些信息。Active
    Directory 还具有细粒度的安全性，允许管理员比 SAM 更轻松地将配置的部分委派给不同的用户。
- en: Active Directory is stored locally on a domain controller, and computers in
    the network can access it using the *Lightweight Directory Access Protocol (LDAP)*,
    which exposes a TCP/IP network connection on port 389\. LDAP derives from the
    more complex *Directory Access Protocol (DAP)*, which formed part of the X.500
    directory service specification. If you’re familiar with the X.509 certificate
    format for exchanging public key information on secure websites, some of the following
    concepts might seem familiar.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Active Directory 存储在域控制器本地，网络中的计算机可以使用 *轻量目录访问协议（LDAP）* 访问它，该协议通过 TCP/IP 网络连接在端口
    389 上暴露。LDAP 源自更复杂的 *目录访问协议（DAP）*，后者是 X.500 目录服务规范的一部分。如果你熟悉 X.509 证书格式，用于在安全网站上交换公钥信息，那么接下来的某些概念可能会显得熟悉。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exploring an Active Directory Domain
    with PowerShell</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 PowerShell 探索 Active Directory 域</samp>
- en: Let’s begin our exploration of Active Directory with a high-level look at a
    domain configuration. [Figure 11-1](chapter11.xhtml#fig11-1) shows an example
    forest (of course, your configuration might differ).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从高层次了解一下域配置，开始探索Active Directory。[图 11-1](chapter11.xhtml#fig11-1)展示了一个示例森林（当然，你的配置可能有所不同）。
- en: '![](../images/Figure11-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: An example Windows
    forest</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-1：一个示例Windows森林</samp>
- en: To explore this forest, we’ll run various PowerShell commands that can enumerate
    its domains, users, groups, and devices. If you’d like to follow along, you can
    find setup instructions for a similar domain configuration in [Appendix A](appendix-A.xhtml).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个森林，我们将运行各种PowerShell命令，以列举它的域、用户、组和设备。如果你想跟随操作，你可以在[附录A](appendix-A.xhtml)中找到类似域配置的设置说明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Remote Server
    Administration Tools</samp>
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">远程服务器管理工具</samp>
- en: We can interact with the Active Directory server through PowerShell’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp> module, which ships
    with the optional Remote Server Administration Tools (RSAT) Windows capability.
    By default, only domain controllers come with RSAT installed, as the commands
    are designed for managing the directory (which not every client system needs to
    do).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过PowerShell的<samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp>模块与Active
    Directory服务器进行交互，该模块随可选的远程服务器管理工具(RSAT)Windows功能一起提供。默认情况下，只有域控制器安装了RSAT，因为这些命令是为管理目录设计的（并非每个客户端系统都需要执行这些操作）。
- en: Therefore, you might need to install RSAT before running the example scripts
    in this chapter. If you’re running a version of Windows older than Windows 10,
    version 1809, you must download RSAT from the Microsoft website. If you’re using
    a newer version of Windows, you can install RSAT by running the commands in [Listing
    11-1](chapter11.xhtml#Lis11-1) from an administrator PowerShell console.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能需要在运行本章示例脚本之前安装RSAT。如果你使用的是Windows 10版本1809之前的旧版Windows，你必须从微软网站下载RSAT。如果你使用的是更新版本的Windows，你可以通过在管理员PowerShell控制台中运行[清单
    11-1](chapter11.xhtml#Lis11-1)中的命令来安装RSAT。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: Installing the Remote Server Administration Tools'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-1：安装远程服务器管理工具
- en: Note that the examples in this section won’t work unless you run the commands
    on a machine joined to a Windows enterprise network, such as the one described
    in [Appendix A](appendix-A.xhtml).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除非在加入Windows企业网络的计算机上运行这些命令，否则本节中的示例将无法正常工作，具体网络配置请参见[附录A](appendix-A.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Basic Forest and
    Domain Information</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基本的森林和域信息</samp>
- en: Let’s start by gathering some basic information about the forest and domain
    we’re connected to. You can follow along by executing the commands in [Listing
    11-2](chapter11.xhtml#Lis11-2) on a computer in the root *mineral.local* domain
    of the example forest.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从收集一些关于我们连接的森林和域的基本信息开始。你可以通过在示例森林的根域*mineral.local*的计算机上执行[清单 11-2](chapter11.xhtml#Lis11-2)中的命令来跟随操作。
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-2: Listing some basic information about the forest and domain'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-2：列出森林和域的基本信息
- en: We first request information about the current forest using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADForest</samp>
    command ❶. The returned object has many properties, but here we focus on two of
    them. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Domains</samp> property
    returns a list of the Domain Name System (DNS) names for the domains in the forest
    ❷. In this example, it matches the forest in [Figure 11-1](chapter11.xhtml#fig11-1).
    We also inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalCatalogs</samp>
    property, which lists all systems that maintain a copy of the shared global catalog
    ❸. We can use these to inspect the forest-level configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADForest</samp>命令❶请求当前森林的信息。返回的对象有许多属性，但这里我们重点关注其中的两个。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Domains</samp>属性返回该森林中域的域名系统(DNS)名称列表❷。在此示例中，它与[图
    11-1](chapter11.xhtml#fig11-1)中的森林相匹配。我们还检查<samp class="SANS_TheSansMonoCd_W5Regular_11">GlobalCatalogs</samp>属性，该属性列出了所有维护共享全局目录副本的系统❸。我们可以使用这些信息来检查森林级别的配置。
- en: We then run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADDomain</samp>
    command, which returns information about the domain to which the current system
    is connected ❹. Here, we select four properties. The first one, <samp class="SANS_TheSansMonoCd_W5Regular_11">PDCEmulator</samp>,
    is the DNS name of the *primary domain controller (PDC) emulator*. The PDC, which
    used to be the main domain controller in the local domain, once acted as the definitive
    user database. (A backup domain controller served as a secondary database, in
    case the PDC went down.) With the introduction of Active Directory, it became
    possible to more evenly distribute the authentication workload without the PDC.
    However, Windows still gives the PDC emulator preferential treatment; for example,
    when you change your password, the operating system will always first try to change
    it on the PDC. The PDC also runs the legacy Netlogon service, for backward compatibility
    with older versions of Windows.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADDomain</samp> 命令，它返回有关当前系统连接的域的信息
    ❹。在这里，我们选择了四个属性。第一个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">PDCEmulator</samp>，它是
    *主域控制器 (PDC) 模拟器* 的 DNS 名称。PDC 曾是本地域中的主要域控制器，曾作为权威的用户数据库。（备份域控制器作为次级数据库，以防 PDC
    故障。）随着 Active Directory 的引入，能够在没有 PDC 的情况下更加均匀地分配身份验证工作负载。然而，Windows 仍然对 PDC 模拟器给予优先处理；例如，当你更改密码时，操作系统总是首先尝试在
    PDC 上更改密码。PDC 还运行遗留的 Netlogon 服务，以兼容旧版本的 Windows。
- en: The next property is the <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainSID</samp>.
    This SID serves as the basis for all other user and group SIDs in the domain.
    It’s equivalent to the machine SID we saw in [Chapter 10](chapter10.xhtml), but
    it applies to the entire network. The final two properties are the <samp class="SANS_TheSansMonoCd_W5Regular_11">DNSRoot</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NetBIOSName</samp>. These are
    the domain’s root DNS name and simple domain name, which Windows keeps around
    for legacy support reasons.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性是 <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainSID</samp>。这个 SID
    作为该域中所有其他用户和组 SID 的基础。它相当于我们在 [第 10 章](chapter10.xhtml) 中看到的计算机 SID，但它适用于整个网络。最后两个属性是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DNSRoot</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NetBIOSName</samp>。这两个是域的根
    DNS 名称和简单域名，Windows 保留它们是为了支持遗留兼容性。
- en: A good example of this legacy support involves the names of users in a domain.
    Officially, you should refer to users with a fully qualified name, the *user principal
    name (UPN)*, which takes the form *alice@mineral.local*. However, in the user
    interface you use to log in to your computer, you typically won’t enter the UPN
    as your username; instead, you’d enter something like *MINERAL\alice*, which we
    refer to as a *down-level logon name*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子，说明了如何支持这一遗留情况，涉及到域中用户的命名。官方上，你应该使用完全合格的名称，即 *用户主体名称 (UPN)*，其形式为 *alice@mineral.local*。然而，在你用来登录计算机的用户界面中，你通常不会输入
    UPN 作为用户名；而是输入类似 *MINERAL\alice* 的名称，这被我们称为 *下级登录名*。
- en: 'Next, we list the domain controllers on the domain the system is connected
    to using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADDomainController</samp>
    command ❺. We’re inspecting a simple domain, so [Listing 11-2](chapter11.xhtml#Lis11-2)
    contains only a single entry, <samp class="SANS_TheSansMonoCd_W5Regular_11">PRIMARYDC</samp>.
    As we saw earlier, though, the forest contains multiple domains. We can enumerate
    the configured trust relationships using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADTrust</samp>
    command ❻. The output reveals all of the trusts to be bidirectional. The third
    column identifies the type of each domain: <samp class="SANS_TheSansMonoCd_W5Regular_11">Uplevel</samp>
    indicates that the domain is also based on Active Directory, while a value of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Downlevel</samp> would represent
    a pre–Windows 2000 domain.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADDomainController</samp>
    命令 ❺ 列出系统连接的域中的域控制器。由于我们正在检查一个简单的域，因此 [列表 11-2](chapter11.xhtml#Lis11-2) 只包含一个条目，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PRIMARYDC</samp>。不过，正如我们之前看到的，森林包含多个域。我们可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADTrust</samp> 命令 ❻ 枚举配置的信任关系。输出显示所有的信任关系都是双向的。第三列标识了每个域的类型：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Uplevel</samp> 表示该域也基于 Active Directory，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Downlevel</samp> 则表示一个 Windows 2000
    之前的域。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Users</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用户</samp>
- en: Let’s now list the user account information stored on the Active Directory server.
    We can do this with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    command, as shown in [Listing 11-3](chapter11.xhtml#Lis11-3).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们列出存储在 Active Directory 服务器上的用户帐户信息。我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>
    命令，如 [Listing 11-3](chapter11.xhtml#Lis11-3) 所示。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-3: Displaying the Active Directory server’s users'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 11-3：显示 Active Directory 服务器的用户
- en: Using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> is like
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>, except
    that you need to specify a filter. In [Listing 11-3](chapter11.xhtml#Lis11-3)
    we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> to get all users,
    but on a real network you’ll find filtering important to reduce the output, as
    the Active Directory server could contain hundreds or thousands of users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp> 类似于使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>，只不过你需要指定一个过滤器。在 [Listing
    11-3](chapter11.xhtml#Lis11-3) 中，我们指定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    来获取所有用户，但在实际的网络中，你会发现过滤器非常重要，以减少输出，因为 Active Directory 服务器可能包含成百上千的用户。
- en: The output shows each user’s plain username (in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamAccountName</samp>
    column), whether the user is enabled, and their SID. As with the local users,
    each SID has a common prefix that should match the domain SID from [Listing 11-2](chapter11.xhtml#Lis11-2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了每个用户的纯用户名（在 <samp class="SANS_TheSansMonoCd_W5Regular_11">SamAccountName</samp>
    列中）、用户是否启用以及其 SID。与本地用户一样，每个 SID 都有一个共同的前缀，应该与 [Listing 11-2](chapter11.xhtml#Lis11-2)
    中的域 SID 匹配。
- en: The user’s password is stored in a special write-only attribute in the Active
    Directory server. We can’t read this password from outside the domain controller
    except via backups of the directory or when the directory is replicated between
    domain controllers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的密码存储在 Active Directory 服务器中的一个特殊的只写属性中。除非通过目录的备份或在目录在域控制器之间复制时，否则我们无法从域控制器外部读取此密码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Groups</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">组</samp>
- en: To list the security groups in the Active Directory server, we can use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroup</samp> command ([Listing 11-4](chapter11.xhtml#Lis11-4)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出 Active Directory 服务器中的安全组，我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroup</samp>
    命令（见[Listing 11-4](chapter11.xhtml#Lis11-4)）。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-4: Displaying the Active Directory server’s groups'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 11-4：显示 Active Directory 服务器的组
- en: Notice that the output includes both *BUILTIN* groups, such as *Administrators*,
    and domain groups, such as *Enterprise Admins*. You can easily distinguish these
    group types based on the domain SID used as the prefix of a group’s SID. In this
    example, the domain SID prefix is <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-21-1195776225-522706947-2538775957</samp>.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出包括了 *BUILTIN* 组，例如 *Administrators*，以及域组，例如 *Enterprise Admins*。你可以通过组的
    SID 前缀所使用的域 SID 来轻松区分这些组类型。在此示例中，域 SID 前缀是 <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-21-1195776225-522706947-2538775957</samp>。
- en: The system uses the *BUILTIN* groups only when a user authenticates to the domain
    controller. For example, adding a user to the *BUILTIN\Administrators* group would
    grant that user administrator access to the database on the domain controller,
    but not on any other machine in the network. On the other hand, the domain groups
    get added to the user’s token when they authenticate, and they can be used for
    access checks on the local computer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 系统仅在用户进行域控制器身份验证时使用 *BUILTIN* 组。例如，将用户添加到 *BUILTIN\Administrators* 组会授予该用户对域控制器上数据库的管理员访问权限，但不会在网络中其他任何计算机上授予此权限。另一方面，域组会在用户进行身份验证时添加到用户的令牌中，并且可以用于本地计算机的访问检查。
- en: Domain groups can have three possible scopes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>
    group scope is visible to the entire forest. While any domain in the forest can
    use the group, it contains users or groups in the defining domain only. A <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group is equivalent to the
    group object in the SAM configuration we covered in the previous chapter. By contrast,
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp> group is visible
    only in the defining domain, but it can contain any user or group from any trusted
    domain. It’s equivalent to the alias object in the SAM database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 域组可以有三种可能的作用域。<samp class="SANS_TheSansMonoCd_W5Regular_11">全局</samp>组的作用域对整个林内可见。虽然林内的任何域都可以使用该组，但它只包含定义域中的用户或组。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">全局</samp>组相当于我们在上一章中介绍的SAM配置中的组对象。相比之下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">域本地</samp>组只在定义域内可见，但可以包含来自任何受信任域的任何用户或组。它相当于SAM数据库中的别名对象。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> group scope
    combines the global visibility and broad membership of the two other scopes: groups
    in this scope are visible to the entire forest and can contain any user or group.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">通用</samp>组作用域结合了另外两个作用域的全局可见性和广泛的成员资格：此作用域中的组对整个林可见，并且可以包含任何用户或组。
- en: To highlight the distinction between the <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group scopes,
    let’s consider the difference between two groups, *Enterprise Admins* and *Domain
    Admins*. *Enterprise Admins* includes all the users who can manage a forest. While
    there should be only one instance of this group, defined in the root domain, you
    might want to be able to add any user across the forest as a member. Therefore,
    as you can see in [Listing 11-4](chapter11.xhtml#Lis11-4), it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>
    group. All domains can use it, and it can contain anyone.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出<samp class="SANS_TheSansMonoCd_W5Regular_11">通用</samp>组和<samp class="SANS_TheSansMonoCd_W5Regular_11">全局</samp>组作用域之间的区别，我们来看看两个组的区别，*企业管理员*和*域管理员*。*企业管理员*包括所有可以管理林的用户。虽然这个组应该只有一个实例，并且定义在根域中，但你可能希望能够将林中任何用户添加为成员。因此，正如你在[示例11-4](chapter11.xhtml#Lis11-4)中看到的，它是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">通用</samp>组。所有域都可以使用它，并且它可以包含任何人。
- en: In contrast, *Domain Admins* contains users who are administrators of a single
    domain. Other domains might use the group as a resource if it is configured to
    grant them access, but it restricts its membership to the defining domain. Therefore,
    it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group. If you’re
    managing only a single domain, the differences between these scopes aren’t particularly
    relevant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，*域管理员*包含的是单一域的管理员用户。如果其他域需要使用该组作为资源，它们可以通过配置授予访问权限，但该组的成员限制在定义域内。因此，它是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">全局</samp>组。如果你只管理一个域，这些作用域之间的区别并不是特别重要。
- en: The SAM remote service would return <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp>
    groups when you enumerate alias objects and both <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> groups when you
    enumerate group objects. You might find it odd that the service returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp> groups as group objects;
    after all, the APIs used to manipulate group object members allow you to specify
    a member using the domain’s relative ID only, preventing you from using the SAM
    remote service to modify a <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>
    group if it has any members outside of the domain. In any case, you shouldn’t
    really use the SAM remote service to manage an Active Directory domain.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SAM远程服务在枚举别名对象时会返回<samp class="SANS_TheSansMonoCd_W5Regular_11">域本地</samp>组，在枚举组对象时则返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">通用</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">全局</samp>组。你可能会觉得奇怪，为什么服务会将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">通用</samp>组作为组对象返回；毕竟，操作组对象成员的API允许你仅使用域的相对ID来指定成员，这就阻止了你使用SAM远程服务来修改如果组中有任何来自域外的成员的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">通用</samp>组。无论如何，你不应该真正使用SAM远程服务来管理Active
    Directory域。
- en: You can list the members of an Active Directory server group using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroupMember</samp> command, as shown
    in [Listing 11-5](chapter11.xhtml#Lis11-5).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroupMember</samp>命令列出Active
    Directory服务器组的成员，如[列表11-5](chapter11.xhtml#Lis11-5)所示。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-5: Displaying <samp class="SANS_Futura_Std_Book_11">Administrators</samp>
    group members once they’ve joined the domain'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-5：在计算机加入域后显示<samp class="SANS_Futura_Std_Book_11">Administrators</samp>组成员
- en: Here, we enumerate the members of the *BUILTIN\Administrators* group on the
    domain controller. Because this is a *BUILTIN* group, users receive membership
    to the group only once they’ve authenticated to the domain controller.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出了在域控制器上*BUILTIN\Administrators*组的成员。因为这是一个*BUILTIN*组，用户只有在通过域控制器认证后，才能成为该组的成员。
- en: However, when you join a computer to a domain, you can modify the local groups
    on that computer to include domain groups. For example, when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroupMember</samp>
    to list the members of the local *BUILTIN\Administrators* group, we see that the
    *Domain Admins* group from the domain has been added as a member. This change
    allows all administrators in the domain to be local administrators on any computer
    in the domain.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你将计算机加入域时，你可以修改该计算机上的本地组，以包含域组。例如，当我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroupMember</samp>列出本地*BUILTIN\Administrators*组的成员时，我们看到*Domain
    Admins*组已被添加为成员。此更改允许域中的所有管理员成为域内任何计算机的本地管理员。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Computers</samp>
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算机</samp>
- en: When you join a computer to a domain, an account is created in the domain. These
    special user accounts grant the computer access to certain domain services before
    any user has authenticated to the system. The computer account is especially important
    for configuring the group policy, as well as for authenticating users to the system,
    as we’ll see in [Chapter 14](chapter14.xhtml).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将计算机加入域时，域中会创建一个账户。这些特殊的用户账户在任何用户认证系统之前，授予计算机访问某些域服务的权限。计算机账户对于配置组策略以及用户认证系统特别重要，正如我们在[第14章](chapter14.xhtml)中将看到的那样。
- en: You can list the computer accounts on the Active Directory server using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp> command, shown
    in [Listing 11-6](chapter11.xhtml#Lis11-6).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>命令列出Active
    Directory服务器上的计算机账户，如[列表11-6](chapter11.xhtml#Lis11-6)所示。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-6: Displaying the computer account SIDs'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-6：显示计算机账户的SID
- en: As this output shows, the computer account names usually have a trailing dollar
    sign character (<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>), which
    makes it easy to differentiate computer accounts from user accounts. We can also
    see once again that the SIDs use the domain SID as a prefix. (The computers themselves
    continue to store their own separate machine SIDs in the local SAM database.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如该输出所示，计算机账户的名称通常以一个美元符号（<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>）结尾，这使得计算机账户与用户账户之间容易区分。我们还可以再次看到，SID使用域SID作为前缀。（计算机本身会继续在本地SAM数据库中存储它们各自的机器SID。）
- en: A computer account needs a password to authenticate to the domain, and the domain-joined
    computer and domain controller automatically manage this password. By default,
    the computer generates a new complex password every 30 days and changes it on
    the domain controller. As the computer must change the password without user interaction,
    it stores the password in an LSA secret object called <samp class="SANS_TheSansMonoCd_W5Regular_11">$MACHINE.ACC</samp>.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机账户需要密码来进行域认证，域加入的计算机和域控制器会自动管理此密码。默认情况下，计算机会每30天生成一个新的复杂密码，并在域控制器上更改密码。由于计算机必须在没有用户交互的情况下更改密码，它将密码存储在一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$MACHINE.ACC</samp>的LSA秘密对象中。
- en: '[Listing 11-7](chapter11.xhtml#Lis11-7) shows how to query a computer’s LSA
    secret using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -LsaPrivateData</samp>
    command. You’ll need to run this command as an administrator. It’s similar to
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSecret</samp> command
    we saw in the previous chapter, except we don’t need to manually open the policy
    and secret objects.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-7](chapter11.xhtml#Lis11-7)展示了如何使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get
    -LsaPrivateData</samp>命令查询计算机的LSA密钥。你需要以管理员身份运行此命令。这与我们在上一章中看到的<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSecret</samp>命令类似，不同之处在于我们不需要手动打开策略和密钥对象。'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-7: Querying the $MACHINE.ACC LSA secret'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-7：查询$MACHINE.ACC LSA密钥
- en: The LSA obfuscates the contents of the secret object, so just reading the value
    isn’t enough to extract the password used for the computer account.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: LSA会混淆密钥对象的内容，因此仅仅读取其值不足以提取计算机帐户使用的密码。
- en: We’ve performed a high-level exploration of an Active Directory server configuration.
    Let’s now look at how the directory is configured at a low level, so we can understand
    how it is secured.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对Active Directory服务器配置进行了高级探索。现在，让我们看看目录是如何在低级别上配置的，以便我们理解它是如何被保护的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Objects and Distinguished Names</samp>
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象和唯一名称</samp>
- en: Although we can use the commands in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp>
    module to access the user configuration, these commands hide the real structure
    of the Active Directory server, which consists of a hierarchical tree of entries,
    as shown in [Figure 11-2](chapter11.xhtml#fig11-2).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp>模块中的命令来访问用户配置，但这些命令隐藏了Active
    Directory服务器的真实结构，服务器实际上是由一个条目的层次树组成，如[图11-2](chapter11.xhtml#fig11-2)所示。
- en: '![](../images/Figure11-2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: The structure
    of an Active Directory server</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-2：Active Directory服务器的结构</samp>
- en: 'There are a few different types of entries, but the only ones we care about
    are *objects*, which store the user configuration. To refer to an object in the
    tree, we use its *distinguished name*, which must be unique across the directory.
    The distinguished name is a sequence of one or more *relative distinguished names*
    separated by commas. In the Active Directory server, you’re most likely to encounter
    the following relative distinguished name types:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中有几种不同类型的条目，但我们关心的只有*对象*，它们存储用户配置。要引用树中的一个对象，我们使用它的*唯一名称*（distinguished name），该名称在整个目录中必须是唯一的。唯一名称是由一个或多个*相对唯一名称*（relative
    distinguished names）组成的序列，名称之间用逗号分隔。在Active Directory服务器中，你最可能遇到以下几种相对唯一名称类型：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">C   </samp>The country name
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">C   </samp>国家名称
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CN  </samp>The common name
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CN  </samp>常见名称
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DC  </samp>The domain component
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DC  </samp>域组件
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O   </samp>The organization name
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">O   </samp>组织名称
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">OU  </samp>The organizational unit
    name
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">OU  </samp>组织单位名称
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ST  </samp>The state or province
    name
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ST  </samp>州或省的名称
- en: For example, at the root of the directory is the domain object ❶, which has
    the domain name <samp class="SANS_TheSansMonoCd_W5Regular_11">DC=mineral,DC=local</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">DC</samp> relative distinguished
    name represents a domain component that is part of a DNS name. Taken together,
    this distinguished name represents the *mineral.local* DNS name of the domain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在目录的根部是域对象❶，它具有域名<samp class="SANS_TheSansMonoCd_W5Regular_11">DC=mineral,DC=local</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DC</samp>相对唯一名称表示域组件，它是DNS名称的一部分。总的来说，这个唯一名称表示*mineral.local*域的DNS名称。
- en: Underneath the root object is a tree of objects that describe the configuration
    of the domain. I’ve shown only three of them in [Figure 11-2](chapter11.xhtml#fig11-2).
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CN</samp> refers to a common name,
    a simple label for the object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Users</samp>
    object ❷ contains the user and group objects for the domain. The other two objects,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Builtin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Computers</samp>,
    contain group accounts for the *BUILTIN* domain on the domain controller and the
    list of computer accounts, respectively.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根对象下是一个描述域配置的对象树。我在[图 11-2](chapter11.xhtml#fig11-2)中仅展示了其中的三个。<samp class="SANS_TheSansMonoCd_W5Regular_11">CN</samp>表示通用名称，这是对象的简单标签。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CN=Users</samp>对象❷包含域中的用户和组对象。其他两个对象，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CN=Builtin</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Computers</samp>，分别包含域控制器上*BUILTIN*域的组账户和计算机账户列表。
- en: To refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp> object,
    you would use its full distinguished name, <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=Users,DC=mineral,DC=local</samp>.
    Each user object could contain further objects, but it’s more common for them
    to contain only a list of attribute values that represent the user’s configuration
    ❸. For example, a user object might contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">userPrincipalName</samp>
    attribute, representing the UPN of the user in the Active Directory server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用<samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp>对象，你需要使用其完整的唯一名称，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CN=Users,DC=mineral,DC=local</samp>。每个用户对象可能包含进一步的对象，但通常它们只包含一系列表示用户配置的属性值❸。例如，用户对象可能包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">userPrincipalName</samp>属性，表示用户在Active
    Directory服务器中的UPN。
- en: Each object can also contain an <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>
    attribute with a GUID that uniquely identifies the object. Although unique, the
    distinguished name cannot consistently identify an object, as it would change
    if the object were moved or renamed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>
    attribute stays the same even if the distinguished name changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象还可以包含一个<samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>属性，带有一个唯一标识对象的GUID。尽管是唯一的，唯一名称无法始终如一地标识一个对象，因为如果对象被移动或重命名，唯一名称也会发生变化。而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>属性即使唯一名称发生变化，仍然保持不变。
- en: Two separate root objects store administrative information for the domain root.
    These are the configuration object ❹ and the schema object ❺. The information
    stored in the configuration object matters to Active Directory security, and the
    schema object defines the directory’s structure. We’ll discuss both objects in
    more depth in later sections.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个独立的根对象存储域根的管理信息。它们是配置对象❹和架构对象❺。存储在配置对象中的信息对于Active Directory安全性非常重要，而架构对象定义了目录的结构。我们将在后面的章节中更深入地讨论这两个对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enumerating Directory
    Objects</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">列举目录对象</samp>
- en: Default installations of the Active Directory server use well-known distinguished
    names, configurations, and schema objects. However, an administrator can change
    these names or add new directories to the database. For that reason, the Active
    Directory server exposes a special directory entry called the *Root Directory
    System Agent-Specific Entry (RootDSE)* that contains high-level configuration
    for the directory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Active Directory服务器的默认安装使用知名的唯一名称、配置和架构对象。然而，管理员可以更改这些名称或向数据库中添加新的目录。因此，Active
    Directory服务器提供了一个特殊的目录条目，称为*根目录系统代理专用条目（RootDSE）*，它包含了目录的高级配置。
- en: '[Listing 11-8](chapter11.xhtml#Lis11-8) shows how to access the RootDSE entry
    for the current domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADRootDSE</samp>
    command.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-8](chapter11.xhtml#Lis11-8)展示了如何使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADRootDSE</samp>命令访问当前域的RootDSE条目。'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 11-8: Inspecting the RootDSE entry for the current domain'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-8：检查当前域的RootDSE条目
- en: As properties, we select the distinguished names for the *naming contexts*,
    which represent the top-level objects in the directory. Using these naming contexts,
    we can query objects on the Active Directory server with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>
    command ([Listing 11-9](chapter11.xhtml#Lis11-9)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为属性，我们选择区分名称用于*naming contexts*，它们表示目录中的顶级对象。使用这些命名上下文，我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>命令在Active
    Directory服务器上查询对象（[列表11-9](chapter11.xhtml#Lis11-9)）。
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-9: Querying for the Active Directory server’s objects'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-9：查询Active Directory服务器的对象
- en: First we get the root domain naming context from the RootDSE ❶. This naming
    context represents the distinguished name for the directory’s root domain object,
    which we can use to query for objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从RootDSE中获取根域命名上下文❶。此命名上下文表示目录根域对象的区分名称，我们可以用它来查询对象。
- en: We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>
    command to query the child objects of the root ❷. The command takes various options
    to limit the scope of the child objects to return. The first is the <samp class="SANS_TheSansMonoCd_W5Regular_11">SearchBase</samp>
    parameter, which returns only the children of a certain object (in this case,
    only the default naming context). We’ve supplied the default value here, which
    is unnecessary, but the parameter is useful in other cases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>命令查询根的子对象❷。该命令接受各种选项来限制返回的子对象范围。第一个选项是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SearchBase</samp>参数，它仅返回某个对象的子对象（在这种情况下，仅返回默认命名上下文）。我们在这里提供了默认值，尽管这不是必需的，但在其他情况下该参数非常有用。
- en: The second option is the <samp class="SANS_TheSansMonoCd_W5Regular_11">SearchScope</samp>
    parameter, which determines how recursive the search should be. We specify <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OneLevel</samp> to search only the immediate
    children of the search base. Other values include <samp class="SANS_TheSansMonoCd_W5Regular_11">Base</samp>,
    which returns only the search base object, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtree</samp>,
    which recursively searches all child objects. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp>
    parameter limits the values returned. In this case, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    to return everything.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是<samp class="SANS_TheSansMonoCd_W5Regular_11">SearchScope</samp>参数，它决定搜索的递归程度。我们指定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">OneLevel</samp>以仅搜索搜索基准的直接子对象。其他值包括<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Base</samp>，它仅返回搜索基准对象，以及<samp class="SANS_TheSansMonoCd_W5Regular_11">Subtree</samp>，它递归搜索所有子对象。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp>参数限制返回的值。在这种情况下，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>来返回所有内容。
- en: The output includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistinguishedName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp> attributes
    ❸. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp> attribute
    represents the name of the schema type, which we’ll come back to in “The Schema”
    on page 353. We can select a specific distinguished name by specifying it as the
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp> parameter
    ❹. The object returned contains a list of the directory object’s attributes as
    PowerShell properties. For example, we can see the <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>
    attribute, which represents the object’s unique identifier.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括<samp class="SANS_TheSansMonoCd_W5Regular_11">DistinguishedName</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp>属性❸。<samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp>属性表示模式类型的名称，我们将在第353页的“模式”中进一步讨论。我们可以通过指定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Identity</samp>参数的值来选择一个特定的区分名称❹。返回的对象包含目录对象的属性列表，作为PowerShell属性。例如，我们可以看到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>属性，它表示对象的唯一标识符。
- en: In this case, the command returns only four values. For performance reasons,
    it queries for a small set of attributes, as some of the attribute values can
    be quite large. To query for more attributes, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Properties</samp>
    parameter, passing it either a list of attribute names or <samp class="SANS_TheSansMonoCd_W7Bold_B_11">*</samp>
    to return all attributes ❺.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，命令只返回四个值。出于性能考虑，它查询的是一小部分属性，因为某些属性值可能非常大。要查询更多属性，可以指定<samp class="SANS_TheSansMonoCd_W5Regular_11">Properties</samp>参数，并传递一个属性名称的列表，或者使用<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">*</samp>来返回所有属性❺。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Objects
    in Other Domains</samp>
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">访问其他域中的对象</samp>
- en: What if you’re on a computer in one domain of the forest and want to access
    the Active Directory server for another domain? You might attempt to use the distinguished
    name of the object you’re interested in, as in [Listing 11-10](chapter11.xhtml#Lis11-10).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在林中的一个域的计算机上，并且想要访问另一个域的活动目录服务器怎么办？你可以尝试使用你感兴趣的对象的区分名称，如[示例 11-10](chapter11.xhtml#Lis11-10)所示。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-10: Trying to access another domain’s Active Directory'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-10：尝试访问另一个域的活动目录
- en: As you can see, trying to access an object in another domain’s Active Directory
    server fails; the command tries to search for a child object with the specified
    distinguished name and can’t find it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尝试访问另一个域的活动目录服务器时会失败；该命令尝试搜索具有指定区分名称的子对象，但无法找到它。
- en: To view the Active Directory server from another domain, you have a couple of
    options, shown in [Listing 11-11](chapter11.xhtml#Lis11-11).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看另一个域的活动目录服务器，你有几种选择，详见[示例 11-11](chapter11.xhtml#Lis11-11)。
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 11-11: Accessing the Active Directory server’s objects in another domain'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-11：访问另一个域中活动目录服务器的对象
- en: The first option is to explicitly specify the target domain using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> parameter
    ❶. This parameter accepts the domain’s simple name or DNS name, as well as the
    hostname of a domain controller within the domain. In this case, we specify <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SALES</samp>, and because this domain
    is part of our forest, the query returns a suitable domain controller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>命令显式指定目标域，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>参数❶。该参数接受域的简单名称或DNS名称，以及域内域控制器的主机名。在此示例中，我们指定了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SALES</samp>，由于该域是我们林的一部分，查询将返回一个合适的域控制器。
- en: The second option is to query the global catalog. As [Listing 11-2](chapter11.xhtml#Lis11-2)
    showed, servers in the domain manage this catalog using data copied from other
    Active Directory servers. Select the global catalog by specifying the well-known
    port <samp class="SANS_TheSansMonoCd_W5Regular_11">3268</samp> as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    parameter ❷. In this example, we specify no domain or server name, which selects
    the global catalog in the current domain by default. If you wanted to, however,
    you could query the global catalog in another domain by prefixing the port with
    its name.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是查询全球目录。如[示例 11-2](chapter11.xhtml#Lis11-2)所示，域中的服务器通过复制自其他活动目录服务器的数据来管理此目录。通过指定著名端口<samp
    class="SANS_TheSansMonoCd_W5Regular_11">3268</samp>作为<samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>参数❷，可以选择全球目录。在这个例子中，我们没有指定域或服务器名称，这样默认会选择当前域中的全球目录。然而，如果你愿意，你也可以通过在端口前加上域名来查询另一个域的全球目录。
- en: One thing to keep in mind is that the global catalog contains merely a subset
    of the full data in the Active Directory server. If we count the number of properties
    returned, we see that the object contains 28 properties ❸, whereas the global
    catalog version of it returns only 25\. For certain object classes, the difference
    in property counts might be even more pronounced.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，全球目录仅包含活动目录服务器中完整数据的一个子集。如果我们计算返回的属性数量，可以看到该对象包含28个属性❸，而其全球目录版本只返回25个属性。对于某些对象类，属性数量的差异可能更加明显。
- en: 'You might wonder: Why wouldn’t you just query the domain directly for Active
    Directory information? Basically, it’s a question of locality. The domain on which
    you’re running the command might live on the other side of the world from the
    target domain, joined by a high-latency satellite link. Querying the target directly
    might be slow, expensive, or both. By contrast, the local global catalog might
    live on a domain controller in the next office, which offers convenience, even
    if it won’t provide the same level of detail.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：为什么不直接查询域以获取 Active Directory 信息呢？基本上，这是一个局部性的问题。你运行命令的域可能位于目标域的另一端，通过高延迟的卫星链路连接。直接查询目标域可能很慢、很昂贵，或者两者兼有。相反，本地全局目录可能位于下一个办公室的域控制器上，这虽然提供的细节级别较低，但提供了便利。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Schema</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">模式</samp>
- en: The Active Directory server’s schema describes the classes of object that exist,
    the attributes those classes might contain, and the relationships between classes.
    Each object in the directory is assigned to one or more classes; for example,
    a group is of the class <samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp>.
    You can find an object’s class in its <samp class="SANS_TheSansMonoCd_W5Regular_11">objectClass</samp>
    attribute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Active Directory 服务器的模式描述了存在的对象类、这些类可能包含的属性以及类之间的关系。目录中的每个对象都被分配到一个或多个类中；例如，一个组属于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp> 类。你可以在对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">objectClass</samp>
    属性中找到对象的类。
- en: Each object class has a corresponding schema type. The schema can organize these
    types in a hierarchy, as shown in [Figure 11-3](chapter11.xhtml#fig11-3).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象类都有一个对应的模式类型。模式可以按层次结构组织这些类型，如[图 11-3](chapter11.xhtml#fig11-3)所示。
- en: '![](../images/Figure11-3.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A schema hierarchy
    for the group, user, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">computer
    classes</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-3：用于组、用户和</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">计算机类的模式层次结构</samp>
- en: All schema class types derive from a base type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>
    class ❶, and each class object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">subClassOf</samp>
    attribute specifies the classes from which it derives. For example, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">group</samp> type ❷ specifies <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>
    as its only <samp class="SANS_TheSansMonoCd_W5Regular_11">subClassOf</samp> value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的模式类类型都派生自一个基础类型，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>
    类❶，每个类对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">subClassOf</samp> 属性指定了它派生的类。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">group</samp> 类型❷指定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>
    作为唯一的 <samp class="SANS_TheSansMonoCd_W5Regular_11">subClassOf</samp> 值。
- en: Each class type can also include a list of the attributes that an instance of
    the class can contain ❸. This list is split into <samp class="SANS_TheSansMonoCd_W5Regular_11">mustContain</samp>,
    for required attributes, and <samp class="SANS_TheSansMonoCd_W5Regular_11">mayContain</samp>,
    for optional ones. In [Figure 11-3](chapter11.xhtml#fig11-3), for example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mustContain</samp> attribute has
    the required <samp class="SANS_TheSansMonoCd_W5Regular_11">groupType</samp> attribute,
    used to indicate whether the group is <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp>.
    However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> attribute,
    which contains the list of members of the group, is optional, as a group could
    have no members.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类类型还可以包括一个实例可能包含的属性列表❸。这个列表分为 <samp class="SANS_TheSansMonoCd_W5Regular_11">mustContain</samp>（必需的属性）和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mayContain</samp>（可选的属性）。例如，在[图
    11-3](chapter11.xhtml#fig11-3)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">mustContain</samp>
    属性包含了必需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">groupType</samp> 属性，用于指示该组是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>（全局的）、<samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp>（全局的）还是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp>（域本地的）。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">member</samp> 属性是可选的，因为一个组可能没有成员。
- en: A second set of attribute lists, <samp class="SANS_TheSansMonoCd_W5Regular_11">systemMustContain</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">systemMayContain</samp>, hold
    required and optional attributes that only the Active Directory server can modify;
    a normal user can’t change these.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组属性列表，<samp class="SANS_TheSansMonoCd_W5Regular_11">systemMustContain</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">systemMayContain</samp>，保存只有Active Directory服务器才能修改的必需和可选属性；普通用户无法更改这些属性。
- en: Not all class schema types are as simple as <samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp>.
    For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> class
    ❹ is a subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">organizationalPerson</samp>,
    which itself is a subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">person</samp>,
    which in turn is a subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>.
    Each of these schema class types can contribute required and optional attributes
    to the final subclass object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的类模式类型都像<samp class="SANS_TheSansMonoCd_W5Regular_11">group</samp>那样简单。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">user</samp>类 ❹是<samp class="SANS_TheSansMonoCd_W5Regular_11">organizationalPerson</samp>的子类，而<sup
    class="SANS_TheSansMonoCd_W5Regular_11">organizationalPerson</samp>又是<samp class="SANS_TheSansMonoCd_W5Regular_11">person</samp>的子类，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">person</samp>又是<samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>的子类。每种模式类类型都可以为最终的子类对象提供必需和可选的属性。
- en: A class can also contain lists of auxiliary classes, defined with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">auxiliaryClass</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">systemAuxiliaryClass</samp>
    attributes ❺. We can use these classes to add additional attributes to a schema
    class without making them part of the inheritance hierarchy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类也可以包含辅助类的列表，这些辅助类通过<samp class="SANS_TheSansMonoCd_W5Regular_11">auxiliaryClass</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">systemAuxiliaryClass</samp>属性定义 ❺。我们可以使用这些类来为模式类添加额外的属性，而不将它们作为继承层次的一部分。
- en: 'Each class has an <samp class="SANS_TheSansMonoCd_W5Regular_11">objectClassCategory</samp>
    attribute to define how the class can be used. It can be one of the following
    values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都有一个<samp class="SANS_TheSansMonoCd_W5Regular_11">objectClassCategory</samp>属性，用于定义该类的使用方式。它可以是以下值之一：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Structural  </samp>The class can
    be used as an object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">结构类</samp> 该类可以用作对象。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Abstract  </samp>The class can
    be used for inheritance only.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">抽象类</samp> 该类只能用于继承。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Auxiliary  </samp>The class can
    be used as an auxiliary only.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">辅助类</samp> 该类只能用作辅助类。
- en: An additional type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Class88</samp>,
    represents classes that were defined in the oldest LDAP specifications. Only certain
    system classes use this type, and new schema classes shouldn’t use it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">Class88</samp>，表示在最早的LDAP规范中定义的类。只有某些系统类使用此类型，新的模式类不应使用它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting the Schema</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查模式</samp>
- en: We can inspect the schema using the same tools we would use to inspect user
    or group objects. An administrator can also modify the schema to add new types
    and attributes. For example, the Exchange mail server might modify the Active
    Directory server on which it’s installed to add additional email address attributes
    for user objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与检查用户或组对象相同的工具来检查模式。管理员还可以修改模式，以添加新的类型和属性。例如，Exchange邮件服务器可能会修改它安装的Active
    Directory服务器，以为用户对象添加额外的电子邮件地址属性。
- en: As the schema is part of the directory, we can inspect it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>
    command, as shown in [Listing 11-12](chapter11.xhtml#Lis11-12).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模式是目录的一部分，我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>命令来检查它，如[Listing
    11-12](chapter11.xhtml#Lis11-12)所示。
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-12: Enumerating schema objects'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-12: 枚举模式对象'
- en: We start by querying for all objects under the schema’s naming context and displaying
    them to the shell ❶. The output shows the name of each schema object and its object
    class ❷. We can see two classes, <samp class="SANS_TheSansMonoCd_W5Regular_11">classSchema</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">attributeSchema</samp>, which
    represent the schema types for object classes and attributes, respectively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查询架构命名上下文下的所有对象，并将其显示到 shell 中 ❶。输出结果显示每个架构对象的名称及其对象类 ❷。我们可以看到两个类，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">classSchema</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">attributeSchema</samp>，分别代表对象类和属性的架构类型。
- en: Next, we query for the schema objects and attributes again, but this time we
    use a filter to select only the objects whose <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp>
    attribute is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">classSchema</samp>
    ❸. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp> property takes
    a PowerShell-style expression that can filter the returned objects based on the
    object’s attributes. The server evaluates this filter to improve performance,
    as it won’t return objects that don’t match the filter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次查询架构对象和属性，但这次我们使用过滤器只选择那些其 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp>
    属性等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">classSchema</samp> 的对象 ❸。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp> 属性接受 PowerShell 风格的表达式，可以根据对象的属性过滤返回的对象。服务器会评估这个过滤器以提高性能，因为它不会返回与过滤器不匹配的对象。
- en: Note that the filter string isn’t a full PowerShell script, even though it uses
    a similar syntax, so you can’t perform complex scripting operations in the filter.
    The commands in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp>
    module also support the <samp class="SANS_TheSansMonoCd_W5Regular_11">LDAPFilter</samp>
    parameter, which uses the LDAP specification’s somewhat less intuitive filtering
    syntax. (Technically, even if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp>
    parameter, PowerShell will convert it to an LDAP filter before sending the query
    to the LDAP server, as Active Directory doesn’t yet execute PowerShell code directly.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，过滤器字符串并不是一个完整的 PowerShell 脚本，尽管它使用了类似的语法，因此你不能在过滤器中执行复杂的脚本操作。<samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectory</samp>
    模块中的命令也支持 <samp class="SANS_TheSansMonoCd_W5Regular_11">LDAPFilter</samp> 参数，该参数使用
    LDAP 规范的过滤语法（这种语法相对不那么直观）。（从技术上讲，即使你使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Filter</samp>
    参数，PowerShell 也会在发送查询到 LDAP 服务器之前将其转换为 LDAP 过滤器，因为 Active Directory 尚未直接执行 PowerShell
    代码。）
- en: The returned class objects appear in the console, where I’ve highlighted some
    of their important attributes. The first is the <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>
    attribute ❹, which represents the unique identifier for the schema type. Microsoft
    documents most of these schema identifiers, although an administrator can also
    add their own. The directory stores the <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>
    attribute as an array of bytes, so we convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">guid</samp>
    object to view the value more easily.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的类对象会出现在控制台中，我已经标出了其中一些重要属性。第一个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>
    属性 ❹，它表示架构类型的唯一标识符。微软文档记录了大部分这些架构标识符，尽管管理员也可以添加自己的标识符。目录将 <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>
    属性存储为字节数组，因此我们将其转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">guid</samp>
    对象，以便更容易查看其值。
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>
    won’t match the <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>
    attribute assigned to the object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>
    should be unique in the directory, but it won’t necessarily be unique globally.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp> should have
    the same value across all instances of the Active Directory server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp> 与分配给对象的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp> 属性不匹配。<samp class="SANS_TheSansMonoCd_W5Regular_11">objectGUID</samp>
    在目录中应该是唯一的，但它不一定在全球范围内唯一。<samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>
    应该在所有 Active Directory 服务器实例中具有相同的值。
- en: The next four attributes ❺ represent the lists of attributes the class can contain.
    In this case, only <samp class="SANS_TheSansMonoCd_W5Regular_11">mayContain</samp>,
    the list of optional class attributes, has any values. Each entry is identified
    by a name that is unique across the Active Directory server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个属性 ❺ 代表类可以包含的属性列表。在这种情况下，只有 <samp class="SANS_TheSansMonoCd_W5Regular_11">mayContain</samp>（即可选类属性列表）有值。每个条目都由一个在
    Active Directory 服务器中唯一的名称标识。
- en: These lists are not exhaustive, however; in addition to these, the class could
    also incorporate attributes from its configured auxiliary classes (although in
    this example, none are listed ❻). It will also incorporate any attributes inherited
    from the parent, which you can find in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SubClassOf</samp>
    attribute ❼. To get the full list of attributes a class could contain, you need
    to enumerate the entire inheritance chain and all auxiliary classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些列表并不详尽；除了这些，类还可能包含其配置的辅助类的属性（尽管在此示例中，未列出任何辅助类 ❻）。它还将包含从父类继承的任何属性，这些属性可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SubClassOf</samp> 属性中找到 ❼。要获取类可能包含的所有属性的完整列表，你需要枚举整个继承链和所有辅助类。
- en: Because it’s unique, we can return an attribute’s schema type by specifying
    a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">lDAPDisplayName</samp>
    attribute value. In this case, we use the first value in the attribute list, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uid</samp> ❽, and display a few of the
    schema type’s attributes, including a description of the attribute and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是唯一的，我们可以通过指定特定的 <samp class="SANS_TheSansMonoCd_W5Regular_11">lDAPDisplayName</samp>
    属性值来返回一个属性的架构类型。在这种情况下，我们使用属性列表中的第一个值，<samp class="SANS_TheSansMonoCd_W5Regular_11">uid</samp>
    ❽，并显示该架构类型的几个属性，包括属性的描述和 <samp class="SANS_TheSansMonoCd_W5Regular_11">schemaIDGUID</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the Security
    Attributes</samp>
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">访问安全属性</samp>
- en: As you just witnessed, manually inspecting the schema is a convoluted process.
    Still, we need to understand the schema to analyze the security of the directory.
    For that reason, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module comes with some commands that return the schema’s security-specific attributes.
    [Listing 11-13](chapter11.xhtml#Lis11-13) shows the simplest of these commands,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaClass</samp>.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才所见，手动检查架构是一个复杂的过程。不过，我们需要理解架构以分析目录的安全性。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    模块提供了一些返回架构安全特定属性的命令。[列表 11-13](chapter11.xhtml#Lis11-13) 显示了这些命令中最简单的一个，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaClass</samp>。
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-13: Enumerating all schema classes'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-13：枚举所有架构类
- en: When we specify no parameters, the command looks up all class type objects from
    the schema and returns them. The output shows each type’s LDAP name and schema
    identifier, as well as the total number of attributes the type can contain, including
    all required and system attributes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不指定任何参数时，命令会从架构中查找所有类类型对象并返回它们。输出显示每个类型的 LDAP 名称和架构标识符，以及该类型可以包含的所有属性的总数，包括所有必需的和系统属性。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Depending on the complexity of the schema and speed of the network, querying
    for all schema types can take a while. Once the command has downloaded the types,
    however, it will cache them, so you should receive a rapid response the next time
    you request them in the same PowerShell session.*'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*根据架构的复杂性和网络速度，查询所有架构类型可能需要一些时间。然而，一旦命令下载了这些类型，它会将其缓存，因此下次在同一 PowerShell 会话中请求时，应该会得到快速响应。*'
- en: '[Listing 11-14](chapter11.xhtml#Lis11-14) shows how to inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">account</samp>
    type using the module’s commands.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-14](chapter11.xhtml#Lis11-14) 显示了如何使用模块的命令检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">account</samp>
    类型。'
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 11-14: Inspecting a single class schema type'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-14：检查单个类架构类型
- en: You can specify the name of the class using either the LDAP name with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> parameter or the schema identifier
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SchemaId</samp> parameter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> 参数指定类的 LDAP
    名称，或者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SchemaId</samp> 参数指定架构标识符。
- en: The returned object contains an <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    property, which holds the list of all attributes for the class ❶. Rather than
    including separate attribute lists, the command assigns each attribute the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Required</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    properties to indicate the list from which they were sourced.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp> 属性，该属性保存类的所有属性列表
    ❶。命令并不单独列出每个属性的列表，而是为每个属性分配 <samp class="SANS_TheSansMonoCd_W5Regular_11">Required</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> 属性，指示它们来自哪个列表。
- en: To get more information about the attributes, you can pipe them into the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaAttribute</samp> command,
    which looks up the schema attribute type ❷. This command returns the LDAP name
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>) and schema identifier
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">SchemaId</samp>) properties, as
    well as a decoded attribute type (<samp class="SANS_TheSansMonoCd_W5Regular_11">AttributeType</samp>).
    We can see, for example, that the <samp class="SANS_TheSansMonoCd_W5Regular_11">uid</samp>
    type is a Unicode string, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">seeAlso</samp>
    type is a string that contains a distinguished name.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多关于属性的信息，可以将它们通过管道传递到 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaAttribute</samp>
    命令，该命令查找模式属性类型 ❷。该命令返回 LDAP 名称（<samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>）和模式标识符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SchemaId</samp>）属性，以及解码后的属性类型（<samp class="SANS_TheSansMonoCd_W5Regular_11">AttributeType</samp>）。例如，我们可以看到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">uid</samp> 类型是一个 Unicode 字符串，而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">seeAlso</samp> 类型是包含区分名称的字符串。
- en: Finally, you can directly look up the parent class by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parent</samp>
    parameter and specifying the existing class object ❸. You can also specify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp> parameter to recursively
    enumerate all parents. In this case, the only parent class is <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>,
    but querying a more complex class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>,
    would return several more schema classes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以直接通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Parent</samp> 参数并指定现有的类对象
    ❸ 来查找父类。你还可以指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Recurse</samp> 参数以递归列举所有父类。在这种情况下，唯一的父类是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>，但查询一个更复杂的类，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>，将返回多个其他模式类。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Security Descriptors</samp>
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安全描述符</samp>
- en: Almost any time we must secure a resource in Windows, we’ll turn to security
    descriptors and access checking, and with Active Directory it’s no different.
    LDAP supports authentication, and the Active Directory server uses it to create
    a token that represents the user. It then uses this token to determine what objects
    and attributes a given user can manipulate. Let’s begin by discussing how to query
    and store security descriptors on the Active Directory server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在任何时候，当我们必须在 Windows 中保护一个资源时，我们都会依赖安全描述符和访问检查，在 Active Directory 中也不例外。LDAP
    支持身份验证，Active Directory 服务器使用它来创建表示用户的令牌。然后，它使用这个令牌来确定给定用户可以操作的对象和属性。让我们从讨论如何查询和存储
    Active Directory 服务器上的安全描述符开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Querying Security
    Descriptors of Directory Objects</samp>
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查询目录对象的安全描述符</samp>
- en: Each directory object is assigned a security descriptor when it’s created. The
    object stores this security descriptor as a byte array in a mandatory attribute
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp>.
    As this attribute is defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp>
    class, all object classes require it. [Listing 11-15](chapter11.xhtml#Lis11-15)
    checks the attribute schema class and shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">Required</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录对象在创建时都会分配一个安全描述符。该对象将此安全描述符作为字节数组存储在名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp>
    的强制属性中。由于此属性在 <samp class="SANS_TheSansMonoCd_W5Regular_11">top</samp> 类中定义，所有对象类都需要它。[清单
    11-15](chapter11.xhtml#Lis11-15) 检查该属性的模式类，并显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Required</samp>
    为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-15: Checking the nTSecurityDescriptor attribute in the top class'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-15：检查顶级类中的 nTSecurityDescriptor 属性
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The lowercase* n *in the name <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nTSecurityDescriptor</samp>
    might look odd, but it’s correct. While LDAP name lookups are case insensitive,
    the names themselves are defined using lower camel case.*'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*小写* n *在名称 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nTSecurityDescriptor</samp>
    中可能看起来很奇怪，但它是正确的。虽然 LDAP 名称查找不区分大小写，但名称本身是使用小驼峰命名法定义的。*'
- en: To read the security descriptor, the user must be granted either <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access
    rights on the object, depending on the parts of the security descriptor they’ve
    requested. [Listing 11-16](chapter11.xhtml#Lis11-16) shows two techniques for
    retrieving the security descriptor of an Active Directory server object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取安全描述符，用户必须被授予对该对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> 访问权限，具体取决于他们请求的安全描述符的部分。[列表
    11-16](chapter11.xhtml#Lis11-16) 展示了两种检索 Active Directory 服务器对象的安全描述符的技术。
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 11-16: Accessing the security descriptor for the root object'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-16：访问根对象的安全描述符
- en: The first technique queries the object’s security descriptor using <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp>
    ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command
    automatically converts the security descriptor to an instance of the .NET <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectorySecurity</samp> class,
    so we can show its DACL using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>
    property.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp>
    ❶ 查询对象的安全描述符。<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>
    命令会自动将安全描述符转换为 .NET 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectorySecurity</samp>
    类实例，因此我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> 属性展示其
    DACL。
- en: The second technique uses the Win32 security descriptor commands from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module, specifying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ds</samp> type and the pathname
    as the distinguished name of the object. In this example, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32SecurityDescriptor</samp>
    command ❷ to get the security descriptor and immediately format it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术使用来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    模块的 Win32 安全描述符命令，指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ds</samp> 类型和路径名作为对象的区别名。在这个例子中，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-Win32SecurityDescriptor</samp>
    命令 ❷ 来获取安全描述符并立即格式化它。
- en: When might you choose to use one technique over the other? The Win32 security
    descriptor commands are a better option if you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module installed, as they don’t modify the information retrieved from the security
    descriptor. For example, you might notice that the first ACE in the DACL returned
    from each command isn’t the same. One belongs to the *Everyone* user, whereas
    the other belongs to *BUILTIN\Pre-Windows 2000 Compatible Access*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你什么时候可能选择一种技术而不是另一种？如果你安装了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    模块，Win32 安全描述符命令是一个更好的选择，因为它们不会修改从安全描述符中检索到的信息。例如，你可能会注意到从每个命令返回的 DACL 中的第一个 ACE
    不相同。一个属于 *Everyone* 用户，另一个属于 *BUILTIN\Pre-Windows 2000 Compatible Access*。
- en: The difference comes from the fact that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ActiveDirectorySecurity</samp>
    class, which the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>
    command uses to return the security descriptor from its attribute, automatically
    canonicalizes the DACL before allowing the user access to it. The canonicalization
    process might hide security misconfigurations. The Win32 command doesn’t do any
    canonicalization.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> 命令用来从其属性返回安全描述符时，会自动将
    DACL 规范化，从而允许用户访问它。这个规范化过程可能会隐藏安全配置错误。而 Win32 命令则不会进行任何规范化。
- en: Note that if you access the domain controller via the SAM remote service, you’ll
    really be accessing the Active Directory server’s user configuration, not a local
    SAM database. But if you inspect the security descriptors for the various supported
    objects, the SAM remote service won’t return the Active Directory ones. Instead,
    the LSA will pick a security descriptor from a predefined set, choosing the one
    that most closely matches the one in the directory object. This is just for show,
    though; ultimately, any access checks will occur against the security descriptor
    stored in the Active Directory server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果通过 SAM 远程服务访问域控制器，你实际上是在访问 Active Directory 服务器的用户配置，而不是本地 SAM 数据库。但如果你检查不同支持对象的安全描述符，SAM
    远程服务不会返回 Active Directory 中的那些对象。相反，LSA 将从预定义的集合中选择一个安全描述符，选择最接近目录对象中描述符的那个。不过，这仅仅是为了显示；最终，所有的访问检查都会针对存储在
    Active Directory 服务器中的安全描述符进行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Security
    Descriptors to New Directory Objects</samp>
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为新目录对象分配安全描述符</samp>
- en: When we create a new Active Directory object, we can assign it a security descriptor
    by providing a byte array for the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp>
    attribute. [Listing 11-17](chapter11.xhtml#Lis11-17) shows how to set this security
    descriptor when running PowerShell as a domain administrator. Don’t run these
    commands in a production environment, where modifying Active Directory could have
    adverse effects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的 Active Directory 对象时，可以通过为对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nTSecurityDescriptor</samp>
    属性提供一个字节数组来分配安全描述符。[清单 11-17](chapter11.xhtml#Lis11-17) 显示了如何在以域管理员身份运行 PowerShell
    时设置这个安全描述符。不要在生产环境中运行这些命令，因为修改 Active Directory 可能会产生不利影响。
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11-17: Creating a new Active Directory object with a security descriptor'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-17：创建一个带有安全描述符的新 Active Directory 对象
- en: We first create a security descriptor containing a single ACE that grants the
    *Administrators* group full access ❶. We then create a new container object called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SDDEMO</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ADObject</samp>
    command ❷, specifying the security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">OtherAttributes</samp>
    parameter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含单个 ACE 的安全描述符，该 ACE 允许 *Administrators* 组完全访问 ❶。然后，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ADObject</samp>
    命令 ❷ 创建一个新的容器对象，命名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">SDDEMO</samp>，并通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">OtherAttributes</samp> 参数指定安全描述符。
- en: Next, we format the new object’s security descriptor. As you can see, the ACE
    we specified is at the top of the DACL ❸, but other ACEs have appeared after the
    one we specified ❹, as auto-inheritance rules apply to the DACL and SACL of the
    parent object. (As discussed in [Chapter 6](chapter6.xhtml), you can specify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp>
    security descriptor control flags to prevent inheritable ACEs from being applied
    to the object, but we haven’t done that here.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们格式化新对象的安全描述符。如你所见，我们指定的 ACE 位于 DACL 的顶部 ❸，但在我们指定的 ACE 之后还出现了其他 ACE ❹，因为自动继承规则适用于父对象的
    DACL 和 SACL。（如[第 6 章](chapter6.xhtml)所述，你可以通过指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">SaclProtected</samp> 安全描述符控制标志来防止继承的
    ACE 被应用到对象上，但我们在这里没有这样做。）
- en: What if we don’t specify the security descriptor value when creating the object?
    In that case, the object will use a default security descriptor, taken from the
    schema class object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">defaultSecurityDescriptor</samp>
    attribute. [Listing 11-18](chapter11.xhtml#Lis11-18) shows how to manually create
    a new object security descriptor based on this default security descriptor attribute.
    This is simulating the operations the Active Directory server performs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建对象时没有指定安全描述符值，会怎样呢？在这种情况下，对象将使用从架构类对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">defaultSecurityDescriptor</samp>
    属性中获取的默认安全描述符。[清单 11-18](chapter11.xhtml#Lis11-18) 显示了如何基于此默认安全描述符属性手动创建一个新的对象安全描述符。这模拟了
    Active Directory 服务器执行的操作。
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 11-18: Creating a new object security descriptor'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-18：创建一个新的对象安全描述符
- en: First, we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp>
    schema class ❶. By inspecting this class’s schema identifier, we can determine
    which object ACEs were inherited (those with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritedObjectType</samp>
    value set) and identify the default security descriptors for the class. We then
    get the security descriptor from the parent, which is the root domain object ❷.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtSecurityDescriptor</samp>,
    specifying the parent security descriptor, the default security descriptor, and
    the object type ❸. We also specify the auto-inherit flags, to automatically inherit
    any DACL or SACL ACEs, and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Container</samp>
    parameter to identify that the security descriptor will secure a container, which
    ensures that it will use the correct inheritance rules. Finally, we can format
    the newly created security descriptor, which has auto-inherited the DACL.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The new security descriptor has the owner and group SIDs you might expect:
    namely, the user SID and the primary group SID of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object on which it is based. However, this won’t always be the case. If the creator
    of the object is a local administrator on the Active Directory server, the server
    will change the owner and group SIDs to one of the following SIDs:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '***Domain Admins    ***Set for any object in the default naming context under
    the domain root'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '***Enterprise Admins    ***Set for any object in the configuration naming context'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '***Schema Admins    ***Set for any object in the schema naming context'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Changing the owner and group SIDs to one of these values ensures that the resources
    across a forest have appropriate owners. For example, if *Enterprise Admins* weren’t
    the default owner for configuration objects, an administrator from a different
    domain in the forest might create an object that an administrator in another domain
    wouldn’t be able to access, even if they were in the correct group.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the final security descriptor, we must perform one last step: standardization.
    *Security descriptor standardization* is a feature introduced in Windows Server
    2003, and it’s turned on by default. It ensures that non-inherited ACEs always
    appear in a binary comparison order. This contrasts with the ACL canonicalization
    process described in [Chapter 5](chapter5.xhtml), which orders the ACEs based
    on the ACE type rather than on their binary value. Consequently, two canonical
    ACLs with the same ACE entries could have different ordering.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We can standardize a security descriptor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    command and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Standardize</samp>
    parameter ❹. Note, however, that the standardized ACL form doesn’t always match
    the canonical one. Indeed, if we compare the original canonicalized security descriptor
    (shown in [Listing 11-16](chapter11.xhtml#Lis11-16)) with the standardized one,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtSecurityDescriptor</samp>
    command shows two reordered ACEs ❺. In theory this discrepancy could change the
    result of an access check, but in practice it’s unlikely to do so, as <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACEs always appear before <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACEs, regardless of the other ACE ordering rules in place.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    命令和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Standardize</samp> 参数 ❹ 来标准化安全描述符。然而，请注意，标准化后的
    ACL 形式并不总是与规范化形式一致。实际上，如果我们将原始的规范化安全描述符（如 [清单 11-16](chapter11.xhtml#Lis11-16)
    所示）与标准化后的描述符进行比较，<samp class="SANS_TheSansMonoCd_W5Regular_11">Compare-NtSecurityDescriptor</samp>
    命令会显示两个重新排序的 ACE ❺。理论上，这种差异可能会改变访问检查的结果，但实际上不太可能发生这种情况，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE 始终出现在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp> ACE 之前，无论其他
    ACE 排序规则如何。
- en: An administrator can disable the standardization feature by setting a flag in
    the directory’s special <samp class="SANS_TheSansMonoCd_W5Regular_11">dsHeuristics</samp>
    attribute. You can query this flag using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsHeuristics</samp>
    PowerShell command, as shown in [Listing 11-19](chapter11.xhtml#Lis11-19).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以通过在目录的特殊 <samp class="SANS_TheSansMonoCd_W5Regular_11">dsHeuristics</samp>
    属性中设置标志来禁用标准化功能。你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsHeuristics</samp>
    PowerShell 命令查询此标志，如 [清单 11-19](chapter11.xhtml#Lis11-19) 所示。
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 11-19: Checking whether security descriptor standardization is enabled'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-19：检查是否启用了安全描述符标准化
- en: If the command returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    security descriptor standardization is disabled.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，则表示禁用了安全描述符标准化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning Security
    Descriptors to Existing Objects</samp>
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为现有对象分配安全描述符</samp>
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp>
    PowerShell command to change an existing object’s security descriptor based on
    the distinguished name of the object. [Listing 11-20](chapter11.xhtml#Lis11-20)
    demonstrates this for the object <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=SomeObject,DC=mineral,DC=local</samp>.
    Before running the script, change this name to that of an object that exists in
    your Active Directory configuration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-Win32SecurityDescriptor</samp>
    PowerShell 命令，根据对象的区分名来更改现有对象的安全描述符。[清单 11-20](chapter11.xhtml#Lis11-20) 演示了如何针对对象
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CN=SomeObject,DC=mineral,DC=local</samp>
    执行此操作。在运行脚本之前，请将此名称更改为你 Active Directory 配置中存在的对象名称。
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-20: Setting an object’s security descriptor using the Set-Win32SecurityDescriptor
    command'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-20：使用 Set-Win32SecurityDescriptor 命令设置对象的安全描述符
- en: The command sends a modification request to the directory server to set the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSecurityDescriptor</samp> attribute.
    As discussed in [Chapter 6](chapter6.xhtml), the user modifying the security descriptor
    must be granted the appropriate access rights on the object (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    access) for the part of the security descriptor being written.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令向目录服务器发送修改请求，以设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSecurityDescriptor</samp>
    属性。如 [第 6 章](chapter6.xhtml) 中所讨论，修改安全描述符的用户必须被授予对该对象的适当访问权限（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    访问权限），才能修改安全描述符的相应部分。
- en: Security information flags specify which parts of the security descriptor you
    can modify. To get this information, request the constructed <samp class="SANS_TheSansMonoCd_W5Regular_11">sDRightsEffective</samp>
    attribute for the object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSDRightsEffective</samp>
    PowerShell command exposes this attribute, as shown in [Listing 11-21](chapter11.xhtml#Lis11-21).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 安全信息标志指定了可以修改的安全描述符的部分。要获取这些信息，请请求对象的构造后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sDRightsEffective</samp>
    属性。<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSDRightsEffective</samp>
    PowerShell 命令会暴露此属性，如 [列表 11-21](chapter11.xhtml#Lis11-21) 所示。
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 11-21: Querying for the effective security information'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-21：查询有效的安全信息
- en: The output indicates that the current caller would be granted write access to
    the owner, group, and DACL. This result takes into account privileges such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>,
    which allows a caller to modify the owner even if the security descriptor doesn’t
    grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access.
    The directory also allows a caller to bypass certain checks using privileges;
    for example, it can check for <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
    to determine whether the caller can set arbitrary owner SIDs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果表示当前调用者将被授予对所有者、组和 DACL 的写访问权限。这个结果考虑了如 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    等特权，该特权允许调用者修改所有者，即使安全描述符未授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    访问权限。目录还允许调用者通过特权绕过某些检查；例如，它可以检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
    来确定调用者是否可以设置任意所有者 SID。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To add or remove a DACL-protected flag with the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Set-Win32SecurityDescriptor</samp>
    command, you’ll need to use the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ProtectedDacl</samp>
    or UnprotectedDacl security information flag. These flags aren’t passed to the
    server; instead, they are set in the security descriptor’s control flags, which
    are then sent to the server.*'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*要使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Set-Win32SecurityDescriptor</samp>
    命令添加或移除受 DACL 保护的标志，您需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ProtectedDacl</samp>
    或 UnprotectedDacl 安全信息标志。这些标志不会传递到服务器；相反，它们会在安全描述符的控制标志中设置，然后发送到服务器。*'
- en: 'In [Listing 11-22](chapter11.xhtml#Lis11-22), we build a new security descriptor
    for an object, deriving it from three values: the security descriptor supplied
    by the user, the current security descriptor, and the parent security descriptor.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 11-22](chapter11.xhtml#Lis11-22) 中，我们为一个对象构建了一个新的安全描述符，从三个值中派生：用户提供的安全描述符、当前的安全描述符以及父级安全描述符。
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-22: Creating a new security descriptor for an object'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-22：为对象创建一个新的安全描述符
- en: First, we get the current security descriptor for the object. In this case I’ve
    picked the <samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp> container,
    as it provides an easy example ❶, but you can choose any object in the directory.
    Next, we create a new security descriptor ❷ and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    PowerShell command to modify the object’s existing security descriptor, replacing
    it with the one we just created ❸. In this command, we must specify the security
    information flags as well as the auto-inherit flags.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取对象的当前安全描述符。在这个例子中，我选择了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp>
    容器，因为它提供了一个简单的示例 ❶，但您可以选择目录中的任何对象。接下来，我们创建一个新的安全描述符 ❷，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    PowerShell 命令修改对象现有的安全描述符，将其替换为我们刚刚创建的 ❸。在此命令中，我们必须指定安全信息标志以及自动继承标志。
- en: We then use the modified security descriptor as the creator security descriptor,
    using the parent security descriptor and the target object’s class information
    for inheritance ❹. We specify some additional auto-inherit flags to disable the
    owner check; this ensures that we set the owner value correctly based on the original
    security descriptor. Disabling the checks isn’t a security issue because the caller
    must have set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> security
    information flag to change the owner, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>
    would have checked for the owner SID, preventing a user from circumventing the
    check.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用修改后的安全描述符作为创建者安全描述符，利用父级安全描述符和目标对象的类信息进行继承 ❹。我们指定了一些额外的自动继承标志来禁用所有者检查；这样可以确保我们根据原始安全描述符正确设置所有者值。禁用检查不是安全问题，因为调用者必须已设置<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>安全信息标志才能更改所有者，并且<samp class="SANS_TheSansMonoCd_W5Regular_11">Edit-NtSecurityDescriptor</samp>会检查所有者SID，防止用户绕过检查。
- en: We can now standardize the security descriptor and format it ❺. As you can see,
    it now contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">Everyone</samp>
    ACE, matching the new security descriptor we specified. At this point, the server
    will also enumerate any child objects of the security descriptor we’re modifying
    and apply any inheritance changes to the new security descriptor we’ve introduced.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以标准化安全描述符并格式化它 ❺。如您所见，它现在包含了<samp class="SANS_TheSansMonoCd_W5Regular_11">Everyone</samp>
    ACE，符合我们指定的新安全描述符。此时，服务器还将枚举我们正在修改的安全描述符的任何子对象，并将继承的任何更改应用于我们引入的新安全描述符。
- en: 'Note that the server automatically propagates inheritable ACEs to child objects
    whenever a parent object’s security descriptor changes. This behavior contrasts
    with that of files and registry keys, where it’s the responsibility of the Win32
    APIs to manually propagate inheritance to children. The automatic propagation
    introduces an interesting consequence: the server doesn’t check that the user
    setting the security descriptor has appropriate access rights to the child object.
    Therefore, a user with <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    access to an object higher in a hierarchy can set a new inheritable ACE and grant
    themselves access to a child object to which they didn’t previously have access.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每当父级对象的安全描述符发生变化时，服务器会自动将可继承的ACE传播到子对象。这一行为与文件和注册表项的行为不同，因为在这些情况下，由Win32
    API负责手动传播继承给子对象。自动传播引入了一个有趣的结果：服务器不会检查设置安全描述符的用户是否具有适当的访问权限来访问子对象。因此，在层级结构中具有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>访问权限的用户可以设置一个新的可继承ACE，并授予他们对先前无法访问的子对象的访问权限。
- en: The only way to mitigate this behavior is by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>
    control flag in the object’s security descriptor to block inheritance (as well
    as the fact that administrators should never grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>
    access to non-administrator users).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解这种行为的唯一方法是通过在对象的安全描述符中设置<samp class="SANS_TheSansMonoCd_W5Regular_11">DaclProtected</samp>控制标志来阻止继承（以及管理员永远不应授予非管理员用户<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>访问权限这一事实）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting a Security
    Descriptor’s Inherited Security</samp>
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查安全描述符的继承安全性</samp>
- en: Because the security descriptors are assigned based on the object hierarchy,
    it’s possible to locate the source of their inherited ACEs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp>
    PowerShell command. In [Listing 11-23](chapter11.xhtml#Lis11-23), we find the
    inherited ACEs for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp>
    container.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全描述符是基于对象层级分配的，因此可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Search-Win32SecurityDescriptor</samp>
    PowerShell命令定位其继承的ACE来源。在[列表 11-23](chapter11.xhtml#Lis11-23)中，我们找到了<samp class="SANS_TheSansMonoCd_W5Regular_11">Users</samp>容器的继承ACE。
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-23: Searching for the source of inherited ACEs'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-23：搜索继承ACE的来源
- en: You can use this command with Active Directory objects in almost the same way
    as you would use it with files. The important difference is that you must set
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> property to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ds</samp> to look up Active Directory
    objects on the server.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用文件一样，几乎相同地在活动目录对象上使用此命令。重要的区别是，你必须将<samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>属性设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ds</samp>，以便在服务器上查找活动目录对象。
- en: You must also specify the schema class GUID for inheritance ACEs using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> parameter; otherwise,
    the command might not be able to find the source ACEs at all, as they’re likely
    to be inherited based on the object’s type. In my testing, the search sometimes
    succeeded when I didn’t specify the object type, but in most cases, the operation
    failed with an unrelated error.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp>参数指定继承ACE的架构类GUID；否则，命令可能无法找到源ACE，因为它们可能基于对象的类型继承。在我的测试中，当我未指定对象类型时，有时搜索成功，但在大多数情况下，操作因无关的错误而失败。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Access Checks</samp>
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">访问检查</samp>
- en: 'Now that we can query an object’s security descriptor, we can perform an access
    check to determine whether it would grant a user some specific access. Active
    Directory designates nine type-specific access rights that directory objects can
    grant, in addition to the standard rights such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp> (used to read
    and write, respectively, the security descriptor on the object). They are:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查询对象的安全描述符，可以执行访问检查以确定它是否会授予用户某些特定访问权限。活动目录指定了九种类型特定的访问权限，目录对象可以授予这些权限，此外还有一些标准权限，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteDac</samp>（分别用于读取和写入对象上的安全描述符）。它们包括：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateChild  </samp>Enables creating
    a new child object
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateChild  </samp>启用创建新子对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeleteChild  </samp>Enables deleting
    a child object
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeleteChild  </samp>启用删除子对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">List  </samp>Enables listing child
    objects
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">List  </samp>启用列出子对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Self  </samp>Enables writing an
    attribute value (which the server will verify)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Self  </samp>启用写入属性值（服务器将验证此值）
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadProp  </samp>Enables reading
    an attribute value
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadProp  </samp>启用读取属性值
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteProp</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables
    writing an attribute value
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteProp</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>启用写入属性值
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeleteTree  </samp>Enables deleting
    a tree of objects
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeleteTree  </samp>启用删除一棵对象树
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListObject  </samp>Enables listing
    a specific object
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListObject  </samp>启用列出特定对象
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ControlAccess  </samp>Grants access
    to a directory operation
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ControlAccess  </samp>授予目录操作访问权限
- en: Some of these access rights require more explanation than others. In the following
    sections, we’ll walk through the various operations they represent and how they’re
    used to determine what a user can do on the directory server. Note that the behaviors
    of these access rights also apply to ACEs specified in an object’s SACL, meaning
    you should be able to take the descriptions presented here and apply them to the
    generation of audit events.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问权限中的一些需要比其他权限更多的解释。在接下来的章节中，我们将逐步讲解它们代表的各种操作以及如何用它们来确定用户可以在目录服务器上执行的操作。请注意，这些访问权限的行为同样适用于对象的SACL中指定的ACE，这意味着你应该能够将这里提供的描述应用于审计事件的生成。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Objects</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建对象</samp>
- en: If a user is granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    access right, they can create a child object for the object. The object’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp> ACEs determine what
    kinds of child objects a user can create. [Listing 11-24](chapter11.xhtml#Lis11-24)
    shows how to grant the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    access right for a specific object type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户被授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> 访问权限，他们可以为该对象创建子对象。对象的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AllowedObject</samp> ACE 决定了用户可以创建哪些类型的子对象。[列表
    11-24](chapter11.xhtml#Lis11-24) 展示了如何为特定对象类型授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    访问权限。
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-24: Testing CreateChild object type access'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-24：测试 CreateChild 对象类型访问权限
- en: We first create a new security descriptor and add an ACE that grants everyone
    <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access ❶. This ACE doesn’t
    specify an object type, so it will apply to every user who matches the SID. Next,
    we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> schema class
    ❷ and use it to create a second ACE that grants <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    access, specifying the schema identifier as the object type.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的安全描述符，并添加一个授予每个人 <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp>
    访问权限的 ACE ❶。此 ACE 没有指定对象类型，因此它将适用于每个匹配 SID 的用户。接下来，我们获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    模式类 ❷，并使用它创建第二个 ACE，授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    访问权限，指定模式标识符作为对象类型。
- en: We display the security descriptor to verify that we’ve created the correct
    ACEs, passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResolveObjectType</samp>
    parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>
    to return the directory object type’s name. If you don’t use this parameter, the
    command will print the GUID instead, which is less useful; however, note that
    returning these names can be quite time-consuming and might cause the command
    to hang.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显示安全描述符以验证我们是否创建了正确的 ACE，传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">ResolveObjectType</samp>
    参数给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>
    以返回目录对象类型的名称。如果不使用此参数，命令将打印 GUID，尽管这没有那么有用；不过请注意，返回这些名称可能非常耗时，可能会导致命令挂起。
- en: We now request the maximum granted access for the security descriptor ❸, specifying
    the schema class as the object type to check, and are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> access. The directory
    server will do the same when performing the access check for the child creation
    operation; it will look up the schema class identifier for the object class being
    created and pass it to the access check API. If <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    access is granted, the operation will proceed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在请求最大授予的安全描述符访问权限 ❸，指定模式类作为检查的对象类型，并获得 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> 访问权限。目录服务器在执行子创建操作的访问检查时也会执行相同的操作；它将查找正在创建的对象类的模式类标识符，并将其传递给访问检查
    API。如果授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> 访问权限，操作将继续进行。
- en: Finally, we repeat the access check but instead specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp>
    class ❹. This time, we’re granted only <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp>
    access—because we didn’t pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    class’s identifier in the list of object types to check, the access check ignored
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> ACE.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重复访问检查，但这次指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp>
    类 ❹。这一次，我们只获得 <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> 访问权限——因为我们没有在检查的对象类型列表中传递
    <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> 类的标识符，访问检查忽略了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> ACE。
- en: If an object’s security descriptor contains an ACE that grants the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    access right with no object type specified, the user can create any child object.
    However, limitations still exist. First, the user can only create new objects
    of structural classes; the server should reject the creation of an object from
    an abstract or auxiliary class. Second, each schema class has a list of possible
    parent classes, or *superiors*, stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">possSuperiors</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">systemPossSuperiors</samp> attributes.
    The server will permit the creation of a child only if the parent object’s class
    is in this list of classes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象的安全描述符包含一个ACE，它授予了<sup class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</sup>访问权限且未指定对象类型，则用户可以创建任何子对象。然而，仍然存在一些限制。首先，用户只能创建结构类的新对象；服务器应拒绝创建来自抽象类或辅助类的对象。其次，每个模式类都有一个可能的父类列表，或者称为*上级*，这些信息存储在<sup
    class="SANS_TheSansMonoCd_W5Regular_11">possSuperiors</sup>和<sup class="SANS_TheSansMonoCd_W5Regular_11">systemPossSuperiors</sup>属性中。服务器仅在父对象的类位于此类列表中时，才允许创建子对象。
- en: Determining all permitted child classes can be quite complex due to the rules
    of class inheritance. Fortunately, the directory server also constructs the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">possibleInferiors</samp> attribute, which
    lists the classes the directory will allow as children for a given schema class.
    You can query for these classes using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaClass</samp>
    PowerShell command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Inferior</samp>
    parameter, as shown in [Listing 11-25](chapter11.xhtml#Lis11-25).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 确定所有允许的子类可能会非常复杂，因为涉及类继承的规则。幸运的是，目录服务器还构建了<sup class="SANS_TheSansMonoCd_W5Regular_11">possibleInferiors</sup>属性，它列出了目录将允许作为给定模式类子类的类。你可以通过使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Get-DsSchemaClass</sup> PowerShell命令，结合<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Inferior</sup>参数来查询这些类，如[Listing 11-25](chapter11.xhtml#Lis11-25)所示。
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 11-25: Listing inferior classes of the user schema class'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 11-25：列出用户模式类的下级类
- en: '[Listing 11-25](chapter11.xhtml#Lis11-25) shows the four child classes allowed
    for a user object. Trying to create an object of a class that isn’t in the list
    of children will result in an error and abort the creation operation. An administrator
    can change this list by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    class to another class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">possSuperiors</samp>
    attribute.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-25](chapter11.xhtml#Lis11-25)展示了允许的用户对象的四个子类。如果尝试创建不在子类列表中的类，将导致错误并中止创建操作。管理员可以通过将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">user</sup>类添加到另一个类的<sup class="SANS_TheSansMonoCd_W5Regular_11">possSuperiors</sup>属性中来更改此列表。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Deleting Objects</samp>
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">删除对象</sup>
- en: 'Three access rights control deletion: <samp class="SANS_TheSansMonoCd_W5Regular_11">Delete</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteTree</samp>.
    Each concerns a different delete operation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Delete</samp>
    access right applies only to the current object; if the object has child objects,
    the server will refuse to delete the object. (A client application could bypass
    this restriction by recursively enumerating all children and deleting them if
    the user had the necessary access.)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个访问权限控制删除操作：<sup class="SANS_TheSansMonoCd_W5Regular_11">Delete</sup>、<sup
    class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</sup>和<sup class="SANS_TheSansMonoCd_W5Regular_11">DeleteTree</sup>。每个访问权限对应不同的删除操作。<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Delete</sup>访问权限仅适用于当前对象；如果对象有子对象，服务器将拒绝删除该对象。（客户端应用程序可以通过递归地枚举所有子对象，并在用户具有必要访问权限时删除它们，从而绕过此限制。）
- en: If the user is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp>
    access, they can delete any immediate child object, although if that child object
    has its own children, the same restriction as for <samp class="SANS_TheSansMonoCd_W5Regular_11">Delete</samp>
    applies. The ACE granting <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp>
    access can use the object type to restrict which of an object’s classes a user
    can delete.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteTree</samp>
    access right allows a user to delete an entire tree of objects, including the
    root object. This deletion is performed entirely on the server, using a specific
    tree-deletion command. The user does not need any deletion rights on the child
    objects if they have this right.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: You can remove objects using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-ADObject</samp>
    PowerShell command. To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteTree</samp>
    access right, you must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Recursive</samp>
    parameter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listing Objects</samp>
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The list of access rights includes two rights for listing objects, <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp>. There are
    some differences between these. By default, if a user is not granted <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp>
    access, they cannot inspect any of an object’s children. However, this restriction
    isn’t transitive; for example, if a child object grants the <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp>
    access right, the user can inspect the children of that object, even though they
    can’t list the object itself from the parent. (This means the user will need to
    know the name of the child object to inspect.)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access applies
    not to the parent but to individual objects. If a user has the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp>
    access right on an object but doesn’t have the <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp>
    access right on the parent, the user can still list and interact with the object.
    By default, the Active Directory server doesn’t check the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp>
    access right, likely for performance reasons.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: If the user were not granted <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp>
    access on an object, but tried to enumerate its children, the server would need
    to do an access check for every child object to find out which were visible through
    allowing <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access.
    For directory objects with large numbers of children, this would be a very expensive
    operation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable this access right using a flag in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dsHeuristics</samp>
    attribute in the directory. Query the flag using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsHeuristics</samp>
    PowerShell command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过目录中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">dsHeuristics</samp>
    属性中的标志启用此访问权限。使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsHeuristics</samp>
    PowerShell 命令查询此标志：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the output is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp> access right
    is enabled.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">ListObject</samp>
    访问权限已启用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading and Writing
    Attributes</samp>
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">读取和写入属性</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access rights control
    the reading and writing, respectively, of attributes in an object. It’s possible
    to allow the reading and writing of all of an object’s attributes through an ACE
    with no object type. More commonly, however, an object will allow the reading
    of all attributes, but restrict which attributes can be written by specifying
    an ACE’s object type as the attribute’s schema identifier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    访问权限分别控制对对象属性的读取和写入。可以通过没有对象类型的 ACE 允许读取和写入对象的所有属性。然而，更常见的情况是，对象允许读取所有属性，但通过指定
    ACE 的对象类型为属性的模式标识符来限制可以写入的属性。
- en: '[Listing 11-26](chapter11.xhtml#Lis11-26) shows an example of how to implement
    an access check for reading and writing attributes.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-26](chapter11.xhtml#Lis11-26) 展示了如何实现读取和写入属性的访问检查的示例。'
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 11-26: Testing the ReadProp and WriteProp access rights'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-26：测试 ReadProp 和 WriteProp 访问权限
- en: We start by creating a new security descriptor with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE that grants <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access, without specifying an object type ❶. We then add an ACE that grants <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access to only the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp> attribute ❷.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的安全描述符，带有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Allowed</samp>
    ACE，授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> 访问权限，但没有指定对象类型
    ❶。然后，我们添加一个 ACE，授予对 <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    属性的 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> 访问权限 ❷。
- en: Next, we perform an access check specifying that attribute’s schema identifier
    as the object type ❸, and we’re granted both <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access. However,
    if we run the access check with a different attribute type ❹, we’re granted only
    the general <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行一个访问检查，指定该属性的模式标识符作为对象类型 ❸，并且我们被授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> 访问权限。然而，如果我们使用不同的属性类型
    ❹ 运行访问检查，则只会授予一般的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    访问权限。
- en: Note that the security descriptor could contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE to block the reading or writing of a specific attribute, even if a separate
    ACE enabled reading or writing of all attributes. For instance, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE blocked the reading of the <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp>
    attribute we queried for here, even <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access wouldn’t be granted. The directory server must ensure that it specifies
    the exact object type for the attributes to check.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，安全描述符可能包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE，阻止特定属性的读取或写入，即使另一个独立的 ACE 允许读取或写入所有属性。例如，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE 阻止了我们在这里查询的 <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp>
    属性的读取，即使有 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> 访问权限，也不会被授予。目录服务器必须确保它为要检查的属性指定了正确的对象类型。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Even if the access check indicates that an attribute can be read or written,
    the directory server doesn’t have to honor that decision. The directory contains
    several attributes that a normal user can’t read or write. For example, they can’t
    read or write user passwords, which are stored in the unicodePwd attribute that
    only the system is permitted to access. No amount of configuring the security
    descriptor should change this behavior (although a separate mechanism allows a
    user to write the password;* *we’ll come back to this in “Control Access Rights”
    on page 376). Note also that a normal user can’t modify any attribute that is
    marked as system-only, indicated by the systemOnly attribute in the schema.*'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*即使访问检查显示某个属性可以被读取或写入，目录服务器也不一定会遵循这一决定。目录中包含多个普通用户无法读取或写入的属性。例如，用户无法读取或写入存储在unicodePwd属性中的密码，只有系统可以访问该属性。配置安全描述符的任何方式都不应改变这一行为（尽管一个单独的机制允许用户写入密码；*
    *我们将在“控制访问权限”一章第376页回到这个问题）。还需要注意的是，普通用户不能修改任何标记为系统专用的属性，这些属性在架构中由systemOnly属性表示。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Multiple
    Attributes</samp>
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查多个属性</samp>
- en: To avoid making you send multiple requests to the directory server, LDAP supports
    the reading and writing of multiple attributes in a single request. However, it
    would be expensive to then require an access check for each of these attributes’
    schema identifiers before determining what you can read or write.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免让你向目录服务器发送多个请求，LDAP支持在单次请求中读取和写入多个属性。然而，如果每个属性的架构标识符都需要单独进行访问检查，以确定你能读取或写入什么，这将是非常昂贵的。
- en: As I described in [Chapter 7](chapter7.xhtml), the access check process allows
    you to build a tree of object types to verify multiple attributes in a single
    check. This tree lists each object type and what access it will be granted, enabling
    the directory server to quickly determine if it should grant a request. [Listing
    11-27](chapter11.xhtml#Lis11-27) shows how to use an object type tree in an access
    check. It adds to the commands in [Listing 11-26](chapter11.xhtml#Lis11-26).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第7章](chapter7.xhtml)中所述，访问检查过程允许你构建一个对象类型树，在一次检查中验证多个属性。该树列出了每个对象类型以及它将被授予的访问权限，使得目录服务器能够快速判断是否应该批准请求。[清单11-27](chapter11.xhtml#Lis11-27)展示了如何在访问检查中使用对象类型树。这是对[清单11-26](chapter11.xhtml#Lis11-26)命令的扩展。
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 11-27: Using an object type tree to check multiple attributes'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-27：使用对象类型树检查多个属性
- en: We first get the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> schema
    class ❶ and use it to build the tree, setting the class’s schema identifier as
    the tree’s root. We then add the two attributes we want to check, <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp>, as leaf nodes
    to the root, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-ObjectTypeTree</samp>
    command. [Figure 11-4](chapter11.xhtml#fig11-4) shows the structure of the final
    tree.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取<samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>架构类 ❶，并利用它构建树，将该类的架构标识符设置为树的根。然后，我们将要检查的两个属性，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp>，作为叶节点添加到根节点中，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Add-ObjectTypeTree</samp>命令。[图11-4](chapter11.xhtml#fig11-4)展示了最终树的结构。
- en: '![](../images/Figure11-4.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The object type
    tree for the user object and its accountExpires</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and
    pwdLastSet attributes</samp>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-4：用户对象的对象类型树及其accountExpires</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">和pwdLastSet属性</samp>
- en: Next, we pass the tree to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    ❷, making sure to specify that we want the list of all results, not the single
    granted-access value. The results show that only the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    attribute has been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access, while
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp> attribute have been
    granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access only.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the Active Directory server will specify an explicit access right
    to check for, rather than simply requesting the maximum granted access. We can
    test this by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>
    parameter with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    and checking the resulting behavior ❸. The results show that the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    object and its <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp>
    attribute have been denied access, but that the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    attribute is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the object’s class is specified in the tree leads to an interesting
    behavior, demonstrated in [Listing 11-28](chapter11.xhtml#Lis11-28).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 11-28: Granting WriteProp access to the schema class'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it’s possible to add an ACE that grants access rights for all
    attributes of a specified object class. Here, we add an ACE granting <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    class’s schema identifier. When we repeat our access check, this time we find
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp> access is
    granted for all attributes in the tree.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: This behavior, granting access to all attributes, is likely an emergent property
    of the implementation, not an intentional design decision; the Windows user interface
    for modifying a directory object’s security descriptor can’t understand the ACE
    and shows it as granting no specific access rights. An attacker could use this
    behavior to hide malicious modifications to the security descriptor from an administrator.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Property
    Sets</samp>
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As shown in [Listing 11-29](chapter11.xhtml#Lis11-29), an object class can have
    many attributes—in the case of the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    class, a total of 428 if we include the attributes of all its auxiliary classes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 11-29: Counting attributes for the user schema class'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to grant specific access rights to all of these attributes, the
    DACL would quickly become unmanageable; the ACL might even run out of its allowed
    64KB of space.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: To partially solve this problem, the Active Directory configuration can define
    arbitrary *property sets*, which group multiple attributes together under a single
    GUID. It can then use this identifier as the object type in an ACE to grant or
    deny access to a group of attributes in one go. Property sets are just one type
    of *extended right*, which allow an administrator to add additional access rights
    to the directory. We’ll cover the other two, control access rights and validated
    write access rights, in the following sections. [Listing 11-30](chapter11.xhtml#Lis11-30)
    shows how to get all the extended rights in the current directory.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 11-30: Getting extended rights and grouping them by the validAccesses
    attribute'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: An object can specify a particular type of extended right in its <samp class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp>
    attribute, which stores an integer representing directory object access rights.
    We convert the attribute to an access rights enumeration using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccessMask</samp>
    PowerShell command. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp>
    attribute (and thus the value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    column) is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>, the extended
    right is a property set.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the analysis of extended rights and property sets, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsExtendedRight</samp>
    PowerShell command, as shown in [Listing 11-31](chapter11.xhtml#Lis11-31).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 11-31: Getting the property set for an attribute and its possible schema
    classes'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: We first get the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    attribute we used earlier and pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsExtendedRight</samp>
    command ❶. If the attribute is part of a property set, the command will return
    the extended right. Here, the output lists the attribute as part of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">User-Account-Restrictions</samp> property
    set ❷.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">RightsId</samp> column provides
    the GUID you’d use in an ACE to allow or deny access to the object type. You can
    find this GUID in the schema attribute’s <samp class="SANS_TheSansMonoCd_W5Regular_11">attributeSecurityGUID</samp>
    attribute. Each property set also has a list of schema classes that are allowed
    to contain it ❸. This allows the directory server to know what object type tree
    it needs to build when doing an access check.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we perform the reverse operation; finding all property sets that apply
    to a specific schema class, <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    ❹.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-32](chapter11.xhtml#Lis11-32) demonstrates using a property set
    in an access check.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 11-32: Performing an access check with a property set'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: We build a new security descriptor to do the check ❶, and we grant <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access based on the property set identifier. We also grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    attribute within that set, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">attr</samp>
    variable we defined in [Listing 11-31](chapter11.xhtml#Lis11-31) ❷.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to build the object type tree ❸. As before, the root of the tree
    is the object class. We then add the property set as a child of the tree, producing
    the object type tree shown in [Figure 11-5](chapter11.xhtml#fig11-5).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-5.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: The property set
    object type tree</samp>'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: This object type tree contains both the property set at level 1 and entries
    for each attribute in the set at level 2\. This tree structure allows us to grant
    access based on either the property set identifier or individual attributes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Note that the directory server implements individual attribute checks a little
    differently; it always uses property sets if it can, but if an attribute isn’t
    in a property set it uses a dummy GUID, named <samp class="SANS_TheSansMonoCd_W5Regular_11">PROPSET_GUID_DEFAULT</samp>,
    as a placeholder. You might see this GUID in audit log entries, although the configuration’s
    extended rights don’t specify it.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We pass the object type tree and security descriptor to the access check ❹,
    and since we granted the property set <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access, all attributes in the set receive at least this level of access. Because
    we explicitly granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    attribute, it receives this access right as well.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if the security descriptor granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access to every attribute in the set, the access would propagate to the property
    set node at level 1\. Therefore, if the server merely checked the property set’s
    granted access, it wouldn’t matter if the security descriptor granted the access
    directly, using the property set’s identifier, or instead granted access to every
    individual attribute in the set.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: One last thing to highlight is what happens when we add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE for attributes in a property set. [Listing 11-33](chapter11.xhtml#Lis11-33)
    shows an example.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 11-33: Denying access to an attribute in a property set'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we include a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE for the <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp> attribute
    to restrict the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access right ❶. You must remember to canonicalize the DACL ❷ after adding the
    ACE; otherwise, it won’t appear at the start of the list, and the access check
    process will ignore it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the access check, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE has removed <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access from the <samp class="SANS_TheSansMonoCd_W5Regular_11">pwdLastSet</samp>
    attribute, then propagated that change to the property set and <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    class, removing their access as well ❸. All other attributes in the set retain
    their <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp> access. This
    behavior makes sense: if one of the property set’s attributes is denied access,
    then the property set as a whole isn’t granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: If the property set identifier was used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeniedObject</samp>
    ACE, all attributes in the set would be denied the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProp</samp>
    access right. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">accountExpires</samp>
    would still be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access as it has a separate ACE granting it that access.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: An Active Directory server administrator can add their own property sets to
    the configuration to extend this functionality to commonly used attributes; this
    reduces the complexity of object security descriptors.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting Control
    Access Rights</samp>
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second type of extended right, *control access rights*, don’t necessarily
    correspond to any object attribute; instead, they tell the Active Directory server
    whether the user can perform a particular operation. Let’s start by listing a
    subset of the control access rights, as shown in [Listing 11-34](chapter11.xhtml#Lis11-34).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 11-34: Listing control access rights with password in the name'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsControl</samp> property,
    we filter the output so it includes only control access rights with <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp>
    in their name. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IsControl</samp>
    property is <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp> attribute on the
    extended right is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp>.
    The results include two commonly used control access rights, <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Force-Change-Password</samp>,
    which allow a user to modify their user object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">unicodePwd</samp>
    write-only attribute. We can’t grant this ability using <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The difference between these two rights is that <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp>
    requires the user to send their old password as part of the modify operation,
    while <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Force-Change-Password</samp>
    works without requiring the old password. These correspond to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp> SAM
    user access rights we discussed in [Chapter 10](chapter10.xhtml) and serve the
    same purpose.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: To give an example of how the directory server might check for a control access
    right, let’s assume a user wants to change another user’s password. [Listing 11-35](chapter11.xhtml#Lis11-35)
    shows how the server might implement the access check for permitting the change
    operation.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 11-35: Checking for the User-Change-Password control access right'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new security descriptor, get the control access right, and
    add an ACE to the security descriptor granting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp>
    access right for <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp>
    ❶. Next, we query for the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    schema class and use it to build the object type tree ❷. We need the object class
    to be the root, but we make the control access right its immediate child. We also
    query for the <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Force-Change-Password</samp>
    control access right and add it to the tree ❸. If the user is granted this right,
    the server will allow them to force the password change even if they cannot provide
    the currently set password.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: We then run the access check ❹ and see that the user has been granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp>
    control access right. Now the directory server can proceed with the operation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: As with other types of access, it’s possible for a security descriptor to grant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> either with
    a non-object ACE or on the object class. From the access check perspective, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> is granted to the
    control access right; the directory server doesn’t necessarily know the difference.
    It’s also possible for an administrator to extend the list of control access rights,
    although that normally requires a third-party application to check for the right,
    as the directory server won’t know about it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analyzing Write-Validated
    Access Rights</samp>
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final type of extended right is write-validated access rights. They’re defined
    when the <samp class="SANS_TheSansMonoCd_W5Regular_11">validAccesses</samp> attribute
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>. [Listing
    11-36](chapter11.xhtml#Lis11-36) shows how to list the write-validated access
    rights by filtering on the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsValidatedWrite</samp>
    property.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 11-36: Listing write-validated access rights'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: A write-validated access right grants a user the ability to write to certain
    attributes of an object, with the server verifying the new value for the attribute
    before it’s written. As an example, if a user wants to add a new member to a group
    object, they will need <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access on the <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> attribute,
    which contains a list of distinguished names of all users and groups that are
    members of that group. Being granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access will allow the user to modify the member list, adding or removing user
    or group objects. A user without that access right might still be able to add
    or remove their own user account name, however, if they’re granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>
    access right for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Self-Membership</samp>
    write-validated access right on a group object. While this operation would still
    modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">member</samp> attribute,
    the server would ensure that the added or removed value corresponds to the calling
    user’s distinguished name and reject any other modification.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The name of the access right, <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>,
    is likely derived from its use as a mechanism for self-group membership. Over
    time, its use has been expanded to cover a few additional attributes. Microsoft’s
    Active Directory Technical Specification (*MS-ADTS*, available online) refers
    to it as <samp class="SANS_TheSansMonoCd_W5Regular_11">RIGHT_DS_WRITE_PROPERTY_EXTENDED</samp>,
    which is a slightly better description.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: We won’t perform an example access check for write-validated access because
    it’s the same as the check shown in [Listing 11-35](chapter11.xhtml#Lis11-35)
    for control access rights; simply change the extended right you query and check
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp> access is granted.
    As with <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp>, it’s
    possible for a non-object ACE to grant <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>
    access without having a specific ACE for the write-validated access right.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Note that an administrator can’t modify the list of write-validated access rights;
    this is because the directory server won’t know to enforce the restriction. A
    third-party application can’t implement this behavior, either, as its purpose
    is to limit the changes that can be made to the directory.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the SELF
    SID</samp>
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When I discussed the object type access check in [Chapter 7](chapter7.xhtml),
    I also mentioned a principal SID that you can specify to replace the *SELF* SID
    in an ACE. Active Directory uses the *SELF* SID to grant access to resources based
    on whether the user making the request is the “self” in question. It extracts
    the SID to use as this principal SID from the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp>
    attribute, used to store the SID for the user or computer account, as well as
    the group SID.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to modify a user object in the directory, the server
    will look up the object’s security descriptor and query for the object’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp> attribute. If the attribute
    is present in the object, the access check will use the value as the principal
    SID, along with the security descriptor. If the attribute isn’t present, no principal
    SID will be set, and any ACE with the *SELF* SID won’t be evaluated. [Listing
    11-37](chapter11.xhtml#Lis11-37) shows how to extract the <samp class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp>
    attribute.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 11-37: Getting a computer account’s objectSID'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways of accessing the attribute. The simplest is to use either
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADComputer</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-ADUser</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADGroup</samp>
    command, which will automatically extract the SID. In [Listing 11-37](chapter11.xhtml#Lis11-37),
    we get the SID for the current computer. Alternatively, if you’re using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp>, you can request the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">objectSID</samp> attribute to access
    the property directly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a command that comes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    module: <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-DsObjectSid</samp>,
    which requires the full distinguished name of the object to query. The main advantage
    of this command is that it returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Sid</samp>
    class you can use in the access check without converting the value into the correct
    format. You can pass the returned SID to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Principal</samp> parameter.
    We’ll use it in the worked example at the end of the chapter.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing Additional
    Security Checks</samp>
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In most cases the access check process grants access to the directory based
    on the security descriptors assigned to objects, but there are several exceptions
    to this. For example, the directory supports privileges such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>,
    for changing the components of a security descriptor. Let’s discuss a few additional
    nonstandard checks.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Workstations to a Domain</samp>
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a default domain configuration, the *Authenticated Users* group is granted
    a special privilege on the domain controller called <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>.
    This privilege allows any domain user to join a computer to a domain, which, at
    a low level, means creating a computer object.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: When a user tries to create a computer object, the directory server checks whether
    the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    access for the target object. If not, it checks whether they have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>
    privilege. If they do, it allows the creation operation.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: However, in the latter case the server limits the attributes the user can set
    at creation time. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>
    privilege doesn’t allow a user to set an arbitrary <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSecurityDescriptor</samp>
    attribute; the object must use the default security descriptor. The values for
    attributes the user is allowed to set, like the username, must also match a fixed
    pattern, and the security descriptor must use the *Domain Admins* SID as its owner
    and group SIDs, limiting the user’s access to the object after its creation.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: An individual user can create only a fixed number of computer accounts. By default,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ms-DS-MachineAccountQuota</samp>
    attribute in the root of the directory sets this limit to 10\. To enforce this
    restriction during the creation of a new computer object, the server searches
    all existing computer objects and checks their <samp class="SANS_TheSansMonoCd_W5Regular_11">mS-DS-CreatorSID</samp>
    attribute, which stores the SID of the user who created the object. The server
    then calculates the number of computers the caller has already added, and if it’s
    over the quota, it rejects the request. However, if the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp>
    access, the quota doesn’t apply. [Listing 11-38](chapter11.xhtml#Lis11-38) shows
    how to query these values.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 11-38: Querying the SIDs used to enforce computer account creation
    quotas'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: You can create a new computer account using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-ADComputer</samp>
    command, specifying the required attributes. For example, [Listing 11-39](chapter11.xhtml#Lis11-39)
    creates the computer account *DEMOCOMP* with a known password.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 11-39: Creating a new computer account in the domain'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an account using the SAM remote service, as shown in [Listing
    11-40](chapter11.xhtml#Lis11-40).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 11-40: Creating a new computer in the domain via the SAM remote service'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Servers typically create an account in this way when you join a computer to
    a domain.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">User Delegation Rights</samp>
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In a default domain configuration, the *Administrators* group is granted a
    special privilege on the domain controller: the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp>
    privilege, which allows users to modify the Kerberos delegation settings. Specifically,
    it lets them do the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Set the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedForDelegation</samp>
    user account control flag.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the <samp class="SANS_TheSansMonoCd_W5Regular_11">TrustedToAuthenticateForDelegation</samp>
    user account control flag.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-AllowedToDelegateTo</samp>
    attribute of a user or computer object.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll discuss Kerberos delegation and the use of these settings in more detail
    in [Chapter 14](chapter14.xhtml).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Protected Objects</samp>
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The root domain of the directory shares its domain configuration and schema
    with the entire forest, meaning changes to a user in other domains will eventually
    be replicated in the root domain. But allowing a child domain to modify the domain
    configuration or schema is not a good idea, so the server implements a way of
    protecting objects from being directly modified, deleted, or moved.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Rather than storing this protection as an object attribute or an ACE, the server
    sets the resource manager control flag in the security descriptor to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    The technical specification refers to this bit flag as <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_PRIVATE_OBJECT</samp>.
    If the object’s security descriptor has this flag set and the object is in the
    schema’s or configuration’s naming context, then users cannot modify the object
    unless their owner SID belongs to the same domain as the domain controller on
    which the modification is being performed.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: For example, most objects in the configuration are owned by the *Enterprise
    Admins* group, a *Universal* group defined in the root domain. So, if an object
    is protected, only a domain controller in the root domain can modify it directly.
    [Listing 11-41](chapter11.xhtml#Lis11-41) contains a short script that searches
    for protected objects in the configuration naming context by checking the resource
    manager control flags. No other Windows feature uses these resource manager control
    flags, as far as I can tell.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 11-41: Finding protected configuration objects'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: In a default installation of an Active Directory server, [Listing 11-41](chapter11.xhtml#Lis11-41)
    should output no results, as the directory shouldn’t have any protected objects.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes our discussion of access checking, although we’ll come back
    to it in an expansive worked example at the end of the chapter. Next, we’ll cover
    two final Active Directory topics: how user and device claims are stored in the
    directory, and how group policies are configured.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Claims and Central Access Policies</samp>
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding chapters we discussed user and device claims, how tokens store
    them as security attributes, and how access checks use them. Claims are especially
    important for enabling central access policies, as we discussed in [Chapter 7](chapter7.xhtml).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The domain’s Active Directory server stores both claims and central access policies,
    and it can apply these whenever a user authenticates or a computer synchronizes
    its policy. [Listing 11-42](chapter11.xhtml#Lis11-42) shows how to query the Active
    Directory server for a claim using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADClaimType</samp>
    PowerShell command, which searches for objects of the schema class <samp class="SANS_TheSansMonoCd_W5Regular_11">msDS-ClaimType</samp>*.*
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 11-42: Displaying properties of the Country claim'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we find that an administrator configured the <samp class="SANS_TheSansMonoCd_W5Regular_11">Country</samp>
    claim when setting up the domain; it isn’t available by default. This claim represents
    the name of the user’s country.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: We show only a few of the relevant properties of the object. The first is the
    claim’s ID, used for the security attribute in the token; in this case, it’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ad://ext/country</samp>. We also show
    the value’s type, used to determine what security attribute values to add to the
    token; in this case, it’s a string.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The next property is the distinguished name of the schema attribute from which
    the value is derived. (It’s possible for a claim to be derived from other data,
    such as values on a user’s smart card, but sourcing the claim from a schema attribute
    is the simplest case.) When the user is authenticated, the token will construct
    the claim based on the attribute value from their user object; if the attribute
    isn’t set, the claim won’t be added to the token. An administrator can modify
    the directory schema to add new attributes from which to derive their own claims,
    such as a user’s security clearance.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we display the list of schema classes to which this claim applies.
    In this case, only the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    schema class appears in the listing. If this list contained the distinguished
    name of the <samp class="SANS_TheSansMonoCd_W5Regular_11">computer</samp> class,
    it would be a device claim, not a user claim, although claims can apply to both
    users and computers.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-43](chapter11.xhtml#Lis11-43) shows how to display the properties
    of a central access policy in the directory.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 11-43: Displaying properties of a central access policy'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Administrators deploy central access policies to a domain’s computers and servers
    based on the group policy configuration. This allows them to selectively deploy
    a policy to a specific subset of systems in the domain. The policy’s configuration
    is stored in the directory, however.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The policy consists of two components: the policy object itself, represented
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">msAuthz-CentralAccessPolicy</samp>
    schema class, and one or more central access rules, represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">msAuthz-CentralAccessRule</samp>
    schema class.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 11-43](chapter11.xhtml#Lis11-43), we first query for a specific
    central access policy named <samp class="SANS_TheSansMonoCd_W5Regular_11">Secure
    Room Policy</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADCentralAccessPolicy</samp>
    PowerShell command. From the policy we can extract the policy SID, which we use
    to apply the policy to a resource, as well as a list of the distinguished names
    of each member rule.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Get-ADCentralAccessPolicy</samp>
    command differs from the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Get-CentralAccessPolicy</samp>
    command I demonstrated in [Chapter 7](chapter7.xhtml). The former reads all policies
    from the Active Directory server, whereas the latter shows only the policies configured
    to be enabled on the local system.*'
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADCentralAccessRule</samp>
    command to get each of the policy rules. In this example, there is only one rule.
    We display its name, the resource condition used to determine when the rule is
    enabled, and the DACL, which determines the level of access a user will be granted
    on the resource for which the rule is applied. Refer to [Chapters 5](chapter5.xhtml)
    and [7](chapter7.xhtml) for more information about the implementation of central
    access policies.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Group Policies</samp>
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a stand-alone system, the local policy combines information from the LSA
    policy’s configuration with various registry settings that define what applications
    can do. In a domain network, an administrator can configure a policy for the entire
    network using *group policies*. Domain-joined computers download these policies
    on a regular basis (generally, every 90 minutes by default). Computers then merge
    these group policies with any existing local policy settings to define the computer’s
    overall policy.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-6](chapter11.xhtml#fig11-6) shows how a domain network configures
    group policies.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure11-6.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: The configuration
    of group policies</samp>'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: The root domain and any organizational unit object can contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp>
    attribute. An *organizational unit* is a directory container that represents some
    structure in an organization. For example, an administrator could create different
    organizational units for different offices, then apply different policies for
    computers within those organizational units.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute contains
    a list of the domain names belonging to the group policy objects applied to the
    organizational unit. The group policy objects themselves don’t contain the actual
    policy settings. Instead, the object contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">gPCFileSysPath</samp>
    attribute that represents a filepath to a policy configuration file, which contains
    the settings. This filepath typically points to a special network file share,
    *SYSVOL*, which contains the configuration files.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: What policies to apply depends on where the computer’s account object is stored
    in the directory. For example, in [Figure 11-6](chapter11.xhtml#fig11-6), the
    administrator has created the *Servers* organizational unit, then added the *CINNABAR*
    server account to that container. The organizational unit has the <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp>
    attribute, which links to the Servers Group Policy object.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: However, the organizational unit also lives in the root domain, which has its
    own <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute and
    assigned policy. When the *CINNABAR* server updates its group policy, it will
    discover all of these linked group policies in the parent directory hierarchy
    and use that information to download and apply the policies. The most specific
    policy takes precedence; for example, for *CINNABAR*, the Servers Group Policy
    would override conflicting settings in the Default Group Policy. The server will
    merge any settings that don’t conflict when creating the final policy.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 11-44](chapter11.xhtml#Lis11-44), we query for group policy objects
    on the Active Directory server.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 11-44: Finding group policy objects'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: First, we query for organizational unit objects in the directory using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-ADOrganizationalUnit</samp> command
    and request the <samp class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute
    ❶. We display the name and the list of group policy objects for each organizational
    unit.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: We could now take the group policy object’s distinguished names from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gpLink</samp> attribute and manually look
    up each one. Instead, let’s simply search for all objects of class <samp class="SANS_TheSansMonoCd_W5Regular_11">groupPolicyContainer</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> PowerShell
    command ❷. This shows us the name of each policy object, as well as the path to
    the real policy store on the *SYSVOL* file server.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: We can also list the contents of the policy directory on the file server ❸.
    Depending on how complex the policy is, the file share might contain many different
    files. A group policy can apply to a particular machine, as well as on a per-user
    basis, which is why there are separate *MACHINE* and *USER* directories.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: We won’t discuss the configuration of group policies any further, but I recommend
    inspecting the files contained in the file share during your security research.
    Group policies can contain a wealth of information related to the configuration
    of computers and users in the domain. Sometimes this policy configuration includes
    shared passwords for user accounts or private key material. Because any user on
    the network can access the *SYSVOL* share, an attacker could extract this information
    to gain additional privileges on the network.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: As a minor example of information leakage, you could determine which SIDs would
    be granted the two special privileges, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp>,
    on a domain controller. The group policy assigned to the domain controller typically
    stores this privilege assignment information in the *GptTmpl.inf* file, which
    any user in the domain can access. (The LSA domain policy remote service discussed
    in [Chapter 10](chapter10.xhtml) can also provide this information, but it requires
    administrator privileges.)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 11-44](chapter11.xhtml#Lis11-44), we retrieve the Default Domain
    Controllers Policy ❹, the only policy applied in our simple environment. We then
    extract the privileges from the file using a simple string selection. In this
    example, we find the default configuration: *Authenticated Users* is granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>, and
    *BUILTIN\Administrators* is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeEnableDelegationPrivilege</samp>
    ❺.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Example</samp>
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter’s single worked example, we’ll walk through a script that checks
    a user’s access to every object we can find in the local Active Directory server.
    This process is quite involved, so I’ve broken it into multiple sections.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Authorization
    Context</samp>
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve been using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    command to run the access check for a security descriptor. This command is fine
    for testing purposes, but it causes a subtle problem when used to check real-world
    security descriptors in the Active Directory server.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: The command uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAccessCheck</samp>
    system call, which uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to represent the user’s identity. However, the token’s group membership
    is based on the local system’s LSA user configuration, and the domain controller
    is unlikely to use the same groups. For example, many security descriptors in
    the directory grant full access to the *BUILTIN\Administrators* group, but these
    local administrators won’t necessarily also be administrators on the domain controller.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: We need a way of running an access check using the groups from the domain controller.
    One option is to run the access check on the domain controller itself. However,
    that only works if we have full control over the network, which is best avoided.
    A second option would be to manually create a token with the necessary groups,
    but this would still require elevated local privileges. Finally, we could use
    our own implementation of the access check, such as the one we built in [Chapter
    7](chapter7.xhtml), but this risks introducing incorrect behavior.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'We do have another option: Windows provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp>
    (authorization) API, which has a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZAccessCheck</samp>
    that we can use to perform an access check based on a constructed authorization
    context rather than a token. This API runs entirely in user mode, and the authorization
    context for a user can contain any groups the caller likes. If you don’t want
    to enable auditing, the APIs also work without any elevated privileges.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: A big advantage of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp>
    API over a custom access check implementation is that it shares code with the
    kernel’s own access check implementation, and therefore, it should be correct.
    As a bonus, it’s also the same API used by the Active Directory server to perform
    access checks, so its results should match the server’s when given the correct
    authorization context.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: We can build an authorization context for a domain user based only on information
    that we can extract from the domain without administrator privileges. [Listing
    11-45](chapter11.xhtml#Lis11-45) shows how to build the authorization context.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 11-45: Building an authorization context for the access check'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: In the directory, user and group objects have a <samp class="SANS_TheSansMonoCd_W5Regular_11">memberOf</samp>
    attribute that lists the distinguished names of the group objects that the user
    or group is a member of. We can use this list to recursively inspect the directory
    to find all groups. This is what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-Member</samp>
    function is doing ❶.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: We then define a function to get a list of member SIDs from a user object ❷.
    We need to add the root groups, which include the user’s primary group ❸ and groups
    referenced by the <samp class="SANS_TheSansMonoCd_W5Regular_11">memberOf</samp>
    attribute. We also need to add groups from SIDs that are outside the domain. These
    are stored as foreign security principals. In the example, we find the entry for
    *Authenticated Users*, a group that all users are a member of, and add its group
    memberships ❹. We now have a list of distinguished names for group objects, which
    we convert to a list of SIDs that we can add to the authorization context ❺.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Next, we build the authorization context itself. We start by querying for the
    user object ❻; if that fails, we check for a computer object and get the list
    of SIDs the account is a member of. Then we create an <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp>
    resource manager ❼, which (as its name suggests) is used to manage resources.
    For example, we can use it to cache access checks between contexts.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: We create the authorization context using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-AuthZContext</samp>
    command ❽. We need to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">SkipTokenGroups</samp>
    flag when creating the context so that only the user’s SID gets added to it. Otherwise,
    the context will contain the list of local groups, which defeats the purpose of
    gathering the groups on the domain controller.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-AuthZSid</samp>
    command to add the group SIDs to the context ❾, making sure to include the default
    *World* and *Authenticated Users* groups. Finally, we test the behavior of the
    functions for the user *alice* ❿, printing out the list of domain groups the user
    is a member of on the domain controller.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Gathering Object
    Information</samp>
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the authorization context in hand, we can begin the access check. We’ll
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AuthZGrantedAccess</samp>
    command, which works almost the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtGrantedAccess</samp>
    but relies on the context we’ve created. We’ll start by gathering information
    about the object we want to check. We need the following details:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The security descriptor of the object
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object SID, if present, for the principal SID
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All schema classes, including auxiliary and child classes
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowed schema attributes and associated property sets
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicable control and write-validated access rights
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 11-46](chapter11.xhtml#Lis11-46) implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ObjectInformation</samp>
    function, which gathers this information about an object based on its distinguished
    name.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 11-46: Implementing the Get-ObjectInformation function'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: We can test the function by passing it the distinguished name of the object
    for which we want the information, as shown in [Listing 11-47](chapter11.xhtml#Lis11-47).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 11-47: Gathering object information'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we request the information for the root domain object. You
    could cache most of the returned information about the schema class, as only the
    security descriptor and object SID typically change between objects. However,
    for simplicity, we’ll gather the information for every request.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Access
    Check</samp>
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now have everything we need to perform a maximum access check for an object.
    However, it’s not as simple as passing the security descriptor and the authorization
    context to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthZ</samp> access
    check API and calling it a day. We must separately handle each type of resource
    (such as classes, attributes, control access rights, and write-validated access
    rights) to make sure we capture the maximum allowed access.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-48](chapter11.xhtml#Lis11-48) contains the functions to run the
    access check process. For simplicity, we’ll focus on capturing access rights that
    could result in a modification of the object. However, you could easily modify
    the functions to capture read access, as well.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 11-48: Running the object access check'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a few helper functions. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-Access</samp>,
    runs the access check based on the authorization context, the security descriptor,
    the object type tree, and a desired access mask ❶. The access check returns a
    list of results for each checked object type. We’re interested only in the ones
    that succeeded, granting some access.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The next helper, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-PropertyObjTree</samp>,
    builds the object type tree used for checking property sets and attributes. The
    root of the tree is the object’s schema class identifier. From there, we first
    populate all available property sets ❷. We then add all remaining attributes that
    aren’t already in a property set by placing them into a separate dummy set ❸.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the multiple access check functions. First we get the
    information for an object based on its distinguished name ❹. We then get the maximum
    granted access for the object, with only the object schema class identifier as
    the object type. This gives us an idea of the basic rights the user will be granted,
    such as the ability to delete the object or modify its security descriptor.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Next, we build the tree for the property sets and attributes ❺ and run the access
    check using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-Access</samp>
    function. We’re interested only in results that grant <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProp</samp>
    access (most objects let any user read their attributes, so this information is
    less interesting). We split the access check results into writable property sets
    and writable individual attributes.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: We now focus on the child classes by building the object type tree from the
    schema class identifier ❻. Even though the directory server would check a single
    class at a time, we’ll perform all the checks in one go. We run two access checks,
    one for <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateChild</samp> access
    and one for <samp class="SANS_TheSansMonoCd_W5Regular_11">DeleteChild</samp> access.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that we use the dummy identifier as the root object type.
    If we instead used the schema class identifier for the object, the access granted
    to that class would propagate to all the children, potentially giving us the wrong
    result. Using an identifier that isn’t a real schema class should enable us to
    avoid this outcome.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: We run a similar access check for control access rights ❼ and write-validated
    access rights ❽, requesting <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Self</samp>, respectively. Finally,
    we package all the results into a custom object to return to the caller ❾.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-49](chapter11.xhtml#Lis11-49) demonstrates calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessCheckResult</samp>
    function for an Active Directory object.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 11-49: Testing the Get-AccessCheckResult function'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: In this example I’ve used the *GRAPHITE* computer object, but you can change
    this distinguished name to that of any object you want to check in the directory.
    We first need to get the authentication context for the user (here, *alice*) ❶.
    This user created the *GRAPHITE* object and therefore has some special access
    other users don’t have.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Next, we run the access check and display the results to the console ❷. You
    can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> property
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">ControlAccess</samp> has been
    granted generally. This means that *alice* can use any control access right unless
    it is explicitly denied through an ACE (a <samp class="SANS_TheSansMonoCd_W5Regular_11">Denied</samp>
    ACE also applies whenever a user or computer is marked as “User cannot change
    password,” blocking the <samp class="SANS_TheSansMonoCd_W5Regular_11">User-Change-Password</samp>
    control access right).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the user has some writable attributes and property sets but
    can’t create or delete any child objects. We additionally see the list of granted
    control and write-validated access rights. The control access rights are granted
    based on the top-level granted access, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Validated-SPN</samp>
    access right must have been granted explicitly.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Next, we repeat the check using the computer account ❸. If you compare the output
    with that for *alice*, you’ll notice several differences. First, the attributes
    and property sets that the user can write to have changed. More importantly, the
    computer account can create and delete any child object. The computer account
    also has fewer control access rights, but more write-validated access rights.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: You can enumerate all objects in the local Active Directory server using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ADObject</samp> command, then
    pass each distinguished name to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get
    -AccessCheckResult</samp> function to enumerate writable access across the entire
    directory.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our worked example. Hopefully, it has given you a better understanding
    of the nuts and bolts of the Active Directory server access check process. If
    you’d like to explore an existing implementation of the access check, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp> module provides
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-AccessibleDsObject</samp>
    command, which checks for read access in addition to write access and caches domain
    information to improve performance. You can use it to run a full recursive scan
    of the Active Directory server for the current user with the command shown in
    [Listing 11-50](chapter11.xhtml#Lis11-50).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 11-50: Performing an access check'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: The tabular output indicates whether the user can modify each type of object,
    such as by changing its attributes or creating a child object, and whether any
    control access rights have been granted to the user for that object.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We began this long chapter with a high-level overview of the information stored
    in Active Directory, such as the users and groups that are part of the domain,
    and we inspected the directory’s configuration from PowerShell using the Remote
    Server Administration Tools.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: We then dug into the Active Directory server at a lower level, starting with
    its schema, which defines the structure of the directory. The Active Directory
    server consists of hierarchical objects that can contain named values called attributes.
    Each object and attribute has a schema representation that defines what it can
    contain.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed how the Active Directory server secures objects through a
    mandatory security descriptor attribute. We looked at examples of querying the
    security descriptors of existing objects, as well as how to create security descriptors
    for new objects. We also saw how to assign security descriptors to existing objects.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Once we understood how an object’s security descriptor is configured, we explored
    how the directory server determines what access a user has to an object and its
    attributes. This access check process uses unique identifiers taken from the schema
    representation to build object type trees. These make the access check granular,
    able to grant a user access to only a specific attribute without requiring thousands
    of hardcoded checks.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'The Active Directory configuration also contains two special types of access
    rights: control access rights and write-validated access writes. These allow users
    to perform special operations on an object, such as changing a user’s password;
    they also prevent a user from modifying certain attribute values without confirmation
    from the server.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: The access check process contains a few exceptions too. For example, a user
    can be granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeMachineAccountPrivilege</samp>
    privilege, which allows them to create computer objects even if no directory object
    grants them the necessary permission. This allows users to join their computer
    to a domain without needing an administrator account. However, the directory server
    limits what the user can do with the new computer account, to mitigate the risk
    of compromise.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we went through a very quick overview of how a domain configures group
    policies through links to external network filesystems. We noted that this design
    could leak information about the configuration of users on a domain controller
    to users without administrative access.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to the topic of Active Directory when we discuss Kerberos authentication
    in [Chapter 14](chapter14.xhtml). Keep in mind that real-world deployments of
    Windows domains can be extremely complex, with many more security nuances than
    covered here. If you’d like to know more about how Active Directory functions
    and the many security edge cases it presents, consult Microsoft’s technical specification
    for Active Directory (*MS-ADTS*).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to delve into how interactive authentication
    is implemented on Windows. This authentication allows you to log in to a desktop
    and use the computer’s user interface.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
