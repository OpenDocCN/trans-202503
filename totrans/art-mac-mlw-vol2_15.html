<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">12</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">MIC AND WEBCAM MONITOR</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In “Shut Up and Dance,” a poignant episode of the TV show <i>Black Mirror</i>, hackers infect a young teenager’s computer with malware, spy on him through his webcam, then blackmail him into performing criminal acts. Coincidentally, shortly before the episode aired, I found myself reverse engineering an intriguing piece of Mac malware known as FruitFly that did something very similar.<sup><a role="doc-noteref" id="chapter12_1" href="#chapter12-1">1</a></sup></p>&#13;
<p class="TX">This persistent backdoor had many capabilities, including the ability to spy on its victims’ webcams by leveraging archaic QuickTime APIs. Although these APIs activated a camera’s LED indicator light, the malware had a rather insidious trick up its sleeve to attempt to remain undetected; it waited until the victim was inactive before triggering the spying logic. As a result, the victim likely didn’t notice that their webcam had been surreptitiously activated.</p>&#13;
<p class="TX">My investigation of the malware intersected with an FBI operation that led to the arrest of the alleged creator and revealed FruitFly’s insidious reach. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label="280"/>According to a Justice Department press release and indictment, the creator had installed FruitFly on thousands of computers over the course of 13 years.<sup><a role="doc-noteref" id="chapter12_2" href="#chapter12-2">2</a></sup></p>&#13;
<p class="TX">Apple eventually took steps to mitigate this threat, such as creating XProtect detection signatures. Even so, FruitFly remains a stark reminder of the very real dangers Mac users can face, despite Apple’s best efforts. FruitFly isn’t even the only Mac malware that spies on its victims through the webcam. Others include Mokes, Eleanor, and Crisis.</p>&#13;
<p class="TX">To address these threats, I released OverSight, a utility that monitors a Mac’s built-in mic and webcam, as well as any external connected audio and video devices, and alerts the user about any unauthorized access. In this chapter, I’ll explain how OverSight monitors these devices. I’ll also demonstrate how this tool ingests system log messages filtered via custom predicates to identify the process responsible for the device access.</p>&#13;
<p class="TX">You can find OverSight’s full source code in the Objective-See GitHub repository at <a href="https://github.com/objective-see/OverSight"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/OverSight</i></a>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-68"/><span class="SANS_Futura_Std_Bold_B_11">Tool Design</span></h3>&#13;
<p class="TNI">In a nutshell, OverSight alerts the user whenever their Mac’s mic or webcam activates and, most importantly, identifies the responsible process. Thus, whenever malware such as FruitFly attempts to access the camera or mic, this action will trigger an OverSight alert. While OverSight doesn’t attempt to classify the process as benign or malicious by design, it provides options for users to either allow or block the process or to exempt trusted processes (<a href="chapter12.xhtml#fig12-1">Figure 12-1</a>).</p>&#13;
<figure class="IMG"><img class="img6" id="fig12-1" src="../images/Figure12-1.jpg" alt="" width="902" height="413"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: OverSight provides the option to always allow a certain tool to access the mic and webcam.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The Allow (Once) option essentially takes no action, as OverSight receives notifications once the device activation has already occurred. However, the Allow (Always) option provides a simple way for users to create rules that keep trusted processes, such as FaceTime or Zoom, from generating alerts in the future. Finally, the Block option will terminate the process by sending it a kill signal (<span class="SANS_TheSansMonoCd_W5Regular_11">SIGKILL</span>).</p>&#13;
<p class="TX">Compared to tools such as BlockBlock, which contains various components and XPC communications, OverSight is relatively simple. It’s a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/>self-contained, stand-alone app able to perform its mic and webcam monitoring duties with standard user privileges. Let’s explore exactly how OverSight achieves this monitoring and, more importantly, identifies the responsible process. We’ll see that the former is easy thanks to various <span class="SANS_TheSansMonoCd_W5Regular_11">CoreAudio</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">CoreMediaIO</span> APIs, while the latter is a more challenging task.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-93"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mic and Camera Enumeration</span></h4>&#13;
<p class="TNI">To receive a notification that a process has activated or deactivated each connected mic or webcam, OverSight adds to each device what is known as a property listener for the “is running somewhere” property, <span class="SANS_TheSansMonoCd_W5Regular_11">kAudioDevicePropertyDeviceIsRunningSomewhere</span>. Because the APIs to add such a listener require a device ID, let’s first look at how we can enumerate mic and camera devices and then extract each device’s ID.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">AVFoundation</span><sup><a role="doc-noteref" id="chapter12_3" href="#chapter12-3">3</a></sup> class <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span><sup><a role="doc-noteref" id="chapter12_4" href="#chapter12-4">4</a></sup> exposes the class method <span class="SANS_TheSansMonoCd_W5Regular_11">devicesWithMediaType:</span>, which takes a media type as an argument (<a href="chapter12.xhtml#Lis12-1">Listing 12-1</a>). To enumerate audio devices such as mics, we use the constant <span class="SANS_TheSansMonoCd_W5Regular_11">AVMediaTypeAudio</span>. To enumerate video devices, we use <span class="SANS_TheSansMonoCd_W5Regular_11">AVMediaTypeVideo</span>. The method returns an array of <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span> objects that match the specified media type.</p>&#13;
<span id="Lis12-1"/>&#13;
<pre><code>#import &lt;AVFoundation/AVCaptureDevice.h&gt;&#13;
&#13;
for(AVCaptureDevice* audioDevice in [AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio]) {&#13;
    printf("audio device: %s\n", audioDevice.description.UTF8String);&#13;
&#13;
    // Add code here to add a property listener for each audio device.&#13;
}&#13;
for(AVCaptureDevice* videoDevice in [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]) {&#13;
    printf("video device: %s\n", videoDevice.description.UTF8String);&#13;
&#13;
    // Add code here to add a property listener for each video device.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Enumerating all audio and video devices</span></p>&#13;
<p class="TX">Compiling and running the code in <a href="chapter12.xhtml#Lis12-1">Listing 12-1</a> outputs the following on my system, which shows my Mac’s built-in microphone and webcam and also a pair of connected headphones:</p>&#13;
&#13;
<pre><code>Audio device: &lt;AVCaptureHALDevice: 0x11b36a480 [MacBook Pro&#13;
Microphone][BuiltInMicrophoneDevice]&gt;&#13;
&#13;
Audio device: &lt;AVCaptureHALDevice: 0x11a7e0440 [Bose QuietComfort 35]&#13;
[04-52-C7-77-0D-4E:input]&gt;&#13;
&#13;
Video device: &lt;AVCaptureDALDevice: 0x10dbb2c00 [FaceTime HD Camera]&#13;
[3F45E80A-0176-46F7-B185-BB9E2C0E82E3]&gt;&#13;
</code></pre>&#13;
<p class="TX">You can access the device’s name, such as FaceTime HD Camera, in the <span class="SANS_TheSansMonoCd_W5Regular_11">localizedName</span> property of each <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span> object. You may also want to make use of other object properties such as <span class="SANS_TheSansMonoCd_W5Regular_11">modelID</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">manufacturer</span>, and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/><span class="SANS_TheSansMonoCd_W5Regular_11">deviceType</span> to monitor only a subset of devices. For example, you might choose to monitor only devices built into your Mac.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-94"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Audio Monitoring</span></h4>&#13;
<p class="TNI">To set a property listener on each audio device so you can receive activation and deactivation notifications, OverSight implements a helper method named <span class="SANS_TheSansMonoCd_W5Regular_11">watchAudioDevice:</span> that takes a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span> object. For each device of type <span class="SANS_TheSansMonoCd_W5Regular_11">AVMediaTypeAudio</span>, OverSight invokes this helper.</p>&#13;
<p class="TX">At the core of this method is a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">AVFoundation AudioObjectAddPropertyListenerBlock</span> function, defined in the <span class="SANS_TheSansMonoCd_W5Regular_11">AVFoundation</span> <i>AudioHardware.h</i> header file as follows:</p>&#13;
&#13;
<pre><code>extern OSStatus AudioObjectAddPropertyListenerBlock(AudioObjectID inObjectID,&#13;
const AudioObjectPropertyAddress* inAddress, dispatch_queue_t __nullable inDispatchQueue,&#13;
AudioObjectPropertyListenerBlock inListener);&#13;
</code></pre>&#13;
<p class="TX">The first parameter is an ID for the audio object, for which we can register a property listener. Each <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span> object has an object property named <span class="SANS_TheSansMonoCd_W5Regular_11">connectionID</span> containing this required ID, but it isn’t publicly exposed. This means we can’t access it directly by writing code such as <span class="SANS_TheSansMonoCd_W5Regular_11">audioDevice.connectionID</span>. However, as noted elsewhere in this book, you can access private properties either by extending the object’s definition or by using the <span class="SANS_TheSansMonoCd_W5Regular_11">performSelector:withObject:</span> method.</p>&#13;
<p class="TX">OverSight uses the latter approach. You’ll find the logic to obtain the private device ID from an <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span> object in a helper method named <span class="SANS_TheSansMonoCd_W5Regular_11">getAVObjectID:</span> (<a href="chapter12.xhtml#Lis12-2">Listing 12-2</a>).</p>&#13;
<span id="Lis12-2"/>&#13;
<pre><code>-(UInt32)getAVObjectID:(AVCaptureDevice*)device {&#13;
    UInt32 objectID = 0;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> SEL methodSelector = NSSelectorFromString(@"connectionID");&#13;
    if(YES != [device respondsToSelector:methodSelector]) {&#13;
        goto bail;&#13;
    }&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> #pragma clang diagnostic push&#13;
    #pragma clang diagnostic ignored "-Wpointer-to-int-cast"&#13;
    #pragma clang diagnostic ignored "-Warc-performSelector-leaks"&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> objectID = (UInt32)[device performSelector:methodSelector withObject:nil];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> #pragma clang diagnostic pop&#13;
&#13;
bail:&#13;
    return objectID;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Obtaining a device’s private ID</span></p>&#13;
<p class="TX">In Objective-C, you can access object properties, including private ones, by invoking a method on the object that matches the property’s name. You can refer to these methods, or indeed any methods, by their names using <span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>selectors. Represented by the <span class="SANS_TheSansMonoCd_W5Regular_11">SEL</span> type, Objective-C selectors are really just pointers to strings that represent the name of the method. In <a href="chapter12.xhtml#Lis12-2">Listing 12-2</a>, you can see that the code first creates a selector for the <span class="SANS_TheSansMonoCd_W5Regular_11">connectionID</span> property using the <span class="SANS_TheSansMonoCd_W5Regular_11">NSSelectorFromString</span> API <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">connectionID</span> is a private property, nothing is stopping Apple from renaming it or removing it altogether. For that reason, the code invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">respondsToSelector:</span> method to make sure it’s still found on the <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span> object; if not, it bails. You should always make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">respondsToSelector:</span> method before attempting to access private properties or invoking private methods; otherwise, your program risks crashing with a <span class="SANS_TheSansMonoCd_W5Regular_11">doesNotRecognizeSelector</span> exception.<sup><a role="doc-noteref" id="chapter12_5" href="#chapter12-5">5</a></sup></p>&#13;
<p class="TX">Next, the code makes use of various <span class="SANS_TheSansMonoCd_W5Regular_11">#pragma</span> directives to save the diagnostic state and tell the compiler to ignore warnings that would otherwise be shown <span class="CodeAnnotation" aria-label="annotation2">❷</span>. These warnings get raised when we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">performSelector:withObject:</span> method <span class="CodeAnnotation" aria-label="annotation3">❸</span>, as the compiler has no way of knowing what object it returns and thus can’t know how to manage its memory.<sup><a role="doc-noteref" id="chapter12_6" href="#chapter12-6">6</a></sup> Because the <span class="SANS_TheSansMonoCd_W5Regular_11">connectionID</span> is just an unsigned 32-bit integer, it doesn’t need memory management.</p>&#13;
<p class="TX">Finally, the code accesses the <span class="SANS_TheSansMonoCd_W5Regular_11">connectionID</span> property via the selector created earlier. It accomplishes this in the aforementioned <span class="SANS_TheSansMonoCd_W5Regular_11">performSelector:withObject:</span> method, which allows you to invoke an arbitrary selector on an arbitrary object. With the device’s identifier in hand, the helper function restores the previous diagnostic state <span class="CodeAnnotation" aria-label="annotation4">❹</span> and returns the device’s ID to the caller.</p>&#13;
<p class="TX">The second argument to the <span class="SANS_TheSansMonoCd_W5Regular_11">AudioObjectAddPropertyListenerBlock</span> function is a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">AudioObjectPropertyAddress</span> structure, which identifies the property we’re interested in receiving a notification about. OverSight initializes the structure, as shown in <a href="chapter12.xhtml#Lis12-3">Listing 12-3</a>.</p>&#13;
<span id="Lis12-3"/>&#13;
<pre><code>AudioObjectPropertyAddress propertyStruct = {0};&#13;
propertyStruct.mSelector = kAudioDevicePropertyDeviceIsRunningSomewhere;&#13;
propertyStruct.mScope = kAudioObjectPropertyScopeGlobal;&#13;
propertyStruct.mElement = kAudioObjectPropertyElementMain;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Initializing an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">AudioObjectPropertyAddress</span> structure</span></p>&#13;
<p class="TX">We specify that we’re interested in the <span class="SANS_TheSansMonoCd_W5Regular_11">kAudioDevicePropertyDeviceIsRunningSomewhere</span> property, which relates to device activation and deactivation by any process on the system. The other elements of the structure indicate that the property we specified applies globally to the entire device, not just to a particular input or output. As a result, once we’ve added the property listener block, OverSight will receive notifications when the specified audio device’s run state changes.</p>&#13;
<p class="TX">The function’s third argument is a standard dispatch queue on which to execute the listener block (described next). We can either create a dedicated queue via the <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_queue_create</span> API or use <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_get_global_queue</span>, for example, with the <span class="SANS_TheSansMonoCd_W5Regular_11">DISPATCH_QUEUE_PRIORITY_DEFAULT</span> constant, to make use of an existing global queue. The final argument to the function is a block of type <span class="SANS_TheSansMonoCd_W5Regular_11">AudioObjectPropertyListenerBlock</span> that the Core Audio <span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/>framework will automatically invoke whenever the specified property changes on the specified device. Here is the listener block’s type definition, also found in <i>AudioHardware.h</i>:</p>&#13;
&#13;
<pre><code>typedef void (^AudioObjectPropertyListenerBlock)(UInt32 inNumberAddresses,&#13;
const AudioObjectPropertyAddress* inAddresses);&#13;
</code></pre>&#13;
<p class="TX">As multiple properties could change all at once if specified to receive notifications, the listener block gets invoked with an array of <span class="SANS_TheSansMonoCd_W5Regular_11">AudioObjectPropertyAddress</span> objects and the number of elements in this array. OverSight is only interested in a single property, so it ignores these parameters. For completeness, <a href="chapter12.xhtml#Lis12-4">Listing 12-4</a> shows OverSight’s <span class="SANS_TheSansMonoCd_W5Regular_11">watchAudioDevice:</span> method, which contains the core logic for specifying the property of interest, defining a listener block for notifications, and then adding it to the specified audio device.</p>&#13;
<span id="Lis12-4"/>&#13;
<pre><code>-(BOOL)watchAudioDevice:(AVCaptureDevice*)device {&#13;
    AudioObjectPropertyAddress propertyStruct = {0};&#13;
&#13;
    propertyStruct.mSelector = kAudioDevicePropertyDeviceIsRunningSomewhere;&#13;
    propertyStruct.mScope = kAudioObjectPropertyScopeGlobal;&#13;
    propertyStruct.mElement = kAudioObjectPropertyElementMain;&#13;
&#13;
    AudioObjectID deviceID = [self getAVObjectID:device];&#13;
&#13;
    AudioObjectPropertyListenerBlock listenerBlock =&#13;
    ^(UInt32 inNumberAddresses, const AudioObjectPropertyAddress* inAddresses) {&#13;
        // Code to handle device's run state changes removed for brevity&#13;
    };&#13;
&#13;
    AudioObjectAddPropertyListenerBlock(deviceID, &amp;propertyStruct, self.eventQueue,&#13;
    listenerBlock);&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Setting up a listener block for an audio device’s run state changes</span></p>&#13;
<p class="TX">The OverSight code in the listener block queries the device to determine its current state, as the notification tells us that the run state changed, but not to what state. If it finds the audio device turned on, OverSight consults its log monitor to determine the identity of the process responsible for accessing and activating the device. This step, discussed in more detail in <span class="Xref">“Responsible Process Identification” on <a href="chapter12.xhtml#pg_288">page 288</a></span>, is unfortunately necessary, because although Apple provides APIs to receive notifications about the state changes of an audio device, they provide no information about the responsible process. Lastly, the listener block alerts the user, providing information about the audio device, its state, and, in activation cases, the responsible process.</p>&#13;
<p class="TX">To determine whether the device was activated or deactivated, OverSight invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">AudioDeviceGetProperty</span> API within a helper method it names <span class="SANS_TheSansMonoCd_W5Regular_11">getMicState:</span> (<a href="chapter12.xhtml#Lis12-5">Listing 12-5</a>).</p>&#13;
<span id="Lis12-5"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/>-(UInt32)getMicState:(AVCaptureDevice*)device {&#13;
    UInt32 isRunning = 0;&#13;
    UInt32 propertySize = sizeof(isRunning);&#13;
&#13;
    AudioObjectID deviceID = [self getAVObjectID:device]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    AudioDeviceGetProperty(deviceID, 0, false, kAudioDevicePropertyDeviceIsRunningSomewhere,&#13;
    &amp;propertySize, &amp;isRunning); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    return isRunning;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: Determining the current state of an audio device</span></p>&#13;
<p class="TX">After declaring a few necessary variables, this method invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">getAVObjectID:</span> helper method discussed earlier to extract the private device ID from the <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span> object that triggered the notification <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It then passes this value, along with the <span class="SANS_TheSansMonoCd_W5Regular_11">kAudioDevicePropertyDeviceIsRunningSomewhere</span> constant, a size, and an out pointer for the result, to the <span class="SANS_TheSansMonoCd_W5Regular_11">AudioDeviceGetProperty</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. As a result of this call, we’ll know whether the notification we received in the callback block occurred due to a device activation or a less interesting deactivation.</p>&#13;
<p class="TX">Next, I’ll show you how to monitor video devices, such as the built-in webcam.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-95"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Camera Monitoring</span></h4>&#13;
<p class="TNI">To detect the run-state changes of video devices, which are of type <span class="SANS_TheSansMonoCd_W5Regular_11">AVMediaTypeVideo</span>, we can follow an approach similar to the audio device monitoring code. However, we’ll use APIs in the <i>CoreMediaIO</i> framework and register a property listener with the <span class="SANS_TheSansMonoCd_W5Regular_11">CMIOObjectAddPropertyListenerBlock</span> API.</p>&#13;
<p class="TX">OverSight monitors video devices for run-state changes in its <span class="SANS_TheSansMonoCd_W5Regular_11">watchVideoDevice:</span> method (<a href="chapter12.xhtml#Lis12-6">Listing 12-6</a>).</p>&#13;
<span id="Lis12-6"/>&#13;
<pre><code>-(BOOL)watchVideoDevice:(AVCaptureDevice*)device {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> CMIOObjectPropertyAddress propertyStruct = {0};&#13;
    propertyStruct.mScope = kAudioObjectPropertyScopeGlobal;&#13;
    propertyStruct.mElement = kAudioObjectPropertyElementMain;&#13;
    propertyStruct.mSelector = <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> kAudioDevicePropertyDeviceIsRunningSomewhere;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> CMIOObjectID deviceID = [self getAVObjectID:device];&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> CMIOObjectPropertyListenerBlock listenerBlock = ^(UInt32&#13;
    inNumberAddresses, const CMIOObjectPropertyAddress addresses[]) {&#13;
        // Code to handle device's run-state changes removed for brevity&#13;
    };&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> CMIOObjectAddPropertyListenerBlock(deviceID, &amp;propertyStruct,&#13;
    self.eventQueue, listenerBlock);&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-6: Setting up a listener block for a video device’s run-state changes</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/>As when monitoring audio devices, the code initializes a property structure to specify the property for which we’re interested in receiving notifications <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Notice that we use the same constants as for audio devices <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Apple’s header files don’t appear to define a video device–specific constant.</p>&#13;
<p class="TX">Next, we get the video device’s ID using OverSight’s <span class="SANS_TheSansMonoCd_W5Regular_11">getAVObjectID:</span> helper method <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We also implement a listener block of type <span class="SANS_TheSansMonoCd_W5Regular_11">CMIOObjectPropertyListenerBlock</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, then invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">CMIOObjectAddPropertyListenerBlock</span> function <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Once we’ve made this call, the <i>CoreMediaIO</i> framework will automatically invoke the listener block whenever a monitored video device activates or deactivates.</p>&#13;
<p class="TX">As with audio devices, we must manually query the device to learn whether it was activated or deactivated. You can find this logic in OverSight’s <span class="SANS_TheSansMonoCd_W5Regular_11">getCameraState:</span> method, which uses <span class="SANS_TheSansMonoCd_W5Regular_11">CoreMediaIO</span> APIs but is otherwise nearly identical to the <span class="SANS_TheSansMonoCd_W5Regular_11">getMicState:</span> method. As such, I won’t cover it here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-96"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Device Connections and Disconnections</span></h4>&#13;
<p class="TNI">So far, we’ve enumerated the audio and video devices currently connected to the system. For each device, we’ve added a property listener block that will receive a notification whenever the device activates or deactivates. This is all well and good, but we also need to handle cases in which currently monitored devices disconnect and reconnect, as well as situations in which a user plugs in a new device during the monitoring. For example, imagine that the user regularly connects or disconnects their laptop to an Apple Cinema display. These displays have built-in webcams that OverSight should monitor for unauthorized activations, so we must be able to handle devices that come and go.</p>&#13;
<p class="TX">Luckily, this is relatively straightforward thanks to the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">NSNotificationCenter</span> dispatch mechanism. Part of the <i>Foundation</i> framework, it allows clients to register themselves as observers for events of interest, then receive notifications whenever these events occur. To learn about audio or video device connections and disconnections, we’ll subscribe to the events <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDeviceWasConnectedNotification</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDeviceWasDisconnectedNotification</span>, which we can register with the code in <a href="chapter12.xhtml#Lis12-7">Listing 12-7</a>.</p>&#13;
<span id="Lis12-7"/>&#13;
<pre><code>[NSNotificationCenter.defaultCenter addObserver:self&#13;
selector:@selector(handleConnectedDeviceNotification:)&#13;
name:AVCaptureDeviceWasConnectedNotification object:nil];&#13;
&#13;
[NSNotificationCenter.defaultCenter addObserver:self&#13;
selector:@selector(handleDisconnectedDeviceNotification:)&#13;
name:AVCaptureDeviceWasDisconnectedNotification object:nil];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-7: Registering for device connections and disconnections</span></p>&#13;
<p class="TX">OverSight makes two calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">addObserver:selector:name:object:</span> method to register itself for the events of interest. Let’s take a closer look at the arguments passed to this method. First is the object, or <i>observer</i>, used to handle the notification. OverSight specifies <span class="SANS_TheSansMonoCd_W5Regular_11">self</span> to indicate that the object <span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>registering for the notifications is the same as the object that will handle them. As the second argument, OverSight uses the <span class="SANS_TheSansMonoCd_W5Regular_11">@selector</span> keyword to specify the name of the method to invoke on the observer object and handle the notification. For new device connections, we use an OverSight method named <span class="SANS_TheSansMonoCd_W5Regular_11">handleConnectedDeviceNotification:</span>, and for disconnections, we use <span class="SANS_TheSansMonoCd_W5Regular_11">handleDisconnectedDeviceNotification:</span>. We’ll look at these methods shortly.</p>&#13;
<p class="TX">Next, we specify the event of interest, such as device connection or disconnection. The constants for these events can be found in Apple’s <i>AVCaptureDevice.h</i> file. The last argument allows you to specify an additional object to deliver along with the notification. OverSight doesn’t make use of this and, as such, simply passes <span class="SANS_TheSansMonoCd_W5Regular_11">nil</span>.</p>&#13;
<p class="TX">Once OverSight has invoked <span class="SANS_TheSansMonoCd_W5Regular_11">addObserver:selector:name:object:</span> twice, whenever a device connects or disconnects, the notification center will invoke our corresponding observer method. The single parameter it passes to this method is a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">NSNotification</span> object. In the case of device connection or disconnection, this object contains a pointer to the <span class="SANS_TheSansMonoCd_W5Regular_11">AVCaptureDevice</span>.</p>&#13;
<p class="TX">Both notification observer methods first extract the device from the notification object and then determine its type (audio or video). Next, the code invokes OverSight’s device type–specific methods to either start or stop the monitoring, depending on whether the device was connected or disconnected.</p>&#13;
<p class="TX">As an example, <a href="chapter12.xhtml#Lis12-8">Listing 12-8</a> shows the implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">handleConnectedDeviceNotification:</span> method.</p>&#13;
<span id="Lis12-8"/>&#13;
<pre><code>-(void)handleConnectedDeviceNotification:(NSNotification *)notification {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> AVCaptureDevice* device = notification.object;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(YES == [device hasMediaType:AVMediaTypeAudio]) {&#13;
        [self watchAudioDevice:device];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if(YES == [device hasMediaType:AVMediaTypeVideo]) {&#13;
        [self watchVideoDevice:device];&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-8: When a new device connects, OverSight will begin monitoring it for run-state changes.</span></p>&#13;
<p class="TX">The method extracts the device that triggered the notification by accessing the <span class="SANS_TheSansMonoCd_W5Regular_11">object</span> property of the <span class="SANS_TheSansMonoCd_W5Regular_11">NSNotification</span> object passed into it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If this just-connected device is an audio device, the code invokes OverSight’s <span class="SANS_TheSansMonoCd_W5Regular_11">watchAudioDevice:</span> method, discussed earlier, to register a property listener block for state changes <span class="CodeAnnotation" aria-label="annotation2">❷</span>. For video devices, the code invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">watchVideoDevice:</span> method <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The method to handle device disconnections is identical, except it invokes the relevant OverSight <i>unwatch</i> methods, discussed in <span class="Xref">“Stopping” on <a href="chapter12.xhtml#pg_293">page 293</a></span>, which stop the monitoring of audio or video devices.</p>&#13;
<p class="TX">If we were solely interested in the fact that a video or audio device had activated or deactivated, we’d be done. However, these events have limited <span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>utility for malware detection if they don’t include the process responsible for triggering it. So, we have more work cut out for us.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-97"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Responsible Process Identification</span></h4>&#13;
<p class="TNI">Many legitimate activities could activate your mic or camera (for example, hopping on a conference call). A security tool must be able to identify the process accessing a device so it can ignore the ones it trusts and generate alerts for any it doesn’t recognize.</p>&#13;
<p class="TX">In previous chapters, I mentioned that Endpoint Security APIs can identify the process responsible for many events of interest. Unfortunately, Endpoint Security doesn’t report on mic and camera access yet (although I’ve begged Apple to add this feature many a time). While we’ve shown that the <span class="SANS_TheSansMonoCd_W5Regular_11">CoreAudio</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">CoreMediaIO</span> APIs can provide notifications about changes to a device’s run state, they don’t contain information about the responsible process.</p>&#13;
<p class="TX">Over the years, OverSight has taken various roundabout approaches to accurately identify the responsible process. Initially, it took advantage of the fact that frameworks within processes accessing the mic or webcam would send various Mach messages to the core macOS camera and audio assistant daemons. When it received a device run-state change notification, OverSight would enumerate any Mach message senders. It also supplemented this information by extracting responsible candidate processes from the I/O registry.<sup><a role="doc-noteref" id="chapter12_7" href="#chapter12-7">7</a></sup> Unfortunately, even this combined approach often yielded more than one candidate process. So, OverSight executed the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">sample</span> utility, which provided stack traces of the candidate processes. By examining these stack traces, it could identify whether a process was actively interacting with an audio or video device.</p>&#13;
<p class="TX">This approach wasn’t the most efficient (and the <span class="SANS_TheSansMonoCd_W5Regular_11">sample</span> utility is a touch invasive, as it briefly suspends the target process), but it could consistently identify the responsible process. At the time, OverSight was the only tool on the market able to provide this feature, making it a hit not only with users but also with commercial entities, who reverse engineered the tool to steal this capability for their own purposes—bugs and all! When I confronted the companies with proof of this transgression, all eventually admitted fault, apologized, and made amends.<sup><a role="doc-noteref" id="chapter12_8" href="#chapter12-8">8</a></sup></p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Interestingly, one of the developers who copied OverSight’s proprietary logic began working for Apple shortly thereafter. Coincidentally or not, more recent versions of macOS now alert you when a process initially attempts to access the mic or camera. As they say, imitation is the sincerest form of flattery.</i></p>&#13;
<p class="TX">As macOS changed, OverSight’s initial method of identifying the responsible process began to show its age. Luckily the introduction of the universal log provides a more efficient solution. In <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, I showed how to use the universal log’s private APIs and frameworks for ingesting streaming log messages, among other tasks. OverSight uses these same APIs and frameworks, coupled with custom filter predicates, to identify the process responsible for triggering any mic or camera state changes.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Messages in the log can change at any time. In this section, I focus on the messages present in macOS 14 and 15. While future versions of the operating system could replace these messages, you should be able to identify the new ones and swap them in.</i></p>&#13;
<p class="TX">The universal log contains many messages continually streaming from all corners of the system. To identify relevant messages (for example, those pertaining to processes accessing the camera), let’s start a log stream, then fire up an application such as FaceTime that makes use of the webcam:</p>&#13;
&#13;
<pre><code>% <b>log stream</b>&#13;
...&#13;
Default     0x0   367    0    com.apple.cmio.registerassistantservice:&#13;
[com.apple.cmio:] RegisterAssistantService.m:2343:-[RegisterAssistantServer&#13;
addRegisterExtensionConnection:]_block_invoke [{private}<b>901</b>][{private}0]&#13;
added &lt;private&gt; endpoint &lt;private&gt; camera &lt;private&gt;&#13;
&#13;
Default     0x0   <b>901</b>    0    avconferenced: (CoreMediaIO) [com.apple.cmio:]&#13;
CMIOHardware.cpp:747:CMIODeviceStartStream backtrace 0   CoreMediaIO&#13;
0x000000019b4c4040 CMIODeviceStartStream + 228    [0x19b45a000 + 434240]&#13;
</code></pre>&#13;
<p class="TX">In the stream, you can see messages related to the camera access. These contain references to a process with the PID of 901 or emanating from that process. In this example, that PID maps to the process <span class="SANS_TheSansMonoCd_W5Regular_11">avconferenced</span>, which accesses the webcam on behalf of FaceTime. Let’s try another application (say, Zoom) to see what shows up in the logs:</p>&#13;
&#13;
<pre><code>% <b>log stream</b>&#13;
...&#13;
Default     0x0   367    0    com.apple.cmio.registerassistantservice:&#13;
[com.apple.cmio:] RegisterAssistantService.m:2343:-[RegisterAssistantServer&#13;
addRegisterExtensionConnection:]_block_invoke [{private}<b>17873</b>][{private}0]&#13;
added &lt;private&gt; endpoint &lt;private&gt; camera &lt;private&gt;&#13;
&#13;
Default     0x0   <b>17873</b>  0    zoom.us: (CoreMediaIO) [com.apple.cmio:]&#13;
CMIOHardware.cpp:747:CMIODeviceStartStream backtrace 0   CoreMediaIO&#13;
0x00007ff8248a6287 CMIODeviceStartStream&#13;
+ 205    [0x7ff824840000 + 418439]CMIOHardware.cpp:747:CMIODeviceStartStream&#13;
backtrace 0   CoreMediaIO      0x00007ff8248a6287 CMIODeviceStartStream +&#13;
205    [0x7ff824840000 + 418439]&#13;
</code></pre>&#13;
<p class="TX">We receive the exact same messages, except this time they contain a process ID of 17873, which belongs to Zoom. You can perform a similar experiment to identify log messages containing information about processes accessing the mic.</p>&#13;
<p class="TX">To programmatically interact with the universal log, OverSight implements a custom class named <span class="SANS_TheSansMonoCd_W5Regular_11">LogMonitor</span>. The code in this class interfaces with APIs found within the private <i>LoggingSupport</i> framework. Since <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> covered this strategy, I won’t repeat the detail here. If you’re interested in the full code, take a look at the <i>LogMonitor.m</i> file in the <i>OverSight</i> project.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/>OverSight’s <span class="SANS_TheSansMonoCd_W5Regular_11">LogMonitor</span> class exposes a method with the definition shown in <a href="chapter12.xhtml#Lis12-9">Listing 12-9</a>.</p>&#13;
<span id="Lis12-9"/>&#13;
<pre><code>-(BOOL)start:(NSPredicate*)predicate level:(NSUInteger)level&#13;
callback:(void(^)(OSLogEvent*))callback;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-9: <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">LogMonitor</span>’s method to start a log stream filtered by a specified level and predicate</span></p>&#13;
<p class="TX">Given a predicate and a log level (such as default or debug), this method activates a streaming log session. It will pass log messages of type <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEvent</span> that match the specified predicate to the caller using the specified callback block.</p>&#13;
<p class="TX">OverSight uses a predicate that matches all log messages from either the core media I/O subsystem or the core media subsystem, because these subsystems generate the specific log messages that contain the PID of the responsible process (<a href="chapter12.xhtml#Lis12-10">Listing 12-10</a>).</p>&#13;
<span id="Lis12-10"/>&#13;
<pre><code>if(@available(macOS 14.0, *)) {&#13;
    [self.logMonitor start:[NSPredicate predicateWithFormat:@"subsystem=='com.apple.cmio' OR&#13;
    subsystem=='com.apple.coremedia'"] level:Log_Level_Default callback:^(OSLogEvent*&#13;
    logEvent) {&#13;
        // Code that processes cmio and coremedia log messages removed for brevity&#13;
    }];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: Filtering messages from the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">cmio</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">coremedia</span> subsystems</span></p>&#13;
<p class="TX">We intentionally leave these predicates broad to ensure that macOS performs the predicate matching within the system log daemon’s instance of the logging framework, rather than in the instance of the same framework loaded in OverSight. This avoids the significant overhead of copying and transmitting all system log messages between the two processes. The only downside to using a broader predicate is that OverSight must then filter out irrelevant messages. As neither of the two specified subsystems generates a significant number of log messages, however, this additional processing doesn’t introduce much overhead.</p>&#13;
<p class="TX">For each message from the subsystems, OverSight checks whether it contains the PID of the process that triggered the device’s run-state change. <a href="chapter12.xhtml#Lis12-11">Listing 12-11</a> shows the code to do this for camera events.</p>&#13;
<span id="Lis12-11"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> NSRegularExpression* cameraRegex = [NSRegularExpression&#13;
regularExpressionWithPattern:@"\\[\\{private\\}(\\d+)\\]"&#13;
options:0 error:nil];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if((YES == [logEvent.subsystem isEqual:@"com.apple.cmio"]) &amp;&amp;&#13;
    (YES == [logEvent.composedMessage hasSuffix:@"added &lt;private&gt;&#13;
    endpoint &lt;private&gt; camera &lt;private&gt;"])) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> NSTextCheckingResult* match = [cameraRegex firstMatchInString:logEvent.&#13;
    composedMessage options:0 range:NSMakeRange(0, logEvent.composedMessage.&#13;
    length)];&#13;
    if((nil == match) || (NSNotFound == match.range.location)) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/>        return;&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> NSInteger pid = [[logEvent.composedMessage substringWithRange:&#13;
    [match rangeAtIndex:1]] integerValue];&#13;
        self.lastCameraClient = pid;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-11: Parsing <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">cmio</span> messages to detect the responsible process</span></p>&#13;
<p class="TX">For camera events, we look for a message from the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.cmio</span> subsystem ending with <span class="SANS_TheSansMonoCd_W5Regular_11">added &lt;private&gt; endpoint &lt;private&gt; camera &lt;private&gt;</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. To extract the PID for this process, OverSight uses a regular expression, which it initializes prior to the message processing to avoid reinitialization <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then applies it to the candidate messages <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the regular expression doesn’t match, the callback exits with a return statement. Otherwise, it extracts the PID as an integer and saves it into an instance variable named <span class="SANS_TheSansMonoCd_W5Regular_11">lastCameraClient</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. OverSight references this variable when it receives a camera run-state change notification and builds an alert to show the user (<a href="chapter12.xhtml#Lis12-12">Listing 12-12</a>).</p>&#13;
<span id="Lis12-12"/>&#13;
<pre><code>Client* client = nil;&#13;
&#13;
if(0 != self.lastCameraClient) {&#13;
    client = [[Client alloc] init];&#13;
    client.pid = [NSNumber numberWithInteger:self.<b>lastCameraClient</b>];&#13;
    client.path = valueForStringItem(getProcessPath(client.pid.intValue));&#13;
    client.name = valueForStringItem(getProcessName(client.path));&#13;
}&#13;
Event* event = [[Event alloc] init:client device:device deviceType:&#13;
Device_Camera state:NSControlStateValueOn];&#13;
&#13;
[self handleEvent:event];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-12: Creating an object encapsulating the responsible process</span></p>&#13;
<p class="TX">For mic events, the approach is similar, except OverSight looks for messages from the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.coremedia</span> subsystem that start with <span class="SANS_TheSansMonoCd_W5Regular_11">-MXCoreSession- -[MXCoreSession beginInterruption]</span> and end with <span class="SANS_TheSansMonoCd_W5Regular_11">Recording = YES&gt; is going active</span>.</p>&#13;
<p class="TX">Using the universal log to identify processes responsible for mic and camera access has proven effective. The strategy’s main downside is that Apple occasionally changes or removes relevant log messages. For example, OverSight used different log messages to identify responsible processes in earlier versions of macOS, forcing me to update the tool when Apple removed them. You can see these updates by viewing the <i>AVMonitor.m</i> commit history in OverSight’s GitHub repository.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-69"/><span class="SANS_Futura_Std_Bold_B_11">Triggering Scripts</span></h3>&#13;
<p class="TNI">When I introduced OverSight in 2015, macOS provided no restrictions on mic or webcam access, meaning any malware that infected the system could trivially access either. Recent versions of macOS have addressed this <span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label="292"/>shortcoming by prompting the user the first time any application attempts to access these devices. Unfortunately, this approach relies on the operating system’s Transparency, Consent, and Control (TCC) mechanism, which hackers and malware often bypass, as noted in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
<p class="TX">Besides providing an additional layer of defense, OverSight offers features that users have leveraged creatively. For example, it provides a mechanism to take additional actions whenever a process accesses the mic or camera. If you open OverSight’s preferences and click the Action tab, you’ll see that you can specify a path to an external script or binary. If a user provides such an executable, OverSight will execute it upon each activation event.</p>&#13;
<p class="TX">To further enhance this capability, another option allows users to enable arguments to provide to the script, including the device, state, and responsible process. This makes OverSight relatively easy to integrate into other security tools (although users have frequently used the feature for more practical reasons, such as turning on an external light outside their home office whenever they activate their mic or camera).</p>&#13;
<p class="TX">OverSight’s code to execute external scripts or binaries is fairly straightforward, though the handling of arguments requires a few nuances. Over- Sight makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">NSUserDefaults</span> class to persistently store settings and preferences, including any user-specified script or binary. <a href="chapter12.xhtml#Lis12-13">Listing 12-13</a> shows the code that saves the path of an item when the user interacts with the Browse button.</p>&#13;
<span id="Lis12-13"/>&#13;
<pre><code>#define PREF_EXECUTE_PATH @"executePath"&#13;
#define PREF_EXECUTE_ACTION @"executeAction"&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> self.executePath.stringValue = panel.URL.path;&#13;
...&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> [NSUserDefaults.standardUserDefaults setBool:NSControlStateValueOn&#13;
forKey:PREF_EXECUTE_ACTION];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> [NSUserDefaults.standardUserDefaults setObject:self.executePath.stringValue&#13;
forKey:PREF_EXECUTE_PATH];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> [NSUserDefaults.standardUserDefaults synchronize];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-13: The <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NSUserDefaults</span> class used to store user preferences</span></p>&#13;
<p class="TX">We save the path of the item the user selected via the user interface <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then set a flag indicating that the user specified an action <span class="CodeAnnotation" aria-label="annotation2">❷</span> and save the item’s path <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Note that <span class="SANS_TheSansMonoCd_W5Regular_11">panel</span> is an <span class="SANS_TheSansMonoCd_W5Regular_11">NSOpenPanel</span> object containing the item the user selected. We set the flag using the <span class="SANS_TheSansMonoCd_W5Regular_11">setBool:</span> method of the <span class="SANS_TheSansMonoCd_W5Regular_11">NSUserDefaults</span>’s <span class="SANS_TheSansMonoCd_W5Regular_11">standardUserDefaults</span> object and set the item path using the <span class="SANS_TheSansMonoCd_W5Regular_11">setObject:</span> method. Finally, we synchronize to trigger a save <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">When the user specifies an external item to run, OverSight invokes a helper function named <span class="SANS_TheSansMonoCd_W5Regular_11">executeUserAction:</span> to run the item when a run-state change occurs to a mic or camera (<a href="chapter12.xhtml#Lis12-14">Listing 12-14</a>).</p>&#13;
<span id="Lis12-14"/>&#13;
<pre><code>#define SHELL @"/bin/bash"&#13;
#define PREF_EXECUTE_PATH @"executePath"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label="293"/>#define PREF_EXECUTE_ACTION_ARGS @"executeActionArgs"&#13;
&#13;
-(BOOL)executeUserAction:(Event*)event {&#13;
    NSMutableString* args = [NSMutableString string];&#13;
&#13;
    NSString* action = [NSUserDefaults.standardUserDefaults objectForKey:PREF_EXECUTE_PATH]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    if(YES == [NSUserDefaults.standardUserDefaults boolForKey:PREF_EXECUTE_ACTION_ARGS]) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        [args appendString:@"-device "]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        (Device_Camera == event.deviceType) ? [args appendString:@"camera"] :&#13;
        [args appendString:@"microphone"];&#13;
&#13;
        [args appendString:@" -process "];&#13;
        [args appendString:event.client.pid.stringValue];&#13;
        ...&#13;
    }&#13;
&#13;
  <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span> execTask(SHELL, @[@"-c", [NSString stringWithFormat:@"\"%@\" %@", action, args]], NO, NO);&#13;
    ...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-14: Executing a user-specified item with arguments</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">executeUserAction:</span> method first extracts the path of the user-specified item to execute from the saved preference <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then it checks whether the user has opted to pass arguments to the item <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If so, it dynamically builds a string containing the arguments, including the device that triggered the event and the responsible process <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, it executes the item and any arguments via the shell using the <span class="SANS_TheSansMonoCd_W5Regular_11">execTask</span> helper function <span class="CodeAnnotation" aria-label="annotation4">❹</span> discussed in previous chapters.</p>&#13;
<p class="TX">You might be wondering why OverSight executes the user-specified item via <i>/bin/bash</i> instead of just executing the item directly. Well, as the shell supports the execution of both scripts and stand-alone executables, this means users can specify either in OverSight.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-70"/><span class="SANS_Futura_Std_Bold_B_11">Stopping</span></h3>&#13;
<p class="TNI">It’s nice to provide users with an easy way to pause or fully disable a security tool they have installed. I’ll end this chapter by looking at OverSight’s code to stop the device and log monitor. I won’t cover the UI components and logic that expose this ability, but you can find them implemented as a macOS status bar menu in OverSight’s <i>Application/StatusBarItem.m</i> file.</p>&#13;
<p class="TX">When a user disables or stops OverSight, it first stops its log monitor by calling a <span class="SANS_TheSansMonoCd_W5Regular_11">stop</span> method that the custom log monitor exposes. This method ends the stream that ingests log messages by invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventLiveStream</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">invalidate</span> method. Once the log monitor has stopped, OverSight stops monitoring all audio and video devices in two loops (<a href="chapter12.xhtml#Lis12-15">Listing 12-15</a>).</p>&#13;
<span id="Lis12-15"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_294" aria-label="294"/>-(void)stop {&#13;
    ...&#13;
    for(AVCaptureDevice* audioDevice in [AVCaptureDevice devicesWithMediaType:AVMediaType&#13;
    Audio]) {&#13;
        [self unwatchAudioDevice:audioDevice];&#13;
    }&#13;
&#13;
    for(AVCaptureDevice* videoDevice in [AVCaptureDevice devicesWithMediaType:AVMediaType&#13;
    Video]) {&#13;
        [self unwatchVideoDevice:videoDevice];&#13;
    }&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-15: Ending the monitoring of all devices</span></p>&#13;
<p class="TX">One loop iterates over all audio devices, calling OverSight’s <span class="SANS_TheSansMonoCd_W5Regular_11">unwatchAudioDevice:</span> method, and a second loop iterates over video devices to invoke <span class="SANS_TheSansMonoCd_W5Regular_11">unwatchVideoDevice:</span> on them. The code in these methods, which remove listener blocks, is nearly identical to the <span class="SANS_TheSansMonoCd_W5Regular_11">watch*</span> monitoring methods covered earlier in this chapter, as you can see in this snippet from the <span class="SANS_TheSansMonoCd_W5Regular_11">unwatchAudioDevice</span> method (<a href="chapter12.xhtml#Lis12-16">Listing 12-16</a>).</p>&#13;
<span id="Lis12-16"/>&#13;
<pre><code>-(void)unwatchAudioDevice:(AVCaptureDevice*)device {&#13;
    ...&#13;
    AudioObjectID deviceID = [self getAVObjectID:device];&#13;
&#13;
    AudioObjectPropertyAddress propertyStruct = {0};&#13;
    propertyStruct.mScope = kAudioObjectPropertyScopeGlobal;&#13;
    propertyStruct.mElement = kAudioObjectPropertyElementMain;&#13;
    propertyStruct.mSelector = kAudioDevicePropertyDeviceIsRunningSomewhere;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> AudioObjectRemovePropertyListenerBlock(deviceID,&#13;
    &amp;propertyStruct, self.eventQueue, self.audioListeners[device.uniqueID]);&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-16: Removing a property listener block from an audio device</span></p>&#13;
<p class="TX">The code in this listing first gets the specified device’s ID and then initializes an <span class="SANS_TheSansMonoCd_W5Regular_11">AudioObjectPropertyAddress</span> that describes the previously added property listener <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It passes these, along with the listener block stored in the dictionary named <span class="SANS_TheSansMonoCd_W5Regular_11">audioListeners</span>, to the <span class="SANS_TheSansMonoCd_W5Regular_11">AudioObjectRemovePropertyListenerBlock</span> function. This fully removes the property listener block, ending OverSight’s monitoring of the device.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-71"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">Some of the most insidious threats targeting Mac users spy on their victim using the mic or camera. Instead of trying to detect specific malware specimens, OverSight counters all of them by taking the simple, albeit powerful, heuristic-based approach of detecting unauthorized mic and camera access.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/>In this chapter, I first showed you how OverSight leverages various <span class="SANS_TheSansMonoCd_W5Regular_11">CoreAudio</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">CoreMediaIO</span> APIs to register for notifications about mic and camera activations and deactivations. Then we explored the tool’s use of a custom log monitor to identify the process responsible for the event. Finally, I showed you how users can easily extend OverSight to execute external scripts or binaries as it detects events and the logic behind stopping OverSight.</p>&#13;
<p class="TX">In the next chapter, we’ll continue to explore the building of robust security tools by looking at how to create a DNS monitor capable of detecting and blocking unauthorized network access.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-1" href="#chapter12_1">  1</a></span>.  Selena Larson, “Mac Malware Caught Silently Spying on Computer Users,” CNN Money, July 24, 2017, <a href="https://money.cnn.com/2017/07/24/technology/mac-fruitfly-malware-spying/index.html"><i>https://money.cnn.com/2017/07/24/technology/mac-fruitfly-malware-spying/index.html</i><span class="endnoteentry_LinkURL_Italic">.</span></a></p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-2" href="#chapter12_2">  2</a></span>.  US Department of Justice, Office of Public Affairs, “Ohio Computer Programmer Indicted for Infecting Thousands of Computers with Malicious Software and Gaining Access to Victims’ Communications and Personal Information,” press release no. 18-21, January 10, 2018, <a href="https://www.justice.gov/opa/pr/ohio-computer-programmer-indicted-infecting-thousands-computers-malicious-software-and"><i>https://<wbr/>www<wbr/>.justice<wbr/>.gov<wbr/>/opa<wbr/>/pr<wbr/>/ohio<wbr/>-computer<wbr/>-programmer<wbr/>-indicted<wbr/>-infecting<wbr/>-thousands<wbr/>-computers<wbr/>-malicious<wbr/>-software<wbr/>-and</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-3" href="#chapter12_3">  3</a></span>.  “AVFoundation,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/avfoundation?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/avfoundation<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-4" href="#chapter12_4">  4</a></span>.  “AVCapture Device,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/avfoundation/avcapturedevice?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/avfoundation<wbr/>/avcapturedevice<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-5" href="#chapter12_5">  5</a></span>.  “doesNotRecognizeSelector:,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418637-doesnotrecognizeselector?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/objectivec<wbr/>/nsobject<wbr/>/1418637<wbr/>-doesnotrecognizeselector<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-6" href="#chapter12_6">  6</a></span>.  “performSelector May Cause a Leak Because Its Selector Is Unknown,” Stack Overflow, November 18, 2018, <a href="https://stackoverflow.com/a/20058585"><i>https://<wbr/>stackoverflow<wbr/>.com<wbr/>/a<wbr/>/20058585</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-7" href="#chapter12_7">  7</a></span>.  “The I/O Registry,” Apple Documentation Archive, last updated April 9, 2014, <a href="https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/TheRegistry/TheRegistry.html"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/library<wbr/>/archive<wbr/>/documentation<wbr/>/DeviceDrivers<wbr/>/Conceptual<wbr/>/IOKitFundamentals<wbr/>/TheRegistry<wbr/>/TheRegistry<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter12-8" href="#chapter12_8">  8</a></span>.  You can read more about this series of events in Corin Faife, “This Mac Hacker’s Code Is So Good, Corporations Keep Stealing It,” The Verge, August 11, 2022, <a href="https://www.theverge.com/2022/8/11/23301130/patrick-wardle-mac-code-corporations-stealing-black-hat"><i>https://<wbr/>www<wbr/>.theverge<wbr/>.com<wbr/>/2022<wbr/>/8<wbr/>/11<wbr/>/23301130<wbr/>/patrick<wbr/>-wardle<wbr/>-mac<wbr/>-code<wbr/>-corporations<wbr/>-stealing<wbr/>-black<wbr/>-hat</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>