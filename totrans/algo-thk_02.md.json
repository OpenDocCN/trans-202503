["```\ntypedef struct snowflake_node {\n  int snowflake[6];\n  struct snowflake_node *next;\n} snowflake_node;\n```", "```\ntypedef struct node {\n  int candy;\n  // ... what else should we add?\n} node;\n```", "```\ntypedef struct node {\n  int candy;\n  struct node *left, *right;\n} node;\n```", "```\n  node *four = malloc(sizeof(node));\n  four->candy = 4;\n  four->left = NULL;\n  four->right = NULL;\n```", "```\n  node *nine = malloc(sizeof(node));\n  nine->candy = 9;\n  nine->left = NULL;\n  nine->right = NULL;\n```", "```\n  node *B = malloc(sizeof(node));\n  B->left = four;\n  B->right = nine;\n```", "```\nnode *new_house(int candy) {\n  node *house = malloc(sizeof(node));\n  if (house == NULL) {\n    fprintf(stderr, \"malloc error\\n\");\n    exit(1);\n  }\n  house->candy = candy;\n  house->left = NULL;\n  house->right = NULL;\n  return house;\n}\n\nnode *new_nonhouse(node *left, node *right) {\n  node *nonhouse = malloc(sizeof(node));\n  if (nonhouse == NULL) {\n    fprintf(stderr, \"malloc error\\n\");\n    exit(1);\n  }\n  nonhouse->left = left;\n  nonhouse->right = right;\n  return nonhouse;\n}\n```", "```\n  node *four = new_house(4);\n  node *nine = new_house(9);\n  node *B = new_nonhouse(four, nine);\n  node *fifteen = new_house(15);\n  node *C = new_nonhouse(B, fifteen);\n```", "```\n  printf(\"%d\\n\", C->right->candy);\n```", "```\nprintf(\"%d\\n\", C->left->right->candy);\n```", "```\nprintf(\"%d\\n\", C->left->left);\n```", "```\nprintf(\"%d\\n\", C->candy);\n```", "```\nint tree_candy(node *tree)\n```", "```\n#define SIZE 255\n\ntypedef struct stack {\n  node * values[SIZE];\n  int highest_used;\n} stack;\n```", "```\nstack *new_stack(void) {\n❶ stack *s = malloc(sizeof(stack));\n   if (s == NULL) {\n     fprintf(stderr, \"malloc error\\n\");\n     exit(1);\n  }\n➋ s->highest_used = -1;\n   return s;\n}\n```", "```\nvoid push_stack(stack *s, node *value) {\n❶ s->highest_used++;\n➋ s->values[s->highest_used] = value;\n}\n\nnode * pop_stack(stack *s) {\n➌ node * ret = s->values[s->highest_used];\n➍ s->highest_used--;\n➎ return ret;\n}\n```", "```\nint is_empty_stack(stack *s) {\n  return s->highest_used == -1;\n}\n```", "```\nint main(void) {\n  stack *s;\n  s = new_stack();\n  node *n, *n1, *n2, *n3;\n  n1 = new_house(20);\n  n2 = new_house(30);\n  n3 = new_house(10);\n  push_stack(s, n1);\n  push_stack(s, n2);\n  push_stack(s, n3);\n  while (!is_empty_stack(s)) {\n    n = pop_stack(s);\n    printf(\"%d\\n\", n->candy);\n  }\n  return 0;\n}\n```", "```\nif (tree->left && tree->right) {\n  push_stack(s, tree->left);\n  tree = tree->right;\n}\n```", "```\ntotal = total + tree->candy;\n```", "```\ntotal = total + tree->candy;\nif (is_empty_stack(s))\n  tree = NULL;\nelse\n  tree = pop_stack(s);\n```", "```\nint tree_candy(node *tree) {\n  int total = 0;\n  stack *s = new_stack();\n  while (tree != NULL) {\n    if (tree->left && tree->right) {\n      push_stack(s, tree->left);\n      tree = tree->right;\n    } else {\n      total = total + tree->candy;\n      if (is_empty_stack(s))\n        tree = NULL;\n      else\n        tree = pop_stack(s);\n    }\n  }\n  return total;\n}\n```", "```\nint tree_candy(node *tree) {\n❶ if (!tree->left && !tree->right)\n     return tree->candy;\n➋ return tree_candy(tree->left) + tree_candy(tree->right);\n}\n```", "```\n// bugged!\nint tree_candy(node *tree) {\n  if (!tree->left && !tree->right)\n    return tree->candy;\n❶ tree_candy(tree->left) + tree_candy(tree->right);\n}\n```", "```\n// bugged!\nint tree_candy(node *tree) {\n  if (!tree->left && !tree->right)\n    return tree->candy;\n❶ return tree_candy(tree);\n}\n```", "```\nint tree_nodes(node *tree) {\n  if (!tree->left && !tree->right)\n    return 1;\n  return 1 + tree_nodes(tree->left) + tree_nodes(tree->right);\n}\n```", "```\nint tree_leaves(node *tree) {\n  if (!tree->left && !tree->right)\n    return 1;\n  return tree_leaves(tree->left) + tree_leaves(tree->right);\n}\n```", "```\nint tree_streets(node *tree) {\n  if (!tree->left && !tree->right)\n    return 0;\n  return tree_streets(tree->left) + tree_streets(tree->right) + 4;\n}\n```", "```\nint max(int v1, int v2) {\n  if (v1 > v2)\n    return v1;\n  else\n    return v2;\n}\n\nint tree_height(node *tree) {\n  if (!tree->left && !tree->right)\n    return 0;\n  return 1 + max(tree_height(tree->left), tree_height(tree->right));\n}\n```", "```\nvoid tree_solve(node *tree) {\n  int candy = tree_candy(tree);\n  int height = tree_height(tree);\n  int num_streets = tree_streets(tree) - height;\n  printf(\"%d %d\\n\", num_streets, candy);\n}\n```", "```\n4\n```", "```\n(4 9)\n```", "```\n((4 9) 15)\n```", "```\nnode *read_tree(char *line)\n```", "```\n node *tree;\n tree = malloc(sizeof(node));\n if (line[0] == '(') {\n❶ tree->left = read_tree(&line[1]);\n➋ tree->right = read_tree(???);\n   return tree;\n}\n```", "```\nnode *read_tree(char *line) {\n  int pos = 0;\n  return read_tree_helper(line, &pos);\n}\n```", "```\n node *tree;\n tree = malloc(sizeof(node));\n if (line[*pos] == '(') {\n❶ (*pos)++;\n   tree->left = read_tree_helper(line, pos);\n➋ (*pos)++;\n   tree->right = read_tree_helper(line, pos);\n➌ (*pos)++;\n   return tree;\n }\n```", "```\n#define SIZE 255\n\n// bugged!\nint main(void) {\n  char line[SIZE + 1];\n  int candy;\n  gets(line);\n  candy = line[0];\n  printf(\"%d\\n\", candy);\n  return 0;\n}\n```", "```\n#define SIZE 255\n\nint main(void) {\n  char line[SIZE + 1];\n  int candy;\n  gets(line);\n  candy = line[0] - '0';\n  printf(\"%d\\n\", candy);\n  return 0;\n}\n```", "```\n#define SIZE 255\n\nint main(void) {\n  char line[SIZE + 1];\n  int digit1, digit2, candy;\n  gets(line);\n  digit1 = line[0] - '0';\n  digit2 = line[1] - '0';\n  candy = 10 * digit1 + digit2;\n  printf(\"%d\\n\", candy);\n  return 0;\n}\n```", "```\n   --snip--\n   tree->left = NULL;\n   tree->right = NULL;\n❶ tree->candy = line[*pos] - '0';\n➋ (*pos)++;\n   if (line[*pos] != ')' && line[*pos] != ' ' &&\n     line[*pos] != '\\0') {\n  ➌ tree->candy = tree->candy * 10 + line[*pos] - '0';\n➍ (*pos)++;\n}\nreturn tree;\n```", "```\nnode *read_tree_helper(char *line, int *pos) {\n  node *tree;\n  tree = malloc(sizeof(node));\n  if (tree == NULL) {\n    fprintf(stderr, \"malloc error\\n\");\n    exit(1);\n  }\n  if (line[*pos] == '(') {\n    (*pos)++;\n    tree->left = read_tree_helper(line, pos);\n    (*pos)++;\n    tree->right = read_tree_helper(line, pos);\n    (*pos)++;\n    return tree;\n  } else {\n    tree->left = NULL;\n    tree->right = NULL;\n    tree->candy = line[*pos] - '0';\n    (*pos)++;\n    if (line[*pos] != ')' && line[*pos] != ' ' &&\n        line[*pos] != '\\0') {\n      tree->candy = tree->candy * 10 + line[*pos] - '0';\n      (*pos)++;\n    }\n    return tree;\n  }\n}\n```", "```\n#define SIZE 255\n#define TEST_CASES 5\n\nint main(void) {\n  int i;\n  char line[SIZE + 1];\n  node *tree;\n  for (i = 0; i < TEST_CASES; i++) {\n    gets(line);\n    tree = read_tree(line);\n    tree_solve(tree);\n  }\n  return 0;\n}\n```", "```\n1\n7 2\nLucas 1 Enzo\nZara 1 Amber\nSana 2 Gabriel Lucas\nEnzo 2 Min Becky\nKevin 2 Jad Cassie\nAmber 4 Vlad Sana Ashley Kevin\nVlad 1 Omar\n```", "```\nTree i:\n```", "```\nTree 1:\nAmber 5\nZara 4\nLucas 2\n```", "```\ntypedef struct node {\n  int num_children;\n  struct node **children;\n  char *name;\n  int score;\n} node;\n```", "```\nZara 1 Amber\nAmber 4 Vlad Sana Ashley Kevin\n```", "```\nAmber 4 Vlad Sana Ashley Kevin\nZara 1 Amber\n```", "```\nLucas 1 Enzo\nZara 1 Amber\n```", "```\nnode *find_node(node *nodes[], int num_nodes, char *name) {\n  int i;\n  for (i = 0; i < num_nodes; i++)\n    if (strcmp(nodes[i]->name, name) == 0)\n      return nodes[i];\n  return NULL;\n}\n```", "```\nvoid *malloc_safe(int size) {\n  char *mem = malloc(size);\n  if (mem == NULL) {\n    fprintf(stderr, \"malloc error\\n\");\n    exit(1);\n  }\n  return mem;\n}\n```", "```\nnode *new_node(char *name) {\n  node *n = malloc_safe(sizeof(node));\n  n->name = name;\n  n->num_children = 0;\n  return n;\n}\n```", "```\nLucas 1 Enzo\n```", "```\n#define MAX_NAME 10\n\nint read_tree(node *nodes[], int num_lines) {\n  node *parent_node, *child_node;\n  char *parent_name, *child_name;\n  int i, j, num_children;\n  int num_nodes = 0;\n❶ for (i = 0; i < num_lines; i++) {\n   parent_name = malloc_safe(MAX_NAME + 1);\n   scanf(\"%s\", parent_name);\n   scanf(\"%d\", &num_children);\n➋ parent_node = find_node(nodes, num_nodes, parent_name);\n   if (parent_node == NULL) {\n     parent_node = new_node(parent_name);\n     nodes[num_nodes] = parent_node;\n     num_nodes++;\n   }\n   else\n   ➌ free(parent_name);\n\n➍ parent_node->children = malloc_safe(sizeof(node) * num_children);\n➎ parent_node->num_children = num_children;\n   for (j = 0; j < num_children; j++) {\n     child_name = malloc_safe(MAX_NAME + 1);\n     scanf(\"%s\", child_name);\n     child_node = find_node(nodes, num_nodes, child_name);\n     if (child_node == NULL) {\n       child_node = new_node(child_name);\n       nodes[num_nodes] = child_node;\n       num_nodes++;\n     }\n     else\n       free(child_name);\n   ➏ parent_node->children[j] = child_node;\n    }\n  }\n  return num_nodes;\n}\n```", "```\nint score_one(node *n, int d)\n```", "```\nif (d == 1)\n  return n->num_children;\n```", "```\nint score_one(node *n, int d) {\n  int total, i;\n  if (d == 1)\n    return n->num_children;\n  total = 0;\n  for (i = 0; i < n->num_children; i++)\n    total = total + score_one(n->children[i], d - 1);\n  return total;\n}\n```", "```\nvoid score_all(node **nodes, int num_nodes, int d) {\n  int i;\n  for (i = 0; i < num_nodes; i++)\n    nodes[i]->score = score_one(nodes[i], d);\n}\n```", "```\nint compare(const void *v1, const void *v2) {\n  const node *n1 = *(const node **)v1;\n  const node *n2 = *(const node **)v2;\n  if (n1->score > n2->score)\n    return -1;\n  if (n1->score < n2->score)\n    return 1;\n  return strcmp(n1->name, n2->name);\n}\n```", "```\nvoid output_info(node *nodes[], int num_nodes) {\n  int i = 0;\n❶ while (i < 3 && i < num_nodes && nodes[i]->score > 0) {\n     printf(\"%s %d\\n\", nodes[i]->name, nodes[i]->score);\n     i++;\n  ➋ while (i < num_nodes && nodes[i]->score == nodes[i - 1]->score) {\n       printf(\"%s %d\\n\", nodes[i]->name, nodes[i]->score);\n       i++;\n    }\n  }\n}\n```", "```\n #define MAX_NODES 1000\n\n int main(void) {\n   int num_cases, case_num;\n   int n, d, num_nodes;\n❶ node **nodes = malloc_safe(sizeof(node) * MAX_NODES);\n   scanf(\"%d\", &num_cases);\n   for (case_num = 1; case_num <= num_cases; case_num++) {\n   ➋ printf(\"Tree %d:\\n\", case_num);\n      scanf(\"%d %d\", &n, &d);\n      num_nodes = read_tree(nodes, n);\n      score_all(nodes, num_nodes, d);\n      qsort(nodes, num_nodes, sizeof(node*), compare);\n      output_info(nodes, num_nodes);\n   ➌ if (case_num < num_cases)\n        printf(\"\\n\");\n   }\n   return 0;\n }\n```"]