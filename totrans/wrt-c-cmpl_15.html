<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_294" aria-label="294"/>&#13;
<figure class="co-img"><img id="fig-pg294" class="img60" src="../images/pg294.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-28.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch13">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">FLOATING-POINT NUMBERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">Your compiler now supports four different integer types, but it still doesn’t support non-integral values. It also doesn’t support values outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. In this chapter, you’ll address these shortcomings by implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type. This type uses a <i>floating-point</i> binary representation, which is totally different from the signed and unsigned integer representations we’ve seen so far. The C standard also defines two other floating-point types, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, but we won’t implement those in this book.</p>&#13;
<p class="TX">We’ll have two major tasks in this chapter. The first task is figuring out exactly what behavior we’re trying to implement. We can’t just check the C standard, because many aspects of floating-point behavior are implementation-defined. Instead, we’ll consult yet another standard, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_296" aria-label="296"/><i>IEEE 754</i>, to fill in most of the details that the C standard doesn’t specify. Our second major task is generating assembly code; we’ll need a whole new set of specialized assembly instructions and registers to operate on floating-point numbers.</p>&#13;
<p class="TX">We’ll start with a quick look at the IEEE 754 standard, which defines the binary format of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and some other aspects of floating-point behavior. Then, we’ll consider all the ways that rounding error can creep into floating-point operations and decide how our implementation will handle them. We won’t cover every aspect of floating-point arithmetic, but you can find links to the standard itself and more comprehensive explanations of IEEE 754, rounding error, and other aspects of floating-point behavior in <span class="Xref">“Additional Resources” on <a href="#pg_343">page 343</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-106"/><samp class="SANS_Futura_Std_Bold_B_11">IEEE 754, What Is It Good For?</samp></h3>&#13;
<p class="TNI">The IEEE 754 standard specifies several floating-point formats and how to work with them. It defines a set of floating-point operations, including basic arithmetic operations, conversions, and comparisons. It also defines several rounding modes, which control how the results of these operations are rounded, and various floating-point exceptions, like overflow and division by zero. The standard can be used as a specification for any system that implements floating-point arithmetic, whether that system is a processor or a high-level programming language. In processors, the required operations are typically implemented as machine instructions. In most programming languages, including C, some IEEE 754 operations are implemented as primitive operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, while others are implemented as standard library functions.</p>&#13;
<p class="TX">Virtually all modern programming languages represent floating-point numbers in IEEE 754 format (because they run on hardware using that format), but they have varying degrees of support for other aspects of the standard. For example, not all programming languages let you detect floating-point exceptions or use nondefault rounding modes.</p>&#13;
<p class="TX">In theory, you could implement C without using IEEE 754 at all; the C standard doesn’t dictate how to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and other floating-point types. However, the standard is designed to be compatible with IEEE 754. Annex F, an optional section of the C standard, specifies how to fully support IEEE 754 and explicitly binds C types, operations, and macros to their IEEE 754 equivalents. (Note that the standard refers to “IEC 60559,” which is just another name for IEEE 754.)</p>&#13;
<p class="TX">While the C standard doesn’t specify how to represent floating-point types, the System V x64 ABI does. Implementations that follow this ABI, including ours, must represent these types in IEEE 754 format. However, the ABI doesn’t deal with the other aspects of IEEE 754.</p>&#13;
<p class="TX">Most C implementations provide command line options to control exactly how strictly they conform to IEEE 754. Our compiler won’t provide these options; instead, it will roughly match the default behavior of Clang and GCC. This means we’ll implement mathematical floating-point <span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/>operations according to IEEE 754, and we’ll correctly handle most special values, but we’ll ignore floating-point exceptions and nondefault rounding modes.</p>&#13;
<p class="TX">In the next couple of sections, I’ll discuss the parts of IEEE 754 that you’ll need to know about as you work on your compiler. I won’t discuss operations that are implemented in the underlying hardware (like addition and subtraction) or in the C standard library (like square root and remainder). You don’t need to know the details of how those are specified, since they’re handled for you. But you <i>do</i> need to know a bit about the binary format of IEEE 754 numbers, so we’ll start with that.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-107"/><samp class="SANS_Futura_Std_Bold_B_11">The IEEE 754 Double-Precision Format</samp></h3>&#13;
<p class="TNI">The System V x64 ABI tells us to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> using the IEEE 754 <i>double-precision</i> format, which is 64 bits wide. <a href="#fig13-1">Figure 13-1</a> illustrates this format. (This figure is reproduced with slight modifications from <i><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Double<wbr/>-precision<wbr/>_floating<wbr/>-point<wbr/>_format</a></i>.)</p>&#13;
<figure class="IMG"><img id="fig13-1" class="img100" src="../images/fig13-1.jpg" alt="" width="1365" height="248"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The IEEE 754 double-precision floating-point format <a href="description-29.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The double-precision floating-point format has three fields: the sign bit, the exponent field, and the fraction field. These fields encode three values: the sign <i>s</i>, the exponent <i>e</i>, and the significand <i>f</i>, respectively. (Sometimes <i>f</i> is called the <i>mantissa</i> instead of the significand.) A number in this format has the value (–1)<i><sup>s</sup></i> × <i>f</i> × 2<i><sup>e</sup></i>, except for a few special cases that we’ll discuss shortly.</p>&#13;
<p class="TX">The significand <i>f</i> is a <i>binary fraction</i>, which is analogous to a decimal number. In decimal numbers, the digits to the left of the decimal point (the <i>integer part</i>) represent nonnegative powers of 10, and the digits to the right (the <i>fractional part</i>) represent negative powers of 10: 1/10, 1/100, and so on. Similarly, each bit in the integer part of a binary fraction represents a nonnegative power of 2, like 1, 2, 4, or 8, and each bit in the fractional part represents a negative power of 2, like 1/2, 1/4, or 1/8.</p>&#13;
<p class="TX">The integer part of <i>f</i> is always 1; the 52 bits of the fraction field encode only the fractional part. This means that the value of <i>f</i> is always greater than or equal to 1 and less than 2. For example, the fraction field</p>&#13;
<pre><code>1000000000000000000000000000000000000000000000000000</code></pre>&#13;
<p class="BodyContinued">indicates that the fractional part of <i>f</i> is 0.1, so the overall value of <i>f</i> is the binary fraction 1.1, which is 1.5 in decimal notation. The implied leading 1 lets the 52-bit fraction field represent binary fractions up to 53 bits long.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_298" aria-label="298"/>The value of <i>e</i> is between –1,022 and 1,023. The exponent field uses a <i>biased</i> encoding: we interpret the 11 bits in this field as an unsigned integer and then subtract 1,023 to get the value of <i>e</i>. For example, suppose this field has the following bits:</p>&#13;
<pre><code>00000000010</code></pre>&#13;
<p class="TX">Interpreted as an ordinary unsigned integer, these bits represent the number 2. The value of the exponent <i>e</i> is therefore 2 – 1,023, or –1,021. Setting the exponent field to all 1s or all 0s indicates one of the special values we’ll discuss in a moment.</p>&#13;
<p class="TX">Since <i>f</i> is always positive, the whole floating-point number will be negative if the sign bit is 1 and positive if it’s 0. Essentially, floating point lets us express numbers in scientific notation, but with powers of 2 instead of powers of 10.</p>&#13;
<p class="TX">The IEEE 754 standard also defines a few special values that are interpreted differently than ordinary floating-point numbers:</p>&#13;
<p class="ListHead"><b>Zero and negative zero</b></p>&#13;
<p class="ListPlain">If a floating-point number is all zeros, its value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>. If it’s all zeros except for its sign bit, its value is <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. This value compares equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> but follows the usual rules for determining the sign of arithmetic results. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0 * 0.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0 * -0.0</samp> both evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.</p>&#13;
<p class="ListHead"><b>Subnormal numbers</b></p>&#13;
<p class="ListPlain">As we just saw, most floating-point numbers have a significand between 1 and 2. We say that these numbers are <i>normalized</i>. The smallest magnitude a normalized <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent is 1 × 2<sup>–1,022</sup>, since the minimum exponent is –1,022. In a <i>subnormal</i> number, the significand is smaller than 1, which lets us represent values that are even closer to zero. An all-zero exponent field indicates that a number is subnormal, so its exponent is –1,022 and the integer part of its significand is 0 instead of 1. Subnormal numbers are much slower to work with in hardware than normalized numbers, so some C implementations let users disable them and round any subnormal results to zero.</p>&#13;
<p class="ListHead"><b>Infinity</b></p>&#13;
<p class="ListPlain">At the opposite end of the spectrum, the largest magnitude a normalized <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent is the largest possible value of the significand (just shy of 2) multiplied by 2<sup>1,023</sup>. Anything larger gets rounded to infinity. The result of dividing a nonzero number by zero is also infinity. The IEEE standard defines both positive and negative infinity; for example, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0 / 0.0</samp> evaluates to negative infinity. A number whose exponent is all 1s and whose fraction field is all 0s represents infinity. The sign bit indicates whether it’s negative or positive infinity.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_299" aria-label="299"/><b>NaN</b></p>&#13;
<p class="ListPlain">NaN is short for <i>not-a-number</i>. A few operations, including <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0 / 0.0</samp>, produce NaN. The IEEE 754 standard defines both <i>signaling NaNs</i>, which raise an exception if you try to use them, and <i>quiet NaNs</i>, which don’t. A number whose exponent is all 1s and whose fraction field is nonzero represents NaN.</p>&#13;
<p class="TX">We’ll support all of these values except for NaN. Quiet NaNs are an extra credit feature because handling them correctly in comparisons requires a bit of extra work. We can support negative zero, subnormal numbers, and infinity with no extra work on our part; the processor will deal with them for us.</p>&#13;
<p class="TX">Aside from the double-precision format, IEEE 754 defines a few other floating-point formats that we won’t use, including <i>single precision</i>, which corresponds to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, and <i>double extended precision</i>, which usually corresponds to <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>. These formats include the same three fields as double precision, use the same formula to determine a floating-point number’s value, and have the same special values; they just have different widths.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-108"/><samp class="SANS_Futura_Std_Bold_B_11">Rounding Behavior</samp></h3>&#13;
<p class="TNI">You can’t represent every real number exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. There are infinitely many real numbers, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has only 64 bits. We’re not particularly interested in <i>all</i> the real numbers; we care only about the numbers that show up in C programs. Unfortunately, a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can’t represent most of those exactly either, so we’ll need to round them. Let’s start by examining how IEEE 754 tells us to round real numbers to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Then, we’ll look at the three cases where we can encounter rounding error: when converting constants from decimal to binary floating point, performing type conversions, and performing arithmetic operations.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Modes</samp></h4>&#13;
<p class="TNI">IEEE 754 defines several different rounding modes, including rounding to nearest, rounding toward zero, rounding toward positive infinity, and rounding toward negative infinity. Modern processors support all four of these rounding modes and provide instructions to let programs change the current rounding mode. We’ll support only the default IEEE rounding mode, <i>round-to-nearest, ties-to-even</i> rounding. As the name suggests, in this mode the real value of a result is always rounded to the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. “Ties-to-even” means that if a result is exactly between two representable values, it’s rounded to the one whose least significant bit is 0. We’ll use this rounding mode when converting constants to floating point, when converting from integer types to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and in arithmetic operations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_300" aria-label="300"/>&#13;
<h4 class="H2" id="sec5"><span id="h2-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Constants</samp></h4>&#13;
<p class="TNI">C programmers generally write <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> constants in decimal. At compile time, we’ll convert constants from this decimal representation to a double-precision floating-point representation. This conversion is inexact, since most decimal constants can’t be represented exactly in binary floating point. For example, you can’t represent the decimal number 0.1 in binary floating point, because each bit in a binary fraction represents a power of 2, but you can’t add up powers of 2 and get 0.1. If the source code of a C program includes the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp>, the compiler will round this constant to the value in <a href="chapter13.xhtml#list13-1">Listing 13-1</a>, which is the nearest value we can represent as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<a id="list13-1"/>&#13;
<pre><code>0.1000000000000000055511151231257827021181583404541015625</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: The closest</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to 0.1, in decimal notation</samp></p>&#13;
<p class="TX">Unlike 0.1, this value can be represented exactly as a 53-bit binary fraction multiplied by a power of 2, as shown in <a href="chapter13.xhtml#list13-2">Listing 13-2</a>.</p>&#13;
<a id="list13-2"/>&#13;
<pre><code>1.100110011001100110011001100110011001100110011001101 * 2^-4</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: The closest</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to 0.1, represented as a binary fraction</samp></p>&#13;
<p class="TX">Representing 0.1 as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> is analogous to trying to write 1/3 in decimal notation; since you can’t break it down into powers of 10, you can’t write it out exactly using any number of decimal places. Instead, you have to round 1/3 to the nearest value you can represent in the space available. For example, a calculator that can display up to four digits would display 1/3 as <samp class="SANS_TheSansMonoCd_W5Regular_11">.3333</samp>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>IEEE 754 defines several</i> <span class="note_Italic">decimal floating-point</span> <i>formats, which can represent decimal constants without this sort of rounding error. These formats encode numbers as decimal significands multiplied by powers of 10. C23 includes new decimal floating-point types that correspond to these formats.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-98"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Type Conversions</samp></h4>&#13;
<p class="TNI">We may also need to round when we convert an integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. This issue arises because of the spacing between values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent. The gap between representable values grows larger as the magnitude of the values themselves increases. At a certain point, the gap becomes larger than 1, which means you can’t represent all integers in that range. To illustrate this problem, let’s imagine a decimal format with three digits of precision. This format can represent any integer smaller than 1,000; for example, we can write 992 and 993 as 9.92 × 10<sup>2</sup> and 9.93 × 10<sup>2</sup>. But it can’t represent every integer larger than 1,000. We can represent 1,000 exactly as 1.00 × 10<sup>3</sup>, but the next representable value is 1.01 × 10<sup>3</sup>, or 1,010; there’s a gap of 10. The gap increases to 100 once we hit 10,000, and continues to grow at larger magnitudes. We’ll encounter precisely the same issue <span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label="301"/>when converting from <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. A <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has 53 bits of precision, since the significand is a 53-bit binary fraction. A <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>, however, has 64 bits of precision. Suppose we need to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775803</samp> from a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The binary representation of this <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is:</p>&#13;
<pre><code>111111111111111111111111111111111111111111111111111111111111011</code></pre>&#13;
<p class="TX">That’s 63 bits, so it won’t fit in the significand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>! We’ll need to round it to the nearest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>, or 1 × 2<sup>63</sup>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-99"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Arithmetic Operations</samp></h4>&#13;
<p class="TNI">Finally, we may need to round the results of basic floating-point operations like addition, subtraction, and multiplication. Once again, this is due to the gaps between representable values. For example, let’s try computing 993 + 45 in the three-digit decimal format from the previous section. The correct result, 1,038, can’t be represented in only three digits; we’ll need to round it to 1.04 × 10<sup>3</sup>. Division can also produce values that aren’t representable at any precision, just like the result of 1 / 3 isn’t representable in any number of decimal digits. Thankfully, we can basically ignore this category of rounding error; the assembly instructions for floating-point arithmetic will round correctly without any extra effort on our part.</p>&#13;
<p class="TX">Now that you understand the basics of the IEEE 754 format and the rounding behavior you need to implement, you’re ready to get to work on the compiler. We’ll start with a change to the compiler driver.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-109"/><samp class="SANS_Futura_Std_Bold_B_11">Linking Shared Libraries</samp></h3>&#13;
<p class="TNI">This chapter’s test suite uses functions from <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp>, the standard math library. We’ll add a new command line option to the compiler driver that lets us link in shared libraries like <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp>. This option takes the form <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;lib&gt;</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;lib&gt;</samp> is the name of a library. You should pass this option through to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command to assemble and link the program, placing it after the names of any input assembly files in that command. For example, if your compiler is invoked with the command</p>&#13;
<pre><code><var>./YOUR_COMPILER</var> /path/to/program.c -lm</code></pre>&#13;
<p class="BodyContinued">it should assemble and link the program with the command:</p>&#13;
<pre><code>gcc /path/to/program.s -o /path/to/program -lm</code></pre>&#13;
<p class="TX">If you’re on macOS, you don’t need to add this new option, because the standard math library is linked in by default. You may want to add it anyway, though, since being able to link in shared libraries is generally useful.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label="302"/>&#13;
<h3 class="H1" id="sec9"><span id="h1-110"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll introduce two new tokens in this chapter:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> A keyword</p>&#13;
<p class="RunInParaL"><b>Floating-point constants</b> Constants that use scientific notation or contain a decimal point</p>&#13;
<p class="TX">You’ll also change how the lexer recognizes the end of a constant token; this will affect both the new floating-point constants and the integer constants you already support.</p>&#13;
<p class="TX">Let’s start by walking through the format of floating-point constants. Then, we’ll see how to recognize the end of a constant. Finally, we’ll define the new regular expressions for each constant token.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Recognizing Floating-Point Constant Tokens</samp></h4>&#13;
<p class="TNI">Numerals with decimal points, like <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.72</samp>, are valid tokens that represent floating-point numbers. We’ll call a sequence of digits that includes a decimal point a <i>fractional constant</i>. A fractional constant may include a decimal point with no digits after it. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp> is a valid fractional constant with the same value as <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.</p>&#13;
<p class="TX">A floating-point constant can also be written in scientific notation. A token that uses scientific notation consists of:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">A significand, which may be an integer or fractional constant</li>&#13;
<li class="ListBullet">An uppercase or lowercase <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp></li>&#13;
<li class="ListBullet">An exponent, which is an integer with an optional leading <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> sign</li>&#13;
</ul>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">100E10</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">.05e-2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp> are all valid floating-point constants. These constants are all in decimal, and their exponents are powers of 10. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp> is 5 × 10<sup>3</sup>, or 5,000. The C standard also defines hexadecimal floating-point constants, but we won’t implement them. There’s no constant for infinity. The <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp> header defines an <samp class="SANS_TheSansMonoCd_W5Regular_11">INFINITY</samp> macro, which is supposed to translate to the constant for positive infinity, but our compiler can’t include this header, since it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, and other language features we don’t support. Therefore, we won’t support this macro (or any other macros defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp>, for that matter).</p>&#13;
<p class="TX">It’s a bit tricky to write a regex that will match every floating-point constant, so let’s break it down into steps. The regex in <a href="chapter13.xhtml#list13-3">Listing 13-3</a> matches a fractional constant.</p>&#13;
<a id="list13-3"/>&#13;
<pre><code>[0-9]*\.[0-9]+|[0-9]+\.</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: The regex for a fractional constant</samp></p>&#13;
<p class="TX">The first part of this regex, <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]*\.[0-9]+</samp>, matches any constant with digits after the decimal point, like <samp class="SANS_TheSansMonoCd_W5Regular_11">.03</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>. The part after the <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> matches constants like <samp class="SANS_TheSansMonoCd_W5Regular_11">3.</samp> with nothing after the decimal point. <a href="chapter13.xhtml#list13-4">Listing 13-4</a> defines a similar regex to match the significand of a constant in scientific notation.</p>&#13;
<a id="list13-4"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label="303"/>[0-9]*\.[0-9]+|[0-9]+\.?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-4: The regex for the significand of a constant in scientific notation</samp></p>&#13;
<p class="TX">The only difference from <a href="chapter13.xhtml#list13-3">Listing 13-3</a> is that the trailing decimal point in the second clause is optional, so it matches both integers and fractional constants with trailing decimal points.</p>&#13;
<p class="TX">We’ll use the regex in <a href="chapter13.xhtml#list13-5">Listing 13-5</a> to match the exponent part of a floating-point constant.</p>&#13;
<a id="list13-5"/>&#13;
<pre><code>[Ee][+-]?[0-9]+</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-5: The regex for the exponent of a constant in scientific notation</samp></p>&#13;
<p class="TX">This regex includes the case-insensitive <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> that marks the start of the exponent, an optional sign, and the integer value of the exponent. To match any floating-point constant, we’ll assemble one giant regex of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;<a href="chapter13.xhtml#list13-4">Listing 13-4</a>&gt; &lt;<a href="chapter13.xhtml#list13-5">Listing 13-5</a>&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;<a href="chapter13.xhtml#list13-3">Listing 13-3</a>&gt;</samp>, which gives us <a href="chapter13.xhtml#list13-6">Listing 13-6</a>.</p>&#13;
<a id="list13-6"/>&#13;
<pre><code>([0-9]*\.[0-9]+|[0-9]+\.?)[Ee][+-]?[0-9]+|[0-9]*\.[0-9]+|[0-9]+\.</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-6: The regex to match every part of a floating-point constant</samp></p>&#13;
<p class="TX">In other words, a floating-point constant is either a significand followed by an exponent, or a fractional constant. <a href="chapter13.xhtml#list13-6">Listing 13-6</a> isn’t quite complete, though: we need one more component to match the boundary between the end of this token and the start of the next one.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Matching the End of a Constant</samp></h4>&#13;
<p class="TNI">Until now, we’ve required constants to end at word boundaries. Given the string <samp class="SANS_TheSansMonoCd_W5Regular_11">123foo</samp>, for example, we wouldn’t accept the substring <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp> as a constant. Now we’ll add another requirement: a constant token can’t be immediately followed by a period. This means, for example, that the lexer will recognize the start of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">123L;</samp> as a long integer constant token, <samp class="SANS_TheSansMonoCd_W5Regular_11">123L</samp>, but it will reject the string <samp class="SANS_TheSansMonoCd_W5Regular_11">123L.bar;</samp> as malformed. Along the same lines, the lexer will accept the string <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0+x</samp> but reject <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0.+x</samp>, and it will accept <samp class="SANS_TheSansMonoCd_W5Regular_11">1.}</samp> but reject <samp class="SANS_TheSansMonoCd_W5Regular_11">1..}</samp>. Note that the last character in a floating-point constant like <samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp> can be a period, but the first character <i>after</i> the constant cannot.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you’re curious about where in the C standard this requirement comes from, see the definition of preprocessing numbers in section 6.4.8, the list of translation phases in section 5.1.1.2, and the discussion of tokens and preprocessing tokens in section 6.4, paragraph 3. These sections describe a multiphase process for dividing a source file into preprocessing tokens and then converting them into tokens. We don’t follow this process, but we define each token in a way that produces the same results for the subset of C that we support.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label="304"/>To enforce this new requirement, we’ll end the regular expression for each constant token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> character class instead of the special word boundary character <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> character class matches any single character except for a word character (a letter, digit, or underscore) or a period. This single non-word, non-period character marks the end of the constant but isn’t part of the constant itself, so we’ll define a capture group within each regex to match the actual constant.</p>&#13;
<p class="TX">For example, our old regular expression for a signed integer constant was <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp>. Our new regular expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[\w.]</samp>. This regex matches the entire string <samp class="SANS_TheSansMonoCd_W5Regular_11">100;</samp>, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> at the end. The capture group <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)</samp> matches just the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, not the final <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> character. Whenever your lexer recognizes a constant, it should consume only the constant itself from the input, not the character that immediately follows it.</p>&#13;
<p class="TX">In <a href="chapter13.xhtml#list13-7">Listing 13-7</a>, we finally define the whole regular expression to recognize a floating-point constant.</p>&#13;
<a id="list13-7"/>&#13;
<pre><code>(([0-9]*\.[0-9]+|[0-9]+\.?)[Ee][+-]?[0-9]+|[0-9]*\.[0-9]+|[0-9]+\.)[^\w.]</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-7: The complete regex to recognize a floating-point constant</samp></p>&#13;
<p class="TX">This is just the regular expression we defined in <a href="chapter13.xhtml#list13-6">Listing 13-6</a>, wrapped in parentheses to form a capture group and followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> character class.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#tab13-1">Table 13-1</a> defines the new regular expressions for all of our constant tokens.</p>&#13;
<p class="TT" id="tab13-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Regular Expressions for Constant Tokens</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Token</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Regular expression</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed integer constant</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[^\w.]</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned integer constant</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[uU])[^\w.]</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed long integer constant</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[lL])[^\w.]</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned long integer constant</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+([lL][uU]|[uU][lL]))[^\w.]</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Floating-point constant</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">(([0-9]*\.[0-9]+|[0-9]+\.?)[Ee][+-]?[0-9]+|[0-9]*\.[0-9]+|[0-9]+\.)[^\w.]</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Go ahead and add the new floating-point constant token and update how you recognize the constant tokens from earlier chapters. Don’t forget to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> keyword too!</p>&#13;
<aside class="box" aria-label="box-28"><p class="BoxTitle" id="box-28"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label="305"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 13 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your lexer should fail on the test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_13/invalid_lex</samp><samp class="SANS_Futura_Std_Book_11">, which include malformed floating-point and integer constants. It should successfully process all the other test programs for this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-111"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">The changes to the parser are pretty limited. <a href="chapter13.xhtml#list13-8">Listing 13-8</a> gives the updated AST, which includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type and floating-point constants.</p>&#13;
<a id="list13-8"/>&#13;
<pre><code>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, exp? init,&#13;
                        type var_type, storage_class?)&#13;
function_declaration = (identifier name, identifier* params, block? body,&#13;
                        type fun_type, storage_class?)&#13;
type = Int | Long | UInt | ULong | <b>Double |</b> FunType(type* params, type ret)&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(const)&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, exp)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label="306"/>const = ConstInt(int) | ConstLong(int)&#13;
      | ConstUInt(int) | ConstULong(int)&#13;
<b>      | ConstDouble(double)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-8: The abstract syntax tree with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">type and floating-point constants</samp></p>&#13;
<p class="TX">Your AST should represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> constants using the double-precision floating-point format, since that’s how they’ll be represented at runtime. You’ll need to look up which type in your implementation language uses this format. If you use a representation with less precision than <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, you might not be able to represent the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to every constant in the source code, so you’ll end up with incorrectly rounded constants in the compiled program.</p>&#13;
<p class="TX">Surprisingly, storing constants with <i>more</i> precision than <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can also cause problems. Storing a floating-point number in a higher-precision format and then rounding to a lower-precision format can produce a different result than rounding exactly once. This phenomenon is called <i>double rounding error</i>. (The word <i>double</i> here refers to rounding twice, not to the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type.) We’ll explore double rounding error in more depth during assembly generation.</p>&#13;
<p class="TX">After updating the AST, we’ll make the corresponding changes to the grammar. <a href="chapter13.xhtml#list13-9">Listing 13-9</a> shows the complete grammar with these changes bolded.</p>&#13;
<a id="list13-9"/>&#13;
<pre><code>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;identifier&gt; ["=" &lt;exp&gt;] ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;identifier&gt; "(" &lt;param-list&gt; ")" (&lt;block&gt; | ";")&#13;
&lt;param-list&gt; ::= "void"&#13;
               | {&lt;type-specifier&gt;}+ &lt;identifier&gt; {"," {&lt;type-specifier&gt;}+ &lt;identifier&gt;}&#13;
&lt;type-specifier&gt; ::= "int" | "long" | "unsigned" | "signed" <b>| "double"</b>&#13;
&lt;specifier&gt; ::= &lt;type-specifier&gt; | "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;const&gt; | &lt;identifier&gt;&#13;
           | "(" {&lt;type-specifier&gt;}+ ")" &lt;factor&gt;&#13;
           | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
           | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_307" aria-label="307"/>&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt; | &lt;uint&gt; | &lt;ulong&gt; <b>| &lt;double&gt;</b>&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? An int token ?&#13;
&lt;long&gt; ::= ? An int or long token ?&#13;
&lt;uint&gt; ::= ? An unsigned int token ?&#13;
&lt;ulong&gt; ::= ? An unsigned int or unsigned long token ?&#13;
<b>&lt;double&gt; ::= ? A floating-point constant token ?</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-9: The grammar with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">type specifier and floating-point constants</samp></p>&#13;
<p class="TX">In the last two chapters, we had to deal with the many different ways to specify integer types. Luckily, there’s only one way to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type: with the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> keyword. <a href="chapter13.xhtml#list13-10">Listing 13-10</a> demonstrates how to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> when we process a list of type specifiers.</p>&#13;
<a id="list13-10"/>&#13;
<pre><code>parse_type(specifier_list):&#13;
    if specifier_list == ["double"]:&#13;
        return Double&#13;
    if specifier_list contains "double":&#13;
        fail("Can't combine 'double' with other type specifiers")&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-10: Determining a type from a list of type specifiers</samp></p>&#13;
<p class="TX">Either <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> should be the only specifier in the list, or it shouldn’t appear at all; it can’t be combined with <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>, or any other type specifier we’ve introduced so far. (It can, however, appear alongside storage-class specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>.)</p>&#13;
<p class="TX">Next, we’ll convert floating-point constant tokens to constants in the AST. We saw earlier that most decimal constants can’t be represented exactly in binary floating point, so we’ll need to round them. According to the C standard, the rounding direction here is implementation-defined and doesn’t necessarily need to match the runtime rounding mode. We’ll use round-to-nearest mode here, like we do everywhere else. Your implementation language’s built-in string-to-floating point conversion utilities should handle this correctly.</p>&#13;
<p class="TX">When we parse integer constants, we need to ensure that they’re within the range the type can hold. Floating-point constants, however, can’t go out of range. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> supports positive and negative infinity, its range includes all real numbers. So, our parser shouldn’t run into any errors when parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> constants.</p>&#13;
<aside class="box" aria-label="box-29"><p class="BoxTitle" id="box-29"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 13 --stage parse</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_308" aria-label="308"/>&#13;
<h3 class="H1" id="sec13"><span id="h1-112"/><samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp></h3>&#13;
<p class="TNI">We’ll make a handful of changes to account for <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> in the type checker. First, we’ll make sure to annotate <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> constants with the correct type. Then, we’ll update how we find the common real type of two values. The rule here is simple: if either value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, the common real type is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. <a href="chapter13.xhtml#list13-11">Listing 13-11</a> shows how to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp> helper function to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<a id="list13-11"/>&#13;
<pre><code>get_common_type(type1, type2):&#13;
    if type1 == type2:&#13;
        return type1&#13;
<b>    if type1 == Double or type2 == Double:</b>&#13;
<b>        return Double</b>&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-11: Finding the common real type of two values</samp></p>&#13;
<p class="TX">We also need to detect a couple of new type errors. The bitwise complement operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>, and the remainder operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>, accept only integer operands. We’ll validate that both of these operators are used correctly in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>. <a href="chapter13.xhtml#list13-12">Listing 13-12</a> demonstrates how to type check the <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator.</p>&#13;
<a id="list13-12"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | Unary(Complement, inner) -&gt;&#13;
        typed_inner = typecheck_exp(inner, symbols)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if get_type(typed_inner) == Double:&#13;
            fail("Can't take the bitwise complement of a double")&#13;
        unary_exp = Unary(Complement, typed_inner)&#13;
        return set_type(unary_exp, get_type(typed_inner))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-12: Type checking a bitwise complement expression</samp></p>&#13;
<p class="TX">First, we type check the operand. Then, we validate that the operand is an integer <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Finally, we annotate the expression with the type of its result. Only the validation step differs from earlier chapters. We can handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> operator in a similar way.</p>&#13;
<p class="TX">To wrap up the changes to the type checker, we’ll deal with static variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We’ll add a new kind of initializer for these variables:</p>&#13;
<pre><code>static_init = IntInit(int) | LongInit(int) | UIntInit(int) | ULongInit(int)&#13;
<b>            | DoubleInit(double)</b></code></pre>&#13;
<p class="TX">As usual, we’ll convert each initializer to the type of the variable it initializes, using the same rules that we’d apply at runtime. The C standard requires us to truncate toward zero when we convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an integer type. For example, we would convert <samp class="SANS_TheSansMonoCd_W5Regular_11">2.8</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. If the truncated value is out of range of the resulting integer type, the result is undefined, so you can handle it however you like. The cleanest option here is to just throw an error.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_309" aria-label="309"/>When we convert an integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll preserve its value if it can be represented exactly. Otherwise, we’ll round to the nearest representable value. You should be able to use your implementation language’s built-in type conversion utilities to cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to integer types and vice versa.</p>&#13;
<aside class="box" aria-label="box-30"><p class="BoxTitle" id="box-30"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your type checker, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 13 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The type checker should succeed on every valid test case and fail on the tests in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_13/invalid_types</samp><samp class="SANS_Futura_Std_Book_11">, which exercise the new type errors in this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h1-113"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">In TACKY, we’ll add a few new instructions to handle conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and integer types. <a href="chapter13.xhtml#list13-13">Listing 13-13</a> gives the updated TACKY IR.</p>&#13;
<a id="list13-13"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, static_init init)&#13;
instruction = Return(val)&#13;
            | SignExtend(val src, val dst)&#13;
            | Truncate(val src, val dst)&#13;
            | ZeroExtend(val src, val dst)&#13;
            <b>| DoubleToInt(val src, val dst)</b>&#13;
            <b>| DoubleToUInt(val src, val dst)</b>&#13;
            <b>| IntToDouble(val src, val dst)</b>&#13;
            <b>| UIntToDouble(val src, val dst)</b>&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val dst)&#13;
val = Constant(const) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-13: Adding conversions between</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and the integer types to TACKY</samp></p>&#13;
<p class="TX"><a href="chapter13.xhtml#list13-13">Listing 13-13</a> introduces four new instructions to convert between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and the signed and unsigned integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_310" aria-label="310"/><samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>. We don’t have different instructions for integer operands of different sizes; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp> can cast to either <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.</p>&#13;
<p class="TX">To update the TACKY generation pass, just emit the appropriate cast instruction when you encounter a cast to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<aside class="box" aria-label="box-31"><p class="BoxTitle" id="box-31"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 13 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-114"/><samp class="SANS_Futura_Std_Bold_B_11">Floating-Point Operations in Assembly</samp></h3>&#13;
<p class="TNI">Before we get to work on the assembly generation pass, we need to understand how to work with floating-point numbers in assembly. Because floating-point numbers use a completely different binary representation from signed and unsigned integers, we can’t operate on them with our existing arithmetic instructions. Instead, we’ll use a set of specialized instructions called the <i>Streaming SIMD Extension (SSE)</i> instructions. This instruction set includes operations on both floating-point values and integers. It gets its name because it includes <i>single-instruction, multiple data (SIMD)</i> instructions, which perform the same operation on a vector of several values simultaneously (or two vectors of values, in the case of binary operations). For example, a SIMD addition instruction whose operands were the two-element vectors <samp class="SANS_TheSansMonoCd_W5Regular_11">[1.0, 2.0]</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">[4.0, 6.0]</samp> would add their corresponding elements together to produce the vector <samp class="SANS_TheSansMonoCd_W5Regular_11">[5.0, 8.0]</samp>.</p>&#13;
<p class="TX">The term <i>SSE</i> is a bit misleading because only some SSE instructions perform SIMD operations on vectors. Others operate on single values. When we talk about SSE instructions, we refer to vectors as <i>packed</i> operands and single values as <i>scalar</i> operands. SSE instructions that use these different types of operands are called packed and scalar instructions, respectively. Our implementation will primarily use scalar instructions, although we will need one packed instruction.</p>&#13;
<p class="TX">The SSE instructions were first introduced as an extension to the x86 instruction set; they weren’t available on every x86 processor. Over time, new groups of SSE instructions were added, creatively named SSE2, SSE3, and SSE4. The SSE and SSE2 instructions were eventually incorporated into the core x64 instruction set, so they’re available on every x64 processor. The first generation of floating-point SSE instructions support only single-precision operands, which correspond to the <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type in C. SSE2 added support for double-precision operands. Since we’re working with double-precision operands, we’ll use only SSE2 instructions in this chapter.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_311" aria-label="311"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The x64 and x86 instruction sets include an older set of floating-point instructions that were first introduced with the Intel 8087</i> <span class="Roman">floating-point unit (FPU)</span><i>, a separate processor that handled floating-point math. These are called</i> <span class="Roman">x87</span> <i>or</i> <span class="Roman">FPU instructions</span> <i>(sometimes simply referred to as</i> <span class="Roman">floating-point instructions</span><i>). Be aware that some resources on floating-point assembly—particularly older ones—discuss only x87 instructions and don’t mention SSE.</i></p>&#13;
<p class="TX">Just like the general-purpose instructions we’re already familiar with, SSE instructions take suffixes that describe their operands. Instructions that operate on scalar double-precision values use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp> suffix. Instructions that take packed double-precision values use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pd</samp> suffix. Scalar and packed single-precision instructions use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ps</samp> suffixes, respectively. The next few sections introduce the SSE instructions we’ll need in this chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-102"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with SSE Instructions</samp></h4>&#13;
<p class="TNI">There are two major differences between SSE instructions and the assembly instructions you learned about in earlier chapters. The first difference is that SSE instructions use a separate set of registers, called the <i>XMM registers</i>. There are 16 XMM registers: XMM0, XMM1, and so on, up to XMM15. Each XMM register is 128 bits wide, but we’ll use only their lower 64 bits. From now on, I’ll refer to all the non-XMM registers we know and love—like RAX, RSP, and so on—as <i>general-purpose registers</i>. SSE instructions can’t use general-purpose registers, and non-SSE instructions can’t use XMM registers. Both SSE and non-SSE instructions can refer to values in memory.</p>&#13;
<p class="TX">The second difference is that SSE instructions can’t use immediate operands. If we need to use a constant in an SSE instruction, we’ll define that constant in read-only memory. Then, the constant can be accessed with RIP-relative addressing, just like a static variable. <a href="chapter13.xhtml#list13-14">Listing 13-14</a>, which computes <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> in assembly, illustrates how to use XMM registers and floating-point constants.</p>&#13;
<a id="list13-14"/>&#13;
<pre><code>    .section .rodata&#13;
    .align 8&#13;
.L_one:&#13;
    .double 1.0&#13;
    .text&#13;
one_plus_one:&#13;
    movsd   .L_one(%rip), %xmm0&#13;
    addsd   .L_one(%rip), %xmm0&#13;
    <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-14: Computing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">1.0 + 1.0</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">At the start of the listing, we define the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>. We can define and initialize this constant in almost exactly the same way as a static variable. The key difference is that we don’t store this value in the data or BSS section; instead, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.section .rodata</samp> directive to put it in the <i>read-only data section</i>. As the name suggests, the program can read data from this section at runtime, but it can’t write to it.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_312" aria-label="312"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">.section</samp> directive can be used to write to any section. We use it here because we don’t have a dedicated directive to write to the read-only data section the way we have dedicated <samp class="SANS_TheSansMonoCd_W5Regular_11">.text</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> directives. In the object file format used on macOS, there are several read-only data sections; we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> directive to write to the section that holds 8-byte constants.</p>&#13;
<p class="TX">We use a new directive, <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp>, to initialize the memory address labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> to the floating-point value <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> prefix on <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> makes it a local label. As you learned back in <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>, local labels are omitted from the symbol table in the object file. Compilers typically use local labels for floating-point constants.</p>&#13;
<p class="TX">Now that we’ve defined the data we need, let’s look at the start of the assembly function <samp class="SANS_TheSansMonoCd_W5Regular_11">one_plus_one</samp>. The first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd .L_one(%rip), %xmm0</samp>, copies the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> from memory into the XMM0 register. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> instruction, like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, copies data from one location to another. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> to copy values between XMM registers or between an XMM register and memory.</p>&#13;
<p class="TX">Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> instruction to perform floating-point addition. This instruction adds the constant at <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> to the value in XMM0 and stores the result in XMM0. The source of <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> can be an XMM register or a memory address, and the destination must be an XMM register.</p>&#13;
<p class="TX">Now that you have a high-level understanding of how to use SSE instructions, let’s dig into some specifics. First, we’ll explore how the System V calling convention handles floating-point function arguments and return values. Then, we’ll cover how individual floating-point operations, like arithmetic, comparisons, and type conversions, are implemented in assembly. At that point, you’ll finally be ready to add floating-point support to the backend of your compiler.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-103"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Floating-Point Values in the System V Calling Convention</samp></h4>&#13;
<p class="TNI">In <span class="Xref-1"><a href="chapter9.xhtml">Chapter 9</a></span>, you learned that a function’s first six arguments are passed in general-purpose registers and its return value is passed in the EAX register (or RAX, depending on its size). The System V calling convention handles floating-point values a bit differently: they’re passed and returned in XMM registers instead of general-purpose registers.</p>&#13;
<p class="TX">A function’s first eight floating-point arguments are passed in registers XMM0 through XMM7. Any remaining floating-point arguments are pushed onto the stack in reverse order, just like integer arguments are. Floating-point return values are passed in XMM0 instead of RAX. Consider the function in <a href="chapter13.xhtml#list13-15">Listing 13-15</a>, which takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> arguments, adds them together, and returns the result.</p>&#13;
<a id="list13-15"/>&#13;
<pre><code>double add_double(double a, double b) {&#13;
    return a + b;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-15: Adding two</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">arguments</samp></p>&#13;
<p class="TX">We could compile this function to the assembly in <a href="chapter13.xhtml#list13-16">Listing 13-16</a>.</p>&#13;
<a id="list13-16"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_313" aria-label="313"/>    .text&#13;
    .globl add_double&#13;
add_double:&#13;
    addsd   %xmm1, %xmm0&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-16:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">add_double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">According to the System V calling convention, arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> will be passed in registers XMM0 and XMM1, respectively. The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd %xmm1, %xmm0</samp> will therefore add <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, storing the result in XMM0. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values are returned in XMM0, the function’s return value is already in the right place after that <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> instruction. At that point, the function can return immediately. This code is more optimized than what your compiler will produce—it doesn’t include the function prologue and epilogue, for example—but it illustrates how to pass and return floating-point values in assembly.</p>&#13;
<p class="TX">When a function contains a mix of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and integer arguments, it can be tricky to push the right arguments onto the stack in the right order. First, we need to assign parameters to registers, working from the start of the parameter list. Then, we push any remaining unassigned parameters of any type onto the stack, starting from the back of the parameter list. Let’s work through a few examples, starting with <a href="chapter13.xhtml#list13-17">Listing 13-17</a>.</p>&#13;
<a id="list13-17"/>&#13;
<pre><code>long pass_parameters_1(int i1, double d1, int i2, unsigned long i3,&#13;
                       double d2, double d3, long i4, int i5);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-17: A function declaration with integer and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">parameters</samp></p>&#13;
<p class="TX">This example is simple because we can pass every parameter in a register. <a href="#fig13-2">Figure 13-2</a> illustrates the state of each register just before invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">pass_parameters_1</samp> with a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction.</p>&#13;
<figure class="IMG"><img id="fig13-2" class="img50" src="../images/fig13-2.jpg" alt="" width="625" height="768"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: Passing parameters from <a href="chapter13.xhtml#list13-17">Listing 13-17</a> <a href="description-30.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_314" aria-label="314"/><a href="chapter13.xhtml#list13-18">Listing 13-18</a> shows a slightly more complicated example, where some integer parameters are passed on the stack.</p>&#13;
<a id="list13-18"/>&#13;
<pre><code>double pass_parameters_2(double d1, long i1, long i2, double d2, int i3,&#13;
                         long i4, long i5, double d3, long i6, long i7,&#13;
                         int i8, double d4);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-18: A function declaration with even more parameters</samp></p>&#13;
<p class="TX">We’ll pass every <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> argument to this function in a register, but the last two integer arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>, will be passed on the stack. <a href="#fig13-3">Figure 13-3</a> illustrates where each parameter will wind up.</p>&#13;
<figure class="IMG"><img id="fig13-3" class="img100" src="../images/fig13-3.jpg" alt="" width="1359" height="772"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: Passing parameters from <a href="chapter13.xhtml#list13-18">Listing 13-18</a> <a href="description-31.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After we’ve assigned parameters to all the available registers, only <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp> are left. Because we push stack arguments in reverse order, we push <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp> first, then <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>, which puts <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> at the top of the stack.</p>&#13;
<p class="TX">Finally, let’s consider the function declared in <a href="chapter13.xhtml#list13-19">Listing 13-19</a>. When we call this function, we’ll need to pass both <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and integer parameters on the stack.</p>&#13;
<a id="list13-19"/>&#13;
<pre><code>int pass_parameters_3(double d1, double d2, int i1, double d3, double d4,&#13;
                      double d5, double d6, unsigned int i2, long i3,&#13;
                      double d7, double d8, unsigned long i4, double d9,&#13;
                      int i5, double d10, int i6, int i7, double d11,&#13;
                      int i8, int i9);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-19: A function declaration with way too many parameters</samp></p>&#13;
<p class="TX">We’ll pass the first six integer parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">i1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">i6</samp>, and the first eight <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">d1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">d8</samp>, in registers. <a href="chapter13.xhtml#list13-20">Listing 13-20</a> reproduces <a href="chapter13.xhtml#list13-19">Listing 13-19</a>, with parameters that will be passed on the stack bolded.</p>&#13;
<a id="list13-20"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_315" aria-label="315"/>int pass_parameters_3(double d1, double d2, int i1, double d3, double d4,&#13;
                      double d5, double d6, unsigned int i2, long i3,&#13;
                      double d7, double d8, unsigned long i4, <b>double d9</b>,&#13;
                      int i5, <b>double d10,</b> int i6, <b>int i7, double d11,</b>&#13;
                      <b>int i8, int i9</b>);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-20: The declaration of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pass_parameters_3</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, with parameters passed on the stack bolded</samp></p>&#13;
<p class="TX">Going in reverse order, we’ll push <samp class="SANS_TheSansMonoCd_W5Regular_11">i9</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d11</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d10</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">d9</samp>. <a href="#fig13-4">Figure 13-4</a> illustrates where we’ll put each parameter.</p>&#13;
<figure class="IMG"><img id="fig13-4" class="img100" src="../images/fig13-4.jpg" alt="" width="1343" height="765"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: Passing parameters from <a href="chapter13.xhtml#list13-19">Listing 13-19</a> <a href="description-32.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now that we understand how our calling convention handles floating-point values, let’s look at basic arithmetic and comparisons.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-104"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Doing Arithmetic with SSE Instructions</samp></h4>&#13;
<p class="TNI">We need to support five arithmetic operations on floating-point numbers: addition, subtraction, multiplication, division, and negation. We’ve already seen an example of addition with the <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> instruction. There are equivalent SSE instructions for the other binary operations: <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp> for subtraction, <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> for multiplication, and <samp class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp> for division. All four of these SSE instructions follow the same pattern as the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> instructions: take a source and destination operand, use them in a binary operation, and store the result in the destination. These four floating-point instructions all require an XMM register or memory address as a source and an XMM register as a destination. Floating-point division follows the same pattern as the other arithmetic instructions; it doesn’t require special handling like integer division does.</p>&#13;
<p class="TX">There’s no floating-point negation instruction. To negate a floating-point value, we’ll XOR it with <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>, which has its sign bit set but is otherwise <span role="doc-pagebreak" epub:type="pagebreak" id="pg_316" aria-label="316"/>all zeros. This has the effect of flipping the value’s sign bit, which negates it. This operation correctly negates normal numbers, subnormal numbers, positive and negative zero, and positive and negative infinity.</p>&#13;
<p class="TX">The only complication is that there’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">xorsd</samp> instruction to XOR two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s. Instead, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction, which XORs two packed vectors of two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s each. Each operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> is 16 bytes wide; the lower 8 bytes hold the first element of the vector and the upper 8 bytes hold the second. We’ll use the lower 8 bytes of each operand and ignore the upper bytes. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> and the other arithmetic floating-point instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> takes an XMM register or memory address as a source operand and an XMM register as a destination. Unlike those other instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> only accepts memory addresses that are 16-byte aligned; using a misaligned source operand causes a runtime exception.</p>&#13;
<p class="TX">Suppose we want to negate the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>, then store the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>. First, we define the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>:</p>&#13;
<pre><code>    .section .rodata&#13;
    .align 16&#13;
.L_negative.zero:&#13;
    .double -0.0</code></pre>&#13;
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align 16</samp> directive to ensure that this constant is 16-byte aligned. Next, we XOR it with our source value:</p>&#13;
<pre><code>    movsd   -8(%rbp), %xmm0&#13;
    xorpd   .L_negative.zero(%rip), %xmm0&#13;
    movsd   %xmm0, -16(%rbp)</code></pre>&#13;
<p class="TX">The first <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> instruction moves the source value into the lower 8 bytes of XMM0, zeroing out the upper 8 bytes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction XORs the lower 8 bytes of XMM0 with the 8-byte value at <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_negative.zero</samp>, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. It simultaneously XORs the upper 8 bytes of XMM0 with 8 bytes of whatever happens to immediately follow <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> in memory. After this instruction, the lower bytes of XMM0 hold our negated value, and the upper 8 bytes hold junk. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> instruction copies the lower bytes of XMM0 to their final destination at <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>.</p>&#13;
<p class="TX">We’ll also use <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> to zero out registers. Because the result of XORing any number with itself is 0, an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd %xmm0, %xmm0</samp> is the easiest way to zero out a floating-point register.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The XOR trick works for general-purpose registers too; for example, xorq %rax, %rax will zero out RAX. In fact, most compilers zero out both floating-point and general-purpose registers this way because it’s slightly faster than using a mov instruction. Since we’re prioritizing clarity and simplicity over performance, we use mov instead of xor to zero out general-purpose registers. But for XMM registers, zeroing with xor is the simpler option.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_317" aria-label="317"/>&#13;
<h4 class="H2" id="sec19"><span id="h2-105"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing Floating-Point Numbers</samp></h4>&#13;
<p class="TNI">We’ll compare floating-point values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction, which works similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>. Executing <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd b, a</samp> sets ZF to 1 if the values are equal and 0 otherwise. It sets CF to 1 if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and 0 otherwise. These are the same flags that characterize the result of an unsigned comparison. Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction always sets SF and OF to 0. We’ll therefore use the same condition codes for floating-point comparisons that we use for unsigned comparisons: <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction handles subnormal numbers, infinity, and negative zero correctly without any special effort on our part. It treats <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> as equal, like the IEEE 754 standard requires. Handling NaN, which is an extra credit feature in this chapter, <i>does</i> require special effort. When either operand is NaN, <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> reports an <i>unordered</i> result, which we can’t detect with the condition codes we’ve learned about so far. For more details, see <span class="Xref">“Extra Credit: NaN” on <a href="#pg_342">page 342</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-106"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between Floating-Point and Integer Types</samp></h4>&#13;
<p class="TNI">In <a href="chapter13.xhtml#list13-13">Listing 13-13</a>, we defined TACKY instructions for four different type conversions: <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>. The SSE instruction set includes conversions to and from signed integer types, so implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp> is easy. It doesn’t include conversions to and from unsigned integer types, so implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> takes a little ingenuity. There’s more than one way to implement these trickier conversions; we’ll implement them roughly the same way that GCC does.</p>&#13;
<p class="TX">Let’s walk through these four conversions one at a time.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a double to a Signed Integer</samp></h5>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> instruction converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to a signed integer. It truncates its source operand toward zero, which is what the C standard requires for conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to integer types. This instruction takes a suffix that indicates the size of the result: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp> converts the source value to a 32-bit integer, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> converts it to a 64-bit integer.</p>&#13;
<p class="TX">Since <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent a much wider range of values than either <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, the source of <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> might be outside the range of the destination type. In that case, the instruction results in the special <i>indefinite integer</i> value, which is the minimum integer the destination type supports. It also sets a status flag indicating that the operation was invalid. Converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an integer type is undefined behavior when it’s outside the range of that type, so we’re free to handle this case however we want. We’ll just use the indefinite integer as the result of the conversion and ignore the status flag.</p>&#13;
<p class="TX">A more user-friendly compiler might check the status flag and raise a runtime error when a conversion is out of range, instead of silently returning a bogus result. It might do the same for the conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to the unsigned integer types, which we’ll consider next. Our approach makes <span role="doc-pagebreak" epub:type="pagebreak" id="pg_318" aria-label="318"/>it easy for C programmers to shoot themselves in the foot, but at least we’re in good company: by default, GCC and Clang handle out-of-range conversions the same way we do.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a double to an Unsigned Integer</samp></h5>&#13;
<p class="TNI">It’s not always possible to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an unsigned integer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> instruction. We’ll run into trouble when the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> is in the range of an unsigned integer type but outside the range of the corresponding signed type. Consider the following C cast expression:</p>&#13;
<pre><code>(unsigned int) 4294967290.0</code></pre>&#13;
<p class="TX">This should evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp>, which is a perfectly valid <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. But if we try to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp> instruction, it will produce the indefinite integer instead of the right answer, because that value is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>. There’s no SSE instruction to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an unsigned integer, either. We’ll need to be a bit clever to work around these limitations.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>A newer instruction set extension called</i> <span class="note_Italic">AVX</span> <i>does include conversions from double to unsigned integer types, but not all x64 processors support this extension.</i></p>&#13;
<p class="TX">To convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, we’ll first convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp> and then truncate the result. For example, to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> in XMM0 to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and then store it on the stack, we can use the assembly in <a href="chapter13.xhtml#list13-21">Listing 13-21</a>.</p>&#13;
<a id="list13-21"/>&#13;
<pre><code>cvttsd2siq  %xmm0, %rax&#13;
movl  %eax, -4(%rbp)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-21: Converting a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">Any value in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is also in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> will handle it correctly. If the value is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, the behavior is undefined, so we don’t care what the result will be.</p>&#13;
<p class="TX">Converting from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> is trickier. First, we’ll check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> we want to convert is in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>. If it is, we can convert it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> instruction. If it’s not, we’ll subtract the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> from our <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to get a result in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>. We’ll convert that result to an integer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> instruction, then add <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> again after the conversion. <a href="chapter13.xhtml#list13-22">Listing 13-22</a> demonstrates how we might convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> stored in XMM0 to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> in RAX.</p>&#13;
<a id="list13-22"/>&#13;
<pre><code>    .section .rodata&#13;
    .align 8&#13;
.L_upper_bound:&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> .double 9223372036854775808.0&#13;
    .text&#13;
    <var>--snip--</var>&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> comisd  .L_upper_bound(%rip), %xmm0&#13;
    jae     .L_out_of_range&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> cvttsd2siq    %xmm0, %rax&#13;
    jmp     .L_end&#13;
.L_out_of_range:&#13;
    movsd   %xmm0, %xmm1&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> subsd   .L_upper_bound(%rip), %xmm1&#13;
    cvttsd2siq    %xmm1, %rax&#13;
    movq    $9223372036854775808, %rdx&#13;
    addq    %rdx, %rax&#13;
.L_end:</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-22: Converting a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_319" aria-label="319"/>&#13;
<p class="TX">We define a constant <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, or 2<sup>63</sup> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. To perform the conversion, we first check whether the value in XMM0 is below this constant <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it is, we can convert it to an integer with a <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> instruction <span class="CodeAnnotation" aria-label="annotation3">❸</span>, then jump over the instructions for the other case.</p>&#13;
<p class="TX">If XMM0 is greater than the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp> constant, it’s too large for <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> to convert. To handle this case, we jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp> label. We first copy the source value into XMM1 to avoid overwriting the original value, then subtract <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp> from it <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If the original value was within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>, the new value will be within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. Therefore, we can convert XMM1 to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> instruction. (If the original value wasn’t within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>, the behavior is undefined according to the C standard and <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> will result in the indefinite integer.) At this point, the value in RAX is exactly 2<sup>63</sup> (or 9,223,372,036,854,775,808) less than the correct answer, so we add <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp> to get the final result.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#list13-22">Listing 13-22</a> includes a decimal value, <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>, which the assembler will convert to a double-precision floating-point number. It also includes floating-point subtraction. We know that both of these operations can potentially introduce rounding error. Could this rounding error lead to an incorrect result?</p>&#13;
<p class="TX">Luckily for us, it won’t. We can prove that <a href="chapter13.xhtml#list13-22">Listing 13-22</a> won’t require any rounding at all. First of all, <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp> can be represented exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, where the significand is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and the exponent is <samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp>. (That’s why we use this constant instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>, which <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> cannot represent exactly.) A <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can also represent the exact result of <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd .L_upper_bound(%rip), %xmm0</samp> in every case we care about. Specifically, we care about the cases where the source value is greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>, which is 2<sup>63</sup>, but not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp>, which is 2<sup>64</sup> – 1. That means we can write this value as 1.<i>x</i> × 2<sup>63</sup>, for some sequence of bits <i>x</i>. Because a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has 53 bits of precision, <i>x</i> can’t be more than 52 bits long. When we subtract 1 × 2<sup>63</sup> from the source value, the result will be exactly <i>x</i> × 2<sup>62</sup>, which requires at most 52 bits of precision to represent exactly. (This is a special case of the <i>Sterbenz lemma</i>, in case you want to look it up.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_320" aria-label="320"/>Therefore, this subtraction will give us an exact result, and adding <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp> to that result after converting it to an integer will give us an exact final answer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a Signed Integer to a double</samp></h5>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction converts a signed integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. You write it with an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> suffix, depending on whether the source operand is a 32-bit or 64-bit integer. If the result can’t be represented exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, it will be rounded according to the CPU’s current rounding mode, which we can assume is round-to-nearest.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h5 class="H3" id="sec24"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting an Unsigned Integer to a double</samp></h5>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction interprets its source operand as a two’s complement value, meaning any value with its upper bit set gets converted to a negative <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Unfortunately, there’s no unsigned equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> that we can use instead. We’re back in a similar situation to the previous section on unsigned integers, so we’ll rely on similar techniques.</p>&#13;
<p class="TX">To convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we can zero extend it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and then convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>. <a href="chapter13.xhtml#list13-23">Listing 13-23</a> illustrates how we can use this approach to convert the unsigned integer <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<a id="list13-23"/>&#13;
<pre><code>movl  $4294967290, %eax&#13;
cvtsi2sdq  %rax, %xmm0</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-23: Converting an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">Recall that a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction moves a value into a register’s lower 32 bits and zeroes out its upper 32 bits. The first instruction in this listing effectively moves and zero extends <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp> into the RAX register. This zero-extended number has the same value whether we interpret it as signed or unsigned, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> instruction will convert it correctly, storing the floating-point value <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp> in XMM0.</p>&#13;
<p class="TX">That leaves the conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. To handle this case, we’ll first check whether the value is in the range that <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp> can represent. If it is, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> directly. Otherwise, we’ll halve the source value to bring it into the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>, convert it with <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>, and then double the result of the conversion. A naive attempt to perform this conversion in assembly might look like <a href="chapter13.xhtml#list13-24">Listing 13-24</a>.</p>&#13;
<a id="list13-24"/>&#13;
<pre><code>  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> cmpq    $0, -8(%rbp)&#13;
    jl      .L_out_of_range&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> cvtsi2sdq    -8(%rbp), %xmm0&#13;
    jmp     .L_end&#13;
.L_out_of_range:&#13;
    movq    -8(%rbp), %rax&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> shrq    %rax&#13;
    cvtsi2sdq    %rax, %xmm0&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_321" aria-label="321"/>    addsd   %xmm0, %xmm0&#13;
.L_end:</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-24: Incorrectly converting an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">We first check whether the source value, at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>, is out of bounds by performing a signed comparison to zero <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the signed value is greater than or equal to zero, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> directly <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then jump over the instructions for the out-of-range case.</p>&#13;
<p class="TX">Otherwise, we jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp> label. We copy the source value into RAX, then halve it by shifting it 1 bit to the right with the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> instruction <span class="CodeAnnotation" aria-label="annotation3">❸</span>. (The mnemonic <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> is short for <i>shift right</i>.) Next, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> to convert the halved value to the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Finally, we add the result to itself, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> representation of the original value (or at least the closest value that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent exactly).</p>&#13;
<p class="TX">But there’s a problem with this code: the result won’t always be correctly rounded. When we halve an integer with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>, we round down; halving <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>, for example, gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> as the result. If this rounded-down integer happens to be at the exact midpoint between two consecutive values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent, <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> might round down again, even though the original integer was closer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> above it than the one below it. We’ve hit a double rounding error!</p>&#13;
<p class="TX">Let’s work through a concrete example. (To make this example more readable, I’ll bold the digits that differ between large numbers that are near each other.) We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> according to <a href="chapter13.xhtml#list13-24">Listing 13-24</a>. The closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values to our source operand are <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>, which is 1,025 less than the source value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7856.0</samp>, which is 1,023 more than it. We should convert the source value to the higher <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, since it’s closer.</p>&#13;
<p class="TX">Halving the source value with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">8416</samp>. This integer is exactly at the midpoint between two adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values: <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">8928.0</samp>.</p>&#13;
<p class="TX">Written out as a binary fraction, the lower value is</p>&#13;
<pre><code>1.000000000000000000000000000000000000000000000000000<b>0</b> * 2^62</code></pre>&#13;
<p class="BodyContinued">and the higher one is:</p>&#13;
<pre><code>1.000000000000000000000000000000000000000000000000000<b>1</b> * 2^62</code></pre>&#13;
<p class="TX">This notation shows us the significands of both values, written out with the full available precision. Since we round ties to even, we pick the value with a 0 in the least significant bit of the significand. In this particular example, that means rounding down, so <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> produces the lower <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp>. We then add that to itself, which gives us a final answer of <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>. Instead of getting the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> just above our initial value, which was the correctly rounded result, we got the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> just below it. <a href="#fig13-5">Figure 13-5</a> illustrates how double rounding here leads to an incorrect result. (To reduce the size of the figure, we only show the first and last few digits of each number.)</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_322" aria-label="322"/>&#13;
<figure class="IMG"><img id="fig13-5" class="img100" src="../images/fig13-5.jpg" alt="" width="1343" height="170"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: A double rounding error when converting from an unsigned long to a double <a href="description-33.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The dotted arrow shows the correct rounding of <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/ 2</samp> to the nearest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The two solid lines demonstrate the actual result of double rounding.</p>&#13;
<p class="TX">To avoid this error, we need to make sure that when we halve the initial value, we don’t round the result to a midpoint between two values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent. We’ll do this with a technique called <i>rounding to odd</i>. When we halve the source value, we won’t truncate it toward zero. Instead, we’ll round to the nearest odd number. Using this rounding rule, we’ll round <samp class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp> up to <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> instead of down to <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. Similarly, we’ll round <samp class="SANS_TheSansMonoCd_W5Regular_11">7 / 2</samp> down to <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, and we’ll round <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/ 2</samp> up to <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">8417</samp>. If the result of dividing by 2 is already an integer, we don’t need to round; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">16 / 2</samp> will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. (Only the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> needs to be rounded to odd; <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> will still round to nearest.)</p>&#13;
<p class="TX">Rounding to odd works in this situation because the midpoints we want to avoid are always even integers. The gaps between binary floating-point numbers are always powers of 2, and they get bigger at larger magnitudes. Remember that we halve an integer for this conversion only if it’s too big to fit in a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. The halved value will therefore be between <samp class="SANS_TheSansMonoCd_W5Regular_11">(LONG_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1) / 2</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX / 2</samp>. In that range, the gap between representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values is 1,024, so every midpoint is a multiple of 512, which is even.</p>&#13;
<p class="TX"><a href="#fig13-6">Figure 13-6</a> illustrates a few different cases of rounding to odd in action.</p>&#13;
<figure class="IMG"><img class="img100" id="fig13-6" src="../images/fig13-6.jpg" alt="" width="1688" height="546"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: Using rounding to odd to avoid a double rounding error <a href="description-34.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the first case, rounding to odd prevents us from rounding to a midpoint and then down to an incorrect result. In the remaining cases, it doesn’t change the final result; whether we round these cases to odd or toward zero on the first rounding, we’ll get the same answer as if we’d rounded only once <span role="doc-pagebreak" epub:type="pagebreak" id="pg_323" aria-label="323"/>using round-to-nearest, ties-to-even mode. Sometimes rounding to odd is necessary to get the right answer, and sometimes it has no impact, but it never gives us the wrong answer.</p>&#13;
<p class="TX">Now that we understand why rounding to odd works, let’s figure out how to implement it in assembly. <a href="chapter13.xhtml#list13-25">Listing 13-25</a> demonstrates how to halve the value stored in RAX and round the result to odd.</p>&#13;
<a id="list13-25"/>&#13;
<pre><code>movq    %rax, %rdx&#13;
shrq    %rdx&#13;
andq    $1, %rax&#13;
orq     %rax, %rdx</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-25: Rounding to odd after halving an integer with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">shrq</samp></p>&#13;
<p class="TX">This listing includes two new instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>. If you did the extra credit section in <span class="Xref-1"><a href="chapter3.xhtml">Chapter 3</a></span>, you’re already familiar with them. These instructions perform bitwise AND and OR operations, respectively; they’re used exactly like our other instructions that perform binary operations on integers, including <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>.</p>&#13;
<p class="TX">Let’s figure out why this code works. First, we copy the value we want to halve into RDX and halve it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>. Next, we take the bitwise AND of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and the original value in RAX; this produces <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the original value was odd and <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> if it was even.</p>&#13;
<p class="TX">Now we need to decide what to do about the halved value in RDX. At this point, one of three things is true:</p>&#13;
<ol class="NL">&#13;
<li class="NL">The original value was even, so RDX contains the exact result of halving that value. Therefore, we don’t need to round it.</li>&#13;
<li class="NL">The original value was odd, and the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> is also odd. For example, if the original value was <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, halving it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> will produce <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. In this case, the result is already rounded to odd and doesn’t need to change.</li>&#13;
<li class="NL">The original value was odd, and the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> is even. For example, if the original value was <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>, halving it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> will produce <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. In this case, the result is not rounded to odd, and we need to increment it.</li>&#13;
</ol>&#13;
<p class="TX">In each of these three cases, the final instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">orq %rax, %rdx</samp>, has the desired effect. In the first case, it does nothing because RAX is 0, thanks to the prior <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> instruction. In the second case, it does nothing because the least significant bit of RDX is already 1. In the third case, it flips the least significant bit of RDX from 0 to 1 and makes the value odd.</p>&#13;
<p class="TX">Putting it all together, <a href="chapter13.xhtml#list13-26">Listing 13-26</a> shows the complete assembly to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to a correctly rounded <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>&#13;
<a id="list13-26"/>&#13;
<pre><code>    cmpq    $0, -8(%rbp)&#13;
    jl      .L_out_of_range&#13;
    cvtsi2sdq    -8(%rbp), %xmm0&#13;
    jmp     .L_end&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_324" aria-label="324"/>.L_out_of_range:&#13;
    movq    -8(%rbp), %rax&#13;
<b>    movq    %rax, %rdx</b>&#13;
<b>    shrq    %rdx</b>&#13;
<b>    andq    $1, %rax</b>&#13;
<b>    orq     %rax, %rdx</b>&#13;
    cvtsi2sdq    <b>%rdx,</b> %xmm0&#13;
    addsd   %xmm0, %xmm0&#13;
.L_end:</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-26: Correctly converting an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp></p>&#13;
<p class="TX">This code is identical to the original conversion in <a href="chapter13.xhtml#list13-24">Listing 13-24</a>, except for the bolded changes: we round the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> to odd and use the rounded value in RDX as the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> instruction.</p>&#13;
<p class="TX">We’ve now discussed how to implement every floating-point operation we need; we’re ready to update the assembly generation pass!</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-115"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">As usual, our first task is to update the assembly AST. We’ll add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> assembly type:</p>&#13;
<pre><code>assembly_type = Longword | Quadword <b>| Double</b></code></pre>&#13;
<p class="TX">We’ll also add a new top-level construct to represent floating-point constants:</p>&#13;
<pre><code>StaticConstant(identifier name, int alignment, static_init init)</code></pre>&#13;
<p class="TX">This construct is almost identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>. The one difference is that we can omit the <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> attribute, since we’ll never define global constants. For now, we’ll define only floating-point constants; in later chapters, we’ll use this construct to define constants of other types as well.</p>&#13;
<p class="TX">Next, we’ll add two new instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si</samp>:</p>&#13;
<pre><code>instruction =<var> --snip--</var>&#13;
            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)&#13;
            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)</code></pre>&#13;
<p class="TX">Each of these takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp> parameter to specify whether it operates on <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> integers.</p>&#13;
<p class="TX">We’ll reuse the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions to represent floating-point comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> and arithmetic with <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>, and so on. We’ll add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">DivDouble</samp> binary operator to represent floating-point division. (Recall that the assembly AST doesn’t include a binary operator for integer division because <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> don’t follow the same pattern as the other arithmetic instructions.) We’ll also add the <samp class="SANS_TheSansMonoCd_W5Regular_11">Xor</samp> binary operator we need to negate floating-point values, as well as the bitwise <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp> operators we need to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label="325"/>binary_operator = <var>--snip--</var> | DivDouble | And | Or | Xor</code></pre>&#13;
<p class="TX">We need the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp> operator for that type conversion too:</p>&#13;
<pre><code>unary_operator = <var>--snip--</var> | Shr</code></pre>&#13;
<p class="TX">Finally, we’ll add the XMM registers. We’ll need XMM0 through XMM7 for parameter passing, plus a couple more scratch registers for instruction rewrites. You can use any registers apart from XMM0 through XMM7 for scratch; I’ll use XMM14 and XMM15. You can either add all 16 registers to the AST or just add the ones we need right now:</p>&#13;
<pre><code>reg = <var>--snip--</var> | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15</code></pre>&#13;
<p class="TX"><a href="chapter13.xhtml#list13-27">Listing 13-27</a> gives the entire assembly AST, with changes bolded.</p>&#13;
<a id="list13-27"/>&#13;
<pre><code>program = Program(top_level*)&#13;
assembly_type = Longword | Quadword <b>| Double</b>&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, int alignment, static_init init)&#13;
          <b>| StaticConstant(identifier name, int alignment, static_init init)</b>&#13;
instruction = Mov(assembly_type, operand src, operand dst)&#13;
            | Movsx(operand src, operand dst)&#13;
            | MovZeroExtend(operand src, operand dst)&#13;
            <b>| Cvttsd2si(assembly_type dst_type, operand src, operand dst)</b>&#13;
            <b>| Cvtsi2sd(assembly_type src_type, operand src, operand dst)</b>&#13;
            | Unary(unary_operator, assembly_type, operand)&#13;
            | Binary(binary_operator, assembly_type, operand, operand)&#13;
            | Cmp(assembly_type, operand, operand)&#13;
            | Idiv(assembly_type, operand)&#13;
            | Div(assembly_type, operand)&#13;
            | Cdq(assembly_type)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
&#13;
unary_operator = Neg | Not <b>| Shr</b>&#13;
binary_operator = Add | Sub | Mult <b>| DivDouble | And | Or | Xor</b>&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int) | Data(identifier)&#13;
cond_code = E | NE | G | GE | L | LE | A | AE | B | BE&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP&#13;
    <b>| XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-27: The assembly AST with floating-point constants, instructions, and registers</samp></p>&#13;
<p class="TX">We already understand how to perform floating-point operations in assembly, but there are a few implementation details we still need to discuss. We’ll deal with constants first.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label="326"/>&#13;
<h4 class="H2" id="sec26"><span id="h2-107"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Constants</samp></h4>&#13;
<p class="TNI">In previous chapters, we converted integer constants in TACKY to <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> operands in assembly. This approach won’t work for floating-point constants. Instead, when we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> constant in TACKY, we’ll generate a new top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> construct with a unique identifier. To use that constant in an instruction, we refer to it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand, just like a static variable. For example, suppose we need to convert the following TACKY instruction to assembly:</p>&#13;
<pre><code>Copy(Constant(ConstDouble(1.0)), Var("x"))</code></pre>&#13;
<p class="TX">First, we’ll generate a unique label, <samp class="SANS_TheSansMonoCd_W5Regular_11">const_label</samp>, that won’t conflict with any of the names in the symbol table or any of the internal labels we use as jump targets. Then, we’ll define a new top-level constant like this:</p>&#13;
<pre><code>StaticConstant(const_label, 8, DoubleInit(1.0))</code></pre>&#13;
<p class="TX">This top-level constant must be 8-byte aligned to conform to the System V ABI. After defining this constant, we’ll emit the following assembly instruction:</p>&#13;
<pre><code>Mov(Double, Data(const_label), Pseudo("x"))</code></pre>&#13;
<p class="TX">Keep track of every <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> you define throughout the entire assembly generation pass. Then, at the end of this pass, add these constants to your list of top-level constructs.</p>&#13;
<p class="TX">Aside from constant handling, this example demonstrates a few things about assembly generation that won’t change. First, we’ll still convert the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction in assembly, whether we’re copying an integer or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Second, TACKY variables are still converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operands, regardless of their type.</p>&#13;
<p class="TX">There are a couple of optional tweaks you can make here to bring your top-level constants more in line with what a production compiler would generate:</p>&#13;
<p class="ListHead"><b>Avoiding duplicate constants</b></p>&#13;
<p class="ListPlain">Don’t generate multiple equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> constructs. Instead, whenever you see a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> constant in TACKY, check whether you’ve already generated a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> with the same value and alignment. If you have, refer to that constant in your assembly code instead of generating a new one. Just keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> are distinct constants that require separate <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> constructs, even though they compare equal in most languages.</p>&#13;
<p class="ListHead"><b>Using local labels for top-level constants</b></p>&#13;
<p class="ListPlain">Compilers typically use local labels starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> (on macOS) or <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> (on Linux) for floating-point constants, so they don’t show up as symbols in the final executable. (Recall that we already use local labels for <span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label="327"/>jump targets.) If you want to follow this naming convention, don’t add the local label prefix just yet; wait until the code emission pass. For now, add top-level constants to the backend symbol table and use a new attribute to distinguish them from variables. <a href="chapter13.xhtml#list13-28">Listing 13-28</a> shows how to update the original backend symbol table entry from <span class="listplain_Xref-1"><a href="chapter11.xhtml#list11-26">Listing 11-26</a></span> to include this attribute.</p>&#13;
<a id="list13-28"/>&#13;
<pre><code>asm_symtab_entry = ObjEntry(assembly_type, bool is_static, <b>bool is_constant</b>)&#13;
 | FunEntry(bool defined)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-28: Definition of an entry in the backend symbol table, including the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is_constant</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">attribute</samp></p>&#13;
<p class="ListBodyLast">During code emission, we’ll use this new attribute to figure out which operands should get a local label prefix. The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp> attribute should also be true for constants, since we store them in the read-only data section and access them with RIP-relative addressing. We’re waiting until code emission to add local labels instead of generating them right off the bat because it will be easier to extend this approach when we add more kinds of top-level constants in <span class="Xref-1"><a href="chapter16.xhtml">Chapter 16</a></span>.</p>&#13;
<p class="TX">Feel free to make both of these tweaks, skip both of them, or make one but not the other.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-108"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unary Instructions, Binary Instructions, and Conditional Jumps</samp></h4>&#13;
<p class="TNI">We’ll convert floating-point addition, subtraction, and multiplication instructions from TACKY to assembly just like their integer equivalents. Floating-point division will follow the same pattern as these other instructions, even though integer division doesn’t. Consider the following TACKY instruction:</p>&#13;
<pre><code>Binary(Divide, Var("src1"), Var("src2"), Var("dst"))</code></pre>&#13;
<p class="TX">If the type of its operands is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll generate the following assembly:</p>&#13;
<pre><code>Mov(Double, Pseudo("src1"), Pseudo("dst"))&#13;
Binary(DivDouble, Double, Pseudo("src2"), Pseudo("dst"))</code></pre>&#13;
<p class="TX">We’ll also translate floating-point negation differently from its integer counterpart. To negate a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll XOR it with <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. For example, to translate the TACKY instruction</p>&#13;
<pre><code>Unary(Negate, Var("src"), Var("dst"))</code></pre>&#13;
<p class="BodyContinued">we’ll start by defining a new 16-byte-aligned constant:</p>&#13;
<pre><code>StaticConstant(const, 16, DoubleInit(-0.0))</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label="328"/>Then we’ll generate the following assembly instructions:</p>&#13;
<pre><code>Mov(Double, Pseudo("src"), Pseudo("dst"))&#13;
Binary(Xor, Double, Data(const), Pseudo("dst"))</code></pre>&#13;
<p class="TX">We need to align <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> to 16 bytes so that we can use it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction. This is the only time we align a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to 16 bytes instead of 8. We don’t need to worry about the alignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>; <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>’s destination must be a register, and we’ll take care of that requirement during instruction fix-up.</p>&#13;
<p class="TX">Next, let’s talk about how to handle our relational binary operators: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>, and so on. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> sets the CF and ZF flags, we’ll handle floating-point comparisons just like unsigned integer comparisons. Here’s an example:</p>&#13;
<pre><code>Binary(LessThan, Var("x"), Var("y"), Var("dst"))</code></pre>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are floating-point values, we’ll produce the following assembly:</p>&#13;
<pre><code>Cmp(Double, Pseudo("y"), Pseudo("x"))&#13;
Mov(Longword, Imm(0), Pseudo("dst"))&#13;
SetCC(B, Pseudo("dst"))</code></pre>&#13;
<p class="TX">We’ll take a similar approach to the three TACKY instructions that compare a value to zero: <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>, and the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> operation. We’ll convert</p>&#13;
<pre><code>JumpIfZero(Var("x"), "label")</code></pre>&#13;
<p class="TNI">to the following assembly:</p>&#13;
<pre><code>Binary(Xor, Double, Reg(XMM0), Reg(XMM0))&#13;
Cmp(Double, Pseudo("x"), Reg(XMM0))&#13;
JmpCC(E, "label")</code></pre>&#13;
<p class="TX">Note that we need to zero out an XMM register with <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> in order to perform the comparison. You don’t need to use XMM0 here, but you shouldn’t use the scratch registers you’ve chosen for the rewrite pass. It’s easier to avoid conflicting uses of registers if you strictly separate which registers you introduce in each backend pass.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Conversions</samp></h4>&#13;
<p class="TNI">Since we’ve already covered the assembly for each of our type conversions, I won’t present it again here, but I will flag a couple of details we haven’t discussed yet. First, you’ll need to choose which hard registers to use in these conversions. All four conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and the unsigned integer types use XMM registers, general-purpose registers, or both. For example, <a href="chapter13.xhtml#list13-26">Listing 13-26</a> uses RAX and RDX to halve an integer and then round to odd. You don’t need to stick with the same registers we used when we <span role="doc-pagebreak" epub:type="pagebreak" id="pg_329" aria-label="329"/>walked through these conversions earlier; just avoid the callee-saved registers (RBX, R12, R13, R14, and R15) and the registers you use in the rewrite pass (R10 and R11, plus your two scratch XMM registers; mine are XMM14 and XMM15).</p>&#13;
<p class="TX">Second, when you process a conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, be sure to generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instruction to explicitly zero extend the source value, rather than a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction. This will become important when we implement register allocation in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>. We’ll use a technique called <i>register coalescing</i> to delete redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions as we allocate registers; using <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> here signals that you’re using this instruction to zero out bytes and not just to move values around, so it shouldn’t be deleted.</p>&#13;
<p class="TX">Concretely, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, you’ll translate the TACKY instruction</p>&#13;
<pre><code>UIntToDouble(Var("x"), Var("y"))</code></pre>&#13;
<p class="BodyContinued">into this assembly:</p>&#13;
<pre><code>MovZeroExtend(Pseudo("x"), Reg(AX))&#13;
Cvtsi2sd(Quadword, Reg(AX), Pseudo("y"))</code></pre>&#13;
<p class="TX">You can use a register other than RAX here, as long as it meets the requirements we just discussed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h4 class="H2" id="sec29"><span id="h2-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Calls</samp></h4>&#13;
<p class="TNI">The tricky part of handling floating-point values in function calls is figuring out where each argument is passed. We’ll use this information in two places. First, we’ll need it to pass arguments correctly when we translate the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction. Second, we’ll use it to set up parameters at the beginning of each function body. We’ll write a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>, to handle the bookkeeping we need in both of these places. Given a list of TACKY values, this helper function will convert each one to an assembly operand and determine its assembly type. It will also partition the list in three: one list of operands passed in general-purpose registers, one list of operands passed in XMM registers, and one list of operands passed on the stack. <a href="chapter13.xhtml#list13-29">Listing 13-29</a> gives the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.</p>&#13;
<a id="list13-29"/>&#13;
<pre><code>classify_parameters(values):&#13;
    int_reg_args = []&#13;
    double_reg_args = []&#13;
    stack_args = []&#13;
&#13;
    for v in values:&#13;
        operand = convert_val(v)&#13;
        t = assembly_type_of(v)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> typed_operand = (t, operand)&#13;
        if t == Double:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if length(double_reg_args) &lt; 8:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> double_reg_args.append(operand)&#13;
            else:&#13;
                stack_args.append(typed_operand)&#13;
        else:&#13;
            if length(int_reg_args) &lt; 6:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> int_reg_args.append(typed_operand)&#13;
            else:&#13;
                stack_args.append(typed_operand)&#13;
&#13;
    return (int_reg_args, double_reg_args, stack_args)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-29: Classifying function arguments or parameters</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_330" aria-label="330"/>&#13;
<p class="TX">To process each parameter, we first convert it from a TACKY value to an assembly operand and convert its type to the corresponding assembly type. (I won’t give you the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type_of</samp>, which just finds the type of a TACKY value and converts it to assembly.) We package these up into a pair, <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">int_reg_args</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> will all be pairs in this form. The elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp> will be plain assembly operands; since they’re all <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s, it would be redundant to specify each one’s type explicitly.</p>&#13;
<p class="TX">Next, we figure out which list to add the operand to. We’ll see if we can pass it in an available register for its type. For example, if its type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>, we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp> already contains eight values <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it does, registers XMM0 through XMM7 are already taken. If it doesn’t, there’s at least one XMM register still available.</p>&#13;
<p class="TX">If we can pass the operand in an XMM register, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double_arg_regs</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If we can pass it in a general-purpose register, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int_arg_regs</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If there are no registers of the correct type available, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>. Once we’ve processed every value, we return all three lists.</p>&#13;
<p class="TX">As we build up these three lists, we preserve the order in which the values appear. In particular, we add values to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> in the same order they appear in the original list of values, not in reverse. That means the first value in <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> will be pushed last and will appear at the top of the stack. From the callee’s perspective, the first value will be stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>, the second value at <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>, and so on.</p>&#13;
<p class="TX">Recall that at the start of a function body, we copy any parameters from their initial locations into pseudoregisters. <a href="chapter13.xhtml#list13-30">Listing 13-30</a> demonstrates how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> to perform this setup.</p>&#13;
<a id="list13-30"/>&#13;
<pre><code>set_up_parameters(parameters):&#13;
&#13;
    // classify them&#13;
    int_reg_params, double_reg_params, stack_params = classify_parameters(parameters)&#13;
&#13;
    // copy parameters from general-purpose registers&#13;
    int_regs = [DI, SI, DX, CX, R8, R9]&#13;
    reg_index = 0&#13;
    for (param_type, param) in int_reg_params:&#13;
        r = int_regs[reg_index]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_331" aria-label="331"/>        emit(Mov(param_type, Reg(r), param))&#13;
        reg_index += 1&#13;
&#13;
    // copy parameters from XMM registers&#13;
    double_regs = [XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7]&#13;
    reg_index = 0&#13;
    for param in double_reg_params:&#13;
        r = double_regs[reg_index]&#13;
        emit(Mov(Double, Reg(r), param))&#13;
        reg_index += 1&#13;
&#13;
    // copy parameters from the stack&#13;
    offset = 16&#13;
    for (param_type, param) in stack_params:&#13;
        emit(Mov(param_type, Stack(offset), param))&#13;
        offset += 8</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-30: Setting up parameters in function bodies</samp></p>&#13;
<p class="TX">In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp> takes a list of a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>s representing a function’s parameter list. We process this list with <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>, then handle the three resulting lists of assembly operands. To process parameters passed in general-purpose registers, we copy the value in EDI (or RDI, depending on the type) to the pseudoregister for the first parameter, copy the value in ESI to the second parameter, and so on. We handle parameters passed in XMM registers the same way. Finally, we handle parameters passed on the stack: we copy the value at <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</samp> to the first pseudoregister in <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_params</samp>, then increase the stack offset by 8 for each subsequent parameter until we’ve processed the whole list.</p>&#13;
<p class="TX">We’ll also use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> to implement the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction. Let’s revisit the pseudocode to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> to assembly, which we first introduced in <span class="Xref-1"><a href="chapter9.xhtml#list9-31">Listing 9-31</a></span> and updated in <span class="Xref-1"><a href="chapter11.xhtml#list11-25">Listing 11-25</a></span>. <a href="chapter13.xhtml#list13-31">Listing 13-31</a> presents this pseudocode again, with the new logic to process floating-point arguments and return values bolded. (I haven’t bolded minor changes like renaming <samp class="SANS_TheSansMonoCd_W5Regular_11">arg_registers</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int_registers</samp>.)</p>&#13;
<a id="list13-31"/>&#13;
<pre><code>convert_function_call(FunCall(fun_name, args, dst)):&#13;
    int_registers = [DI, SI, DX, CX, R8, R9]&#13;
    <b>double_registers = [XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7]</b>&#13;
&#13;
    <b>// classify arguments</b>&#13;
    <b>int_args, double_args, stack_args = classify_parameters(args)</b>&#13;
&#13;
    // adjust stack alignment&#13;
    if length(stack_args) is odd:&#13;
        stack_padding = 8&#13;
    else:&#13;
        stack_padding = 0&#13;
&#13;
    if stack_padding != 0:&#13;
        emit(Binary(Sub, Quadword, Imm(stack_padding), Reg(SP)))&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_332" aria-label="332"/>    // pass args in registers&#13;
    reg_index = 0&#13;
    for (assembly_type, assembly_arg) in int_args:&#13;
        r = int_registers[reg_index]&#13;
        emit(Mov(assembly_type, assembly_arg, Reg(r)))&#13;
        reg_index += 1&#13;
&#13;
    <b>reg_index = 0</b>&#13;
    <b>for assembly_arg in double_args:</b>&#13;
        <b>r = double_registers[reg_index]</b>&#13;
        <b>emit(Mov(Double, assembly_arg, Reg(r)))</b>&#13;
        <b>reg_index += 1</b>&#13;
&#13;
    // pass args on stack&#13;
    for (assembly_type, assembly_arg) in reverse(stack_args):&#13;
        if (assembly_arg is a Reg or Imm operand&#13;
            or assembly_type == Quadword&#13;
            <b>or assembly_type == Double</b>):&#13;
            emit(Push(assembly_arg))&#13;
        else:&#13;
            emit(Mov(<b>assembly_type</b>, assembly_arg, Reg(AX)))&#13;
            emit(Push(Reg(AX)))&#13;
&#13;
    // emit call instruction&#13;
    emit(Call(fun_name))&#13;
&#13;
    // adjust stack pointer&#13;
    bytes_to_remove = 8 * length(stack_args) + stack_padding&#13;
    if bytes_to_remove != 0:&#13;
        emit(Binary(Add, Quadword, Imm(bytes_to_remove), Reg(SP)))&#13;
&#13;
    // retrieve return value&#13;
    assembly_dst = convert_val(dst)&#13;
    return_type = assembly_type_of(dst)&#13;
    <b>if return_type == Double:</b>&#13;
        <b>emit(Mov(Double, Reg(XMM0), assembly_dst))</b>&#13;
    <b>else:</b>&#13;
        emit(Mov(return_type, Reg(AX), assembly_dst))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-31: Supporting</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in function calls</samp></p>&#13;
<p class="TX">Let’s walk through the changes in this listing. To start, we need to categorize our arguments with <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>. The arguments in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_args</samp> are passed in general-purpose registers the same way as before (possibly with a few tweaks, not bolded here, to account for the fact that we’re iterating over typed assembly operands rather than TACKY values). We add a new step to copy each argument in <samp class="SANS_TheSansMonoCd_W5Regular_11">double_args</samp> into the corresponding XMM register.</p>&#13;
<p class="TX">Next, we update how we pass arguments on the stack. We make two tiny changes from <span class="Xref-1"><a href="chapter11.xhtml#list11-25">Listing 11-25</a></span>, where we last looked at this step. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operands of <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> type, like operands of <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type, are pushed directly onto the stack without copying them into a register first, since they’re the correct operand size for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction. Second, in cases where we move an operand into the <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp> register before we push it onto the stack, we no longer hardcode <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp> as the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction; instead, we use <span role="doc-pagebreak" epub:type="pagebreak" id="pg_333" aria-label="333"/>the operand type we determined in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>. This future-proofs our code against later chapters, where we’ll add more assembly types.</p>&#13;
<p class="TX">Finally, we update how we retrieve the function’s return value. If the return value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll copy it from XMM0 to the destination. Otherwise, we’ll copy it from EAX (or RAX), as usual. We don’t need to change how we adjust the stack alignment before a function call, issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction itself, or clean up arguments afterward.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h4 class="H2" id="sec30"><span id="h2-111"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Return Instructions</samp></h4>&#13;
<p class="TNI">Last but not least, we’ll change how we translate the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. For example, given the TACKY instruction</p>&#13;
<pre><code>Return(Var("x"))</code></pre>&#13;
<p class="BodyContinued">we’ll look up the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in the backend symbol table. If it’s an integer, we can handle it as before. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll copy it into XMM0 and then return:</p>&#13;
<pre><code>Mov(Double, Pseudo("x"), Reg(XMM0))&#13;
Ret</code></pre>&#13;
<p class="TX">And with that, we’ve covered every update to the assembly genera- tion pass.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-112"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Complete Conversion from TACKY to Assembly</samp></h4>&#13;
<p class="TNI"><a href="chapter13.xhtml#tab13-2">Tables 13-2</a> through <a href="chapter13.xhtml#tab13-7">13-7</a> summarize this chapter’s changes to the conversion from TACKY to assembly. As usual, new constructs and changes to the conversions for existing constructs are bolded. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;R&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;X&gt;</samp> placeholders in <a href="chapter13.xhtml#tab13-3">Table 13-3</a> indicate arbitrary general-purpose and XMM registers, respectively.</p>&#13;
<p class="TT" id="tab13-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(top_level_defs)</samp></p></td>&#13;
<td class="Basic-Table TBF" colspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(top_level_defs</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;all StaticConstant constructs for&#13;
         floating-point constants&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global, params,&#13;
          instructions)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL" colspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, global,</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">        </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[Mov(&lt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">first int param type</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;, Reg(DI),</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">first int param</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">         </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(&lt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">second int param type</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;, Reg(SI),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">              </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">second int param</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">         </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;copy next four</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"> integer</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">parameters from registers&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">          Mov(Double, Reg(XMM0),</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;first double param&gt;),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">          Mov(Double, Reg(XMM1),</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;second double param&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">          &lt;copy next six double parameters from registers&gt;,</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">          Mov(&lt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">first stack param type</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;, Stack(16),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">               &lt;first stack param</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">          Mov(&lt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">second stack param type</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;, Stack(24),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">              </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">second stack param</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;),</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">          &lt;copy remaining parameters from stack&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp> +&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">        instructions)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-3"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_334" aria-label="334"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_335" aria-label="335"/>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Integer</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;val type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, val, Reg(AX))<br/>Ret</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Double, val, Reg(XMM0))<br/>Ret</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Not, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Integer</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp><samp class="SANS_TheSansMonoCd_W5Regular_11"> Imm(0), src)<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp><samp class="SANS_TheSansMonoCd_W5Regular_11"> Imm(0), dst)<br/>SetCC(E, dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Xor, Double, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Cmp(Double, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, Imm(0), dst)<br/>SetCC(E, dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unary(Negate, src, dst) (double</samp> <samp class="SANS_Futura_Std_Heavy_B_11">negation)</samp></p></td>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Double, src, dst)<br/>Binary(Xor, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;negative-zero&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp></code></pre>&#13;
<pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">And add a top-level constant:</samp><br/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;negative-zero&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 16,&#13;
                DoubleInit(-0.0))</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2,        dst)</samp> <samp class="SANS_Futura_Std_Heavy_B_11">(integer division)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX))<br/>Cdq(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)<br/>Idiv(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src2)<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(AX), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX))<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), Reg(DX))<br/>Div(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src2)<br/>Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(AX), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Integer</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)<br/>JmpCC(E, target)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Xor, Double, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Cmp(Double, condition, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>JmpCC(E, target)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Integer</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Imm(0), condition)<br/>JmpCC(NE, target)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Xor, Double, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Cmp(Double, condition, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>JmpCC(NE, target)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall(fun_name, args, dst)</samp></p></td>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;fix stack alignment&gt;</samp> <br/><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;move arguments to general-purpose registers&gt;<br/>&lt;move arguments to XMM registers&gt;<br/>&lt;push arguments onto the stack&gt;</samp> <br/><samp class="SANS_TheSansMonoCd_W5Regular_11">Call(fun_name)</samp> <br/><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;deallocate arguments/padding&gt;</samp> <br/><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst register&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntToDouble(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvtsi2sd(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, src, dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToInt(src, dst)</samp></p></td>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, src, dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">UIntToDouble(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned int</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(src, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Cvtsi2sd(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned long</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cmp(Quadword, Imm(0), src)<br/>JmpCC(L,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)<br/>Cvtsi2sd(Quadword, src, dst) Jmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)<br/>Mov(Quadword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Mov(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Unary(Shr, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Binary(And, Quadword, Imm(1), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Binary(Or, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Cvtsi2sd(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)<br/>Binary(Add, Double, dst, dst)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBL" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToUInt(src, dst)</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned int</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(Quadword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Mov(Longword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned long</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cmp(Double, Data(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), src)<br/>JmpCC(AE,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)<br/>Cvttsd2si(Quadword, src, dst)<br/>Jmp(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label1&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)<br/>Mov(Double, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Binary(Sub, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">      </samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Cvttsd2si(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;X&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)<br/>Mov(Quadword, Imm(9223372036854775808), Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))<br/>Binary(Add, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;R&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)<br/>Label(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label2&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp></code></pre>&#13;
<pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">And add a top-level constant:</samp><br/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;upper-bound&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 8,&#13;
                DoubleInit(9223372036854775808.0))</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Arithmetic Operators to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Divide</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DivDouble</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">(double</samp> <samp class="SANS_Futura_Std_Heavy_B_11">division)</samp></p></td>&#13;
<td class="Basic-Table TBL"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Comparisons to Assembly</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_336" aria-label="336"/>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"/>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstDouble(double))</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Data(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;ident&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">And add top-level constant:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;ident&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, 8, DoubleInit(double))</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Types to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">As the row for the top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp> construct in <a href="chapter13.xhtml#tab13-2">Table 13-2</a> indicates, you’ll need to add every <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> you define in this pass to the list of top-level definitions. From this point on, updating the rest of the backend is relatively smooth sailing.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-113"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pseudoregister Replacement</samp></h4>&#13;
<p class="TNI">You should allocate 8 bytes on the stack for each <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> pseudoregister and make sure it’s 8-byte aligned. If the backend symbol table indicates that a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has static storage duration, you should replace any references to it with <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands, like you do for other static variables. In short, this pass can treat <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> pseudoregisters identically, since they have the same size and alignment.</p>&#13;
<p class="TX">As usual, you should also extend this pass to handle the new assembly instructions in this chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-114"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instruction Fix-Up</samp></h4>&#13;
<p class="TNI">Next, we’ll rewrite invalid SSE instructions. We’ll also need to rewrite the new bitwise instructions that operate on integers. Let’s handle the SSE instructions first. You should dedicate one XMM register to fixing instructions’ source operands and one to fixing destinations. I’ll use XMM14 for the former and XMM15 for the latter.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_337" aria-label="337"/>The destination of <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> must be a register. For example, we’ll rewrite</p>&#13;
<pre><code>Cvttsd2si(Quadword, Stack(-8), Stack(-16))</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>Cvttsd2si(Quadword, Stack(-8), Reg(R11))&#13;
Mov(Quadword, Reg(R11), Stack(-16))</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction has two constraints: the source can’t be a constant, and the destination must be a register. We’ll therefore rewrite</p>&#13;
<pre><code>Cvtsi2sd(Longword, Imm(10), Stack(-8))</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>Mov(Longword, Imm(10), Reg(R10))&#13;
Cvtsi2sd(Longword, Reg(R10), Reg(XMM15))&#13;
Mov(Double, Reg(XMM15), Stack(-8))</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction has different constraints from <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>. Its second operand, in the “destination” position, must be a register. So, we’ll rewrite</p>&#13;
<pre><code>Cmp(Double, Stack(-8), Stack(-16))</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>Mov(Double, Stack(-16), Reg(XMM15))&#13;
Cmp(Double, Stack(-8), Reg(XMM15))</code></pre>&#13;
<p class="TX">The destination of an <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction must be a register as well, so we’ll rewrite all of these instructions accordingly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction also requires either a register or a 16-byte-aligned memory address as its source operand, but we don’t need a rewrite rule for this since all the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instructions we generate already satisfy this requirement.</p>&#13;
<p class="TX">We’ll use the same rewrite rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> that we introduced for the general-purpose <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in <span class="Xref-1"><a href="chapter2.xhtml">Chapter 2</a></span>, because it’s subject to the same constraint: its operands can’t both be in memory. (The one difference, of course, is that we’ll use an XMM register instead of R10 as the scratch register.)</p>&#13;
<p class="TX">That leaves the new bitwise instructions. We won’t need to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> instructions are subject to the same constraints as integer <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>: the operands can’t both be memory addresses, and they can’t take immediate source operands outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.</p>&#13;
<p class="TX">There’s one other constraint that we’ll ignore for now: the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction can’t push an XMM register. We’ll wait until the next chapter to add the rewrite rule for invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions because it will use a new kind of assembly operand that we haven’t added yet. We won’t actually need this <span role="doc-pagebreak" epub:type="pagebreak" id="pg_338" aria-label="338"/>rewrite rule until we implement register allocation in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>; until then, we’ll push only immediate values and memory operands (and the RBP register in the function prologue).</p>&#13;
<aside class="box" aria-label="box-32"><p class="BoxTitle" id="box-32"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Your compiler should now generate complete, valid assembly programs for each of this chapter’s test cases. To test it out, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 13 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h3 class="H1" id="sec34"><span id="h1-116"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">As always, the last step is printing out the newest additions to the assembly AST. The most fiddly bit of this pass is emitting floating-point constants and static variables. Let’s walk through how to format floating-point numbers in assembly, how to label floating-point constants, and how to store floating-point constants and variables in the correct section.</p>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h4 class="H2" id="sec35"><span id="h2-115"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatting Floating-Point Numbers</samp></h4>&#13;
<p class="TNI">There are a few different ways to format floating-point numbers in assembly. One option is to print these numbers as <i>hexadecimal floating-point</i> constants, where the significand is a hexadecimal number and the exponent is a power of 2. This notation can represent a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> exactly, without any rounding. The significand of a hexadecimal floating-point constant has an <samp class="SANS_TheSansMonoCd_W5Regular_11">0x</samp> prefix, and the exponent has a <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">P</samp> prefix. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp> in hexadecimal floating point is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2.8p+3</samp>. The hexadecimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2.8</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">2.5</samp> in decimal, and 2.5 × 2<sup>3</sup> = 20. We can use this notation in a <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp> directive, like so:</p>&#13;
<pre><code>.L_twenty:&#13;
    .double 0x2.8p+3</code></pre>&#13;
<p class="TX">When you emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> in this notation, you’ll need up to 14 hexadecimal digits to represent it exactly. Unfortunately, not every assembler understands this format. The LLVM assembler, which is the default assembler on macOS, does; GAS, the GNU assembler, doesn’t.</p>&#13;
<p class="TX">If your assembler doesn’t support hexadecimal floating-point constants, you can emit a quadword with the same binary representation as the required <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Printing out <samp class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp> with this approach results in:</p>&#13;
<pre><code>.L_twenty:&#13;
    .quad 4626322717216342016</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_339" aria-label="339"/>This isn’t the most readable assembly, but it works perfectly well as long as your implementation language provides a way for you to get at the binary representation of a floating-point number. Your last option is to use decimal floating-point constants, which we used in earlier assembly examples:</p>&#13;
<pre><code>.L_twenty:&#13;
    .double 20.0</code></pre>&#13;
<p class="TX">Decimal can be less compact than hexadecimal floating point. For example, consider <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>, the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to the decimal number 0.1. The exact decimal representation of this value is:</p>&#13;
<pre><code>1.000000000000000055511151231257827021181583404541015625e-1</code></pre>&#13;
<p class="TX">You don’t need to emit this entire value; 17 digits is always enough to guarantee a <i>round-trip conversion</i> back to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. In other words, you can print out a 17-digit decimal approximation of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>, like this:</p>&#13;
<pre><code>1.0000000000000001e-1</code></pre>&#13;
<p class="TX">This isn’t exactly the right value, but it’s close enough that when the assembler converts it back to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> you’ll get the original value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h4 class="H2" id="sec36"><span id="h2-116"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Labeling Floating-Point Constants</samp></h4>&#13;
<p class="TNI">If you’re using local labels for top-level constants, you should include the local label prefix (<samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> on macOS, <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> on Linux) any time you emit these constants’ identifiers. You’ll need to check the backend symbol table to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands that represent static variables and those that represent constants. If an object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp> attribute is true, it takes a local label prefix; otherwise, it’s a variable, so it doesn’t.</p>&#13;
<p class="TX">If you’re not using local labels, you’ll need to emit all <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands uniformly. On macOS, that means prefixing the labels for both constants and static variables with an underscore.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h4 class="H2" id="sec37"><span id="h2-117"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Storing Constants in the Read-Only Data Section</samp></h4>&#13;
<p class="TNI">The name of the section that holds constants is platform-specific. On Linux, you should specify this section with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.section .rodata</samp> directive. On macOS, 8-byte-aligned and 16-byte-aligned constants are stored in different sections. If a constant is 8-byte aligned, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> directive to store it in the correct section. For our one 16-byte-aligned constant (<samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>, which we use to implement negation), use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal16</samp> directive.</p>&#13;
<p class="TX">The macOS linker expects 16-byte-aligned constants to be 16 bytes long, but <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> is only 8 bytes. Emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad 0</samp> directive right after the directive for <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> to bring the total size of the section holding this constant up to 16 bytes and satisfy the linker’s requirements.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_340" aria-label="340"/>&#13;
<h4 class="H2" id="sec38"><span id="h2-118"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing Static Variables to 0.0 or –0.0</samp></h4>&#13;
<p class="TNI">We won’t store static variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> in the BSS section or initialize them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> directive, even if they’re initialized to zero. This sidesteps any potential confusion about whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> is really initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. (These two values usually compare equal, but we can’t store <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> in the BSS section or initialize it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> directive because its binary representation isn’t all zeros.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h4 class="H2" id="sec39"><span id="h2-119"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp></h4>&#13;
<p class="TNI">Aside from floating-point constants and static variables, the code emission stage needs to handle the new XMM registers, the new instructions, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp> suffix on the floating-point versions of existing instructions. These changes are extensive, but they don’t require much discussion. <a href="chapter13.xhtml#tab13-8">Tables 13-8</a> through <a href="chapter13.xhtml#tab13-13">13-13</a> summarize this chapter’s updates to the code emission pass. New constructs and changes to the way we emit existing constructs are bolded.</p>&#13;
<p class="TT" id="tab13-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF" rowspan="2"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable(name, global,&#13;
                alignment, init)</samp></code></pre></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Integer initialized to zero</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;global-directive&gt;&#13;
   </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss&#13;
   </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:&#13;
   </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Integer with nonzero initializer,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or any</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;global-directive&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#13;
   .data</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&#13;
    &lt;alignment-directive&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL" rowspan="3"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">StaticConstant(name, alignment,&#13;
                init)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Linux</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">    .section .rodata</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;alignment-directive&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"/> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">    &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">macOS (8-byte-aligned constants)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">    .literal8&#13;
    .balign 8</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">    &lt;init&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">macOS (16-byte-aligned constants)</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">    .literal16&#13;
    .balign 16</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">    &lt;init&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">    .quad 0</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-9"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Static Initializers</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleInit(d)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">.double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;d&gt;</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or .quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;d-interpreted-as-long&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-10"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_341" aria-label="341"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-10:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvtsi2sd(t, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">cvtsi2sd</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;t&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src&gt;, &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(t, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">cvttsd2si</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;t&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src&gt;, &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Xor, Double, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">xorpd   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Mult, Double, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">mulsd   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cmp(Double, operand, operand)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">comisd  </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;operand&gt;, &lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-11"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-11:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Names for Assembly Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shr</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DivDouble</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">div</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">And</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Or</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-12"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-12:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Suffixes for Assembly Types</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction suffix</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">sd</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab13-13"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-13:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM0)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM1)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM2)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm2</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM3)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm3</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM4)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm4</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM5)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm5</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM6)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm6</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM7)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm7</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM14)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm14</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM15)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm15</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Note that <a href="chapter13.xhtml#tab13-8">Table 13-8</a> doesn’t include local label prefixes on constants, although you have the option to include them, as we’ve discussed. Also note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> instructions in <a href="chapter13.xhtml#tab13-10">Table 13-10</a> require special handling. As a packed instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> doesn’t use the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp> suffix, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_342" aria-label="342"/>and the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> instructions have different names than their integer counterparts.</p>&#13;
<p class="TX">Once you’ve worked through all these changes, you’re ready to test the whole compiler.</p>&#13;
<aside class="box" aria-label="box-33"><p class="BoxTitle" id="box-33"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out your whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 13</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This chapter’s test suite includes several test cases with separate library and client source files, to exercise our support for the System V calling convention. Other tests in this chapter use subnormal numbers, infinity, and negative zero. Several tests call mathematical functions that are declared in the standard library’s</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp> <samp class="SANS_Futura_Std_Book_11">header. These test programs explicitly declare any library functions they need rather than including the whole</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp> <samp class="SANS_Futura_Std_Book_11">header.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Many of this chapter’s test programs do something you don’t often see in real-life C programs: they compare floating-point values for equality. This is usually a bad idea because rounding error can make equivalent calculations produce slightly different results, but this chapter’s tests take rounding error into account; they either use constants that can be exactly represented in floating point or check whether the result of some computation equals the expected correctly rounded result.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
&#13;
<h3 class="H1" id="sec40"><span id="h1-117"/><samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: NaN</samp></h3>&#13;
<p class="TNI">You can add support for quiet NaNs as an extra credit feature. Arithmetic operations should just work, without any extra effort on your part, because the SSE instructions will propagate NaNs appropriately. You don’t need to handle type conversions, either, since conversions from NaN to integers are undefined. The only operations you need to worry about are comparisons.</p>&#13;
<p class="TX">When you compare any value to NaN, the result is unordered. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is NaN, then <samp class="SANS_TheSansMonoCd_W5Regular_11">x &gt; y</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x &lt; y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are all false. NaN even compares unequal to itself. The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction indicates an unordered result by setting three flags to 1: ZF, CF, and PF, the <i>parity flag</i>. Just as there are condition codes that rely on ZF, CF, and the other status flags we’ve already encountered, the <samp class="SANS_TheSansMonoCd_W5Regular_11">P</samp> condition code relies on the parity flag. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">jp</samp> instruction will jump only if PF is 1. You’ll need to use this condition code to properly account for NaN in floating-point comparisons.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_343" aria-label="343"/>Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--nan</samp> flag to include test cases with NaN when you run the test suite:</p>&#13;
<pre><code>$ <b>./test_compiler </b><var><b>/path/to/your_compiler</b></var><b> --chapter 13 --nan</b></code></pre>&#13;
<p class="TX">Or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp> flag to enable all extra credit tests, as usual.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h3 class="H1" id="sec41"><span id="h1-118"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">Your compiler now supports floating-point numbers! In this chapter, you learned how to define floating-point constants in assembly, how to use SSE instructions, and how to pass floating-point arguments according to the System V calling convention. You also dealt with rounding error throughout the compiler, from the parser all the way through code emission. Above all, you’ve seen how difficult floating-point arithmetic is to get right. Many programmers know, in a general way, that floating-point arithmetic can be imprecise; writing a compiler forces you to understand exactly how it can go awry. In the next chapter, you’ll add a very different type: pointers. You’ll deal with tricky parsing issues, expand the type checker, and add a few extremely useful constructs to the TACKY and assembly ASTs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h3 class="H1" id="sec42"><span id="h1-119"/><samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp></h3>&#13;
<p class="TNI">These are the resources I relied on while writing this chapter, roughly organized by the section where they’re most relevant. I’ve also included a couple of online floating-point visualization tools that I found particularly helpful.</p>&#13;
<p class="ListHead"><b>IEEE 754</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">The IEEE 754 standard is available for purchase on the IEEE website for $100 (<i><a href="https://ieeexplore.ieee.org/document/8766229">https://<wbr/>ieeexplore<wbr/>.ieee<wbr/>.org<wbr/>/document<wbr/>/8766229</a></i>). But you can probably get any answers you need from the following resources, which are free:<ul class="BL"><li class="ListBulletSub">The “Double-Precision Floating-Point Format” article on Wikipedia gives a thorough description of the binary encoding of IEEE 754 double-precision values (<i><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Double<wbr/>-precision<wbr/>_floating<wbr/>-point<wbr/>_format</a></i>).</li>&#13;
<li class="ListBulletSub">“What Every Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg is one of the best-known introductions to floating-point math, if not the most readable (<i><a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">https://<wbr/>docs<wbr/>.oracle<wbr/>.com<wbr/>/cd<wbr/>/E19957<wbr/>-01<wbr/>/806<wbr/>-3568<wbr/>/ncg<wbr/>_goldberg<wbr/>.html</a></i>). I found the discussion of the IEEE 754 format in the section “The IEEE Standard” especially useful. The article also covers some important topics that I’ve glossed over completely, like exceptions and error handling.</li>&#13;
<li class="ListBulletSub">The Floating-Point Guide, a website created by Michael Borgwardt, covers the basics of working with IEEE 754 floating-point numbers in an approachable way (<i><a href="https://floating-point-gui.de">https://<wbr/>floating<wbr/>-point<wbr/>-gui<wbr/>.de</a></i>). Start here if the other two articles are too dense.</li></ul></li>&#13;
<li class="ListBullet"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_344" aria-label="344"/>To learn more about support for the IEEE 754 standard in GCC and Clang, see the following resources:<ul class="BL"><li class="ListBulletSub">“Semantics of Floating Point Math in GCC” on the GCC wiki summarizes the state of floating-point support in GCC, describes the default floating-point behavior, and discusses some of the challenges of fully conforming to IEEE 754 (<i><a href="https://gcc.gnu.org/wiki/FloatingPointMath">https://<wbr/>gcc<wbr/>.gnu<wbr/>.org<wbr/>/wiki<wbr/>/FloatingPointMath</a></i>).</li>&#13;
<li class="ListBulletSub">The section “Controlling Floating-Point Behavior” in the Clang Compiler User’s Manual discusses IEEE 754 compliance in Clang (<i><a href="https://clang.llvm.org/docs/UsersManual.html#controlling-floating-point-behavior">https://<wbr/>clang<wbr/>.llvm<wbr/>.org<wbr/>/docs<wbr/>/UsersManual<wbr/>.html#controlling<wbr/>-floating<wbr/>-point<wbr/>-behavior</a></i>).</li></ul></li>&#13;
</ul>&#13;
<p class="ListHead"><b>Reference for “Rounding Behavior” on <a href="#pg_299">page 299</a></b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“The Spacing of Binary Floating-Point Numbers,” a blog post by Rick Regan, discusses the gaps between consecutive floating-point numbers (<i><a href="https://www.exploringbinary.com/the-spacing-of-binary-floating-point-numbers/">https://<wbr/>www<wbr/>.exploringbinary<wbr/>.com<wbr/>/the<wbr/>-spacing<wbr/>-of<wbr/>-binary<wbr/>-floating<wbr/>-point<wbr/>-numbers<wbr/>/</a></i>). I found that focusing on the gaps in the number line was the key to understanding floating-point rounding error. After I read this blog post, other discussions of this topic suddenly made a lot more sense.</li>&#13;
</ul>&#13;
<p class="ListHead"><b>References for “Floating-Point Operations in Assembly” on <a href="#pg_310">page 310</a></b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">For details about the System V calling convention, see the System V x64 ABI (<i><a href="https://gitlab.com/x86-psABIs/x86-64-ABI">https://<wbr/>gitlab<wbr/>.com<wbr/>/x86<wbr/>-psABIs<wbr/>/x86<wbr/>-64<wbr/>-ABI</a></i>).</li>&#13;
<li class="ListBullet">For details about individual SSE instructions, including how they deal with overflow and rounding, see the Intel 64 Software Developer’s Manual (<i><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">https://<wbr/>www<wbr/>.intel<wbr/>.com<wbr/>/content<wbr/>/www<wbr/>/us<wbr/>/en<wbr/>/developer<wbr/>/articles<wbr/>/technical<wbr/>/intel<wbr/>-sdm<wbr/>.html</a></i>).</li>&#13;
<li class="ListBullet">“Sometimes Floating Point Math Is Perfect,” a blog post by Bruce Dawson, gives an overview of cases where floating-point calculations <i>don’t</i> produce rounding error (<i><a href="https://randomascii.wordpress.com/2017/06/19/sometimes-floating-point-math-is-perfect/">https://<wbr/>randomascii<wbr/>.wordpress<wbr/>.com<wbr/>/2017<wbr/>/06<wbr/>/19<wbr/>/sometimes<wbr/>-floating<wbr/>-point<wbr/>-math<wbr/>-is<wbr/>-perfect<wbr/>/</a></i>). It helped me think through why our assembly to convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> won’t have rounding error.</li>&#13;
<li class="ListBullet">Pascal Cuoq has written an excellent answer to a Stack Overflow question about the assembly-level conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> (<i><a href="https://stackoverflow.com/a/26799227">https://<wbr/>stackoverflow<wbr/>.com<wbr/>/a<wbr/>/26799227</a></i>). This is the best explanation of this conversion I’ve been able to find.</li>&#13;
<li class="ListBullet">“GCC Avoids Double Rounding Errors with Round-to-Odd,” another post by Rick Regan, provides more background information on double rounding error (<i><a href="https://www.exploringbinary.com/gcc-avoids-double-rounding-errors-with-round-to-odd/">https://<wbr/>www<wbr/>.exploringbinary<wbr/>.com<wbr/>/gcc<wbr/>-avoids<wbr/>-double<wbr/>-rounding<wbr/>-errors<wbr/>-with<wbr/>-round<wbr/>-to<wbr/>-odd<wbr/>/</a></i>).</li>&#13;
</ul>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_345" aria-label="345"/><b>References for “Code Emission” on <a href="#pg_338">page 338</a></b></p>&#13;
<p class="ListPlain">I drew on two of Rick Regan’s blog posts on Exploring Binary to handle floating-point constants during code emission:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Hexadecimal Floating-Point Constants” talks about representing floating-point numbers in hexadecimal to avoid rounding error (<i><a href="https://www.exploringbinary.com/hexadecimal-floating-point-constants/">https://<wbr/>www<wbr/>.exploringbinary<wbr/>.com<wbr/>/hexadecimal<wbr/>-floating<wbr/>-point<wbr/>-constants<wbr/>/</a></i>).</li>&#13;
<li class="ListBullet">“Number of Digits Required for Round-Trip Conversions” explains why 17 decimal digits is enough to represent a floating-point constant (<i><a href="https://www.exploringbinary.com/number-of-digits-required-for-round-trip-conversions/">https://<wbr/>www<wbr/>.exploringbinary<wbr/>.com<wbr/>/number<wbr/>-of<wbr/>-digits<wbr/>-required<wbr/>-for<wbr/>-round<wbr/>-trip<wbr/>-conversions<wbr/>/</a></i>).</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Floating-point visualization tools</b></p>&#13;
<p class="ListPlainFirst">These tools let you experiment with the IEEE 754 representations of decimal numbers:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">The Decimal to Floating-Point Converter, created by Rick Regan, lets you convert a decimal number to the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and display it in a wide range of formats, including raw binary, hexadecimal floating point, and binary scientific notation (<i><a href="https://www.exploringbinary.com/floating-point-converter/">https://<wbr/>www<wbr/>.exploringbinary<wbr/>.com<wbr/>/floating<wbr/>-point<wbr/>-converter<wbr/>/</a></i>).</li>&#13;
<li class="ListBullet">Float Exposed, created by Bartosz Ciechanowski, lets you view and edit the sign, exponent, and significand fields within a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> as well as its raw binary representation (<i><a href="https://float.exposed">https://<wbr/>float<wbr/>.exposed</a></i>).</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>