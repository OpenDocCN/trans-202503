<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="157" id="Page_157"/>8</span><br/>
<span class="ChapterTitle">Working with the Canvas</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll learn how to use WebAssembly with the HTML canvas element to create fast and efficient animations in a web application. We’ll manipulate pixel data inside the WebAssembly linear memory, and then transfer that pixel data in linear memory directly onto the HTML canvas. We’ll continue with our random collider objects example (Listing 6-16) by generating the objects in JavaScript linear memory and then using WebAssembly to move these objects, detect collisions, and render them. Because the number of possible collisions grows exponentially with the number of objects, this kind of graphical collision detection is an excellent test of WebAssembly’s capabilities. By the end of this chapter, we’ll have an application that can test collisions between thousands of different colliders dozens of times per second. In this case, our objects will be squares drawn in green if there is no collision and red if a collision occurs. </p>
<p><span epub:type="pagebreak" title="158" id="Page_158"/>As discussed earlier, web browsers were originally designed for displaying simple online documents, meaning any changes to the position of any of the document’s elements frequently resulted in the entire page being rerendered. That is a performance nightmare for any application that requires high-frame-rate graphical effects (such as games). Since then browsers have evolved into sophisticated application-hosting environments, necessitating the development of a more sophisticated rendering model: the <em>canvas</em>. The canvas element was introduced in 2004 by Apple for its Safari web browser and adopted as a part of the HTML standard in 2006. Within the bounds of the canvas element, web developers can render 2D images and animations with significantly better performance than could be done by manipulating the DOM, as had been done previously. Using the canvas with WebAssembly can help us render animations to the browser with lightning speed.</p>
<h2 id="h1-501737c08-0001">Rendering to the Canvas</h2>
<p class="BodyFirst">Entire books have been written on the HTML canvas API, so we’ll only touch on a few of the features needed for this WebAssembly demonstration. As with the DOM, WebAssembly cannot interact directly with the canvas. Instead, we must render pixel data directly from linear memory onto the canvas element. That allows us to write a canvas application with minimal JavaScript code. Before writing the WebAssembly code, we’ll write the HTML and JavaScript portion. To see what the finished app looks like, browse to <a href="https://wasmbook.com/collide.html" class="LinkURL">https://wasmbook.com/collide.html</a>. </p>
<h3 id="h2-501737c08-0001">Defining the Canvas in HTML</h3>
<p class="BodyFirst">As usual, we’ll break the HTML file into sections and examine it a piece at a time. This first piece defines the canvas, which is the area in the web page where animations are rendered. Create a file named <em>collide.html</em> and add the code in <a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a>.</p>
<p class="CodeLabel"><b>collide.html (part 1 of 5)</b></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Collision detection&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> &lt;canvas <span class="CodeAnnotationCode" aria-label="annotation2">2</span>id="cnvs" <span class="CodeAnnotationCode" aria-label="annotation3">3</span>width="512" <span class="CodeAnnotationCode" aria-label="annotation4">4</span>height="512"&gt;&lt;/canvas&gt;
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: HTML to define the canvas</p>
<p>The element you need to pay attention to here is the <code>canvas</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> element. We give the <code>canvas</code> element an <code>id</code> of <code>cnvs</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> so that later we can use a call to <code>document.getElementById</code> to retrieve the canvas element. We set the <code>width</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and <code>height</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to <code>512</code>, chosen because 512 is 2<sup>9</sup> or hexadecimal 0x200. This choice <span epub:type="pagebreak" title="159" id="Page_159"/>makes it easy to work with the width and height using binary logic, which can help improve the app’s performance if we design our code properly. </p>
<h3 id="h2-501737c08-0002">Defining JavaScript Constants in HTML</h3>
<p class="BodyFirst">At the beginning of our JavaScript, we’ll add constant values for configuring some top level settings in the WebAssembly module. The values will be shared between the JavaScript and the WebAssembly. Defining these values inside the JavaScript makes it simpler to update the configuration. We begin the code with some canvas-related constants that set parameters for interaction between the WebAssembly and the HTML <code>canvas</code> element. We also have a cluster of constants related to the organization of the data in linear memory that define our base address, stride, and offset for the objects we’re rendering. In addition, we must define a new <code>ImageData</code> object that sets aside a section of the linear memory buffer as an object that the app can directly draw to the canvas. Add the code in <a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a> to your HTML file.</p>
<p class="CodeLabel"><b>collide.html (part 2 of 5)</b></p>
<pre><code>...
&lt;script&gt;
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> const cnvs_size = 512;  <span class="LiteralGray">// square canvas where width and height = 512</span>

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> const no_hit_color = 0xff_00_ff_00; <span class="LiteralGray">// no hit color (green)</span>
  const hit_color = 0xff_00_00_ff;    <span class="LiteralGray">// hit color (red)</span>

<span class="LiteralGray">  // pixels count is canvas_size x canvas_size because it's a square canvas</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> const pixel_count = cnvs_size * cnvs_size; 

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> const canvas = document.getElementById("cnvs");
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, 512, 512);

 <span class="LiteralGray">// the number of bytes needed for that pixel data is the number of pixels * 4</span>
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> const obj_start = pixel_count * 4; <span class="LiteralGray">// 4 bytes in every pixel.</span>
  const obj_start_32 = pixel_count;  <span class="LiteralGray">// 32-bit offset to the starting object</span>
  const obj_size = 4;       <span class="LiteralGray">// how many pixels is the square object</span>
  const obj_cnt = 3000;     <span class="LiteralGray">// 3000 objects</span>
  const stride_bytes = 16;  <span class="LiteralGray">// there are 16 bytes in each stride</span>

  const x_offset  = 0;      <span class="LiteralGray">// x attribute is bytes 0-3</span>
  const y_offset  = 4;      <span class="LiteralGray">// y attribute is bytes 4-7</span>
  const xv_offset = 8;      <span class="LiteralGray">// x velocity attribute is bytes 8-11</span>
  const yv_offset = 12;     <span class="LiteralGray">// y velocity attribute is bytes 12-15</span>

<span class="CodeAnnotationCode" aria-label="annotation7">7</span> const memory = new WebAssembly.Memory({initial: 80});
  const mem_i8 = new Uint8Array(memory.buffer);         <span class="LiteralGray">// 8-bit view</span>
  const mem_i32 = new Uint32Array(memory.buffer);       <span class="LiteralGray">// 32-bit view</span>

<span class="CodeAnnotationCode" aria-label="annotation8">8</span> const importObject = {
  env: {
    buffer: memory,

    cnvs_size: cnvs_size,
    no_hit_color: no_hit_color,
<span epub:type="pagebreak" title="160" id="Page_160"/>    hit_color: hit_color,
    obj_start: obj_start,
    obj_cnt: obj_cnt,
    obj_size: obj_size,

    x_offset: x_offset,
    y_offset: y_offset,
    xv_offset: xv_offset,
    yv_offset: yv_offset
  }
 };

<span class="LiteralGray">  // An ImageData object can be blitted onto the canvas</span>
  const image_data = 
  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> new ImageData( new Uint8ClampedArray(memory.buffer, 0, obj_start),
                 cnvs_size, 
                 cnvs_size );
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: Configuring image data in JavaScript</p>
<p>We have a single <code>cnvs_size</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> constant that holds the height and width of the <code>canvas</code> element because they’re the same. We then have two constants that define hexadecimal color values. The first, <code>no_hit_color</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, defines the color an object will be when it doesn’t collide with another object. The second, <code>hit_color</code>, defines the color an object will be when it collides with another object. The meaning of these hexadecimal numbers is covered in more detail in “Bitmap Image Data” on page 162. Then we define the <code>pixel_count</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which we can get by squaring the <code>canvas_size</code> because we have a square canvas.</p>
<p>Next, we deal with the Canvas API interface, the <em>drawing context</em>, which allows JavaScript to interact with the <code>canvas</code>. There are a few options for working with the HTML <code>canvas</code>. We’ll work with the <code>"2d"</code> canvas context because it’s relatively simple. Here we create a <code>canvas</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> element constant with a call to <code>document.getElementById</code> to retrieve a context from the HTML canvas. We then call the function <code>getContext</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> on that <code>canvas</code> constant to create a constant containing the context interface, which we’ve named <code>ctx</code>. We’ll use this <code>ctx</code> object to render a bitmap generated in WebAssembly to the <code>canvas</code> element.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	WebAssembly also works well with the <em>webgl</em> and <em>webgl2</em> canvas contexts, which render 3D models to the canvas. Unfortunately, WebGL is beyond the scope of this book.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Following the canvas-related constants is a group of linear memory object-related constants. These constants begin with the <code>obj_start</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> constant and follow the base, stride, and offset format we discussed in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. The base address in <code>obj_start</code> must show an address that follows all of our pixel data at the beginning of linear memory. We set <code>obj_start</code> to <code>pixel_count * 4</code> because each pixel takes up four bytes of data, and the object data immediately follows a section of that size. In this area, we use some constants to define our stride size and the offsets for each of the object <span epub:type="pagebreak" title="161" id="Page_161"/>attributes. We define the linear memory <span class="CodeAnnotation" aria-label="annotation7">7</span> with an initial size of 80 pages, enough to fit all the objects and pixel data we require. Then we create an 8-bit and a 32-bit view of that data object. All the constants we’ve created so far must be passed into the WebAssembly module using the <code>importObject</code> <span class="CodeAnnotation" aria-label="annotation8">8</span>.</p>
<p>Lastly, we create a new <code>ImageData</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> object, which is a JavaScript interface that we can use to access the underlying pixel data in our canvas element. The <code>Memory</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> object that we created in <a href="#listing8-2">Listing 8-2</a> has an attribute called <code>buffer</code>, which is a typed array containing the data in linear memory. The <code>buffer</code><code> </code>attribute is a data buffer that can represent the pixel data displayed on a canvas. To create a new <code>ImageData</code> object, the <code>memory.buffer</code> object must be passed into the <code>ImageData</code> object as a <code>Uint8ClampedArray</code> along with the width and height of the canvas. </p>
<h3 id="h2-501737c08-0003">Creating Random Objects</h3>
<p class="BodyFirst">Next, we’ll create the random objects, similar to how we did so previously in the book. We continue to use random data because it allows us to focus on the WebAssembly rather than the data. However, WebAssembly doesn’t have a random number function, so creating our randomized objects inside JavaScript is much simpler. The objects have four attributes: an x- and y-coordinate (position), as well as an x and y velocity (motion). We use a 32-bit integer to represent the value of each of these attributes. <a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a> shows the code that loops to create data for several objects represented by the <code>object_cnt</code> constant we defined earlier.</p>
<p class="CodeLabel"><b>collide.html (part 3 of 5)</b></p>
<pre><code>...
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> const stride_i32 = stride_bytes/4;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> for( let i = 0; i &lt; obj_cnt * stride_i32; i += stride_i32 ) {

<span class="LiteralGray">    // value less than canvas_size</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> let temp = Math.floor(Math.random() * cnvs_size);

<span class="LiteralGray">    // set object x attribute to random value</span>
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> mem_i32[obj_start_32 + i] = temp; 

<span class="LiteralGray">    //random value less than canvas_size</span>
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> temp = Math.floor(Math.random()*cnvs_size);

<span class="LiteralGray">    // set object y attribute to random value</span>
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> mem_i32[obj_start_32 + i + 1] = temp; 

<span class="LiteralGray">    // random value between -2 and 2</span>
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> temp = (Math.round(Math.random() * 4) - 2); 

<span class="LiteralGray">    // set x velocity to random value</span>
  <span class="CodeAnnotationCode" aria-label="annotation8">8</span> mem_i32[obj_start_32 + i + 2] = temp; 

<span class="LiteralGray">    // random value between -2 and 2</span>
  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> temp = (Math.round(Math.random() * 4) - 2);  

<span class="LiteralGray">    // set y velocity to random value</span>
<span epub:type="pagebreak" title="162" id="Page_162"/>  <span class="CodeAnnotationCode" aria-label="annotationa">a</span> mem_i32[obj_start_32 + i + 3] = temp; 
}
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: Setting linear memory data</p>
<p>The code in this loop accesses the data in linear memory through the 32-bit integer view in <code>mem_i32</code>. Because the loop is working with 32-bit numbers, we create a 32-bit version of <code>stride_bytes</code>, which we call <code>stride_i32</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. We set it to the value <code>stride_bytes / 4</code>, because there are four bytes per <code>i32</code>. The <code>for</code> loop loops until index <code>i</code> is equal to the number of objects set in <code>obj_count</code> multiplied by the number of 32-bit integers in our stride defined by <code>stride_i32</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. This creates the circle data structure in linear memory.</p>
<p>Inside the loop, we set four 32-bit integers to random numbers that will represent the position and velocity of each object. First, we set the position attributes. We get a random number between 0 and the canvas width <span class="CodeAnnotation" aria-label="annotation3">3</span> held in <code>cnvs_size</code> and store it in the location of the <code>x</code> position attribute <span class="CodeAnnotation" aria-label="annotation4">4</span> in linear memory. Next, a random number between 0 and the canvas height <span class="CodeAnnotation" aria-label="annotation5">5</span> is generated and stored in the <code>y</code> attribute <span class="CodeAnnotation" aria-label="annotation6">6</span> location in linear memory. Then we set the velocity attributes by generating a number between –2 and 2 <span class="CodeAnnotation" aria-label="annotation7">7</span>, storing it in the location of the <code>x</code> velocity <span class="CodeAnnotation" aria-label="annotation8">8</span> attribute, and do the same <span class="CodeAnnotation" aria-label="annotation9">9</span> for the <code>y</code> velocity <span class="CodeAnnotation" aria-label="annotationa">a</span> attribute.</p>
<h3 id="h2-501737c08-0004">Bitmap Image Data</h3>
<p class="BodyFirst">We can render bitmap image data directly to the HTML <code>canvas</code> element using the <code>putImageData</code> function, passing in the <code>ImageData</code> object we defined earlier. The HTML canvas is a grid of pixels; each of which can be represented by three bytes with one byte dedicated to each of the three colors: red, green, and blue. In the bitmap format, a pixel is represented with a single 32-bit integer where each byte of the integer represents one of the colors. The fourth byte of the integer represents the<em> alpha value</em>,<em> </em>which is<em> </em>used for pixel opacity. When the alpha byte is 0, the pixel is fully transparent, and when it’s 255, it’s fully opaque. In WebAssembly linear memory, we’ll create an array of 32-bit integers that represents an array of pixel data. This type of array makes WebAssembly a very convenient tool for manipulating data to be rendered to the HTML canvas.</p>
<p>In the <code>script</code> tag, we’ll store the WebAssembly module function that generates this bitmap data in the variable <code>animation_wasm</code>. We also need a JavaScript function that calls that WebAssembly function. Then we call <code>ctx.putImageData</code> to render that image data to the <code>canvas</code> element. <a href="#listing8-4" id="listinganchor8-4">Listing 8-4</a> contains the next chunk of JavaScript code you need to add to the HTML file.</p>
<p class="CodeLabel"><b>collide.html (part 4 of 5)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> var animation_wasm; <span class="LiteralGray">// the webassembly function we will call every frame</span>

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> function animate() {
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> animation_wasm();
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> ctx.putImageData(image_data, 0, 0); <span class="LiteralGray">// render pixel data</span>
<span epub:type="pagebreak" title="163" id="Page_163"/>  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> requestAnimationFrame(animate);
  }
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: The JavaScript <code>animate</code> function renders the animation frame.</p>
<p>The <code>animation_wasm</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> variable holds the WebAssembly function that generates the image data. The <code>animate</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function that follows calls the WebAssembly module’s <code>animation_wasm</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function, which generates the <code>image_data</code> for the next frame in the animation. The <code>image_data</code> object is then passed into a call to <code>ctx.putImageData</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, which renders the image generated by WebAssembly in the <code>canvas</code> element. The last function, <code>requestAnimationFrame</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, is a little more complicated, so we’ll examine it in more detail in the next section.</p>
<h3 id="h2-501737c08-0005">The requestAnimationFrame Function</h3>
<p class="BodyFirst">Animation is an optical illusion: a series of still images displayed in rapid sequence tricks the eye into believing there is motion. Every television screen, computer monitor, and film you’ve ever watched works this way. JavaScript provides the handy <code>requestAnimationFrame</code> function: when you call <code>requestAnimationFrame</code>, the function passed to <code>requestAnimationFrame</code> is called the next time a frame is rendered. To <code>requestAnimationFrame</code>, we pass the function we want to call the next time our computer is ready to render a frame of animation. </p>
<p>We call this function at the end of the JavaScript, passing in the <code>animate</code> function that we defined in <a href="#listing8-4">Listing 8-4</a>. We call <code>requestAnimationFrame</code> a second time from the end of the <code>animate</code> function to register the function as a callback on the frame render that follows. That second call must be made because the <code>requestAnimationFrame</code> function doesn’t register a function to be called every time a frame is rendered; it’s only registered for the next frame render. The <code>animate</code> function needs to call the WebAssembly module, which performs the collision detection and object move computations. WebAssembly calculates the image data placed on the canvas. However, it’s unable to render that data to the canvas directly. That’s why we must call <code>putImageData</code> from our JavaScript animation function to render the pixel data to the canvas. The call to <code>putImageData</code> moves the chunk of linear memory we set aside to represent pixel data over to the <code>canvas</code> element.</p>
<p>The first time we call <code>requestAnimationFrame</code> is immediately after instantiating the WebAssembly module in the last line of the code. <a href="#listing8-5" id="listinganchor8-5">Listing 8-5</a> shows the final portion of the HTML code.</p>
<p class="CodeLabel"><b>collide.html (part 5 of 5)</b></p>
<pre><code>...
(async () =&gt; {
  let obj = await
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> WebAssembly.instantiateStreaming( fetch('collide.wasm'),
                                     importObject );
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> animation_wasm = obj.instance.exports.main;
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> requestAnimationFrame(<span class="CodeAnnotationCode" aria-label="annotation4">4</span>animate);
})();
&lt;/script&gt;
<span epub:type="pagebreak" title="164" id="Page_164"/>&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing8-5">Listing 8-5</a>: Instantiate the WebAssembly module and call <code>requestAnimationFrame</code>.</p>
<p>Inside the asynchronous IIFE we begin by calling the <code>instantiateStreaming</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function. We set the <code>animation_wasm</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> variable we defined in <a href="#listing8-4">Listing 8-4</a> to an exported function in the WebAssembly module named <code>main</code>. Recall that we called the <code>animation_wasm</code> function from the <code>animate</code> function. Finally, a call to <code>requestAnimationFrame</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> passes in the <code>animate</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> function defined earlier. Because <code>animate</code> also calls <code>requestAnimationFrame</code> on itself, the browser calls <code>animate</code> every time it refreshes.</p>
<h2 id="h1-501737c08-0002">The WAT Module</h2>
<p class="BodyFirst">Now that we’ve defined the HTML, we need to write the WebAssembly module in WAT, which will manage the object movement, collision detection, and bitmap image data. Create a file named <em>collide.wat</em>. We’ll write the collision code and canvas rendering code as straightforwardly as possible. To accomplish this, we’ll write it with many functions, some of which might result in less than ideal performance. In the next chapter, we’ll revisit this code in an attempt to optimize it. But in this chapter, we’ll focus on clarity and simplicity over high performance. The module will define global variables that import values from the JavaScript. We’ll need to define a series of functions that clear the canvas, calculate the absolute value of an integer, set individual pixels, and draw the collider objects. Then we’ll need to define the <code>main</code> function that will use a double loop to move each collider object and test to see whether it collides with another object.</p>
<h3 id="h2-501737c08-0006">Imported Values</h3>
<p class="BodyFirst">The beginning of the module, as shown in <a href="#listing8-6" id="listinganchor8-6">Listing 8-6</a>, imports the constants passed into the module through the <code>importObject</code> we defined in our JavaScript. These values include our memory buffer, the canvas size, object colors, and the base, offset, and stride values we can use to access objects in linear memory.</p>
<p class="CodeLabel"><b>collide.wat (part 1 of 12)</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (global $cnvs_size    (import "env" "cnvs_size")    i32)

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $no_hit_color (import "env" "no_hit_color") i32)
  (global $hit_color    (import "env" "hit_color")    i32)
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (global $obj_start    (import "env" "obj_start")    i32)
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (global $obj_size     (import "env" "obj_size")     i32)
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (global $obj_cnt      (import "env" "obj_cnt")      i32)

<span class="CodeAnnotationCode" aria-label="annotation6">6</span> (global $x_offset     (import "env" "x_offset")     i32)  <span class="LiteralGray">;; bytes 00-03</span>
  (global $y_offset     (import "env" "y_offset")     i32)  <span class="LiteralGray">;; bytes 04-07</span>
<span class="CodeAnnotationCode" aria-label="annotation7">7</span> (global $xv_offset    (import "env" "xv_offset")    i32)  <span class="LiteralGray">;; bytes 08-11</span>
  (global $yv_offset    (import "env" "yv_offset")    i32)  <span class="LiteralGray">;; bytes 12-15</span>
<span epub:type="pagebreak" title="165" id="Page_165"/>
<span class="CodeAnnotationCode" aria-label="annotation8">8</span> (import "env" "buffer" (memory 80))                       <span class="LiteralGray">;; canvas</span><span class="LiteralGray"> buffer</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-6">Listing 8-6</a>: Declaring the imported global variables and memory buffer</p>
<p>We first import the global variable <code>$cnvs_size</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, defined as <code>512</code> in the JavaScript, which represents the width and height of the canvas. Next are two color values, <code>$no_hit_color</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, representing the 32-bit color of a noncolliding object, and <code>$hit_color</code>, representing the color of a colliding object. Remember that we defined them as the hexadecimal value for green and red.</p>
<p>Then we have an <code>$obj_start</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> variable that contains the base location for the object data. The <code>$obj_size</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> variable is the width and height of the objects in pixels, which will be square. The <code>$obj_cnt</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> variable contains the number of objects the application will render and checks for collisions. Next is the offset for the two coordinates, <code>$x_offset</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> and <code>$y_offset</code>, and the two attributes for the velocity values <span class="CodeAnnotation" aria-label="annotation7">7</span>, <code>$xv_offset</code> and <code>$yv_offset</code>. The final <code>import</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> in this code block imports the <code>memory</code> <code>buffer</code> that we defined in JavaScript.</p>
<h3 id="h2-501737c08-0007">Clearing the Canvas</h3>
<p class="BodyFirst">Next, we’ll define a function that clears the entire bitmap image buffer. If the canvas isn’t cleared every time the frame is rendered, the old impression of each object will remain in memory and the objects will smear across the screen. The <code>$clear_canvas</code> function sets every color value to <code>0xff_00_00_00</code>, representing black with full opacity. <a href="#listing8-7" id="listinganchor8-7">Listing 8-7</a> shows the code for the <code>$clear_canvas</code> function.</p>
<p class="CodeLabel"><b>collide.wat (part 2 of 12)</b></p>
<pre><code>...
<span class="LiteralGray">;; clear the entire canvas</span>
(func $clear_canvas 
  (local $i       i32)
  (local $pixel_bytes  i32)

  global.get $cnvs_size
  global.get $cnvs_size
  i32.mul                  <span class="LiteralGray">;; multiply $width and $height</span>

  i32.const 4
  i32.mul                 <span class="LiteralGray"> ;; 4 bytes per pixel</span>

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.set $pixel_bytes   <span class="LiteralGray">;; $pixel_bytes = $width * $height * 4</span>

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (loop $pixel_loop
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (i32.store (local.get $i) (i32.const 0xff_00_00_00)) 

    (i32.add (local.get $i) (i32.const 4))
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.set $i          <span class="LiteralGray"> ;; $i += 4 (bytes per pixel)</span>

<span class="LiteralGray">    ;; if $i &lt; $pixel_bytes</span>
<span epub:type="pagebreak" title="166" id="Page_166"/>  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (i32.lt_u (local.get $i) (local.get $pixel_bytes)) 
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> br_if $pixel_loop <span class="LiteralGray">;; break loop if all pixels set</span>
  )
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-7">Listing 8-7</a>: The <code>$clear_canvas</code> function definition</p>
<p>The <code>$clear_canvas</code> function calculates the number of pixel bytes by squaring the canvas size (because we chose a square canvas) and then multiplying by <code>4</code> because four bytes are used for each pixel. Next, we store this value, which is the number of bytes dedicated to pixel memory, in the local variable <code>$pixel_bytes</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. The function then loops <span class="CodeAnnotation" aria-label="annotation2">2</span> over each pixel, storing a hexadecimal value <code>0xff_00_00_00</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, where all the pixel colors are <code>0</code> with <code>0xff</code> (full opacity) used for the alpha value. The function increments the index stored in <code>$i</code> by <code>4</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> because four bytes are in an <code>i32</code> integer. The code checks whether the <code>$i</code> index is less than the number of pixel bytes <span class="CodeAnnotation" aria-label="annotation5">5</span> and if it is, branches back to the top of the <code>loop</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>, because if <code>$i</code> is less than the number of pixels, it means there are objects that need to be cleared.</p>
<h3 id="h2-501737c08-0008">Absolute Value Function</h3>
<p class="BodyFirst">In this app, we’ll use the box collision detection strategy, as opposed to the circle collision detection we used earlier in the book, because our objects are square. We’ll need to switch to the rectangle collision detection algorithm, which requires the code to find the absolute value of a signed integer. In <a href="#listing8-8" id="listinganchor8-8">Listing 8-8</a>, we’ll write a small <code>$abs</code> function that can take a signed integer and look to see whether the parameter passed in is negative, and if so, make it a positive number to give us that absolute value. </p>
<p class="CodeLabel"><b>collide.wat (part 3 of 12)</b></p>
<pre><code>...
<span class="LiteralGray">;; this function returns an absolute value when a value is passed in</span>
(func $abs 
  (param $value       i32) 
  (result             i32)

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (i32.lt_s (local.get $value) (i32.const 0)) <span class="LiteralGray">;; is $value negative?</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> if <span class="LiteralGray">;; if $value is negative subtract it from 0 to get the positive value</span>
    i32.const 0
    local.get $value
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.sub
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> return
  end
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> local.get $value  <span class="LiteralGray">;; return original value</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-8">Listing 8-8</a>: The absolute value function <code>$abs</code></p>
<p>The <code>$abs</code> function first looks at the value passed in and checks whether the signed value of that integer is less than <code>0</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. If it is less than <code>0</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, the <span epub:type="pagebreak" title="167" id="Page_167"/>function subtracts <span class="CodeAnnotation" aria-label="annotation3">3</span> that number from 0, negating it and returning the positive number <span class="CodeAnnotation" aria-label="annotation4">4</span>. If the number wasn’t negative, the function returns the original number <span class="CodeAnnotation" aria-label="annotation5">5</span>. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	When I originally wrote the <code>$abs</code> function, I used the 2s complement algorithm to negate the number. As it turns out, subtracting the number from 0 is faster in WebAssembly.  </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501737c08-0009">Setting a Pixel Color</h3>
<p class="BodyFirst">To draw the object to the canvas, we need to be able to set a pixel’s color in linear memory given an x- and y-coordinate and the color value. That function will need a bounds check because we’re writing to an area of linear memory set aside to represent the area of the canvas. Without this check, if we try to write to a memory location that isn’t on the canvas, the function will be writing to an area of linear memory that we might be using for some other purpose. </p>
<p>The function tests coordinates against the bounds of the canvas and returns if those coordinates are out of bounds. This determines where, in linear memory, it needs to update the pixel data. Before we look at the code, let’s quickly examine how coordinates on the canvas translate into linear memory.</p>
<p> The canvas is a 2D surface with rows and columns. <a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a> shows a simple canvas four pixels high and four pixels wide.</p>
<figure>
<img src="Images/f08001.png" alt="f08001" width="191" height="148"/>
<figcaption><p><a id="figure8-1">Figure 8-1</a>: A 4 × 4 canvas</p></figcaption></figure>
<p>Each row in the canvas has been textured differently for reasons that will become clear shortly. The canvas has x- and y-coordinates, where the x-coordinate of the first column is 0 and increments from left to right; the y-coordinate also begins at 0 and increments from top to bottom. <a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a> illustrates our 4 × 4 canvas with x- and y-coordinates.</p>
<figure>
<img src="Images/f08002.png" alt="f08002" width="202" height="164"/>
<figcaption><p><a id="figure8-2">Figure 8-2</a>: The 4 × 4 canvas in x- and y-coordinates</p></figcaption></figure>
<p><span epub:type="pagebreak" title="168" id="Page_168"/>This is how the canvas is arranged on a computer monitor, but computer memory isn’t arranged in rows and columns. Memory is one dimensional with a single address representing each pixel. For this reason, our pixel data is arranged in memory as shown in <a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a>.</p>
<figure>
<img src="Images/f08003.png" alt="f08003" width="675" height="101"/>
<figcaption><p><a id="figure8-3">Figure 8-3</a>: The 16 pixels of the canvas in linear memory</p></figcaption></figure>
<p>The rows are arranged one after the other in a 16-pixel data array. If you look at how the linear memory has arranged the pixels from the perspective of the x- and y-coordinates, it looks like <a href="#figure8-4" id="figureanchor8-4">Figure 8-4</a>.</p>
<figure>
<img src="Images/f08004.png" alt="f08004" width="675" height="113"/>
<figcaption><p><a id="figure8-4">Figure 8-4</a>: The x- and y-coordinates in linear memory</p></figcaption></figure>
<p>Our <code>$set_pixel</code> function already has the x- and y-coordinates, and needs to find the memory address. We do this using the equation <code>$y * 4 + $x</code>, which gives us the linear memory values in <a href="#figure8-5" id="figureanchor8-5">Figure 8-5</a>.</p>
<figure>
<img src="Images/f08005.png" alt="f08005" width="675" height="71"/>
<figcaption><p><a id="figure8-5">Figure 8-5</a>: The formula for translating from x-, y-coordinates to linear memory</p></figcaption></figure>
<p>Once we have the memory location, we can update linear memory using <code>i32.store</code> to set the value at that address to the color value in the parameter <code>$c</code>. <a href="#listing8-9" id="listinganchor8-9">Listing 8-9</a> shows the source code.</p>
<p class="CodeLabel"><b>collide.wat (part 4 of 12)</b></p>
<pre><code>...
<span class="LiteralGray">;; this function sets a pixel at coordinates $x, $y to the color $c</span>
(func $set_pixel
  (param $x       i32)    <span class="LiteralGray">;; x coordinate</span>
  (param $y       i32)    <span class="LiteralGray">;; y coordinate</span>
  (param $c       i32)    <span class="LiteralGray">;; color value</span>

<span class="LiteralGray">    ;; is $x &gt; $cnvs_size</span>
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (i32.ge_u (local.get $x) (global.get $cnvs_size)) 
  if    <span class="LiteralGray">;; $x is outside the canvas</span><span class="LiteralGray"> bounds</span>
    return
  end

<span epub:type="pagebreak" title="169" id="Page_169"/><span class="CodeAnnotationCode" aria-label="annotation2">2</span> (i32.ge_u (local.get $y) (global.get $cnvs_size))  <span class="LiteralGray">;; is $y &gt; $cnvs_size</span>
  if    <span class="LiteralGray">;; $y is outside the canvas</span><span class="LiteralGray"> bounds</span>
    return
  end

  local.get $y
  global.get $cnvs_size
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.mul

  local.get $x
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.add       <span class="LiteralGray">;; $x + $y * $cnvs_size (get pixels into linear memory)</span>

  i32.const 4
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> i32.mul       <span class="LiteralGray">;; multiply by 4 because each pixel is 4 bytes</span>

  local.get $c  <span class="LiteralGray">;; load color value</span>

<span class="CodeAnnotationCode" aria-label="annotation6">6</span> i32.store     <span class="LiteralGray">;; store color in memory location</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-9">Listing 8-9</a>: The function that sets an individual pixel to a given color</p>
<p>This function first does a bounds check so the user can’t try to set the color of a pixel that isn’t on our canvas. To verify that the x-coordinate is in the bounds of the canvas, we check whether <code>$x</code> is greater than <code>$cnvs_size</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, and if it is, return the function without updating memory. We do the same with the y-coordinate <span class="CodeAnnotation" aria-label="annotation2">2</span>. </p>
<p>After the bounds check, we need to retrieve the location in integers of the target pixel. We get this by multiplying <code>$y</code> by <code>$cnvs_size</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> to get the number of pixels in memory that are in the rows before the pixel and adding <span class="CodeAnnotation" aria-label="annotation4">4</span> <code>$x</code> to that value. Because the location value is in 32-bit integers (four bytes per pixel), we need to multiply that number by <code>4</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> to get the byte location of our pixel in linear memory. This memory location is where we store <code>$c</code> using a call to the <code>i32.store</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> statement.</p>
<h3 id="h2-501737c08-0010">Drawing the Object</h3>
<p class="BodyFirst">The collider objects are green squares if they don’t collide with another object and red if they do. We set the size of these squares to <code>4</code> in the JavaScript code’s constant section, so each is four pixels wide and four pixels high. We draw these pixels using a loop that increments the <code>x</code> value until it reaches the position of the object plus width. Doing so draws the first row of pixels. Once the x-coordinate value has exceeded the maximum <code>x</code>, the code increments the y-coordinate value. We then draw the second row of pixels and repeat until it exceeds the maximum <code>y</code> value of a pixel in this object. The code then breaks out of the loop. We end up with an object of 4 × 4 pixels. Let’s add the code for this function to our WAT file, as shown in <a href="#listing8-10" id="listinganchor8-10">Listing 8-10</a>.</p>
<span epub:type="pagebreak" title="170" id="Page_170"/>
<p class="CodeLabel"><b>collide.wat (part 5 of 12)</b></p>
<pre><code>...
<span class="LiteralGray">;; draw multi pixel object as a square given coordinates $x, $y and color $c</span>
(func $draw_obj 
  (param $x i32)    <span class="LiteralGray">;; x position of the object</span>
  (param $y i32)    <span class="LiteralGray">;; y position of the object</span>
  (param $c i32)    <span class="LiteralGray">;; color of the object    </span> 

  (local $max_x       i32)
  (local $max_y       i32)

  (local $xi          i32)
  (local $yi          i32)

  local.get $x
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.tee $xi
  global.get $obj_size
  i32.add
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> local.set $max_x        <span class="LiteralGray">;; $max_x = $x + $obj_size</span>

  local.get $y
  local.tee $yi
  global.get $obj_size
  i32.add
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.set $max_y        <span class="LiteralGray">;; $max_y = $y + $obj_size</span>

  (block $break (loop $draw_loop 

    local.get $xi
    local.get $yi
    local.get $c
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> call $set_pixel     <span class="LiteralGray">;; set pixel at $xi, $yi to color $c</span>

    local.get $xi
    i32.const 1
    i32.add
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> local.tee $xi       <span class="LiteralGray">;; $xi++</span>

    local.get $max_x
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> i32.ge_u            <span class="LiteralGray">;; is $xi &gt;= $max_x</span>

    if
      local.get $x
    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> local.set $xi     <span class="LiteralGray">;; reset $xi to $x</span>

      local.get $yi
      i32.const 1
      i32.add
    <span class="CodeAnnotationCode" aria-label="annotation8">8</span> local.tee $yi     <span class="LiteralGray">;; $yi++</span>

      local.get $max_y
    <span class="CodeAnnotationCode" aria-label="annotation9">9</span> i32.ge_u          <span class="LiteralGray">;; is $yi &gt;= $max_y</span>

<span epub:type="pagebreak" title="171" id="Page_171"/>      br_if $break

    end
    br $draw_loop
  ))
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-10">Listing 8-10</a>: The <code>$draw_obj</code> function draws a square of pixels calling the <code>$set_pixel</code> function.</p>
<p>The <code>$draw_obj</code> function takes as parameters the x- and y-coordinates, and color in the form of <code>param</code><code> i32</code> variables <code>$x</code>, <code>$y</code>, and <code>$c</code>. It draws pixels starting at the <code>$x </code>position for the x-coordinate and <code>$y</code> for the y-coordinate. It needs to loop over each pixel until it reaches a <code>$max_x</code> and <code>$max_y</code> position for the x- and y-coordinates. The function begins by using <code>local.tee</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to set the value of <code>$xi</code> to the value passed to the function as <code>$x</code>. It then adds the object’s size (<code>$obj_size</code>) to find the <code>$max_x</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> value. Thereafter, the function finds <code>$max_y</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> in the same way. </p>
<p>We find the starting and ending x-coordinates, and then do the same task for the y-axis <span class="CodeAnnotation" aria-label="annotation4">4</span>. I chose 512 as the width and height of the canvas because I assumed this kind of mask would offer better performance than using an <code>i32.rem_u</code> for a canvas bounds check. In <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, we’ll test this hypothesis to see whether this was a valid assumption or a premature optimization. <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> went into detail as to how bit masking works.</p>
<p>The minimum and maximum <code>x</code> and <code>y</code> values enter a loop that draws each pixel using a <code>call</code><code> $set_pixel</code> expression <span class="CodeAnnotation" aria-label="annotation5">5</span>. The loop increments <code>$xi</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> and compares it with <code>$max_x</code>, resetting <code>$xi</code> to <code>$x</code> and incrementing <code>$yi</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> if <code>$xi</code> is greater than or equal to <code>$max_x</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>. Then, when <code>$yi</code> has exceeded <code>$max_y</code>, the object is fully drawn and the code exits the loop.</p>
<h3 id="h2-501737c08-0011">Setting and Getting Object Attributes</h3>
<p class="BodyFirst">Let’s create a few helper functions to set and get object attribute values inside linear memory. These functions take in an object number and an attribute offset and return the value from linear memory. In the case of <code>$set_obj_attr</code>, the function also takes a value and sets the object attribute to that value. In the case of <code>$get_obj_attr</code>, the function returns the value in linear memory for that object and attribute. Add the code in <a href="#listing8-11" id="listinganchor8-11">Listing 8-11</a> for <code>$set_obj_attr</code> to your WAT module.</p>
<p class="CodeLabel"><b>collide.wat (part 6 of 12)</b></p>
<pre><code>...
<span class="LiteralGray">;; set the attribute of an object in linear memory using the object number,</span>
<span class="LiteralGray">;; the attributes offset and a value used to set the attribute</span>
(func $set_obj_attr
  (param $obj_number  i32)
  (param $attr_offset i32)
  (param $value       i32)

  local.get $obj_number

<span epub:type="pagebreak" title="172" id="Page_172"/>  i32.const 16
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> i32.mul                 <span class="LiteralGray">;;  16 byte stride multiplied by the object number </span>

  global.get $obj_start   <span class="LiteralGray">;;  add the starting byte for the objects (base)</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.add                 <span class="LiteralGray">;;  ($obj_number*16) + $obj_start</span>

  local.get $attr_offset  <span class="LiteralGray">;; add the attribute offset to the address</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.add                 <span class="LiteralGray">;; ($obj_number*16) + $obj_start + $attr_offset</span>

  local.get $value

<span class="LiteralGray">  ;; store $value at location ($obj_number*16)+$obj_start+$attr_offset</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.store  
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-11">Listing 8-11</a>: Setting an object in memory based on a stride value of 16</p>
<p>Most of the code in this function calculates the address in linear memory where the attribute for the specific object is stored. Recall from <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> that we calculated the memory location of our attribute using a base address (<code>$obj_start</code> in this function), a stride of <code>16</code>, an object number (<code>$obj_number</code>), and an attribute offset (<code>$attr_offset</code>). This function uses the formula <code>$obj_number</code>*<code>16</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> + <code>$obj_start</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> + <code>$attr_offset</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> to determine the memory location of the attribute we want to modify. It then calls the <code>i32.store</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> statement to store that value in memory.</p>
<p>Next, we’ll create the corresponding <code>$get_obj_attr</code>, which needs to calculate the address of the attribute value. You might be familiar with the software development principle <em>Don’t Repeat Yourself (DRY)</em>. DRY code is an excellent way to write maintainable code that is easy for other developers to read and update. Unfortunately, there are times when DRY code can reduce performance. In this example, we’ll redo some of the calculations we did in the previous function. When we venture into the performance optimization chapter, we’ll make our code even less DRY (sometimes called <em>wet code</em>) than it was in this chapter. Some techniques that produce DRY code can add layers of abstraction that require additional computing cycles. For example, a function call requires additional cycles to push values onto the stack and jump to new locations in the code. Optimizing compilers can frequently mitigate the impact of abstractions used in the code, but it can be helpful to understand how they do this and why DRY code isn’t always the most efficient during execution.</p>
<p>In other assembly languages, macros are a great way to maintain performance while keeping your code relatively DRY. Unfortunately, <code>wat2wasm</code> doesn’t currently support macros. <a href="#listing8-12" id="listinganchor8-12">Listing 8-12</a> shows the code for the <code>$get_obj_attr</code> function.</p>
<p class="CodeLabel"><b>collide.wat (part 7 of 12)</b></p>
<pre><code>...
<span class="LiteralGray">;; get the attribute of an object in linear memory using the object</span>
<span class="LiteralGray">;; number, and the attributes offset</span>
(func $get_obj_attr
  (param $obj_number  i32)
<span epub:type="pagebreak" title="173" id="Page_173"/>  (param $attr_offset i32)
  (result i32)

  local.get $obj_number
  i32.const 16
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> i32.mul                 <span class="LiteralGray"> ;; $obj_number * 16</span>

  global.get $obj_start
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.add                  <span class="LiteralGray">;; ($obj_number*16) + $obj_start</span>

  local.get $attr_offset
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.add                  <span class="LiteralGray">;; ($obj_number*16) + $obj_start + $attr_offset</span>

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.load                 <span class="LiteralGray">;; load the pointer above</span>
<span class="LiteralGray">  ;; returns the attribute</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-12">Listing 8-12</a>: Gets an object in memory based on a stride value of 16</p>
<p>To get the offset bytes for an object, we start by multiplying <code>$obj_number</code> by the stride value of <code>16</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. Then we add <span class="CodeAnnotation" aria-label="annotation2">2</span> the base address, which is stored in the global variable <code>$obj_start</code>. That’s followed by adding the offset, stored in <code>$attr_offset</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. At this point, the top of the stack has the location in memory of the attribute we want to retrieve, so calling the expression <code>i32.load</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> pushes that value onto the stack.</p>
<h3 id="h2-501737c08-0012">The $main Function</h3>
<p class="BodyFirst">The <code>$main</code> function will be called from the JavaScript code once per frame render. Its job is to move every object based on that object’s velocity, detect a collision between objects, and then render the object in red if it collides with another object and green if it doesn’t. The <code>$main</code> function is very long, so we’ll break it into several parts.</p>
<h4 id="h3-501737c08-0001">Defining Local Variables</h4>
<p class="BodyFirst">The first part of the <code>$main</code> function, shown in <a href="#listing8-13" id="listinganchor8-13">Listing 8-13</a>, defines all the local variables and calls the <code>$clear_canvas</code> function.</p>
<p class="CodeLabel"><b>collide.wat (part 8 of 12)</b></p>
<pre><code>...
<span class="LiteralGray">;; move and detect collisions between all of the objects in our app</span>
(func $main (export "main")
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (local $i           i32)<span class="LiteralGray">  ;; outer loop index</span>
<span class="LiteralGray">  </span>(local $j           i32)<span class="LiteralGray">  ;; inner loop index</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (local $outer_ptr   i32)<span class="LiteralGray">  ;; pointer to outer loop object</span>
<span class="LiteralGray">  </span>(local $inner_ptr   i32)<span class="LiteralGray">  ;; pointer to inner loop object</span>

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (local $x1          i32)<span class="LiteralGray">  ;; outer loop object x coordinate</span>
<span class="LiteralGray">  </span>(local $x2          i32)<span class="LiteralGray">  ;; inner loop object x coordinate</span>
  (local $y1          i32)<span class="LiteralGray">  ;; outer loop object y coordinate</span>
  (local $y2          i32)<span class="LiteralGray">  ;; inner loop object y coordinate</span>

<span epub:type="pagebreak" title="174" id="Page_174"/><span class="CodeAnnotationCode" aria-label="annotation4">4</span> (local $xdist       i32)<span class="LiteralGray">  ;; distance between objects on x axis</span>
<span class="LiteralGray">  </span>(local $ydist       i32)<span class="LiteralGray">  ;; distance between objects on y axis</span>

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (local $i_hit       i32)<span class="LiteralGray">  ;; i object hit boolean flag</span>
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> (local $xv          i32)<span class="LiteralGray">  ;; x velocity</span>
<span class="LiteralGray">  </span>(local $yv          i32)<span class="LiteralGray">  ;; y velocity</span>

<span class="CodeAnnotationCode" aria-label="annotation7">7</span> (call $clear_canvas)<span class="LiteralGray">      ;; clear the canvas to black</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-13">Listing 8-13</a>: The beginning of the <code>$main</code> function declares the local variables and clears the canvas.</p>
<p>This function has a double loop that compares every object with every other object. To do this, we define two loop variables, <code>$i</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>$j</code>, which will be loop counters for our outer and inner loops, respectively. We need to loop over every object using the <code>$i</code> variable and compare it to every other object using the <code>$j</code> variable. Then we use two pointer variables, <code>$outer_ptr</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>$inner_ptr</code>, that point to the linear memory location for those two collider objects.</p>
<p>The next four local variables are the x- and y-coordinates <span class="CodeAnnotation" aria-label="annotation3">3</span> for the inner and outer loop objects. The distance between the x- and y-coordinates of the two objects are stored in the <code>$xdist</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> and <code>$ydist</code> local variables. The <code>$i_hit</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> local variable is a boolean flag that is set to <code>1</code> if the <code>$i</code> object collides with another object and <code>0</code> if it doesn’t. Two variables, <code>$xv</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> and <code>$yv</code>, store the velocity of the <code>$i</code> object. After the local variables are declared, the function performs the first action: clear all the canvas pixels to black using the statement <code>(call</code><code> $clear_canvas)</code><span class="CodeAnnotation" aria-label="annotation7">7</span>.</p>
<h4 id="h3-501737c08-0002">The $move_loop</h4>
<p class="BodyFirst">The next part of the <code>$main</code> function defines a loop that moves every object in linear memory each frame. This part of the function will retrieve the <code>$x</code>, <code>$y</code>, <code>$xv</code>, and <code>$yv</code> attributes for the <code>$i</code> object. The <code>$xv</code> and <code>$yv</code> variables are the <code>x</code> and <code>y</code> velocity variables, and they’re used to move the object by changing the <code>$x</code> and <code>$y</code> coordinate values. The code also forces the <code>x</code> and <code>y</code> values to stay within the bounds of the canvas. Immediately after the move loop, the <code>$i</code> variable is reset to <code>0</code>. Add the code in <a href="#listing8-14" id="listinganchor8-14">Listing 8-14</a> to the WAT module.</p>
<p class="CodeLabel"><b>collide.wat (part 9 of 12)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (loop $move_loop
 <span class="LiteralGray">   ;; get x attribute</span>
    (call $get_obj_attr (local.get $i) (global.get $x_offset))
    local.set $x1

   <span class="LiteralGray"> ;; get y attribute</span>
    (call $get_obj_attr (local.get $i) (global.get $y_offset)) 
    local.set $y1

    <span class="LiteralGray">;; get x velocity attribute</span>
    (call $get_obj_attr (local.get $i) (global.get $xv_offset)) 
    local.set $xv
<span epub:type="pagebreak" title="175" id="Page_175"/>
    <span class="LiteralGray">;; get y velocity attribute</span>
    (call $get_obj_attr (local.get $i) (global.get $yv_offset)) 
    local.set $yv

    <span class="LiteralGray">;; add velocity to x and force it to stay in the canvas bounds</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (i32.add (local.get $xv) (local.get $x1))
    i32.const 0x1ff  <span class="LiteralGray">;; 511 in decimal</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.and          <span class="LiteralGray">;; clear high-order 23 bits</span>
    local.set $x1

    <span class="LiteralGray">;; add velocity to y and force it to stay in the canvas bounds</span>
    (i32.add (local.get $yv) (local.get $y1))
    i32.const 0x1ff  <span class="LiteralGray">;; 511 in decimal</span>
    i32.and          <span class="LiteralGray">;; clear high-order 23 bits</span>
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.set $y1

    <span class="LiteralGray">;; set the x attribute in linear memory</span>
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (call $set_obj_attr 
    (local.get $i) 
    (global.get $x_offset)
    (local.get $x1)
  )

    <span class="LiteralGray">;; set the y attribute in linear memory</span>
    (call $set_obj_attr 
    (local.get $i) 
    (global.get $y_offset)
    (local.get $y1)
  )

  local.get $i
  i32.const 1
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> i32.add
<span class="CodeAnnotationCode" aria-label="annotation7">7</span> local.tee $i        <span class="LiteralGray">;; increment $i</span>

  global.get $obj_cnt
  i32.lt_u            <span class="LiteralGray">;; $i &lt; $obj_cnt</span>

<span class="CodeAnnotationCode" aria-label="annotation8">8</span> if  <span class="LiteralGray">;; if $i &lt; $obj_count branch back to top of $move_loop</span>
    br $move_loop
  end

 )

  i32.const 0
<span class="CodeAnnotationCode" aria-label="annotation9">9</span> local.set $i
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-14">Listing 8-14</a>: Loop to move each object</p>
<p>The code in <a href="#listing8-14">Listing 8-14</a> loops through all of our objects, changing the x- and y-coordinates based on the <code>x </code>and <code>y</code> velocities. The first few lines of the loop <span class="CodeAnnotation" aria-label="annotation1">1</span> call <code>$get_obj_attr</code> for the <code>x</code> position, <code>y</code> position, <code>x</code> velocity, and <code/><span epub:type="pagebreak" title="176" id="Page_176"/>y velocity attributes, passing in the loop index and the offset of the attribute to be set. Doing this pushes the value of the attribute onto the stack. The expression <code>local.set</code> is then used to set a local variable we’ll use in the <code>loop</code>.</p>
<p>The <code>loop</code> will add the velocity variables (<code>$xv</code> and <code>$yv</code>) to the position variables <code>($x1</code> and <code>$y1</code>) with a call to <code>i32.add</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. Before <code>$x1</code> is set to the new position, an <code>i32.and</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> is used to mask the last nine bits of the <code>x</code> position. This holds the value of the x-coordinate between 0 and 511, wrapping the value back around to 0 if it exceeds 511. The same is then done for <code>$y1</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to set the <code>y</code> position. Once the new values of <code>$x1</code> and <code>$y1</code> are set, the <code>$set_obj_attr</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> function is called for those values to set them in linear memory. The loop counter <code>$i</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> is incremented with a call to <code>i32.and</code> and <code>local.tee</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>. If the value in <code>$i</code> is less than the object count (<code>$obj_count</code> <span class="CodeAnnotation" aria-label="annotation8">8</span>), the code branches back to the top of the <code>loop</code>. Otherwise, <code>local.set</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> is called to set <code>$i</code> to <code>0</code>.</p>
<p>The squares in <a href="#listing8-14">Listing 8-14</a> wrap around on the canvas so when one goes offscreen on the right, it loops back around and appears on the left side of the screen, as in the old-school arcade games. Games like Atari’s <em>Asteroids</em> and Namco’s <em>Pac-Man</em> didn’t need any extra code to have this effect; instead, their screens were 256 pixels wide and used an 8-bit number to store the x-coordinate. So if a game object had an x-coordinate of 255 and moved one pixel to the right, the single byte value would roll back over to 0, and the game object would reappear on the left side of the screen, as shown in <a href="#figure8-6" id="figureanchor8-6">Figure 8-6</a>.</p>
<figure>
<img src="Images/f08006.png" alt="f08006" width="701" height="488"/>
<figcaption><p><a id="figure8-6">Figure 8-6</a>: Player’s character goes off the screen to the right and appears on the left.</p></figcaption></figure>
<p><span epub:type="pagebreak" title="177" id="Page_177"/>We can accomplish this effect using <code>i32.and</code> to mask all but the bottom nine bits. The code calls <code>$get_obj_attr</code> to get the attributes for <code>$x1</code>, <code>$y1</code>, <code>$xv</code>, and <code>$yv</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. The new <code>$x1</code> value is calculated by adding <code>$xv</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and then using the <code>i32.and</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> against the constant <code>0x1ff</code>. In binary, <code>0x1ff</code> has the lowest nine bits all set to 1, and all the higher bits are set to 0. <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> explained how to use an <code>i32.and</code> to set specific bits to 0, as illustrated in <a href="#figure8-7" id="figureanchor8-7">Figure 8-7</a>.</p>
<figure>
<img src="Images/f08007.png" alt="f08007" width="701" height="683"/>
<figcaption><p><a id="figure8-7">Figure 8-7</a>: The 0s in our mask turn any values in the initial value to 0.</p></figcaption></figure>
<p>When we call <code>i32.and</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> on <code>$x1</code> and <code>0x1ff</code> (binary 00000000000000000000000111111111), the resulting value has the top 23 bits set to 0. That limits the <code>$x1</code> value to nine bits, so if the number goes above what a 9-bit number can hold, the <code>$x1</code> value rolls back over, similar to an odometer. That creates an old-school arcade effect where objects that move offscreen to the left reappear on the right, and objects that move offscreen on the top reappear on the bottom of the screen.</p>
<p><span epub:type="pagebreak" title="178" id="Page_178"/>After making changes to the x- and y-coordinates, the <code>$i</code> index is incremented <span class="CodeAnnotation" aria-label="annotation8">8</span>, and if <code>$i</code> is less than <code>$obj_count</code>, the code branches back to the top of the <code>$move_loop</code>. When the loop is complete, the <code>$i</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> index variable is reset to <code>0</code>.</p>
<h4 id="h3-501737c08-0003">Beginning of the Outer Loop</h4>
<p class="BodyFirst">Now we need to define our double loop, which compares every object against every other object to see whether any collisions have occurred. The next part of the <code>$main</code> function defines the outer loop of our double loop, which will determine the first object of our collision test. The loop begins by initializing <code>$j</code> to <code>0</code>. The <code>$i</code> local variable is the increment variable for the outer loop. The inner loop will use <code>$j</code> to loop through all the objects to check each one against <code>$i</code> until it finds a collision or makes its way through every object. The outer loop starts with the first object, and then the inner loop checks that object for a collision with every other object. This continues until the outer loop has checked every object. Add the code in <a href="#listing8-15" id="listinganchor8-15">Listing 8-15</a> to the <code>$main</code> function.</p>
<p class="CodeLabel"><b>collide.wat (part 10 of 12)</b></p>
<pre><code>...
  (loop $outer_loop (block $outer_break
    i32.const 0
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.tee $j        <span class="LiteralGray">;; setting j to 0</span>

    <span class="LiteralGray">;; $i_hit is a boolean value.  0 for false, 1 for true</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> local.set $i_hit    <span class="LiteralGray">;; setting i_hit to 0</span>

   <span class="LiteralGray"> ;; get x attribute for object $i</span>
    (call $get_obj_attr (local.get $i) (global.get $x_offset))
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.set $x1

    <span class="LiteralGray">;; get y attribute for object $i</span>
    (call $get_obj_attr (local.get $i) (global.get $y_offset))
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.set $y1
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-15">Listing 8-15</a>: The outer loop of a collision detection double loop</p>
<p>The beginning of the loop resets <code>$j</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>$i_hit</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to <code>0</code>. The code then calls the <code>$get_obj_attr</code> function to find the values for <code>$x1</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and <code>$y1</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<h4 id="h3-501737c08-0004">The Inner Loop</h4>
<p class="BodyFirst">The next section of the <code>$main</code> function is the inner loop, whose function is to detect a collision between two squares. Square collision detection is very simple: you compare the x-coordinates and size to see whether the objects overlap on the x-axis. If the x-axis doesn’t overlap but the y-axis does, it looks like <a href="#figure8-8" id="figureanchor8-8">Figure 8-8</a> and has no collision.</p>
<p>If the x-axis overlaps but the y-axis doesn’t, there is no collision between the objects, as in <a href="#figure8-9" id="figureanchor8-9">Figure 8-9</a>.</p>
<span epub:type="pagebreak" title="179" id="Page_179"/><figure>
<img src="Images/f08008.png" alt="f08008" width="526" height="442"/>
<figcaption><p><a id="figure8-8">Figure 8-8</a>: The x-axis doesn’t overlap but the y-axis does.</p></figcaption></figure>
<figure>
<img src="Images/f08009.png" alt="f08009" width="526" height="630"/>
<figcaption><p><a id="figure8-9">Figure 8-9</a>: The x-axis overlaps but the y-axis doesn’t.</p></figcaption></figure>
<p><span epub:type="pagebreak" title="180" id="Page_180"/>The only collision scenario is when the x-axis and y-axis overlap, as in <a href="#figure8-10" id="figureanchor8-10">Figure 8-10</a>.</p>
<figure>
<img src="Images/f08010.png" alt="f08010" width="561" height="582"/>
<figcaption><p><a id="figure8-10">Figure 8-10</a>: The x-axis and y-axis overlap, so there is a collision.</p></figcaption></figure>
<p>The inner loop performs this check against every object in linear memory. <a href="#listing8-16" id="listinganchor8-16">Listing 8-16</a> shows the code.</p>
<p class="CodeLabel"><b>collide.wat (part 11 of 12)</b></p>
<pre><code>...
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (loop $inner_loop (block $inner_break
      local.get $i
      local.get $j
      i32.eq
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> if              <span class="LiteralGray">;; if $i == $j increment $j</span>
        local.get $j
        i32.const 1
        i32.add
        local.set $j
      end

      local.get $j
      global.get $obj_cnt
      i32.ge_u
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if              <span class="LiteralGray">;; if $j &gt;= $obj_count break from inner loop</span>
        br $inner_break
      end

<span epub:type="pagebreak" title="181" id="Page_181"/><span class="LiteralGray">       ;; get x attribute</span>
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (call $get_obj_attr (local.get $j)(global.get $x_offset)) 
      local.set $x2  <span class="LiteralGray">;; set the x attribute for inner loop object</span>

<span class="LiteralGray">       ;; distance between $x1 and $x2</span>
      (i32.sub (local.get $x1) (local.get $x2))

      call $abs  <span class="LiteralGray">;; distance is not negative so get the absolute value</span>
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> local.tee $xdist  <span class="LiteralGray">;; $xdist = the absolute value of ($x1 - $x2)</span>

      global.get $obj_size
      i32.ge_u 

    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> if  <span class="LiteralGray">;; if $xdist &gt;= $obj_size object does not collide</span>
        local.get $j
        i32.const 1
        i32.add
        local.set $j

        br $inner_loop  <span class="LiteralGray">;; increment $j and jump to beginning of inner loop</span>
      end

<span class="LiteralGray">       ;; get y attribute</span>
      (call $get_obj_attr (local.get $j)(global.get $y_offset))
      local.set $y2

      (i32.sub (local.get $y1) (local.get $y2))
      call $abs
    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> local.tee $ydist

      global.get $obj_size
      i32.ge_u 

    <span class="CodeAnnotationCode" aria-label="annotation8">8</span> if
        local.get $j
        i32.const 1
        i32.add
        local.set $j

        br $inner_loop
      end

      i32.const 1
    <span class="CodeAnnotationCode" aria-label="annotation9">9</span> local.set $i_hit
<span class="LiteralGray">      ;; exit the loop if there is a collision</span>
<span class="LiteralGray">    </span>))<span class="LiteralGray"> ;; end of inner loop</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing8-16">Listing 8-16</a>: The inner loop of a collision detection double loop</p>
<p>The inner <code>loop</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> compares the current object of the outer loop against every other object that hasn’t already been checked against it. First, it needs to make sure it’s not checking an object against itself. An object always completely collides with itself, so if <code>$i</code> is equal to <code>$j </code><span class="CodeAnnotation" aria-label="annotation2">2</span>, we ignore it and need to <span epub:type="pagebreak" title="182" id="Page_182"/>increment <code>$j</code>. Then we compare <code>$j</code> with <code>$obj_cnt</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> to see whether the code has tested all the objects yet. If it has, the code exits the inner <code>loop</code></p>.
<p>If the code hasn’t tested all objects, the <code>x</code> attribute is loaded into the <code>$x2</code> variable by calling <code>$get_obj_attr</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. We then get the distance between <code>$x1</code> and <code>$x2</code> by subtracting <code>$x2</code> from <code>$x1</code>, taking the absolute value and setting the <code>$xdist</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> variable. We compare the <code>x</code> distance between the two objects to the object size to see whether the two objects overlap on the x-axis. If they don’t overlap because <code>$xdist</code> is greater than <code>$obj_size</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>, the code increments <code>$j</code> and jumps back to the top of the <code>loop</code>.</p>
<p>In the same way, the <code>y</code> distance is calculated and stored in the <code>$ydist</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> variable, and the code checks whether the <code>$ydist</code> variable is greater than <code>$obj_size</code> <span class="CodeAnnotation" aria-label="annotation8">8</span>. If so, these objects don’t collide, so we increment <code>$j</code> and jump back to the top of the <code>loop</code>. If we haven’t jumped to the top of the loop at this point, we know that the x- and y-axis of the objects overlap, indicating a collision, so we set <code>$i_hit</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> to <code>1</code> and exit the inner <code>loop</code>.</p>
<h4 id="h3-501737c08-0005">Redrawing the Objects</h4>
<p class="BodyFirst">When the code has exited the inner loop, either a collision was found or it wasn’t. The code checks the hit variable (<code>$i_hit</code>) and calls the <code>$draw_obj</code> function with the no collision color (green) if there wasn’t a collision and with the <code>$hit_color</code> (red) if there was a collision. Then <code>$</code>i is incremented, and if <code>$i</code> is less than the number of objects, the code jumps back to the top of the outer loop. <a href="#listing8-17" id="listinganchor8-17">Listing 8-17</a> shows the last section of code to add to the WAT file.</p>
<p class="CodeLabel"><b>collide.wat (part 12 of 12)</b></p>
<pre><code>...
    local.get $i_hit
    i32.const 0
    i32.eq
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> if      <span class="LiteralGray">;; if $i_hit == 0 (no hit)</span>
      (call $draw_obj
        (local.get $x1) (local.get $y1)  (global.get $no_hit_color))
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> else    <span class="LiteralGray">;; if $i_hit == 1 (hit)</span>
      (call $draw_obj
        (local.get $x1) (local.get $y1) (global.get $hit_color))
    end

    local.get $i
    i32.const 1
    i32.add
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.tee $i          <span class="LiteralGray">;; increment $i</span>

    global.get $obj_cnt
    i32.lt_u
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> if                    <span class="LiteralGray">;; if $i &lt; $obj_cnt jump to top of the outer loop</span>
      br $outer_loop
    end
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> )) <span class="LiteralGray">;; end of outer loop</span>
) <span class="LiteralGray">;; end of function</span>
)<span class="LiteralGray"> ;; end of module</span></code></pre>
<p class="CodeListingCaption"><a id="listing8-17">Listing 8-17</a>: Drawing the object inside the inner loop</p>
<p><span epub:type="pagebreak" title="183" id="Page_183"/>Immediately after the inner loop ends, the outer loop checks whether the <code>$i_hit</code> variable was set to <code>0</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> , indicating no collision. If it was, <code>$draw_obj</code> is called, passing in the <code>$no_hit_color</code> global variable as the last parameter and drawing the square in green. If the <code>$i_hit</code> variable is set to <code>1</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> (true), <code>$draw_obj</code> is called with <code>$hit_color</code> (red). At this point, <code>$i</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> is incremented, and if it’s less than <code>$obj_cnt</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, indicating we’ve not completed drawing our objects, the code jumps back to the top of the loop. If not <span class="CodeAnnotation" aria-label="annotation5">5</span>, the code exits the loop and this function is complete.</p>
<h3 id="h2-501737c08-0013">Compiling and Running the App</h3>
<p class="BodyFirst">Before we run the collider application, we need to compile our WAT into a WebAssembly module. Use the following <code>wat2wasm</code> command to compile <em>collide.wat</em> into <em>collide.wasm</em>:</p>
<pre><code>wat2wasm collide.wat</code></pre>
<p>When you run a web server and open the <em>collide.html</em> file in a web browser from localhost, your screen should look similar to <a href="#figure8-11" id="figureanchor8-11">Figure 8-11</a>.</p>
<figure>
<img src="Images/f08011.png" alt="f08011" width="439" height="439"/>
<figcaption><p><a id="figure8-11">Figure 8-11</a>: The collider app</p></figcaption></figure>
<p>The boxes should move about the canvas, appearing on the left side of the canvas when they move off the right side and on the top when they move off the bottom. Boxes that collide with each other appear in red, and boxes that don’t collide with other boxes appear in green.</p>
<h2 id="h1-501737c08-0003"><span epub:type="pagebreak" title="184" id="Page_184"/>Summary</h2>
<p class="BodyFirst">In this chapter, we explored how WebAssembly and the HTML canvas can work together to create fantastic animations on a web page. You should now understand when it’s best to use WebAssembly and when using JavaScript is a better option. Rendering to the canvas from WebAssembly can be done quickly and efficiently by modifying memory locations that represent bitmap data. The collider app we created used many JavaScript constants to define its details. That allowed us to tweak and play with the numbers in the app without recompiling the WebAssembly module. JavaScript can easily generate random numbers that we can use in the app. Generating random numbers from WebAssembly is much more challenging. Because the random numbers only need to be generated once, using JavaScript isn’t a significant performance hit.</p>
<p>You learned about bitmap image data and how to use WebAssembly to generate that image data inside linear memory. We used the <code>requestAnimationFrame</code> function from within JavaScript to call the WebAssembly module once per frame, using WebAssembly to generate the bitmap image data to be used in the canvas. This image data is moved into the HTML canvas using the <code>putImageData</code> function on the canvas context.</p>
<p>In the WAT module code, we set up and modified an area of memory dedicated to the image data, and created a canvas clearing function. We drew a specific pixel color to the canvas; then we drew objects larger than a single pixel and made those objects appear at the opposite side of the canvas when they moved out of the element’s bounds. Lastly, we used box collision detection to detect and change the color of our objects if there were collisions between objects.</p>
<p>We didn’t spend a lot of time or effort trying to make the collider application fast. In the next chapter, we’ll make this application run as fast as possible with some performance tuning.</p>
</section>
</div></body></html>