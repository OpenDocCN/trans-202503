<html><head></head><body>
<h2 class="h2" id="ch18"><span epub:type="pagebreak" id="page_253"/><span class="big">18</span><br/>CREATING AND CONFIGURING A SQL SERVER</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">So far, you’ve created a module that can create a VM, attach a VHD to it, install Windows, and create (and populate) an Active Directory forest. Let’s add one more thing to that list: deploying a SQL server. With a VM provisioned, an OS installed, and a domain controller</span> set up, you’ve done most of the hard work! Now you just need to leverage your existing functions and, with a few tweaks, you’ll be able to install a SQL server.</p>&#13;
<h3 class="h3" id="ch18lev1">Prerequisites</h3>&#13;
<p class="noindent">Throughout this chapter, I’m assuming that you’ve been following along in <a href="part3.xhtml#part3">Part III</a> and have created at least one VM called LABDC that’s running on your Hyper-V host. This VM will be a domain controller, and since you’ll again be connecting to multiple VMs via PowerShell Direct, you’ll need the domain credential saved to the Hyper-V host (check out <a href="ch17.xhtml#ch17">Chapter 17</a> to see how we did this).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_254"/>You’ll use a script called <em>ManuallyCreatingASqlServer.ps1</em> (found in this chapter’s resources) to explain how to properly automate the deploying of a SQL server. This script contains all the rough steps covered in this chapter and will be a great resource to reference as you progress through this chapter.</p>&#13;
<p class="indent">As always, please run the Prerequisites test script included with this chapter to ensure you meet all the expected prerequisites.</p>&#13;
<h3 class="h3" id="ch18lev2">Creating the Virtual Machine</h3>&#13;
<p class="noindent">When you think <em>SQL Server</em>, you probably think about things like databases, jobs, and tables. But before you can even get there, a ton of background work has to be done: for starters, every SQL database must exist on a server, every server needs an operating system, and every operating system needs a physical or virtual machine to be installed on. Luckily, you’ve spent the past few chapters setting up the exact environment you need to create a SQL server.</p>&#13;
<p class="indent">A good automator starts every project by breaking down all the required dependencies. They automate around those dependencies, and then on top of them. This process results in a modular, decoupled architecture that has the flexibility to be changed at any time with relative ease.</p>&#13;
<p class="indent">What you’re ultimately looking for is a single function that uses a standard configuration to bring up any number of SQL servers. But to get there, you have to think about this project in layers. The first layer is the virtual machine. Let’s handle that first.</p>&#13;
<p class="indent">Since you already have a function in your PowerLab module that’ll build a VM, you’ll use that. Because all lab environments you build are going to be the same, and because you defined many of the parameters needed to provision a new VM as default parameter values in the <code>New-PowerLabVM</code> function, the only value you need to pass to this function is the VM name:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabVm -Name 'SQLSRV'</span></pre>&#13;
<h3 class="h3" id="ch18lev3">Installing the Operating System</h3>&#13;
<p class="noindent">Just like that, you have a VM ready to go. That was easy. Let’s do it again. Use the command you wrote in <a href="ch16.xhtml#ch16">Chapter 16</a> to install Windows on your VM:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Install-PowerLabOperatingSystem -VmName 'SQLSRV'</span>&#13;
Get-Item : Cannot find path 'C:\Program Files\WindowsPowerShell\Modules\&#13;
powerlab\SQLSRV.xml' because it does not exist.&#13;
At C:\Program Files\WindowsPowerShell\Modules\powerlab\PowerLab.psm1:138 char:16&#13;
+     $answerFile = Get-Item -Path "$PSScriptRoot\$VMName.xml"&#13;
+                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
    + CategoryInfo          : ObjectNotFound: (C:\Program File...rlab\SQLSRV&#13;
                              .xml:String) [Get-Item], ItemNotFoundException</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>Oops! You used the existing <code>Install-PowerLabOperatingSystem</code> function in the PowerLab module to install the operating system on the soon-to-be SQL server, but it failed because it was referencing a file called <em>SQLSRV.xml</em> in the module folder. When you built this function, you assumed there would be an <em>.xml</em> file in the module folder. Problems like path discrepancies and files that don’t exist are common when building large automation projects like this. You’ll have many dependencies that you must address. The only way to flush out all these bugs is to execute the code as many times as possible in as many scenarios as possible.</p>&#13;
<h3 class="h3" id="ch18lev4">Adding a Windows Unattended Answer File</h3>&#13;
<p class="noindent">The <code>Install-PowerLabOperatingSystem</code> function was assuming there would always be a file called <em>.xml</em> in the PowerLab module folder. This means that before you deploy a new server, you have to first ensure that you have this file in the right place. Luckily, now that you created the LABDC unattended answer file, this should be easy. The first thing you have to do is copy the already-existing <em>LABDC.xml</em> file and call it <em>SQLSRV.xml</em>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Copy-Item -Path 'C:\Program Files\WindowsPowerShell\Modules\PowerLab\LABDC.xml' -Destination</span>&#13;
<span class="codestrong1">'C:\Program Files\WindowsPowerShell\Modules\PowerLab\SQLSRV.xml'</span></pre>&#13;
<p class="indent">Once you’ve made a copy, you have to make a few tweaks: the name of the host and the IP address. Since you haven’t deployed a DHCP server, you’ll use static IP addresses and have to change them (otherwise you’d have to change just the server name).</p>&#13;
<p class="indent">Open <em>C:\Program Files\WindowsPowerShell\Modules\SQLSRV.xml</em> and look for the spot that defines the hostname. Once you find it, change the <code>ComputerName</code> value. It should look similar to this:</p>&#13;
<pre>&lt;component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64"&#13;
publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" &#13;
    xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" &#13;
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;&#13;
    &lt;ComputerName&gt;SQLSRV&lt;/ComputerName&gt;&#13;
    &lt;ProductKey&gt;XXXXXXXXXXXXX&lt;/ProductKey&gt;&#13;
&lt;/component&gt;</pre>&#13;
<p class="indent">Next, look for the <code>UnicastIPAddress</code> node. It will look like the following code. Note I’m using a 10.0.0.0/24 network and have chosen to make my SQL server have the IP address of 10.0.0.101:</p>&#13;
<pre>&lt;UnicastIpAddresses&gt;&#13;
    &lt;IpAddress wcm:action="add" wcm:keyValue="1"&gt;10.0.0.101&lt;/IpAddress&gt;&#13;
&lt;/UnicastIpAddresses&gt;</pre>&#13;
<p class="indent">Save the <em>SQLSRV.xml</em> file and try running the <code>Install-PowerLabOperatingSystem</code> command again. At this time, your command should run successfully and should deploy Windows Server 2016 to your SQLSRV VM.</p>&#13;
<h3 class="h3" id="ch18lev5"><span epub:type="pagebreak" id="page_256"/>Adding the SQL Server to a Domain</h3>&#13;
<p class="noindent">You just installed the operating system, so now you need to start up the VM. This is easy enough using the <code>Start-VM</code> cmdlet:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Start-VM -Name SQLSRV</span></pre>&#13;
<p class="indent">Now you have to wait for the VM to come online—this could take a while. How long? That depends; there are a lot of variables. One thing you can do is use a <code>while</code> loop to continually check whether you can connect to the VM.</p>&#13;
<p class="indent">Let’s walk though how to do this. In <a href="ch18.xhtml#ch18list1">Listing 18-1</a>, you’re grabbing the locally saved credential for the VM. Once you have that, you can create a <code>while</code> loop that keeps executing the <code>Invoke-Command</code> until something is returned.</p>&#13;
<p class="indent">Notice that you’re using the <code>Ignore</code> value for the <code>ErrorAction</code> parameter. You have to do this because without it, when <code>Invoke-Command</code> can’t connect to a computer, it will return a nonterminating error message. To avoid having your console flood with expected errors (since you know that it might not connect and are OK with it), you’re ignoring the error messages.</p>&#13;
<pre>$vmCred = Import-CliXml -Path 'C:\PowerLab\VMCredential.xml'&#13;
while (-not (Invoke-Command -VmName SQLSRV -ScriptBlock { 1 } -Credential&#13;
$vmCred -ErrorAction Ignore)) {&#13;
    Start-Sleep -Seconds 10&#13;
    Write-Host 'Waiting for SQLSRV to come up...'&#13;
}</pre>&#13;
<p class="caption" id="ch18list1"><em>Listing 18-1: Checking to see whether the server is alive, and ignoring the error messages</em></p>&#13;
<p class="indent">Once the VM finally comes up, it’s time to add it to the domain you created in the preceding chapter. The command that adds a computer to a domain is <code>Add-Computer</code>. Since you’re running all commands from the Hyper-V host itself, and aren’t depending on network connectivity, you need to wrap the <code>Add-Computer</code> command in a scriptblock and execute it via PowerShell Direct to run it directly on SQLSRV itself.</p>&#13;
<p class="indent">Notice that in <a href="ch18.xhtml#ch18list2">Listing 18-2</a>, you have to use both the local user account for the VM and a domain account. To do so, you first make a connection to the SQLSRV server itself by using <code>Invoke-Command</code>. Once you are connected, you’ll pass the domain credential to the domain controller to get authenticated, which will let you add the computer account.</p>&#13;
<pre>$domainCred = Import-CliXml -Path 'C:\PowerLab\DomainCredential.xml'&#13;
$addParams = @{&#13;
    DomainName = 'powerlab.local'&#13;
    Credential = $domainCred&#13;
    Restart    = $true&#13;
    Force      = $true&#13;
}&#13;
Invoke-Command -VMName SQLSRV -ScriptBlock { Add-Computer <span class="ent">❶</span>@using:addParams } -Credential $vmCred</pre>&#13;
<p class="caption" id="ch18list2"><em>Listing 18-2: Retrieving the credentials and adding the computer to the domain</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_257"/>Notice that you’re using the <code>$using</code> keyword <span class="ent">❶</span>. This keyword allows you to pass the local variable <code>$addParams</code> to the remote session on your SQLSRV server.</p>&#13;
<p class="indent">Since you used the <code>Restart</code> switch parameter on <code>Add-Computer</code>, the VM will restart as soon as it gets added to the domain. Again, because you have further work to do, you need to wait for this to happen. However, this time, you need to wait for it to go down <em>and</em> come back up (<a href="ch18.xhtml#ch18list3">Listing 18-3</a>) because the script is so fast that if you don’t wait for it to go down first, you risk the script continuing because it detected that it was up when it didn’t even go down yet!</p>&#13;
<pre><span class="ent">❶</span> while (Invoke-Command -VmName SQLSRV -ScriptBlock { 1 } -Credential $vmCred &#13;
   -ErrorAction Ignore) {&#13;
    <span class="ent">❷</span> Start-Sleep -Seconds 10&#13;
    <span class="ent">❸</span> Write-Host 'Waiting for SQLSRV to go down...'&#13;
}&#13;
&#13;
<span class="ent">❶</span> while (-not (Invoke-Command -VmName SQLSRV -ScriptBlock { 1 } -Credential &#13;
   $domainCred -ErrorAction Ignore)) {&#13;
    <span class="ent">❷</span> Start-Sleep -Seconds 10&#13;
    <span class="ent">❸</span> Write-Host 'Waiting for SQLSRV to come up...'&#13;
}</pre>&#13;
<p class="caption" id="ch18list3"><em>Listing 18-3: Waiting for the server to reboot</em></p>&#13;
<p class="indent">You first check whether SQLSRV has been powered down by simply returning the number 1 on SQLSRV <span class="ent">❶</span>. If it receives output, this means that PowerShell remoting is available and thus SQLSRV has not been powered down yet. If output is returned, you then pause for 10 seconds <span class="ent">❷</span>, write a message to the screen <span class="ent">❸</span>, and try again.</p>&#13;
<p class="indent">You then do the opposite when testing to see when SQLSRV comes back up. Once the script releases control of the console, SQLSRV should now be up and added to your Active Directory domain.</p>&#13;
<h4 class="h4" id="ch18lev5sec1">Installing the SQL Server</h4>&#13;
<p class="noindent">Now that you’ve created a VM with Windows Server 2016, you can install SQL Server 2016 to it. This is new code! Up until now, you simply leveraged existing code; now you’re back blazing new trails.</p>&#13;
<p class="indent">Installing SQL Server via PowerShell consists of a few steps:</p>&#13;
<ol>&#13;
<li><p class="noindent">Copying, and tweaking, a SQL Server answer file</p></li>&#13;
<li><p class="noindent">Copying the SQL Server ISO file to the soon-to-be SQL server</p></li>&#13;
<li><p class="noindent">Mounting the ISO file on the soon-to-be SQL server</p></li>&#13;
<li><p class="noindent">Running the SQL Server installer</p></li>&#13;
<li><p class="noindent">Dismounting the ISO file</p></li>&#13;
<li><p class="noindent">Cleaning up any temporary copied files on the SQL server</p></li>&#13;
</ol>&#13;
<h4 class="h4" id="ch18lev5sec2">Copying Files to the SQL Server</h4>&#13;
<p class="noindent">As per our plan, the first thing to do is to get a few files on the soon-to-be SQL server. You need the unattended answer file that the SQL Server <span epub:type="pagebreak" id="page_258"/>installer needs, and you also need the ISO file that contains the SQL Server installation content. Since we’re assuming that you have no network connectivity from the Hyper-V host to the VMs, you’ll again use PowerShell Direct to copy these files. To use PowerShell Direct to copy files, you first need to create a session on the remote VM. In the following code, you’re using the <code>Credential</code> parameter to authenticate to SQLSRV. If your server were in the same Active Directory domain as the computer you’re currently working on, the <code>Credential</code> parameter would not be necessary.</p>&#13;
<pre>$session = New-PSSession -VMName 'SQLSRV' -Credential $domainCred</pre>&#13;
<p class="indent">Next, make a copy of the template <em>SQLServer.ini</em> file found in the PowerLab module:</p>&#13;
<pre>$sqlServerAnswerFilePath = "C:\Program Files\WindowsPowerShell\Modules\&#13;
PowerLab\SqlServer.ini"&#13;
$tempFile = Copy-Item -Path $sqlServerAnswerFilePath -Destination "C:\Program&#13;
Files\WindowsPowerShell\Modules\PowerLab\temp.ini" -PassThru</pre>&#13;
<p class="indent">Once that’s done, you’ll modify the file to match the configuration you need. Recall that earlier, when you needed to change some values, you manually opened the unattended XML file. This was more work than you needed to do—believe it or not, you can automate this step as well!</p>&#13;
<p class="indent">In <a href="ch18.xhtml#ch18list4">Listing 18-4</a>, you’re reading in the contents of the copied template file, looking for the strings <code>SQLSVCACCOUNT=</code>, <code>SQLSVCPASSWORD=</code>, and <code>SQLSYSADMINACCOUNTS=</code> and replacing those strings with specific values. When you’re finished, rewrite the copied template file with your new changed strings.</p>&#13;
<pre>$configContents = Get-Content -Path $tempFile.FullName -Raw&#13;
$configContents = $configContents.Replace('SQLSVCACCOUNT=""', 'SQLSVCACCOUNT="PowerLabUser"')&#13;
$configContents = $configContents.Replace('SQLSVCPASSWORD=""', 'SQLSVCPASSWORD="P@$$w0rd12"')&#13;
$configContents = $configContents.Replace('SQLSYSADMINACCOUNTS=""', 'SQLSYSADMINACCOUNTS=&#13;
"PowerLabUser"')&#13;
Set-Content -Path $tempFile.FullName -Value $configContents</pre>&#13;
<p class="caption" id="ch18list4"><em>Listing 18-4: Replacing the strings</em></p>&#13;
<p class="indent">Once you have the answer file, and have copied that file and the SQL Server ISO file to the soon-to-be SQL server, the installer will be ready to go:</p>&#13;
<pre>$copyParams = @{&#13;
    Path        = $tempFile.FullName&#13;
    Destination = 'C:\'&#13;
    ToSession   = $session&#13;
}&#13;
Copy-Item @copyParams&#13;
Remove-Item -Path $tempFile.FullName -ErrorAction Ignore&#13;
Copy-Item -Path 'C:\PowerLab\ISOs\en_sql_server_2016_standard_x64_dvd_8701871.iso' &#13;
-Destination 'C:\' -Force -ToSession $session</pre>&#13;
<h4 class="h4" id="ch18lev5sec3"><span epub:type="pagebreak" id="page_259"/>Running the SQL Server Installer</h4>&#13;
<p class="noindent">You’re finally ready to install SQL Server. <a href="ch18.xhtml#ch18list5">Listing 18-5</a> contains the code to do so:</p>&#13;
<pre>$icmParams = @{&#13;
    Session      = $session&#13;
    ArgumentList = $tempFile.Name&#13;
    ScriptBlock  = {&#13;
        $image = Mount-DiskImage -ImagePath 'C:\en_sql_server_2016_standard_x64_dvd_8701871&#13;
        .iso' -PassThru <span class="ent">❶</span>&#13;
        $installerPath = "$(($image | Get-Volume).DriveLetter):"&#13;
        $null = &amp; "$installerPath\setup.exe" "/CONFIGURATIONFILE=C:\$($using:tempFile.Name)" <span class="ent">❷</span>&#13;
        $image | Dismount-DiskImage <span class="ent">❸</span>&#13;
    }&#13;
}&#13;
Invoke-Command @icmParams</pre>&#13;
<p class="caption" id="ch18list5"><em>Listing 18-5: Using <code>Invoke-Command</code> to mount, install, and dismount the image</em></p>&#13;
<p class="indent">First, you mount the copied ISO file on the remote machine <span class="ent">❶</span>; then you execute the installer, assigning the output to <code>$null</code> <span class="ent">❷</span> as you don’t need it; lastly, when you’re all done, you dismount the image <span class="ent">❸</span>. In <a href="ch18.xhtml#ch18list5">Listing 18-5</a>, you’re using <code>Invoke-Command</code> and PowerShell Direct to remotely execute these commands.</p>&#13;
<p class="indent">When SQL Server has been installed, do some cleanup work to ensure that you remove all the temporary copied files, as shown in <a href="ch18.xhtml#ch18list6">Listing 18-6</a>.</p>&#13;
<pre>$scriptBlock = { Remove-Item -Path 'C:\en_sql_server_2016_standard_x64_dvd&#13;
_8701871.iso', "C:\$($using:tempFile.Name)" -Recurse -ErrorAction Ignore }&#13;
Invoke-Command -ScriptBlock $scriptBlock -Session $session&#13;
$session | Remove-PSSession</pre>&#13;
<p class="caption" id="ch18list6"><em>Listing 18-6: Cleaning up the temporary files</em></p>&#13;
<p class="indent">At this point, the SQL Server will be set up and ready to go! In just 64 lines of PowerShell, you created a Microsoft SQL Server from nothing but a Hyper-V host. This is great progress, but you can make it even better.</p>&#13;
<h3 class="h3" id="ch18lev6">Automating the SQL Server</h3>&#13;
<p class="noindent">You’ve done most of the heavy lifting already. By now, you have a script that does everything you need it to do. What you want next is to roll all that functionality into a few functions in your PowerLab module: the <code>New-PowerLabSqlServer</code> and <code>Install-PowerLabOperatingSystem</code> functions.</p>&#13;
<p class="indent">You’ll follow the basic automation pattern established in the previous chapters: build functions around all the common actions and call them instead of using hardcoded values in many places. The result will be a single function the user can call. In <a href="ch18.xhtml#ch18list7">Listing 18-7</a>, you use existing functions to <span epub:type="pagebreak" id="page_260"/>create the VM and VHD, and create a second <code>Install-PowerLabSQLServer</code> function to house the code for installing the SQL Server:</p>&#13;
<pre>function New-PowerLabSqlServer {&#13;
    [CmdletBinding()]&#13;
    param&#13;
    (&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Name,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [pscredential]$DomainCredential,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [pscredential]$VMCredential,&#13;
&#13;
        [Parameter()]&#13;
        [string]$VMPath = 'C:\PowerLab\VMs',&#13;
&#13;
        [Parameter()]&#13;
        [int64]$Memory = 2GB,&#13;
&#13;
        [Parameter()]&#13;
        [string]$Switch = 'PowerLab',&#13;
&#13;
        [Parameter()]&#13;
        [int]$Generation = 2,&#13;
&#13;
        [Parameter()]&#13;
        [string]$DomainName = 'powerlab.local',&#13;
&#13;
        [Parameter()]&#13;
        [string]$AnswerFilePath = "C:\Program Files\WindowsPowerShell\Modules\PowerLab&#13;
        \SqlServer.ini"&#13;
    )&#13;
&#13;
    ## Build the VM&#13;
    $vmparams = @{ &#13;
        Name       = $Name&#13;
        Path       = $VmPath&#13;
        Memory     = $Memory&#13;
        Switch     = $Switch&#13;
        Generation = $Generation&#13;
    }&#13;
    New-PowerLabVm @vmParams&#13;
    Install-PowerLabOperatingSystem -VmName $Name&#13;
    Start-VM -Name $Name&#13;
    Wait-Server -Name $Name -Status Online -Credential $VMCredential&#13;
    $addParams = @{&#13;
        DomainName = $DomainName&#13;
        Credential = $DomainCredential&#13;
        Restart    = $true&#13;
        Force      = $true&#13;
<span epub:type="pagebreak" id="page_261"/>    Invoke-Command -VMName $Name -ScriptBlock { Add-Computer @using:addParams } -Credential&#13;
    $VMCredential&#13;
    Wait-Server -Name $Name -Status Offline -Credential $VMCredential&#13;
    Wait-Server -Name $Name -Status Online -Credential $DomainCredential&#13;
    $tempFile = Copy-Item -Path $AnswerFilePath&#13;
    -Destination "C:\Program Files\WindowsPowerShell\Modules\PowerLab\temp.ini" -PassThru&#13;
    &#13;
    Install-PowerLabSqlServer -ComputerName $Name -AnswerFilePath $tempFile.FullName&#13;
}</pre>&#13;
<p class="caption" id="ch18list7"><em>Listing 18-7: The <code>New-PowerLabSqlServer</code> function</em></p>&#13;
<p class="indent">You should recognize most of this code: it’s the exact same code we covered just a bit ago, here wrapped in a function for easy reuse! I used the same code body but instead of using hardcoded values, I parameterized many attributes, allowing you to install SQL Server with different parameters without changing the code itself.</p>&#13;
<p class="indent">Turning specific scripts into a general function preserves the functionality of your code and allows greater flexibility if at some point in the future you want to change the behavior of how you deploy SQL servers.</p>&#13;
<p class="indent">Let’s take a look at the important pieces of the <code>Install-PowerLabSqlServer</code> code in <a href="ch18.xhtml#ch18list8">Listing 18-8</a>.</p>&#13;
<pre>function Install-PowerLabSqlServer {&#13;
    <span class="ent">❶</span> param&#13;
    (&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$ComputerName,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [pscredential]$DomainCredential,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$AnswerFilePath,&#13;
&#13;
        [Parameter()]&#13;
        [string]$IsoFilePath = 'C:\PowerLab\ISOs\en_sql_server_2016_standard&#13;
        _x64_dvd_8701871.iso'&#13;
    )&#13;
&#13;
    try {&#13;
        <span class="codeitalic1">--snip--</span>&#13;
&#13;
     <span class="ent">❷</span> ## Test to see if SQL Server is already installed&#13;
        if (Invoke-Command -Session $session&#13;
        -ScriptBlock { Get-Service -Name 'MSSQLSERVER' -ErrorAction Ignore }) {&#13;
            Write-Verbose -Message 'SQL Server is already installed'&#13;
        } else {&#13;
&#13;
         <span class="ent">❸</span> PrepareSqlServerInstallConfigFile -Path $AnswerFilePath&#13;
<span epub:type="pagebreak" id="page_262"/>        <span class="codeitalic1">--snip--</span>&#13;
    } catch {&#13;
        $PSCmdlet.ThrowTerminatingError($_)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch18list8"><em>Listing 18-8: The <code>Install-PowerLabSqlServer</code> PowerLab module function</em></p>&#13;
<p class="indent">You parameterize all the types of input you need to install SQL Server <span class="ent">❶</span> and add an error-handling step <span class="ent">❷</span> to check whether SQL Server is already installed. This allows you to run the function over and over again; if SQL Server is already installed, the function will simply skip over it.</p>&#13;
<p class="indent">Notice that you call a function you haven’t seen before: <code>PrepareSqlServerInstallConfigFile</code> <span class="ent">❸</span>. This is a <em>helper function</em>: a small function that captures some bit of functionality you’re likely to use again and again (helper functions are usually hidden from the user and used behind the scenes). Although not required by any means, breaking out small bits of functionality like this makes code more readable. As a general rule, functions should only do one “thing.” <em>Thing</em> here is, of course, a highly relative term, but the more you program, the more you’ll have an intuitive sense for when a function is doing too many things at once.</p>&#13;
<p class="indent"><a href="ch18.xhtml#ch18list9">Listing 18-9</a> is the code for the <code>PrepareSqlServerInstallConfigFile</code> function.</p>&#13;
<pre>function PrepareSqlServerInstallConfigFile {&#13;
    [CmdletBinding()]&#13;
    param&#13;
    (&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$Path,&#13;
&#13;
        [Parameter()]&#13;
        [string]$ServiceAccountName = 'PowerLabUser',&#13;
&#13;
        [Parameter()]&#13;
        [string]$ServiceAccountPassword = 'P@$$w0rd12',&#13;
&#13;
        [Parameter()]&#13;
        [string]$SysAdminAccountName = 'PowerLabUser'&#13;
    )&#13;
&#13;
    $configContents = Get-Content -Path $Path -Raw&#13;
    $configContents = $configContents.Replace('SQLSVCACCOUNT=""',&#13;
    ('SQLSVCACCOUNT="{0}"' -f $ServiceAccountName))&#13;
    $configContents = $configContents.Replace('SQLSVCPASSWORD=""',&#13;
    ('SQLSVCPASSWORD="{0}"' -f $ServiceAccountPassword))&#13;
    $configContents = $configContents.Replace('SQLSYSADMINACCOUNTS=""',&#13;
    ('SQLSYSADMINACCOUNTS="{0}"' -f $SysAdminAccountName))&#13;
    Set-Content -Path $Path -Value $configContents&#13;
}</pre>&#13;
<p class="caption" id="ch18list9"><em>Listing 18-9: The <code>PrepareSqlServerInstallConfigFile</code> helper function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_263"/>You’ll recognize this code from <a href="ch18.xhtml#ch18list4">Listing 18-4</a>; it hasn’t changed much. You added the parameters <code>Path</code>, <code>ServiceAccountName</code>, <code>ServiceAccountPassword</code>, and <code>SysAdminAccountName</code> to represent each attribute instead of the hardcoded values used earlier.</p>&#13;
<p class="indent">Now that you have all your functions in a row, bringing up an SQL server from scratch is just a few commands away. Run the following code to bring up a SQL server from scratch!</p>&#13;
<pre>PS&gt; <span class="codestrong1">$vmCred = Import-CliXml -Path 'C:\PowerLab\VMCredential.xml'</span>&#13;
PS&gt; <span class="codestrong1">$domainCred = Import-CliXml -Path 'C:\PowerLab\DomainCredential.xml'</span>&#13;
PS&gt; <span class="codestrong1">New-PowerLabSqlServer -Name SQLSRV -DomainCredential $domainCred -VMCredential $vmCred</span></pre>&#13;
<h3 class="h3" id="ch18lev7">Running Pester Tests</h3>&#13;
<p class="noindent">It’s that time again: let’s run some Pester tests to test the new changes you implemented. For this chapter, you installed SQL Server on the existing SQLSRV VM. You didn’t do too much configuring when you installed, and accepted most of the installation defaults, so you’ll have only a few Pester tests: you have to make sure that SQL Server is installed, and you have to make sure that during installation it read the unattended configuration file you supplied it. You can do this by verifying that <code>PowerLabUser</code> holds a server sysadmin role and that SQL Server is running under the <code>PowerLabUser</code> account:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Invoke-Pester 'C:\PowerShellForSysAdmins\Part II\Creating and Configuring&#13;
SQL Servers\Creating and Configuring SQL Servers.Tests.ps1'</span>&#13;
&#13;
Describing SQLSRV&#13;
   Context SQL Server installation&#13;
    [+] SQL Server is installed 4.33s&#13;
   Context SQL Server configuration&#13;
    [+] PowerLabUser holds the sysadmin role 275ms&#13;
    [+] the MSSQLSERVER is running under the PowerLabUser account 63ms&#13;
Tests completed in 6.28s&#13;
Passed: 3 Failed: 0 Skipped: 0 Pending: 0 Inconclusive: 0</pre>&#13;
<p class="indent">Everything checks out, so you’re good to go!</p>&#13;
<h3 class="h3" id="ch18lev8">Summary</h3>&#13;
<p class="noindent">In this chapter, you finally saw a more fleshed-out example of what you can do with PowerShell. Building on the work in previous chapters, you added that final layer of automation: installing software (SQL Server) on top of an operating system that was “layered” on top of a virtual machine. You did this in much the same way as in the past few chapters. You used a single example to figure out the code you needed; then you packaged that code <span epub:type="pagebreak" id="page_264"/>in a reusable format and put it inside your PowerLab module. And now that that’s done, you can build as many SQL servers as you want with nothing more than a few lines of code!</p>&#13;
<p class="indent">In the next chapter, you’ll do something a little different: revisit code you’ve already written and refactor it. You’ll learn about best coding practices and make sure your module is in the place you need it to be before adding the final piece in <a href="ch20.xhtml#ch20">Chapter 20</a>.</p>&#13;
</body></html>