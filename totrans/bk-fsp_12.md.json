["```\n*builder-name* { *computation-expression-body* }\n```", "```\nerror FS0708: This control construct may only be used if the computation\nexpression builder defines a 'Using' method\n```", "```\ntype FizzBuzzSequenceBuilder() =\n  member x.Yield(v) =\n    match (v % 3, v % 5) with\n    | 0, 0 -> \"FizzBuzz\"\n    | 0, _ -> \"Fizz\"\n    | _, 0 -> \"Buzz\"\n    | _ -> v.ToString()\n```", "```\nlet fizzbuzz = FizzBuzzSequenceBuilder()\n```", "```\n> **fizzbuzz { yield 1 };;**\nval it : string = \"1\"\n```", "```\nfizzbuzz.Yield 1\n```", "```\ntype FizzBuzzSequenceBuilder() =\n-- *snip* --\nmember x.Delay(f) = f() |> Seq.singleton\n```", "```\n> **fizzbuzz { yield 1 };;**\nval it : seq<string> = seq [\"1\"]\n```", "```\nfizzbuzz.Delay(fun () -> fizzbuzz.Yield 1)\n```", "```\nfizzbuzz {\n  yield 1\n  yield 2\n  yield 3 }\n```", "```\ntype FizzBuzzSequenceBuilder() =\n  -- *snip* --\n  member x.Delay(f : unit -> string seq) = f()\n  member x.Combine(l, r) =\n    Seq.append (Seq.singleton l) (Seq.singleton r)\n  member x.Combine(l, r) =\n    Seq.append (Seq.singleton l) r\n```", "```\n> **fizzbuzz {**\n  **yield 1**\n  **yield 2**\n  **yield 3 };;**\nval it : seq<string> = seq [\"1\"; \"2\"; \"Fizz\"]\n```", "```\nfizzbuzz.Delay (fun () ->\n  fizzbuzz.Combine (\n    fizzbuzz.Yield 1,\n    fizzbuzz.Delay (fun () ->\n      fizzbuzz.Combine(\n        fizzbuzz.Yield 2,\n        fizzbuzz.Delay (fun () -> fizzbuzz.Yield 3)))))\n```", "```\ntype FizzBuzzSequenceBuilder() =\n  -- *snip* --\n  member x.For(g, f) = Seq.map f g\n```", "```\nfizzbuzz { for x = 1 to 99 do yield x }\n```", "```\nfizzbuzz { yield 1\n           yield 2\n           for x = 3 to 50 do yield x }\n```", "```\ntype FizzBuzzSequenceBuilder() =\n  member x.Yield(v) =\n    match (v % 3, v % 5) with\n    | 0, 0 -> \"FizzBuzz\"\n    | 0, _ -> \"Fizz\"\n    | _, 0 -> \"Buzz\"\n    | _ -> v.ToString()\n  member x.Delay(f) = f() |> Seq.singleton\n  member x.Delay(f : unit -> string seq) = f()\n  member x.Combine(l, r) =\n    Seq.append (Seq.singleton l) (Seq.singleton r)\n  member x.Combine(l, r) =\n    Seq.append (Seq.singleton l) r\n  member x.For(g, f) = Seq.map f g\n```", "```\nopen System.Text\n\nStringBuilder(\"The quick \")\n  .Append(\"brown fox \")\n  .Append(\"jumps over \")\n  .Append(\"the lazy dog\")\n  .ToString()\n```", "```\nlet sb = System.Text.StringBuilder()\nPrintf.bprintf sb \"The quick \"\nPrintf.bprintf sb \"brown fox \"\nPrintf.bprintf sb \"jumps over \"\nPrintf.bprintf sb \"the lazy dog\"\nsb.ToString() |> printfn \"%s\"\n```", "```\nbuildstring {\n  yield \"The quick \"\n  yield \"brown fox \"\n  yield \"jumps over \"\n  yield \"the lazy dog\" }\n```", "```\nopen System.Text\n\ntype StringFragment =\n| ① Empty\n| ② Fragment of string\n| ③ Concat of StringFragment * StringFragment\n  override x.ToString() =\n    let rec flatten frag (sb : StringBuilder) =\n      match frag with\n      | Empty -> sb\n      | Fragment(s) -> sb.Append(s)\n      | Concat(s1, s2) -> sb |> flatten s1 |> flatten s2\n    (StringBuilder() |> flatten x).ToString()\n```", "```\ntype StringFragmentBuilder() =\n  member x.Zero() = Empty\n  member x.Yield(v) = Fragment(v)\n  member x.YieldFrom(v) = v\n  member x.Combine(l, r) = Concat(l, r)\n  member x.Delay(f) = f()\n  member x.For(s, f) =\n    Seq.map f s\n    |> Seq.reduce (fun l r -> x.Combine(l, r))\n\nlet buildstring = StringFragmentBuilder()\n```", "```\nbuildstring {\n  yield \"A\"\n  yield \"B\" }\n```", "```\nbuildstring.Combine(\n  buildstring.Yield(\"A\"),\n  buildstring.Yield(\"B\"))\n```", "```\nConcat (Fragment \"A\", Fragment \"B\")\n```", "```\nbuildstring.Combine(\n  buildstring.Yield(\"A\"),\n  buildstring.Combine(\n    buildstring.Yield(\"B\"),\n    buildstring.Yield(\"C\")))\n```", "```\nConcat (Fragment \"A\", Concat (Fragment \"B\", Fragment \"C\"))\n```", "```\nbuildstring.Delay(\n  fun () ->\n    buildstring.Combine(\n      buildstring.Yield(\"A\"),\n      buildstring.Delay(\n        fun () ->\n          buildstring.Combine(\n           buildstring.Yield(\"B\"),\n             buildstring.Delay(\n               fun () ->\n                 buildstring.Yield(\"C\"))))))\n```", "```\nlet bingo() =\n  let buildNamePhrase fullName =\n    buildstring {\n      yield \"And \"\n      yield fullName\n      yield \" was his name-o\\n\"\n   }\n  let buildClapAndSpellPhrases maxChars chars =\n    let clapCount = maxChars - (List.length chars)\n    let spellPart =\n      List.init clapCount (fun _ -> \"*clap*\") @ chars\n      |> Seq.ofList\n      |> String.concat \"-\"\n    buildstring {\n      for i in 1..3 do yield spellPart\n                       yield \"\\n\" }\n  let rec buildVerse fullName (chars : string list) =\n    buildstring {\n      yield \"There was a farmer who had a dog,\\n\"\n      yield! buildNamePhrase fullName\n      yield! buildClapAndSpellPhrases fullName.Length chars\n      yield! buildNamePhrase fullName\n      match chars with\n      | [] -> ()\n      | _::nextChars -> yield \"\\n\"\n                        yield! buildVerse fullName nextChars\n    }\n  let name = \"Bingo\"\n  let letters = [ for c in name.ToUpper() -> c.ToString() ]\n  buildVerse name letters\n```", "```\n> **bingo() |> printfn \"%O\";;**\nThere was a farmer who had a dog,\nAnd Bingo was his name-o!\nB-I-N-G-O\nB-I-N-G-O\nB-I-N-G-O\nAnd Bingo was his name-o!\n\nThere was a farmer who had a dog,\nAnd Bingo was his name-o!\n*clap*-I-N-G-O\n*clap*-I-N-G-O\n*clap*-I-N-G-O\nAnd Bingo was his name-o!\n\nThere was a farmer who had a dog,\nAnd Bingo was his name-o!\n*clap*-*clap*-N-G-O\n*clap*-*clap*-N-G-O\n*clap*-*clap*-N-G-O\nAnd Bingo was his name-o!\n-- *snip* --\n```"]