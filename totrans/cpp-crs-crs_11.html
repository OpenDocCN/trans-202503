<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_242"/><span epub:type="pagebreak" id="page_243"/><strong><span class="big">9</span><br/>FUNCTIONS</strong></h2>&#13;
<p class="quote"><em>Functions should do one thing. They should do it well. They should do it only.<br/>—Robert C. Martin,</em> Clean Code</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter rounds out the ongoing discussion of functions, which encapsulate code into reusable components. Now that you’re armed with a strong background in C++ fundamentals, this chapter first revisits functions with a far more in-depth treatment of modifiers, specifiers, and return types, which appear in function declarations and specialize the behavior of your functions.</p>&#13;
<p class="indent">Then you’ll learn about overload resolution and accepting variable numbers of arguments before exploring function pointers, type aliases, function objects, and the venerable lambda expression. The chapter closes with an introduction to the <span class="literal">std::function</span> before revisiting the <span class="literal">main</span> function and accepting command line arguments.</p>&#13;
<h3 class="h3" id="ch09lev1sec1"><strong><span epub:type="pagebreak" id="page_244"/>Function Declarations</strong></h3>&#13;
<p class="noindent">Function declarations have the following familiar form:</p>&#13;
<pre><span class="codeitalic1">prefix-modifiers return-type func-name(arguments) suffix-modifiers</span>;</pre>&#13;
<p class="indent">You can provide a number of optional <em>modifiers</em> (or <em>specifiers</em>) to functions. Modifiers alter a function’s behavior in some way. Some modifiers appear at the beginning in the function’s declaration or definition (<em>prefix modifiers</em>), whereas others appear at the end (<em>suffix modifiers</em>). The prefix modifiers appear before the return type. The suffix modifiers appear after the argument list.</p>&#13;
<p class="indent">There isn’t a clear language reason why certain modifiers appear as prefixes or suffixes: because C++ has a long history, these features evolved incrementally.</p>&#13;
<h4 class="h4" id="ch09lev2sec1"><strong><em>Prefix Modifiers</em></strong></h4>&#13;
<p class="noindent">At this point, you already know several prefix modifiers:</p>&#13;
<ul>&#13;
<li class="noindent">The prefix <span class="literal">static</span> indicates that a function that isn’t a member of a class has internal linkage, meaning the function won’t be used outside of this translation unit. Unfortunately, this keyword does double duty: if it modifies a method (that is, a function inside a class), it indicates that the function isn’t associated with an instantiation of the class but rather with the class itself (see <a href="ch04.xhtml#ch04">Chapter 4</a>).</li>&#13;
<li class="noindent">The modifier <span class="literal">virtual</span> indicates that a method can be overridden by a child class. The <span class="literal">override</span> modifier indicates to the compiler that a child class intends to override a parent’s virtual function (see <a href="ch05.xhtml#ch05">Chapter 5</a>).</li>&#13;
<li class="noindent">The modifier <span class="literal">constexpr</span> indicates that the function should be evaluated at compile time if possible (see <a href="ch07.xhtml#ch07">Chapter 7</a>).</li>&#13;
<li class="noindent">The modifier <span class="literal">[[noreturn]]</span> indicates that this function won’t return (see <a href="ch08.xhtml#ch08">Chapter 8</a>). Recall that this attribute helps the compiler to optimize your code.</li>&#13;
</ul>&#13;
<p class="indent">Another prefix modifier is <span class="literal">inline</span>, which plays a role in guiding the compiler when optimizing code.</p>&#13;
<p class="indent">On most platforms, a function call compiles into a series of instructions, such as the following:</p>&#13;
<ol>&#13;
<li class="noindent">Place arguments into registers and on the call stack.</li>&#13;
<li class="noindent">Push a return address onto the call stack.</li>&#13;
<li class="noindent">Jump to the called function.</li>&#13;
<li class="noindent">After the function completes, jump to the return address.</li>&#13;
<li class="noindent">Clean up the call stack.</li>&#13;
</ol>&#13;
<p class="indent">These steps typically execute very quickly, and the payoff in reduced binary size can be substantial if you use a function in many places.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_245"/><em>Inlining a function</em> means copying and pasting the contents of the function directly into the execution path, eliminating the need for the five steps outlined. This means that as the processor executes your code, it will immediately execute your function’s code rather than executing the (modest) ceremony required for function invocation. If you prefer this marginal increase in speed over the commensurate cost in increased binary size, you can use the <span class="literal">inline</span> keyword to indicate this to the compiler. The <span class="literal">inline</span> keyword hints to the compiler’s optimizer to put a function directly inline rather than perform a function call.</p>&#13;
<p class="indent">Adding <span class="literal">inline</span> to a function doesn’t change its behavior; it’s purely an expression of preference to the compiler. You must ensure that if you define a function <span class="literal">inline</span>, you do so in all translation units. Also note that modern compilers will typically inline functions where it makes sense—especially if a function isn’t used outside of a single translation unit.</p>&#13;
<h4 class="h4" id="ch09lev2sec2"><strong><em>Suffix Modifiers</em></strong></h4>&#13;
<p class="noindent">At this point in the book, you already know two suffix modifiers:</p>&#13;
<ul>&#13;
<li class="noindent">The modifier <span class="literal">noexcept</span> indicates that the function will <em>never</em> throw an exception. It enables certain optimizations (see <a href="ch04.xhtml#ch04">Chapter 4</a>).</li>&#13;
<li class="noindent">The modifier <span class="literal">const</span> indicates that the method won’t modify an instance of its class, allowing <span class="literal">const</span> references types to invoke the method (see <a href="ch04.xhtml#ch04">Chapter 4</a>).</li>&#13;
</ul>&#13;
<p class="indent">This section explores three more suffix modifiers: <span class="literal">final</span>, <span class="literal">override</span>, and <span class="literal">volatile</span>.</p>&#13;
<h5 class="h5" id="ch09lev3sec1"><strong>final and override</strong></h5>&#13;
<p class="indent">The <span class="literal">final</span> modifier indicates that a method cannot be overridden by a child class. It’s effectively the opposite of <span class="literal">virtual</span>. <a href="ch09.xhtml#ch09ex01">Listing 9-1</a> attempts to override a <span class="literal">final</span> method and yields a compiler error.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BostonCorbett {&#13;
  virtual void shoot() final<span class="ent">➊</span> {&#13;
    printf("What a God we have...God avenged Abraham Lincoln");&#13;
  }&#13;
};&#13;
&#13;
struct BostonCorbettJunior : BostonCorbett {&#13;
  void shoot() override<span class="ent">➋</span> { } // Bang! shoot is final.&#13;
};&#13;
&#13;
int main() {&#13;
  BostonCorbettJunior junior;&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex01"/><em>Listing 9-1: A class attempting to override a final method (This code doesn’t compile.)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>This listing marks the <span class="literal">shoot</span> method <span class="literal">final</span> <span class="ent">➊</span>. Within <span class="literal">BostonCorbettJunior</span>, which inherits from <span class="literal">BostonCorbett</span>, you attempt to <span class="literal">override</span> the <span class="literal">shoot</span> method <span class="ent">➋</span>. This causes a compiler error.</p>&#13;
<p class="indent">You can also apply the <span class="literal">final</span> keyword to an entire class, disallowing that class from becoming a parent entirely, as demonstrated in <a href="ch09.xhtml#ch09ex02">Listing 9-2</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BostonCorbett final <span class="ent">➊</span> {&#13;
  void shoot()  {&#13;
    printf("What a God we have...God avenged Abraham Lincoln");&#13;
  }&#13;
};&#13;
&#13;
struct BostonCorbettJunior : BostonCorbett <span class="ent">➋</span> { }; // Bang!&#13;
&#13;
int main() {&#13;
  BostonCorbettJunior junior;&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex02"/><em>Listing 9-2: A program with a class attempting to inherit from a final class. (This code doesn’t compile.)</em></p>&#13;
<p class="indent">The <span class="literal">BostonCorbett</span> class is marked as <span class="literal">final</span> <span class="ent">➊</span>, and this causes a compiler error when you attempt to inherit from it in <span class="literal">BostonCorbettJunior</span> <span class="ent">➋</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Neither <span class="literal">final</span> nor <span class="literal">override</span> is technically a language keyword; they are <em>identifiers</em>. Unlike keywords, identifiers gain special meaning only when used in a specific context. This means you can use <span class="literal">final</span> and <span class="literal">override</span> as symbol names elsewhere in your program, thereby leading to the insanity of constructions like <span class="literal">virtual void final() override</span>. Try not to do this.</em></p>&#13;
</div>&#13;
<p class="indent">Whenever you’re using interface inheritance, you should mark implementing classes <span class="literal">final</span> because the modifier can encourage the compiler to perform an optimization called <em>devirtualization</em>. When virtual calls are devirtualized, the compiler eliminates the runtime overhead associated with a virtual call.</p>&#13;
<h5 class="h5" id="ch09lev3sec2"><strong>volatile</strong></h5>&#13;
<p class="noindent">Recall from <a href="ch07.xhtml#ch07">Chapter 7</a> that a volatile object’s value can change at any time, so the compiler must treat all accesses to volatile objects as visible side effects for optimization purposes. The <span class="literal">volatile</span> keyword indicates that a method can be invoked on volatile objects. This is analogous to how <span class="literal">const</span> methods can be applied to <span class="literal">const</span> objects. Together, these two keywords define a method’s <em>const/volatile qualification</em> (or sometimes <em>cv qualification</em>), as demonstrated in <a href="ch09.xhtml#ch09ex03">Listing 9-3</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Distillate {&#13;
<span epub:type="pagebreak" id="page_247"/>  int apply() volatile <span class="ent">➊</span> {&#13;
    return ++applications;&#13;
  }&#13;
private:&#13;
  int applications{};&#13;
};&#13;
&#13;
int main() {&#13;
  volatile <span class="ent">➋</span> Distillate ethanol;&#13;
  printf("%d Tequila\n", ethanol.apply()<span class="ent">➌</span>);&#13;
  printf("%d Tequila\n", ethanol.apply());&#13;
  printf("%d Tequila\n", ethanol.apply());&#13;
  printf("Floor!");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 Tequila <span class="ent">➌</span></span>&#13;
<span class="color1">2 Tequila</span>&#13;
<span class="color1">3 Tequila</span>&#13;
<span class="color1">Floor!</span></pre>&#13;
<p class="listing"><a id="ch09ex03"/><em>Listing 9-3: Illustrating the use of a <span class="literal">volatile</span> method</em></p>&#13;
<p class="indent">In this listing, you declare the <span class="literal">apply</span> method on the <span class="literal">Distillate</span> class <span class="literal">vola</span><span class="literal">tile</span> <span class="ent">➊</span>. You also create a <span class="literal">volatile Distillate</span> called <span class="literal">ethanol</span> within <span class="literal">main</span> <span class="ent">➋</span>. Because the <span class="literal">apply</span> method is <span class="literal">volatile</span>, you can still invoke it <span class="ent">➌</span> (even though <span class="literal">ethanol</span> is <span class="literal">volatile</span>).</p>&#13;
<p class="indent">Had you not marked <span class="literal">apply volatile</span> <span class="ent">➊</span>, the compiler would emit an error when you attempted to invoke it <span class="ent">➌</span>. Just like you cannot invoke a non-<span class="literal">const</span> method on a <span class="literal">const</span> object, you cannot invoke a non-<span class="literal">volatile</span> method on a <span class="literal">volatile</span> object. Consider what would happen if you could perform such an operation: a non-<span class="literal">volatile</span> method is a candidate for all kinds of compiler optimizations for the reasons outlined in <a href="ch07.xhtml#ch07">Chapter 7</a>: many kinds of memory accesses can be optimized away without changing the observable side effects of your program.</p>&#13;
<p class="indent">How should the compiler treat a contradiction arising from you using a <span class="literal">volatile</span> object—which requires that all its memory accesses are treated as observable side effects—to invoke a non-<span class="literal">volatile</span> method? The compiler’s answer is that it calls this contradiction an error.</p>&#13;
<h3 class="h3" id="ch09lev1sec2"><strong>auto Return Types</strong></h3>&#13;
<p class="noindent">There are two ways to declare the return value of a function:</p>&#13;
<ul>&#13;
<li class="noindent">(Primary) Lead a function declaration with its return type, as you’ve been doing all along.</li>&#13;
<li class="noindent">(Secondary) Have the compiler deduce the correct return type by using <span class="literal">auto</span>.</li>&#13;
</ul>&#13;
<p class="indent">As with <span class="literal">auto</span> type deduction, the compiler deduces the return type, fixing the runtime type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>This feature should be used judiciously. Because function definitions are documentation, it’s best to provide concrete return types when available.</p>&#13;
<h3 class="h3" id="ch09lev1sec3"><strong>auto and Function Templates</strong></h3>&#13;
<p class="noindent">The primary use case for <span class="literal">auto</span> type deduction is with function templates, where a return type can depend (in potentially complicated ways) on the template parameters. Its usage is as follows:</p>&#13;
<pre>auto <span class="codeitalic1">my-function</span>(<span class="codeitalic1">arg1-type arg1</span>, <span class="codeitalic1">arg2-type arg2</span>, ...) {&#13;
  // return any type and the&#13;
  // compiler will deduce what auto means&#13;
}</pre>&#13;
<p class="indent">It’s possible to extend the <span class="literal">auto</span>-return-type deduction syntax to provide the return type as a suffix with the arrow operator <span class="literal">-&gt;</span>. This way, you can append an expression that evaluates to the function’s return type. Its usage is as follows:</p>&#13;
<pre>auto <span class="codeitalic1">my-function</span>(<span class="codeitalic1">arg1-type</span> arg1, <span class="codeitalic1">arg2-type</span> arg2, ...) -&gt; <span class="codeitalic1">type-expression</span> {&#13;
  // return an object with type matching&#13;
  // the type-expression above&#13;
}</pre>&#13;
<p class="indent">Usually, you wouldn’t use this pedantic form, but in certain situations it’s helpful. For example, this form of <span class="literal">auto</span> type deduction is commonly paired with a <span class="literal">decltype</span> type expression. A <span class="literal">decltype</span> type expression yields another expression’s resultant type. Its usage is as follows:</p>&#13;
<pre>decltype(<span class="codeitalic1">expression</span>)</pre>&#13;
<p class="indent">This expression resolves to the resulting type of the expression. For example, the following <span class="literal">decltype</span> expression yields <span class="literal">int</span>, because the integer literal 100 has that type:</p>&#13;
<pre>decltype(100)</pre>&#13;
<p class="indent">Outside of generic programming with templates, <span class="literal">decltype</span> is rare.</p>&#13;
<p class="indent">You can combine <span class="literal">auto</span>-return-type deduction and <span class="literal">decltype</span> to document the return types of function templates. Consider the <span class="literal">add</span> function in <a href="ch09.xhtml#ch09ex04">Listing 9-4</a>, which defines a function template <span class="literal">add</span> that adds two arguments together.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;typename X, typename Y&gt;&#13;
auto add(X x, Y y) -&gt; decltype(x + y) { <span class="ent">➊</span>&#13;
  return x + y;&#13;
}&#13;
<span epub:type="pagebreak" id="page_249"/>int main() {&#13;
  auto my_double = add(100., -10);&#13;
  printf("decltype(double + int) = double; %f\n", my_double); <span class="ent">➋</span>&#13;
&#13;
  auto my_uint = add(100U, -20);&#13;
  printf("decltype(uint + int) = uint; %u\n", my_uint); <span class="ent">➌</span>&#13;
&#13;
  auto my_ulonglong = add(char{ 100 }, 54'999'900ull);&#13;
  printf("decltype(char + ulonglong) = ulonglong; %llu\n", my_ulonglong); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">decltype(double + int) = double; 90.000000 <span class="ent">➋</span></span>&#13;
<span class="color1">decltype(uint + int) = uint; 80 <span class="ent">➌</span></span>&#13;
<span class="color1">decltype(char + ulonglong) = ulonglong; 55000000 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch09ex04"/><em>Listing 9-4: Using <span class="literal">decltype</span> and <span class="literal">auto</span>-return-type deduction</em></p>&#13;
<p class="indent">The <span class="literal">add</span> function employs <span class="literal">auto</span> type deduction with the <span class="literal">decltype</span> type expression <span class="ent">➊</span>. Each time you instantiate a template with two types <span class="literal">X</span> and <span class="literal">Y</span>, the compiler evaluates <span class="literal">decltype(X + Y)</span> and fixes the return type of <span class="literal">add</span>. Within <span class="literal">main</span>, you provide three instantiations. First, you add a <span class="literal">double</span> and an <span class="literal">int</span> <span class="ent">➋</span>. The compiler determines that <span class="literal">decltype(double{ 100. } + int{ -10 })</span> is a <span class="literal">double</span>, which fixes the return type of this <span class="literal">add</span> instantiation. This, in turn, sets the type of <span class="literal">my_double</span> to <span class="literal">double</span> <span class="ent">➋</span>. You have two other instantiations: one for an <span class="literal">unsigned int</span> and <span class="literal">int</span> (which results in an <span class="literal">unsigned int</span> <span class="ent">➌</span>) and another for a <span class="literal">char</span> and an <span class="literal">unsigned long long</span> (which results in an <span class="literal">unsigned long long</span> <span class="ent">➍</span>).</p>&#13;
<h3 class="h3" id="ch09lev1sec4"><strong>Overload Resolution</strong></h3>&#13;
<p class="noindent"><em>Overload resolution</em> is the process that the compiler executes when matching a function invocation with its proper implementation.</p>&#13;
<p class="indent">Recall from <a href="ch04.xhtml#ch04">Chapter 4</a> that function overloads allow you to specify functions with the same name but different types and possibly different arguments. The compiler selects among these function overloads by comparing the argument types within the function invocation with the types within each overload declaration. The compiler will choose the best among the possible options, and if it cannot select a best option, it will generate a compiler error.</p>&#13;
<p class="indent">Roughly, the matching process proceeds as follows:</p>&#13;
<ol>&#13;
<li class="noindent">The compiler will look for an exact type match.</li>&#13;
<li class="noindent">The compiler will try using integral and floating-point promotions to get a suitable overload (for example, <span class="literal">int</span> to <span class="literal">long</span> or <span class="literal">float</span> to <span class="literal">double</span>).</li>&#13;
<li class="noindent">The compiler will try to match using standard conversions like integral type to floating-point or casting a pointer-to-child into a pointer-to-parent.</li>&#13;
<li class="noindent">The compiler will look for a user-defined conversion.</li>&#13;
<li class="noindent">The compiler will look for a variadic function.</li>&#13;
</ol>&#13;
<h3 class="h3" id="ch09lev1sec5"><strong><span epub:type="pagebreak" id="page_250"/>Variadic Functions</strong></h3>&#13;
<p class="noindent"><em>Variadic functions</em> take a variable number of arguments. Typically, you specify the exact number of arguments a function takes by enumerating all of its parameters explicitly. With a variadic function, you can take any number of arguments. The variadic function <span class="literal">printf</span> is a canonical example: you provide a format specifier and an arbitrary number of parameters. Because <span class="literal">printf</span> is a variadic function, it accepts any number of parameters.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The astute Pythonista will note an immediate conceptual relationship between variadic functions and <span class="literal">*args</span>/<span class="literal">**kwargs</span>.</em></p>&#13;
</div>&#13;
<p class="indent">You declare variadic functions by placing <span class="literal">...</span> as the final parameter in the function’s argument list. When a variadic function is invoked, the compiler matches arguments against declared arguments. Any leftovers pack into the variadic arguments represented by the <span class="literal">...</span> argument.</p>&#13;
<p class="indent">You cannot extract elements from the variadic arguments directly. Instead, you access individual arguments using the utility functions in the <span class="literal">&lt;cstdarg&gt;</span> header.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09tab01">Table 9-1</a> lists these utility functions.</p>&#13;
<p class="tabcap" id="ch09tab01"><strong>Table 9-1:</strong> Utility Functions in the <span class="literal">&lt;cstdarg&gt;</span> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">va_list</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Used to declare a local variable representing the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">va_start</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Enables access to the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">va_end</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Used to end iteration over the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">va_arg</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Used to iterate over each element in the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">va_copy</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Makes a copy of the variadic arguments</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The utility functions’ usage is a little convoluted and best presented in a cohesive example. Consider the variadic <span class="literal">sum</span> function in <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>, which contains a variadic argument.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
#include &lt;cstdarg&gt;&#13;
&#13;
int sum(size_t n, ...<span class="ent">➊</span>) {&#13;
  va_list args; <span class="ent">➋</span>&#13;
  va_start(args, n); <span class="ent">➌</span>&#13;
  int result{};&#13;
  while (n--) {&#13;
    auto next_element = va_arg(args, int); <span class="ent">➍</span>&#13;
      result += next_element;&#13;
  }&#13;
  va_end(args); <span class="ent">➎</span>&#13;
<span epub:type="pagebreak" id="page_251"/>  return result;&#13;
}&#13;
&#13;
int main() {&#13;
  printf("The answer is %d.", sum(6, 2, 4, 6, 8, 10, 12)); <a id="_idTextAnchor421"/><span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch09ex05"/><em>Listing 9-5: A <span class="literal">sum</span> function with a variadic argument list</em></p>&#13;
<p class="indent">You declare <span class="literal">sum</span> as a variadic function <span class="ent">➊</span>. All variadic functions must declare a <span class="literal">va_list</span>. You’ve named it <span class="literal">args</span> <span class="ent">➋</span>. A <span class="literal">va_list</span> requires initialization with <span class="literal">va_start</span> <span class="ent">➌</span>, which takes two arguments. The first argument is a <span class="literal">va_list</span>, and the second is the size of the variadic arguments. You iterate over each element in the variadic arguments using the <span class="literal">va_args</span> function. The first argument is the <span class="literal">va_list</span> argument, and the second is the argument type <span class="ent">➍</span>. Once you’ve completed iterating, you call <span class="literal">va_end</span> with the <span class="literal">va_list</span> structure <span class="ent">➎</span>.</p>&#13;
<p class="indent">You invoke <span class="literal">sum</span> with seven arguments: the first is the number of variadic arguments (six) followed by six numbers (2, 4, 6, 8, 10, 12) <span class="ent">➏</span>.</p>&#13;
<p class="indent">Variadic functions are a holdover from C. Generally, variadic functions are unsafe and a common source of security vulnerabilities.</p>&#13;
<p class="indent">There are at least two major problems with variadic functions:</p>&#13;
<ul>&#13;
<li class="noindent">Variadic arguments are not type-safe. (Notice that the second argument of <span class="literal">va_arg</span> is a type.)</li>&#13;
<li class="noindent">The number of elements in the variadic arguments must be tracked separately.</li>&#13;
</ul>&#13;
<p class="indent">The compiler cannot help you with either of these issues.</p>&#13;
<p class="indent">Fortunately, variadic templates provide a safer and more performant way to implement variadic functions.</p>&#13;
<h3 class="h3" id="ch09lev1sec6"><strong>Variadic Templates</strong></h3>&#13;
<p class="noindent">The variadic template enables you to create function templates that accept variadic, same-typed arguments. They enable you to employ the considerable power of the template engine. To declare a variadic template, you add a special template parameter called a <em>template parameter pack</em>. <a href="ch09.xhtml#ch09ex06">Listing 9-6</a> demonstrates its usage.</p>&#13;
<pre>template &lt;typename...<span class="ent">➊</span> Args&gt;&#13;
<span class="codeitalic1">return-type</span> <span class="codeitalic1">func-name</span>(Args...<span class="ent">➋</span> args) {&#13;
  // Use parameter pack semantics&#13;
  // within function body&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex06"/><em>Listing 9-6: A template function with a parameter pack</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>The template parameter pack is part of the template parameter list <span class="ent">➊</span>. When you use <span class="literal">Args</span> within the function template <span class="ent">➋</span>, it’s called a <em>function parameter pack</em>. Some special operators are available for use with parameter packs:</p>&#13;
<ul>&#13;
<li class="noindent">You can use <span class="literal">sizeof...(args)</span> to obtain the parameter pack’s size.</li>&#13;
<li class="noindent">You can invoke a function (for example, <span class="literal">other_function</span>) with the special syntax <span class="literal">other_function(args...)</span>. This expands the parameter pack <span class="literal">args</span> and allows you to perform further processing on the arguments contained in the parameter pack.</li>&#13;
</ul>&#13;
<h4 class="h4" id="ch09lev2sec3"><strong><em>Programming with Parameter Packs</em></strong></h4>&#13;
<p class="noindent">Unfortunately, it’s not possible to index into a parameter pack directly. You must invoke the function template from within itself—a process called <em>compile-time recursion</em>—to recursively iterate over the elements in a parameter pack.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex07">Listing 9-7</a> demonstrates the pattern.</p>&#13;
<pre>template &lt;typename T, typename... Args&gt;&#13;
void my_func(T x<span class="ent">➊</span>, Args...args) {&#13;
  // Use x, then recurse:&#13;
  my_func(args...); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex07"/><em>Listing 9-7: A template function illustrating compile-time recursion with parameter packs. Unlike other usage listings, the ellipses contained in this listing are literal.</em></p>&#13;
<p class="indent">The key is to add a regular template parameter before the parameter pack <span class="ent">➊</span>. Each time you invoke <span class="literal">my_func</span>, <span class="literal">x</span> absorbs the first argument. The remainder packs into <span class="literal">args</span>. To invoke, you use the <span class="literal">args...</span> construct to expand the parameter pack <span class="ent">➋</span>.</p>&#13;
<p class="indent">The recursion needs a stopping criteria, so you add a function template specialization without the parameter:</p>&#13;
<pre>template &lt;typename T&gt;&#13;
void my_func(T x) {&#13;
  // Use x, but DON'T recurse&#13;
}</pre>&#13;
<h4 class="h4" id="ch09lev2sec4"><strong><em>Revisiting the sum Function</em></strong></h4>&#13;
<p class="noindent">Consider the (much improved) <span class="literal">sum</span> function implemented as a variadic template in <a href="ch09.xhtml#ch09ex08">Listing 9-8</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
constexpr<span class="ent">➊</span> T sum(T x) { <span class="ent">➋</span>&#13;
    return x;&#13;
<span epub:type="pagebreak" id="page_253"/>}&#13;
&#13;
template &lt;typename T, typename... Args&gt;&#13;
constexpr<span class="ent">➌</span> T sum(T x, Args... args) { <span class="ent">➍</span>&#13;
    return x + sum(args...<span class="ent">➎</span>);&#13;
}&#13;
&#13;
int main() {&#13;
  printf("The answer is %d.", sum(2, 4, 6, 8, 10, 12)); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch09ex08"/><em>Listing 9-8: A refactor of <a href="ch09.xhtml#ch09ex05">Listing 9-5</a> using a template parameter pack instead of <span class="literal">va_args</span></em></p>&#13;
<p class="indent">The first function <span class="ent">➋</span> is the overload that handles the stopping condition; if the function has only a single argument, you simply return the argument <span class="literal">x,</span> because the sum of a single element is just the element. The variadic template <span class="ent">➍</span> follows the recursion pattern outlined in <a href="ch09.xhtml#ch09ex07">Listing 9-7</a>. It peels a single argument <span class="literal">x</span> off the parameter pack <span class="literal">args</span> and then returns <span class="literal">x</span> plus the result of the recursive call to <span class="literal">sum</span> with the expanded parameter pack <span class="ent">➎</span>. Because all of this generic programming can be computed at compile time, you mark these functions <span class="literal">constexpr</span> <span class="ent">➊➌</span>. This compile-time computation is a <em>major</em> advantage over <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>, which has identical output but computes the result at runtime <span class="ent">➏</span>. (Why pay runtime costs when you don’t have to?)</p>&#13;
<p class="indent">When you just want to apply a single binary operator (like plus or minus) over a range of values (like <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>), you can use a fold expression instead of recursion.</p>&#13;
<h4 class="h4" id="ch09lev2sec5"><strong><em>Fold Expressions</em></strong></h4>&#13;
<p class="noindent">A <em>fold expression</em> computes the result of using a binary operator over all the arguments of a parameter pack. Fold expressions are distinct from but related to variadic templates. Their usage is as follows:</p>&#13;
<pre>(... <span class="codeitalic1">binary-operator parameter-pack</span>)</pre>&#13;
<p class="indent">For example, you could employ the following fold expression to sum over all elements in a parameter pack called <span class="literal">args</span>:</p>&#13;
<pre>(... + args)</pre>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex09">Listing 9-9</a> refactors 9-8 to use a fold expression instead of recursion.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;typename... T&gt;&#13;
constexpr auto sum(T... args) {&#13;
  return (... + args); <span class="ent">➊</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_254"/>int main() {&#13;
  printf("The answer is %d.", sum(2, 4, 6, 8, 10, 12)); <span class="ent">➋</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42. <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch09ex09"/><em>Listing 9-9: A refactor of <a href="ch09.xhtml#ch09ex08">Listing 9-8</a> using a fold expression</em></p>&#13;
<p class="indent">You simplify the <span class="literal">sum</span> function by using a fold expression instead of the recursion approach <span class="ent">➊</span>. The end result is identical <span class="ent">➋</span>.</p>&#13;
<h3 class="h3" id="ch09lev1sec7"><strong>Function Pointers</strong></h3>&#13;
<p class="noindent"><em>Functional programming</em> is a programming paradigm that emphasizes function evaluation and immutable data. One of the major concepts in functional programming is to pass a function as a parameter to another function.</p>&#13;
<p class="indent">One way you can achieve this is to pass a function pointer. Functions occupy memory, just like objects. You can refer to this memory address via usual pointer mechanisms. However, unlike objects, you cannot modify the pointed-to function. In this respect, functions are conceptually similar to <span class="literal">const</span> objects. You can take the address of functions and invoke them, and that’s about it.</p>&#13;
<h4 class="h4" id="ch09lev2sec6"><strong><em>Declaring a Function Pointer</em></strong></h4>&#13;
<p class="noindent">To declare a function pointer, use the following ugly syntax:</p>&#13;
<pre><span class="codeitalic1">return-type</span> (*<span class="codeitalic1">pointer-name</span>)(<span class="codeitalic1">arg-type1</span>, <span class="codeitalic1">arg-type2</span>, ...);</pre>&#13;
<p class="indent">This has the same appearance as a function declaration where the function name is replaced (<span class="literal">*<span class="codeitalic">pointer-name</span>)</span>.</p>&#13;
<p class="indent">As usual, you can employ the address-of operator <span class="literal">&amp;</span> to take the address of a function. This is optional, however; you can simply use the function name as a pointer.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex10">Listing 9-10</a> illustrates how you can obtain and use function pointers.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
float add(float a, int b) {&#13;
  return a + b;&#13;
}&#13;
&#13;
float subtract(float a, int b) {&#13;
  return a - b;&#13;
}&#13;
&#13;
int main() {&#13;
  const float first{ 100 };&#13;
  const int second{ 20 };&#13;
&#13;
  float(*operation)(float, int) {}; <span class="ent">➊</span>&#13;
  printf("operation initialized to 0x%p\n", operation); <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_255"/>&#13;
  operation = &amp;add; <span class="ent">➌</span>&#13;
  printf("&amp;add = 0x%p\n", operation); <span class="ent">➍</span>&#13;
  printf("%g + %d = %g\n", first, second, operation(first, second)); <span class="ent">➎</span>&#13;
&#13;
  operation = subtract; <span class="ent">➏</span>&#13;
  printf("&amp;subtract = 0x%p\n", operation); <span class="ent">➐</span>&#13;
  printf("%g - %d = %g\n", first, second, operation(first, second)); <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">operation initialized to 0x0000000000000000 <span class="ent">➋</span></span>&#13;
<span class="color1">&amp;add = 0x00007FF6CDFE1070 <span class="ent">➍</span></span>&#13;
<span class="color1">100 + 20 = 120 <span class="ent">➎</span></span>&#13;
<span class="color1">&amp;subtract = 0x00007FF6CDFE10A0 <span class="ent">➐</span></span>&#13;
<span class="color1">100 - 20 = 80 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch09ex10"/><em>Listing 9-10: A program illustrating function pointers. (Due to address space layout randomization, the addresses <span class="ent">➍➐</span> will vary at runtime.)</em></p>&#13;
<p class="indent">This listing shows two functions with identical function signatures, <span class="literal">add</span> and <span class="literal">subtract</span>. Because the function signatures match, pointer types to these functions will also match. You initialize a function pointer <span class="literal">operation</span> accepting a <span class="literal">float</span> and an <span class="literal">int</span> as arguments and returning a <span class="literal">float</span> <span class="ent">➊</span>. Next, you print the value of <span class="literal">operation</span>, which is <span class="literal">nullptr</span>, after initialization <span class="ent">➋</span>.</p>&#13;
<p class="indent">You then assign the address of <span class="literal">add</span> to <span class="literal">operation</span> <span class="ent">➌</span> using the address-of operator and print its new address <span class="ent">➍</span>. You invoke <span class="literal">operation</span> and print the result <span class="ent">➎</span>.</p>&#13;
<p class="indent">To illustrate that you can reassign function pointers, you assign <span class="literal">operation</span> to <span class="literal">subtract</span> without using the address of operator <span class="ent">➏</span>, print the new value of <span class="literal">operation</span> <span class="ent">➐</span>, and finally print the result <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch09lev2sec7"><strong><em>Type Aliases and Function Pointers</em></strong></h4>&#13;
<p class="noindent">Type aliases provide a neat way to program with function pointers. The usage is as follows:</p>&#13;
<pre>using <span class="codeitalic1">alias-name</span> = <span class="codeitalic1">return-type</span>(*)(<span class="codeitalic1">arg-type1</span>, <span class="codeitalic1">arg-type2</span>, ...)</pre>&#13;
<p class="indent">You could have defined an <span class="literal">operation_func</span> type alias in <a href="ch09.xhtml#ch09ex10">Listing 9-10</a>, for example:</p>&#13;
<pre>using operation_func = float(*)(float, int);</pre>&#13;
<p class="indent">This is especially useful if you’ll be using function pointers of the same type; it can really clean up the code.</p>&#13;
<h3 class="h3" id="ch09lev1sec8"><strong>The Function-Call Operator</strong></h3>&#13;
<p class="noindent">You can make user-defined types callable or invocable by overloading the function-call operator <span class="literal">operator()()</span>. Such a type is called a <em>function type</em>, and instances of a function type are called <em>function objects</em>. The function-call <span epub:type="pagebreak" id="page_256"/>operator permits any combination of argument types, return types, and modifiers (except <span class="literal">static</span>).</p>&#13;
<p class="indent">The primary reason you might want to make a user-defined type callable is to interoperate with code that expects function objects to use the function-call operator. You’ll find that many libraries, such as the stdlib, use the function-call operator as the interface for function-like objects. For example, in <a href="ch19.xhtml#ch19">Chapter 19</a>, you’ll learn how to create an asynchronous task with the <span class="literal">std::async</span> function, which accepts an arbitrary function object that can execute on a separate thread. It uses the function-call operator as the interface. The committee that invented <span class="literal">std::async</span> could have required you to expose, say, a <span class="literal">run</span> method, but they chose the function-call operator because it allows generic code to use identical notation to invoke a function or a function object.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex11">Listing 9-11</a> illustrates the function-call operator’s usage.</p>&#13;
<pre>struct <span class="codeitalic1">type-name</span> {&#13;
  <span class="codeitalic1">return-type</span><span class="ent">➊</span> operator()<span class="ent">➋</span>(<span class="codeitalic1">arg-type1</span> arg1, <span class="codeitalic1">arg-type2</span> arg2, ...<span class="ent">➌</span>) {&#13;
    // Body of function-call operator&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex11"/><em>Listing 9-11: The function-call operator’s usage</em></p>&#13;
<p class="indent">The function-call operator has the special <span class="literal">operator()</span> method name <span class="ent">➋</span>. You declare an arbitrary number of arguments <span class="ent">➌</span>, and you also decide the appropriate return type <span class="ent">➊</span>.</p>&#13;
<p class="indent">When the compiler evaluates a function-call expression, it will invoke the function-call operator on the first operand, passing the remaining operands as arguments. The result of the function-call expression is the result of invoking the corresponding function-call operator.</p>&#13;
<h3 class="h3" id="ch09lev1sec9"><strong>A Counting Example</strong></h3>&#13;
<p class="noindent">Consider the function type <span class="literal">CountIf</span> in <a href="ch09.xhtml#ch09ex12">Listing 9-12</a>, which computes the frequency of a particular <span class="literal">char</span> in a null-terminated string.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
struct CountIf {&#13;
  CountIf(char x) : x{ x } { }<span class="ent">➊</span>&#13;
  size_t operator()(const char* str<span class="ent">➋</span>) const {&#13;
    size_t index{}<span class="ent">➌</span>, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == x) result++; <span class="ent">➍</span>&#13;
      index++;&#13;
    }&#13;
    return result;&#13;
  }&#13;
private:&#13;
  const char x;&#13;
<span epub:type="pagebreak" id="page_257"/>};&#13;
&#13;
int main() {&#13;
  CountIf s_counter{ 's' }; <span class="ent">➎</span>&#13;
  auto sally = s_counter("Sally sells seashells by the seashore."); <span class="ent">➏</span>&#13;
  printf("Sally: %zu\n", sally);&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
  auto buffalo = CountIf{ 'f' }("Buffalo buffalo Buffalo buffalo "&#13;
                                "buffalo buffalo Buffalo buffalo."); <span class="ent">➐</span>&#13;
  printf("Buffalo: %zu\n", buffalo);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Buffalo: 16</span></pre>&#13;
<p class="listing"><a id="ch09ex12"/><em>Listing 9-12: A function type that counts the number of characters appearing in a null-terminated string</em></p>&#13;
<p class="indent">You initialize <span class="literal">CountIf</span> objects using a constructor taking a <span class="literal">char</span> <span class="ent">➊</span>. You can call the resulting function object as if it were a function taking a null-terminated string argument <span class="ent">➋</span>, because you’ve implemented the function call operator. The function call operator iterates through each character in the argument <span class="literal">str</span> using an <span class="literal">index</span> variable <span class="ent">➌</span>, incrementing the <span class="literal">result</span> variable whenever the character matches the <span class="literal">x</span> field <span class="ent">➍</span>. Because calling the function doesn’t modify the state of a <span class="literal">CountIf</span> object, you’ve marked it <span class="literal">const</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you’ve initialized the <span class="literal">CountIf</span> function object <span class="literal">s_counter</span>, which will count the frequency of the letter <span class="literal">s</span> <span class="ent">➎</span>. You can use <span class="literal">s_counter</span> as if it were a function <span class="ent">➏</span>. You can even initialize a <span class="literal">CountIf</span> object and use the function operator directly as an rvalue object <span class="ent">➐</span>. You might find this convenient to do in some settings where, for example, you might only need to invoke the object a single time.</p>&#13;
<p class="indent">You can employ function objects as partial applications. <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> is conceptually similar to the <span class="literal">count_if</span> function in <a href="ch09.xhtml#ch09ex13">Listing 9-13</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
size_t count_if(char x<span class="ent">➊</span>, const char* str) {&#13;
  size_t index{}, result{};&#13;
  while (str[index]) {&#13;
    if (str[index] == x) result++;&#13;
    index++;&#13;
  }&#13;
  return result;&#13;
}&#13;
&#13;
int main() {&#13;
  auto sally = count_if('s', "Sally sells seashells by the seashore.");&#13;
  printf("Sally: %zu\n", sally);&#13;
  auto sailor = count_if('s', "Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
<span epub:type="pagebreak" id="page_258"/>  auto buffalo = count_if('f', "Buffalo buffalo Buffalo buffalo "&#13;
                               "buffalo buffalo Buffalo buffalo.");&#13;
  printf("Buffalo: %zu\n", buffalo);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Buffalo: 16</span></pre>&#13;
<p class="listing"><a id="ch09ex13"/><em>Listing 9-13: A free function emulating <a href="ch09.xhtml#ch09ex12">Listing 9-12</a></em></p>&#13;
<p class="indent">The <span class="literal">count_if</span> function has an extra argument <span class="literal">x</span> <span class="ent">➊</span>, but otherwise it’s almost identical to the function operator of <span class="literal">CountIf</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In functional programming parlance, the <span class="literal">CountIf</span> is the <span class="literal">partial application</span> of <span class="literal">x</span> to <span class="literal">count_if</span>. When you partially apply an argument to a function, you fix that argument’s value. The product of such a partial application is another function taking one less argument.</em></p>&#13;
</div>&#13;
<p class="indent">Declaring function types is verbose. You can often reduce the boilerplate substantially with lambda expressions.</p>&#13;
<h3 class="h3" id="ch09lev1sec10"><strong>Lambda Expressions</strong></h3>&#13;
<p class="noindent"><em>Lambda expressions</em> construct unnamed function objects succinctly. The function object implies the function type, resulting in a quick way to declare a function object on the fly. Lambdas don’t provide any additional functionality other than declaring function types the old-fashioned way. But they’re extremely convenient when you need to initialize a function object in only a single context.</p>&#13;
<h4 class="h4" id="ch09lev2sec8"><strong><em>Usage</em></strong></h4>&#13;
<p class="noindent">There are five components to a lambda expression:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal"><em>captures</em></span>: The member variables of the function object (that is, the partially applied parameters)</li>&#13;
<li class="noindent"><span class="literal"><em>parameters</em></span>: The arguments required to invoke the function object</li>&#13;
<li class="noindent"><span class="literal"><em>body</em></span>: The function object’s code</li>&#13;
<li class="noindent"><span class="literal"><em>specifiers</em></span>: Elements like <span class="literal">constexpr, mutable</span>, <span class="literal">noexcept</span>, and <span class="literal">[[noreturn]]</span></li>&#13;
<li class="noindent"><span class="literal"><em>return type</em></span>: The type returned by the function object</li>&#13;
</ul>&#13;
<p class="indent">Lambda expression usage is as follows:</p>&#13;
<pre>[<span class="codeitalic1">captures</span><span class="ent">➊</span>] (<span class="codeitalic1">parameters</span><span class="ent">➋</span>) <span class="codeitalic1">specifiers</span><span class="ent">➌</span> -&gt; <span class="codeitalic1">return-type</span><span class="ent">➍</span> { <span class="codeitalic1">body</span><span class="ent">➎</span> }</pre>&#13;
<p class="indent">Only the captures and the body are required; everything else is optional. You’ll learn about each of these components in depth in the next few sections.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>Each lambda component has a direct analogue in a function object. To form a bridge between the function objects like <span class="literal">CountIf</span> and lambda expressions, look at <a href="ch09.xhtml#ch09ex14">Listing 9-14</a>, which lists the <span class="literal">CountIf</span> function type from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> with annotations that correspond to the analogous portions of the lambda expression in the usage listing.</p>&#13;
<pre>struct CountIf {&#13;
  CountIf(char x) : x{ x } { } <span class="ent">➊</span>&#13;
  size_t<span class="ent">➍</span> operator()(const char* str<span class="ent">➋</span>) const<span class="ent">➎</span> {&#13;
    --<span class="codeitalic1">snip</span>--<span class="ent">➌</span>&#13;
  }&#13;
private:&#13;
  const char x; <span class="ent">➋</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch09ex14"/><em>Listing 9-14: Comparing the <span class="literal">CountIf</span> type declaration with a lambda expression</em></p>&#13;
<p class="indent">The member variables you set in the constructor of <span class="literal">CountIf</span> are analogous to a lambda’s capture <span class="ent">➊</span>. The function-call operator’s arguments <span class="ent">➋</span>, body <span class="ent">➌</span>, and return type <span class="ent">➍</span> are analogous to the lambda’s parameters, body, and return type. Finally, modifiers can apply to the function-call operator <span class="ent">➎</span> and the lambda. (The numbers in the Lambda expession usage example and <a href="ch09.xhtml#ch09ex14">Listing 9-14</a> correspond.)</p>&#13;
<h4 class="h4" id="ch09lev2sec9"><strong><em>Lambda Parameters and Bodies</em></strong></h4>&#13;
<p class="noindent">Lambda expressions produce function objects. As function objects, lambdas are callable. Most of the time, you’ll want your function object to accept parameters upon invocation.</p>&#13;
<p class="indent">The lambda’s body is just like a function body: all of the parameters have function scope.</p>&#13;
<p class="indent">You declare lambda parameters and bodies using essentially the same syntax that you use for functions.</p>&#13;
<p class="indent">For example, the following lambda expression yields a function object that will square its <span class="literal">int</span> argument:</p>&#13;
<pre>[](int x) { return x*x; }</pre>&#13;
<p class="indent">The lambda takes a single <span class="literal">int x</span> and uses it within the lambda’s body to perform the squaring.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex15">Listing 9-15</a> employs three different lambdas to transform the array <span class="literal">1, 2, 3</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
template &lt;typename Fn&gt;&#13;
void transform(Fn fn, const int* in, int* out, size_t length) { <span class="ent">➊</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    out[i] = fn(in[i]); <span class="ent">➋</span>&#13;
  }&#13;
<span epub:type="pagebreak" id="page_260"/>}&#13;
&#13;
int main() {&#13;
  const size_t len{ 3 };&#13;
  int base[]{ 1, 2, 3 }, a[len], b[len], c[len];&#13;
  transform([](int x) { return 1; }<span class="ent">➌</span>, base, a, len);&#13;
  transform([](int x) { return x; }<span class="ent">➍</span>, base, b, len);&#13;
  transform([](int x) { return 10*x+5; }<span class="ent">➎</span>, base, c, len);&#13;
  for (size_t i{}; i &lt; len; i++) {&#13;
    printf("Element %zu: %d %d %d\n", i, a[i], b[i], c[i]);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Element 0: 1 1 15</span>&#13;
<span class="color1">Element 1: 1 2 25</span>&#13;
<span class="color1">Element 2: 1 3 35</span></pre>&#13;
<p class="listing"><a id="ch09ex15"/><em>Listing 9-15: Three lambdas and a transform function</em></p>&#13;
<p class="indent">The <span class="literal">transform</span> template function <span class="ent">➊</span> accepts four arguments: a function object <span class="literal">fn</span>, an <span class="literal">in</span> array and an <span class="literal">out</span> array, and the corresponding <span class="literal">length</span> of those arrays. Within transform, you invoke <span class="literal">fn</span> on each element of <span class="literal">in</span> and assign the result to the corresponding element of <span class="literal">out</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you declare a <span class="literal">base</span> array <span class="literal">1, 2, 3</span> that will be used as the <span class="literal">in</span> array. In the same line you also declare three uninitialized arrays <span class="literal">a, b</span>, and <span class="literal">c</span>, which will be used as the <span class="literal">out</span> arrays. The first call to <span class="literal">transform</span> passes a lambda <span class="literal">([](int x) { return 1; })</span> that always returns 1 <span class="ent">➌</span>, and the result is stored into <span class="literal">a</span>. (Notice that the lambda didn’t need a name!) The second call to <span class="literal">transform ([](int x) { return x; })</span> simply returns its argument <span class="ent">➍</span>, and the result is stored into <span class="literal">b</span>. The third call to <span class="literal">transform</span> multiplies the argument by 10 and adds 5 <span class="ent">➎</span>. The result is stored in <span class="literal">c</span>. You then print the output into a matrix where each column illustrates the transform that was applied to the different lambdas in each case.</p>&#13;
<p class="indent">Notice that you declared <span class="literal">transform</span> as a template function, allowing you to reuse it with any function object.</p>&#13;
<h4 class="h4" id="ch09lev2sec10"><strong><em>Default Arguments</em></strong></h4>&#13;
<p class="noindent">You can provide default arguments to a lambda. Default lambda parameters behave just like default function parameters. The caller can specify values for default parameters, in which case the lambda uses the caller-provided values. If the caller doesn’t specify a value, the lambda uses the default.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex16">Listing 9-16</a> illustrates the default argument behavior.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  auto increment = [](auto x, int y = 1<span class="ent">➊</span>) { return x + y; };&#13;
  printf("increment(10)    = %d\n", increment(10)); <span class="ent">➋</span>&#13;
  printf("increment(10, 5) = %d\n", increment(10, 5)); <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_261"/>increment(10)    = 11 <span class="ent">➋</span></span>&#13;
<span class="color1">increment(10, 5) = 15 <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch09ex16"/><em>Listing 9-16: Using default lambda parameters</em></p>&#13;
<p class="indent">The increment lambda has two parameters, <span class="literal">x</span> and <span class="literal">y</span>. But the <span class="literal">y</span> parameter is optional because it has the default argument 1 <span class="ent">➊</span>. If you don’t specify an argument for <span class="literal">y</span> when you call the function <span class="ent">➋, increment</span> returns <span class="literal">1 + x</span>. If you do call the function with an argument for <span class="literal">y</span> <span class="ent">➌</span>, that value is used instead.</p>&#13;
<h4 class="h4" id="ch09lev2sec11"><strong><em>Generic Lambdas</em></strong></h4>&#13;
<p class="noindent">Generic lambdas are lambda expression templates. For one or more parameters, you specify <span class="literal">auto</span> rather than a concrete type. These <span class="literal">auto</span> types become template parameters, meaning the compiler will stamp out a custom instantiation of the lambda.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex17">Listing 9-17</a> illustrates how to assign a generic lambda into a variable and then use the lambda in two different template instantiations.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
template &lt;typename Fn, typename T<span class="ent">➊</span>&gt;&#13;
void transform(Fn fn, const T* in, T* out, size_t len) {&#13;
  for(size_t i{}; i&lt;len; i++) {&#13;
    out[i] = fn(in[i]);&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  constexpr size_t len{ 3 };&#13;
  int base_int[]{ 1, 2, 3 }, a[len]; <span class="ent">➋</span>&#13;
  float base_float[]{ 10.f, 20.f, 30.f }, b[len]; <span class="ent">➌</span>&#13;
  auto translate = [](auto x) { return 10 * x + 5; }; <span class="ent">➍</span>&#13;
  transform(translate, base_int, a, l); <span class="ent">➎</span>&#13;
  transform(translate, base_float, b, l); <span class="ent">➏</span>&#13;
&#13;
  for (size_t i{}; i &lt; l; i++) {&#13;
    printf("Element %zu: %d %f\n", i, a[i], b[i]);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Element 0: 15 105.000000</span>&#13;
<span class="color1">Element 1: 25 205.000000</span>&#13;
<span class="color1">Element 2: 35 305.000000</span></pre>&#13;
<p class="listing"><a id="ch09ex17"/><em>Listing 9-17: Using a generic lambda</em></p>&#13;
<p class="indent">You add a second template parameter to <span class="literal">transform</span> <span class="ent">➊</span>, which you use as the pointed-to type of <span class="literal">in</span> and <span class="literal">out</span>. This allows you to apply transform to arrays of any type, not just of <span class="literal">int</span> types. To test out the upgraded transform template, you declare two arrays with different pointed-to types: <span class="literal">int</span> <span class="ent">➋</span> and <span epub:type="pagebreak" id="page_262"/><span class="literal">float</span> <span class="ent">➌</span>. (Recall from <a href="ch03.xhtml#ch03">Chapter 3</a> that the <span class="literal">f</span> in <span class="literal">10.f</span> specifies a <span class="literal">float</span> literal.) Next, you assign a generic lambda expression to <span class="literal">translate</span> <span class="ent">➍</span>. This allows you to use the same lambda for each instantiation of transform: when you instantiate with <span class="literal">base_int</span> <span class="ent">➎</span> and with <span class="literal">base_float</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Without a generic lambda, you’d have to declare the parameter types explicitly, like the following:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>–&#13;
  transform([](int x) { return 10 * x + 5; }, base_int, a, l); <span class="ent">➎</span>&#13;
  transform([](double x) { return 10 * x + 5; }, base_float, b, l); <span class="ent">➏</span></pre>&#13;
<p class="indent">So far, you’ve been leaning on the compiler to deduce the return types of your lambdas. This is especially useful for generic lambdas, because often the lambda’s return type will depend on its parameter types. But you can explicitly state the return type if you want.</p>&#13;
<h4 class="h4" id="ch09lev2sec12"><strong><em>Lambda Return Types</em></strong></h4>&#13;
<p class="noindent">The compiler deduces a lambda’s return type for you. To take over from the compiler, you use the arrow <span class="literal">-&gt;</span> syntax, as in the following:</p>&#13;
<pre>[](int x, double y) -&gt; double { return x + y; }</pre>&#13;
<p class="indent">This lambda expression accepts an <span class="literal">int</span> and a <span class="literal">double</span> and returns a <span class="literal">double</span>.</p>&#13;
<p class="indent">You can also use <span class="literal">decltype</span> expressions, which can be useful with generic lambdas. For example, consider the following lambda:</p>&#13;
<pre>[](auto x, double y) -&gt; decltype(x+y) { return x + y; }</pre>&#13;
<p class="indent">Here you’ve explicitly declared that the return type of the lambda is whatever type results from adding an <span class="literal">x</span> to a <span class="literal">y</span>.</p>&#13;
<p class="indent">You’ll rarely need to specify a lambda’s return type explicitly.</p>&#13;
<p class="indent">A far more common requirement is that you must inject an object into a lambda before invocation. This is the role of lambda captures.</p>&#13;
<h4 class="h4" id="ch09lev2sec13"><strong><em>Lambda Captures</em></strong></h4>&#13;
<p class="noindent"><em>Lambda captures</em> inject objects into the lambda. The injected objects help to modify the behavior of the lambda.</p>&#13;
<p class="indent">Declare a lambda’s capture by specifying a capture list within brackets <span class="literal">[]</span>. The capture list goes before the parameter list, and it can contain any number of comma-separated arguments. You then use these arguments within the lambda’s body.</p>&#13;
<p class="indent">A lambda can capture by reference or by value. By default, lambdas capture by value.</p>&#13;
<p class="indent">A lambda’s capture list is analogous to a function type’s constructor. <a href="ch09.xhtml#ch09ex18">Listing 9-18</a> reformulates <span class="literal">CountIf</span> from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> as the lambda <span class="literal">s_counter</span>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_263"/>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  char to_count{ 's' }; <span class="ent">➊</span>&#13;
  auto s_counter = [to_count<span class="ent">➋</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count<span class="ent">➌</span>) result++;&#13;
      index++;&#13;
    }&#13;
    return result;&#13;
  };&#13;
  auto sally = s_counter("Sally sells seashells by the seashore."<span class="ent">➍</span>);&#13;
  printf("Sally: %zu\n", sally);&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Sailor: 3</span></pre>&#13;
<p class="listing"><a id="ch09ex18"/><em>Listing 9-18: Reformulating <span class="literal">CountIf</span> from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> as a lambda</em></p>&#13;
<p class="indent">You initialize a <span class="literal">char</span> called <span class="literal">to_count</span> to the letter <span class="literal">s</span> <span class="ent">➊</span>. Next, you capture <span class="literal">to_count</span> within the lambda expression assigned to <span class="literal">s_counter</span> <span class="ent">➋</span>. This makes <span class="literal">to_count</span> available within the body of the lambda expression <span class="ent">➌</span>.</p>&#13;
<p class="indent">To capture an element by reference rather than by value, prefix the captured object’s name with an ampersand <span class="literal">&amp;</span>. <a href="ch09.xhtml#ch09ex19">Listing 9-19</a> adds a capture reference to <span class="literal">s_counter</span> that keeps a running tally across lambda invocations.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  char to_count{ 's' };&#13;
  size_t tally{};<span class="ent">➊</span>&#13;
  auto s_counter = [to_count, &amp;tally<span class="ent">➋</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count) result++;&#13;
      index++;&#13;
    }&#13;
    tally += result;<span class="ent">➌</span>&#13;
    return result;&#13;
  };&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➍</span>&#13;
  auto sally = s_counter("Sally sells seashells by the seashore.");&#13;
  printf("Sally: %zu\n", sally);&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➎</span>&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
<span epub:type="pagebreak" id="page_264"/>  printf("Tally: %zu\n", tally); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Tally: 0 <span class="ent">➍</span></span>&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Tally: 7 <span class="ent">➎</span></span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Tally: 10 <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch09ex19"/><em>Listing 9-19: Using a capture reference in a lambda</em></p>&#13;
<p class="indent">You initialize the counter variable <span class="literal">tally</span> to zero <span class="ent">➊</span>, and then the <span class="literal">s_counter</span> lambda captures <span class="literal">tally</span> by reference (note the ampersand <span class="literal">&amp;</span>) <span class="ent">➋</span>. Within the lambda’s body, you add a statement to increment <span class="literal">tally</span> by an invocation’s <span class="literal">result</span> before returning <span class="ent">➌</span>. The result is that <span class="literal">tally</span> will track the total count no matter how many times you invoke the lambda. Before the first <span class="literal">s_counter</span> invocation, you print the value of <span class="literal">tally</span> <span class="ent">➍</span> (which is still zero). After you invoke <span class="literal">s_counter</span> with <span class="literal">Sally sells seashells by the seashore.</span>, you have a <span class="literal">tally</span> of 7 <span class="ent">➎</span>. The last invocation of <span class="literal">s_counter</span> with <span class="literal">Sailor went to sea to see what he could see.</span> returns 3, so the value of <span class="literal">tally</span> is 7 + 3 = 10 <span class="ent">➏</span>.</p>&#13;
<h5 class="h5" id="ch09lev3sec3"><strong>Default Capture</strong></h5>&#13;
<p class="noindent">So far, you’ve had to capture each element by name. Sometimes this style of capturing is called <em>named capture</em>. If you’re lazy, you can capture all automatic variables used within a lambda using <em>default capture</em>. To specify a default capture by value within a capture list, use a lone equal sign <span class="literal">=</span>. To specify a default capture by reference, use a lone ampersand <span class="literal">&amp;</span>.</p>&#13;
<p class="indent">For example, you could “simplify” the lambda expression in <a href="ch09.xhtml#ch09ex19">Listing 9-19</a> to perform a default capture by reference, as demonstrated in <a href="ch09.xhtml#ch09ex20">Listing 9-20</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
  auto s_counter = [&amp;<span class="ent">➊</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count<span class="ent">➋</span>) result++;&#13;
      index++;&#13;
    }&#13;
    tally<span class="ent">➌</span> += result;&#13;
    return result;&#13;
  };&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="listing"><a id="ch09ex20"/><em>Listing 9-20: Simplifying a lambda expression with a default capture by reference</em></p>&#13;
<p class="indent">You specify a default capture by reference <span class="ent">➊</span>, which means any automatic variables in the body of the lambda expression get captured by reference. There are two: <span class="literal">to_count</span> <span class="ent">➋</span> and <span class="literal">tally</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">If you compile and run the refactored listing, you’ll obtain identical output. However, notice that <span class="literal">to_count</span> is now captured by reference. If you <span epub:type="pagebreak" id="page_265"/>accidentally modify it within the lambda expression’s body, the change will occur across lambda invocations as well as within <span class="literal">main</span> (where <span class="literal">to_count</span> is an automatic variable).</p>&#13;
<p class="indent">What would happen if you performed a default capture by value instead? You would only need to change the <span class="literal">=</span> to an <span class="literal">&amp;</span> in the capture list, as demonstrated in <a href="ch09.xhtml#ch09ex21">Listing 9-21</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
  auto s_counter = [=<span class="ent">➊</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count<span class="ent">➋</span>) result++;&#13;
      index++;&#13;
    }&#13;
    tally<span class="ent">➌</span> += result;&#13;
    return result;&#13;
  };&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="listing"><a id="ch09ex21"/><em>Listing 9-21: Modifying <a href="ch09.xhtml#ch09ex20">Listing 9-20</a> to capture by value instead of by reference (This code doesn't compile.)</em></p>&#13;
<p class="indent">You change the default capture to be by value <span class="ent">➊</span>. The <span class="literal">to_count</span> capture is unaffected <span class="ent">➋</span>, but attempting to modify <span class="literal">tally</span> results in a compiler error <span class="ent">➌</span>. You’re not allowed to modify variables captured by value unless you add the <span class="literal">mutable</span> keyword to the lambda expression. The <span class="literal">mutable</span> keyword allows you to modify value-captured variables. This includes calling non-<span class="literal">const</span> methods on that object.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex22">Listing 9-22</a> adds the <span class="literal">mutable</span> modifier and has a default capture by value.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  char to_count{ 's' };&#13;
  size_t tally{};&#13;
  auto s_counter = [=<span class="ent">➊</span>](const char* str) mutable<span class="ent">➋</span> {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count) result++;&#13;
      index++;&#13;
    }&#13;
    tally += result;&#13;
    return result;&#13;
  };&#13;
  auto sally = s_counter("Sally sells seashells by the seashore.");&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➌</span>&#13;
  printf("Sally: %zu\n", sally);&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➍</span>&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
<span epub:type="pagebreak" id="page_266"/>  printf("Tally: %zu\n", tally); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Tally: 0</span>&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Tally: 0</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Tally: 0</span></pre>&#13;
<p class="listing"><a id="ch09ex22"/><em>Listing 9-22: A <span class="literal">mutable</span> lambda expression with a default capture by value</em></p>&#13;
<p class="indent">You declare a default capture by value <span class="ent">➊</span>, and you make the lambda <span class="literal">s_counter mutable</span> <span class="ent">➋</span>. Each of the three times you print <span class="literal">tally</span> <span class="ent">➌➍➎</span>, you get a zero value. Why?</p>&#13;
<p class="indent">Because <span class="literal">tally</span> gets copied by value (via the default capture), the version in the lambda is, in essence, an entirely different variable that just happens to have the same name. Modifications to the lambda’s copy of <span class="literal">tally</span> don’t affect the automatic <span class="literal">tally</span> variable of <span class="literal">main</span>. The <span class="literal">tally</span> in <span class="literal">main()</span> is initialized to zero and never gets modified.</p>&#13;
<p class="indent">It’s also possible to mix a default capture with a named capture. You could, for example, default capture by reference and copy <span class="literal">to_count</span> by value using the following formulation:</p>&#13;
<pre>  auto s_counter = [&amp;<span class="ent">➊</span>,to_count<span class="ent">➋</span>](const char* str) {&#13;
    --<span class="codeitalic1">snip</span>--&#13;
  };</pre>&#13;
<p class="indent">This specifies a default capture by reference <span class="ent">➊</span> and <span class="literal">to_count</span> <span class="ent">➋</span> capture by value.</p>&#13;
<p class="indent">Although performing a default capture might seem like an easy shortcut, refrain from using it. It’s far better to declare captures explicitly. If you catch yourself saying “I’ll just use a default capture because there are too many variables to list out,” you probably need to refactor your code.</p>&#13;
<h5 class="h5" id="ch09lev3sec4"><strong>Initializer Expressions in Capture Lists</strong></h5>&#13;
<p class="noindent">Sometimes you want to initialize a whole new variable within a capture list. Maybe renaming a captured variable would make a lambda expression’s intent clearer. Or perhaps you want to move an object into a lambda and therefore need to initialize a variable.</p>&#13;
<p class="indent">To use an initializer expression, just declare the new variable’s name followed by an equal sign and the value you want to initialize your variable with, as <a href="ch09.xhtml#ch09ex23">Listing 9-23</a> demonstrates.</p>&#13;
<pre>  auto s_counter = [&amp;tally<span class="ent">➊</span>,my_char=to_count<span class="ent">➋</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == my_char<span class="ent">➌</span>) result++;&#13;
    --<span class="codeitalic1">snip</span>--&#13;
  };</pre>&#13;
<p class="listing"><a id="ch09ex23"/><em>Listing 9-23: Using an initializer expression within a lambda capture</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_267"/>The capture list contains a simple named capture where you have <span class="literal">tally</span> by reference <span class="ent">➊</span>. The lambda also captures <span class="literal">to_count</span> by value, but you’ve elected to use the variable name <span class="literal">my_char</span> instead <span class="ent">➋</span>. Of course, you’ll need to use the name <span class="literal">my_char</span> instead of <span class="literal">to_count</span> inside the lambda <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>An initializer expression in a capture list is also called an init capture.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec5"><strong>Capturing this</strong></h5>&#13;
<p class="noindent">Sometimes lambda expressions have an enclosing class. You can capture an enclosing object (pointed-to by <span class="literal">this</span>) by value or by reference using either <span class="literal">[*this]</span> or <span class="literal">[this]</span>, respectively.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex24">Listing 9-24</a> implements a <span class="literal">LambdaFactory</span> that generates counting lambdas and keeps track of a <span class="literal">tally</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
struct LambdaFactory {&#13;
  LambdaFactory(char in) : to_count{ in }, tally{} { }&#13;
  auto make_lambda() { <span class="ent">➊</span>&#13;
    return [this<span class="ent">➋</span>](const char* str) {&#13;
      size_t index{}, result{};&#13;
      while (str[index]) {&#13;
        if (str[index] == to_count<span class="ent">➌</span>) result++;&#13;
        index++;&#13;
      }&#13;
      tally<span class="ent">➍</span> += result;&#13;
      return result;&#13;
    };&#13;
  }&#13;
  const char to_count;&#13;
  size_t tally;&#13;
};&#13;
&#13;
int main() {&#13;
  LambdaFactory factory{ 's' }; <span class="ent">➎</span>&#13;
  auto lambda = factory.make_lambda(); <span class="ent">➏</span>&#13;
  printf("Tally: %zu\n", factory.tally);&#13;
  printf("Sally: %zu\n", lambda("Sally sells seashells by the seashore."));&#13;
  printf("Tally: %zu\n", factory.tally);&#13;
  printf("Sailor: %zu\n", lambda("Sailor went to sea to see what he could see."));&#13;
  printf("Tally: %zu\n", factory.tally);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Tally: 0</span>&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Tally: 7</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Tally: 10</span></pre>&#13;
<p class="listing"><a id="ch09ex24"/><em>Listing 9-24: A <span class="literal">LambdaFactory</span> illustrating the use of <span class="literal">this</span> capture</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>The <span class="literal">LambdaFactory</span> constructor takes a single character and initializes the <span class="literal">to_count</span> field with it. The <span class="literal">make_lambda</span> <span class="ent">➊</span> method illustrates how you can capture <span class="literal">this</span> by reference <span class="ent">➋</span> and use the <span class="literal">to_count</span> <span class="ent">➌</span> and <span class="literal">tally</span> <span class="ent">➍</span> member variables within the lambda expression.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you initialize a <span class="literal">factory</span> <span class="ent">➎</span> and make a <span class="literal">lambda</span> using the <span class="literal">make_</span><span class="literal">lambda</span> method <span class="ent">➏</span>. The output is identical to <a href="ch09.xhtml#ch09ex19">Listing 9-19</a>, because you capture <span class="literal">this</span> by reference and state of <span class="literal">tally</span> persists across invocations of <span class="literal">lambda</span>.</p>&#13;
<h5 class="h5" id="ch09lev3sec6"><strong>Clarifying Examples</strong></h5>&#13;
<p class="noindent">There are a lot of possibilities with capture lists, but once you have a command of the basics–capturing by value and by reference–there aren’t many surprises. <a href="ch09.xhtml#ch09tab02">Table 9-2</a> provides short, clarifying examples that you can use for future reference.</p>&#13;
<p class="tabcap"><a id="ch09tab02"><strong>Table 9-2:</strong> Clarifying Examples of Lambda Capture Lists</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Capture list</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">[&amp;]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Default capture by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[&amp;,i]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default capture by reference; capture <span class="literal">i</span> by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">[=]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Default capture by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[=,&amp;i]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default capture by value; capture <span class="literal">i</span> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">[i]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Capture <span class="literal">i</span> by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[&amp;i]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Capture <span class="literal">i</span> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">[i,&amp;j]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Capture <span class="literal">i</span> by value; capture <span class="literal">j</span> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[i=j,&amp;k]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Capture <span class="literal">j</span> by value as <span class="literal">i</span>; capture <span class="literal">k</span> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">[this]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Capture <span class="literal">enclosing object</span> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">[*this]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Capture <span class="literal">enclosing object</span> by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">[=,*this,i,&amp;j]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Default capture by value; capture <span class="literal">this</span> and <span class="literal">i</span> by value; capture <span class="literal">j</span> by reference</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch09lev2sec14"><strong><em>constexpr Lambda Expressions</em></strong></h4>&#13;
<p class="noindent">All lambda expressions are <span class="literal">constexpr</span> as long as the lambda can be invoked at compile time. You can optionally make the <span class="literal">constexpr</span> declaration explicit, as in the following:</p>&#13;
<pre>[] (int x) constexpr { return x * x; }</pre>&#13;
<p class="indent">You should mark a lambda <span class="literal">constexpr</span> if you want to make sure that it meets all <span class="literal">constexpr</span> requirements. As of C++17, this means no dynamic memory allocations and no calling non-<span class="literal">constexpr</span> functions, among other restrictions. The standards committee plans to loosen these restrictions with each release, so if you write a lot of code using <span class="literal">constexpr</span>, be sure to brush up on the latest <span class="literal">constexpr</span> constraints.</p>&#13;
<h3 class="h3" id="ch09lev1sec11"><span epub:type="pagebreak" id="page_269"/><strong>std::function</strong></h3>&#13;
<p class="noindent">Sometimes you just want a uniform container for storing callable objects. The <span class="literal">std::function</span> class template from the <span class="literal">&lt;functional&gt;</span> header is a polymorphic wrapper around a callable object. In other words, it’s a generic function pointer. You can store a static function, a function object, or a lambda into a <span class="literal">std::function</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="literal"><em>function</em></span> class is in the stdlib. We’re presenting it a little ahead of schedule because it fits naturally.</em></p>&#13;
</div>&#13;
<p class="indent">With <span class="literal">functions</span>, you can:</p>&#13;
<ul>&#13;
<li class="noindent">Invoke without the caller knowing the function’s implementation</li>&#13;
<li class="noindent">Assign, move, and copy</li>&#13;
<li class="noindent">Have an empty state, similar to a <span class="literal">nullptr</span></li>&#13;
</ul>&#13;
<h4 class="h4" id="ch09lev2sec15"><strong><em>Declaring a Function</em></strong></h4>&#13;
<p class="noindent">To declare a <span class="literal">function</span>, you must provide a single template parameter containing the function prototype of the callable object:</p>&#13;
<pre>std::function&lt;return-type(arg-type-1, arg-type-2, etc.)&gt;</pre>&#13;
<p class="indent">The <span class="literal">std::function</span> class template has a number of constructors. The default constructor constructs a <span class="literal">std::function</span> in empty mode, meaning it contains no callable object.</p>&#13;
<h5 class="h5" id="ch09lev3sec7"><strong>Empty Functions</strong></h5>&#13;
<p class="noindent">If you invoke a <span class="literal">std::function</span> with no contained object, <span class="literal">std::function</span> will throw a <span class="literal">std::bad_function_call</span> exception. Consider <a href="ch09.xhtml#ch09ex25">Listing 9-25</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
int main() {&#13;
    std::function&lt;void()&gt; func; <span class="ent">➊</span>&#13;
    try {&#13;
        func(); <span class="ent">➋</span>&#13;
    } catch(const std::bad_function_call&amp; e) {&#13;
        printf("Exception: %s", e.what()); <span class="ent">➌</span>&#13;
    }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Exception: bad function call <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch09ex25"/><em>Listing 9-25: The default <span class="literal">std::function</span> constructor and the <span class="literal">std::bad_function_call</span> exception</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_270"/>You default-construct a <span class="literal">std::function</span> <span class="ent">➊</span>. The template parameter <span class="literal">void()</span> denotes a function taking no arguments and returning <span class="literal">void</span>. Because you didn’t fill <span class="literal">func</span> with a callable object, it’s in an empty state. When you invoke <span class="literal">func</span> <span class="ent">➋</span>, it throws a <span class="literal">std::bad_function_call</span>, which you catch and print <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch09lev3sec8"><strong>Assigning a Callable Object to a Function</strong></h5>&#13;
<p class="noindent">To assign a callable object to a <span class="literal">function</span>, you can either use the constructor or assignment operator of <span class="literal">function</span>, as in <a href="ch09.xhtml#ch09ex26">Listing 9-26</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
void static_func() { <span class="ent">➊</span>&#13;
  printf("A static function.\n");&#13;
}&#13;
&#13;
int main() {&#13;
  std::function&lt;void()&gt; func { [] { printf("A lambda.\n"); } }; <span class="ent">➋</span>&#13;
  func(); <span class="ent">➌</span>&#13;
  func = static_func; <span class="ent">➍</span>&#13;
  func(); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">A lambda. <span class="ent">➌</span></span>&#13;
<span class="color1">A static function. <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch09ex26"/><em>Listing 9-26: Using the constructor and assignment operator of <span class="literal">function</span></em></p>&#13;
<p class="indent">You declare the static function <span class="literal">static_func</span> that takes no arguments and returns <span class="literal">void</span> <span class="ent">➊</span>. In <span class="literal">main</span>, you create a function called <span class="literal">func</span> <span class="ent">➋</span>. The template parameter indicates that a callable object contained by <span class="literal">func</span> takes no arguments and returns <span class="literal">void</span>. You initialize <span class="literal">func</span> with a lambda that prints the message <span class="literal">A lambda</span>. You invoke <span class="literal">func</span> immediately afterward <span class="ent">➌</span>, invoking the contained lambda and printing the expected message. Next, you assign <span class="literal">static_func</span> to <span class="literal">func</span>, which replaces the lambda you assigned upon construction <span class="ent">➍</span>. You then invoke <span class="literal">func</span>, which invokes <span class="literal">static_func</span> rather than the lambda, so you see <span class="literal">A static function.</span> printed <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch09lev2sec16"><strong><em>An Extended Example</em></strong></h4>&#13;
<p class="noindent">You can construct a <span class="literal">function</span> with callable objects, as long as that object supports the function semantics implied by the template parameter of <span class="literal">function</span>.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex27">Listing 9-27</a> uses an array of <span class="literal">std::function</span> instances and fills it with a static function that counts spaces, a <span class="literal">CountIf</span> function object from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a>, and a lambda that computes string length.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
struct CountIf {&#13;
<span epub:type="pagebreak" id="page_271"/>  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
size_t count_spaces(const char* str) {&#13;
  size_t index{}, result{};&#13;
  while (str[index]) {&#13;
    if (str[index] == ' ') result++;&#13;
    index++;&#13;
  }&#13;
  return result;&#13;
}&#13;
&#13;
std::function<span class="ent">➊</span>&lt;size_t(const char*)<span class="ent">➋</span>&gt; funcs[]{&#13;
  count_spaces, <span class="ent">➌</span>&#13;
  CountIf{ 'e' }, <span class="ent">➍</span>&#13;
  [](const char* str) { <span class="ent">➎</span>&#13;
    size_t index{};&#13;
    while (str[index]) index++;&#13;
    return index;&#13;
  }&#13;
};&#13;
&#13;
auto text = "Sailor went to sea to see what he could see.";&#13;
&#13;
int main() {&#13;
  size_t index{};&#13;
  for(const auto&amp; func : funcs<span class="ent">➏</span>) {&#13;
    printf("func #%zu: %zu\n", index++, func(text)<span class="ent">➐</span>);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">func #0: 9 <span class="ent">➌</span></span>&#13;
<span class="color1">func #1: 7 <span class="ent">➍</span></span>&#13;
<span class="color1">func #2: 44 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch09ex27"/><em>Listing 9-27: Using a <span class="literal">std::function</span> array to iterate over a uniform collection of callable objects with varying underlying types</em></p>&#13;
<p class="indent">You declare a <span class="literal">std::function</span> array <span class="ent">➊</span> with static storage duration called <span class="literal">funcs</span>. The template argument is the function prototype for a function taking a <span class="literal">const char*</span> and returning a <span class="literal">size_t</span> <span class="ent">➋</span>. In the <span class="literal">funcs</span> array, you pass in a static function pointer <span class="ent">➌</span>, a function object <span class="ent">➍</span>, and a lambda <span class="ent">➎</span>. In <span class="literal">main</span>, you use a range-based <span class="literal">for</span> loop to iterate through each function in <span class="literal">funcs</span> <span class="ent">➏</span>. You invoke each function <span class="literal">func</span> with the text <span class="literal">Sailor went to sea to see what he could see.</span> and print the result.</p>&#13;
<p class="indent">Notice that, from the perspective of <span class="literal">main</span>, all the elements in <span class="literal">funcs</span> are the same: you just invoke them with a null-terminated string and get back a <span class="literal">size_t</span> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Using a <span class="literal">function</span> can incur runtime overhead. For technical reasons, <span class="literal">function</span> might need to make a dynamic allocation to store the callable object. The compiler also has difficulty optimizing away <span class="literal">function</span> invocations, so you’ll often incur an indirect function call. Indirect function calls require additional pointer dereferences</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch09lev1sec12"><strong><span epub:type="pagebreak" id="page_272"/>The main Function and the Command Line</strong></h3>&#13;
<p class="noindent">All C++ programs must contain a global function with the name <span class="literal">main</span>. This function is defined as the program’s entry point, the function invoked at program startup. Programs can accept any number of environment-provided arguments called <em>command line parameters</em> upon startup.</p>&#13;
<p class="indent">Users pass command line parameters to programs to customize their behavior. You’ve probably used this feature when executing command line programs, as in the <span class="literal">copy</span> (on Linux: <span class="literal">cp</span>) command:</p>&#13;
<pre>$ copy file_a.txt file_b.txt</pre>&#13;
<p class="indent">When invoking this command, you instruct the program to copy <span class="literal">file_a.txt</span> into <span class="literal">file_b.txt</span> by passing these values as command line parameters. As with command line programs you might be used to, it’s possible to pass values as command line parameters to your C++ programs.</p>&#13;
<p class="indent">You can choose whether your program handles command line parameters by how you declare <span class="literal">main</span>.</p>&#13;
<h4 class="h4" id="ch09lev2sec17"><strong><em>The Three main Overloads</em></strong></h4>&#13;
<p class="noindent">You can access command line parameters within <span class="literal">main</span> by adding arguments to your <span class="literal">main</span> declaration.</p>&#13;
<p class="indent">There are three valid varieties of overload for <span class="literal">main</span>, as shown in <a href="ch09.xhtml#ch09ex28">Listing 9-28</a>.</p>&#13;
<pre>int main(); <span class="ent">➊</span>&#13;
int main(int argc, char* argv[]); <span class="ent">➋</span>&#13;
int main(int argc, char* argv[], <span class="codeitalic1">impl-parameters</span>); <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch09ex28"/><em>Listing 9-28: The valid overloads for <span class="literal">main</span></em></p>&#13;
<p class="indent">The first overload <span class="ent">➊</span> takes no parameters, which is the way you’ve been using <span class="literal">main()</span> in this book so far. Use this form if you want to ignore any arguments provided to your program.</p>&#13;
<p class="indent">The second overload <span class="ent">➋</span> accepts two parameters, <span class="literal">argc</span> and <span class="literal">argv</span>. The first argument, <span class="literal">argc</span>, is a non-negative number corresponding to the number of elements in <span class="literal">argv</span>. The environment calculates this automatically: you don’t have to provide the number of elements in <span class="literal">argc</span>. The second argument, <span class="literal">argv</span>, is an array of pointers to null-terminated strings that corresponds to an argument passed in from the execution environment.</p>&#13;
<p class="indent">The third overload <span class="ent">➌</span>: is an extension of the second overload <span class="ent">➋</span>: it accepts an arbitrary number of additional implementation parameters. This way, the target platform can offer some additional arguments to the program. Implementation parameters aren’t common in modern desktop environments.</p>&#13;
<p class="indent">Usually, an operating system passes the full path to the program’s executable as the first command line argument. This behavior depends on your operating environment. On macOS, Linux, and Windows, the <span epub:type="pagebreak" id="page_273"/>executable’s path is the first argument. The format of this path depends on the operating system. (<a href="ch17.xhtml">Chapter 17</a> discusses filesystems in depth.)</p>&#13;
<h4 class="h4" id="ch09lev2sec18"><strong><em>Exploring Program Parameters</em></strong></h4>&#13;
<p class="noindent">Let’s build a program to explore how the operating system passes parameters to your program. <a href="ch09.xhtml#ch09ex29">Listing 9-29</a> prints the number of command line arguments and then prints the index and value of the arguments on each line.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main(int argc, char** argv) { <span class="ent">➊</span>&#13;
  printf("Arguments: %d\n", argc); <span class="ent">➋</span>&#13;
  for(size_t i{}; i&lt;argc; i++) {&#13;
    printf("%zu: %s\n", i, argv[i]); <span class="ent">➌</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex29"/><em>Listing 9-29: A program that prints the command line arguments. Compile this program as <span class="literal">list_929</span>.</em></p>&#13;
<p class="indent">You declare main with the <span class="literal">argc</span>/<span class="literal">argv</span> overload, which makes command line parameters available to your program <span class="ent">➊</span>. First, you print the number of command line arguments via <span class="literal">argc</span> <span class="ent">➋</span>. Then you loop through each argument, printing its index and its value <span class="ent">➌</span>.</p>&#13;
<p class="indent">Let’s look at some sample output (on Windows 10 x64). Here is one program invocation:</p>&#13;
<pre>$ <span class="codestrong1">list_929</span> <span class="ent">➊</span>&#13;
<span class="color1">Arguments: 1 <span class="ent">➋</span></span>&#13;
<span class="color1">0: list_929.exe <span class="ent">➌</span></span></pre>&#13;
<p class="indent">Here, you provide no additional command line arguments aside from the name of the program, <span class="literal">list_929</span> <span class="ent">➊</span>. (Depending on how you compiled the listing, you should replace this with the name of your executable.) On a Windows 10 x64 machine, the result is that your program receives a single argument <span class="ent">➋</span>, the name of the executable <span class="ent">➌</span>.</p>&#13;
<p class="indent">And here is another invocation:</p>&#13;
<pre>$ <span class="codestrong1">list_929 Violence is the last refuge of the incompetent.</span> <span class="ent">➊</span>&#13;
<span class="color1">Arguments: 9</span>&#13;
<span class="color1">0: list_929.exe</span>&#13;
<span class="color1">1: Violence</span>&#13;
<span class="color1">2: is</span>&#13;
<span class="color1">3: the</span>&#13;
<span class="color1">4: last</span>&#13;
<span class="color1">5: refuge</span>&#13;
<span class="color1">6: of</span>&#13;
<span class="color1">7: the</span>&#13;
<span class="color1">8: incompetent.</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_274"/>Here, you provide additional program arguments: <span class="literal">Violence is the last refuge of the incompetent.</span> <span class="ent">➊</span>. You can see from the output that Windows has split the command line by spaces, resulting in a total of nine arguments.</p>&#13;
<p class="indent">In major desktop operating systems, you can force the operating system to treat such a phrase as a single argument by enclosing it within quotes, as in the following:</p>&#13;
<pre>$ <span class="codestrong1">list_929 "Violence is the last refuge of the incompetent."</span>&#13;
<span class="color1">Arguments: 2</span>&#13;
<span class="color1">0: list_929.exe</span>&#13;
<span class="color1">1: Violence is the last refuge of the incompetent.</span></pre>&#13;
<h4 class="h4" id="ch09lev2sec19"><strong><em>A More Involved Example</em></strong></h4>&#13;
<p class="noindent">Now that you know how to process command line input, let’s consider a more involved example. A <em>histogram</em> is an illustration that shows a distribution’s relative frequency. Let’s build a program that computes a histogram of the letter distribution of the command line arguments.</p>&#13;
<p class="indent">Start with two helper functions that determine whether a given <span class="literal">char</span> is an uppercase letter or a lowercase letter:</p>&#13;
<pre>constexpr char pos_A{ 65 }, pos_Z{ 90 }, pos_a{ 97 }, pos_z{ 122 };&#13;
constexpr bool within_AZ(char x) { return pos_A &lt;= x &amp;&amp; pos_Z &gt;= x; } <span class="ent">➊</span>&#13;
constexpr bool within_az(char x) { return pos_a &lt;= x &amp;&amp; pos_z &gt;= x; } <span class="ent">➋</span></pre>&#13;
<p class="indent">The <span class="literal">pos_A, pos_Z, pos_a</span>, and <span class="literal">pos_z</span> constants contain the ASCII values of the letters A, Z, a, and z respectively (refer to the ASCII chart in <a href="ch02.xhtml#ch02tab04">Table 2-4</a>). The <span class="literal">within_AZ</span> function determines whether some <span class="literal">char x</span> is an uppercase letter by determining whether its value is between <span class="literal">pos_A</span> and <span class="literal">pos_Z</span> inclusive <span class="ent">➊</span>. The <span class="literal">within_az</span> function does the same for lowercase letters <span class="ent">➋</span>.</p>&#13;
<p class="indent">Now that you have some elements for processing ASCII data from the command line, let’s build an <span class="literal">AlphaHistogram</span> class that can ingest command line elements and store character frequencies, as shown in <a href="ch09.xhtml#ch09ex30">Listing 9-30</a>.</p>&#13;
<pre>struct AlphaHistogram {&#13;
  void ingest(const char* x); <span class="ent">➊</span>&#13;
  void print() const; <span class="ent">➋</span>&#13;
private:&#13;
  size_t counts[26]{}; <span class="ent">➌</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch09ex30"/><em>Listing 9-30: An <span class="literal">AlphaHistogram</span> that ingests command line elements</em></p>&#13;
<p class="indent">An <span class="literal">AlphaHistogram</span> will store the frequency of each letter in the <span class="literal">counts</span> array <span class="ent">➌</span>. This array initializes to zero whenever an <span class="literal">AlphaHistogram</span> is constructed. The <span class="literal">ingest</span> method will take a null-terminated string and update <span class="literal">counts</span> appropriately <span class="ent">➊</span>. Then the <span class="literal">print</span> method will display the histogram information stored in <span class="literal">counts</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_275"/>First, consider the implementation of <span class="literal">ingest</span> in <a href="ch09.xhtml#ch09ex31">Listing 9-31</a>.</p>&#13;
<pre>void AlphaHistogram::ingest(const char* x) {&#13;
  size_t index{}; <span class="ent">➊</span>&#13;
  while(const auto c = x[index]) { <span class="ent">➋</span>&#13;
    if (within_AZ(c)) counts[c - pos_A]++; <span class="ent">➌</span>&#13;
    else if (within_az(c)) counts[c - pos_a]++; <span class="ent">➍</span>&#13;
    index++; <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex31"/><em>Listing 9-31: An implementation of the <span class="literal">ingest</span> method</em></p>&#13;
<p class="indent">Because <span class="literal">x</span> is a null-terminated string, you don’t know its length ahead of time. So, you initialize an <span class="literal">index</span> variable <span class="ent">➊</span> and use a <span class="literal">while</span> loop to extract a single <span class="literal">char c</span> at a time <span class="ent">➋</span>. This loop will terminate if <span class="literal">c</span> is null, which is the end of the string. Within the loop, you use the <span class="literal">within_AZ</span> helper function to determine whether <span class="literal">c</span> is an uppercase letter <span class="ent">➌</span>. If it is, you subtract <span class="literal">pos_A</span> from <span class="literal">c</span>. This normalizes an uppercase letter to the interval 0 to 25 to correspond with <span class="literal">counts</span>. You do the same check for lowercase letters using the <span class="literal">within_az</span> helper function <span class="ent">➍</span>, and you update <span class="literal">counts</span> in case <span class="literal">c</span> is lowercase. If <span class="literal">c</span> is neither lowercase nor uppercase, <span class="literal">counts</span> is unaffected. Finally, you increment <span class="literal">index</span> before continuing to loop <span class="ent">➎</span>.</p>&#13;
<p class="indent">Now, consider how to <span class="literal">print</span> <span class="literal">counts</span>, as shown in <a href="ch09.xhtml#ch09ex32">Listing 9-32</a>.</p>&#13;
<pre>void AlphaHistogram::print() const {&#13;
  for(auto index{ pos_A }; index &lt;= pos_Z; index++) { <span class="ent">➊</span>&#13;
    printf("%c: ", index); <span class="ent">➋</span>&#13;
    auto n_asterisks = counts[index - pos_A]; <span class="ent">➌</span>&#13;
    while (n_asterisks--) printf("*"); <span class="ent">➍</span>&#13;
    printf("\n"); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex32"/><em>Listing 9-32: An implementation of the <span class="literal">print</span> method</em></p>&#13;
<p class="indent">To print the histogram, you loop over each letter from A to Z <span class="ent">➊</span>. Within the loop, you first print the <span class="literal">index</span> letter <span class="ent">➋</span>, and then determine how many asterisks to print by extracting the correct letter out of <span class="literal">counts</span> <span class="ent">➌</span>. You print the correct number of asterisks using a <span class="literal">while</span> loop <span class="ent">➍</span>, and then you print a terminating newline <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex33">Listing 9-33</a> shows <span class="literal">AlphaHistogram</span> in action.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
constexpr char pos_A{ 65 }, pos_Z{ 90 }, pos_a{ 97 }, pos_z{ 122 };&#13;
constexpr bool within_AZ(char x) { return pos_A &lt;= x &amp;&amp; pos_Z &gt;= x; }&#13;
constexpr bool within_az(char x) { return pos_a &lt;= x &amp;&amp; pos_z &gt;= x; }&#13;
&#13;
struct AlphaHistogram {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
<span epub:type="pagebreak" id="page_276"/>};&#13;
&#13;
int main(int argc, char** argv) {&#13;
  AlphaHistogram hist;&#13;
  for(size_t i{ 1 }; i&lt;argc; i++) { <span class="ent">➊</span>&#13;
    hist.ingest(argv[i]); <span class="ent">➋</span>&#13;
  }&#13;
  hist.print(); <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">$</span> <span class="codestrong1">list_933 The quick brown fox jumps over the lazy dog</span>&#13;
<span class="color1">A: *</span>&#13;
<span class="color1">B: *</span>&#13;
<span class="color1">C: *</span>&#13;
<span class="color1">D: *</span>&#13;
<span class="color1">E: ***</span>&#13;
<span class="color1">F: *</span>&#13;
<span class="color1">G: *</span>&#13;
<span class="color1">H: **</span>&#13;
<span class="color1">I: *</span>&#13;
<span class="color1">J: *</span>&#13;
<span class="color1">K: *</span>&#13;
<span class="color1">L: *</span>&#13;
<span class="color1">M: *</span>&#13;
<span class="color1">N: *</span>&#13;
<span class="color1">O: ****</span>&#13;
<span class="color1">P: *</span>&#13;
<span class="color1">Q: *</span>&#13;
<span class="color1">R: **</span>&#13;
<span class="color1">S: *</span>&#13;
<span class="color1">T: **</span>&#13;
<span class="color1">U: **</span>&#13;
<span class="color1">V: *</span>&#13;
<span class="color1">W: *</span>&#13;
<span class="color1">X: *</span>&#13;
<span class="color1">Y: *</span>&#13;
<span class="color1">Z: *</span></pre>&#13;
<p class="listing"><a id="ch09ex33"/><em>Listing 9-33: A program illustrating <span class="literal">AlphaHistogram</span></em></p>&#13;
<p class="indent">You iterate over each command line argument after the program name <span class="ent">➊</span>, passing each into the <span class="literal">ingest</span> method of your <span class="literal">AlphaHistogram</span> object <span class="ent">➋</span>. Once you’ve ingested them all, you print the <span class="literal">histogram</span> <span class="ent">➌</span>. Each line corresponds to a letter, and the asterisks show the absolute frequency of the corresponding letter. As you can see, the phrase <span class="literal">The quick brown fox jumps over the lazy dog</span> contains each letter in the English alphabet.</p>&#13;
<h4 class="h4" id="ch09lev2sec20"><strong><em>Exit Status</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">main</span> function can return an <span class="literal">int</span> corresponding to the exit status of the program. What the values represent is environment defined. On modern desktop systems, for example, a zero return value corresponds with a successful program execution. If no <span class="literal">return</span> statement is explicitly given, an implicit <span class="literal">return 0</span> is added by the compiler.</p>&#13;
<h3 class="h3" id="ch09lev1sec13"><span epub:type="pagebreak" id="page_277"/><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter took a deeper look at functions, including how to declare and define them, how to use the myriad keywords available to you to modify function behavior, how to specify return types, how overload resolution works, and how to take a variable number of arguments. After a discussion of how you take pointers to functions, you explored lambda expressions and their relationship to function objects. Then you learned about the entry point for your programs, the <span class="literal">main</span> function, and how to take command line arguments.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>9-1.</strong> Implement a <span class="literal">fold</span> function template with the following prototype:</p>&#13;
<pre>template &lt;typename Fn, typename In, typename Out&gt;&#13;
constexpr Out fold(Fn function, In* input, size_t length, Out initial);</pre>&#13;
<p class="indent">For example, your implementation must support the following usage:</p>&#13;
<pre>int main() {&#13;
  int data[]{ 100, 200, 300, 400, 500 };&#13;
  size_t data_len = 5;&#13;
  auto sum = fold([](auto x, auto y) { return x + y; }, data, data_len,&#13;
0);&#13;
  printf("Sum: %d\n", sum);&#13;
}</pre>&#13;
<p class="indent">The value of <span class="literal">sum</span> should be 1,500. Use <span class="literal">fold</span> to calculate the following quantities: the <span class="literal">maximum</span>, the <span class="literal">minimum</span>, and the number of elements greater than 200.</p>&#13;
<p class="noindent"><strong>9-2.</strong> Implement a program that accepts an arbitrary number of command line arguments, counts the length in characters of each argument, and prints a histogram of the argument length distribution.</p>&#13;
<p class="noindent"><strong>9-3.</strong> Implement an <span class="literal">all</span> function with the following prototype:</p>&#13;
<pre>template &lt;typename Fn, typename In&gt;&#13;
constexpr bool all(Fn function, In* input, size_t length);</pre>&#13;
<p class="indent">The <span class="literal">Fn</span> function type is a <span class="literal">predicate</span> that supports <span class="literal">bool operator()(In)</span>. Your <span class="literal">all</span> function must test whether <span class="literal">function</span> returns <span class="literal">true</span> for every element of <span class="literal">input</span>. If it does, return <span class="literal">true</span>. Otherwise, return <span class="literal">false</span>.</p>&#13;
<p class="indent">For example, your implementation must support the following usage:</p>&#13;
<pre>int main() {&#13;
  int data[]{ 100, 200, 300, 400, 500 };&#13;
  size_t data_len = 5;&#13;
  auto all_gt100 = all([](auto x) { return x &gt; 100; }, data, data_len);&#13;
  if(all_gt100) printf("All elements greater than 100.\n");&#13;
}</pre>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_278"/><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Functional Programming in C++: How to Improve Your C++ Programs Using Functional Techniques</em> by Ivan Čukić (Manning, 2019)</li>&#13;
<li class="noindent"><em>Clean Code: A Handbook of Agile Software Craftsmanship</em> by Robert C. Martin (Pearson Education, 2009</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>