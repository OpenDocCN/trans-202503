<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_242"/><span epub:type="pagebreak" id="page_243"/><strong><span class="big">9</span><br/>FUNCTIONS</strong></h2>&#13;
<p class="quote"><em>Functions should do one thing. They should do it well. They should do it only.<br/>—Robert C. Martin,</em> Clean Code</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter rounds out the ongoing discussion of functions, which encapsulate code into reusable components. Now that you’re armed with a strong background in C++ fundamentals, this chapter first revisits functions with a far more in-depth treatment of modifiers, specifiers, and return types, which appear in function declarations and specialize the behavior of your functions.</p>&#13;
<p class="indent">Then you’ll learn about overload resolution and accepting variable numbers of arguments before exploring function pointers, type aliases, function objects, and the venerable lambda expression. The chapter closes with an introduction to the <code>std::function</code> before revisiting the <code>main</code> function and accepting command line arguments.</p>&#13;
<h3 class="h3" id="ch09lev1sec1"><strong><span epub:type="pagebreak" id="page_244"/>Function Declarations</strong></h3>&#13;
<p class="noindent">Function declarations have the following familiar form:</p>&#13;
<pre><span class="codeitalic1">prefix-modifiers return-type func-name(arguments) suffix-modifiers</span>;</pre>&#13;
<p class="indent">You can provide a number of optional <em>modifiers</em> (or <em>specifiers</em>) to functions. Modifiers alter a function’s behavior in some way. Some modifiers appear at the beginning in the function’s declaration or definition (<em>prefix modifiers</em>), whereas others appear at the end (<em>suffix modifiers</em>). The prefix modifiers appear before the return type. The suffix modifiers appear after the argument list.</p>&#13;
<p class="indent">There isn’t a clear language reason why certain modifiers appear as prefixes or suffixes: because C++ has a long history, these features evolved incrementally.</p>&#13;
<h4 class="h4" id="ch09lev2sec1"><strong><em>Prefix Modifiers</em></strong></h4>&#13;
<p class="noindent">At this point, you already know several prefix modifiers:</p>&#13;
<ul>&#13;
<li class="noindent">The prefix <code>static</code> indicates that a function that isn’t a member of a class has internal linkage, meaning the function won’t be used outside of this translation unit. Unfortunately, this keyword does double duty: if it modifies a method (that is, a function inside a class), it indicates that the function isn’t associated with an instantiation of the class but rather with the class itself (see <a href="ch04.xhtml#ch04">Chapter 4</a>).</li>&#13;
<li class="noindent">The modifier <code>virtual</code> indicates that a method can be overridden by a child class. The <code>override</code> modifier indicates to the compiler that a child class intends to override a parent’s virtual function (see <a href="ch05.xhtml#ch05">Chapter 5</a>).</li>&#13;
<li class="noindent">The modifier <code>constexpr</code> indicates that the function should be evaluated at compile time if possible (see <a href="ch07.xhtml#ch07">Chapter 7</a>).</li>&#13;
<li class="noindent">The modifier <code>[[noreturn]]</code> indicates that this function won’t return (see <a href="ch08.xhtml#ch08">Chapter 8</a>). Recall that this attribute helps the compiler to optimize your code.</li>&#13;
</ul>&#13;
<p class="indent">Another prefix modifier is <code>inline</code>, which plays a role in guiding the compiler when optimizing code.</p>&#13;
<p class="indent">On most platforms, a function call compiles into a series of instructions, such as the following:</p>&#13;
<ol>&#13;
<li class="noindent">Place arguments into registers and on the call stack.</li>&#13;
<li class="noindent">Push a return address onto the call stack.</li>&#13;
<li class="noindent">Jump to the called function.</li>&#13;
<li class="noindent">After the function completes, jump to the return address.</li>&#13;
<li class="noindent">Clean up the call stack.</li>&#13;
</ol>&#13;
<p class="indent">These steps typically execute very quickly, and the payoff in reduced binary size can be substantial if you use a function in many places.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_245"/><em>Inlining a function</em> means copying and pasting the contents of the function directly into the execution path, eliminating the need for the five steps outlined. This means that as the processor executes your code, it will immediately execute your function’s code rather than executing the (modest) ceremony required for function invocation. If you prefer this marginal increase in speed over the commensurate cost in increased binary size, you can use the <code>inline</code> keyword to indicate this to the compiler. The <code>inline</code> keyword hints to the compiler’s optimizer to put a function directly inline rather than perform a function call.</p>&#13;
<p class="indent">Adding <code>inline</code> to a function doesn’t change its behavior; it’s purely an expression of preference to the compiler. You must ensure that if you define a function <code>inline</code>, you do so in all translation units. Also note that modern compilers will typically inline functions where it makes sense—especially if a function isn’t used outside of a single translation unit.</p>&#13;
<h4 class="h4" id="ch09lev2sec2"><strong><em>Suffix Modifiers</em></strong></h4>&#13;
<p class="noindent">At this point in the book, you already know two suffix modifiers:</p>&#13;
<ul>&#13;
<li class="noindent">The modifier <code>noexcept</code> indicates that the function will <em>never</em> throw an exception. It enables certain optimizations (see <a href="ch04.xhtml#ch04">Chapter 4</a>).</li>&#13;
<li class="noindent">The modifier <code>const</code> indicates that the method won’t modify an instance of its class, allowing <code>const</code> references types to invoke the method (see <a href="ch04.xhtml#ch04">Chapter 4</a>).</li>&#13;
</ul>&#13;
<p class="indent">This section explores three more suffix modifiers: <code>final</code>, <code>override</code>, and <code>volatile</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec1"><strong>final and override</strong></h5>&#13;
<p class="indent">The <code>final</code> modifier indicates that a method cannot be overridden by a child class. It’s effectively the opposite of <code>virtual</code>. <a href="ch09.xhtml#ch09ex01">Listing 9-1</a> attempts to override a <code>final</code> method and yields a compiler error.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BostonCorbett {&#13;
  virtual void shoot() final<span class="ent">➊</span> {&#13;
    printf("What a God we have...God avenged Abraham Lincoln");&#13;
  }&#13;
};&#13;
&#13;
struct BostonCorbettJunior : BostonCorbett {&#13;
  void shoot() override<span class="ent">➋</span> { } // Bang! shoot is final.&#13;
};&#13;
&#13;
int main() {&#13;
  BostonCorbettJunior junior;&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex01"/><em>Listing 9-1: A class attempting to override a final method (This code doesn’t compile.)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>This listing marks the <code>shoot</code> method <code>final</code> <span class="ent">➊</span>. Within <code>BostonCorbettJunior</code>, which inherits from <code>BostonCorbett</code>, you attempt to <code>override</code> the <code>shoot</code> method <span class="ent">➋</span>. This causes a compiler error.</p>&#13;
<p class="indent">You can also apply the <code>final</code> keyword to an entire class, disallowing that class from becoming a parent entirely, as demonstrated in <a href="ch09.xhtml#ch09ex02">Listing 9-2</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct BostonCorbett final <span class="ent">➊</span> {&#13;
  void shoot()  {&#13;
    printf("What a God we have...God avenged Abraham Lincoln");&#13;
  }&#13;
};&#13;
&#13;
struct BostonCorbettJunior : BostonCorbett <span class="ent">➋</span> { }; // Bang!&#13;
&#13;
int main() {&#13;
  BostonCorbettJunior junior;&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex02"/><em>Listing 9-2: A program with a class attempting to inherit from a final class. (This code doesn’t compile.)</em></p>&#13;
<p class="indent">The <code>BostonCorbett</code> class is marked as <code>final</code> <span class="ent">➊</span>, and this causes a compiler error when you attempt to inherit from it in <code>BostonCorbettJunior</code> <span class="ent">➋</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Neither <code>final</code> nor <code>override</code> is technically a language keyword; they are <em>identifiers</em>. Unlike keywords, identifiers gain special meaning only when used in a specific context. This means you can use <code>final</code> and <code>override</code> as symbol names elsewhere in your program, thereby leading to the insanity of constructions like <code>virtual void final() override</code>. Try not to do this.</em></p>&#13;
</div>&#13;
<p class="indent">Whenever you’re using interface inheritance, you should mark implementing classes <code>final</code> because the modifier can encourage the compiler to perform an optimization called <em>devirtualization</em>. When virtual calls are devirtualized, the compiler eliminates the runtime overhead associated with a virtual call.</p>&#13;
<h5 class="h5" id="ch09lev3sec2"><strong>volatile</strong></h5>&#13;
<p class="noindent">Recall from <a href="ch07.xhtml#ch07">Chapter 7</a> that a volatile object’s value can change at any time, so the compiler must treat all accesses to volatile objects as visible side effects for optimization purposes. The <code>volatile</code> keyword indicates that a method can be invoked on volatile objects. This is analogous to how <code>const</code> methods can be applied to <code>const</code> objects. Together, these two keywords define a method’s <em>const/volatile qualification</em> (or sometimes <em>cv qualification</em>), as demonstrated in <a href="ch09.xhtml#ch09ex03">Listing 9-3</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Distillate {&#13;
<span epub:type="pagebreak" id="page_247"/>  int apply() volatile <span class="ent">➊</span> {&#13;
    return ++applications;&#13;
  }&#13;
private:&#13;
  int applications{};&#13;
};&#13;
&#13;
int main() {&#13;
  volatile <span class="ent">➋</span> Distillate ethanol;&#13;
  printf("%d Tequila\n", ethanol.apply()<span class="ent">➌</span>);&#13;
  printf("%d Tequila\n", ethanol.apply());&#13;
  printf("%d Tequila\n", ethanol.apply());&#13;
  printf("Floor!");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 Tequila <span class="ent">➌</span></span>&#13;
<span class="color1">2 Tequila</span>&#13;
<span class="color1">3 Tequila</span>&#13;
<span class="color1">Floor!</span></pre>&#13;
<p class="listing"><a id="ch09ex03"/><em>Listing 9-3: Illustrating the use of a <code>volatile</code> method</em></p>&#13;
<p class="indent">In this listing, you declare the <code>apply</code> method on the <code>Distillate</code> class <code>vola</code><code>tile</code> <span class="ent">➊</span>. You also create a <code>volatile Distillate</code> called <code>ethanol</code> within <code>main</code> <span class="ent">➋</span>. Because the <code>apply</code> method is <code>volatile</code>, you can still invoke it <span class="ent">➌</span> (even though <code>ethanol</code> is <code>volatile</code>).</p>&#13;
<p class="indent">Had you not marked <code>apply volatile</code> <span class="ent">➊</span>, the compiler would emit an error when you attempted to invoke it <span class="ent">➌</span>. Just like you cannot invoke a non-<code>const</code> method on a <code>const</code> object, you cannot invoke a non-<code>volatile</code> method on a <code>volatile</code> object. Consider what would happen if you could perform such an operation: a non-<code>volatile</code> method is a candidate for all kinds of compiler optimizations for the reasons outlined in <a href="ch07.xhtml#ch07">Chapter 7</a>: many kinds of memory accesses can be optimized away without changing the observable side effects of your program.</p>&#13;
<p class="indent">How should the compiler treat a contradiction arising from you using a <code>volatile</code> object—which requires that all its memory accesses are treated as observable side effects—to invoke a non-<code>volatile</code> method? The compiler’s answer is that it calls this contradiction an error.</p>&#13;
<h3 class="h3" id="ch09lev1sec2"><strong>auto Return Types</strong></h3>&#13;
<p class="noindent">There are two ways to declare the return value of a function:</p>&#13;
<ul>&#13;
<li class="noindent">(Primary) Lead a function declaration with its return type, as you’ve been doing all along.</li>&#13;
<li class="noindent">(Secondary) Have the compiler deduce the correct return type by using <code>auto</code>.</li>&#13;
</ul>&#13;
<p class="indent">As with <code>auto</code> type deduction, the compiler deduces the return type, fixing the runtime type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>This feature should be used judiciously. Because function definitions are documentation, it’s best to provide concrete return types when available.</p>&#13;
<h3 class="h3" id="ch09lev1sec3"><strong>auto and Function Templates</strong></h3>&#13;
<p class="noindent">The primary use case for <code>auto</code> type deduction is with function templates, where a return type can depend (in potentially complicated ways) on the template parameters. Its usage is as follows:</p>&#13;
<pre>auto <span class="codeitalic1">my-function</span>(<span class="codeitalic1">arg1-type arg1</span>, <span class="codeitalic1">arg2-type arg2</span>, ...) {&#13;
  // return any type and the&#13;
  // compiler will deduce what auto means&#13;
}</pre>&#13;
<p class="indent">It’s possible to extend the <code>auto</code>-return-type deduction syntax to provide the return type as a suffix with the arrow operator <code>-&gt;</code>. This way, you can append an expression that evaluates to the function’s return type. Its usage is as follows:</p>&#13;
<pre>auto <span class="codeitalic1">my-function</span>(<span class="codeitalic1">arg1-type</span> arg1, <span class="codeitalic1">arg2-type</span> arg2, ...) -&gt; <span class="codeitalic1">type-expression</span> {&#13;
  // return an object with type matching&#13;
  // the type-expression above&#13;
}</pre>&#13;
<p class="indent">Usually, you wouldn’t use this pedantic form, but in certain situations it’s helpful. For example, this form of <code>auto</code> type deduction is commonly paired with a <code>decltype</code> type expression. A <code>decltype</code> type expression yields another expression’s resultant type. Its usage is as follows:</p>&#13;
<pre>decltype(<span class="codeitalic1">expression</span>)</pre>&#13;
<p class="indent">This expression resolves to the resulting type of the expression. For example, the following <code>decltype</code> expression yields <code>int</code>, because the integer literal 100 has that type:</p>&#13;
<pre>decltype(100)</pre>&#13;
<p class="indent">Outside of generic programming with templates, <code>decltype</code> is rare.</p>&#13;
<p class="indent">You can combine <code>auto</code>-return-type deduction and <code>decltype</code> to document the return types of function templates. Consider the <code>add</code> function in <a href="ch09.xhtml#ch09ex04">Listing 9-4</a>, which defines a function template <code>add</code> that adds two arguments together.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;typename X, typename Y&gt;&#13;
auto add(X x, Y y) -&gt; decltype(x + y) { <span class="ent">➊</span>&#13;
  return x + y;&#13;
}&#13;
<span epub:type="pagebreak" id="page_249"/>int main() {&#13;
  auto my_double = add(100., -10);&#13;
  printf("decltype(double + int) = double; %f\n", my_double); <span class="ent">➋</span>&#13;
&#13;
  auto my_uint = add(100U, -20);&#13;
  printf("decltype(uint + int) = uint; %u\n", my_uint); <span class="ent">➌</span>&#13;
&#13;
  auto my_ulonglong = add(char{ 100 }, 54'999'900ull);&#13;
  printf("decltype(char + ulonglong) = ulonglong; %llu\n", my_ulonglong); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">decltype(double + int) = double; 90.000000 <span class="ent">➋</span></span>&#13;
<span class="color1">decltype(uint + int) = uint; 80 <span class="ent">➌</span></span>&#13;
<span class="color1">decltype(char + ulonglong) = ulonglong; 55000000 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch09ex04"/><em>Listing 9-4: Using <code>decltype</code> and <code>auto</code>-return-type deduction</em></p>&#13;
<p class="indent">The <code>add</code> function employs <code>auto</code> type deduction with the <code>decltype</code> type expression <span class="ent">➊</span>. Each time you instantiate a template with two types <code>X</code> and <code>Y</code>, the compiler evaluates <code>decltype(X + Y)</code> and fixes the return type of <code>add</code>. Within <code>main</code>, you provide three instantiations. First, you add a <code>double</code> and an <code>int</code> <span class="ent">➋</span>. The compiler determines that <code>decltype(double{ 100. } + int{ -10 })</code> is a <code>double</code>, which fixes the return type of this <code>add</code> instantiation. This, in turn, sets the type of <code>my_double</code> to <code>double</code> <span class="ent">➋</span>. You have two other instantiations: one for an <code>unsigned int</code> and <code>int</code> (which results in an <code>unsigned int</code> <span class="ent">➌</span>) and another for a <code>char</code> and an <code>unsigned long long</code> (which results in an <code>unsigned long long</code> <span class="ent">➍</span>).</p>&#13;
<h3 class="h3" id="ch09lev1sec4"><strong>Overload Resolution</strong></h3>&#13;
<p class="noindent"><em>Overload resolution</em> is the process that the compiler executes when matching a function invocation with its proper implementation.</p>&#13;
<p class="indent">Recall from <a href="ch04.xhtml#ch04">Chapter 4</a> that function overloads allow you to specify functions with the same name but different types and possibly different arguments. The compiler selects among these function overloads by comparing the argument types within the function invocation with the types within each overload declaration. The compiler will choose the best among the possible options, and if it cannot select a best option, it will generate a compiler error.</p>&#13;
<p class="indent">Roughly, the matching process proceeds as follows:</p>&#13;
<ol>&#13;
<li class="noindent">The compiler will look for an exact type match.</li>&#13;
<li class="noindent">The compiler will try using integral and floating-point promotions to get a suitable overload (for example, <code>int</code> to <code>long</code> or <code>float</code> to <code>double</code>).</li>&#13;
<li class="noindent">The compiler will try to match using standard conversions like integral type to floating-point or casting a pointer-to-child into a pointer-to-parent.</li>&#13;
<li class="noindent">The compiler will look for a user-defined conversion.</li>&#13;
<li class="noindent">The compiler will look for a variadic function.</li>&#13;
</ol>&#13;
<h3 class="h3" id="ch09lev1sec5"><strong><span epub:type="pagebreak" id="page_250"/>Variadic Functions</strong></h3>&#13;
<p class="noindent"><em>Variadic functions</em> take a variable number of arguments. Typically, you specify the exact number of arguments a function takes by enumerating all of its parameters explicitly. With a variadic function, you can take any number of arguments. The variadic function <code>printf</code> is a canonical example: you provide a format specifier and an arbitrary number of parameters. Because <code>printf</code> is a variadic function, it accepts any number of parameters.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The astute Pythonista will note an immediate conceptual relationship between variadic functions and <code>*args</code>/<code>**kwargs</code>.</em></p>&#13;
</div>&#13;
<p class="indent">You declare variadic functions by placing <code>...</code> as the final parameter in the function’s argument list. When a variadic function is invoked, the compiler matches arguments against declared arguments. Any leftovers pack into the variadic arguments represented by the <code>...</code> argument.</p>&#13;
<p class="indent">You cannot extract elements from the variadic arguments directly. Instead, you access individual arguments using the utility functions in the <code>&lt;cstdarg&gt;</code> header.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09tab01">Table 9-1</a> lists these utility functions.</p>&#13;
<p class="tabcap" id="ch09tab01"><strong>Table 9-1:</strong> Utility Functions in the <code>&lt;cstdarg&gt;</code> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>va_list</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Used to declare a local variable representing the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>va_start</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Enables access to the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>va_end</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Used to end iteration over the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>va_arg</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Used to iterate over each element in the variadic arguments</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>va_copy</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Makes a copy of the variadic arguments</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The utility functions’ usage is a little convoluted and best presented in a cohesive example. Consider the variadic <code>sum</code> function in <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>, which contains a variadic argument.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
#include &lt;cstdarg&gt;&#13;
&#13;
int sum(size_t n, ...<span class="ent">➊</span>) {&#13;
  va_list args; <span class="ent">➋</span>&#13;
  va_start(args, n); <span class="ent">➌</span>&#13;
  int result{};&#13;
  while (n--) {&#13;
    auto next_element = va_arg(args, int); <span class="ent">➍</span>&#13;
      result += next_element;&#13;
  }&#13;
  va_end(args); <span class="ent">➎</span>&#13;
<span epub:type="pagebreak" id="page_251"/>  return result;&#13;
}&#13;
&#13;
int main() {&#13;
  printf("The answer is %d.", sum(6, 2, 4, 6, 8, 10, 12)); <a id="_idTextAnchor421"/><span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch09ex05"/><em>Listing 9-5: A <code>sum</code> function with a variadic argument list</em></p>&#13;
<p class="indent">You declare <code>sum</code> as a variadic function <span class="ent">➊</span>. All variadic functions must declare a <code>va_list</code>. You’ve named it <code>args</code> <span class="ent">➋</span>. A <code>va_list</code> requires initialization with <code>va_start</code> <span class="ent">➌</span>, which takes two arguments. The first argument is a <code>va_list</code>, and the second is the size of the variadic arguments. You iterate over each element in the variadic arguments using the <code>va_args</code> function. The first argument is the <code>va_list</code> argument, and the second is the argument type <span class="ent">➍</span>. Once you’ve completed iterating, you call <code>va_end</code> with the <code>va_list</code> structure <span class="ent">➎</span>.</p>&#13;
<p class="indent">You invoke <code>sum</code> with seven arguments: the first is the number of variadic arguments (six) followed by six numbers (2, 4, 6, 8, 10, 12) <span class="ent">➏</span>.</p>&#13;
<p class="indent">Variadic functions are a holdover from C. Generally, variadic functions are unsafe and a common source of security vulnerabilities.</p>&#13;
<p class="indent">There are at least two major problems with variadic functions:</p>&#13;
<ul>&#13;
<li class="noindent">Variadic arguments are not type-safe. (Notice that the second argument of <code>va_arg</code> is a type.)</li>&#13;
<li class="noindent">The number of elements in the variadic arguments must be tracked separately.</li>&#13;
</ul>&#13;
<p class="indent">The compiler cannot help you with either of these issues.</p>&#13;
<p class="indent">Fortunately, variadic templates provide a safer and more performant way to implement variadic functions.</p>&#13;
<h3 class="h3" id="ch09lev1sec6"><strong>Variadic Templates</strong></h3>&#13;
<p class="noindent">The variadic template enables you to create function templates that accept variadic, same-typed arguments. They enable you to employ the considerable power of the template engine. To declare a variadic template, you add a special template parameter called a <em>template parameter pack</em>. <a href="ch09.xhtml#ch09ex06">Listing 9-6</a> demonstrates its usage.</p>&#13;
<pre>template &lt;typename...<span class="ent">➊</span> Args&gt;&#13;
<span class="codeitalic1">return-type</span> <span class="codeitalic1">func-name</span>(Args...<span class="ent">➋</span> args) {&#13;
  // Use parameter pack semantics&#13;
  // within function body&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex06"/><em>Listing 9-6: A template function with a parameter pack</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>The template parameter pack is part of the template parameter list <span class="ent">➊</span>. When you use <code>Args</code> within the function template <span class="ent">➋</span>, it’s called a <em>function parameter pack</em>. Some special operators are available for use with parameter packs:</p>&#13;
<ul>&#13;
<li class="noindent">You can use <code>sizeof...(args)</code> to obtain the parameter pack’s size.</li>&#13;
<li class="noindent">You can invoke a function (for example, <code>other_function</code>) with the special syntax <code>other_function(args...)</code>. This expands the parameter pack <code>args</code> and allows you to perform further processing on the arguments contained in the parameter pack.</li>&#13;
</ul>&#13;
<h4 class="h4" id="ch09lev2sec3"><strong><em>Programming with Parameter Packs</em></strong></h4>&#13;
<p class="noindent">Unfortunately, it’s not possible to index into a parameter pack directly. You must invoke the function template from within itself—a process called <em>compile-time recursion</em>—to recursively iterate over the elements in a parameter pack.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex07">Listing 9-7</a> demonstrates the pattern.</p>&#13;
<pre>template &lt;typename T, typename... Args&gt;&#13;
void my_func(T x<span class="ent">➊</span>, Args...args) {&#13;
  // Use x, then recurse:&#13;
  my_func(args...); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex07"/><em>Listing 9-7: A template function illustrating compile-time recursion with parameter packs. Unlike other usage listings, the ellipses contained in this listing are literal.</em></p>&#13;
<p class="indent">The key is to add a regular template parameter before the parameter pack <span class="ent">➊</span>. Each time you invoke <code>my_func</code>, <code>x</code> absorbs the first argument. The remainder packs into <code>args</code>. To invoke, you use the <code>args...</code> construct to expand the parameter pack <span class="ent">➋</span>.</p>&#13;
<p class="indent">The recursion needs a stopping criteria, so you add a function template specialization without the parameter:</p>&#13;
<pre>template &lt;typename T&gt;&#13;
void my_func(T x) {&#13;
  // Use x, but DON'T recurse&#13;
}</pre>&#13;
<h4 class="h4" id="ch09lev2sec4"><strong><em>Revisiting the sum Function</em></strong></h4>&#13;
<p class="noindent">Consider the (much improved) <code>sum</code> function implemented as a variadic template in <a href="ch09.xhtml#ch09ex08">Listing 9-8</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
constexpr<span class="ent">➊</span> T sum(T x) { <span class="ent">➋</span>&#13;
    return x;&#13;
<span epub:type="pagebreak" id="page_253"/>}&#13;
&#13;
template &lt;typename T, typename... Args&gt;&#13;
constexpr<span class="ent">➌</span> T sum(T x, Args... args) { <span class="ent">➍</span>&#13;
    return x + sum(args...<span class="ent">➎</span>);&#13;
}&#13;
&#13;
int main() {&#13;
  printf("The answer is %d.", sum(2, 4, 6, 8, 10, 12)); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42. <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch09ex08"/><em>Listing 9-8: A refactor of <a href="ch09.xhtml#ch09ex05">Listing 9-5</a> using a template parameter pack instead of <code>va_args</code></em></p>&#13;
<p class="indent">The first function <span class="ent">➋</span> is the overload that handles the stopping condition; if the function has only a single argument, you simply return the argument <code>x,</code> because the sum of a single element is just the element. The variadic template <span class="ent">➍</span> follows the recursion pattern outlined in <a href="ch09.xhtml#ch09ex07">Listing 9-7</a>. It peels a single argument <code>x</code> off the parameter pack <code>args</code> and then returns <code>x</code> plus the result of the recursive call to <code>sum</code> with the expanded parameter pack <span class="ent">➎</span>. Because all of this generic programming can be computed at compile time, you mark these functions <code>constexpr</code> <span class="ent">➊➌</span>. This compile-time computation is a <em>major</em> advantage over <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>, which has identical output but computes the result at runtime <span class="ent">➏</span>. (Why pay runtime costs when you don’t have to?)</p>&#13;
<p class="indent">When you just want to apply a single binary operator (like plus or minus) over a range of values (like <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>), you can use a fold expression instead of recursion.</p>&#13;
<h4 class="h4" id="ch09lev2sec5"><strong><em>Fold Expressions</em></strong></h4>&#13;
<p class="noindent">A <em>fold expression</em> computes the result of using a binary operator over all the arguments of a parameter pack. Fold expressions are distinct from but related to variadic templates. Their usage is as follows:</p>&#13;
<pre>(... <span class="codeitalic1">binary-operator parameter-pack</span>)</pre>&#13;
<p class="indent">For example, you could employ the following fold expression to sum over all elements in a parameter pack called <code>args</code>:</p>&#13;
<pre>(... + args)</pre>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex09">Listing 9-9</a> refactors 9-8 to use a fold expression instead of recursion.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;typename... T&gt;&#13;
constexpr auto sum(T... args) {&#13;
  return (... + args); <span class="ent">➊</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_254"/>int main() {&#13;
  printf("The answer is %d.", sum(2, 4, 6, 8, 10, 12)); <span class="ent">➋</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The answer is 42. <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch09ex09"/><em>Listing 9-9: A refactor of <a href="ch09.xhtml#ch09ex08">Listing 9-8</a> using a fold expression</em></p>&#13;
<p class="indent">You simplify the <code>sum</code> function by using a fold expression instead of the recursion approach <span class="ent">➊</span>. The end result is identical <span class="ent">➋</span>.</p>&#13;
<h3 class="h3" id="ch09lev1sec7"><strong>Function Pointers</strong></h3>&#13;
<p class="noindent"><em>Functional programming</em> is a programming paradigm that emphasizes function evaluation and immutable data. One of the major concepts in functional programming is to pass a function as a parameter to another function.</p>&#13;
<p class="indent">One way you can achieve this is to pass a function pointer. Functions occupy memory, just like objects. You can refer to this memory address via usual pointer mechanisms. However, unlike objects, you cannot modify the pointed-to function. In this respect, functions are conceptually similar to <code>const</code> objects. You can take the address of functions and invoke them, and that’s about it.</p>&#13;
<h4 class="h4" id="ch09lev2sec6"><strong><em>Declaring a Function Pointer</em></strong></h4>&#13;
<p class="noindent">To declare a function pointer, use the following ugly syntax:</p>&#13;
<pre><span class="codeitalic1">return-type</span> (*<span class="codeitalic1">pointer-name</span>)(<span class="codeitalic1">arg-type1</span>, <span class="codeitalic1">arg-type2</span>, ...);</pre>&#13;
<p class="indent">This has the same appearance as a function declaration where the function name is replaced (<code>*<span class="codeitalic">pointer-name</code>)</span>.</p>&#13;
<p class="indent">As usual, you can employ the address-of operator <code>&amp;</code> to take the address of a function. This is optional, however; you can simply use the function name as a pointer.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex10">Listing 9-10</a> illustrates how you can obtain and use function pointers.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
float add(float a, int b) {&#13;
  return a + b;&#13;
}&#13;
&#13;
float subtract(float a, int b) {&#13;
  return a - b;&#13;
}&#13;
&#13;
int main() {&#13;
  const float first{ 100 };&#13;
  const int second{ 20 };&#13;
&#13;
  float(*operation)(float, int) {}; <span class="ent">➊</span>&#13;
  printf("operation initialized to 0x%p\n", operation); <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_255"/>&#13;
  operation = &amp;add; <span class="ent">➌</span>&#13;
  printf("&amp;add = 0x%p\n", operation); <span class="ent">➍</span>&#13;
  printf("%g + %d = %g\n", first, second, operation(first, second)); <span class="ent">➎</span>&#13;
&#13;
  operation = subtract; <span class="ent">➏</span>&#13;
  printf("&amp;subtract = 0x%p\n", operation); <span class="ent">➐</span>&#13;
  printf("%g - %d = %g\n", first, second, operation(first, second)); <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">operation initialized to 0x0000000000000000 <span class="ent">➋</span></span>&#13;
<span class="color1">&amp;add = 0x00007FF6CDFE1070 <span class="ent">➍</span></span>&#13;
<span class="color1">100 + 20 = 120 <span class="ent">➎</span></span>&#13;
<span class="color1">&amp;subtract = 0x00007FF6CDFE10A0 <span class="ent">➐</span></span>&#13;
<span class="color1">100 - 20 = 80 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch09ex10"/><em>Listing 9-10: A program illustrating function pointers. (Due to address space layout randomization, the addresses <span class="ent">➍➐</span> will vary at runtime.)</em></p>&#13;
<p class="indent">This listing shows two functions with identical function signatures, <code>add</code> and <code>subtract</code>. Because the function signatures match, pointer types to these functions will also match. You initialize a function pointer <code>operation</code> accepting a <code>float</code> and an <code>int</code> as arguments and returning a <code>float</code> <span class="ent">➊</span>. Next, you print the value of <code>operation</code>, which is <code>nullptr</code>, after initialization <span class="ent">➋</span>.</p>&#13;
<p class="indent">You then assign the address of <code>add</code> to <code>operation</code> <span class="ent">➌</span> using the address-of operator and print its new address <span class="ent">➍</span>. You invoke <code>operation</code> and print the result <span class="ent">➎</span>.</p>&#13;
<p class="indent">To illustrate that you can reassign function pointers, you assign <code>operation</code> to <code>subtract</code> without using the address of operator <span class="ent">➏</span>, print the new value of <code>operation</code> <span class="ent">➐</span>, and finally print the result <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch09lev2sec7"><strong><em>Type Aliases and Function Pointers</em></strong></h4>&#13;
<p class="noindent">Type aliases provide a neat way to program with function pointers. The usage is as follows:</p>&#13;
<pre>using <span class="codeitalic1">alias-name</span> = <span class="codeitalic1">return-type</span>(*)(<span class="codeitalic1">arg-type1</span>, <span class="codeitalic1">arg-type2</span>, ...)</pre>&#13;
<p class="indent">You could have defined an <code>operation_func</code> type alias in <a href="ch09.xhtml#ch09ex10">Listing 9-10</a>, for example:</p>&#13;
<pre>using operation_func = float(*)(float, int);</pre>&#13;
<p class="indent">This is especially useful if you’ll be using function pointers of the same type; it can really clean up the code.</p>&#13;
<h3 class="h3" id="ch09lev1sec8"><strong>The Function-Call Operator</strong></h3>&#13;
<p class="noindent">You can make user-defined types callable or invocable by overloading the function-call operator <code>operator()()</code>. Such a type is called a <em>function type</em>, and instances of a function type are called <em>function objects</em>. The function-call <span epub:type="pagebreak" id="page_256"/>operator permits any combination of argument types, return types, and modifiers (except <code>static</code>).</p>&#13;
<p class="indent">The primary reason you might want to make a user-defined type callable is to interoperate with code that expects function objects to use the function-call operator. You’ll find that many libraries, such as the stdlib, use the function-call operator as the interface for function-like objects. For example, in <a href="ch19.xhtml#ch19">Chapter 19</a>, you’ll learn how to create an asynchronous task with the <code>std::async</code> function, which accepts an arbitrary function object that can execute on a separate thread. It uses the function-call operator as the interface. The committee that invented <code>std::async</code> could have required you to expose, say, a <code>run</code> method, but they chose the function-call operator because it allows generic code to use identical notation to invoke a function or a function object.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex11">Listing 9-11</a> illustrates the function-call operator’s usage.</p>&#13;
<pre>struct <span class="codeitalic1">type-name</span> {&#13;
  <span class="codeitalic1">return-type</span><span class="ent">➊</span> operator()<span class="ent">➋</span>(<span class="codeitalic1">arg-type1</span> arg1, <span class="codeitalic1">arg-type2</span> arg2, ...<span class="ent">➌</span>) {&#13;
    // Body of function-call operator&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex11"/><em>Listing 9-11: The function-call operator’s usage</em></p>&#13;
<p class="indent">The function-call operator has the special <code>operator()</code> method name <span class="ent">➋</span>. You declare an arbitrary number of arguments <span class="ent">➌</span>, and you also decide the appropriate return type <span class="ent">➊</span>.</p>&#13;
<p class="indent">When the compiler evaluates a function-call expression, it will invoke the function-call operator on the first operand, passing the remaining operands as arguments. The result of the function-call expression is the result of invoking the corresponding function-call operator.</p>&#13;
<h3 class="h3" id="ch09lev1sec9"><strong>A Counting Example</strong></h3>&#13;
<p class="noindent">Consider the function type <code>CountIf</code> in <a href="ch09.xhtml#ch09ex12">Listing 9-12</a>, which computes the frequency of a particular <code>char</code> in a null-terminated string.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
struct CountIf {&#13;
  CountIf(char x) : x{ x } { }<span class="ent">➊</span>&#13;
  size_t operator()(const char* str<span class="ent">➋</span>) const {&#13;
    size_t index{}<span class="ent">➌</span>, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == x) result++; <span class="ent">➍</span>&#13;
      index++;&#13;
    }&#13;
    return result;&#13;
  }&#13;
private:&#13;
  const char x;&#13;
<span epub:type="pagebreak" id="page_257"/>};&#13;
&#13;
int main() {&#13;
  CountIf s_counter{ 's' }; <span class="ent">➎</span>&#13;
  auto sally = s_counter("Sally sells seashells by the seashore."); <span class="ent">➏</span>&#13;
  printf("Sally: %zu\n", sally);&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
  auto buffalo = CountIf{ 'f' }("Buffalo buffalo Buffalo buffalo "&#13;
                                "buffalo buffalo Buffalo buffalo."); <span class="ent">➐</span>&#13;
  printf("Buffalo: %zu\n", buffalo);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Buffalo: 16</span></pre>&#13;
<p class="listing"><a id="ch09ex12"/><em>Listing 9-12: A function type that counts the number of characters appearing in a null-terminated string</em></p>&#13;
<p class="indent">You initialize <code>CountIf</code> objects using a constructor taking a <code>char</code> <span class="ent">➊</span>. You can call the resulting function object as if it were a function taking a null-terminated string argument <span class="ent">➋</span>, because you’ve implemented the function call operator. The function call operator iterates through each character in the argument <code>str</code> using an <code>index</code> variable <span class="ent">➌</span>, incrementing the <code>result</code> variable whenever the character matches the <code>x</code> field <span class="ent">➍</span>. Because calling the function doesn’t modify the state of a <code>CountIf</code> object, you’ve marked it <code>const</code>.</p>&#13;
<p class="indent">Within <code>main</code>, you’ve initialized the <code>CountIf</code> function object <code>s_counter</code>, which will count the frequency of the letter <code>s</code> <span class="ent">➎</span>. You can use <code>s_counter</code> as if it were a function <span class="ent">➏</span>. You can even initialize a <code>CountIf</code> object and use the function operator directly as an rvalue object <span class="ent">➐</span>. You might find this convenient to do in some settings where, for example, you might only need to invoke the object a single time.</p>&#13;
<p class="indent">You can employ function objects as partial applications. <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> is conceptually similar to the <code>count_if</code> function in <a href="ch09.xhtml#ch09ex13">Listing 9-13</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
size_t count_if(char x<span class="ent">➊</span>, const char* str) {&#13;
  size_t index{}, result{};&#13;
  while (str[index]) {&#13;
    if (str[index] == x) result++;&#13;
    index++;&#13;
  }&#13;
  return result;&#13;
}&#13;
&#13;
int main() {&#13;
  auto sally = count_if('s', "Sally sells seashells by the seashore.");&#13;
  printf("Sally: %zu\n", sally);&#13;
  auto sailor = count_if('s', "Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
<span epub:type="pagebreak" id="page_258"/>  auto buffalo = count_if('f', "Buffalo buffalo Buffalo buffalo "&#13;
                               "buffalo buffalo Buffalo buffalo.");&#13;
  printf("Buffalo: %zu\n", buffalo);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Buffalo: 16</span></pre>&#13;
<p class="listing"><a id="ch09ex13"/><em>Listing 9-13: A free function emulating <a href="ch09.xhtml#ch09ex12">Listing 9-12</a></em></p>&#13;
<p class="indent">The <code>count_if</code> function has an extra argument <code>x</code> <span class="ent">➊</span>, but otherwise it’s almost identical to the function operator of <code>CountIf</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In functional programming parlance, the <code>CountIf</code> is the <code>partial application</code> of <code>x</code> to <code>count_if</code>. When you partially apply an argument to a function, you fix that argument’s value. The product of such a partial application is another function taking one less argument.</em></p>&#13;
</div>&#13;
<p class="indent">Declaring function types is verbose. You can often reduce the boilerplate substantially with lambda expressions.</p>&#13;
<h3 class="h3" id="ch09lev1sec10"><strong>Lambda Expressions</strong></h3>&#13;
<p class="noindent"><em>Lambda expressions</em> construct unnamed function objects succinctly. The function object implies the function type, resulting in a quick way to declare a function object on the fly. Lambdas don’t provide any additional functionality other than declaring function types the old-fashioned way. But they’re extremely convenient when you need to initialize a function object in only a single context.</p>&#13;
<h4 class="h4" id="ch09lev2sec8"><strong><em>Usage</em></strong></h4>&#13;
<p class="noindent">There are five components to a lambda expression:</p>&#13;
<ul>&#13;
<li class="noindent"><code><em>captures</em></code>: The member variables of the function object (that is, the partially applied parameters)</li>&#13;
<li class="noindent"><code><em>parameters</em></code>: The arguments required to invoke the function object</li>&#13;
<li class="noindent"><code><em>body</em></code>: The function object’s code</li>&#13;
<li class="noindent"><code><em>specifiers</em></code>: Elements like <code>constexpr, mutable</code>, <code>noexcept</code>, and <code>[[noreturn]]</code></li>&#13;
<li class="noindent"><code><em>return type</em></code>: The type returned by the function object</li>&#13;
</ul>&#13;
<p class="indent">Lambda expression usage is as follows:</p>&#13;
<pre>[<span class="codeitalic1">captures</span><span class="ent">➊</span>] (<span class="codeitalic1">parameters</span><span class="ent">➋</span>) <span class="codeitalic1">specifiers</span><span class="ent">➌</span> -&gt; <span class="codeitalic1">return-type</span><span class="ent">➍</span> { <span class="codeitalic1">body</span><span class="ent">➎</span> }</pre>&#13;
<p class="indent">Only the captures and the body are required; everything else is optional. You’ll learn about each of these components in depth in the next few sections.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>Each lambda component has a direct analogue in a function object. To form a bridge between the function objects like <code>CountIf</code> and lambda expressions, look at <a href="ch09.xhtml#ch09ex14">Listing 9-14</a>, which lists the <code>CountIf</code> function type from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> with annotations that correspond to the analogous portions of the lambda expression in the usage listing.</p>&#13;
<pre>struct CountIf {&#13;
  CountIf(char x) : x{ x } { } <span class="ent">➊</span>&#13;
  size_t<span class="ent">➍</span> operator()(const char* str<span class="ent">➋</span>) const<span class="ent">➎</span> {&#13;
    --<span class="codeitalic1">snip</span>--<span class="ent">➌</span>&#13;
  }&#13;
private:&#13;
  const char x; <span class="ent">➋</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch09ex14"/><em>Listing 9-14: Comparing the <code>CountIf</code> type declaration with a lambda expression</em></p>&#13;
<p class="indent">The member variables you set in the constructor of <code>CountIf</code> are analogous to a lambda’s capture <span class="ent">➊</span>. The function-call operator’s arguments <span class="ent">➋</span>, body <span class="ent">➌</span>, and return type <span class="ent">➍</span> are analogous to the lambda’s parameters, body, and return type. Finally, modifiers can apply to the function-call operator <span class="ent">➎</span> and the lambda. (The numbers in the Lambda expession usage example and <a href="ch09.xhtml#ch09ex14">Listing 9-14</a> correspond.)</p>&#13;
<h4 class="h4" id="ch09lev2sec9"><strong><em>Lambda Parameters and Bodies</em></strong></h4>&#13;
<p class="noindent">Lambda expressions produce function objects. As function objects, lambdas are callable. Most of the time, you’ll want your function object to accept parameters upon invocation.</p>&#13;
<p class="indent">The lambda’s body is just like a function body: all of the parameters have function scope.</p>&#13;
<p class="indent">You declare lambda parameters and bodies using essentially the same syntax that you use for functions.</p>&#13;
<p class="indent">For example, the following lambda expression yields a function object that will square its <code>int</code> argument:</p>&#13;
<pre>[](int x) { return x*x; }</pre>&#13;
<p class="indent">The lambda takes a single <code>int x</code> and uses it within the lambda’s body to perform the squaring.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex15">Listing 9-15</a> employs three different lambdas to transform the array <code>1, 2, 3</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
template &lt;typename Fn&gt;&#13;
void transform(Fn fn, const int* in, int* out, size_t length) { <span class="ent">➊</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    out[i] = fn(in[i]); <span class="ent">➋</span>&#13;
  }&#13;
<span epub:type="pagebreak" id="page_260"/>}&#13;
&#13;
int main() {&#13;
  const size_t len{ 3 };&#13;
  int base[]{ 1, 2, 3 }, a[len], b[len], c[len];&#13;
  transform([](int x) { return 1; }<span class="ent">➌</span>, base, a, len);&#13;
  transform([](int x) { return x; }<span class="ent">➍</span>, base, b, len);&#13;
  transform([](int x) { return 10*x+5; }<span class="ent">➎</span>, base, c, len);&#13;
  for (size_t i{}; i &lt; len; i++) {&#13;
    printf("Element %zu: %d %d %d\n", i, a[i], b[i], c[i]);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Element 0: 1 1 15</span>&#13;
<span class="color1">Element 1: 1 2 25</span>&#13;
<span class="color1">Element 2: 1 3 35</span></pre>&#13;
<p class="listing"><a id="ch09ex15"/><em>Listing 9-15: Three lambdas and a transform function</em></p>&#13;
<p class="indent">The <code>transform</code> template function <span class="ent">➊</span> accepts four arguments: a function object <code>fn</code>, an <code>in</code> array and an <code>out</code> array, and the corresponding <code>length</code> of those arrays. Within transform, you invoke <code>fn</code> on each element of <code>in</code> and assign the result to the corresponding element of <code>out</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you declare a <code>base</code> array <code>1, 2, 3</code> that will be used as the <code>in</code> array. In the same line you also declare three uninitialized arrays <code>a, b</code>, and <code>c</code>, which will be used as the <code>out</code> arrays. The first call to <code>transform</code> passes a lambda <code>([](int x) { return 1; })</code> that always returns 1 <span class="ent">➌</span>, and the result is stored into <code>a</code>. (Notice that the lambda didn’t need a name!) The second call to <code>transform ([](int x) { return x; })</code> simply returns its argument <span class="ent">➍</span>, and the result is stored into <code>b</code>. The third call to <code>transform</code> multiplies the argument by 10 and adds 5 <span class="ent">➎</span>. The result is stored in <code>c</code>. You then print the output into a matrix where each column illustrates the transform that was applied to the different lambdas in each case.</p>&#13;
<p class="indent">Notice that you declared <code>transform</code> as a template function, allowing you to reuse it with any function object.</p>&#13;
<h4 class="h4" id="ch09lev2sec10"><strong><em>Default Arguments</em></strong></h4>&#13;
<p class="noindent">You can provide default arguments to a lambda. Default lambda parameters behave just like default function parameters. The caller can specify values for default parameters, in which case the lambda uses the caller-provided values. If the caller doesn’t specify a value, the lambda uses the default.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex16">Listing 9-16</a> illustrates the default argument behavior.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  auto increment = [](auto x, int y = 1<span class="ent">➊</span>) { return x + y; };&#13;
  printf("increment(10)    = %d\n", increment(10)); <span class="ent">➋</span>&#13;
  printf("increment(10, 5) = %d\n", increment(10, 5)); <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1"><span epub:type="pagebreak" id="page_261"/>increment(10)    = 11 <span class="ent">➋</span></span>&#13;
<span class="color1">increment(10, 5) = 15 <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch09ex16"/><em>Listing 9-16: Using default lambda parameters</em></p>&#13;
<p class="indent">The increment lambda has two parameters, <code>x</code> and <code>y</code>. But the <code>y</code> parameter is optional because it has the default argument 1 <span class="ent">➊</span>. If you don’t specify an argument for <code>y</code> when you call the function <span class="ent">➋, increment</span> returns <code>1 + x</code>. If you do call the function with an argument for <code>y</code> <span class="ent">➌</span>, that value is used instead.</p>&#13;
<h4 class="h4" id="ch09lev2sec11"><strong><em>Generic Lambdas</em></strong></h4>&#13;
<p class="noindent">Generic lambdas are lambda expression templates. For one or more parameters, you specify <code>auto</code> rather than a concrete type. These <code>auto</code> types become template parameters, meaning the compiler will stamp out a custom instantiation of the lambda.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex17">Listing 9-17</a> illustrates how to assign a generic lambda into a variable and then use the lambda in two different template instantiations.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
template &lt;typename Fn, typename T<span class="ent">➊</span>&gt;&#13;
void transform(Fn fn, const T* in, T* out, size_t len) {&#13;
  for(size_t i{}; i&lt;len; i++) {&#13;
    out[i] = fn(in[i]);&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  constexpr size_t len{ 3 };&#13;
  int base_int[]{ 1, 2, 3 }, a[len]; <span class="ent">➋</span>&#13;
  float base_float[]{ 10.f, 20.f, 30.f }, b[len]; <span class="ent">➌</span>&#13;
  auto translate = [](auto x) { return 10 * x + 5; }; <span class="ent">➍</span>&#13;
  transform(translate, base_int, a, l); <span class="ent">➎</span>&#13;
  transform(translate, base_float, b, l); <span class="ent">➏</span>&#13;
&#13;
  for (size_t i{}; i &lt; l; i++) {&#13;
    printf("Element %zu: %d %f\n", i, a[i], b[i]);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Element 0: 15 105.000000</span>&#13;
<span class="color1">Element 1: 25 205.000000</span>&#13;
<span class="color1">Element 2: 35 305.000000</span></pre>&#13;
<p class="listing"><a id="ch09ex17"/><em>Listing 9-17: Using a generic lambda</em></p>&#13;
<p class="indent">You add a second template parameter to <code>transform</code> <span class="ent">➊</span>, which you use as the pointed-to type of <code>in</code> and <code>out</code>. This allows you to apply transform to arrays of any type, not just of <code>int</code> types. To test out the upgraded transform template, you declare two arrays with different pointed-to types: <code>int</code> <span class="ent">➋</span> and <span epub:type="pagebreak" id="page_262"/><code>float</code> <span class="ent">➌</span>. (Recall from <a href="ch03.xhtml#ch03">Chapter 3</a> that the <code>f</code> in <code>10.f</code> specifies a <code>float</code> literal.) Next, you assign a generic lambda expression to <code>translate</code> <span class="ent">➍</span>. This allows you to use the same lambda for each instantiation of transform: when you instantiate with <code>base_int</code> <span class="ent">➎</span> and with <code>base_float</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Without a generic lambda, you’d have to declare the parameter types explicitly, like the following:</p>&#13;
<pre>--<span class="codeitalic1">snip</span>–&#13;
  transform([](int x) { return 10 * x + 5; }, base_int, a, l); <span class="ent">➎</span>&#13;
  transform([](double x) { return 10 * x + 5; }, base_float, b, l); <span class="ent">➏</span></pre>&#13;
<p class="indent">So far, you’ve been leaning on the compiler to deduce the return types of your lambdas. This is especially useful for generic lambdas, because often the lambda’s return type will depend on its parameter types. But you can explicitly state the return type if you want.</p>&#13;
<h4 class="h4" id="ch09lev2sec12"><strong><em>Lambda Return Types</em></strong></h4>&#13;
<p class="noindent">The compiler deduces a lambda’s return type for you. To take over from the compiler, you use the arrow <code>-&gt;</code> syntax, as in the following:</p>&#13;
<pre>[](int x, double y) -&gt; double { return x + y; }</pre>&#13;
<p class="indent">This lambda expression accepts an <code>int</code> and a <code>double</code> and returns a <code>double</code>.</p>&#13;
<p class="indent">You can also use <code>decltype</code> expressions, which can be useful with generic lambdas. For example, consider the following lambda:</p>&#13;
<pre>[](auto x, double y) -&gt; decltype(x+y) { return x + y; }</pre>&#13;
<p class="indent">Here you’ve explicitly declared that the return type of the lambda is whatever type results from adding an <code>x</code> to a <code>y</code>.</p>&#13;
<p class="indent">You’ll rarely need to specify a lambda’s return type explicitly.</p>&#13;
<p class="indent">A far more common requirement is that you must inject an object into a lambda before invocation. This is the role of lambda captures.</p>&#13;
<h4 class="h4" id="ch09lev2sec13"><strong><em>Lambda Captures</em></strong></h4>&#13;
<p class="noindent"><em>Lambda captures</em> inject objects into the lambda. The injected objects help to modify the behavior of the lambda.</p>&#13;
<p class="indent">Declare a lambda’s capture by specifying a capture list within brackets <code>[]</code>. The capture list goes before the parameter list, and it can contain any number of comma-separated arguments. You then use these arguments within the lambda’s body.</p>&#13;
<p class="indent">A lambda can capture by reference or by value. By default, lambdas capture by value.</p>&#13;
<p class="indent">A lambda’s capture list is analogous to a function type’s constructor. <a href="ch09.xhtml#ch09ex18">Listing 9-18</a> reformulates <code>CountIf</code> from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> as the lambda <code>s_counter</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_263"/>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  char to_count{ 's' }; <span class="ent">➊</span>&#13;
  auto s_counter = [to_count<span class="ent">➋</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count<span class="ent">➌</span>) result++;&#13;
      index++;&#13;
    }&#13;
    return result;&#13;
  };&#13;
  auto sally = s_counter("Sally sells seashells by the seashore."<span class="ent">➍</span>);&#13;
  printf("Sally: %zu\n", sally);&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Sailor: 3</span></pre>&#13;
<p class="listing"><a id="ch09ex18"/><em>Listing 9-18: Reformulating <code>CountIf</code> from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a> as a lambda</em></p>&#13;
<p class="indent">You initialize a <code>char</code> called <code>to_count</code> to the letter <code>s</code> <span class="ent">➊</span>. Next, you capture <code>to_count</code> within the lambda expression assigned to <code>s_counter</code> <span class="ent">➋</span>. This makes <code>to_count</code> available within the body of the lambda expression <span class="ent">➌</span>.</p>&#13;
<p class="indent">To capture an element by reference rather than by value, prefix the captured object’s name with an ampersand <code>&amp;</code>. <a href="ch09.xhtml#ch09ex19">Listing 9-19</a> adds a capture reference to <code>s_counter</code> that keeps a running tally across lambda invocations.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  char to_count{ 's' };&#13;
  size_t tally{};<span class="ent">➊</span>&#13;
  auto s_counter = [to_count, &amp;tally<span class="ent">➋</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count) result++;&#13;
      index++;&#13;
    }&#13;
    tally += result;<span class="ent">➌</span>&#13;
    return result;&#13;
  };&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➍</span>&#13;
  auto sally = s_counter("Sally sells seashells by the seashore.");&#13;
  printf("Sally: %zu\n", sally);&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➎</span>&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
<span epub:type="pagebreak" id="page_264"/>  printf("Tally: %zu\n", tally); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Tally: 0 <span class="ent">➍</span></span>&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Tally: 7 <span class="ent">➎</span></span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Tally: 10 <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch09ex19"/><em>Listing 9-19: Using a capture reference in a lambda</em></p>&#13;
<p class="indent">You initialize the counter variable <code>tally</code> to zero <span class="ent">➊</span>, and then the <code>s_counter</code> lambda captures <code>tally</code> by reference (note the ampersand <code>&amp;</code>) <span class="ent">➋</span>. Within the lambda’s body, you add a statement to increment <code>tally</code> by an invocation’s <code>result</code> before returning <span class="ent">➌</span>. The result is that <code>tally</code> will track the total count no matter how many times you invoke the lambda. Before the first <code>s_counter</code> invocation, you print the value of <code>tally</code> <span class="ent">➍</span> (which is still zero). After you invoke <code>s_counter</code> with <code>Sally sells seashells by the seashore.</code>, you have a <code>tally</code> of 7 <span class="ent">➎</span>. The last invocation of <code>s_counter</code> with <code>Sailor went to sea to see what he could see.</code> returns 3, so the value of <code>tally</code> is 7 + 3 = 10 <span class="ent">➏</span>.</p>&#13;
<h5 class="h5" id="ch09lev3sec3"><strong>Default Capture</strong></h5>&#13;
<p class="noindent">So far, you’ve had to capture each element by name. Sometimes this style of capturing is called <em>named capture</em>. If you’re lazy, you can capture all automatic variables used within a lambda using <em>default capture</em>. To specify a default capture by value within a capture list, use a lone equal sign <code>=</code>. To specify a default capture by reference, use a lone ampersand <code>&amp;</code>.</p>&#13;
<p class="indent">For example, you could “simplify” the lambda expression in <a href="ch09.xhtml#ch09ex19">Listing 9-19</a> to perform a default capture by reference, as demonstrated in <a href="ch09.xhtml#ch09ex20">Listing 9-20</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
  auto s_counter = [&amp;<span class="ent">➊</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count<span class="ent">➋</span>) result++;&#13;
      index++;&#13;
    }&#13;
    tally<span class="ent">➌</span> += result;&#13;
    return result;&#13;
  };&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="listing"><a id="ch09ex20"/><em>Listing 9-20: Simplifying a lambda expression with a default capture by reference</em></p>&#13;
<p class="indent">You specify a default capture by reference <span class="ent">➊</span>, which means any automatic variables in the body of the lambda expression get captured by reference. There are two: <code>to_count</code> <span class="ent">➋</span> and <code>tally</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">If you compile and run the refactored listing, you’ll obtain identical output. However, notice that <code>to_count</code> is now captured by reference. If you <span epub:type="pagebreak" id="page_265"/>accidentally modify it within the lambda expression’s body, the change will occur across lambda invocations as well as within <code>main</code> (where <code>to_count</code> is an automatic variable).</p>&#13;
<p class="indent">What would happen if you performed a default capture by value instead? You would only need to change the <code>=</code> to an <code>&amp;</code> in the capture list, as demonstrated in <a href="ch09.xhtml#ch09ex21">Listing 9-21</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
  auto s_counter = [=<span class="ent">➊</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count<span class="ent">➋</span>) result++;&#13;
      index++;&#13;
    }&#13;
    tally<span class="ent">➌</span> += result;&#13;
    return result;&#13;
  };&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="listing"><a id="ch09ex21"/><em>Listing 9-21: Modifying <a href="ch09.xhtml#ch09ex20">Listing 9-20</a> to capture by value instead of by reference (This code doesn't compile.)</em></p>&#13;
<p class="indent">You change the default capture to be by value <span class="ent">➊</span>. The <code>to_count</code> capture is unaffected <span class="ent">➋</span>, but attempting to modify <code>tally</code> results in a compiler error <span class="ent">➌</span>. You’re not allowed to modify variables captured by value unless you add the <code>mutable</code> keyword to the lambda expression. The <code>mutable</code> keyword allows you to modify value-captured variables. This includes calling non-<code>const</code> methods on that object.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex22">Listing 9-22</a> adds the <code>mutable</code> modifier and has a default capture by value.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main() {&#13;
  char to_count{ 's' };&#13;
  size_t tally{};&#13;
  auto s_counter = [=<span class="ent">➊</span>](const char* str) mutable<span class="ent">➋</span> {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == to_count) result++;&#13;
      index++;&#13;
    }&#13;
    tally += result;&#13;
    return result;&#13;
  };&#13;
  auto sally = s_counter("Sally sells seashells by the seashore.");&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➌</span>&#13;
  printf("Sally: %zu\n", sally);&#13;
  printf("Tally: %zu\n", tally); <span class="ent">➍</span>&#13;
  auto sailor = s_counter("Sailor went to sea to see what he could see.");&#13;
  printf("Sailor: %zu\n", sailor);&#13;
<span epub:type="pagebreak" id="page_266"/>  printf("Tally: %zu\n", tally); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Tally: 0</span>&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Tally: 0</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Tally: 0</span></pre>&#13;
<p class="listing"><a id="ch09ex22"/><em>Listing 9-22: A <code>mutable</code> lambda expression with a default capture by value</em></p>&#13;
<p class="indent">You declare a default capture by value <span class="ent">➊</span>, and you make the lambda <code>s_counter mutable</code> <span class="ent">➋</span>. Each of the three times you print <code>tally</code> <span class="ent">➌➍➎</span>, you get a zero value. Why?</p>&#13;
<p class="indent">Because <code>tally</code> gets copied by value (via the default capture), the version in the lambda is, in essence, an entirely different variable that just happens to have the same name. Modifications to the lambda’s copy of <code>tally</code> don’t affect the automatic <code>tally</code> variable of <code>main</code>. The <code>tally</code> in <code>main()</code> is initialized to zero and never gets modified.</p>&#13;
<p class="indent">It’s also possible to mix a default capture with a named capture. You could, for example, default capture by reference and copy <code>to_count</code> by value using the following formulation:</p>&#13;
<pre>  auto s_counter = [&amp;<span class="ent">➊</span>,to_count<span class="ent">➋</span>](const char* str) {&#13;
    --<span class="codeitalic1">snip</span>--&#13;
  };</pre>&#13;
<p class="indent">This specifies a default capture by reference <span class="ent">➊</span> and <code>to_count</code> <span class="ent">➋</span> capture by value.</p>&#13;
<p class="indent">Although performing a default capture might seem like an easy shortcut, refrain from using it. It’s far better to declare captures explicitly. If you catch yourself saying “I’ll just use a default capture because there are too many variables to list out,” you probably need to refactor your code.</p>&#13;
<h5 class="h5" id="ch09lev3sec4"><strong>Initializer Expressions in Capture Lists</strong></h5>&#13;
<p class="noindent">Sometimes you want to initialize a whole new variable within a capture list. Maybe renaming a captured variable would make a lambda expression’s intent clearer. Or perhaps you want to move an object into a lambda and therefore need to initialize a variable.</p>&#13;
<p class="indent">To use an initializer expression, just declare the new variable’s name followed by an equal sign and the value you want to initialize your variable with, as <a href="ch09.xhtml#ch09ex23">Listing 9-23</a> demonstrates.</p>&#13;
<pre>  auto s_counter = [&amp;tally<span class="ent">➊</span>,my_char=to_count<span class="ent">➋</span>](const char* str) {&#13;
    size_t index{}, result{};&#13;
    while (str[index]) {&#13;
      if (str[index] == my_char<span class="ent">➌</span>) result++;&#13;
    --<span class="codeitalic1">snip</span>--&#13;
  };</pre>&#13;
<p class="listing"><a id="ch09ex23"/><em>Listing 9-23: Using an initializer expression within a lambda capture</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_267"/>The capture list contains a simple named capture where you have <code>tally</code> by reference <span class="ent">➊</span>. The lambda also captures <code>to_count</code> by value, but you’ve elected to use the variable name <code>my_char</code> instead <span class="ent">➋</span>. Of course, you’ll need to use the name <code>my_char</code> instead of <code>to_count</code> inside the lambda <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>An initializer expression in a capture list is also called an init capture.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec5"><strong>Capturing this</strong></h5>&#13;
<p class="noindent">Sometimes lambda expressions have an enclosing class. You can capture an enclosing object (pointed-to by <code>this</code>) by value or by reference using either <code>[*this]</code> or <code>[this]</code>, respectively.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex24">Listing 9-24</a> implements a <code>LambdaFactory</code> that generates counting lambdas and keeps track of a <code>tally</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
struct LambdaFactory {&#13;
  LambdaFactory(char in) : to_count{ in }, tally{} { }&#13;
  auto make_lambda() { <span class="ent">➊</span>&#13;
    return [this<span class="ent">➋</span>](const char* str) {&#13;
      size_t index{}, result{};&#13;
      while (str[index]) {&#13;
        if (str[index] == to_count<span class="ent">➌</span>) result++;&#13;
        index++;&#13;
      }&#13;
      tally<span class="ent">➍</span> += result;&#13;
      return result;&#13;
    };&#13;
  }&#13;
  const char to_count;&#13;
  size_t tally;&#13;
};&#13;
&#13;
int main() {&#13;
  LambdaFactory factory{ 's' }; <span class="ent">➎</span>&#13;
  auto lambda = factory.make_lambda(); <span class="ent">➏</span>&#13;
  printf("Tally: %zu\n", factory.tally);&#13;
  printf("Sally: %zu\n", lambda("Sally sells seashells by the seashore."));&#13;
  printf("Tally: %zu\n", factory.tally);&#13;
  printf("Sailor: %zu\n", lambda("Sailor went to sea to see what he could see."));&#13;
  printf("Tally: %zu\n", factory.tally);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Tally: 0</span>&#13;
<span class="color1">Sally: 7</span>&#13;
<span class="color1">Tally: 7</span>&#13;
<span class="color1">Sailor: 3</span>&#13;
<span class="color1">Tally: 10</span></pre>&#13;
<p class="listing"><a id="ch09ex24"/><em>Listing 9-24: A <code>LambdaFactory</code> illustrating the use of <code>this</code> capture</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>The <code>LambdaFactory</code> constructor takes a single character and initializes the <code>to_count</code> field with it. The <code>make_lambda</code> <span class="ent">➊</span> method illustrates how you can capture <code>this</code> by reference <span class="ent">➋</span> and use the <code>to_count</code> <span class="ent">➌</span> and <code>tally</code> <span class="ent">➍</span> member variables within the lambda expression.</p>&#13;
<p class="indent">Within <code>main</code>, you initialize a <code>factory</code> <span class="ent">➎</span> and make a <code>lambda</code> using the <code>make_</code><code>lambda</code> method <span class="ent">➏</span>. The output is identical to <a href="ch09.xhtml#ch09ex19">Listing 9-19</a>, because you capture <code>this</code> by reference and state of <code>tally</code> persists across invocations of <code>lambda</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec6"><strong>Clarifying Examples</strong></h5>&#13;
<p class="noindent">There are a lot of possibilities with capture lists, but once you have a command of the basics–capturing by value and by reference–there aren’t many surprises. <a href="ch09.xhtml#ch09tab02">Table 9-2</a> provides short, clarifying examples that you can use for future reference.</p>&#13;
<p class="tabcap"><a id="ch09tab02"><strong>Table 9-2:</strong> Clarifying Examples of Lambda Capture Lists</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Capture list</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Meaning</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>[&amp;]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Default capture by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[&amp;,i]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default capture by reference; capture <code>i</code> by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>[=]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Default capture by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[=,&amp;i]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default capture by value; capture <code>i</code> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>[i]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Capture <code>i</code> by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[&amp;i]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Capture <code>i</code> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>[i,&amp;j]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Capture <code>i</code> by value; capture <code>j</code> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[i=j,&amp;k]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Capture <code>j</code> by value as <code>i</code>; capture <code>k</code> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>[this]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Capture <code>enclosing object</code> by reference</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>[*this]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Capture <code>enclosing object</code> by value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>[=,*this,i,&amp;j]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Default capture by value; capture <code>this</code> and <code>i</code> by value; capture <code>j</code> by reference</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch09lev2sec14"><strong><em>constexpr Lambda Expressions</em></strong></h4>&#13;
<p class="noindent">All lambda expressions are <code>constexpr</code> as long as the lambda can be invoked at compile time. You can optionally make the <code>constexpr</code> declaration explicit, as in the following:</p>&#13;
<pre>[] (int x) constexpr { return x * x; }</pre>&#13;
<p class="indent">You should mark a lambda <code>constexpr</code> if you want to make sure that it meets all <code>constexpr</code> requirements. As of C++17, this means no dynamic memory allocations and no calling non-<code>constexpr</code> functions, among other restrictions. The standards committee plans to loosen these restrictions with each release, so if you write a lot of code using <code>constexpr</code>, be sure to brush up on the latest <code>constexpr</code> constraints.</p>&#13;
<h3 class="h3" id="ch09lev1sec11"><span epub:type="pagebreak" id="page_269"/><strong>std::function</strong></h3>&#13;
<p class="noindent">Sometimes you just want a uniform container for storing callable objects. The <code>std::function</code> class template from the <code>&lt;functional&gt;</code> header is a polymorphic wrapper around a callable object. In other words, it’s a generic function pointer. You can store a static function, a function object, or a lambda into a <code>std::function</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <code><em>function</em></code> class is in the stdlib. We’re presenting it a little ahead of schedule because it fits naturally.</em></p>&#13;
</div>&#13;
<p class="indent">With <code>functions</code>, you can:</p>&#13;
<ul>&#13;
<li class="noindent">Invoke without the caller knowing the function’s implementation</li>&#13;
<li class="noindent">Assign, move, and copy</li>&#13;
<li class="noindent">Have an empty state, similar to a <code>nullptr</code></li>&#13;
</ul>&#13;
<h4 class="h4" id="ch09lev2sec15"><strong><em>Declaring a Function</em></strong></h4>&#13;
<p class="noindent">To declare a <code>function</code>, you must provide a single template parameter containing the function prototype of the callable object:</p>&#13;
<pre>std::function&lt;return-type(arg-type-1, arg-type-2, etc.)&gt;</pre>&#13;
<p class="indent">The <code>std::function</code> class template has a number of constructors. The default constructor constructs a <code>std::function</code> in empty mode, meaning it contains no callable object.</p>&#13;
<h5 class="h5" id="ch09lev3sec7"><strong>Empty Functions</strong></h5>&#13;
<p class="noindent">If you invoke a <code>std::function</code> with no contained object, <code>std::function</code> will throw a <code>std::bad_function_call</code> exception. Consider <a href="ch09.xhtml#ch09ex25">Listing 9-25</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
int main() {&#13;
    std::function&lt;void()&gt; func; <span class="ent">➊</span>&#13;
    try {&#13;
        func(); <span class="ent">➋</span>&#13;
    } catch(const std::bad_function_call&amp; e) {&#13;
        printf("Exception: %s", e.what()); <span class="ent">➌</span>&#13;
    }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Exception: bad function call <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch09ex25"/><em>Listing 9-25: The default <code>std::function</code> constructor and the <code>std::bad_function_call</code> exception</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_270"/>You default-construct a <code>std::function</code> <span class="ent">➊</span>. The template parameter <code>void()</code> denotes a function taking no arguments and returning <code>void</code>. Because you didn’t fill <code>func</code> with a callable object, it’s in an empty state. When you invoke <code>func</code> <span class="ent">➋</span>, it throws a <code>std::bad_function_call</code>, which you catch and print <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch09lev3sec8"><strong>Assigning a Callable Object to a Function</strong></h5>&#13;
<p class="noindent">To assign a callable object to a <code>function</code>, you can either use the constructor or assignment operator of <code>function</code>, as in <a href="ch09.xhtml#ch09ex26">Listing 9-26</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
void static_func() { <span class="ent">➊</span>&#13;
  printf("A static function.\n");&#13;
}&#13;
&#13;
int main() {&#13;
  std::function&lt;void()&gt; func { [] { printf("A lambda.\n"); } }; <span class="ent">➋</span>&#13;
  func(); <span class="ent">➌</span>&#13;
  func = static_func; <span class="ent">➍</span>&#13;
  func(); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">A lambda. <span class="ent">➌</span></span>&#13;
<span class="color1">A static function. <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch09ex26"/><em>Listing 9-26: Using the constructor and assignment operator of <code>function</code></em></p>&#13;
<p class="indent">You declare the static function <code>static_func</code> that takes no arguments and returns <code>void</code> <span class="ent">➊</span>. In <code>main</code>, you create a function called <code>func</code> <span class="ent">➋</span>. The template parameter indicates that a callable object contained by <code>func</code> takes no arguments and returns <code>void</code>. You initialize <code>func</code> with a lambda that prints the message <code>A lambda</code>. You invoke <code>func</code> immediately afterward <span class="ent">➌</span>, invoking the contained lambda and printing the expected message. Next, you assign <code>static_func</code> to <code>func</code>, which replaces the lambda you assigned upon construction <span class="ent">➍</span>. You then invoke <code>func</code>, which invokes <code>static_func</code> rather than the lambda, so you see <code>A static function.</code> printed <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch09lev2sec16"><strong><em>An Extended Example</em></strong></h4>&#13;
<p class="noindent">You can construct a <code>function</code> with callable objects, as long as that object supports the function semantics implied by the template parameter of <code>function</code>.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex27">Listing 9-27</a> uses an array of <code>std::function</code> instances and fills it with a static function that counts spaces, a <code>CountIf</code> function object from <a href="ch09.xhtml#ch09ex12">Listing 9-12</a>, and a lambda that computes string length.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
struct CountIf {&#13;
<span epub:type="pagebreak" id="page_271"/>  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
size_t count_spaces(const char* str) {&#13;
  size_t index{}, result{};&#13;
  while (str[index]) {&#13;
    if (str[index] == ' ') result++;&#13;
    index++;&#13;
  }&#13;
  return result;&#13;
}&#13;
&#13;
std::function<span class="ent">➊</span>&lt;size_t(const char*)<span class="ent">➋</span>&gt; funcs[]{&#13;
  count_spaces, <span class="ent">➌</span>&#13;
  CountIf{ 'e' }, <span class="ent">➍</span>&#13;
  [](const char* str) { <span class="ent">➎</span>&#13;
    size_t index{};&#13;
    while (str[index]) index++;&#13;
    return index;&#13;
  }&#13;
};&#13;
&#13;
auto text = "Sailor went to sea to see what he could see.";&#13;
&#13;
int main() {&#13;
  size_t index{};&#13;
  for(const auto&amp; func : funcs<span class="ent">➏</span>) {&#13;
    printf("func #%zu: %zu\n", index++, func(text)<span class="ent">➐</span>);&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">func #0: 9 <span class="ent">➌</span></span>&#13;
<span class="color1">func #1: 7 <span class="ent">➍</span></span>&#13;
<span class="color1">func #2: 44 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch09ex27"/><em>Listing 9-27: Using a <code>std::function</code> array to iterate over a uniform collection of callable objects with varying underlying types</em></p>&#13;
<p class="indent">You declare a <code>std::function</code> array <span class="ent">➊</span> with static storage duration called <code>funcs</code>. The template argument is the function prototype for a function taking a <code>const char*</code> and returning a <code>size_t</code> <span class="ent">➋</span>. In the <code>funcs</code> array, you pass in a static function pointer <span class="ent">➌</span>, a function object <span class="ent">➍</span>, and a lambda <span class="ent">➎</span>. In <code>main</code>, you use a range-based <code>for</code> loop to iterate through each function in <code>funcs</code> <span class="ent">➏</span>. You invoke each function <code>func</code> with the text <code>Sailor went to sea to see what he could see.</code> and print the result.</p>&#13;
<p class="indent">Notice that, from the perspective of <code>main</code>, all the elements in <code>funcs</code> are the same: you just invoke them with a null-terminated string and get back a <code>size_t</code> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Using a <code>function</code> can incur runtime overhead. For technical reasons, <code>function</code> might need to make a dynamic allocation to store the callable object. The compiler also has difficulty optimizing away <code>function</code> invocations, so you’ll often incur an indirect function call. Indirect function calls require additional pointer dereferences</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch09lev1sec12"><strong><span epub:type="pagebreak" id="page_272"/>The main Function and the Command Line</strong></h3>&#13;
<p class="noindent">All C++ programs must contain a global function with the name <code>main</code>. This function is defined as the program’s entry point, the function invoked at program startup. Programs can accept any number of environment-provided arguments called <em>command line parameters</em> upon startup.</p>&#13;
<p class="indent">Users pass command line parameters to programs to customize their behavior. You’ve probably used this feature when executing command line programs, as in the <code>copy</code> (on Linux: <code>cp</code>) command:</p>&#13;
<pre>$ copy file_a.txt file_b.txt</pre>&#13;
<p class="indent">When invoking this command, you instruct the program to copy <code>file_a.txt</code> into <code>file_b.txt</code> by passing these values as command line parameters. As with command line programs you might be used to, it’s possible to pass values as command line parameters to your C++ programs.</p>&#13;
<p class="indent">You can choose whether your program handles command line parameters by how you declare <code>main</code>.</p>&#13;
<h4 class="h4" id="ch09lev2sec17"><strong><em>The Three main Overloads</em></strong></h4>&#13;
<p class="noindent">You can access command line parameters within <code>main</code> by adding arguments to your <code>main</code> declaration.</p>&#13;
<p class="indent">There are three valid varieties of overload for <code>main</code>, as shown in <a href="ch09.xhtml#ch09ex28">Listing 9-28</a>.</p>&#13;
<pre>int main(); <span class="ent">➊</span>&#13;
int main(int argc, char* argv[]); <span class="ent">➋</span>&#13;
int main(int argc, char* argv[], <span class="codeitalic1">impl-parameters</span>); <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch09ex28"/><em>Listing 9-28: The valid overloads for <code>main</code></em></p>&#13;
<p class="indent">The first overload <span class="ent">➊</span> takes no parameters, which is the way you’ve been using <code>main()</code> in this book so far. Use this form if you want to ignore any arguments provided to your program.</p>&#13;
<p class="indent">The second overload <span class="ent">➋</span> accepts two parameters, <code>argc</code> and <code>argv</code>. The first argument, <code>argc</code>, is a non-negative number corresponding to the number of elements in <code>argv</code>. The environment calculates this automatically: you don’t have to provide the number of elements in <code>argc</code>. The second argument, <code>argv</code>, is an array of pointers to null-terminated strings that corresponds to an argument passed in from the execution environment.</p>&#13;
<p class="indent">The third overload <span class="ent">➌</span>: is an extension of the second overload <span class="ent">➋</span>: it accepts an arbitrary number of additional implementation parameters. This way, the target platform can offer some additional arguments to the program. Implementation parameters aren’t common in modern desktop environments.</p>&#13;
<p class="indent">Usually, an operating system passes the full path to the program’s executable as the first command line argument. This behavior depends on your operating environment. On macOS, Linux, and Windows, the <span epub:type="pagebreak" id="page_273"/>executable’s path is the first argument. The format of this path depends on the operating system. (<a href="ch17.xhtml">Chapter 17</a> discusses filesystems in depth.)</p>&#13;
<h4 class="h4" id="ch09lev2sec18"><strong><em>Exploring Program Parameters</em></strong></h4>&#13;
<p class="noindent">Let’s build a program to explore how the operating system passes parameters to your program. <a href="ch09.xhtml#ch09ex29">Listing 9-29</a> prints the number of command line arguments and then prints the index and value of the arguments on each line.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
int main(int argc, char** argv) { <span class="ent">➊</span>&#13;
  printf("Arguments: %d\n", argc); <span class="ent">➋</span>&#13;
  for(size_t i{}; i&lt;argc; i++) {&#13;
    printf("%zu: %s\n", i, argv[i]); <span class="ent">➌</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex29"/><em>Listing 9-29: A program that prints the command line arguments. Compile this program as <code>list_929</code>.</em></p>&#13;
<p class="indent">You declare main with the <code>argc</code>/<code>argv</code> overload, which makes command line parameters available to your program <span class="ent">➊</span>. First, you print the number of command line arguments via <code>argc</code> <span class="ent">➋</span>. Then you loop through each argument, printing its index and its value <span class="ent">➌</span>.</p>&#13;
<p class="indent">Let’s look at some sample output (on Windows 10 x64). Here is one program invocation:</p>&#13;
<pre>$ <span class="codestrong1">list_929</span> <span class="ent">➊</span>&#13;
<span class="color1">Arguments: 1 <span class="ent">➋</span></span>&#13;
<span class="color1">0: list_929.exe <span class="ent">➌</span></span></pre>&#13;
<p class="indent">Here, you provide no additional command line arguments aside from the name of the program, <code>list_929</code> <span class="ent">➊</span>. (Depending on how you compiled the listing, you should replace this with the name of your executable.) On a Windows 10 x64 machine, the result is that your program receives a single argument <span class="ent">➋</span>, the name of the executable <span class="ent">➌</span>.</p>&#13;
<p class="indent">And here is another invocation:</p>&#13;
<pre>$ <span class="codestrong1">list_929 Violence is the last refuge of the incompetent.</span> <span class="ent">➊</span>&#13;
<span class="color1">Arguments: 9</span>&#13;
<span class="color1">0: list_929.exe</span>&#13;
<span class="color1">1: Violence</span>&#13;
<span class="color1">2: is</span>&#13;
<span class="color1">3: the</span>&#13;
<span class="color1">4: last</span>&#13;
<span class="color1">5: refuge</span>&#13;
<span class="color1">6: of</span>&#13;
<span class="color1">7: the</span>&#13;
<span class="color1">8: incompetent.</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_274"/>Here, you provide additional program arguments: <code>Violence is the last refuge of the incompetent.</code> <span class="ent">➊</span>. You can see from the output that Windows has split the command line by spaces, resulting in a total of nine arguments.</p>&#13;
<p class="indent">In major desktop operating systems, you can force the operating system to treat such a phrase as a single argument by enclosing it within quotes, as in the following:</p>&#13;
<pre>$ <span class="codestrong1">list_929 "Violence is the last refuge of the incompetent."</span>&#13;
<span class="color1">Arguments: 2</span>&#13;
<span class="color1">0: list_929.exe</span>&#13;
<span class="color1">1: Violence is the last refuge of the incompetent.</span></pre>&#13;
<h4 class="h4" id="ch09lev2sec19"><strong><em>A More Involved Example</em></strong></h4>&#13;
<p class="noindent">Now that you know how to process command line input, let’s consider a more involved example. A <em>histogram</em> is an illustration that shows a distribution’s relative frequency. Let’s build a program that computes a histogram of the letter distribution of the command line arguments.</p>&#13;
<p class="indent">Start with two helper functions that determine whether a given <code>char</code> is an uppercase letter or a lowercase letter:</p>&#13;
<pre>constexpr char pos_A{ 65 }, pos_Z{ 90 }, pos_a{ 97 }, pos_z{ 122 };&#13;
constexpr bool within_AZ(char x) { return pos_A &lt;= x &amp;&amp; pos_Z &gt;= x; } <span class="ent">➊</span>&#13;
constexpr bool within_az(char x) { return pos_a &lt;= x &amp;&amp; pos_z &gt;= x; } <span class="ent">➋</span></pre>&#13;
<p class="indent">The <code>pos_A, pos_Z, pos_a</code>, and <code>pos_z</code> constants contain the ASCII values of the letters A, Z, a, and z respectively (refer to the ASCII chart in <a href="ch02.xhtml#ch02tab04">Table 2-4</a>). The <code>within_AZ</code> function determines whether some <code>char x</code> is an uppercase letter by determining whether its value is between <code>pos_A</code> and <code>pos_Z</code> inclusive <span class="ent">➊</span>. The <code>within_az</code> function does the same for lowercase letters <span class="ent">➋</span>.</p>&#13;
<p class="indent">Now that you have some elements for processing ASCII data from the command line, let’s build an <code>AlphaHistogram</code> class that can ingest command line elements and store character frequencies, as shown in <a href="ch09.xhtml#ch09ex30">Listing 9-30</a>.</p>&#13;
<pre>struct AlphaHistogram {&#13;
  void ingest(const char* x); <span class="ent">➊</span>&#13;
  void print() const; <span class="ent">➋</span>&#13;
private:&#13;
  size_t counts[26]{}; <span class="ent">➌</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch09ex30"/><em>Listing 9-30: An <code>AlphaHistogram</code> that ingests command line elements</em></p>&#13;
<p class="indent">An <code>AlphaHistogram</code> will store the frequency of each letter in the <code>counts</code> array <span class="ent">➌</span>. This array initializes to zero whenever an <code>AlphaHistogram</code> is constructed. The <code>ingest</code> method will take a null-terminated string and update <code>counts</code> appropriately <span class="ent">➊</span>. Then the <code>print</code> method will display the histogram information stored in <code>counts</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_275"/>First, consider the implementation of <code>ingest</code> in <a href="ch09.xhtml#ch09ex31">Listing 9-31</a>.</p>&#13;
<pre>void AlphaHistogram::ingest(const char* x) {&#13;
  size_t index{}; <span class="ent">➊</span>&#13;
  while(const auto c = x[index]) { <span class="ent">➋</span>&#13;
    if (within_AZ(c)) counts[c - pos_A]++; <span class="ent">➌</span>&#13;
    else if (within_az(c)) counts[c - pos_a]++; <span class="ent">➍</span>&#13;
    index++; <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex31"/><em>Listing 9-31: An implementation of the <code>ingest</code> method</em></p>&#13;
<p class="indent">Because <code>x</code> is a null-terminated string, you don’t know its length ahead of time. So, you initialize an <code>index</code> variable <span class="ent">➊</span> and use a <code>while</code> loop to extract a single <code>char c</code> at a time <span class="ent">➋</span>. This loop will terminate if <code>c</code> is null, which is the end of the string. Within the loop, you use the <code>within_AZ</code> helper function to determine whether <code>c</code> is an uppercase letter <span class="ent">➌</span>. If it is, you subtract <code>pos_A</code> from <code>c</code>. This normalizes an uppercase letter to the interval 0 to 25 to correspond with <code>counts</code>. You do the same check for lowercase letters using the <code>within_az</code> helper function <span class="ent">➍</span>, and you update <code>counts</code> in case <code>c</code> is lowercase. If <code>c</code> is neither lowercase nor uppercase, <code>counts</code> is unaffected. Finally, you increment <code>index</code> before continuing to loop <span class="ent">➎</span>.</p>&#13;
<p class="indent">Now, consider how to <code>print</code> <code>counts</code>, as shown in <a href="ch09.xhtml#ch09ex32">Listing 9-32</a>.</p>&#13;
<pre>void AlphaHistogram::print() const {&#13;
  for(auto index{ pos_A }; index &lt;= pos_Z; index++) { <span class="ent">➊</span>&#13;
    printf("%c: ", index); <span class="ent">➋</span>&#13;
    auto n_asterisks = counts[index - pos_A]; <span class="ent">➌</span>&#13;
    while (n_asterisks--) printf("*"); <span class="ent">➍</span>&#13;
    printf("\n"); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch09ex32"/><em>Listing 9-32: An implementation of the <code>print</code> method</em></p>&#13;
<p class="indent">To print the histogram, you loop over each letter from A to Z <span class="ent">➊</span>. Within the loop, you first print the <code>index</code> letter <span class="ent">➋</span>, and then determine how many asterisks to print by extracting the correct letter out of <code>counts</code> <span class="ent">➌</span>. You print the correct number of asterisks using a <code>while</code> loop <span class="ent">➍</span>, and then you print a terminating newline <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09ex33">Listing 9-33</a> shows <code>AlphaHistogram</code> in action.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
constexpr char pos_A{ 65 }, pos_Z{ 90 }, pos_a{ 97 }, pos_z{ 122 };&#13;
constexpr bool within_AZ(char x) { return pos_A &lt;= x &amp;&amp; pos_Z &gt;= x; }&#13;
constexpr bool within_az(char x) { return pos_a &lt;= x &amp;&amp; pos_z &gt;= x; }&#13;
&#13;
struct AlphaHistogram {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
<span epub:type="pagebreak" id="page_276"/>};&#13;
&#13;
int main(int argc, char** argv) {&#13;
  AlphaHistogram hist;&#13;
  for(size_t i{ 1 }; i&lt;argc; i++) { <span class="ent">➊</span>&#13;
    hist.ingest(argv[i]); <span class="ent">➋</span>&#13;
  }&#13;
  hist.print(); <span class="ent">➌</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">$</span> <span class="codestrong1">list_933 The quick brown fox jumps over the lazy dog</span>&#13;
<span class="color1">A: *</span>&#13;
<span class="color1">B: *</span>&#13;
<span class="color1">C: *</span>&#13;
<span class="color1">D: *</span>&#13;
<span class="color1">E: ***</span>&#13;
<span class="color1">F: *</span>&#13;
<span class="color1">G: *</span>&#13;
<span class="color1">H: **</span>&#13;
<span class="color1">I: *</span>&#13;
<span class="color1">J: *</span>&#13;
<span class="color1">K: *</span>&#13;
<span class="color1">L: *</span>&#13;
<span class="color1">M: *</span>&#13;
<span class="color1">N: *</span>&#13;
<span class="color1">O: ****</span>&#13;
<span class="color1">P: *</span>&#13;
<span class="color1">Q: *</span>&#13;
<span class="color1">R: **</span>&#13;
<span class="color1">S: *</span>&#13;
<span class="color1">T: **</span>&#13;
<span class="color1">U: **</span>&#13;
<span class="color1">V: *</span>&#13;
<span class="color1">W: *</span>&#13;
<span class="color1">X: *</span>&#13;
<span class="color1">Y: *</span>&#13;
<span class="color1">Z: *</span></pre>&#13;
<p class="listing"><a id="ch09ex33"/><em>Listing 9-33: A program illustrating <code>AlphaHistogram</code></em></p>&#13;
<p class="indent">You iterate over each command line argument after the program name <span class="ent">➊</span>, passing each into the <code>ingest</code> method of your <code>AlphaHistogram</code> object <span class="ent">➋</span>. Once you’ve ingested them all, you print the <code>histogram</code> <span class="ent">➌</span>. Each line corresponds to a letter, and the asterisks show the absolute frequency of the corresponding letter. As you can see, the phrase <code>The quick brown fox jumps over the lazy dog</code> contains each letter in the English alphabet.</p>&#13;
<h4 class="h4" id="ch09lev2sec20"><strong><em>Exit Status</em></strong></h4>&#13;
<p class="noindent">The <code>main</code> function can return an <code>int</code> corresponding to the exit status of the program. What the values represent is environment defined. On modern desktop systems, for example, a zero return value corresponds with a successful program execution. If no <code>return</code> statement is explicitly given, an implicit <code>return 0</code> is added by the compiler.</p>&#13;
<h3 class="h3" id="ch09lev1sec13"><span epub:type="pagebreak" id="page_277"/><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter took a deeper look at functions, including how to declare and define them, how to use the myriad keywords available to you to modify function behavior, how to specify return types, how overload resolution works, and how to take a variable number of arguments. After a discussion of how you take pointers to functions, you explored lambda expressions and their relationship to function objects. Then you learned about the entry point for your programs, the <code>main</code> function, and how to take command line arguments.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>9-1.</strong> Implement a <code>fold</code> function template with the following prototype:</p>&#13;
<pre>template &lt;typename Fn, typename In, typename Out&gt;&#13;
constexpr Out fold(Fn function, In* input, size_t length, Out initial);</pre>&#13;
<p class="indent">For example, your implementation must support the following usage:</p>&#13;
<pre>int main() {&#13;
  int data[]{ 100, 200, 300, 400, 500 };&#13;
  size_t data_len = 5;&#13;
  auto sum = fold([](auto x, auto y) { return x + y; }, data, data_len,&#13;
0);&#13;
  printf("Sum: %d\n", sum);&#13;
}</pre>&#13;
<p class="indent">The value of <code>sum</code> should be 1,500. Use <code>fold</code> to calculate the following quantities: the <code>maximum</code>, the <code>minimum</code>, and the number of elements greater than 200.</p>&#13;
<p class="noindent"><strong>9-2.</strong> Implement a program that accepts an arbitrary number of command line arguments, counts the length in characters of each argument, and prints a histogram of the argument length distribution.</p>&#13;
<p class="noindent"><strong>9-3.</strong> Implement an <code>all</code> function with the following prototype:</p>&#13;
<pre>template &lt;typename Fn, typename In&gt;&#13;
constexpr bool all(Fn function, In* input, size_t length);</pre>&#13;
<p class="indent">The <code>Fn</code> function type is a <code>predicate</code> that supports <code>bool operator()(In)</code>. Your <code>all</code> function must test whether <code>function</code> returns <code>true</code> for every element of <code>input</code>. If it does, return <code>true</code>. Otherwise, return <code>false</code>.</p>&#13;
<p class="indent">For example, your implementation must support the following usage:</p>&#13;
<pre>int main() {&#13;
  int data[]{ 100, 200, 300, 400, 500 };&#13;
  size_t data_len = 5;&#13;
  auto all_gt100 = all([](auto x) { return x &gt; 100; }, data, data_len);&#13;
  if(all_gt100) printf("All elements greater than 100.\n");&#13;
}</pre>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_278"/><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Functional Programming in C++: How to Improve Your C++ Programs Using Functional Techniques</em> by Ivan Čukić (Manning, 2019)</li>&#13;
<li class="noindent"><em>Clean Code: A Handbook of Agile Software Craftsmanship</em> by Robert C. Martin (Pearson Education, 2009</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>