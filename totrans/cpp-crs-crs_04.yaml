- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: TYPES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**'
- en: '*Hardin once said, “To succeed, planning alone is insufficient. One must improvise
    as well.” I’ll improvise.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈丁曾说过：“成功仅靠计划是不够的，还必须即兴发挥。”我会即兴发挥。'
- en: —Isaac Asimov,* Foundation
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —艾萨克·阿西莫夫，《基地》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: As discussed in [Chapter 1](ch01.xhtml#ch01), a type declares how an object
    will be interpreted and used by the compiler. Every object in a C++ program has
    a type. This chapter begins with a thorough discussion of fundamental types and
    then introduces user-defined types. Along the way, you’ll learn about several
    control flow structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.xhtml#ch01)所述，类型声明了编译器如何解释和使用一个对象。在C++程序中，每个对象都有一个类型。本章首先对基本类型进行详细讨论，然后介绍用户自定义类型。在这个过程中，你将学习到几种控制流结构。
- en: '**Fundamental Types**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本类型**'
- en: '*Fundamental types* are the most basic types of object and include integer,
    floating-point, character, Boolean, `byte`, `size_t`, and `void`. Some refer to
    fundamental types as *primitive* or *built-in* types because they’re part of the
    core language and almost always available to you. These types will work on any
    platform, but their features, such as size and memory layout, depend on implementation.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*基本类型*是最基本的对象类型，包括整数、浮点数、字符、布尔值、`byte`、`size_t`和`void`。有些人称这些基本类型为*原始*类型或*内建*类型，因为它们是核心语言的一部分，几乎总是可以使用。这些类型可以在任何平台上使用，但它们的特性，如大小和内存布局，取决于实现。'
- en: Fundamental types strike a balance. On one hand, they try to map a direct relationship
    from C++ construct to computer hardware; on the other hand, they simplify writing
    cross-platform code by allowing a programmer to write code once that works on
    many platforms. The sections that follow provide additional detail about these
    fundamental types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型在两者之间取得了平衡。一方面，它们尝试映射C++构造与计算机硬件之间的直接关系；另一方面，它们通过允许程序员编写一次代码并在多个平台上运行，从而简化了跨平台编程。接下来的部分将进一步介绍这些基本类型的细节。
- en: '***Integer Types***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***整型类型***'
- en: 'Integer types store whole numbers: those that you can write without a fractional
    component. The four sizes of integer types are *short int*, *int*, *long int*,
    and *long long int*. Each can be either signed or unsigned. A *signed* variable
    can be positive, negative, or zero, and an *unsigned* variable must be non-negative.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 整型类型存储整数：即那些没有小数部分的数字。整型的四种大小是*short int*、*int*、*long int*和*long long int*。每种类型可以是有符号或无符号的。*有符号*变量可以是正数、负数或零，而*无符号*变量必须是非负数。
- en: 'Integer types are signed and `int` by default, which means you can use the
    following shorthand notations in your programs: `short`, `long`, and `long long`
    rather than `short int`, `long int`, and `long long int`. [Table 2-1](ch02.xhtml#ch02tab01)
    lists all available C++ integer types, whether each is signed or unsigned, the
    size of each (in bytes) across platforms, as well as the format specifier for
    each.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 整型类型默认是有符号的`int`，这意味着你可以在程序中使用以下简写：`short`、`long`和`long long`，而不是`short int`、`long
    int`和`long long int`。[表2-1](ch02.xhtml#ch02tab01)列出了所有可用的C++整型类型，指出每种类型是有符号还是无符号，跨平台时每种类型的大小（以字节为单位），以及每种类型的格式说明符。
- en: '**Table 2-1:** Integer Types, Sizes, and Format Specifiers'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 整型类型、大小和格式说明符'
- en: '| **Type** | **Signed** | **Size in bytes** | **printf format specifier** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **有符号** | **字节大小** | **printf格式说明符** |'
- en: '| **32-bit OS** | **64-bit OS** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **32位操作系统** | **64位操作系统** |'
- en: '| **Windows** | **Linux/Mac** | **Windows** | **Linux/Mac** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **Windows** | **Linux/Mac** | **Windows** | **Linux/Mac** |'
- en: '| `Short` | Yes | 2 | 2 | 2 | 2 | `%hd` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | 是 | 2 | 2 | 2 | 2 | `%hd` |'
- en: '| `unsigned short` | No | 2 | 2 | 2 | 2 | `%hu` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short` | 否 | 2 | 2 | 2 | 2 | `%hu` |'
- en: '| `int` | Yes | 4 | 4 | 4 | 4 | `%d` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 是 | 4 | 4 | 4 | 4 | `%d` |'
- en: '| `unsigned int` | No | 4 | 4 | 4 | 4 | `%u` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` | 否 | 4 | 4 | 4 | 4 | `%u` |'
- en: '| `long` | Yes | 4 | 4 | 4 | 8 | `%ld` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 是 | 4 | 4 | 4 | 8 | `%ld` |'
- en: '| `unsigned long` | No | 4 | 4 | 4 | 8 | `%lu` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long` | 否 | 4 | 4 | 4 | 8 | `%lu` |'
- en: '| `long long` | Yes | 8 | 8 | 8 | 8 | `%lld` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | 是 | 8 | 8 | 8 | 8 | `%lld` |'
- en: '| `unsigned long long` | No | 8 | 8 | 8 | 8 | `%llu` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long` | 否 | 8 | 8 | 8 | 8 | `%llu` |'
- en: 'Notice that the integer type sizes vary across platforms: 64-bit Windows and
    Linux/Mac have different sizes for a `long` integer (4 and 8, respectively).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，整型类型的大小在不同平台上有所不同：64位的Windows和Linux/Mac对于`long`整数的大小不同（分别是4和8）。
- en: Usually, a compiler will warn you of a mismatch between format specifier and
    integer type. But you must ensure that the format specifiers are correct when
    you’re using them in `printf` statements. Format specifiers appear here so you
    can print integers to console in examples to follow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会警告格式说明符和整数类型之间的不匹配。但在使用 `printf` 语句时，你必须确保格式说明符是正确的。这里列出格式说明符，以便在后续的示例中可以将整数打印到控制台。
- en: '**Note**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to enforce guaranteed integer sizes, you can use integer types
    in the `<cstdint>` library. For example, if you need a signed integer with exactly
    8, 16, 32, or 64 bits, you could use `int8_t`, `int16_t`, `int32_t`, or `int64_t`.
    You’ll find options for the fastest, smallest, maximum, signed, and unsigned integer
    types to meet your requirements. But because this header is not always available
    in every platform, you should only use `cstdint` types when there is no other
    alternative.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想强制使用保证的整数大小，可以使用 `<cstdint>` 库中的整数类型。例如，如果你需要一个恰好为 8、16、32 或 64 位的有符号整数，你可以使用
    `int8_t`、`int16_t`、`int32_t` 或 `int64_t`。你可以找到符合要求的最快、最小、最大、有符号和无符号整数类型。但由于并非每个平台都可以使用这个头文件，所以你应仅在没有其他替代方案时使用
    `cstdint` 类型。*'
- en: 'A *literal* is a hardcoded value in a program. You can use one of four hardcoded,
    *integer* *literal* representations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量* 是程序中的硬编码值。你可以使用四种硬编码的 *整数* *字面量* 表示法：'
- en: '**`binary`** Uses the prefix `0b`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**`二进制`** 使用前缀 `0b`'
- en: '**`octal`** Uses the prefix `0`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**`八进制`** 使用前缀 `0`'
- en: '**`decimal`** This is the default'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**`十进制`** 这是默认值'
- en: '**`hexadecimal`** Uses the prefix `0x`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**`十六进制`** 使用前缀 `0x`'
- en: These are four different ways of writing the same set of whole numbers. For
    example, [Listing 2-1](ch02.xhtml#ch02ex01) shows how you might assign several
    integer variables with integer literals using each of the non-decimal representations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种不同的表示法都用于表示相同的整数集合。例如，[列表 2-1](ch02.xhtml#ch02ex01)展示了如何使用每种非十进制表示法为多个整数变量赋值，并使用整数字面量。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: A program that assigns several integer variables and prints them
    with the appropriate format specifier*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-1：一个分配多个整数变量并用适当格式说明符打印它们的程序*'
- en: This program uses each of the non-decimal integer representations (binary ➊,
    octal ➋, and hexadecimal ➌) and prints each with `printf` using the appropriate
    format specifier listed in [Table 2-1](ch02.xhtml#ch02tab01). The output from
    each `printf` appears as a following comment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用每种非十进制整数表示法（如二进制 ➊、八进制 ➋ 和十六进制 ➌），并通过 `printf` 打印每个值，使用适当的格式说明符，具体见[表 2-1](ch02.xhtml#ch02tab01)。每个
    `printf` 的输出会作为以下注释出现。
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Integer literals can contain any number of single quotes ('') for readability.
    These are completely ignored by the compiler. For example, `1000000` and `1''000''000`
    are both integer literals equal to one million.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数字面量可以包含任意数量的单引号（''），以提高可读性。这些单引号会被编译器完全忽略。例如，`1000000` 和 `1''000''000` 都是等于一百万的整数字面量。*'
- en: Sometimes, it’s useful to print an unsigned integer in its hexadecimal representation
    or (rarely) its octal representation. You can use the `printf` specifiers `%x`
    and `%o` for these purposes, respectively, as shown in [Listing 2-2](ch02.xhtml#ch02ex02).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，打印无符号整数的十六进制表示法或（很少）八进制表示法是有用的。你可以分别使用 `printf` 格式说明符 `%x` 和 `%o`，如[列表 2-2](ch02.xhtml#ch02ex02)所示。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-2: A program that uses octal and hexadecimal representations of
    unsigned integers*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：一个使用无符号整数的八进制和十六进制表示法的程序*'
- en: The hexadecimal representation of the decimal `3669732608` is `dabbad00`, which
    appears in the first line of output as a result of the hexadecimal format specifier
    `%x` ➊. The decimal 69 is 105 in octal. The format specifiers for unsigned integer
    `%u` ➋ and octal integer `%o` ➌ correspond with the arguments at ➍ and ➎, respectively.
    The `printf` statement substitutes these quantities ➋➌ into the format string,
    yielding the message `There are 69,105 leaves in here`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制 `3669732608` 的十六进制表示为 `dabbad00`，它出现在输出的第一行，作为十六进制格式说明符 `%x` ➊ 的结果。十进制的
    69 在八进制中是 105。无符号整数格式说明符 `%u` ➋ 和八进制整数格式说明符 `%o` ➌ 分别对应于 ➍ 和 ➎ 的参数。`printf` 语句将这些数值
    ➋➌ 替换到格式字符串中，输出信息为 `这里有 69,105 片叶子`。
- en: '**Warning**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The octal prefix is a holdover from the B language, back in the days of the
    PDP-8 computer and ubiquitous octal literals. C, and by extension C++, continues
    the dubious tradition. You must be careful, for example, when you’re hardcoding
    ZIP codes:*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*八进制前缀源自B语言，当时PDP-8计算机和八进制字面量非常普遍。C语言及其扩展C++延续了这个可疑的传统。你必须小心，例如在硬编码邮政编码时：*'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Eliminate leading zeros on decimal literals; otherwise, they’ll cease to be
    decimal. This line doesn’t compile because 9 is not an octal digit.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*去掉十进制字面量中的前导零，否则它们将不再是十进制数。这行代码无法编译，因为 9 不是八进制数字。*'
- en: 'By default, an integer literal’s type is one of the following: `int`, `long`,
    or `long long`. An integer literal’s type is the smallest of these three types
    that fits. (This is defined by the language and will be enforced by the compiler.)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，整数字面量的类型是以下之一：`int`、`long` 或 `long long`。整数字面量的类型是这三种类型中最小的那一个。（这是由语言定义的，并会由编译器强制执行。）
- en: 'If you want more control, you can supply *suffixes* to an integer literal to
    specify its type (suffixes are case insensitive, so you can choose the style you
    like best):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更多控制，可以为整数字面量提供*后缀*来指定其类型（后缀不区分大小写，因此你可以选择自己喜欢的样式）：
- en: The `unsigned` suffix `u` or `U`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned` 后缀 `u` 或 `U`'
- en: The `long` suffix `l` or `L`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 后缀 `l` 或 `L`'
- en: The `long long` suffix `ll` or `LL`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long long` 后缀 `ll` 或 `LL`'
- en: You can combine the `unsigned` suffix with either the `long` or the `long long`
    suffix to specify signed-ness and size. [Table 2-2](ch02.xhtml#ch02tab02) shows
    the possible types that a suffix combination can take. Allowed types are shown
    with a check mark (✓). For binary, octal, and hexadecimal literals, you can omit
    the `u` or `U` suffix. These are depicted with an asterisk (*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `unsigned` 后缀与 `long` 或 `long long` 后缀结合使用，以指定符号性和大小。[表 2-2](ch02.xhtml#ch02tab02)
    显示了后缀组合可能的类型。允许的类型用勾号（✓）表示。对于二进制、八进制和十六进制字面量，你可以省略 `u` 或 `U` 后缀。这些用星号（*）表示。
- en: '**Table 2-2:** Integer Suffixes'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-2：** 整数后缀'
- en: '| **Type** | **(none)** | **l/L** | **ll/LL** | **u/U** | **ul/UL** | **ull/ULL**
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **(无)** | **l/L** | **ll/LL** | **u/U** | **ul/UL** | **ull/ULL**
    |'
- en: '| `int` | ✓ |  |  |  |  |  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `int` | ✓ |  |  |  |  |  |'
- en: '| `long` | ✓ | ✓ |  |  |  |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `long` | ✓ | ✓ |  |  |  |  |'
- en: '| `long long` | ✓ | ✓ | ✓ |  |  |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | ✓ | ✓ | ✓ |  |  |  |'
- en: '| `unsigned int` | * |  |  | ✓ |  |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` | * |  |  | ✓ |  |  |'
- en: '| `unsigned long` | * | * |  | ✓ | ✓ |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long` | * | * |  | ✓ | ✓ |  |'
- en: '| `unsigned long long` | * | * | * | ✓ | ✓ | ✓ |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long` | * | * | * | ✓ | ✓ | ✓ |'
- en: The smallest allowed type that still fits the integer literal is the resulting
    type. This means that among all types allowed for a particular integer, the smallest
    type will apply. For example, the integer literal `112114` could be an `int`,
    a `long`, or a `long long`. Since an `int` can store 112114, the resulting integer
    literal is an `int`. If you really want, say, a `long`, you can instead specify
    `112114L` (or `112114l`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最小允许的类型仍然适应整数字面量的类型即为结果类型。这意味着，在所有允许的类型中，最小的类型将适用。例如，整数字面量 `112114` 可以是 `int`、`long`
    或 `long long`。由于 `int` 可以存储 112114，因此结果类型是 `int`。如果你真的希望使用 `long`，你可以指定 `112114L`（或
    `112114l`）。
- en: '***Floating-Point Types***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***浮点类型***'
- en: Floating-point types store approximations of real numbers (which in our case
    can be defined as any number that has a decimal point and a fractional part, such
    as 0.33333 or 98.6). Although it’s not possible to represent an arbitrary real
    number exactly in computer memory, it’s possible to store an approximation. If
    this seems hard to believe, just think of a number like π, which has infinitely
    many digits. With finite computer memory, how could you possibly represent infinitely
    many digits?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型存储的是实数的近似值（在我们的定义中，实数可以是任何有小数点和分数部分的数字，例如 0.33333 或 98.6）。虽然无法在计算机内存中精确表示任意实数，但可以存储一个近似值。如果这让你难以相信，只需想一想像
    π 这样的数字，它有无限多的位数。考虑到计算机内存是有限的，你怎么可能表示无限多的位数呢？
- en: 'As with all types, floating-point types take up a finite amount of memory,
    which is called the type’s *precision*. The more precision a floating-point type
    has, the more accurate it will be at approximating a real number. C++ offers three
    levels of precision for approximations:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有类型一样，浮点类型占用有限的内存，这被称为类型的*精度*。浮点类型的精度越高，近似实数时就越准确。C++ 提供了三种精度级别的近似：
- en: '`**float**` single precision'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`**float**` 单精度'
- en: '`**double**` double precision'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`**double**` 双精度'
- en: '`**long double**` extended precision'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`**long double**` 扩展精度'
- en: As with integer types, each floating-point representation depends on implementation.
    This section won’t go into detail about floating-point types, but note that there
    is substantial nuance involved in these implementations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数类型一样，每种浮点数表示方式都依赖于实现。此部分不会详细讨论浮点类型，但请注意，这些实现中有许多细微差别。
- en: On major desktop operating systems, the `float` level usually has 4 bytes of
    precision. The `double` and `long double` levels usually have 8 bytes of precision
    (*double precision*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要的桌面操作系统中，`float`类型通常有4字节的精度。`double`和`long double`类型通常有8字节的精度（*双精度*）。
- en: Most users not involved in scientific computing applications can safely ignore
    the details of floating-point representation. In such cases, a good general rule
    is to use a `double`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不涉及科学计算应用的用户可以放心忽略浮点表示的细节。在这种情况下，一个好的通用规则是使用`double`。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For those who cannot safely ignore the details, look at the floating-point
    specification relevant to your hardware platform. The predominant implementation
    of floating-point storage and arithmetic is outlined in* The IEEE Standard for
    Floating-Point Arithmetic, IEEE 754.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于那些无法忽略细节的用户，请查看与你的硬件平台相关的浮点规格。浮点存储和算术的主要实现概述在* IEEE 浮点运算标准 IEEE 754中。'
- en: '**Floating-Point Literals**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮点字面量**'
- en: 'Floating-point literals are double precision by default. If you need single
    precision, use an `f` or `F` suffix; for extended precision, use `l` or `L`, as
    shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点字面量默认是双精度。如果需要单精度，使用`f`或`F`后缀；要使用扩展精度，使用`l`或`L`后缀，如下所示：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use scientific notation in literals:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在字面量中使用科学计数法：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: No spaces are permitted between the *significand* (the base ➊) and the *suffix*
    (the exponential portion ➋).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许在*有效数字*（基数➊）和*后缀*（指数部分➋）之间有空格。
- en: '**Floating-Point Format Specifiers**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮点格式说明符**'
- en: The format specifier `%f` displays a `float` with decimal digits, whereas `%e`
    displays the same number in scientific notation. You can let `printf` decide which
    of these two to use with the `%g` format specifier, which selects the more compact
    of `%e` or `%f`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符`%f`显示带有小数位的`float`，而`%e`则以科学计数法显示相同的数字。你可以让`printf`决定使用这两者中的哪一个，使用`%g`格式说明符，它选择`%e`或`%f`中更紧凑的一个。
- en: For `double`, you simply prepend an `l` (lowercase *L*) to the desired specifier;
    for `long double`, prepend an `L`. For example, if you wanted a `double` with
    decimal digits, you would specify `%lf`, `%le`, or `%lg`; for a long double, you
    would specify `%Lf`, `%Le`, or `%Lg`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`double`，只需在所需的说明符前添加`l`（小写*L*）；对于`long double`，则添加`L`。例如，如果你想要一个带有小数位的`double`，你可以指定`%lf`、`%le`或`%lg`；对于`long
    double`，则指定`%Lf`、`%Le`或`%Lg`。
- en: Consider [Listing 2-3](ch02.xhtml#ch02ex03), which explores the different options
    for printing floating points.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[列出 2-3](ch02.xhtml#ch02ex03)，该示例探讨了打印浮点数的不同选项。
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-3: A program printing several floating points*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 2-3：一个打印多个浮点数的程序*'
- en: This program declares a `double` called `an` ➊. The format specifier `%le` ➋
    gives you scientific notation `6.022141e-23`, and `%lf` ➌ gives the decimal representation
    `602214090000000006225920.000000`. The `%lg` ➍ specifier chose the scientific
    notation `6.02214e-23`. The `float` called `hp` ➎ produces similar `printf` output
    using the `%e` and `%f` specifiers. But the format specifier `%g` decided to provide
    the decimal representation 9.75 rather than scientific notation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序声明了一个名为`an`的`double` ➊。格式说明符`%le` ➋ 给出科学计数法`6.022141e-23`，而`%lf` ➌ 给出了十进制表示`602214090000000006225920.000000`。`%lg`
    ➍ 说明符选择了科学计数法`6.02214e-23`。名为`hp`的`float` ➎ 使用`%e`和`%f`说明符产生类似的`printf`输出。但格式说明符`%g`决定提供十进制表示9.75，而不是科学计数法。
- en: As a general rule, use `%g` to print floating-point types.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用`%g`来打印浮点类型。
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, you can omit the `l` prefix on the format specifiers for `double`,
    because `printf` promotes `float` arguments to `double` precision.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，你可以省略`double`格式说明符前的`l`前缀，因为`printf`会将`float`类型的参数提升为`double`精度。*'
- en: '***Character Types***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符类型***'
- en: 'Character types store human language data. The six character types are:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类型用于存储人类语言数据。六种字符类型包括：
- en: '`**char**` The default type, always 1 byte. May or may not be signed. (Example:
    ASCII.)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`**char**` 默认类型，始终为1字节。可能是有符号也可能是无符号。（示例：ASCII。）'
- en: '`**char16_t**` Used for 2-byte character sets. (Example: UTF-16.)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`**char16_t**` 用于2字节字符集。（示例：UTF-16。）'
- en: '`**char32_t**` Used for 4-byte character sets. (Example: UTF-32.)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`**char32_t**` 用于4字节字符集。（示例：UTF-32。）'
- en: '`**signed char**` Same as `char` but guaranteed to be signed.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`**signed char**` 与`char`相同，但保证为有符号。'
- en: '`**unsigned char**` Same as `char` but guaranteed to be unsigned.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`**unsigned char**` 与`char`相同，但保证为无符号。'
- en: '`**wchar_t**` Large enough to contain the largest character of the implementation’s
    locale. (Example: Unicode.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`**wchar_t**` 大到足以容纳实现区域中最大字符。（示例：Unicode。）'
- en: The character types `char`, `signed char`, and `unsigned char` are called *narrow
    characters*, whereas `char16_t`, `char32_t`, and `wchar_t` are called *wide characters*
    due to their relative storage requirements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**Character Literals**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *character literal* is a single, constant character. Single quotation marks
    (`'' ''`) surround all characters. If the character is any type but `char`, you
    must also provide a prefix: `L` for `wchar_t`, `u` for `char16_t`, and `U` for
    `char32_t`. For example, `''J''` declares a `char` literal and `L''J''` declares
    a `wchar_t`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Escape Sequences**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some characters don’t display on the screen. Instead, they force the display
    to do things like move the cursor to the left side of the screen (carriage return)
    or move the cursor down one line (newline). Other characters can display onscreen,
    but they’re part of the C++ language syntax, such as single or double quotes,
    so you must use them very carefully. To put these characters into a `char`, you
    use the *escape sequences*, as listed in [Table 2-3](ch02.xhtml#ch02tab03).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Reserved Characters and Their Escape Sequences'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Escape sequence** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| Newline | `\n` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| Tab (horizontal) | `\t` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| Tab (vertical) | `\v` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| Backspace | `\b` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| Carriage return | `\r` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| Form feed | `\f` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| Alert | `\a` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| Backslash | `\\` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| Question mark | `?` or `\?` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| Single quote | `\''` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| Double quote | `\"` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| The null character | `\0` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '**Unicode Escape Characters**'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can specify Unicode character literals using the *universal character names*,
    and you can form a universal character name in one of two ways: the prefix `\u`
    followed by a 4-digit Unicode code point or the prefix `\U` followed by an 8-digit
    Unicode code point. For example, you can represent the `A` character as `''\u0041''`
    and represent the beer mug character ![Image](../images/fig38_1.jpg) as `U''\U0001F37A''`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**Format Specifiers**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `printf` format specifier for `char` is `%c`. The `wchar_t` format specifier
    is `%lc`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-4](ch02.xhtml#ch02ex04) initializes two character literals, `x`
    and `y`. You use these variables to build a `printf` call.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-4: A program that assigns several character-typed variables and
    prints them*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: This program outputs *Windows binaries start with MZ*. Even though the *M* is
    a narrow character `char` and the *Z* is a wide character, `printf` works because
    the program uses the correct format specifiers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '*The first two bytes of all Windows binaries are the characters M and Z, an
    homage to Mark Zbikowski, the designer of the MS-DOS executable binary file format*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '***Boolean Types***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Boolean types have two states: true and false. The sole Boolean type is `bool`.
    Integer types and the `bool` types convert readily: the `true` state converts
    to 1, and `false` converts to 0\. Any non-zero integer converts to true, and 0
    converts to `false`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Literals**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To initialize Boolean types, you use two Boolean literals, `true` and `false`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**Format Specifiers**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**格式说明符**'
- en: There is no format specifier for `bool`, but you can use the `int` format specifier
    `%d` within `printf` to yield a `1` for true and a `0` for false. The reason is
    that `printf` promotes any integral value smaller than an `int` to an `int`. [Listing
    2-5](ch02.xhtml#ch02ex05) illustrates how to declare a Boolean variable and inspect
    its value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool` 类型没有格式说明符，但你可以在 `printf` 中使用 `int` 格式说明符 `%d` 来输出 `true` 为 `1`，`false`
    为 `0`。原因是 `printf` 会将任何小于 `int` 的整型值提升为 `int`。[列表 2-5](ch02.xhtml#ch02ex05)展示了如何声明一个布尔变量并检查其值。'
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-5: Printing `bool` variables with a `printf` statement*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-5：使用 `printf` 语句打印 `bool` 变量*'
- en: You initialize `b1` to `true` ➊ and `b2` to `false` ➋. By printing `b1` and
    `b2` as integers (using `%d` format specifiers), you get 1 for `b1` and 0 for
    `b2` ➌.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 `b1` 初始化为 `true` ➊，将 `b2` 初始化为 `false` ➋。通过将 `b1` 和 `b2` 作为整数打印（使用 `%d` 格式说明符），你会得到
    `b1` 为 1，`b2` 为 0 ➌。
- en: '**Comparison Operators**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**比较运算符**'
- en: '*Operators* are functions that perform computations on *operands*. Operands
    are simply objects. (“Logical Operators” on [page 182](ch07.xhtml#page_182) covers
    a full menu of operators.) In order to have meaningful examples using `bool` types,
    you’ll take a quick look at comparison operators in this section and logical operators
    in the next.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*运算符* 是对 *操作数* 执行计算的函数。操作数只是对象。（关于运算符的详细内容请参考 [第 182 页](ch07.xhtml#page_182)的“逻辑运算符”部分。）为了能够使用
    `bool` 类型给出有意义的示例，你将在本节快速了解比较运算符，在下一节了解逻辑运算符。'
- en: You can use several operators to build Boolean expressions. Recall that comparison
    operators take two arguments and return a `bool`. The available operators are
    equality (`==`), inequality (`!=`), greater than (`>`), less than (`<`), greater
    than or equal to (`>=`), and less than or equal to (`<=`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多个运算符来构建布尔表达式。回忆一下，比较运算符接受两个参数并返回一个 `bool`。可用的运算符有相等（`==`）、不等（`!=`）、大于（`>`）、小于（`<`）、大于或等于（`>=`）以及小于或等于（`<=`）。
- en: '[Listing 2-6](ch02.xhtml#ch02ex06) shows how you can use these operators to
    produce Booleans.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-6](ch02.xhtml#ch02ex06)展示了如何使用这些运算符来产生布尔值。'
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 2-6: Using comparison operators*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-6：使用比较运算符*'
- en: Each comparison produces a Boolean result ➋, and the `printf` statement prints
    the Boolean as an `int` ➊.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个比较产生一个布尔结果 ➋，并且 `printf` 语句将布尔值打印为 `int` ➊。
- en: '**Logical Operators**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逻辑运算符**'
- en: '*Logical operators* evaluate Boolean logic on `bool` types. You characterize
    operators by how many operands they take. A *unary operator* takes a single operand,
    a *binary operator* takes two, a *ternary operator* takes three, and so on. You
    categorize operators further by describing the types of their operands.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑运算符* 对 `bool` 类型的布尔逻辑进行求值。你可以通过它们需要的操作数个数来分类运算符。*一元运算符* 需要一个操作数，*二元运算符*
    需要两个，*三元运算符* 需要三个，以此类推。你还可以通过描述它们操作数的类型进一步对运算符进行分类。'
- en: The unary *negation* operator (`!`) takes a single operand and returns its opposite.
    In other words, `!true` yields `false`, and `!false` yields `true`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一元 *取反* 运算符（`!`）接受一个操作数并返回其相反值。换句话说，`!true` 得到 `false`，而 `!false` 得到 `true`。
- en: The logical operators AND (`&&`) and OR (`||`) are binary. Logical AND returns
    `true` only if both of its operands are `true`. Logical OR returns `true` if either
    or both of its operands are `true`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符与（`&&`）和或（`||`）是二元运算符。逻辑与仅在两个操作数都为 `true` 时返回 `true`。逻辑或只要任一操作数为 `true`
    就返回 `true`。
- en: '**NOTE**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you’re reading a Boolean expression, the `!` is pronounced “not,” as
    in “a and not b” for the expression `a && !b`*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你读取布尔表达式时，`!` 读作“非”，例如“a 且 非 b”表示表达式 `a && !b`*。'
- en: Logical operators might seem confusing at first, but they quickly become intuitive.
    [Listing 2-7](ch02.xhtml#ch02ex07) showcases the logical operators.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符刚开始可能看起来让人困惑，但它们很快就变得直观。[列表 2-7](ch02.xhtml#ch02ex07)展示了逻辑运算符的用法。
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-7: A program that illustrates the use of logical operators*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：展示使用逻辑运算符的程序*'
- en: Here, you see the negation operator ➊, the logical AND operator ➋➌, and the
    logical OR operator ➍➎.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到取反运算符 ➊、逻辑与运算符 ➋➌ 和逻辑或运算符 ➍➎。
- en: '***The std::byte Type***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::byte 类型***'
- en: System programmers sometimes work directly with *raw memory*, which is a collection
    of bits without a type. Employ the `std::byte` type, available in the `<cstddef>`
    header, in such situations. The `std::byte` type permits bitwise logical operations
    (which you’ll meet in [Chapter 7](ch07.xhtml#ch07)) and little else. Using this
    type for raw data rather than an integral type can help to avoid common sources
    of difficult-to-debug programming errors.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 系统程序员有时需要直接处理*原始内存*，它是没有类型的位的集合。在这种情况下，使用`std::byte`类型，该类型可以在`<cstddef>`头文件中找到。`std::byte`类型允许进行按位逻辑运算（你将在[第7章](ch07.xhtml#ch07)中遇到这些），除此之外几乎没有其他功能。将此类型用于原始数据而不是整型可以帮助避免常见的难以调试的编程错误。
- en: Note that unlike most other fundamental types in `<cstddef>`, `std::byte` doesn’t
    have an exact corollary type in the C language (a “C type”). Like C++, C has `char`
    and `unsigned char`. These types are less safe to use because they support many
    operations that `std::byte` doesn’t. For example, you can perform arithmetic,
    like addition (`+`), on a `char` but not a `std::byte`. The odd-looking `std::`
    prefix is called a *namespace*, which you’ll meet in “Namespaces” on [page 216](ch08.xhtml#page_216)
    (for now, just think of the namespace `std::` as part of the type name).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`<cstddef>`中的大多数其他基本类型不同，`std::byte`在C语言中没有完全对应的类型（即“C类型”）。像C++一样，C语言有`char`和`unsigned
    char`。这些类型使用起来不那么安全，因为它们支持许多`std::byte`不支持的操作。例如，你可以对`char`执行算术运算（如加法`+`），但不能对`std::byte`执行类似的操作。奇怪的`std::`前缀称为*命名空间*，你将在“命名空间”一节中了解更多内容（见[第216页](ch08.xhtml#page_216)）（现在，暂时将命名空间`std::`视为类型名称的一部分）。
- en: '**NOTE**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are two schools of thought on how to pronounce *std*. One is to treat
    it as an initialism, as in “ess-tee-dee,” and another is to treat it as an acronym,
    as in “stood.” When referring to a class in the `std` namespace, speakers typically
    imply the namespace operator `::`. So you could pronounce `std::byte` as “stood
    byte” or, if you’re not into the whole brevity thing, as “ess-tee-dee colon colon
    byte.”*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于如何发音*std*有两种观点。一种是将其视为首字母缩略词，发音为“ess-tee-dee”；另一种是将其视为首字母缩写，发音为“stood”。当提到`std`命名空间中的类时，通常会隐含命名空间运算符`::`。所以你可以将`std::byte`发音为“stood
    byte”，或者，如果你不喜欢简洁的表达方式，可以发音为“ess-tee-dee colon colon byte”。*'
- en: '***The size_t Type***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***size_t 类型***'
- en: You use the `size_t` type, also available in the `<cstddef>` header, to encode
    size of objects. The `size_t` objects guarantee that their maximum values are
    sufficient to represent the maximum size in bytes of all objects. Technically,
    this means a `size_t` could take 2 bytes or 200 bytes depending on the implementation.
    In practice, it’s usually identical to an `unsigned long long` on 64-bit architectures.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`size_t`类型，该类型也可以在`<cstddef>`头文件中找到，用来编码对象的大小。`size_t`对象保证它们的最大值足以表示所有对象的最大字节数。从技术上讲，这意味着`size_t`可能占用2个字节或200个字节，具体取决于实现。在实践中，它通常与64位架构上的`unsigned
    long long`相同。
- en: '**NOTE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The type `size_t` is a C type in the C library header, but it’s identical
    to the C++ version, which resides in the `std` namespace. Occasionally, you’ll
    see the (technically correct) construction `std::size_t` instead.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*`size_t`类型是C库头文件中的C类型，但它与C++版本相同，后者位于`std`命名空间中。有时，你会看到（技术上正确的）构造`std::size_t`。*'
- en: '**sizeof**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**sizeof**'
- en: The unary operator `sizeof` takes a type operand and returns the size (in bytes)
    of that type. The `sizeof` operator always returns a `size_t`. For example, `sizeof(float)`
    returns the number of bytes of storage a `float` takes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符`sizeof`接受一个类型操作数，并返回该类型的大小（以字节为单位）。`sizeof`运算符始终返回一个`size_t`。例如，`sizeof(float)`返回`float`类型所占的字节数。
- en: '**Format Specifiers**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**格式说明符**'
- en: The usual format specifiers for a `size_t` are `%zu` for a decimal representation
    or `%zx` for a hexadecimal representation. [Listing 2-8](ch02.xhtml#ch02ex08)
    shows how you might check a system for several integer types’ sizes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_t`的常用格式说明符是`%zu`（用于十进制表示）或`%zx`（用于十六进制表示）。[列表2-8](ch02.xhtml#ch02ex08)展示了你如何检查系统上多个整数类型的大小。'
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-8: A program that prints the sizes in bytes of several integer types.
    (The output comes from a Windows 10 x64 machine.)*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表2-8：一个打印多个整数类型字节大小的程序。（输出来自Windows 10 x64机器。）*'
- en: '[Listing 2-8](ch02.xhtml#ch02ex08) evaluates the `sizeof` a `char` ➊, a `short`
    ➋, an `int` ➌, a `long` ➍, and a `long long` ➎ and prints their sizes using the
    `%zu` format specifier. Results will vary depending on the operating system. Recall
    from [Table 2-1](ch02.xhtml#ch02tab01) that each environment defines its own sizes
    for the integer types. Pay special attention to the return value of `long` in
    [Listing 2-8](ch02.xhtml#ch02ex08); Linux and macOS define 8-byte `long` types.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '***void***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `void` type has an empty set of values. Because a `void` object cannot
    hold a value, C++ disallows void objects. You use `void` in special situations,
    such as the return type for functions that don’t return any value. For example,
    the function `taunt` doesn’t return a value, so you declare its return type `void`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [Chapter 3](ch03.xhtml#ch03), you’ll learn about other special `void` uses.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arrays are sequences of identically typed variables. *Array types* include
    the contained type and the number of contained elements. You weave this information
    together in the declaration syntax: the element type precedes square brackets
    enclosing the array’s size.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following line declares an array of 100 `int` objects:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***Array Initialization***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a shortcut for initializing arrays with values using braces:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can omit the length of the array because it can be inferred from the number
    of elements in the braces at compile time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Array Elements***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You access array elements by using square brackets to enclose the desired index.
    Array indexing is zero based in C++, so the first element is at index `0`, the
    tenth element is at index `9`, and so on. [Listing 2-9](ch02.xhtml#ch02ex09) illustrates
    reading and writing array elements.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-9: A program that indexes into an array*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: This code declares a four-element array named `arr` containing the elements
    `1`, `2`, `3`, and `4` ➊. On the next line ➋, it prints the third element. It
    then assigns the third element to 100 ➌, so when it reprints the third element
    ➍, the value is `100`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '***A Nickel Tour of for Loops***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `for` loop lets you repeat (or iterate) the execution of a statement a specified
    number of times. You can stipulate a starting point and other conditions. The
    *init statement* executes before the first iteration executes, so you can initialize
    variables used in the `for` loop. The *conditional* is an expression that is evaluated
    before each iteration. If it evaluates to `true`, iteration proceeds. If `false`,
    the `for` loop terminates. The *iteration statement* executes after each iteration,
    which is useful in situations where you must increment a variable to cover a range
    of values. The `for` loop syntax is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For example, [Listing 2-10](ch02.xhtml#ch02ex10) shows you how to use a `for`
    loop to find the maximum of an array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 2-10: Finding the maximum value contained in an array*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: You initialize `maximum` ➊ to the smallest value possible; here that’s 0 because
    it’s unsigned. Next, you initialize the array `values` ➋, which you iterate over
    using the `for` loop ➌. The iterator variable `i` ranges from 0 to 4 inclusive.
    Within the `for` loop, you access each element of `values` and check whether the
    element is greater than the current `maximum` ➍. If it is, you set `maximum` to
    that new value ➎. When the loop is complete, `maximum` will equal the greatest
    value in the array, which prints the value of `maximum` ➏.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’ve programmed C or C++ before, you might be wondering why [Listing
    2-10](ch02.xhtml#ch02ex10) employs `size_t` instead of an `int` for the type of
    `i`. Consider that `values` could theoretically take up the maximum storage allowed.
    Although `size_t` is guaranteed to be able to index any value within it, `int`
    is not. In practice, it makes little difference, but technically `size_t` is correct.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**The Range-Based for Loop**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In [Listing 2-10](ch02.xhtml#ch02ex10), you saw how to use the `for` loop at
    ➌ to iterate over the elements of the array. You can eliminate the iterator variable
    `i` by using a *range-based for loop*. For certain objects like arrays, `for`
    understands how to iterate over the range of values within an object. Here’s the
    syntax for a range-based for loop:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You declare an iterator variable `element-name` ➋ with type `element-type` ➊.
    The `element-type` must match the types within the array you’re iterating over.
    This array is called `array-name` ➌.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-11](ch02.xhtml#ch02ex11) refactors [Listing 2-10](ch02.xhtml#ch02ex10)
    with a range-based `for` loop.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 2-11: Refactoring [Listing 2-10](ch02.xhtml#ch02ex10) with a range-based
    for loop*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll learn about expressions in [Chapter 7](ch07.xhtml#ch07). For now, think
    of an expression as some bit of code that produces an effect on your program.*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-11](ch02.xhtml#ch02ex11) greatly improves [Listing 2-10](ch02.xhtml#ch02ex10).
    At a glance, you know that the `for` loop iterates over `values` ➊. Because you’ve
    discarded the iterator variable `i`, the body of the `for` loop simplifies nicely;
    for that reason, you can use each element of values directly ➋➌.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Use range-based `for` loops generously.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of Elements in an Array**'
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Use the `sizeof` operator to obtain the total size in bytes of an array. You
    can use a simple trick to determine the number of elements in an array: divide
    the size of the array by the size of a single constituent element:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On most systems, `sizeof(array)` ➊ will evaluate to 16 bytes and `sizeof(short)`
    ➋ will evaluate to 2 bytes. Regardless of the size of a `short`, `n_elements`
    will always initialize to 8 because the factor will cancel. This evaluation happens
    at compile time, so there is no runtime cost in evaluating the length of an array
    in this way.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The `sizeof(x)/sizeof(y)` construction is a bit of a hack, but it’s widely used
    in older code. In [Part II](part02.xhtml#part02), you’ll learn other options for
    storing data that don’t require external computation of their lengths. If you
    really must use an array, you can safely obtain the number of elements using the
    `std::size` function available in the `<iterator>` header.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '*As an additional benefit, `std::size` can be used with any container that
    exposes a `size` method. This includes all the containers in [Chapter 13](ch13.xhtml#ch13).
    This is especially useful when writing generic code, a topic you’ll explore in
    [Chapter 6](ch06.xhtml#ch06). Further, it will refuse to compile if you accidentally
    pass an unsupported type, like a pointer.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '***C-Style Strings***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Strings* are contiguous blocks of characters. A *C-style string* or *null-terminated
    string* has a zero-byte appended to its end (a null) to indicate the end of the
    string. Because array elements are contiguous, you can store strings in arrays
    of character types.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**String Literals**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Declare string literals by enclosing text in quotation marks (`""`). Like character
    literals, string literals support Unicode: just prepend the literal with the appropriate
    prefix, such as `L`. The following example assigns string literals to the arrays
    `english` and `chinese`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**NOTE**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*Surprise! You’ve been using string literals all along: the format strings
    of your `printf` statements are string literals.*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'This code generates two variables: `english`, which contains `A book holds
    a house of gold.`, and `chinese`, which contains the Unicode characters for 书中自有黄金屋.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**Format Specifier**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The format specifier for narrow strings (`char*`) is `%s`. For example, you
    can incorporate strings into format strings as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**NOTE**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '*Printing Unicode to the console is surprisingly complicated. Typically, you
    need to ensure that the correct code page is selected, and this topic is well
    beyond the scope of this book. If you need to embed Unicode characters into a
    string literal, look at `wprintf` in the `<cwchar>` header.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Consecutive string literals get concatenated together, and any intervening
    whitespaces or newlines get ignored. So, you can place string literals on multiple
    lines in your source, and the compiler will treat them as one. For example, you
    could refactor this example as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Usually, such constructions are useful for readability only when you have a
    long string literal that would span multiple lines in your source code. The generated
    programs are identical.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *American Standard Code for Information Interchange (ASCII)* table assigns
    integers to characters. [Table 2-4](ch02.xhtml#ch02tab04) shows the ASCII table.
    For each integer value in decimal (0d) and hex (0x), the given control code or
    printable character is shown.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-4:** The ASCII Table'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '| **Control codes** | **Printable characters** |  |  |  |  |  |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| **0d** | **0x** | **Code** | **0d** | **0x** | **Char** | **0d** | **0x**
    | **Char** | **0d** | **0x** | **Char** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | `NULL` | 32 | 20 | `SPACE` | 64 | 40 | `@` | 96 | 60 | `` ` `` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | `SOH` | 33 | 21 | `!` | 65 | 41 | `A` | 97 | 61 | `a` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | `STX` | 34 | 22 | `"` | 66 | 42 | `B` | 98 | 62 | `b` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | `ETX` | 35 | 23 | `#` | 67 | 43 | `C` | 99 | 63 | `c` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | `EOT` | 36 | 24 | `$` | 68 | 44 | `D` | 100 | 64 | `d` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | `ENQ` | 37 | 25 | `%` | 69 | 45 | `E` | 101 | 65 | `e` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | `ACK` | 38 | 26 | `&` | 70 | 46 | `F` | 102 | 66 | `f` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| 7 | 7 | `BELL` | 39 | 27 | `''` | 71 | 47 | `G` | 103 | 67 | `g` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| 8 | 8 | `BS` | 40 | 28 | `(` | 72 | 48 | `H` | 104 | 68 | `h` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| 9 | 9 | `HT` | 41 | 29 | `)` | 73 | 49 | `I` | 105 | 69 | `i` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| 10 | 0a | `LF` | 42 | 2a | `*` | 74 | 4a | `J` | 106 | 6a | `j` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| 11 | 0b | `VT` | 43 | 2b | `+` | 75 | 4b | `K` | 107 | 6b | `k` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| 12 | 0c | `FF` | 44 | 2c | `,` | 76 | 4c | `L` | 108 | 6c | `l` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| 13 | 0d | `CR` | 45 | 2d | `-` | 77 | 4d | `M` | 109 | 6d | `m` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| 14 | 0e | `SO` | 46 | 2e | `.` | 78 | 4e | `N` | 110 | 6e | `n` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| 15 | 0f | `SI` | 47 | 2f | `/` | 79 | 4f | `O` | 111 | 6f | `o` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| 16 | 10 | `DLE` | 48 | 30 | `0` | 80 | 50 | `P` | 112 | 70 | `p` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| 17 | 11 | `DC1` | 49 | 31 | `1` | 81 | 51 | `Q` | 113 | 71 | `q` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| 18 | 12 | `DC2` | 50 | 32 | `2` | 82 | 52 | `R` | 114 | 72 | `r` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| 19 | 13 | `DC3` | 51 | 33 | `3` | 83 | 53 | `S` | 115 | 73 | `s` |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| 20 | 14 | `DC4` | 52 | 34 | `4` | 84 | 54 | `T` | 116 | 74 | `t` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| 21 | 15 | `NAK` | 53 | 35 | `5` | 85 | 55 | `U` | 117 | 75 | `u` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| 22 | 16 | `SYN` | 54 | 36 | `6` | 86 | 56 | `V` | 118 | 76 | `v` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| 23 | 17 | `ETB` | 55 | 37 | `7` | 87 | 57 | `W` | 119 | 77 | `w` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| 24 | 18 | `CAN` | 56 | 38 | `8` | 88 | 58 | `X` | 120 | 78 | `x` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '|  25  | 19 | `EM` | 57 | 39 | `9` | 89 | 59 | `Y` | 121 | 79 | `y` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| 26 | 1a | `SUB` | 58 | 3a | `:` | 90 | 5a | `Z` | 122 | 7a | `z` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| 27 | 1b | `ESC` | 59 | 3b | `;` | 91 | 5b | `[` | 123 | 7b | `{` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| 28 | 1c | `FS` | 60 | 3c | `<` | 92 | 5c | `\` | 124 | 7c | `&#124;` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| 29 | 1d | `GS` | 61 | 3d | `=` | 93 | 5d | `]` | 125 | 7d | `}` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| 30 | 1e | `RS` | 62 | 3e | `>` | 94 | 5e | `^` | 126 | 7e | `~` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| 31 | 1f | `US` | 63 | 3f | `?` | 95 | 5f | `_` | 127 | 7f | `DEL` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: 'ASCII codes 0 to 31 are the *control code characters* that control devices.
    These are mostly anachronisms. When the American Standards Association formalized
    ASCII in the 1960s, modern devices included teletype machines, magnetic tape readers,
    and dot-matrix printers. Some control codes still in common use are the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 0 (NULL) is used as a string terminator by programming languages.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 (EOT), the end of transmission, terminates shell sessions and PostScript printer
    communications.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7 (BELL) causes a device to make a noise.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 (BS), the backspace, causes the device to erase the last character.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 (HT), the horizontal tab, moves a cursor several spaces to the right.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10 (LF), the line feed, is used as the end-of-line marker on most operating
    systems.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13 (CR), the carriage return, is used in combination with LF as the end-of-line
    marker on Windows systems.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 26 (SUB), the substitute character/end of file/`ctrl`-Z, suspends the currently
    executing interactive process on most operating systems.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of the ASCII table, codes from 32 to 127, is the printable characters.
    These represent the English characters, digits, and punctuation.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: On most systems, the `char` type’s representation is ASCII. Although this relationship
    is not strictly guaranteed, it is a de facto standard.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to combine your knowledge of `char` types, arrays, `for` loops,
    and the ASCII table. [Listing 2-12](ch02.xhtml#ch02ex12) shows how to build an
    array with the letters of the alphabet, print the result, and then convert this
    array to uppercase and print again.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 2-12: Printing the letters of the alphabet in lowercase and uppercase
    using ASCII*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare a `char` array of length 27 to hold the 26 English letters
    plus a null terminator ➊. Next, employ a `for` loop to iterate from 0 to 25 using
    the iterator `i`. The letter *a* has the value 97 in ASCII. By adding 97 to the
    iterator `i`, you can generate all the lowercase letters in the `alphabet` ➋.
    To make `alphabet` a null-terminated string, you set `alphabet[26]` to 0 ➌. You
    then print the result ➍.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Next, you print the uppercase alphabet. The letter *A* has the value 65 in ASCII,
    so you reset each element of the alphabet accordingly ➎ and invoke `printf` again
    ➏.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Defined Types**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*User-defined types* are types that the user can define. The three broad categories
    of user-defined types are these:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Enumerations** The simplest of the user-defined types. The values that an
    enumeration can take are restricted to a set of possible values. Enumerations
    are excellent for modeling categorical concepts.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes** More fully featured types that give you flexibility to pair data
    and functions. Classes that only contain data are called plain-old-data classes;
    you’ll learn about them in this section.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Unions** A boutique user-defined type. All members share the same memory
    location. Unions are dangerous and easy to misuse.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '***Enumeration Types***'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Declare enumerations using the keywords `enum class` followed by the type name
    and a listing of the values it can take. These values are arbitrary alphanumeric
    strings that will represent whatever categories you want to represent. Under the
    hood, these values are simply integers, but they allow you to write safer, more
    expressive code by using programmer-defined types rather than integers that could
    mean anything. For example, [Listing 2-13](ch02.xhtml#ch02ex13) declares an `enum
    class` called `Race` that can take one of seven values.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 2-13: An enumeration class containing all the races from Neal Stephenson’s*
    Seveneves'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize an enumeration variable to a value, use the name of the type
    followed by two colons `::` and the desired value. For example, here’s how to
    declare the variable `langobard_race` and initialize its value to `Aidan`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**NOTE**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '*Technically, an `enum class` is one of two kinds of enumerations: it’s called
    a scoped enum. For compatibility with C, C++ also supports an unscoped enum, which
    is declared with `enum` rather than `enum class`. The major difference is that
    scoped enums require the enum’s type followed by `::` to precede the values, whereas
    unscoped enums don’t. Unscoped `enum` classes are less safe to use than scoped
    enums, so shy away from them unless absolutely necessary. They’re supported in
    C++ for mainly historical reasons, especially interoperation with C code. See
    Effective Modern C++ by Scott Meyers, Item 10, for details.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Switch Statements**'
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *switch statement* transfers control to one of several statements depending
    on the value of a *condition*, which evaluates to either an integer or enumeration
    type. The `switch` keyword denotes a switch statement.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Switch statements provide conditional branching. When a switch statement executes,
    control transfers to the *case* fitting the condition or to a *default condition*
    if no case matches the condition expression. The `case` keyword denotes a case,
    whereas the `default` keyword denotes the default condition.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Somewhat confusingly, execution will continue until the end of the switch statement
    or the `break` keyword. You’ll almost always find a `break` at the end of each
    condition.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Switch statements have a lot of components. [Listing 2-14](ch02.xhtml#ch02ex14)
    shows how they fit together.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 2-14: A sketch of how switch statements fit together*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: All switch statements begin with the `switch` keyword ➊ followed by the `condition`
    in parentheses ➋. Each case begins with the `case` keyword ➌ followed by the case’s
    enumeration or integral value ➍. If `condition` ➋ equals `case-a` ➍, for example,
    the code in the block containing `Handle case a here` will execute. After each
    statement following a case ➎, you place a `break` keyword ➏. If `condition` matches
    none of the cases, the `default` case ➐ executes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '*The braces enclosing each case are optional but highly recommended. Without
    them, you’ll sometimes get surprising behavior.*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a Switch Statement with an Enumeration Class**'
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 2-15](ch02.xhtml#ch02ex15) uses a switch statement on a `Race` enumeration
    class to generate a bespoke greeting.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 2-15: A program that prints a greeting that depends on the `Race`
    selected*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The `enum class` ➊ declares the enumeration type `Race`, which you use to initialize
    `race` to `Dinan` ➋. The switch statement ➌ evaluates the condition `race` to
    determine which condition to hand control to. Because you hardcoded this to `Dinan`
    earlier in the code, execution transfers to ➍, which prints `You work hard.` The
    `break` at ➎ terminates the switch statement.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The `default` condition at ➏ is a safety feature. If someone adds a new `Race`
    value to the enumeration class, you’ll detect that unknown race at runtime and
    print an error message.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Try setting `race` ➋ to different values. How does the output change?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '***Plain-Old-Data Classes***'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Classes* are user-defined types that contain data and functions, and they’re
    the heart and soul of C++. The simplest kind of classes are *plain-old-data classes
    (PODs)*. PODs are simple containers. Think of them as a sort of heterogeneous
    array of elements of potentially *different* types. Each element of a class is
    called a *member*.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Every POD begins with the keyword `struct` followed by the POD’s desired name.
    Next, you list the members’ types and names. Consider the following `Book` class
    declaration with four members:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A single `Book` contains a `char` array called `name` ➊, an `int year` ➋, an
    `int pages` ➌, and a `bool hardcover` ➍.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'You declare POD variables just like any other variables: by type and name.
    You can then access members of the variable using the dot operator (`.`).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-16](ch02.xhtml#ch02ex16) uses the `Book` type.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 2-16: Example using the POD type `Book` to read and write members*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare a `Book` variable `neuromancer` ➊. Next, you set the number
    of pages of `neuromancer` to 271 using the dot operator (`.`) ➋. Finally, you
    print a message and extract the number of pages from `neuromancer`, again using
    the dot operator ➌.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '*PODs have some useful low-level features: they’re C compatible, you can employ
    machine instructions that are highly efficient to copy or move them, and they
    can be efficiently represented in memory.*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '*C++ guarantees that members will be sequential in memory, although some implementations
    require members to be aligned along word boundaries, which depend on CPU register
    length. As a general rule, you should order members from largest to smallest within
    POD definitions.*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '***Unions***'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The union is a cousin of the POD that puts all of its members in the same place.
    You can think of unions as different views or interpretations of a block of memory.
    They can be useful in some low-level situations, such as when marshalling structures
    that must be consistent across architectures, dealing with type-checking issues
    related to C/C++ interoperation, and even when packing bitfields.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-17](ch02.xhtml#ch02ex17) illustrates how you declare a union: simply
    use the `union` keyword instead of `struct`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 2-17: An example union*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The union `Variant` can be interpreted as a `char[10]`, an `int`, or a `double`.
    It takes up only as much memory as its largest member (probably `string` in this
    case).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: You use the dot operator (`.`) to specify a union’s interpretation. Syntactically,
    this looks like accessing a member of a POD, but it’s completely different under
    the hood.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Because all members of a union are in the same place, you can cause data corruption
    very easily. [Listing 2-18](ch02.xhtml#ch02ex18) illustrates the danger.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 2-18: A program using the union `Variant` from [Listing 2-17](ch02.xhtml#ch02ex17)*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: You declare a `Variant v` at ➊. Next, you interpret `v` as an integer, set its
    value to 42 ➋, and print it ➌. You then reinterpret `v` as a `float` and reassign
    its value ➍. You print it to the console, and all appears well ➎. So far so good.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Disaster strikes only when you try to interpret `v` as an integer again ➏. You
    clobbered over the original value of `v` (42) ➋ when assigning Euler’s number
    ➍.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s the main problem with unions: it’s up to you to keep track of which
    interpretation is appropriate. The compiler won’t help you.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: You should avoid using unions in all but the rarest of cases, and you won’t
    see them in this book. “variant” on [page 379](ch12.xhtml#page_379) discusses
    some safer options when you require poly-type functionality.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully Featured C++ Classes**'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: POD classes contain only data members, and sometimes that’s all you want from
    a class. However, designing a program using only PODs can create a lot of complexity.
    You can fight such complexity with *encapsulation*, a design pattern that binds
    data with the functions that manipulate it. Placing related functions and data
    together helps to simplify code in at least two ways. First, you can put related
    code in one place, which helps you to reason about your program. You can understand
    how a code segment works because it describes in one place both program state
    and how your code modifies that state. Second, you can hide some of a class’s
    code and data from the rest of your program using a practice called *information
    hiding*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: In C++, you achieve encapsulation by adding methods and access controls to class
    definitions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '***Methods***'
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Methods* are member functions. They create an explicit connection among a
    class, its data members, and some code. Defining a method is as simple as adding
    a function to a class definition. Methods have access to all of a class’s members.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example class `ClockOfTheLongNow` that keeps track of the year.
    You define an `int year` member and an `add_year` method that increments it:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `add_year` method’s declaration ➊ looks like any other function that takes
    no parameters and returns no value. Within the method, you increment ➋ the member
    `year` ➌. [Listing 2-19](ch02.xhtml#ch02ex19) shows how you can use the class
    to keep track of a year.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 2-19: A program using the `ClockOfTheLongNow` struct*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: You declare the `ClockOfTheLongNow` instance `clock` ➊ and then set the `year`
    of `clock` to `2017` ➋. Next, you call the `add_year` method on `clock` ➌ and
    then print the value of `clock.year` ➍. You complete the program by incrementing
    ➎ and printing ➏ once more.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '***Access Controls***'
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Access controls* restrict class-member access. *Public* and *private* are
    the two major access controls. Anyone can access a public member, but only a class
    can access its private members. All `struct` members are public by default.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Private members play an important role in encapsulation. Consider again the
    `ClockOfTheLongNow` class. As it stands, the `year` member can be accessed from
    anywhere—for both reading and writing. Suppose you want to protect against the
    value of the `year` being less than 2019\. You can accomplish this in two steps:
    you make `year` private, and you require anyone using the class (consumers) to
    interact with `year` only through the struct’s methods. [Listing 2-20](ch02.xhtml#ch02ex20)
    illustrates this approach.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 2-20: An updated `ClockOfTheLongNow` from [Listing 2-19](ch02.xhtml#ch02ex19)
    that encapsulates `year`*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve added two methods to `ClockOfTheLongNow`: a *setter* ➊ and a *getter*
    ➌ for `year`. Rather than allowing a user of `ClockOfTheLongNow` to modify `year`
    directly, you set the `year` with `set_year`. This addition of input validation
    ensures that `new_year` will never be less than 2019 ➋. If it is, the code returns
    `false` and leaves `year` unmodified. Otherwise, `year` is updated and returns
    `true`. To obtain the value of `year`, the user calls `get_year`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: You’ve used the access control label `private` ➍ to prohibit consumers from
    accessing `year`. Now, users can access `year` only from within `ClockOfTheLongNow`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**The class Keyword**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can replace the `struct` keyword with the `class` keyword, which declares
    members `private` by default. Aside from default access control, classes declared
    with the `struct` and `class` keywords are the same. For example, you could declare
    `ClockOfTheLongNow` in the following way:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Which way you declare classes is a matter of style. There is absolutely no difference
    between `struct` and `class` aside from the default access control. I prefer using
    `struct` keywords because I like having the public members listed first. But you’ll
    see all kinds of conventions out in the wild. Cultivate a style and stick to it.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing Members**'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having encapsulated `year`, you must now use methods to interact with `ClockOfTheLongNow`.
    [Listing 2-21](ch02.xhtml#ch02ex21) shows how you can stitch these methods together
    into a program that attempts to set the year to 2018\. This fails, and the program
    then sets the year to 2019, increments the year, and prints its final value.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 2-21: A program using the ClockOfTheLongNow to illustrate the use
    of methods*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: You declare a clock ➊ and attempt to set its year to 2018 ➋. This fails because
    2018 is less than 2019, and the program then sets the year to 2019 ➌. You increment
    the year once ➍ and then print its value.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.xhtml#ch01), you saw how uninitialized variables can contain
    random data as you stepped through the debugger. The `ClockOfTheLongNow` struct
    has the same problem: when `clock` is declared ➊, `year` is uninitialized. You
    want to guarantee that `year` is never less than 2019 *under any circumstances*.
    Such a requirement is called a *class invariant*: a feature of a class that is
    always true (that is, it never varies).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: In this program, `clock` eventually gets into a good state ➌, but you can do
    better by employing a *constructor*. Constructors initialize objects and enforce
    class invariants from the very beginning of an object’s life.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '***Constructors***'
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Constructors are special methods with special declarations. Constructor declarations
    don’t state a return type, and their name matches the class’s name. For example,
    the constructor in [Listing 2-22](ch02.xhtml#ch02ex22) takes no arguments and
    sets `year` to 2019, which causes `year` to default to 2019.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 2-22: Improving [Listing 2-21](ch02.xhtml#ch02ex21) with a parameterless
    constructor*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The constructor takes no arguments ➊ and sets `year` to 2019 ➋. When you declare
    a new `ClockOfTheLongNow` ➌, `year` defaults to 2019\. You access `year` using
    `get_year` and print it to the console ➍.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to initialize a `ClockOfTheLongNow` with a custom year? Constructors
    can take any number of arguments. You can implement as many constructors as you’d
    like, as long as their argument types differ.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example in [Listing 2-23](ch02.xhtml#ch02ex23) where you add a
    constructor taking an `int`. The constructor initializes `year` to the argument’s
    value.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 2-23: Elaborating [Listing 2-22](ch02.xhtml#ch02ex22) with another
    constructor*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The new constructor ➊ takes a single `year_in` argument of type `int`. You call
    `set_year` with `year_in` ➋. If `set_year` returns false, the caller provided
    bad input, and you override `year_in` with the default value of 2019 ➌. In `main`,
    you make a clock with the new constructor ➍ and then print the result ➎.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The conjuration `ClockOfTheLongNow clock{ 2020 };` is called an initialization.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '*You might not like the idea that invalid `year_in` instances were silently
    corrected to 2019 ➌. I don’t like it either. Exceptions solve this problem; you’ll
    learn about them in “Exceptions” on [page 98](ch04.xhtml#page_98).*'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '***Initialization***'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Object initialization*, or simply *initialization,* is how you bring objects
    to life. Unfortunately, object initialization syntax is complicated. Fortunately,
    the initialization process is straightforward. This section distills the bubbling
    cauldron of C++ object initialization into a palatable narrative.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing a Fundamental Type to Zero**'
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s start by initializing an object of fundamental type to zero. There are
    four ways to do so:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Three of these are reliable: explicitly set the value using a literal ➊, use
    braces `{}` ➋, or use the equals-plus-braces approach `= {}` ➌. Declaring the
    object with no extra notation ➍ is unreliable; it works only in certain situations.
    Even if you know what these situations are, you should avoid relying on this behavior
    because it sows confusion.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Using braces `{}` to initialize a variable is, unsurprisingly, called *braced
    initialization*. Part of the reason C++ initialization syntax is such a mess is
    that the language grew out of C, where object life cycles are primitive, into
    a language with a robust and featureful object life cycle. Language designers
    incorporated braced initialization into modern C++ to help smooth over the sharp
    corners this has caused in the initialization syntax. In short, no matter the
    object’s scope or type, *braced initialization is always applicable*, whereas
    the other notations are not. Later in the chapter, you’ll learn a general rule
    that encourages widespread use of braced initialization.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing a Fundamental Type to an Arbitrary Value**'
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Initializing to an arbitrary value is similar to initializing a fundamental
    type to zero:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There are four ways: equals ➊, braced initialization ➋, equals-plus-braces
    initialization ➌, and parentheses ➍. All of these produce identical code.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing PODs**'
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The notation for initializing a POD mostly follows fundamental types. [Listing
    2-24](ch02.xhtml#ch02ex24) illustrates the similarity by declaring a POD type
    containing three members and initializing instances of it with various values.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 2-24: A program illustrating various ways to initialize a POD*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing a POD object to zero is similar to initializing objects of fundamental
    types to zero. The braces ➊ and equals-plus-braces ➋ approaches produce the same
    code: fields initialize to zero.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '*You cannot use the equals-zero approach with PODs. The following will not
    compile because it’s expressly forbidden in the language rules:*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Initializing PODs to Arbitrary Values**'
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can initialize fields to arbitrary values using braced initializers. The
    arguments within braced initializers must match types with POD members. The order
    of arguments from left to right matches the order of members from top to bottom.
    Any omitted members are zeroed. Members `a` and `b` initialize to `42` and `Hello`
    after the initialization of `initialized_pod3` ➌, and `c` is zeroed (set to false)
    because you omitted it from the braced initialization. The initialization of `initialized_pod4`
    ➍ includes an argument for `c` (`true`), so its value is set to true after initialization.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'The equals-plus-braces initialization works identically. For example, you could
    replace ➍ with this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can only omit fields from right to left, so the following won’t compile:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**WARNING**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '*You cannot use parentheses to initialize PODs. The following will not compile:*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Initializing Arrays**'
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You initialize arrays like PODs. The main difference between array and POD declarations
    is that arrays specify length. Recall that this argument goes in square brackets
    `[]`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: When you use braced initializers to initialize arrays, the length argument becomes
    optional; the compiler can infer the size argument from the number of braced initializer
    arguments.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-25](ch02.xhtml#ch02ex25) illustrates some ways to initialize an
    array.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 2-25: A program listing various ways to initialize an array*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The array `array_1` has length three, and its elements equal 1, 2, and 3 ➊.
    The array `array_2` has length five because you specified a length argument ➋.
    The braced initializer is empty, so all five elements initialize to zero. The
    array `array_3` also has length five, but the braced initializer is not empty.
    It contains three elements, so the remaining two elements initialize to zero ➌.
    The array `array_4` has no braced initializer, so it contains uninitialized objects
    ➍.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '*Whether `array_4` is initialized or not actually depends on the same rules
    as does initializing a fundamental type. The object’s storage duration, which
    you’ll learn about in “An Object’s Storage Duration” on [page 89](ch04.xhtml#page_89),
    determines the rules. You don’t have to memorize these rules if you’re explicit
    about initialization*.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully Featured Classes**'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unlike fundamental types and PODs, fully featured classes are *always initialized*.
    In other words, one of a fully featured class’s constructors always gets called
    during initialization. Which constructor is called depends on the arguments given
    during initialization.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: The class in [Listing 2-26](ch02.xhtml#ch02ex26) helps clarify how to use fully
    featured classes.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 2-26: A class announcing which of its several constructors gets called
    during initialization*'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Taxonomist` class has four constructors. If you supply no argument, the
    constructor with no arguments gets called ➊. If you supply a `char`, `int`, or
    `float` during initialization, the corresponding constructor gets called: ➋, ➌,
    or ➍, respectively. In each case, the constructor alerts you with a `printf` statement.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-27](ch02.xhtml#ch02ex27) initializes several `Taxonomists` using
    different syntaxes and arguments.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 2-27: A program using the `Taxonomist` class with various initialization
    syntaxes*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Without any braces or parentheses, the no argument constructor gets called ➊.
    Unlike with POD and fundamental types, you can rely on this initialization no
    matter where you’ve declared the object. With braced initializers, the `char`
    ➋, `int` ➌, and `float` ➍ constructors get called as expected. You can also use
    parentheses ➎ and the equals-plus-braces syntaxes ➏; these invoke the expected
    constructors.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Although fully featured classes always get initialized, some programmers like
    the uniformity of using the same initialization syntax for all objects. This is
    no problem with braced initializers; the default constructor gets invoked as expected
    ➐.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, using parentheses ➑ causes some surprising behavior. You get
    no output.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: If you squint a little bit, this initialization ➑ looks like a function declaration,
    and that’s because it is. Because of some arcane language-parsing rules, what
    you’ve declared to the compiler is that a yet-to-be-defined function `t8` takes
    no arguments and returns an object of type `Taxonomist`. Ouch.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '*Function Declarations” on [page 244](ch09.xhtml#page_244) covers function
    declarations in more detail. But for now, just know that you can provide a function
    declaration that defines a function’s modifiers, name, arguments, and return type
    and then later provide the body in its definition*.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: This widely known problem is called the *most vexing parse*, and it’s a major
    reason why the C++ community added braced initialization syntax to the language.
    *Narrowing conversions* are another problem.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**Narrowing Conversions**'
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Braced initialization will generate warnings whenever implicit narrowing conversions
    are encountered. This is a nice feature that can save you from nasty bugs. Consider
    the following example:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Dividing two `float` literals yields a float. When initializing `narrowed_result`
    ➊, the compiler silently narrows the result of `a/b` (0.5) to 0 because you’ve
    used parentheses `( )` to initialize. When you use braced initializers, the compiler
    generates a warning ➋.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing Class Members**'
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use braced initializers to initialize the members of classes, as demonstrated
    here:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `gold` member is initialized using the equals initialization ➊, `year_of_smelting_accident`
    using braced initialization ➋, and `key_location` using braces-plus-equals initialization
    ➌. It’s not possible to use parentheses to initialize member variables.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '**Brace Yourself**'
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The options for initializing objects bewilder even experienced C++ programmers.
    Here’s a general rule to make initialization simple: *use braced initializers
    everywhere*. Braced initializers work as intended almost everywhere, and they
    cause the fewest surprises. For this reason, braced initialization is also called
    *uniform initialization*. The remainder of the book follows this guidance.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll break the use braced initializers everywhere rule for certain classes
    in C++ stdlib. [Part II](part02.xhtml#part02) will make these exceptions to the
    rule very clear.*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '***The Destructor***'
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An object’s *destructor* is its cleanup function. The destructor is invoked
    before an object is destroyed. Destructors are almost never called explicitly:
    the compiler will ensure that each object’s destructor is called as appropriate.
    You declare a class’s destructor with the tilde `~` followed by the name of the
    class.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Earth` class has a destructor that prints `Making way for hyperspace
    bypass`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Defining a destructor is optional. If you do decide to implement a destructor,
    it must not take any arguments. Examples of actions you might want to take in
    a destructor include releasing file handles, flushing network sockets, and freeing
    dynamic objects.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t define a destructor, a default destructor is automatically generated.
    The default destructor’s behavior is to perform no action.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn a whole lot more about destructors in “Tracing the Object Life
    Cycle” on [page 96](ch04.xhtml#page_94).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter presented the foundation of C++, which is its type system. You
    first learned about fundamental types, the building blocks of all other types.
    Then you continued with user-defined types, including the `enum class`, POD classes,
    and fully featured C++ classes. You capped off your tour of classes with a discussion
    of constructors, initialization syntax, and destructors.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMAND LINE NOTATION**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '**2-1.** Create an `enum class Operation` that has values `Add`, `Subtract`,
    `Multiply`, and `Divide`.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '**2-2.** Create a `struct Calculator. It should have a single constructor that
    takes an Operation.`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**2-3.** Create a method on `Calculator` called `int calculate(int a, int b)`.
    Upon invocation, this method should perform addition, subtraction, multiplication,
    or division based on its constructor argument and return the result.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '**2-4.** Experiment with different means of initializing `Calculator` instances.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) – Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/))*'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Modern C++* by Scott Meyers (O’Reilly Media, 2014)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Made Easier: Plain Old Data” by Andrew Koenig and Barbara E. Moo (Dr.
    Dobb’s, 2002; [http://www.drdobbs.com/c-made-easier-plain-old-data/184401508/](http://www.drdobbs.com/c-made-easier-plain-old-data/184401508/))*'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
