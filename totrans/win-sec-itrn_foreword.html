<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>Foreword</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="for" epub:type="foreword" role="doc-foreword">
<hgroup>
<h1 class="FMH" id="for"><span aria-label=" Page xix. " epub:type="pagebreak" id="pg_xix" role="doc-pagebreak"></span><samp class="SANS_Dogma_OT_Bold_B_11">FOREWORD</samp></h1>
</hgroup>
<p class="TNI1">A Microsoft Technical Fellow once told me he had never met someone who understood how the security of the Windows operating system actually worked. While I don’t think he was right (and plan to send him a copy of this book to prove it), he had a point. Though critical, there is no doubt that Windows security is complex.</p>
<p class="TX">One of the reasons for this is related to the core architectural difference between Linux and Windows. Linux is a file-oriented operating system, while Windows is API oriented, and though APIs can provide a much richer set of capabilities, they come at the expense of simplicity. So, exploring an API-oriented operating system is more difficult. You need to read the API documentation, write code, compile and run it, and debug the results.</p>
<p class="TX">This is a very time-consuming loop, and it’s why so few people have a deep understanding of how Windows security works—it’s just too hard to explore.</p>
<p class="TX">It was because of these problems that I invented PowerShell. I wanted administrators to automate Windows and had originally tried to do so by distributing Unix tools for free. (Remember Windows Services for Unix?) This failed because Unix tools work on files, while everything important in Windows lives behind an API. Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">awk</samp> didn’t work against the registry, <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> didn’t work against Windows Management Instrumentation (WMI), <samp class="SANS_TheSansMonoCd_W5Regular_11">sed</samp> didn’t work against Active Directory, and so on. What we needed was <span aria-label=" Page xx. " epub:type="pagebreak" id="pg_xx" role="doc-pagebreak"></span>an API-oriented command line interface and scripting tool. So, I created PowerShell.</p>
<p class="TX">Today, James is using PowerShell to address the difficulty of acquiring Windows security expertise; he has made the system explorable. Step one: install his PowerShell module, <samp class="SANS_TheSansMonoCd_W5Regular_11">NTObjectManager</samp>, which provides over 550 cmdlets to experiment with all aspects of Windows security. This hands-on exploration will allow you to understand how things really work.</p>
<p class="TX">This book belongs on the desk of every security professional and developer working with Windows security. <a href="part1.xhtml">Part I</a> provides an overview of Windows security’s architecture, <a href="part2.xhtml">Part II</a> covers the details of the operating system’s security mechanisms and services, and <a href="part3.xhtml">Part III</a> explores the various aspects of Windows authentication. Each chapter includes a set of PowerShell examples.</p>
<p class="TX">I strongly encourage you to follow the examples provided; exploration turns words into experience, and experience is the foundation of competence. Run the commands, make intentional mistakes, and see what errors you get. In doing so, you’ll acquire a deep understanding of the system.</p>
<p class="TX">And trust me: it will be fun.</p>
<p class="SourceForeword">Jeffrey Snover<br/>Inventor of PowerShell, former chief architect for Windows Server, and former Microsoft Technical Fellow</p>
</section>
</div></body>
</html>