- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 28 DATABASE PROGRAMMING WITH THE PDO LIBRARY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Incorporating a database into a web application requires writing code to perform
    operations such as opening a connection to the database system; creating a database
    and its table structure; manipulating database data through insertions, deletions,
    and updates; and querying and retrieving data matching your desired criteria.
    In this chapter, you’ll learn about the PHP Data Objects (PDO) library, which
    makes it easy to carry out these sorts of database operations. We’ll use the library
    to progressively develop a simple, multipage web application that pulls information
    from a database.
  prefs: []
  type: TYPE_NORMAL
- en: '### The PDO Library'
  prefs: []
  type: TYPE_NORMAL
- en: The PDO library for database operations has been a built-in feature of the PHP
    language since 2005 and is compatible (through various drivers) with many DBMSs,
    including MySQL and SQLite, as we’ll see in this chapter. This makes it incredibly
    easy to develop flexible web applications that can switch DBMSs with minimal changes
    required to the code. Before PDO, switching to a different DBMS meant using a
    different library.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to offering a standard (and therefore reusable) way to run SQL commands
    on different relational database systems, PDO also makes it much easier to write
    more secure database communication code through the use of *prepared statements*.
    These are templates for database queries, including placeholders for certain fields
    that can be set to actual values when the query is to be executed. The basic pattern
    is to build the SQL statement as a string (including any placeholders), pass that
    string to a PDO connection object to “prepare” the statement, pass along any values
    for filling in the placeholders, and then execute the prepared statement on the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Handling SQL code through prepared statements avoids problems of SQL injection
    attacks, and so we’ll be using only prepared statements in this book. In a *SQL
    injection*, text that’s received from the user (for example, through a web form
    or a login field) is concatenated into an SQL query string and executed on the
    database. Malicious users can take advantage of this common web application vulnerability
    to modify the original SQL query or add an additional SQL query that will then
    also be executed on the database. The web comic XKCD took a humorous look at SQL
    injection, shown in [Figure 28-1](#fig28-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure28-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28-1: Randall Munroe’s “Bobby Tables” cartoon ([https://xkcd.com/327/](https://xkcd.com/327/))
    is a lighthearted example of the damage an SQL injection attack can do.'
  prefs: []
  type: TYPE_NORMAL
- en: Yet another bonus of using PDO is that it offers an *object fetch mode*, whereby
    data queried from the database is automatically packaged into objects of the appropriate
    classes in your PHP code (*model classes*). All you have to do is tell PDO which
    classes correspond to which database tables. Without this feature, you’d have
    to write code to handle the details of building the objects based on the results
    of the query, which often requires fussing with multidimensional arrays and column
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore the basics of using the PDO library throughout this chapter as
    we develop an object-oriented, database-driven web application.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This chapter only scratches the surface of the PDO library’s capabilities.
    For more information about what it can do, I recommend the modestly titled “(The
    Only Proper) PDO Tutorial,” available online at* [https://phpdelusions.net/pdo](https://phpdelusions.net/pdo)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Database-Driven Web Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get started using PDO, we’ll first create a bare-bones application with a
    single page that retrieves and displays information about a selection of products
    stored in a database. This will illustrate how to connect to a database, create
    a table, populate it with data, and retrieve that data for use in the application,
    all in an object-oriented way. In “A Multipage Database-Driven Web Application”
    on [page 553](#pg_553), we’ll expand the application to include multiple pages,
    well-organized controller logic, and Twig templating.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the project will have the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg543.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To begin, create a new project folder and add the usual *composer.json* file
    declaring that Mattsmithdev namespaced classes are located in the *src* folder.
    Then add a *public* folder containing the usual *index.php* script that reads
    in the autoloader, creates an Application object, and invokes its run() method.
    With that, we’re ready to set up the databases. The *db* folder will contain the
    scripts to create both MySQL and SQLite versions of a database to support our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Database Schema
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our web application will be able to use MySQL or SQLite as a DBMS, and in this
    section we’ll write PHP scripts to set up a new database schema using both systems.
    For small, local projects, an SQLite database file in the *var* folder of the
    project is often sufficient. For large-scale, production-ready web applications,
    MySQL is more common, with the database running on a different server (or multiple
    servers).
  prefs: []
  type: TYPE_NORMAL
- en: For this simple example, we’ll save the MySQL and SQLite database setup scripts
    in the project’s *db* folder. In a more realistic scenario, however, the database
    structure would be fixed and the database already set up, so such scripts wouldn’t
    usually be kept as part of the application’s folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: For our database, we’ll create a simple schema consisting of a single table
    called product and insert two example records into that table. [Figure 28-2](#fig28-2)
    shows an ER model of this table.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure28-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28-2: An ER model for the product table'
  prefs: []
  type: TYPE_NORMAL
- en: As the diagram shows, the product table will have fields for the product’s id
    (a unique numerical identifier), its description, and its price.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Listing 28-1 uses PDO to create a MySQL database schema, define the structure
    of a product table, and insert two example records into that table. Name this
    script *create_database.php* and save it in the *db* folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-1: A script to create our MySQL database'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a DB_NAME constant to hold the database schema name, 'demo1'
    ❶. Putting the name in a constant makes this script easy to edit and reuse on
    other database schemas—just update the name in the constant.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new PDO object to establish a connection with a database,
    storing the result in the $connection variable ❷. The first argument is the *data
    source name (DSN)*, a standardized string providing information about the database
    connection. The DSN string begins with 'mysql:', telling PDO that we want to connect
    to a MySQL server, followed by one or more key=value pairs, separated by semicolons.
    For now, we need just one key=value pair to specify that the host the MySQL database
    is running on is the localhost server at port 3306. We don’t include the schema
    name here, since we haven’t created the schema yet. The second and third arguments
    passed to the PDO constructor provide the username 'root' and the password 'passpass'.
    Replace these with the database username and password for your MySQL setup (see
    [Appendix B](appendix-b.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: We next build and execute an SQL statement to create the database schema named
    in the DB_NAME constant ❸. We create the SQL statement as a string in the $sql
    variable, consisting of the SQL keywords 'CREATE DATABASE' plus the schema name.
    We pass that string to the $connection object’s prepare() method to securely prepare
    the statement, placing the result, an object of the PDO library’s PDOStatement
    class, in the $stmt0 variable. Then we execute the prepared statement. We’ll use
    this basic pattern of preparing and executing SQL statements over and over when
    working with databases. In most cases, we’d then perform an action after the statement
    has been executed, such as returning a list of retrieved objects or confirming
    the database has been changed as expected and then informing the user if it has.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the schema, we need to create the product table within
    it. First, we overwrite $connection with a new connection to the database schema
    itself, rather than to the MySQL server in general. Notice that this time we specify
    the schema name as part of the DSN string when constructing the PDO object ❹.
    Specifically, we assign the DB_NAME constant as the value of the dbname key, followed
    by a semicolon (;) to separate this key/value pair from the others in the DSN
    string. Then we build and execute another SQL statement creating the product table
    with id, description, and price fields. MySQL databases support auto-incrementing,
    which automatically generates unique numeric keys in sequence. Our SQL statement
    uses this feature as part of the primary-key declaration for the id field, so
    we don’t have to worry about manually setting the product IDs ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'We finish the script by creating and executing two INSERT SQL statements to
    add two rows to the product table: a ''hammer'' costing 9.99 and a ''ladder''
    costing 59.99. We don’t include values for each product’s id field since MySQL
    will automatically generate them.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve written this script, run it by entering php db/create_database.php
    at the command line. This will create and populate the MySQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s adapt the script from [Listing 28-1](#lis28-1) to create the same
    schema as an SQLite database file. As you’ll see, the process is similar, since
    the PDO library can work with SQLite just as easily as with MySQL. Save the contents
    of [Listing 28-2](#lis28-2) as *create_databaseSQLite.php* in your project’s *db*
    subdirectory. The SQLite database file itself will be located in the *var* subdirectory,
    which is created as part of the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-2: A script to create our SQLite database'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define constants for the database filename ('demo1.db') and folder
    path. Remember that a double dot (..) in a path refers to a parent directory,
    so */../var* indicates that *var* should be at the same hierarchy level as the
    running script’s directory ❶. We create this directory if it doesn’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: Then we create a new PDO object, once again passing a DSN string as an argument
    to provide information about the database we want to connect to ❷. This time,
    the DSN string begins with 'sqlite:', telling PDO that we want to connect to an
    SQLite server, followed by the full filepath, including the directory path and
    filename, to the desired database. Unlike with MySQL, we don’t need to write and
    execute an SQL statement creating the database schema; if necessary, the SQLite
    database file is created when the connection is established. Also, since SQLite
    is just working with a file, there’s no need for any username or password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once PDO establishes a database connection, it mostly doesn’t matter what DBMS
    it’s working with, so the rest of the script is virtually identical to [Listing
    28-1](#lis28-1): we create and execute SQL statements to create the product table
    and add two entries to it. The only difference is that SQLite uses the keyword
    AUTOINCREMENT with no underscore (unlike MySQL’s AUTO_INCREMENT) ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: As with the MySQL version, you need to run this script to create and populate
    the SQLite database schema. Enter php db/create_databaseSQLite.php at the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the PHP Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll organize the logic of our simple web application by writing some PHP
    classes. For now, we need three. As usual, we’ll create an Application class to
    serve as a front controller for the application. We’ll also write a Product class
    with properties corresponding to the fields in our database’s product table, to
    make it easy to move data back and forth between the database and our PHP code.
    Finally, we’ll design a Database class to encapsulate the logic of creating a
    database connection. Not only will this help keep our code tidy and object-oriented,
    but it will also enable us to easily refactor the application to switch between
    MySQL and SQLite with little to no effect on the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the Application class. Declare this class in *src/Application.php*,
    as shown in [Listing 28-3](#lis28-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-3: The Application class'
  prefs: []
  type: TYPE_NORMAL
- en: We start by giving the class a private connection property ❶. This property
    has the nullable data type of ?\PDO, so it will be either a reference to a PDO
    database connection object or NULL (if the connection fails). In the class’s constructor
    method, we create a new Database object and invoke its getConnection() method
    (we’ll define that class and method shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we store the resulting database connection reference into the Application
    class’s connection property ❷. This may seem more roundabout than directly connecting
    to a database as we did earlier in the setup code, but relegating the details
    of establishing the connection to the Database class allows this Application class
    to work regardless of the DBMS we’re using.
  prefs: []
  type: TYPE_NORMAL
- en: We next declare the application’s run() method. In it, we test the connection
    property to make sure it isn’t NULL and invoke the getProducts() method if it
    isn’t ❸, which returns an array of Product objects retrieved from the database.
    For simplicity, we print the array preceded by an HTML <pre> tag. (We’ll refine
    this project to output valid HTML when we expand the application later in the
    chapter.) If connection is NULL, we print an error message instead.
  prefs: []
  type: TYPE_NORMAL
- en: We close out the class by declaring the getProducts() method. It uses the connection
    property to prepare and execute an SQL statement that selects all the rows from
    the database’s product table. The raw results of this query are in the PDOStatement
    object referenced by the $stmt variable, but we want to represent the results
    as Product objects.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the PDO library’s object fetch mode comes in handy. We set it
    up by invoking $stmt->setFetchMode() ❹, passing the \PDO::FETCH_CLASS constant
    as a first argument to indicate that we want the results to be objects of a class.
    The second argument, Product::class, tells PDO which (namespaced) class to use.
    The ::class magic constant returns the fully qualified class name string (in this
    case, 'Mattsmithdev\\Product'). Then we invoke $stmt->fetchAll() to retrieve the
    results. Since we selected multiple rows from the database, this creates an array
    of Product objects rather than just a single object. We return this array via
    the $products variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll create the Product model class. The properties of this class must
    correspond to the columns of the product database table (that is, have the same
    names and data types) for PDO to be able to successfully return query results
    as Product objects. Save the contents of [Listing 28-4](#lis28-4) in *src/Product.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-4: The Product class'
  prefs: []
  type: TYPE_NORMAL
- en: All this code does is declare three private properties for the class (id, description,
    and price) with names and data types matching the fields in the product table.
    That’s all the PDO library needs in order to retrieve rows from the table as objects
    of this class. Since for now our application is simply using var_dump() to display
    an array of Product objects, we never need to access the class’s private properties.
    When we expand the application, we’ll add accessor methods to the Product class
    so that we can write a more elegant template page that loops through and outputs
    each object’s properties in customizable and valid HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s declare the Database class to manage the process of establishing
    and storing a live MySQL database connection. Create the file *src/Database.php*
    containing the contents of [Listing 28-5](#lis28-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-5: The Database class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare class constants for the five individual pieces of data needed to
    create a live connection to a MySQL database ❶: the host (localhost), the port
    (3306), the MySQL username and password (fill these in as appropriate), and the
    name of the database schema we want to work with (demo1). Then we combine some
    of these constants into another constant representing the DSN string that we’ll
    need to pass as the first argument when creating the PDO object ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: We next declare a private connection property for the class ❸, along with a
    public getConnection() method to return its value. This property has the nullable
    data type of ?\PDO, so it will be either NULL or a reference to a PDO object.
  prefs: []
  type: TYPE_NORMAL
- en: In the Database class’s constructor method, we attempt to connect to the MySQL
    database by creating a new PDO object, using the class constants to provide the
    necessary DSN string, username, and password. A reference to the database connection
    is stored in the class’s connection property. These actions are wrapped inside
    a try statement ❹, so any exception thrown in the process will be caught ❺ and
    an error message will be printed out. Therefore, whenever a new Database object
    is created (from within the Application class), the constructor method will attempt
    to connect to the database. A subsequent call to getConnection() will return either
    a PDO connection object or NULL if a problem occurred when creating the connection.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’re ready to run the application and see the results. When you
    visit the localhost server running the web application, you should see something
    like [Figure 28-3](#fig28-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure28-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28-3: The web page showing the contents of the $products array'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the web page doesn’t look like much; all it shows is a var_dump()
    of the $products array. Since we haven’t yet included any decision logic in the
    run() method of the Application class, this page will always be displayed, regardless
    of any URL-encoded request variables. However, the printed contents of the array
    indicate that we’ve successfully retrieved entries from the products MySQL database
    table and mapped them to objects of our custom Product class, an important first
    step in database-driven application development.
  prefs: []
  type: TYPE_NORMAL
- en: Switching from MySQL to SQLite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, we set up the same database schema in both MySQL and SQLite; what would
    it take to refactor our application to use the SQLite schema rather than MySQL?
    We’ve designed the application so that all the DBMS-specific logic is encapsulated
    in the Database class, and we reference this class only once, in the constructor
    method for the Application class (see [Listing 28-3](#lis28-3)). There we use
    the statement $db = new Database() to get a reference to a new Database object
    before invoking its getConnection() method to obtain a PDO database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s replace this statement with one that creates an instance of a DatabaseSQLite
    class that will connect to SQLite instead of MySQL. [Listing 28-6](#lis28-6) shows
    the necessary change to *src/Application.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-6: Updating the Application class to create a DatabaseSQLite object
    instead of a Database object'
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to declare the DatabaseSQLite class to encapsulate the work of creating
    and storing a live SQLite database connection. For the rest of our application
    code to work as before, it needs to have a getConnection() method that returns
    a reference to a PDO connection object, just like the Database class. Create *src/DatabaseSQLite.php*
    containing the code in [Listing 28-7](#lis28-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-7: The DatabaseSQLite class'
  prefs: []
  type: TYPE_NORMAL
- en: 'This new class follows the same contours as the old Database class; only the
    SQLite-specific details differ. We first declare constants for the data needed
    to create a live SQLite database connection: the location of the directory containing
    the database file (DB_DIRECTORY); the full filepath, including the directory location
    and filename (DB_FILE_PATH); and the DSN string, including the full filepath (DATA_SOURCE_NAME).
    Then we declare a private connection property with a nullable \PDO data type of
    ?\PDO and its public getConnection() getter method, as before. Finally, we declare
    a constructor method that uses try and catch statements to attempt to create a
    new PDO database connection object and report any errors—again, just like the
    Database class.'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the web server again and you should see the application function
    exactly as before, displaying the contents of the $products array that features
    data retrieved from the database. It’s just that now we’re using SQLite rather
    than MySQL. This switch required virtually no updates to the code aside from declaring
    the new DatabaseSQLite class and changing one line to create a DatabaseSQLite
    object instead of Database.
  prefs: []
  type: TYPE_NORMAL
- en: A Multipage Database-Driven Web Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s expand our database-driven web application to encompass multiple
    pages, including a home page, a product list page, a page for displaying details
    about a single product, and a page for showing error messages. We’ll also use
    Twig templating to streamline the process of designing these pages. This expanded
    project will have the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg553.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 28-4](#fig28-4) shows the four pages of this website.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure28-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28-4: The expanded web application'
  prefs: []
  type: TYPE_NORMAL
- en: The pages feature HTML formatted with Bootstrap and offer a navigation bar with
    links to the home page and the list of products. When the *(show)* link is clicked
    next to a listed product, the details of that product are displayed on a new page.
    Notice that the ID of the clicked product appears as part of the query string
    in the page’s URL (for example, *id=1* on the page displaying information about
    the hammer). If an error occurs, such as a missing ID or an ID that doesn’t match
    a row in the database, an error page will be shown with an appropriate error message;
    the example in [Figure 28-4](#fig28-4) shows an ID of 99 in the browser address
    bar, and an error message stating that no product could be found with this ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the application will involve several actions, we’ll create two controller
    classes: ProductController for listing all products and displaying a details page
    for an individual item, and DefaultController with methods to display the home
    page and the error message page. We’ll revert to using MySQL and the original
    Database class to manage the database connection, but keep in mind that you can
    always sub in SQLite by switching to the DatabaseSQLite class instead. Since the
    project will use Twig templating, be sure to run composer require twig/twig at
    the command line to add the Twig library to the project.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Managing the Product Information'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin expanding the application by focusing on the classes that manage
    product information through database interaction. To start, we’ll add getter and
    setter methods to the Product class. This is necessary since the application will
    now need to individually access a Product object’s properties to display them
    in a more elegant way than a simple var_dump(). Update *src/Product.php* to match
    the contents of [Listing 28-8](#lis28-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-8: The Product class, now with getters and setters for each property'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we add simple getter and setter methods for each of the three properties
    of the Product class: id, description, and price. That’s a total of six new methods
    for this class.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now start organizing our application code a little better by putting any
    logic pertaining to retrieving products from the database in a ProductRepository
    class. It’s common in database-driven applications to use these sorts of classes,
    called *repository classes*, to separate logic accessing the database from the
    other logic in the application. The repository class methods take in and return
    objects, and handle any access to the database (with help establishing the database
    connection from the Database class itself). The rest of the application works
    with the resulting objects and has nothing at all to do with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Our ProductRepository class will include a method to retrieve all the products,
    as we originally had in the Application class, as well as a new method to retrieve
    a single product with a given ID. (Often repository classes have methods for other
    database operations as well, such as adding, updating, or deleting entries. We’ll
    discuss these operations in [Chapter 29](chapter29.xhtml).) Since this new class
    needs to interact with the database, it will now be responsible for creating the
    necessary Database object. These changes will free up the main Application class
    to focus on controller logic.
  prefs: []
  type: TYPE_NORMAL
- en: Create the new ProductRepository class in *src/ProductRepository.php* as shown
    in [Listing 28-9](#lis28-9). The black code is brand new; the grayed-out code
    has been taken from the Application class (see [Listing 28-3](#lis28-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-9: The new ProductRepository class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a private connection property, followed by a constructor method that
    creates a new Database object and invokes its getConnection() method to retrieve
    a database connection. This is just like the original Application class. Next,
    we declare a findAll() method containing the logic from the Application class’s
    getProducts() method. (Since this is now a method in the ProductRepository class,
    we don’t need to use the word *product* in the method name.) The method starts
    with an extra line of code that tests whether the database connection is NULL
    and returns an empty array if it is ❶. This is necessary because the Application
    class no longer has access to the database connection. If the connection isn’t
    NULL, the method retrieves all the products from the database and returns them
    as an array of Product objects, just like before.
  prefs: []
  type: TYPE_NORMAL
- en: We next declare the new find() method. It takes in an integer $id argument,
    which is used to retrieve a single Product object from the database table. Again,
    the first statement of this method is a NULL test on the database connection.
    If the connection is NULL, this method will immediately return NULL and finish
    executing. If the connection isn’t NULL, we prepare the 'SELECT * FROM product
    WHERE id = :id' string as an SQL query. The :id at the end is a named PDO placeholder,
    consisting of a colon followed by an identifier (id) for a part of the SQL statement
    that needs to be filled in by the value of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: We use the bindParam() method of the PDO statement object to connect the placeholder
    with the value of the $id argument ❷. This mechanism is what makes PDO’s prepared
    statements safe from SQL injection attacks. The placeholder syntax forces the
    value of $id to be treated as a possible value to look for in the id column. The
    value of the variable can’t possibly change the query itself into something more
    malicious.
  prefs: []
  type: TYPE_NORMAL
- en: The method uses PDO’s object fetch mode to retrieve the result of the query
    as a Product object (or NULL if no product in the database has a matching ID).
    Notice that we obtain the Product object by calling $stmt->fetch() ❸ rather than
    $stmt->fetchAll() as we did in the findAll() method, since this time we’re expecting
    only a single result. Since the fetch() method returns false (not NULL) on failure,
    we test for this value and return NULL if no object was successfully retrieved
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Controller Logic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll focus on the classes that implement the application’s controller
    logic. First, we’ll remove the database-related code from the Application class
    (since that code now lives in ProductRepository) and update the class to take
    in requests and delegate them to the appropriate controller. Modify *src/Application.php*
    to match the contents of [Listing 28-10](#lis28-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-10: The updated Application class with simple front-controller logic'
  prefs: []
  type: TYPE_NORMAL
- en: We declare two private defaultController and productController properties and
    then use the constructor to fill them with DefaultController and ProductController
    objects. Then we declare the run() method, which retrieves the value of $action
    from the incoming URL and passes it to a switch statement to decide what to do.
    If the value is 'products' ❶, we invoke the list() method of the ProductController
    object to display the page listing all the products.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of $action is 'show' ❷, we want to display a page with details
    about just one product. For that, we attempt to extract an integer $id variable
    from the URL, using FILTER_SANITIZE_NUMBER_INT to remove any non-integer characters
    from the variable. If $id ends up being empty ❸, we display an error page by passing
    a string error message to the error() method of the DefaultController object.
    If the value of $id isn’t empty ❹, we pass it to the show() method of the ProductController
    object to display the product page. Finally, we declare the switch statement’s
    default action ❺, which is to display the home page by invoking the homepage()
    method of the DefaultController object.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll create an abstract Controller class that will become the superclass
    for both our controller classes, DefaultController and ProductController. Create
    *src/Controller.php* containing the contents of [Listing 28-11](#lis28-11). Note
    that this class is just the same as Listing 22-8 on [page 436](chapter22.xhtml#pg_436).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-11: The abstract Controller superclass, providing a twig property'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare this class to be abstract so that it can’t be instantiated. We declare
    a class a constant for the path to the Twig templates directory. Then we declare
    a twig property with protected visibility so that it will be available to methods
    of subclasses to this class. Within the class’s constructor, we create two Twig
    objects: FilesystemLoader object and Environment. The latter holds the all-important
    render() method and is stored in the twig property, while the former helps the
    Environment object access the template files.'
  prefs: []
  type: TYPE_NORMAL
- en: With this Controller superclass declared, we can now declare the subclasses
    that will inherit from it. We’ll start with DefaultController, which will handle
    displaying the home page and error page. Declare the class in *src/DefaultController.php*
    as shown in [Listing 28-12](#lis28-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-12: The DefaultController class for simple page actions'
  prefs: []
  type: TYPE_NORMAL
- en: We declare that this class extends Controller so that it will inherit the superclass’s
    twig property. The class’s homepage() method ❶ invokes the render() method of
    the inherited twig property to render the *home.xhtml.twig* template, then prints
    out the text received. Similarly, the error() method ❷ renders and prints the
    *error.xhtml.twig* template. For this template, we pass along the value of the
    $message argument so that the error page will include a custom error message.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll create the other controller subclass, ProductController, for displaying
    product-related pages. Create *src/ProductController.php* to match the code in
    [Listing 28-13](#lis28-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-13: The ProductController class'
  prefs: []
  type: TYPE_NORMAL
- en: Like DefaultController, this class is declared as extending Controller. Its
    constructor method first invokes the parent (Controller) constructor, which sets
    up the inherited twig property. Then the constructor creates a new ProductRepository
    object and stores it in the productRepository property. The class will be able
    to use this object to get product information from the database.
  prefs: []
  type: TYPE_NORMAL
- en: The class’s list() method ❶ obtains an array of Product objects by invoking
    the ProductRepository object’s findAll() method. Then it renders and prints the
    *list.xhtml.twig* template, passing along the array of products, to display the
    full product list page. The show() method ❷ is similar to list(), but it uses
    the provided integer $id argument to retrieve a single Product object from the
    database (via the ProductRepository object’s find() method). Then it displays
    a page with just this product’s information by rendering and printing the *show.xhtml.twig*
    template. The if statement in this method tests whether NULL was received from
    the repository instead of an object, indicating no product with the provided ID
    exists in the database. If so, an error page will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Templates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All that remains is to design the Twig templates for the application’s various
    pages. The templates will all extend a common base template that defines the HTML
    skeleton for each page and includes the Bootstrap CSS stylesheets. We’ll write
    that base template first. Create *templates/base.xhtml.twig* containing the Twig
    code in [Listing 28-14](#lis28-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-14: The top-level base.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML <head> element includes a Twig title block where the page title can
    be inserted ❶. Each individual page template will declare its own title to be
    appended to the MGW text immediately before this block. The <head> element also
    contains a link to download the Bootstrap 5 minimized stylesheets from *[https://www.jsdelivr.com](https://www.jsdelivr.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the HTML <body>, we declare an unordered list styled with the nav nav-pills
    CSS class to represent the navigation bar at the top of each page ❷. We want the
    bar to include links to the home page and the product list. We declare each item
    as a list element styled with the nav-item CSS class and an anchor link element
    styled with the nav-link CSS class. The class declaration for each anchor link
    element features an empty Twig block (called homeLink and productLink, respectively),
    which we can override in the page templates to add the active CSS class. This
    way, the current page will be highlighted in the navigation bar. The base template
    ends with a body Twig block, where we’ll fill in the page-specific content ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the base Twig template, we can begin declaring the individual
    child templates, starting with the home page. Create the new Twig template *templates/home.xhtml.twig*
    containing the code in [Listing 28-15](#lis28-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-15: The home.xhtml.twig template for the home page'
  prefs: []
  type: TYPE_NORMAL
- en: We first declare that this template extends the base template. As such, the
    file is very short, since we have to fill in only the page-specific content. We
    override the title block with the text content home page so that the page’s title
    will be MGW - home page. Then we override the homeLink block with the text content
    active, so the home page link will appear as a colored button when this template
    page is displayed. Finally, we override the body block with a basic heading and
    paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll create the Twig template for the error page. Enter the contents of
    [Listing 28-16](#lis28-16) into *templates/error.xhtml.twig*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-16: The error.xhtml.twig template for the error page'
  prefs: []
  type: TYPE_NORMAL
- en: First, we override the title block with the text content error page, making
    this page’s title MGW - error page. Then we override the body block with a heading
    and paragraph. The paragraph is styled with the alert alert-danger CSS class to
    make it a nicely spaced, pink warning message to the viewer. The text content
    of this paragraph is the Twig message variable, which will be passed in via the
    $args array from the DefaultController class’s error() method. [Figure 28-5](#fig28-5)
    shows this error page displayed in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure28-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 28-5: The error page when an integer product ID hasn’t been provided'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create a Twig template for the Product List page in *templates/product/list.xhtml.twig*.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for templates for other model classes, we create a subdirectory of
    *templates* named *product*, and we will create our templates for the Product
    class here. Also, since templates for the Product class are in this folder, we
    don’t need to prefix the template names with the class name. For example, we can
    name this list template *list.xhtml.twig* rather than *productList.xhtml.twig*
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The code for *templates/product/list.xhtml.twig* is shown in [Listing 28-17](#lis28-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-17: The list.xhtml.twig template for listing all products'
  prefs: []
  type: TYPE_NORMAL
- en: We override the title block with the text content product list page and override
    the productLink block with the text content active, much as we did for the home
    page. Then, inside the body block, we use a Twig for loop ❶ to iterate over the
    Product objects in the products variable, formatting each one as a list item in
    an unordered list. (These Product objects were passed to the template in an array
    as part of the list() method of the ProductController class.)
  prefs: []
  type: TYPE_NORMAL
- en: We extract each property of each object individually for display on its own
    line, using Twig’s double curly bracket notation. For example, {{product.id}}
    accesses the id property of the current Product object. Notice that we format
    the product’s price to include two decimal places ❷. Each product’s list item
    ends with an anchor link element to show the details page for just that one product
    ❸. We insert the product’s ID into the link’s URL. This ID, in turn, will be passed
    to the find() method of the ProductRepository class to retrieve just that product’s
    information from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll create the individual Product Details page template in *templates/product/show.xhtml.twig*.
    [Listing 28-18](#lis28-18) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-18: The show.xhtml.twig template to display a single product’s details'
  prefs: []
  type: TYPE_NORMAL
- en: This template is simpler than the main Product List page template, since only
    a single Product object’s properties are being displayed inside the body block.
    The object is the Twig product variable that was passed to this template from
    the ProductController class’s show() method. Just as in the Product List page
    template, we output each of the object’s properties individually, accessing them
    via double curly bracket notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, the application is complete. Try launching it and visiting its four
    pages, clicking the *(show)* link to view the Product Details page about each
    product. You should see that the application is able to retrieve all the products
    from the database, or just one of the products based on the appropriate integer
    ID. You should also be able to toggle between MySQL and SQLite simply by substituting
    the Database class with the SQLiteDatabase class.  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the basics of PHP’s built-in PDO library for interacting
    with databases. We used the library to create a database schema and to insert
    data into a table. We then retrieved data from a table, mapping the results of
    a query to objects of a PHP model class using PDO’s object fetch mode. We also
    used prepared SQL statements, which add a layer of protection against SQL injection
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: We integrated our database schema into a well-organized, multipage web application.
    The code to manage the database connection was abstracted into a suitable class,
    either Database or SQLiteDatabase, allowing us to switch seamlessly between MySQL
    and SQLite as the application’s DBMS. The logic to retrieve data from the database
    and into Product objects was encapsulated in the ProductRepository class, front-controller
    logic was placed in an Application class, and logic for displaying simple pages
    was located in the DefaultController class. Actions relating to requests for one
    or many products went into the ProductController class, which used ProductRepository
    methods to query the database.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture could easily be scaled up, with additional repository, model,
    and controller classes for other database tables (users, customers, orders, suppliers,
    and so on). The entire application was styled using Twig templating, with a base
    (parent) template to efficiently share common page elements across all the individual
    child templates.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Create a new model class called Book with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: id (integer), an auto-incrementing primary key
  prefs: []
  type: TYPE_NORMAL
- en: title (string)
  prefs: []
  type: TYPE_NORMAL
- en: author (string)
  prefs: []
  type: TYPE_NORMAL
- en: price (float)
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a setup script (based on [Listings 28-1](#lis28-1) and [28-2](#lis28-2))
    to create a database with a book table, mapped to the Book class’s properties
    and types (use int, text, and float for the SQL data types). Also insert at least
    two book records into the database table with title, author, and price properties
    of your choice. Then write an object-oriented project (or adapt the example from
    this chapter) to retrieve and list all the books from the database. The project
    should include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Database class to create a connection to your database
  prefs: []
  type: TYPE_NORMAL
- en: A *public/index.php* script that creates an Application object and invokes its
    run() method
  prefs: []
  type: TYPE_NORMAL
- en: An Application class with a run() method to get an array of Book objects and
    var_dump() them
  prefs: []
  type: TYPE_NORMAL
- en: Your Book model class
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Extend your project from Exercise 1 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Add getter and setter accessor methods for each property in your Book class.
  prefs: []
  type: TYPE_NORMAL
- en: b.   Change your Application logic to test for an action variable in the URL.
    The default action should be to display a home page using an appropriate template.
    If the action is books, the application should display a page with information
    about all the books, using an appropriate template.
  prefs: []
  type: TYPE_NORMAL
