- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 28 DATABASE PROGRAMMING WITH THE PDO LIBRARY
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 28 使用PDO库进行数据库编程
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Incorporating a database into a web application requires writing code to perform
    operations such as opening a connection to the database system; creating a database
    and its table structure; manipulating database data through insertions, deletions,
    and updates; and querying and retrieving data matching your desired criteria.
    In this chapter, you’ll learn about the PHP Data Objects (PDO) library, which
    makes it easy to carry out these sorts of database operations. We’ll use the library
    to progressively develop a simple, multipage web application that pulls information
    from a database.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库集成到Web应用程序中需要编写代码来执行操作，如打开与数据库系统的连接；创建数据库及其表结构；通过插入、删除和更新来操作数据库数据；以及查询和检索符合期望条件的数据。在本章中，您将了解PHP数据对象（PDO）库，它使得执行这些数据库操作变得更加简单。我们将使用该库逐步开发一个简单的多页面Web应用程序，从数据库中提取信息。
- en: '### The PDO Library'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### PDO库'
- en: The PDO library for database operations has been a built-in feature of the PHP
    language since 2005 and is compatible (through various drivers) with many DBMSs,
    including MySQL and SQLite, as we’ll see in this chapter. This makes it incredibly
    easy to develop flexible web applications that can switch DBMSs with minimal changes
    required to the code. Before PDO, switching to a different DBMS meant using a
    different library.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 自2005年以来，数据库操作的PDO库已成为PHP语言的内置功能，并且通过各种驱动程序与许多数据库管理系统（DBMS）兼容，包括MySQL和SQLite，正如我们将在本章中看到的那样。这使得开发灵活的Web应用程序变得极为简单，开发者可以在最少修改代码的情况下切换数据库管理系统。在PDO出现之前，切换到不同的DBMS意味着使用不同的库。
- en: In addition to offering a standard (and therefore reusable) way to run SQL commands
    on different relational database systems, PDO also makes it much easier to write
    more secure database communication code through the use of *prepared statements*.
    These are templates for database queries, including placeholders for certain fields
    that can be set to actual values when the query is to be executed. The basic pattern
    is to build the SQL statement as a string (including any placeholders), pass that
    string to a PDO connection object to “prepare” the statement, pass along any values
    for filling in the placeholders, and then execute the prepared statement on the
    database.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一种标准（因此是可重用的）方式来在不同的关系型数据库系统上运行SQL命令外，PDO还通过使用*预处理语句*使得编写更安全的数据库通信代码变得更加容易。这些是数据库查询的模板，包括一些占位符，用于在查询执行时将其设置为实际值。基本的模式是将SQL语句构建为一个字符串（包括任何占位符），将该字符串传递给PDO连接对象以“准备”该语句，传递任何用于填充占位符的值，然后在数据库上执行准备好的语句。
- en: Handling SQL code through prepared statements avoids problems of SQL injection
    attacks, and so we’ll be using only prepared statements in this book. In a *SQL
    injection*, text that’s received from the user (for example, through a web form
    or a login field) is concatenated into an SQL query string and executed on the
    database. Malicious users can take advantage of this common web application vulnerability
    to modify the original SQL query or add an additional SQL query that will then
    also be executed on the database. The web comic XKCD took a humorous look at SQL
    injection, shown in [Figure 28-1](#fig28-1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过预处理语句处理SQL代码可以避免SQL注入攻击问题，因此本书中我们只会使用预处理语句。在*SQL注入*中，接收到的用户输入（例如通过Web表单或登录字段）被连接到SQL查询字符串中，并在数据库上执行。恶意用户可以利用这种常见的Web应用程序漏洞，修改原始SQL查询或添加一个额外的SQL查询，然后也在数据库上执行。Web漫画XKCD以幽默的方式展示了SQL注入攻击，见[图28-1](#fig28-1)。
- en: '![](../images/figure28-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure28-1.jpg)'
- en: 'Figure 28-1: Randall Munroe’s “Bobby Tables” cartoon ([https://xkcd.com/327/](https://xkcd.com/327/))
    is a lighthearted example of the damage an SQL injection attack can do.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图28-1：Randall Munroe的“Bobby Tables”漫画（[https://xkcd.com/327/](https://xkcd.com/327/)）是一个轻松幽默的例子，展示了SQL注入攻击可能造成的损害。
- en: Yet another bonus of using PDO is that it offers an *object fetch mode*, whereby
    data queried from the database is automatically packaged into objects of the appropriate
    classes in your PHP code (*model classes*). All you have to do is tell PDO which
    classes correspond to which database tables. Without this feature, you’d have
    to write code to handle the details of building the objects based on the results
    of the query, which often requires fussing with multidimensional arrays and column
    headers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PDO 的另一个好处是它提供了 *对象获取模式*，通过该模式，从数据库查询到的数据会自动打包成 PHP 代码中相应类的对象（*模型类*）。你只需告诉
    PDO 哪些类对应哪些数据库表。如果没有这个特性，你将不得不编写代码来处理如何根据查询结果构建对象的细节，这通常需要与多维数组和列标题打交道。
- en: We’ll explore the basics of using the PDO library throughout this chapter as
    we develop an object-oriented, database-driven web application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索如何使用 PDO 库的基础知识，同时开发一个面向对象的、数据库驱动的 web 应用程序。
- en: NOTE
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*This chapter only scratches the surface of the PDO library’s capabilities.
    For more information about what it can do, I recommend the modestly titled “(The
    Only Proper) PDO Tutorial,” available online at* [https://phpdelusions.net/pdo](https://phpdelusions.net/pdo)*.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章仅仅触及了 PDO 库功能的皮毛。想了解更多关于它的功能，我推荐那篇名为“（唯一合适的）PDO 教程”的文章，在线阅读地址为* [https://phpdelusions.net/pdo](https://phpdelusions.net/pdo)*。*'
- en: A Simple Database-Driven Web Application
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的数据库驱动 web 应用程序
- en: To get started using PDO, we’ll first create a bare-bones application with a
    single page that retrieves and displays information about a selection of products
    stored in a database. This will illustrate how to connect to a database, create
    a table, populate it with data, and retrieve that data for use in the application,
    all in an object-oriented way. In “A Multipage Database-Driven Web Application”
    on [page 553](#pg_553), we’ll expand the application to include multiple pages,
    well-organized controller logic, and Twig templating.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 PDO，我们首先将创建一个简单的应用程序，其中有一个页面用来从数据库中检索并显示一些产品的信息。这将展示如何连接数据库、创建表、填充数据，并以面向对象的方式检索这些数据以供应用程序使用。在《一个多页面的数据库驱动
    web 应用程序》一节中，位于 [第 553 页](#pg_553)，我们将扩展应用程序，增加多个页面、组织良好的控制器逻辑和 Twig 模板。
- en: 'For now, the project will have the following file structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，项目将具有以下文件结构：
- en: '![](../images/pg543.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg543.jpg)'
- en: To begin, create a new project folder and add the usual *composer.json* file
    declaring that Mattsmithdev namespaced classes are located in the *src* folder.
    Then add a *public* folder containing the usual *index.php* script that reads
    in the autoloader, creates an Application object, and invokes its run() method.
    With that, we’re ready to set up the databases. The *db* folder will contain the
    scripts to create both MySQL and SQLite versions of a database to support our
    application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的项目文件夹，并添加通常的 *composer.json* 文件，声明 Mattsmithdev 命名空间的类位于 *src* 文件夹中。然后添加一个
    *public* 文件夹，其中包含常见的 *index.php* 脚本，读取自动加载器，创建一个 Application 对象并调用它的 run() 方法。这样，我们就准备好设置数据库了。*db*
    文件夹将包含创建 MySQL 和 SQLite 版本数据库的脚本，以支持我们的应用程序。
- en: Setting Up the Database Schema
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置数据库架构
- en: Our web application will be able to use MySQL or SQLite as a DBMS, and in this
    section we’ll write PHP scripts to set up a new database schema using both systems.
    For small, local projects, an SQLite database file in the *var* folder of the
    project is often sufficient. For large-scale, production-ready web applications,
    MySQL is more common, with the database running on a different server (or multiple
    servers).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 web 应用程序将能够使用 MySQL 或 SQLite 作为数据库管理系统（DBMS），在本节中，我们将编写 PHP 脚本，使用这两种系统来设置一个新的数据库架构。对于小型本地项目，项目的
    *var* 文件夹中的 SQLite 数据库文件通常已经足够。对于大规模、生产就绪的 web 应用程序，MySQL 更为常见，且数据库通常运行在不同的服务器上（或者多个服务器上）。
- en: For this simple example, we’ll save the MySQL and SQLite database setup scripts
    in the project’s *db* folder. In a more realistic scenario, however, the database
    structure would be fixed and the database already set up, so such scripts wouldn’t
    usually be kept as part of the application’s folder structure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的例子，我们将把 MySQL 和 SQLite 数据库设置脚本保存在项目的 *db* 文件夹中。然而，在更现实的场景中，数据库结构应该是固定的，数据库也已经设置好了，因此这些脚本通常不会作为应用程序文件夹结构的一部分保留下来。
- en: For our database, we’ll create a simple schema consisting of a single table
    called product and insert two example records into that table. [Figure 28-2](#fig28-2)
    shows an ER model of this table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据库，我们将创建一个由单个名为product的表组成的简单架构，并将两条示例记录插入该表中。[图28-2](#fig28-2)显示了该表的ER模型。
- en: '![](../images/figure28-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure28-2.jpg)'
- en: 'Figure 28-2: An ER model for the product table'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图28-2：产品表的ER模型
- en: As the diagram shows, the product table will have fields for the product’s id
    (a unique numerical identifier), its description, and its price.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，产品表将包含产品的id（一个唯一的数字标识符）、描述和价格字段。
- en: MySQL
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: MySQL
- en: Listing 28-1 uses PDO to create a MySQL database schema, define the structure
    of a product table, and insert two example records into that table. Name this
    script *create_database.php* and save it in the *db* folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 清单28-1使用PDO来创建MySQL数据库架构，定义一个产品表的结构，并将两条示例记录插入到该表中。将这个脚本命名为*create_database.php*并保存在*db*文件夹中。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 28-1: A script to create our MySQL database'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 清单28-1：用于创建MySQL数据库的脚本
- en: First, we define a DB_NAME constant to hold the database schema name, 'demo1'
    ❶. Putting the name in a constant makes this script easy to edit and reuse on
    other database schemas—just update the name in the constant.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个DB_NAME常量来保存数据库架构名称'demo1' ❶。将名称放入常量中使得这个脚本易于编辑，并且可以在其他数据库架构上重用——只需更新常量中的名称。
- en: Next, we create a new PDO object to establish a connection with a database,
    storing the result in the $connection variable ❷. The first argument is the *data
    source name (DSN)*, a standardized string providing information about the database
    connection. The DSN string begins with 'mysql:', telling PDO that we want to connect
    to a MySQL server, followed by one or more key=value pairs, separated by semicolons.
    For now, we need just one key=value pair to specify that the host the MySQL database
    is running on is the localhost server at port 3306. We don’t include the schema
    name here, since we haven’t created the schema yet. The second and third arguments
    passed to the PDO constructor provide the username 'root' and the password 'passpass'.
    Replace these with the database username and password for your MySQL setup (see
    [Appendix B](appendix-b.xhtml)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的PDO对象以建立与数据库的连接，将结果存储在$connection变量中 ❷。第一个参数是*数据源名称（DSN）*，它是一个标准化的字符串，提供有关数据库连接的信息。DSN字符串以'mysql:'开头，告诉PDO我们想连接到MySQL服务器，后面跟着一个或多个由分号分隔的键=值对。现在，我们只需要一个键=值对来指定MySQL数据库运行的主机是localhost服务器，端口为3306。我们在这里不包含架构名称，因为我们还没有创建该架构。传递给PDO构造函数的第二个和第三个参数提供了用户名'root'和密码'passpass'。将它们替换为您MySQL设置的数据库用户名和密码（请参见[附录B](appendix-b.xhtml)）。
- en: We next build and execute an SQL statement to create the database schema named
    in the DB_NAME constant ❸. We create the SQL statement as a string in the $sql
    variable, consisting of the SQL keywords 'CREATE DATABASE' plus the schema name.
    We pass that string to the $connection object’s prepare() method to securely prepare
    the statement, placing the result, an object of the PDO library’s PDOStatement
    class, in the $stmt0 variable. Then we execute the prepared statement. We’ll use
    this basic pattern of preparing and executing SQL statements over and over when
    working with databases. In most cases, we’d then perform an action after the statement
    has been executed, such as returning a list of retrieved objects or confirming
    the database has been changed as expected and then informing the user if it has.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建并执行一个SQL语句来创建DB_NAME常量中指定的数据库架构 ❸。我们将SQL语句作为字符串存储在$sql变量中，内容为SQL关键字'CREATE
    DATABASE'加上架构名称。我们将该字符串传递给$connection对象的prepare()方法，以安全地准备该语句，并将结果（PDO库的PDOStatement类的一个对象）存储在$stmt0变量中。然后我们执行预处理的语句。在与数据库交互时，我们将反复使用这种准备和执行SQL语句的基本模式。在大多数情况下，我们将在语句执行后执行某个操作，例如返回已检索对象的列表，或者确认数据库已按预期更改，并通知用户是否已经更改。
- en: Now that we’ve created the schema, we need to create the product table within
    it. First, we overwrite $connection with a new connection to the database schema
    itself, rather than to the MySQL server in general. Notice that this time we specify
    the schema name as part of the DSN string when constructing the PDO object ❹.
    Specifically, we assign the DB_NAME constant as the value of the dbname key, followed
    by a semicolon (;) to separate this key/value pair from the others in the DSN
    string. Then we build and execute another SQL statement creating the product table
    with id, description, and price fields. MySQL databases support auto-incrementing,
    which automatically generates unique numeric keys in sequence. Our SQL statement
    uses this feature as part of the primary-key declaration for the id field, so
    we don’t have to worry about manually setting the product IDs ❺.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了架构，接下来需要在其中创建产品表。首先，我们通过新建一个连接到数据库架构的连接来覆盖$connection，而不是连接到MySQL服务器。请注意，这次我们在构造PDO对象时在DSN字符串中指定了架构名称
    ❹。具体来说，我们将DB_NAME常量的值作为dbname键的值，并用分号（;）将这个键/值对与DSN字符串中的其他部分分开。然后我们构建并执行另一个SQL语句，创建包含id、description和price字段的产品表。MySQL数据库支持自增功能，它会自动生成唯一的数字键并按顺序排列。我们的SQL语句利用了这个功能，作为id字段主键声明的一部分，因此我们不必担心手动设置产品ID
    ❺。
- en: 'We finish the script by creating and executing two INSERT SQL statements to
    add two rows to the product table: a ''hammer'' costing 9.99 and a ''ladder''
    costing 59.99. We don’t include values for each product’s id field since MySQL
    will automatically generate them.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建并执行两个INSERT SQL语句来为产品表添加两行数据：一把售价9.99的'锤子'和一把售价59.99的'梯子'。我们没有为每个产品的id字段提供值，因为MySQL会自动生成它们。
- en: Once you’ve written this script, run it by entering php db/create_database.php
    at the command line. This will create and populate the MySQL schema.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完此脚本后，输入php db/create_database.php在命令行运行它。这将创建并填充MySQL架构。
- en: SQLite
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SQLite
- en: Now let’s adapt the script from [Listing 28-1](#lis28-1) to create the same
    schema as an SQLite database file. As you’ll see, the process is similar, since
    the PDO library can work with SQLite just as easily as with MySQL. Save the contents
    of [Listing 28-2](#lis28-2) as *create_databaseSQLite.php* in your project’s *db*
    subdirectory. The SQLite database file itself will be located in the *var* subdirectory,
    which is created as part of the script.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将[列表 28-1](#lis28-1)中的脚本修改一下，以便创建与SQLite数据库文件相同的架构。正如你所看到的，过程类似，因为PDO库可以像与MySQL一样轻松地与SQLite一起使用。将[列表
    28-2](#lis28-2)中的内容保存为*create_databaseSQLite.php*，并放入项目的*db*子目录中。SQLite数据库文件本身将位于*var*子目录中，该目录是在脚本运行时创建的。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 28-2: A script to create our SQLite database'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 28-2：创建SQLite数据库的脚本
- en: First, we define constants for the database filename ('demo1.db') and folder
    path. Remember that a double dot (..) in a path refers to a parent directory,
    so */../var* indicates that *var* should be at the same hierarchy level as the
    running script’s directory ❶. We create this directory if it doesn’t already exist.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义数据库文件名（'demo1.db'）和文件夹路径的常量。请记住，路径中的双点（..）表示父目录，因此*/../var*表示*var*应该与运行脚本的目录处于同一级别
    ❶。如果该目录不存在，我们会创建它。
- en: Then we create a new PDO object, once again passing a DSN string as an argument
    to provide information about the database we want to connect to ❷. This time,
    the DSN string begins with 'sqlite:', telling PDO that we want to connect to an
    SQLite server, followed by the full filepath, including the directory path and
    filename, to the desired database. Unlike with MySQL, we don’t need to write and
    execute an SQL statement creating the database schema; if necessary, the SQLite
    database file is created when the connection is established. Also, since SQLite
    is just working with a file, there’s no need for any username or password.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次创建一个新的PDO对象，传入一个DSN字符串作为参数，提供我们希望连接的数据库信息 ❷。这次，DSN字符串以'sqlite:'开头，告诉PDO我们希望连接到SQLite服务器，后面跟着完整的文件路径，包括目录路径和文件名，指向所需的数据库。与MySQL不同，我们不需要编写并执行创建数据库架构的SQL语句；如果需要，SQLite数据库文件将在建立连接时自动创建。而且，由于SQLite只是操作一个文件，因此不需要任何用户名或密码。
- en: 'Once PDO establishes a database connection, it mostly doesn’t matter what DBMS
    it’s working with, so the rest of the script is virtually identical to [Listing
    28-1](#lis28-1): we create and execute SQL statements to create the product table
    and add two entries to it. The only difference is that SQLite uses the keyword
    AUTOINCREMENT with no underscore (unlike MySQL’s AUTO_INCREMENT) ❸.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 PDO 建立了数据库连接，通常不再关心它正在使用的数据库管理系统（DBMS），因此脚本的其余部分与 [清单 28-1](#lis28-1) 几乎相同：我们创建并执行
    SQL 语句来创建产品表并向其中添加两条记录。唯一的区别是 SQLite 使用没有下划线的关键字 AUTOINCREMENT（与 MySQL 的 AUTO_INCREMENT
    不同） ❸。
- en: As with the MySQL version, you need to run this script to create and populate
    the SQLite database schema. Enter php db/create_databaseSQLite.php at the command
    line.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MySQL 版本一样，你需要运行此脚本来创建和填充 SQLite 数据库模式。在命令行输入 php db/create_databaseSQLite.php。
- en: Writing the PHP Classes
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 PHP 类
- en: Now we’ll organize the logic of our simple web application by writing some PHP
    classes. For now, we need three. As usual, we’ll create an Application class to
    serve as a front controller for the application. We’ll also write a Product class
    with properties corresponding to the fields in our database’s product table, to
    make it easy to move data back and forth between the database and our PHP code.
    Finally, we’ll design a Database class to encapsulate the logic of creating a
    database connection. Not only will this help keep our code tidy and object-oriented,
    but it will also enable us to easily refactor the application to switch between
    MySQL and SQLite with little to no effect on the rest of the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过编写一些 PHP 类来组织我们简单 Web 应用程序的逻辑。目前，我们需要三个类。像往常一样，我们将创建一个 Application 类，作为应用程序的前端控制器。我们还将编写一个
    Product 类，具有与数据库中产品表字段对应的属性，以便于在数据库与 PHP 代码之间传输数据。最后，我们将设计一个 Database 类，用于封装创建数据库连接的逻辑。这样不仅有助于保持代码整洁和面向对象，而且还使我们能够轻松重构应用程序，在
    MySQL 和 SQLite 之间切换，而不会对其他代码产生太大影响。
- en: We’ll start with the Application class. Declare this class in *src/Application.php*,
    as shown in [Listing 28-3](#lis28-3).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Application 类开始。在 *src/Application.php* 中声明此类，如 [清单 28-3](#lis28-3) 所示。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 28-3: The Application class'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 28-3：Application 类
- en: We start by giving the class a private connection property ❶. This property
    has the nullable data type of ?\PDO, so it will be either a reference to a PDO
    database connection object or NULL (if the connection fails). In the class’s constructor
    method, we create a new Database object and invoke its getConnection() method
    (we’ll define that class and method shortly).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为类添加一个私有的连接属性 ❶。该属性的数据类型是可空的 ?\PDO，因此它将是指向 PDO 数据库连接对象的引用，或者是 NULL（如果连接失败）。在类的构造方法中，我们创建一个新的
    Database 对象，并调用其 getConnection() 方法（我们稍后会定义该类和方法）。
- en: Next, we store the resulting database connection reference into the Application
    class’s connection property ❷. This may seem more roundabout than directly connecting
    to a database as we did earlier in the setup code, but relegating the details
    of establishing the connection to the Database class allows this Application class
    to work regardless of the DBMS we’re using.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将生成的数据库连接引用存储到 Application 类的连接属性中 ❷。这看起来可能比之前直接连接数据库的方式更为间接，但将建立连接的细节委托给
    Database 类，可以让 Application 类无论使用何种 DBMS 都能正常工作。
- en: We next declare the application’s run() method. In it, we test the connection
    property to make sure it isn’t NULL and invoke the getProducts() method if it
    isn’t ❸, which returns an array of Product objects retrieved from the database.
    For simplicity, we print the array preceded by an HTML <pre> tag. (We’ll refine
    this project to output valid HTML when we expand the application later in the
    chapter.) If connection is NULL, we print an error message instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们声明应用程序的 run() 方法。在其中，我们测试连接属性以确保它不是 NULL，如果不是，则调用 getProducts() 方法 ❸，该方法返回从数据库检索到的
    Product 对象数组。为简便起见，我们将数组打印出来，并在前面加上 HTML <pre> 标签。（我们将在本章后续扩展应用程序时，精细化项目以输出有效的
    HTML。）如果连接为 NULL，则打印错误信息。
- en: We close out the class by declaring the getProducts() method. It uses the connection
    property to prepare and execute an SQL statement that selects all the rows from
    the database’s product table. The raw results of this query are in the PDOStatement
    object referenced by the $stmt variable, but we want to represent the results
    as Product objects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过声明 getProducts() 方法来结束类的定义。该方法使用连接属性来准备和执行一个 SQL 语句，从数据库的产品表中选择所有行。此查询的原始结果保存在
    PDOStatement 对象中，通过 $stmt 变量引用，但我们希望将结果表示为 Product 对象。
- en: This is where the PDO library’s object fetch mode comes in handy. We set it
    up by invoking $stmt->setFetchMode() ❹, passing the \PDO::FETCH_CLASS constant
    as a first argument to indicate that we want the results to be objects of a class.
    The second argument, Product::class, tells PDO which (namespaced) class to use.
    The ::class magic constant returns the fully qualified class name string (in this
    case, 'Mattsmithdev\\Product'). Then we invoke $stmt->fetchAll() to retrieve the
    results. Since we selected multiple rows from the database, this creates an array
    of Product objects rather than just a single object. We return this array via
    the $products variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，PDO 库的对象获取模式派上用场。我们通过调用 $stmt->setFetchMode() ❹ 来设置它，传递 \PDO::FETCH_CLASS
    常量作为第一个参数，表示我们希望结果是类的对象。第二个参数 Product::class 告诉 PDO 使用哪个（带命名空间的）类。::class 魔术常量返回完整限定类名字符串（在这个例子中是
    'Mattsmithdev\\Product'）。然后，我们调用 $stmt->fetchAll() 来获取结果。由于我们从数据库中选择了多行，这将创建一个
    Product 对象的数组，而不仅仅是一个对象。我们通过 $products 变量返回这个数组。
- en: Now we’ll create the Product model class. The properties of this class must
    correspond to the columns of the product database table (that is, have the same
    names and data types) for PDO to be able to successfully return query results
    as Product objects. Save the contents of [Listing 28-4](#lis28-4) in *src/Product.php*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建 Product 模型类。该类的属性必须与产品数据库表的列相对应（即具有相同的名称和数据类型），以便 PDO 能够成功地将查询结果返回为
    Product 对象。将 [Listing 28-4](#lis28-4) 的内容保存到 *src/Product.php* 文件中。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 28-4: The Product class'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 28-4：Product 类
- en: All this code does is declare three private properties for the class (id, description,
    and price) with names and data types matching the fields in the product table.
    That’s all the PDO library needs in order to retrieve rows from the table as objects
    of this class. Since for now our application is simply using var_dump() to display
    an array of Product objects, we never need to access the class’s private properties.
    When we expand the application, we’ll add accessor methods to the Product class
    so that we can write a more elegant template page that loops through and outputs
    each object’s properties in customizable and valid HTML.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做的就是声明该类的三个私有属性（id、description 和 price），它们的名称和数据类型与产品表中的字段相匹配。这就是 PDO 库需要的所有内容，用以将表中的行作为该类的对象检索出来。由于目前我们的应用程序仅仅使用
    var_dump() 来显示一个 Product 对象数组，我们从未需要访问类的私有属性。当我们扩展应用程序时，我们将为 Product 类添加访问器方法，这样我们就可以编写一个更优雅的模板页面，遍历并输出每个对象的属性，以自定义且有效的
    HTML 格式展示。
- en: Finally, let’s declare the Database class to manage the process of establishing
    and storing a live MySQL database connection. Create the file *src/Database.php*
    containing the contents of [Listing 28-5](#lis28-5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明 Database 类来管理建立并存储 MySQL 数据库连接的过程。创建 *src/Database.php* 文件，内容为 [Listing
    28-5](#lis28-5)。
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 28-5: The Database class'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 28-5：Database 类
- en: 'We declare class constants for the five individual pieces of data needed to
    create a live connection to a MySQL database ❶: the host (localhost), the port
    (3306), the MySQL username and password (fill these in as appropriate), and the
    name of the database schema we want to work with (demo1). Then we combine some
    of these constants into another constant representing the DSN string that we’ll
    need to pass as the first argument when creating the PDO object ❷.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明类常量，用于存储创建 MySQL 数据库实时连接所需的五个独立数据项 ❶：主机（localhost）、端口（3306）、MySQL 用户名和密码（根据需要填写），以及我们想要操作的数据库架构名称（demo1）。然后，我们将其中一些常量组合成另一个常量，表示
    DSN 字符串，该字符串将作为创建 PDO 对象时传递的第一个参数 ❷。
- en: We next declare a private connection property for the class ❸, along with a
    public getConnection() method to return its value. This property has the nullable
    data type of ?\PDO, so it will be either NULL or a reference to a PDO object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为该类声明一个私有连接属性 ❸，以及一个公有的 getConnection() 方法来返回其值。这个属性的数据类型为可空的 ?\PDO，因此它要么为
    NULL，要么为一个 PDO 对象的引用。
- en: In the Database class’s constructor method, we attempt to connect to the MySQL
    database by creating a new PDO object, using the class constants to provide the
    necessary DSN string, username, and password. A reference to the database connection
    is stored in the class’s connection property. These actions are wrapped inside
    a try statement ❹, so any exception thrown in the process will be caught ❺ and
    an error message will be printed out. Therefore, whenever a new Database object
    is created (from within the Application class), the constructor method will attempt
    to connect to the database. A subsequent call to getConnection() will return either
    a PDO connection object or NULL if a problem occurred when creating the connection.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库类的构造方法中，我们通过创建一个新的 PDO 对象来尝试连接 MySQL 数据库，使用类常量提供所需的 DSN 字符串、用户名和密码。数据库连接的引用存储在类的
    connection 属性中。这些操作被包装在一个 try 语句中❹，因此在此过程中抛出的任何异常都会被捕获❺，并打印出错误信息。因此，每当创建一个新的数据库对象（来自应用程序类中）时，构造方法都会尝试连接数据库。随后调用
    getConnection() 方法将返回一个 PDO 连接对象，或者如果创建连接时出现问题，则返回 NULL。
- en: With that, we’re ready to run the application and see the results. When you
    visit the localhost server running the web application, you should see something
    like [Figure 28-3](#fig28-3).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以准备好运行应用程序并查看结果了。当你访问运行 Web 应用程序的本地主机服务器时，应该能看到类似于 [图 28-3](#fig28-3)
    的内容。
- en: '![](../images/figure28-3.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure28-3.jpg)'
- en: 'Figure 28-3: The web page showing the contents of the $products array'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 28-3：显示 $products 数组内容的网页
- en: At this stage, the web page doesn’t look like much; all it shows is a var_dump()
    of the $products array. Since we haven’t yet included any decision logic in the
    run() method of the Application class, this page will always be displayed, regardless
    of any URL-encoded request variables. However, the printed contents of the array
    indicate that we’ve successfully retrieved entries from the products MySQL database
    table and mapped them to objects of our custom Product class, an important first
    step in database-driven application development.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，网页看起来并不复杂；它仅显示了 $products 数组的 var_dump()。由于我们尚未在应用程序类的 run() 方法中包含任何决策逻辑，因此无论
    URL 编码的请求变量如何，都会始终显示这个页面。然而，数组的打印内容表明我们已经成功从产品的 MySQL 数据库表中检索到条目，并将它们映射为我们自定义的
    Product 类的对象，这是数据库驱动应用程序开发中的一个重要第一步。
- en: Switching from MySQL to SQLite
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 MySQL 切换到 SQLite
- en: Earlier, we set up the same database schema in both MySQL and SQLite; what would
    it take to refactor our application to use the SQLite schema rather than MySQL?
    We’ve designed the application so that all the DBMS-specific logic is encapsulated
    in the Database class, and we reference this class only once, in the constructor
    method for the Application class (see [Listing 28-3](#lis28-3)). There we use
    the statement $db = new Database() to get a reference to a new Database object
    before invoking its getConnection() method to obtain a PDO database connection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在 MySQL 和 SQLite 中设置了相同的数据库模式；那么，如何重构我们的应用程序以使用 SQLite 模式而不是 MySQL 呢？我们已经设计了应用程序，使得所有数据库管理系统（DBMS）特定的逻辑都被封装在数据库类中，并且我们只在应用程序类的构造方法中引用该类一次（见
    [清单 28-3](#lis28-3)）。在这里，我们使用语句 $db = new Database() 来获取新数据库对象的引用，然后调用其 getConnection()
    方法来获得一个 PDO 数据库连接。
- en: Let’s replace this statement with one that creates an instance of a DatabaseSQLite
    class that will connect to SQLite instead of MySQL. [Listing 28-6](#lis28-6) shows
    the necessary change to *src/Application.php*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此语句替换为创建一个 DatabaseSQLite 类实例的语句，该实例将连接到 SQLite，而不是 MySQL。 [清单 28-6](#lis28-6)
    显示了对 *src/Application.php* 的必要更改。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 28-6: Updating the Application class to create a DatabaseSQLite object
    instead of a Database object'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 28-6：更新应用程序类以创建 DatabaseSQLite 对象而不是 Database 对象
- en: Now we need to declare the DatabaseSQLite class to encapsulate the work of creating
    and storing a live SQLite database connection. For the rest of our application
    code to work as before, it needs to have a getConnection() method that returns
    a reference to a PDO connection object, just like the Database class. Create *src/DatabaseSQLite.php*
    containing the code in [Listing 28-7](#lis28-7).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要声明一个 DatabaseSQLite 类来封装创建和存储实时 SQLite 数据库连接的工作。为了让我们其余的应用程序代码保持原样，它需要一个返回
    PDO 连接对象引用的 getConnection() 方法，就像数据库类一样。创建 *src/DatabaseSQLite.php* 文件，并包含 [清单
    28-7](#lis28-7) 中的代码。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 28-7: The DatabaseSQLite class'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 28-7：DatabaseSQLite 类
- en: 'This new class follows the same contours as the old Database class; only the
    SQLite-specific details differ. We first declare constants for the data needed
    to create a live SQLite database connection: the location of the directory containing
    the database file (DB_DIRECTORY); the full filepath, including the directory location
    and filename (DB_FILE_PATH); and the DSN string, including the full filepath (DATA_SOURCE_NAME).
    Then we declare a private connection property with a nullable \PDO data type of
    ?\PDO and its public getConnection() getter method, as before. Finally, we declare
    a constructor method that uses try and catch statements to attempt to create a
    new PDO database connection object and report any errors—again, just like the
    Database class.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类遵循与旧Database类相同的结构；只有与SQLite相关的细节不同。我们首先声明用于创建SQLite数据库连接所需的数据常量：包含数据库文件的目录位置（DB_DIRECTORY）；包含目录位置和文件名的完整文件路径（DB_FILE_PATH）；以及DSN字符串，包含完整文件路径（DATA_SOURCE_NAME）。然后我们声明一个私有连接属性，数据类型为可为空的
    \PDO（?\PDO），并像以前一样提供公共的getConnection()方法。最后，我们声明一个构造方法，使用try和catch语句来尝试创建新的PDO数据库连接对象，并报告任何错误——这与Database类一样。
- en: Try running the web server again and you should see the application function
    exactly as before, displaying the contents of the $products array that features
    data retrieved from the database. It’s just that now we’re using SQLite rather
    than MySQL. This switch required virtually no updates to the code aside from declaring
    the new DatabaseSQLite class and changing one line to create a DatabaseSQLite
    object instead of Database.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行网页服务器后，你应该会看到应用程序的功能和之前完全一样，展示了从数据库中获取的$products数组的内容。唯一不同的是，现在我们使用的是SQLite而不是MySQL。这个切换几乎不需要更新代码，除了声明新的DatabaseSQLite类，并修改一行代码以创建一个DatabaseSQLite对象，而不是Database对象。
- en: A Multipage Database-Driven Web Application
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个多页面的数据库驱动网页应用程序
- en: 'Now let’s expand our database-driven web application to encompass multiple
    pages, including a home page, a product list page, a page for displaying details
    about a single product, and a page for showing error messages. We’ll also use
    Twig templating to streamline the process of designing these pages. This expanded
    project will have the following file structure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这个数据库驱动的网页应用程序扩展为多个页面，包括主页、产品列表页、显示单个产品详情的页面和显示错误消息的页面。我们还将使用Twig模板引擎来简化这些页面设计的过程。扩展后的项目将具有以下文件结构：
- en: '![](../images/pg553.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg553.jpg)'
- en: '[Figure 28-4](#fig28-4) shows the four pages of this website.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图28-4](#fig28-4)展示了该网站的四个页面。'
- en: '![](../images/figure28-4.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure28-4.jpg)'
- en: 'Figure 28-4: The expanded web application'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图28-4：扩展后的网页应用程序
- en: The pages feature HTML formatted with Bootstrap and offer a navigation bar with
    links to the home page and the list of products. When the *(show)* link is clicked
    next to a listed product, the details of that product are displayed on a new page.
    Notice that the ID of the clicked product appears as part of the query string
    in the page’s URL (for example, *id=1* on the page displaying information about
    the hammer). If an error occurs, such as a missing ID or an ID that doesn’t match
    a row in the database, an error page will be shown with an appropriate error message;
    the example in [Figure 28-4](#fig28-4) shows an ID of 99 in the browser address
    bar, and an error message stating that no product could be found with this ID.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 页面使用了Bootstrap格式化的HTML，并提供了一个导航栏，链接到主页和产品列表。当点击某个产品旁边的*(show)*链接时，产品的详细信息将在新页面上显示。请注意，点击的产品的ID会作为查询字符串的一部分出现在页面的URL中（例如，*id=1*显示关于锤子的页面）。如果发生错误，比如缺少ID或ID与数据库中的行不匹配，错误页面将显示一个适当的错误消息；[图28-4](#fig28-4)中的示例显示浏览器地址栏中ID为99，并且有错误消息，表示没有找到具有该ID的产品。
- en: 'Since the application will involve several actions, we’ll create two controller
    classes: ProductController for listing all products and displaying a details page
    for an individual item, and DefaultController with methods to display the home
    page and the error message page. We’ll revert to using MySQL and the original
    Database class to manage the database connection, but keep in mind that you can
    always sub in SQLite by switching to the DatabaseSQLite class instead. Since the
    project will use Twig templating, be sure to run composer require twig/twig at
    the command line to add the Twig library to the project.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序将涉及多个操作，我们将创建两个控制器类：ProductController 用于列出所有产品并显示单个项目的详细页面，DefaultController
    用于显示主页和错误信息页面。我们将恢复使用 MySQL 和原始的 Database 类来管理数据库连接，但请记住，你始终可以通过改用 DatabaseSQLite
    类来切换到 SQLite。由于项目将使用 Twig 模板，请确保在命令行中运行 `composer require twig/twig` 来将 Twig 库添加到项目中。
- en: '#### Managing the Product Information'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 管理产品信息'
- en: Let’s begin expanding the application by focusing on the classes that manage
    product information through database interaction. To start, we’ll add getter and
    setter methods to the Product class. This is necessary since the application will
    now need to individually access a Product object’s properties to display them
    in a more elegant way than a simple var_dump(). Update *src/Product.php* to match
    the contents of [Listing 28-8](#lis28-8).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始扩展应用程序，重点关注通过数据库交互管理产品信息的类。首先，我们将为 Product 类添加 getter 和 setter 方法。这是必要的，因为应用程序现在需要单独访问
    Product 对象的属性，以比简单的 var_dump() 更优雅的方式显示它们。更新 *src/Product.php*，使其与[列表 28-8](#lis28-8)的内容一致。
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 28-8: The Product class, now with getters and setters for each property'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 28-8：具有每个属性的 getter 和 setter 方法的 Product 类
- en: 'Here we add simple getter and setter methods for each of the three properties
    of the Product class: id, description, and price. That’s a total of six new methods
    for this class.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 Product 类的三个属性：id、description 和 price 添加了简单的 getter 和 setter 方法。这是该类的六个新方法。
- en: We’ll now start organizing our application code a little better by putting any
    logic pertaining to retrieving products from the database in a ProductRepository
    class. It’s common in database-driven applications to use these sorts of classes,
    called *repository classes*, to separate logic accessing the database from the
    other logic in the application. The repository class methods take in and return
    objects, and handle any access to the database (with help establishing the database
    connection from the Database class itself). The rest of the application works
    with the resulting objects and has nothing at all to do with the database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过将与从数据库检索产品相关的逻辑放入 ProductRepository 类中，来更好地组织我们的应用程序代码。在数据库驱动的应用程序中，使用这种类（称为*仓库类*）来将访问数据库的逻辑与应用程序中的其他逻辑分离是很常见的。仓库类方法接受并返回对象，处理与数据库的任何交互（通过
    Database 类本身帮助建立数据库连接）。应用程序的其余部分则处理这些返回的对象，根本不涉及数据库。
- en: Our ProductRepository class will include a method to retrieve all the products,
    as we originally had in the Application class, as well as a new method to retrieve
    a single product with a given ID. (Often repository classes have methods for other
    database operations as well, such as adding, updating, or deleting entries. We’ll
    discuss these operations in [Chapter 29](chapter29.xhtml).) Since this new class
    needs to interact with the database, it will now be responsible for creating the
    necessary Database object. These changes will free up the main Application class
    to focus on controller logic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 ProductRepository 类将包括一个方法来检索所有产品，就像我们最初在 Application 类中实现的那样，同时还将新增一个方法，通过给定的
    ID 检索单个产品。（通常，仓库类也会有其他数据库操作方法，比如添加、更新或删除条目。我们将在[第 29 章](chapter29.xhtml)中讨论这些操作。）由于这个新类需要与数据库交互，它将负责创建必要的
    Database 对象。这些更改将使得主要的 Application 类能够专注于控制器逻辑。
- en: Create the new ProductRepository class in *src/ProductRepository.php* as shown
    in [Listing 28-9](#lis28-9). The black code is brand new; the grayed-out code
    has been taken from the Application class (see [Listing 28-3](#lis28-3)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的 ProductRepository 类，在 *src/ProductRepository.php* 中，如[列表 28-9](#lis28-9)所示。黑色代码是全新的；灰色代码来自
    Application 类（请参见[列表 28-3](#lis28-3)）。
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 28-9: The new ProductRepository class'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 28-9：新的 ProductRepository 类
- en: We declare a private connection property, followed by a constructor method that
    creates a new Database object and invokes its getConnection() method to retrieve
    a database connection. This is just like the original Application class. Next,
    we declare a findAll() method containing the logic from the Application class’s
    getProducts() method. (Since this is now a method in the ProductRepository class,
    we don’t need to use the word *product* in the method name.) The method starts
    with an extra line of code that tests whether the database connection is NULL
    and returns an empty array if it is ❶. This is necessary because the Application
    class no longer has access to the database connection. If the connection isn’t
    NULL, the method retrieves all the products from the database and returns them
    as an array of Product objects, just like before.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个私有的连接属性，接着是一个构造方法，该方法创建一个新的 Database 对象，并调用其 getConnection() 方法来获取数据库连接。这与原始的
    Application 类相同。接下来，我们声明一个 findAll() 方法，其中包含了 Application 类中 getProducts() 方法的逻辑。（由于这已经是
    ProductRepository 类中的一个方法，所以我们不需要在方法名中使用 *product* 一词。）该方法以一行额外的代码开始，用于测试数据库连接是否为
    NULL，如果是的话，返回一个空数组 ❶。这是必要的，因为 Application 类现在不再能够访问数据库连接。如果连接不为 NULL，方法会从数据库中获取所有产品，并将它们作为一个
    Product 对象数组返回，和之前一样。
- en: We next declare the new find() method. It takes in an integer $id argument,
    which is used to retrieve a single Product object from the database table. Again,
    the first statement of this method is a NULL test on the database connection.
    If the connection is NULL, this method will immediately return NULL and finish
    executing. If the connection isn’t NULL, we prepare the 'SELECT * FROM product
    WHERE id = :id' string as an SQL query. The :id at the end is a named PDO placeholder,
    consisting of a colon followed by an identifier (id) for a part of the SQL statement
    that needs to be filled in by the value of a variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了新的 find() 方法。该方法接受一个整数类型的 $id 参数，用于从数据库表中检索单个 Product 对象。同样，该方法的第一条语句是对数据库连接的
    NULL 测试。如果连接为 NULL，方法会立即返回 NULL 并结束执行。如果连接不为 NULL，我们准备一个 SQL 查询字符串 'SELECT * FROM
    product WHERE id = :id'。其中的 :id 是一个命名的 PDO 占位符，由冒号和一个标识符（id）组成，用来替换 SQL 语句中需要填充的变量值部分。
- en: We use the bindParam() method of the PDO statement object to connect the placeholder
    with the value of the $id argument ❷. This mechanism is what makes PDO’s prepared
    statements safe from SQL injection attacks. The placeholder syntax forces the
    value of $id to be treated as a possible value to look for in the id column. The
    value of the variable can’t possibly change the query itself into something more
    malicious.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 PDO 语句对象的 bindParam() 方法，将占位符与 $id 参数的值绑定 ❷。这一机制使得 PDO 的预处理语句能够防止 SQL 注入攻击。占位符语法强制要求
    $id 的值作为要在 id 列中查找的可能值，而变量的值不可能改变查询本身，从而避免了潜在的恶意操作。
- en: The method uses PDO’s object fetch mode to retrieve the result of the query
    as a Product object (or NULL if no product in the database has a matching ID).
    Notice that we obtain the Product object by calling $stmt->fetch() ❸ rather than
    $stmt->fetchAll() as we did in the findAll() method, since this time we’re expecting
    only a single result. Since the fetch() method returns false (not NULL) on failure,
    we test for this value and return NULL if no object was successfully retrieved
    ❹.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用 PDO 的对象提取模式，将查询结果作为一个 Product 对象（如果数据库中没有匹配的产品 ID，则返回 NULL）。注意，我们是通过调用
    $stmt->fetch() ❸ 获取 Product 对象，而不是像在 findAll() 方法中那样使用 $stmt->fetchAll()，因为这次我们只期望得到一个单一的结果。由于
    fetch() 方法在失败时返回的是 false（而非 NULL），我们会检查该值，并在没有成功获取对象时返回 NULL ❹。
- en: Implementing the Controller Logic
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现控制器逻辑
- en: Next, we’ll focus on the classes that implement the application’s controller
    logic. First, we’ll remove the database-related code from the Application class
    (since that code now lives in ProductRepository) and update the class to take
    in requests and delegate them to the appropriate controller. Modify *src/Application.php*
    to match the contents of [Listing 28-10](#lis28-10).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点关注实现应用程序控制器逻辑的类。首先，我们将从 Application 类中移除与数据库相关的代码（因为这些代码现在已经放入了 ProductRepository），并更新该类，以便它能够接收请求并将其委派给适当的控制器。修改
    *src/Application.php* 文件，使其与 [Listing 28-10](#lis28-10) 中的内容一致。
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 28-10: The updated Application class with simple front-controller logic'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 28-10：更新后的 Application 类，包含简单的前端控制器逻辑
- en: We declare two private defaultController and productController properties and
    then use the constructor to fill them with DefaultController and ProductController
    objects. Then we declare the run() method, which retrieves the value of $action
    from the incoming URL and passes it to a switch statement to decide what to do.
    If the value is 'products' ❶, we invoke the list() method of the ProductController
    object to display the page listing all the products.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个私有的 defaultController 和 productController 属性，然后使用构造函数将它们填充为 DefaultController
    和 ProductController 对象。接着，我们声明了 run() 方法，该方法从传入的 URL 中获取 $action 的值，并将其传递给 switch
    语句来决定要做什么。如果值是 'products' ❶，我们调用 ProductController 对象的 list() 方法来显示列出所有产品的页面。
- en: If the value of $action is 'show' ❷, we want to display a page with details
    about just one product. For that, we attempt to extract an integer $id variable
    from the URL, using FILTER_SANITIZE_NUMBER_INT to remove any non-integer characters
    from the variable. If $id ends up being empty ❸, we display an error page by passing
    a string error message to the error() method of the DefaultController object.
    If the value of $id isn’t empty ❹, we pass it to the show() method of the ProductController
    object to display the product page. Finally, we declare the switch statement’s
    default action ❺, which is to display the home page by invoking the homepage()
    method of the DefaultController object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 $action 的值是 'show' ❷，我们希望显示一个包含单个产品详情的页面。为此，我们尝试从 URL 中提取一个整数 $id 变量，使用 FILTER_SANITIZE_NUMBER_INT
    来移除变量中的非整数字符。如果 $id 最终为空 ❸，我们通过将错误消息字符串传递给 DefaultController 对象的 error() 方法来显示错误页面。如果
    $id 的值不为空 ❹，我们将其传递给 ProductController 对象的 show() 方法以显示该产品页面。最后，我们声明了 switch 语句的默认操作
    ❺，即通过调用 DefaultController 对象的 homepage() 方法来显示主页。
- en: Now we’ll create an abstract Controller class that will become the superclass
    for both our controller classes, DefaultController and ProductController. Create
    *src/Controller.php* containing the contents of [Listing 28-11](#lis28-11). Note
    that this class is just the same as Listing 22-8 on [page 436](chapter22.xhtml#pg_436).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个抽象的 Controller 类，它将成为我们两个控制器类 DefaultController 和 ProductController
    的超类。在 *src/Controller.php* 中创建包含 [列表 28-11](#lis28-11) 内容的代码。请注意，这个类与 [第 436 页](chapter22.xhtml#pg_436)
    的列表 22-8 是一样的。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 28-11: The abstract Controller superclass, providing a twig property'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 28-11：抽象的 Controller 超类，提供一个 twig 属性
- en: 'We declare this class to be abstract so that it can’t be instantiated. We declare
    a class a constant for the path to the Twig templates directory. Then we declare
    a twig property with protected visibility so that it will be available to methods
    of subclasses to this class. Within the class’s constructor, we create two Twig
    objects: FilesystemLoader object and Environment. The latter holds the all-important
    render() method and is stored in the twig property, while the former helps the
    Environment object access the template files.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明这个类为抽象类，以便它不能被实例化。我们为 Twig 模板目录路径声明了一个类常量。然后我们声明了一个具有受保护可见性的 twig 属性，以便它可以在该类的子类方法中使用。在类的构造函数中，我们创建了两个
    Twig 对象：FilesystemLoader 对象和 Environment 对象。后者包含了至关重要的 render() 方法，并存储在 twig 属性中，而前者则帮助
    Environment 对象访问模板文件。
- en: With this Controller superclass declared, we can now declare the subclasses
    that will inherit from it. We’ll start with DefaultController, which will handle
    displaying the home page and error page. Declare the class in *src/DefaultController.php*
    as shown in [Listing 28-12](#lis28-12).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了这个 Controller 超类之后，我们现在可以声明将从它继承的子类。我们从 DefaultController 开始，它将负责显示主页和错误页面。在
    *src/DefaultController.php* 中声明该类，如 [列表 28-12](#lis28-12) 所示。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 28-12: The DefaultController class for simple page actions'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 28-12：用于简单页面操作的 DefaultController 类
- en: We declare that this class extends Controller so that it will inherit the superclass’s
    twig property. The class’s homepage() method ❶ invokes the render() method of
    the inherited twig property to render the *home.xhtml.twig* template, then prints
    out the text received. Similarly, the error() method ❷ renders and prints the
    *error.xhtml.twig* template. For this template, we pass along the value of the
    $message argument so that the error page will include a custom error message.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明这个类继承自 Controller，以便它可以继承超类的 twig 属性。该类的 homepage() 方法 ❶ 调用继承的 twig 属性的
    render() 方法来渲染 *home.xhtml.twig* 模板，然后打印出接收到的文本。类似地，error() 方法 ❷ 渲染并打印 *error.xhtml.twig*
    模板。对于这个模板，我们传递 $message 参数的值，以便错误页面会显示一个自定义错误信息。
- en: Now we’ll create the other controller subclass, ProductController, for displaying
    product-related pages. Create *src/ProductController.php* to match the code in
    [Listing 28-13](#lis28-13).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建另一个控制器子类，ProductController，用于显示与产品相关的页面。创建 *src/ProductController.php*
    文件，匹配 [Listing 28-13](#lis28-13) 中的代码。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 28-13: The ProductController class'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 28-13: ProductController 类'
- en: Like DefaultController, this class is declared as extending Controller. Its
    constructor method first invokes the parent (Controller) constructor, which sets
    up the inherited twig property. Then the constructor creates a new ProductRepository
    object and stores it in the productRepository property. The class will be able
    to use this object to get product information from the database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像 DefaultController 一样，这个类声明为扩展 Controller。它的构造方法首先调用父类（Controller）的构造方法，设置继承的
    twig 属性。然后，构造方法创建一个新的 ProductRepository 对象，并将其存储在 productRepository 属性中。该类将能够使用此对象从数据库中获取产品信息。
- en: The class’s list() method ❶ obtains an array of Product objects by invoking
    the ProductRepository object’s findAll() method. Then it renders and prints the
    *list.xhtml.twig* template, passing along the array of products, to display the
    full product list page. The show() method ❷ is similar to list(), but it uses
    the provided integer $id argument to retrieve a single Product object from the
    database (via the ProductRepository object’s find() method). Then it displays
    a page with just this product’s information by rendering and printing the *show.xhtml.twig*
    template. The if statement in this method tests whether NULL was received from
    the repository instead of an object, indicating no product with the provided ID
    exists in the database. If so, an error page will be displayed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的 list() 方法 ❶ 通过调用 ProductRepository 对象的 findAll() 方法获取一个 Product 对象数组。然后它渲染并打印
    *list.xhtml.twig* 模板，传递该产品数组，来显示完整的产品列表页面。show() 方法 ❷ 与 list() 类似，但它使用提供的整数 $id
    参数从数据库中检索一个单一的 Product 对象（通过 ProductRepository 对象的 find() 方法）。然后，它通过渲染并打印 *show.xhtml.twig*
    模板来显示该产品的详细信息。如果该方法中从仓库接收到 NULL，而不是对象，则表明数据库中没有该 ID 的产品，此时将显示错误页面。
- en: Designing the Templates
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计模板
- en: All that remains is to design the Twig templates for the application’s various
    pages. The templates will all extend a common base template that defines the HTML
    skeleton for each page and includes the Bootstrap CSS stylesheets. We’ll write
    that base template first. Create *templates/base.xhtml.twig* containing the Twig
    code in [Listing 28-14](#lis28-14).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是为应用程序的各个页面设计 Twig 模板。所有模板将扩展一个公共的基础模板，该模板定义了每个页面的 HTML 骨架，并包含了 Bootstrap
    CSS 样式表。我们首先编写这个基础模板。创建 *templates/base.xhtml.twig* 文件，包含 [Listing 28-14](#lis28-14)
    中的 Twig 代码。
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 28-14: The top-level base.xhtml.twig template'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 28-14: 顶级 base.xhtml.twig 模板'
- en: The HTML <head> element includes a Twig title block where the page title can
    be inserted ❶. Each individual page template will declare its own title to be
    appended to the MGW text immediately before this block. The <head> element also
    contains a link to download the Bootstrap 5 minimized stylesheets from *[https://www.jsdelivr.com](https://www.jsdelivr.com)*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: HTML <head> 元素包含一个 Twig 标题块，可以在其中插入页面标题 ❶。每个单独的页面模板将声明自己的标题，并在该块之前将其附加到 MGW
    文本。<head> 元素还包含一个链接，用于从 *[https://www.jsdelivr.com](https://www.jsdelivr.com)*
    下载压缩版的 Bootstrap 5 样式表。
- en: Inside the HTML <body>, we declare an unordered list styled with the nav nav-pills
    CSS class to represent the navigation bar at the top of each page ❷. We want the
    bar to include links to the home page and the product list. We declare each item
    as a list element styled with the nav-item CSS class and an anchor link element
    styled with the nav-link CSS class. The class declaration for each anchor link
    element features an empty Twig block (called homeLink and productLink, respectively),
    which we can override in the page templates to add the active CSS class. This
    way, the current page will be highlighted in the navigation bar. The base template
    ends with a body Twig block, where we’ll fill in the page-specific content ❸.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML <body> 中，我们声明一个使用 nav nav-pills CSS 类样式的无序列表，用于表示每个页面顶部的导航栏 ❷。我们希望导航栏包含指向主页和产品列表的链接。我们将每个项声明为使用
    nav-item CSS 类样式的列表元素，并将其包含在一个使用 nav-link CSS 类样式的锚点链接元素中。每个锚点链接元素的类声明包括一个空的 Twig
    块（分别称为 homeLink 和 productLink），我们可以在页面模板中覆盖它，以添加活动的 CSS 类。通过这种方式，当前页面将在导航栏中高亮显示。基础模板以一个
    body Twig 块结束，在这里我们将填充页面特定的内容 ❸。
- en: Now that we have the base Twig template, we can begin declaring the individual
    child templates, starting with the home page. Create the new Twig template *templates/home.xhtml.twig*
    containing the code in [Listing 28-15](#lis28-15).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了基础的Twig模板，接下来我们可以开始声明各个子模板，从主页开始。创建新的Twig模板*templates/home.xhtml.twig*，并将[Listing
    28-15](#lis28-15)中的代码放入其中。
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 28-15: The home.xhtml.twig template for the home page'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 28-15：主页的home.xhtml.twig模板
- en: We first declare that this template extends the base template. As such, the
    file is very short, since we have to fill in only the page-specific content. We
    override the title block with the text content home page so that the page’s title
    will be MGW - home page. Then we override the homeLink block with the text content
    active, so the home page link will appear as a colored button when this template
    page is displayed. Finally, we override the body block with a basic heading and
    paragraph.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明该模板继承自基础模板。因此，该文件非常简短，因为我们只需要填写页面特定的内容。我们覆盖标题块，使用文本内容主页，以便该页面的标题为MGW -
    主页。接着，我们覆盖homeLink块，使用文本内容active，使得主页链接在该模板页面显示时呈现为一个有颜色的按钮。最后，我们覆盖主体块，添加一个基础的标题和段落。
- en: Now we’ll create the Twig template for the error page. Enter the contents of
    [Listing 28-16](#lis28-16) into *templates/error.xhtml.twig*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建错误页面的Twig模板。将[Listing 28-16](#lis28-16)中的内容输入到*templates/error.xhtml.twig*中。
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 28-16: The error.xhtml.twig template for the error page'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 28-16：错误页面的error.xhtml.twig模板
- en: First, we override the title block with the text content error page, making
    this page’s title MGW - error page. Then we override the body block with a heading
    and paragraph. The paragraph is styled with the alert alert-danger CSS class to
    make it a nicely spaced, pink warning message to the viewer. The text content
    of this paragraph is the Twig message variable, which will be passed in via the
    $args array from the DefaultController class’s error() method. [Figure 28-5](#fig28-5)
    shows this error page displayed in a web browser.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们覆盖标题块，并使用文本内容错误页面，使得该页面的标题为MGW - 错误页面。然后，我们覆盖主体块，添加一个标题和一个段落。这个段落使用了alert
    alert-danger CSS类，以便使其成为一个间隔适当、粉色的警告信息展示给用户。段落的文本内容是Twig的消息变量，该变量通过$arguments数组从DefaultController类的error()方法传递给模板。[Figure
    28-5](#fig28-5)展示了该错误页面在浏览器中的显示效果。
- en: '![](../images/figure28-5.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure28-5.jpg)'
- en: 'Figure 28-5: The error page when an integer product ID hasn’t been provided'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 28-5：当没有提供整数类型的产品ID时显示的错误页面
- en: Next, we’ll create a Twig template for the Product List page in *templates/product/list.xhtml.twig*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在*templates/product/list.xhtml.twig*中创建一个产品列表页面的Twig模板。
- en: To prepare for templates for other model classes, we create a subdirectory of
    *templates* named *product*, and we will create our templates for the Product
    class here. Also, since templates for the Product class are in this folder, we
    don’t need to prefix the template names with the class name. For example, we can
    name this list template *list.xhtml.twig* rather than *productList.xhtml.twig*
    and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备其他模型类的模板，我们创建一个名为*product*的*templates*子目录，在这里创建产品类的模板。此外，由于产品类的模板在此文件夹中，我们不需要在模板名称前加上类名。例如，我们可以将这个列表模板命名为*list.xhtml.twig*，而不是*productList.xhtml.twig*，依此类推。
- en: The code for *templates/product/list.xhtml.twig* is shown in [Listing 28-17](#lis28-17).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*templates/product/list.xhtml.twig*的代码如[Listing 28-17](#lis28-17)所示。'
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 28-17: The list.xhtml.twig template for listing all products'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 28-17：列出所有产品的list.xhtml.twig模板
- en: We override the title block with the text content product list page and override
    the productLink block with the text content active, much as we did for the home
    page. Then, inside the body block, we use a Twig for loop ❶ to iterate over the
    Product objects in the products variable, formatting each one as a list item in
    an unordered list. (These Product objects were passed to the template in an array
    as part of the list() method of the ProductController class.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖标题块，使用文本内容产品列表页面，并像在主页中一样，覆盖productLink块，使用文本内容active。然后，在主体块内部，我们使用Twig的for循环❶来遍历products变量中的Product对象，将每个对象格式化为无序列表中的一个列表项。（这些Product对象通过数组的形式作为ProductController类list()方法的一部分传递给模板。）
- en: We extract each property of each object individually for display on its own
    line, using Twig’s double curly bracket notation. For example, {{product.id}}
    accesses the id property of the current Product object. Notice that we format
    the product’s price to include two decimal places ❷. Each product’s list item
    ends with an anchor link element to show the details page for just that one product
    ❸. We insert the product’s ID into the link’s URL. This ID, in turn, will be passed
    to the find() method of the ProductRepository class to retrieve just that product’s
    information from the database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取每个对象的每个属性，分别显示在各自的行上，使用Twig的双大括号表示法。例如，{{product.id}}访问当前Product对象的id属性。请注意，我们将产品的价格格式化为包含两位小数
    ❷。每个产品的列表项末尾都有一个锚点链接元素，用于显示该产品的详情页面 ❸。我们将产品的ID插入链接的URL中。这个ID将被传递到ProductRepository类的find()方法中，用于从数据库中获取该产品的信息。
- en: Finally, we’ll create the individual Product Details page template in *templates/product/show.xhtml.twig*.
    [Listing 28-18](#lis28-18) shows how.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在*templates/product/show.xhtml.twig*中创建单独的产品详情页面模板。[清单28-18](#lis28-18)展示了具体实现方法。
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 28-18: The show.xhtml.twig template to display a single product’s details'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清单28-18：显示单个产品详情的show.xhtml.twig模板
- en: This template is simpler than the main Product List page template, since only
    a single Product object’s properties are being displayed inside the body block.
    The object is the Twig product variable that was passed to this template from
    the ProductController class’s show() method. Just as in the Product List page
    template, we output each of the object’s properties individually, accessing them
    via double curly bracket notation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板比主产品列表页面模板简单，因为只显示了单个Product对象的属性，这些属性在主体块内被显示。该对象是从ProductController类的show()方法传递到此模板中的Twig产品变量。与产品列表页面模板中的方法一样，我们分别输出对象的每个属性，通过双大括号表示法访问它们。
- en: 'With that, the application is complete. Try launching it and visiting its four
    pages, clicking the *(show)* link to view the Product Details page about each
    product. You should see that the application is able to retrieve all the products
    from the database, or just one of the products based on the appropriate integer
    ID. You should also be able to toggle between MySQL and SQLite simply by substituting
    the Database class with the SQLiteDatabase class.  ### Summary'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，应用程序已完成。试着启动它并访问四个页面，点击*(show)*链接查看每个产品的产品详情页面。你应该能够看到应用程序能够从数据库中检索所有产品，或者根据相应的整数ID仅检索一个产品。你还应该能够通过简单地将Database类替换为SQLiteDatabase类，在MySQL和SQLite之间进行切换。###
    总结
- en: In this chapter, we explored the basics of PHP’s built-in PDO library for interacting
    with databases. We used the library to create a database schema and to insert
    data into a table. We then retrieved data from a table, mapping the results of
    a query to objects of a PHP model class using PDO’s object fetch mode. We also
    used prepared SQL statements, which add a layer of protection against SQL injection
    attacks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了PHP内置的PDO库与数据库交互的基础知识。我们使用该库创建了数据库模式并向表中插入数据。然后，我们从表中检索数据，将查询结果映射到PHP模型类的对象中，使用PDO的对象获取模式。我们还使用了预处理SQL语句，增加了一层防止SQL注入攻击的保护。
- en: We integrated our database schema into a well-organized, multipage web application.
    The code to manage the database connection was abstracted into a suitable class,
    either Database or SQLiteDatabase, allowing us to switch seamlessly between MySQL
    and SQLite as the application’s DBMS. The logic to retrieve data from the database
    and into Product objects was encapsulated in the ProductRepository class, front-controller
    logic was placed in an Application class, and logic for displaying simple pages
    was located in the DefaultController class. Actions relating to requests for one
    or many products went into the ProductController class, which used ProductRepository
    methods to query the database.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据库模式整合到一个组织良好的多页面Web应用程序中。管理数据库连接的代码被抽象到合适的类中，无论是Database类还是SQLiteDatabase类，使得我们可以在MySQL和SQLite之间无缝切换，作为应用程序的数据库管理系统（DBMS）。从数据库中检索数据并将其转换为Product对象的逻辑被封装在ProductRepository类中，前端控制器逻辑被放置在Application类中，而用于显示简单页面的逻辑则位于DefaultController类中。与请求单个或多个产品相关的操作放入ProductController类，该类使用ProductRepository方法查询数据库。
- en: This architecture could easily be scaled up, with additional repository, model,
    and controller classes for other database tables (users, customers, orders, suppliers,
    and so on). The entire application was styled using Twig templating, with a base
    (parent) template to efficiently share common page elements across all the individual
    child templates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该架构可以轻松扩展，增加额外的存储库、模型和控制器类，以支持其他数据库表（用户、客户、订单、供应商等）。整个应用程序使用 Twig 模板引擎进行样式设计，并使用一个基础（父）模板来有效地共享所有单独子模板中的公共页面元素。
- en: Exercises
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '1.   Create a new model class called Book with the following properties:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   创建一个名为 Book 的新模型类，包含以下属性：
- en: id (integer), an auto-incrementing primary key
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: id（整数），自增长的主键
- en: title (string)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: title（字符串）
- en: author (string)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: author（字符串）
- en: price (float)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: price（浮动）
- en: 'Create a setup script (based on [Listings 28-1](#lis28-1) and [28-2](#lis28-2))
    to create a database with a book table, mapped to the Book class’s properties
    and types (use int, text, and float for the SQL data types). Also insert at least
    two book records into the database table with title, author, and price properties
    of your choice. Then write an object-oriented project (or adapt the example from
    this chapter) to retrieve and list all the books from the database. The project
    should include the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个设置脚本（基于 [Listings 28-1](#lis28-1) 和 [28-2](#lis28-2)），用于创建一个包含书籍表的数据库，并将其映射到
    Book 类的属性和类型（对于 SQL 数据类型使用 int、text 和 float）。同时，向数据库表中插入至少两条书籍记录，包含你选择的 title、author
    和 price 属性。然后编写一个面向对象的项目（或适应本章中的示例），从数据库中检索并列出所有书籍。该项目应包括以下内容：
- en: A Database class to create a connection to your database
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Database 类，用于创建与数据库的连接。
- en: A *public/index.php* script that creates an Application object and invokes its
    run() method
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *public/index.php* 脚本，它创建一个 Application 对象并调用其 run() 方法。
- en: An Application class with a run() method to get an array of Book objects and
    var_dump() them
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Application 类，带有 run() 方法，用于获取一组 Book 对象并使用 var_dump() 输出它们。
- en: Your Book model class
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Book 模型类
- en: '2.   Extend your project from Exercise 1 as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   如以下所示扩展你在练习 1 中的项目：
- en: a.   Add getter and setter accessor methods for each property in your Book class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: a.   为你的 Book 类中的每个属性添加 getter 和 setter 访问器方法。
- en: b.   Change your Application logic to test for an action variable in the URL.
    The default action should be to display a home page using an appropriate template.
    If the action is books, the application should display a page with information
    about all the books, using an appropriate template.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: b.   更改你的 Application 逻辑，以测试 URL 中的 action 变量。默认的 action 应该是使用适当的模板显示首页。如果 action
    是 books，应用程序应显示一个包含所有书籍信息的页面，使用适当的模板。
