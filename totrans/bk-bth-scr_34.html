<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch31" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch31">
<span class="cn"><span aria-label=" Page 375. " epub:type="pagebreak" id="pg_375" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">31</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">TROUBLESHOOTING TIPS AND TESTING TECHNIQUES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">When I first started to share with a small number of friends and colleagues the fact that I was writing the book that you are now holding, what they wanted to see in it more than anything was a chapter on testing and troubleshooting because of the unique development challenges posed by Batch.</p>
<p class="tx">I’ve mentioned often that there’s no Batch compiler, and maybe this goes without saying, but there’s no animator or debugger either. Stepping through some Batch commands, stepping over others, setting breakpoints, and inspecting or modifying variables are pure fantasy, or a very bad novel in the making (or maybe my next project). There are two steps in the lifecycle of Batch code: it’s written, and it’s executed. That’s the list; there’s no compilation and no animation. But this doesn’t mean you can’t test bat files. In fact, it makes testing all the more crucial.</p>
<p class="tx"><span aria-label=" Page 376. " epub:type="pagebreak" id="pg_376" role="doc-pagebreak"/>In this chapter, I’ll step through a number of tips, discussing the various techniques I’ve learned and developed over my years of coding Batch applications, small and large.</p>
<p class="tx">(If the alliterative title doesn’t sit well with you, be thankful that I pared it down from “Tantalizingly Tidy Troubleshooting Tips and Timeless Testing Techniques”—a veritable tsunami of Ts.)</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-201"/><span class="sans_futura_std_bold_b_">Capture stdout and stderr</span></h3>
<p class="tni">Without a doubt, the first step in testing and troubleshooting any bat file is capturing stdout and stderr to a trace file. While other languages offer an animator, Batch offers the next best thing—a detailed accounting of the results of most every command as each one executes. In some limited ways the trace might even be better than animation. It’s true that you can’t step through the code and manipulate variables as the bat file executes, but you can see the value of variables throughout the run and easily go in the reverse direction by simply scrolling up.</p>
<p class="tx">However, the trace can be daunting. If a loop executes 1,000 times, all 1,000 executions are in the trace file, possibly spanning tens of thousands of lines. For this reason, most tips in this chapter will revolve around how to interpret the trace. The information in it is so invaluable, if you don’t remember how to capture stdout and stderr, return to <span class="xref"><a href="chapter12.xhtml" class="calibre3">Chapter 12</a></span> and reacquaint yourself with the process before reading on.</p>
<p class="tx">Now that you can capture the trace, being able to read it is paramount.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h" id="sec2"><span id="h1-202"/><span class="sans_futura_std_bold_b_">How to Navigate the Trace</span></h3>
<p class="tni">Always navigate the trace while referencing the bat file or files that generated it. It’s exceedingly easy to get lost in the trees of the trace file, and the original Batch code contains the map of the forest. This tip might seem obvious, but at times the trace may bear little resemblance to the bat code. For instance, in the trace you might see <span class="sans_thesansmonocd_w5regular_">myVar</span> being set like so:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;set myVar=finalValue</code></pre>
<p class="tni">But that doesn’t tell you whether <span class="sans_thesansmonocd_w5regular_">finalValue</span> was hardcoded or set by other means, such as resolved from an <span class="sans_thesansmonocd_w5regular_">intermediate</span> variable. The original bat file will, however:</p>
<pre class="pre"><code class="calibre11">set myVar=%intermediate%</code></pre>
<p class="tx">Also, traces can become so long and dense that performing a search is the only reasonable means of finding the desired section of output, but doing so can be trickier than you might imagine. Consider this code:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 377. " epub:type="pagebreak" id="pg_377" role="doc-pagebreak"/>rem Execute the Database Purge Program
  %_pgmPurgeDB%
  if %errorlevel% neq 0 (
     set errorMsg=The Database Purge Program Failed
     goto :Abort
  )
</code></pre>
<p class="tx">The resulting trace might appear like so:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;rem Execute the Database Purge Program 

C:\Batch&gt;DatabasePurge.exe

C:\Batch&gt;if 0 NEQ 0 (
set errorMsg=The Database Purge Program Failed 
 goto :Abort 
)
</code></pre>
<p class="tx">The interpreter shows the variables as resolved, so you can’t find this section of the trace by searching for the <span class="sans_thesansmonocd_w5regular_">_pgmPurgeDB</span> variable name from the bat file. Several sections of the code often look similar. For instance, multiple programs might execute, trailed by similar error handling.</p>
<p class="tx">The two most readily identifiable portions of this Batch code are the remark and error message. Let’s take advantage of these bits of hardcoded text. To manage this issue, make sure that each program has a unique remark before it and/or a unique error message in the error handling code block after it. Now to find this section of the code in the trace, just copy the remark or error message from the bat file and search for it in the trace. And you’ll be documenting your code to boot—a true win-win scenario.</p>
<p class="tx">Successful executions are similar and boring, but failures are often unique and interesting. Let’s execute the same code again, but this time imagine a user has asked us to investigate why the database wasn’t purged despite the apparent success of the bat file’s execution. The clues are in the trace:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;rem Execute the Database Purge Program 

C:\Batch&gt;if 0 NEQ 0 (
set errorMsg=The Database Purge Program Failed 
 goto :Abort 
)
</code></pre>
<p class="tx">First comes the comment. Then the <span class="sans_thesansmonocd_w5regular_">errorlevel</span> variable resolves to <span class="sans_thesansmonocd_w5regular_">0</span> in the conditional clause of the <span class="sans_thesansmonocd_w5regular_">if</span> command, so the program must’ve executed successfully, right? No, this only means that the last process to set the variable set it to <span class="sans_thesansmonocd_w5regular_">0</span>. Was that last process the executable? Hold on ... where’s the executable? It isn’t showing up in the trace after the remark. That’s a clue.</p>
<p class="tx">This demonstrates why it’s so important to reference the original Batch code when reading the trace and doing so line by line by line. Doing that clearly exposes the missing content, which in this case is a program <span aria-label=" Page 378. " epub:type="pagebreak" id="pg_378" role="doc-pagebreak"/>invocation. Without the original bat file, it would’ve been very difficult to see that something was missing.</p>
<p class="tx">Getting back to our specific issue, its proximate cause is probably the variable for the program resolving to null or to one or more spaces, but what’s the root cause? Maybe the variable was misspelled in this code; maybe someone misspelled it earlier when defining it; maybe it was never defined at all; maybe some other process wiped it out. (But maybe someone prefixed the contents of <span class="sans_thesansmonocd_w5regular_">_pgmPurgeDB</span> with <span class="sans_thesansmonocd_w5regular_">@</span>, thus suppressing the executable name from the trace even though it did execute, or maybe I’m overthinking this.) What you can be assured of is that the execution of the program isn’t showing up in the trace, and that with a little more digging you’ll find the actual root cause.</p>
<p class="tx">Remember, this is uncompiled code; using an undefined variable is the type of issue a compiler would catch, but Batch coders don’t have that luxury.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="h" id="sec3"><span id="h1-203"/><span class="sans_futura_std_bold_b_">Don’t Be Fooled by the Ghost Trace</span></h3>
<p class="tni">I’ve witnessed more than one novice Batch coder fixating on a portion of the trace similar to the following example, convinced that the program failed:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;if 0 NEQ 0 (
set errorMsg=The Database Purge Program Failed 
 goto :Abort 
)
</code></pre>
<p class="tx">After all, the trace clearly shows a line with the <span class="sans_thesansmonocd_w5regular_">errorMsg</span> variable being set to a string definitively stating that the program failed, but this is part of the “ghost trace.” The line above the message contains the <span class="sans_thesansmonocd_w5regular_">if</span> command and the conditional clause that triggers the logic: <span class="sans_thesansmonocd_w5regular_">if 0 NEQ 0</span>. This is false; hence, the code block didn’t execute, and any apparent execution is an apparition. If an <span class="sans_thesansmonocd_w5regular_">else</span> keyword and code block had been present, the code in that code block would have executed, but in this instance, after the interpreter evaluated the <span class="sans_thesansmonocd_w5regular_">if</span> command, control skipped to whatever came after the code block.</p>
<p class="tx">For better or worse, the interpreter doesn’t suppress such unexecuted code blocks. Not everything in the trace actually executed. If a command in the code block generates output to stdout, the existence or nonexistence of that output in the trace verifies whether it executed. Many times, however, nothing in the code block generates output, so you must behave like the interpreter and attempt to evaluate the conditional clause.</p>
<p class="tx">Frustratingly, even this has limitations. You can’t always evaluate the results of some conditional clauses from the trace. For example, an <span class="sans_thesansmonocd_w5regular_">if exist</span> command determining the presence of a file is impossible to evaluate from just the conditional clause in the trace. You have little means of knowing whether the file existed when the code executed or whether connectivity to the file was momentarily lost.</p>
<p class="tx"><span aria-label=" Page 379. " epub:type="pagebreak" id="pg_379" role="doc-pagebreak"/>If the code branches significantly, you can infer the result of the <span class="sans_thesansmonocd_w5regular_">if</span> command from what happens next in the trace. For instance, if that error message had been set, control would have immediately jumped to the <span class="sans_thesansmonocd_w5regular_">:Abort</span> label due to the <span class="sans_thesansmonocd_w5regular_">goto</span> command. Ask yourself if the next few lines in the trace look like the code under this label or the code after the code block. (This is another reason for one of those descriptive remarks I mentioned earlier.) However, if the code in the code block does nothing more than set a variable or two, you’ll be hard-pressed to determine whether it actually executed given the trace (although the next tip might help).</p>
<p class="tx">If nothing else, you can begin the code block that executes when the conditional clause is true with an <span class="sans_thesansmonocd_w5regular_">echo true</span> command. I hesitate to suggest this inelegant cluttering of the code, but this writes the <span class="sans_thesansmonocd_w5regular_">true</span> text, or whatever text you desire, to the trace immediately after the execution of the <span class="sans_thesansmonocd_w5regular_">if</span> command, but only if the code block executes, definitively showing the result of the <span class="sans_thesansmonocd_w5regular_">if</span> command. For instance:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;if exist C:\Batch\MysteryFile.txt (
echo true 
 set errorMsg=The Database Purge Program Failed 
 goto :Abort 
) 
true
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">echo true</span> command in the code block always finds its way into the trace. After all, the point of this tip is that the ghost trace contains unexecuted commands. But the <span class="sans_thesansmonocd_w5regular_">true</span> text coming immediately after the close parenthesis shows that the code block executed and that the mystery file definitely existed at the time the <span class="sans_thesansmonocd_w5regular_">if</span> command looked for it.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="h" id="sec4"><span id="h1-204"/><span class="sans_futura_std_bold_b_">Create an Audit Trail of Variables</span></h3>
<p class="tni">An audit trail of all the variables set, reset, or unset during the execution of a bat file can greatly aid your troubleshooting. As mentioned in the prior tip, this might be the only way to know whether a code block executed. To this end, near the beginning of a long-running bat file, I usually add the following two lines:</p>
<pre class="pre"><code class="calibre11">rem - All Variables in Effect Before Execution:
  set
</code></pre>
<p class="tx">This one simple command, the <span class="sans_thesansmonocd_w5regular_">set</span> command with no arguments, writes all existing variables to the captured trace. At the end of the same process, you can execute the same command but with a refence to <span class="sans_thesansmonocd_w5regular_">After Execution</span> in the remark.</p>
<p class="tx">The remarks make both lists of all populated variables easy to find. The initial command details all variables set on the machine as the execution begins, and the latter shows what changed during the execution. You can do this only when debugging or as an audit trail for every execution.</p>
<p class="tx"><span aria-label=" Page 380. " epub:type="pagebreak" id="pg_380" role="doc-pagebreak"/>I more than hinted at this technique in <span class="xref"><a href="chapter29.xhtml" class="calibre3">Chapter 29</a></span> in relation to arrays and hash tables. You might populate these data structures by various means, and it doesn’t take many entries for the building of these data structures to make a mess of the trace. In that chapter, I recommended dumping the contents of an array or hash table to the trace with a more targeted <span class="sans_thesansmonocd_w5regular_">set</span> command. For instance, we built a hash table by the name of <span class="sans_thesansmonocd_w5regular_">people</span>. Since every entry in the data structure starts with <span class="sans_thesansmonocd_w5regular_">people{</span>, the following command displayed the entire contents of the hash table after the load or at any other point in the process flow:</p>
<pre class="pre"><code class="calibre11">rem - The Contents of people{key}:
  set people{
</code></pre>
<p class="tx">Similarly, if your convention is to prepend all variables containing an executable program with the <span class="sans_thesansmonocd_w5regular_">_prog</span> text, the following displays the complete list of all such variables:</p>
<pre class="pre"><code class="calibre11">rem - All Program Variables:
  set _prog
</code></pre>
<p class="tx">The command without an argument works best at the start and end of a long process because it provides you with the global set of variables, and the targeted command works great for a shorter list of variables at strategic locations in a bat file, perhaps just after some tricky code.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="h" id="sec5"><span id="h1-205"/><span class="sans_futura_std_bold_b_">Understand the stdout of the for Command</span></h3>
<p class="tni">The complexity of the trace generated by a <span class="sans_thesansmonocd_w5regular_">for</span> command grows in relation to the complexity of the <span class="sans_thesansmonocd_w5regular_">for</span> command itself, but even a simple example demonstrates what can be a common misconception. The following code is from <span class="xref"><a href="chapter18.xhtml" class="calibre3">Chapter 18</a></span>, but instead of summing the integers from <span class="sans_thesansmonocd_w5regular_">1</span> to <span class="sans_thesansmonocd_w5regular_">100</span>, it sums the integers from <span class="sans_thesansmonocd_w5regular_">1</span> to the number defined by the <span class="sans_thesansmonocd_w5regular_">count</span> variable:</p>
<pre class="pre"><code class="calibre11">for /L %%i in (1,1,%count%) do (
  set /A sum += %%i
)
</code></pre>
<p class="tx">To cut down on the length of the trace, assume that <span class="sans_thesansmonocd_w5regular_">count</span> is set to <span class="sans_thesansmonocd_w5regular_">3</span>, meaning that it executes three times even though the following trace shows four <span class="sans_thesansmonocd_w5regular_">set</span> commands:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;for /L %i in (1 1 3) do (set /A sum += %i) 

C:\Batch&gt;(set /A sum += 1) 

C:\Batch&gt;(set /A sum += 2)

C:\Batch&gt;(set /A sum += 3)
</code></pre>
<p class="tx"><span aria-label=" Page 381. " epub:type="pagebreak" id="pg_381" role="doc-pagebreak"/>The first line is the entire <span class="sans_thesansmonocd_w5regular_">for /L</span> command—but <i class="calibre6">not</i> its execution. Notice that <span class="sans_thesansmonocd_w5regular_">count</span> along with the encasing percent signs resolves to <span class="sans_thesansmonocd_w5regular_">3</span> in the input and that both references to <span class="sans_thesansmonocd_w5regular_">%%i</span> have changed to <span class="sans_thesansmonocd_w5regular_">%i</span>. This is actually how you would enter the variable in a <span class="sans_thesansmonocd_w5regular_">for</span> command at the command prompt, and for whatever reason this is how it appears in stdout. The next three lines show the three actual executions of the code block with the <span class="sans_thesansmonocd_w5regular_">for</span> variable resolved to <span class="sans_thesansmonocd_w5regular_">1</span>, <span class="sans_thesansmonocd_w5regular_">2</span>, and <span class="sans_thesansmonocd_w5regular_">3</span>, respectively.</p>
<p class="tx">Because variables such as <span class="sans_thesansmonocd_w5regular_">count</span> are resolved in the first line, it can appear to be an actual execution. This is especially true with more involved examples using complex code blocks or many more executions of the loop. But understand that it’s just an informational setup for the executions yet to come. Think of it as an inarticulate introduction to a book, with chapters to follow, one for each execution of the loop.</p>
<p class="tx">The next tip demonstrates another source of confusion concerning the trace of the <span class="sans_thesansmonocd_w5regular_">for</span> command.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="h" id="sec6"><span id="h1-206"/><span class="sans_futura_std_bold_b_">How to Interpret Unresolved Variables</span></h3>
<p class="tni">This is very frustrating, but the interpreter resolves some variables in the trace, but not others. In the last tip I teased that the trace of the <span class="sans_thesansmonocd_w5regular_">for</span> command can get quite complex, and it doesn’t take much. To demonstrate, here’s a different take on a file that I used frequently when discussing the <span class="sans_thesansmonocd_w5regular_">for /F</span> command in <span class="xref"><a href="chapter19.xhtml" class="calibre3">Chapter 19</a></span>. I’m doing nothing more than putting the entire record of a file into a variable and writing that record to both stdout and the console:</p>
<pre class="pre"><code class="calibre11">for /F "tokens=*" %%r in (C:\Batch\FourBrits.txt) do (
   set inRec=%%r
   echo Writing to Stdout: !inRec!
   &gt; con echo Writing to the Console: !inRec!
)
</code></pre>
<p class="tni">(If you’re asking why I didn’t simply directly write the <span class="sans_thesansmonocd_w5regular_">%%r</span> token instead of incorporating the superfluous <span class="sans_thesansmonocd_w5regular_">inRec</span> variable, I’m demonstrating the resulting trace of a variable set and used inside a <span class="sans_thesansmonocd_w5regular_">for</span> command’s code block with as little else going on as possible. This condition occurs naturally and often with even moderately complex logic.)</p>
<p class="tx">As in the last tip, the trace first shows the <span class="sans_thesansmonocd_w5regular_">for</span> command largely, but not entirely, unchanged compared to the actual code. But in contrast, the interpreter displays this more complex command and its associated code block on multiple lines, making it easier to read:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;for /F "tokens=*" %r in (C:\Batch\FourBrits.txt) do (
set inRec=%r
 echo Writing to Stdout: !inRec! 
 echo Writing to the Console: !inRec! 1&gt;con
) 
</code></pre>
<p class="tx"><span aria-label=" Page 382. " epub:type="pagebreak" id="pg_382" role="doc-pagebreak"/>Next, the first record in the files generates the following in the trace. Everything inside the parentheses is the code being executed, while the last line is the result of the first <span class="sans_thesansmonocd_w5regular_">echo</span> command:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;(
set inRec=English   John      Paul      George    Richard 
 echo Writing to Stdout: !inRec! 
 echo Writing to the Console: !inRec! 1&gt;con 
) 
Writing to Stdout: English   John      Paul      George    Richard
</code></pre>
<p class="tni">By the way, each record in the file generates something very similar to this, so you can see how the trace can get very big very quickly; 100 records would have generated 600 lines of text.</p>
<p class="tx">The previous trace clearly shows the input record resolved from <span class="sans_thesansmonocd_w5regular_">%%r</span> and its assignment to the <span class="sans_thesansmonocd_w5regular_">inRec</span> variable, but—and this is important—the next two lines of the trace don’t show the resolution of <span class="sans_thesansmonocd_w5regular_">!inRec!</span> at all. Was it set and resolved correctly? In this instance, I use it in the first <span class="sans_thesansmonocd_w5regular_">echo</span> command to clearly show the contents of the variable in the trailing line of output, but you can’t see many other usages of the variable in the trace. For example, the second <span class="sans_thesansmonocd_w5regular_">echo</span> command is writing the same text to the console, but it doesn’t appear in the trace. (Think of this as the opposite of the ghost trace.)</p>
<p class="tx">Simply put, any variable assigned inside a code block and resolved with exclamation marks, also inside the code block, presents as the variable name surrounded by exclamation marks, that is, unresolved. When executed, it resolves as expected, but the trace gives you no indication of this fact.</p>
<p class="tx">This is an immensely unnerving batveat. There are nearly countless reasons to set and use a variable inside of the code block of a <span class="sans_thesansmonocd_w5regular_">for</span> command—and this is usually where the most interesting code resides—but what’s happening is lost into the ether. Delayed expansion, executed inside and outside of code blocks, is another victim of this issue.</p>
<p class="tx">There are a few ways to handle this. The first is do nothing at all; once this behavior is understood, a good coder can navigate these idiosyncrasies with the knowledge that they need to perform a certain amount of extrapolation to read the trace.</p>
<p class="tx">Second, strategically placed <span class="sans_thesansmonocd_w5regular_">echo</span> commands can show the results of a few lines of logic. You can write the text to the console for troubleshooting (more on this to come) or simply to the trace file. That’s in effect what I did in the prior listing with the first <span class="sans_thesansmonocd_w5regular_">echo</span> command.</p>
<p class="tx">Third, if the line-by-line results of each command are required, you can move the interesting code block to a called routine and invoke it with a <span class="sans_thesansmonocd_w5regular_">call</span> command, passing the needed tokens as arguments. The routine can then treat the tokens like parameters with the upshot being functionally equivalent code that’s now fully resolved in the trace.</p>
<p class="tx">I have some professional history with this issue. After implementing a very involved nested <span class="sans_thesansmonocd_w5regular_">for</span> structure culminating in the rename of a file, some <span aria-label=" Page 383. " epub:type="pagebreak" id="pg_383" role="doc-pagebreak"/>continually raised questions as to whether the rename actually occurred. To ultimately settle the debate, I rewrote the code using a called routine. Unfortunately, we all must compromise elegance for functionality at times.</p>
<p class="tx">As a side note, this trace contains some oddities. The first line inside the code block has no indenting, and the others are indented one space, regardless of the indentation in the bat file. The redirection syntax, <span class="sans_thesansmonocd_w5regular_">&gt; con</span>, precedes the <span class="sans_thesansmonocd_w5regular_">echo</span> command in the bat file, but in the trace, it’s moved to the end. I can’t explain these discrepancies, but I know they exist, and we must come to accept that what’s in the trace is a tortured rendering of the actual code.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="h" id="sec7"><span id="h1-207"/><span class="sans_futura_std_bold_b_">Recognize Inconsistent Command Outputs</span></h3>
<p class="tni">Due to the vagaries of Batch, the messages produced from command to command varies, thus compounding the already nasty batveat from the prior tip. For example, if an <span class="sans_thesansmonocd_w5regular_">xcopy</span> command executes inside of a code block using variables set and resolved in the code block, the trace won’t show the resolved filename or names in the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command. But if you use the <span class="sans_thesansmonocd_w5regular_">/F</span> option, the command writes a clear message to the trace detailing the result of the command, listing the file or files copied.</p>
<p class="tx">In contrast, a similar <span class="sans_thesansmonocd_w5regular_">ren</span> command produces no message from a successful rename, meaning that you can rename a file with no mention of it in the trace other than a <span class="sans_thesansmonocd_w5regular_">ren</span> command with unresolved filenames. A failed <span class="sans_thesansmonocd_w5regular_">ren</span> command writes a generic error message to stderr, but unlike the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, it doesn’t contain the filename. The end result is that if a failed <span class="sans_thesansmonocd_w5regular_">ren</span> command uses exclamation marks inside a <span class="sans_thesansmonocd_w5regular_">for</span> loop or it uses delayed expansion, an error message states that the rename failed without noting the file or giving any other information.</p>
<p class="tx">With experience you’ll learn what output to expect and when to expect it from commands that you commonly use. For other commands, expect the unexpected.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="h" id="sec8"><span id="h1-208"/><span class="sans_futura_std_bold_b_">Write Variables to the Console</span></h3>
<p class="tni">Unless you’ve skipped directly to this chapter and to this tip, you’re more than familiar with an <span class="sans_thesansmonocd_w5regular_">echo</span> command redirecting its output to the console via the <span class="sans_thesansmonocd_w5regular_">&gt; con</span> syntax. I’ve used the technique many times to show the results of code listings, and it’s very handy when troubleshooting, especially for complex <span class="sans_thesansmonocd_w5regular_">for</span> loops.</p>
<p class="tx">The trace can be both cryptic and large, which isn’t a good combination for readability. To tease out just the important data, I often place a temporary redirected <span class="sans_thesansmonocd_w5regular_">echo</span> command inside a loop to see the state of one or more variables during each pass.</p>
<p class="tx">For instance, the logic to add up a series of integers in “<span class="xref">Understand the stdout of the</span> <span class="sans_thesansmonocd_w5regular_">for</span> <span class="xref">Command</span>” on page 380 is difficult to test, because while we see the <span class="sans_thesansmonocd_w5regular_">sum</span> variable being set, we never see it resolved in any of the iterations of the loop in the trace. You won’t see the value of <span class="sans_thesansmonocd_w5regular_">sum</span> until you use it <span aria-label=" Page 384. " epub:type="pagebreak" id="pg_384" role="doc-pagebreak"/>somewhere in the code after the loop, but if you aren’t getting the expected result, you’ll likely want to see those lost intermediate values. You can add a single line to the summation code so as to get a summation of events. See if you can spot it:</p>
<pre class="pre"><code class="calibre11">  for /L %%i in (1,1,%count%) do (
      set /A sum += %%i
&gt; con echo ---- index = %%i ---- sum = !sum! -----
  )
</code></pre>
<p class="tni">Assume that <span class="sans_thesansmonocd_w5regular_">count</span> is set to <span class="sans_thesansmonocd_w5regular_">4</span> before this executes; the final <span class="sans_thesansmonocd_w5regular_">sum</span> should be <span class="sans_thesansmonocd_w5regular_">10</span>, but we’re getting <span class="sans_thesansmonocd_w5regular_">35</span>.</p>
<p class="tx">The trace still hasn’t gone anywhere if you need more detail, but the additional command writes the following plain and comprehensive text to the console. The variables are labeled clearly, and the dashes just make them stand out and look nice:</p>
<pre class="pre"><code class="calibre11">---- index = 1 ---- sum = 26 -----
---- index = 2 ---- sum = 28 ----- 
---- index = 3 ---- sum = 31 ----- 
---- index = 4 ---- sum = 35 -----
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">index</span> variable should increment (no surprise there), but a close inspection of the <span class="sans_thesansmonocd_w5regular_">sum</span> variable for each entry reveals the issue. The code never initialized <span class="sans_thesansmonocd_w5regular_">sum</span>, and it can be <span class="sans_thesansmonocd_w5regular_">26</span> in the first line only if it were <span class="sans_thesansmonocd_w5regular_">25</span> coming into the loop. An earlier process must be using the same generically named variable. After adding a quick <span class="sans_thesansmonocd_w5regular_">set</span> command initializing the variable to <span class="sans_thesansmonocd_w5regular_">0</span>, the code displays the following:</p>
<pre class="pre"><code class="calibre11">---- index = 1 ---- sum = 1 -----
---- index = 2 ---- sum = 3 ----- 
---- index = 3 ---- sum = 6 ----- 
---- index = 4 ---- sum = 10 -----
</code></pre>
<p class="tx">Another close inspection of the <span class="sans_thesansmonocd_w5regular_">sum</span> variable now reveals that all is working as intended; that is, the prior <span class="sans_thesansmonocd_w5regular_">sum</span> plus the current <span class="sans_thesansmonocd_w5regular_">index</span> does in fact equal the current <span class="sans_thesansmonocd_w5regular_">sum</span> in every entry after the first, where it’s just <span class="sans_thesansmonocd_w5regular_">1</span>. Once the testing and troubleshooting is complete, you can and should delete the <span class="sans_thesansmonocd_w5regular_">echo</span> command before moving on.</p>
<p class="tx">I’ve demonstrated this technique on one of the simplest <span class="sans_thesansmonocd_w5regular_">for</span> commands possible, but <span class="sans_thesansmonocd_w5regular_">for</span> commands can quickly become opaque. A simple redirected <span class="sans_thesansmonocd_w5regular_">echo</span> command or two can quickly and easily generate a synopsis of some tricky and repetitive logic to greatly aid your troubleshooting.</p>
<p class="tx">In <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span>, I expressed some very definitive views on indenting that I appear to have flouted with this <span class="sans_thesansmonocd_w5regular_">echo</span> command. As a quick recap, remarks have no indent, labels are indented one byte, and everything else is indented two bytes or more. In my opinion this is a must for the finished product, but this particular <span class="sans_thesansmonocd_w5regular_">echo</span> command is temporary, and it’s best to make that obvious. Otherwise, there’s a good chance that you unnecessarily <span aria-label=" Page 385. " epub:type="pagebreak" id="pg_385" role="doc-pagebreak"/>and accidentally leave it in the code. This gaudy unindented command is all but begging to be deleted.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="h" id="sec9"><span id="h1-209"/><span class="sans_futura_std_bold_b_">Decipher Different Types of Syntax Errors</span></h3>
<p class="tni">The interpreter writes two general types of error messages to stderr: errors generated by a command and syntax errors. Failed <span class="sans_thesansmonocd_w5regular_">xcopy</span> or <span class="sans_thesansmonocd_w5regular_">del</span> commands display the command itself in the trace followed by a clear error message stating why it couldn’t copy or delete a file.</p>
<p class="tx">Unfortunately, syntax errors don’t present consistently. One example of a syntax error is the use of the nonexistent <span class="sans_thesansmonocd_w5regular_">and</span> operator in a conditional clause. As mentioned in <span class="xref"><a href="chapter27.xhtml" class="calibre3">Chapter 27</a></span>, the interpreter might just ignore it and go on to execute whatever’s in the code block without even writing a message to stderr. A slightly different conditional clause with the same bad operator might write the <span class="sans_thesansmonocd_w5regular_">if</span> command to the trace followed by an error message:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;if "" NEQ "A" and "" equ "B" (
'and' is not recognized as an internal or external command,
operable program or batch file.
</code></pre>
<p class="tni">But this still plows ahead executing the code block and beyond. By the way, the text of this error message means that the interpreter is mistakenly trying to execute something in the command as if it were a program, but it’s often a syntax error instead.</p>
<p class="tx">There’s at least one more way that syntax errors can manifest themselves. To demonstrate, let’s consider this slightly modified version of the code discussed earlier in this chapter that does little more than execute a program and check the return code:</p>
<pre class="pre"><code class="calibre11">%_pgmPurgeDB%
if %errorlevel% neq 0
   set errorMsg=The Database Purge Program Failed
   goto :Abort
)
</code></pre>
<p class="tx">As simple as this code appears to be, the execution crashes, and the command window closes, leaving the following text at the bottom of the trace:</p>
<pre class="pre"><code class="calibre11">C:\Batch&gt;DatabasePurge.exe
The syntax of the command is incorrect.

C:\Batch&gt;  if 0 neq 0
</code></pre>
<p class="tx">A pessimist might point out that the generic error message is completely devoid of details. An optimist might point out that the interpreter definitively informs you of a syntax error, but when you begin to analyze the message, you realize that its digital author is unintentionally sinister.</p>
<p class="tx">The error message stating that the syntax is incorrect immediately follows the execution of the program; there isn’t even a blank line between <span aria-label=" Page 386. " epub:type="pagebreak" id="pg_386" role="doc-pagebreak"/>them. It certainly suggests that the preceding line has the bad syntax. But no, the interpreter is something of a fortune teller. It’s stating that the following line—the one separated by a blank line—is the source of the gaffe, even though it looks like an uncontroversial <span class="sans_thesansmonocd_w5regular_">if</span> command.</p>
<p class="tx">To recap, syntax errors sometimes write an error message to the trace, and sometimes they don’t. Sometimes the interpreter blows past syntax errors, executing the commands coming next, and sometimes it doesn’t. Error messages sometimes come after the offending command, and sometimes they come before. My best advice is to find the general vicinity of the error. Look at the code before and after the message and avoid tunnel vision.</p>
<p class="tx">Before moving on, what’s wrong with the syntax in that <span class="sans_thesansmonocd_w5regular_">if</span> command anyway? This is where a compiler giving a succinct and pointed error message would be manna from heaven, but we’re armed with little more than our wits and an interpreter that has shrugged its binary shoulders and said, “Something’s wrong. Figure it out.” A heads-down interrogation of the line of code following it reveals a command name nearly impossible to misspell, <span class="sans_thesansmonocd_w5regular_">if</span>; a valid operator, <span class="sans_thesansmonocd_w5regular_">neq</span>; and two numbers to compare. D’oh! The open parenthesis is missing.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="h" id="sec10"><span id="h1-210"/><span class="sans_futura_std_bold_b_">Modularize Wherever Possible</span></h3>
<p class="tni">The act of creating small bat files that perform definitive tasks has many benefits, not least among them is testing. You can easily set up another bat file to call the new bat file many times with various input parameters, each time verifying any and all outputs, which can take the form of returned parameters, data written to the console, or some action, such as a copied file.</p>
<p class="tx">To see an example of this simply flip back to <span class="xref"><a href="chapter11.xhtml" class="calibre3">Chapter 11</a></span>. After building the <i class="calibre6">MadLib.bat</i> file, I called it several times with many different input parameters. Turning to <span class="xref"><a href="chapter29.xhtml" class="calibre3">Chapter 29</a></span>, if you’re creating an array or hash table in a section of code in an already large process, one option is to code it in the existing bat file. But most of the time, a far better option is to create a new called bat file with all of the interesting logic. Then you can test the new bat file quickly and repeatedly with <span class="sans_thesansmonocd_w5regular_">call</span> commands from another bat file to work out any bugs. Finally, you’ll need to do little more than add a <span class="sans_thesansmonocd_w5regular_">call</span> command or two to the existing bat file containing the larger process.</p>
<p class="tx">You’ll soon see more examples of this. In <span class="xref"><a href="chapter32.xhtml" class="calibre3">Chapter 32</a></span>, after creating an object-oriented bat file, I’ll invoke it with multiple <span class="sans_thesansmonocd_w5regular_">call</span> commands from another bat file. Then in <span class="xref"><a href="chapter33.xhtml" class="calibre3">Chapter 33</a></span>, I’ll create a single bat file to handle stacks. Subsequent calls to it will then push items onto the stack and pull items off the stack. Modularize whenever possible.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="h" id="sec11"><span id="h1-211"/><span aria-label=" Page 387. " epub:type="pagebreak" id="pg_387" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Test Snippets in a Test Bat File</span></h3>
<p class="tni">Unfortunately, sometimes modularization isn’t possible. A large application might need a tweak to an existing <span class="sans_thesansmonocd_w5regular_">for</span> command. If it’s in a large bat file that’s part of an even larger process, it’s probably impractical to incorporate the change into a new module. To complicate matters, the lack of a compiler greatly increases the chances of you introducing errors when making even the most trivial of changes. If this is a long-running process, it might take an hour or longer just to learn that you omitted a parenthesis, and more complex changes often require multiple rounds of the coding-testing-tweaking triumvirate. It would be far better to test just the code in question, being able to run it repeatedly and quickly.</p>
<p class="tx">What we need is a way to mimic the actual environment of the new or updated logic in a simple and controlled setting. As a means to this end, every computer I work on has a <i class="calibre6">C:\Batch\</i> folder containing a bat file named <i class="calibre6">Test.bat</i> with these complete contents, at least to start:</p>
<pre class="pre"><code class="calibre11">  @setlocal EnableExtensions EnableDelayedExpansion
  @call :GetTrace &gt; C:\Batch\Trace.txt 2&gt;&amp;1
  @pause
  goto :eof

 :GetTrace
rem --- Variables Set Prior to Code Snippet
rem --- Code Snippet Goes Here
rem --- Variables Set After to Code Snippet
  goto :eof
</code></pre>
<p class="tx">As it stands, this bat file will execute a very boring routine of three <span class="sans_thesansmonocd_w5regular_">rem</span> commands, capture stdout and stderr in a trace file, and hold the console open with the <span class="sans_thesansmonocd_w5regular_">pause</span> command. But this bat file is merely a shell. To test a code snippet from a larger bat file, paste it after the second <span class="sans_thesansmonocd_w5regular_">rem</span> command. Examples might include a complex <span class="sans_thesansmonocd_w5regular_">for</span> command or even a much longer snippet that builds and uses arrays while also reading from and writing to multiple files.</p>
<p class="tx">If the code expects certain variables to be set before the snippet executes, you can enter them as hardcoded values after the first <span class="sans_thesansmonocd_w5regular_">rem</span> command. If a file is to be read, mock one up and add its file connector in this section.</p>
<p class="tx">Similarly, if the process being tested is to set certain variables in the environment for later use, you can interrogate them with <span class="sans_thesansmonocd_w5regular_">echo</span> commands redirected to the console after the third <span class="sans_thesansmonocd_w5regular_">rem</span> command. Not only will you see these resolved variables on the console, but they’ll also be in the detailed trace (unless the issue of unresolved variables rears its head).</p>
<p class="tx"><span aria-label=" Page 388. " epub:type="pagebreak" id="pg_388" role="doc-pagebreak"/>To demonstrate, if you were to use this technique to test the summation logic detailed earlier in this chapter, you might update the internal routine in the shell bat file like so:</p>
<pre class="pre"><code class="calibre11"> :GetTrace
rem --- Variables Set Prior to Code Snippet
  set count=100
  
rem --- Code Snippet Goes Here
  for /L %%i in (1,1,%count%) do (
      set /A sum += %%i
  )

rem --- Variables Set After to Code Snippet
  &gt; con echo sum = %sum%
  goto :eof
</code></pre>
<p class="tx">The code to be tested goes in the middle section, but this is just the starting point. You’ll need to define the <span class="sans_thesansmonocd_w5regular_">count</span> variable before the core logic executes, and since the ultimate result of this code is the value of one variable, you’ll want to resolve and display <span class="sans_thesansmonocd_w5regular_">sum</span> to the console in the third section of the routine.</p>
<p class="tx">You can now test, tweak, retest, and tweak again quickly, efficiently, and often. This isn’t a final test, but once this testing is satisfactory, you can copy and paste the listing into the main process. Now you can perform a full end-to-end test with a high level of confidence.</p>
<p class="tx">I also use this very same bat file for testing the modularized code that I introduced in the prior tip. You can easily add one or more <span class="sans_thesansmonocd_w5regular_">call</span> commands of other bat files to the middle section, while still using the first section for setup and the third for validation. Cutting and pasting is never elegant, but without a doubt, testing snippets in a test bat file is supremely effective.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="h" id="sec12"><span id="h1-212"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">I cannot overstate the importance of mastering techniques for testing and troubleshooting Batch code. In this chapter, I plugged in the amplifier from <i class="calibre6">This Is Spinal Tap</i> and turned it up to 11. With these 11 tips, I demonstrated how I develop and maintain bat files. In one sentence: capture and be able to read the trace, write output to the console, modularize when possible, and use <i class="calibre6">Test.bat</i> whenever appropriate.</p>
<p class="tx">I’m sure that others have useful additions to this list, and I encourage you to seek them out. The only alternative to solid Batch testing is eventually giving up and writing some compiled code to perform a task that could’ve been done, and should’ve been done, with just a few lines of Batch.</p>
<p class="tx">The next chapter tackles an exciting and interesting coding methodology: object-oriented design, a topic that you may not currently associate with Batch, but soon will.</p>
</section>
</section>
</div></body></html>