<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch16" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch16">
<span class="CN"><span aria-label=" Page 277. " epub:type="pagebreak" id="pg_277" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">MONITORING AUTOMOTIVE ELECTRONICS WITH THE CAN BUS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">Cars use a complex network of electronics to monitor operations and control various functions, including engine management, temperature measurement, and window and lock controls. These electronics and devices communicate with each other over the <i>controller area network data bus (CAN bus)</i>.</p>
<p class="TX">In this chapter, you’ll learn to interface your Arduino with the CAN bus to monitor data from certain automotive electronics. You’ll set up and test an Arduino-to-CAN-bus data connection and then monitor and record real-time engine statistics for later analysis.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-119"/><samp class="SANS_Futura_Std_Bold_B_11">The CAN Bus</samp></h2>
<p class="TNI">You may be familiar with the SPI and I<sup>2</sup>C data buses. The CAN bus is a data bus that is used to connect the engine management computer with <span aria-label=" Page 278. " epub:type="pagebreak" id="pg_278" role="doc-pagebreak"/>other devices in a contemporary automobile. This reduces physical wiring between devices and allows you to connect an external device, such as a computer, a scanning tool, or your Arduino, to the automobile for monitoring operations.</p>
<p class="TX">For example, a car’s engine management computer reads sensors in the engine and braking system. Using the CAN bus, it then broadcasts the speed, engine RPM, temperature, and other data to the computer system that controls the dashboard display. When you press the button on a remote control to lock your car doors, the radio data transceiver receives the signal from the remote control and then likewise instructs the central locking controller unit via the CAN bus to lock all the doors.</p>
<p class="TX">The protocol used for communication over the CAN bus is called <i>On-Board Diagnostic II (OBDII)</i>, the second generation of the OBD protocol. You can use an Arduino and matching CAN bus shield to communicate with the bus to review car statistics.</p>
<p class="TX">Before progressing further, if you plan to build the projects for this chapter, check whether your car has a CAN bus and an OBDII connector, as some older cars will not. To do this, look around under the dashboard of your car. The connector will be in an out-of-the-way position; for example, it appears above the pedals in my Mitsubishi Outlander Sport/ASX, as shown in <a href="chapter16.xhtml#fig16-1">Figure 16-1</a>. If you can’t initially find your OBDII connector, you may have to refer to the manual provided by the manufacturer or the service manual.</p>
<figure class="IMG"><img alt="A PHOTO OF AN OBDII CONNECTOR UNDER A CAR DASHBOARD" class="img8" id="fig16-1" src="../images/fig16-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-1: An OBDII connector socket</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 279. " epub:type="pagebreak" id="pg_279" role="doc-pagebreak"/>When it comes time to connect a cable to the OBDII connector, hold the socket firmly with one hand as you insert the plug with your other hand. The socket is usually not mounted with much support, and if you’re not careful, you’ll risk breaking the support bracket.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-120"/><samp class="SANS_Futura_Std_Bold_B_11">Required CAN Bus Hardware</samp></h2>
<p class="TNI">For the projects in this chapter, you’ll need an Arduino shield such as PMD Way part 13479987, shown in <a href="chapter16.xhtml#fig16-2">Figure 16-2</a>. Whichever shield you choose, it must use the Microchip MCP2515 CAN controller and MCP2551 CAN transceiver ICs.</p>
<figure class="IMG"><img alt="A PHOTO OF THE CAN BUS SHIELD FOR ARDUINO" class="img4" id="fig16-2" src="../images/fig16-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-2: A CAN bus shield for Arduino</samp></p></figcaption>
</figure>
<p class="TX">Next, you’ll need a matching cable that runs from the vehicle’s OBDII port to the nine-pin plug on the shield, such as PMD Way part 717211, shown in <a href="chapter16.xhtml#fig16-3">Figure 16-3</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF AN OBDII-TO-DB9 FEMALE CABLE" class="img4" id="fig16-3" src="../images/fig16-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-3: An OBDII-to-shield cable</samp></p></figcaption>
</figure>
<p class="TX">Finally, you’ll need a way to power your Arduino. If you don’t have a laptop computer with enough battery life to last an hour or so, consider getting a USB power bank, as shown in <a href="chapter16.xhtml#fig16-4">Figure 16-4</a>.<span aria-label=" Page 280. " epub:type="pagebreak" id="pg_280" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF A USB POWER BANK" class="img5" id="fig16-4" src="../images/fig16-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-4: A USB power bank</samp></p></figcaption>
</figure>
<p class="TX">Alternatively, you could power your project using a USB cable and a car USB adapter, as shown in <a href="chapter16.xhtml#fig16-5">Figure 16-5</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF A CIGAR LIGHTER USB POWER ADAPTER" class="img5" id="fig16-5" src="../images/fig16-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-5: A car USB power adapter</samp></p></figcaption>
</figure>
<p class="TX">The OBDII connection may differ for each brand and model of car, so it’s a good idea to check with enthusiast forums for more information about your car before purchasing the hardware required for this chapter. For example, Mitsubishi owners could consult the forum at <a href="https://www.mitsubishi-forums.com"><i>https://<wbr/>www<wbr/>.mitsubishi<wbr/>-forums<wbr/>.com</i></a> and search for OBDII posts.</p>
<p class="TX">Once you have the required hardware, download the CAN bus library ZIP file from <a href="https://github.com/sparkfun/SparkFun_CAN-Bus_Arduino_Library/archive/master.zip"><i>https://<wbr/>github<wbr/>.com<wbr/>/sparkfun<wbr/>/SparkFun<wbr/>_CAN<wbr/>-Bus<wbr/>_Arduino<wbr/>_Library<wbr/>/archive<wbr/>/master<wbr/>.zip</i></a>. Open the Arduino IDE and select <b>Sketch</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Include Library</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Add ZIP Library</b> to install the library.</p>
<aside aria-labelledby="box2" class="box">
<h3 class="BoxTitle" id="box2"><span aria-label=" Page 281. " epub:type="pagebreak" id="pg_281" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">BEING SAFE WHEN WORKING WITH AUTOMOBILES</samp></h3>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Never wire directly from your car’s 12 V output to the Arduino since spikes in the power supply may damage your hardware setup. Using an external source means you can be sure of a smooth 5 V DC.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Moreover, when building the projects in this chapter, if you’re running your car in your garage, keep the door open to allow exhaust gases to escape freely. If you’re using a laptop computer while driving around to gather real-world data, don’t look at or use the laptop while you’re driving.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Also, note that this chapter is concerned with reading data from the CAN bus, not writing to it. There may be legislation in your area that doesn’t permit such modifications to a motor vehicle for safety reasons.</samp></p>
</aside>
<p class="TX">You’re now ready to test your hardware with a simple CAN bus data retrieval sketch.</p>
<p class="HeadProject"><span id="h1-121"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #47: Monitoring Engine Data</samp></p>
<p class="TNI">In this project, you’ll use the CAN bus shield to receive basic engine data and speed from the car’s engine control unit (ECU) and display this in the Arduino IDE’s Serial Monitor. This is a good way to check that the hardware is operating and increase familiarity with your car’s operating statistics.</p>
<p class="TX">Your project will monitor the following:</p>
<ul class="ul">
<li class="BL">Car speed</li>
<li class="BL">Engine RPM</li>
<li class="BL">Throttle position</li>
<li class="BL">Percentage of throttle application</li>
<li class="BL">Engine coolant temperature</li>
<li class="BL">Oxygen sensor voltage</li>
<li class="BL">Mass air flow (MAF) sensor values</li>
</ul>
<p class="TX">The ECU uses the oxygen sensor voltage to determine the amount of oxygen present in the engine exhaust gases, which indicates how fuel efficiently the engine is operating. Once your car’s MAF sensor measures the amount of air entering the engine, the ECU uses this value to determine the correct amount of fuel needed for optimal engine operation.</p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A CAN bus shield for Arduino</li>
<li class="BL">An OBDII-to-shield cable</li>
<li class="BL">A laptop computer (preferable but not required)</li>
</ul>
<p class="TX"><span aria-label=" Page 282. " epub:type="pagebreak" id="pg_282" role="doc-pagebreak"/>If you have a laptop computer running the Arduino IDE, you can use that to monitor the project’s output. Otherwise, you could set up a desktop computer in your garage. If neither of these is possible, skip to the next project.</p>
<p class="TX">To assemble the project, connect the CAN bus shield to the Arduino, the Arduino to the computer, and the CAN bus shield to the OBDII connector in the car. If your Arduino board has a full-sized USB socket, such as that shown in <a href="chapter16.xhtml#fig16-6">Figure 16-6</a>, it can rest against the solder joints of the CAN bus shield. If this is the case, place some paper between the two to insulate the Arduino from the shield.</p>
<figure class="IMG"><img alt="A PHOTO OF A CAN BUS SHIELD CONNECTED TO AN ARDUINO WITH A USB SOCKET BRUSHING SHIELD" class="img7" id="fig16-6" src="../images/fig16-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-6: An Arduino USB port contacting the CAN bus shield</samp></p></figcaption>
</figure>
<p class="TX">Enter and upload the sketch, and then make sure the car won’t move if you start the engine. Start the engine, open the Serial Monitor in the Arduino IDE, and set the data rate to 115,200 baud. After a few moments, the engine data should be displayed, as shown in <a href="chapter16.xhtml#fig16-7">Figure 16-7</a>.<span aria-label=" Page 283. " epub:type="pagebreak" id="pg_283" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF EXAMPLE ECU DATA CAPTURED WITH PROJECT #47" class="img8" id="fig16-7" src="../images/fig16-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-7: Example output from Project #47</samp></p></figcaption>
</figure>
<p class="TX">In the figure, the speed is greater than 0 km/h. That’s because I took the car for a drive with a passenger, who took the screenshot using a laptop. This test also demonstrates the potential differences in OBDII data between different cars: in the results shown in <a href="chapter16.xhtml#fig16-7">Figure 16-7</a>, you can see that I didn’t get any readings for the oxygen sensor voltage from the ECU.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-47"/>

<pre><code>// Project #47 - Monitoring engine data

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Canbus.h&gt;
int requestDelay = 100;
char buffer[456];

void setup()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Serial.begin(115200);
    // Initialize CAN bus shield with the required speed
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> if (Canbus.init(CANSPEED_500))
    {
        Serial.println("CAN initialization ok");
    } else
    {
        Serial.println("CAN initialization error");
        while (1) {}
    }
    delay(2000);
}

void loop()
{
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Canbus.ecu_req(VEHICLE_SPEED, buffer);
    Serial.print("Speed: ");
    Serial.print(buffer);
    delay(requestDelay);

    Canbus.ecu_req(ENGINE_RPM, buffer);
    Serial.print(", RPM: ");
    Serial.print(buffer);
    delay(requestDelay);

<span aria-label=" Page 284. " epub:type="pagebreak" id="pg_284" role="doc-pagebreak"/>    Canbus.ecu_req(THROTTLE, buffer);
    Serial.print(", Throttle: ");
    Serial.print(buffer);
    delay(requestDelay);

    Canbus.ecu_req(ENGINE_COOLANT_TEMP, buffer);
    Serial.print(", Coolant temp: ");
    Serial.print(buffer);
    delay(requestDelay);

    Canbus.ecu_req(O2_VOLTAGE, buffer);
    Serial.print(", o2 Voltage: ");
    Serial.print(buffer);
    delay(requestDelay);

    Canbus.ecu_req(MAF_SENSOR, buffer);
    Serial.print(" , MAF sensor: ");
    Serial.println(buffer);
    delay(requestDelay);
}
</code></pre>

<p class="TX">The sketch first includes the CAN bus library <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then creates two variables. The first is <samp class="SANS_TheSansMonoCd_W5Regular_11">requestDelay</samp>, which is used to create a delay after reading data from the CAN bus. You may need to alter this variable’s value depending on the car you’re using, but try 100 first. If the data returned doesn’t match the type or you’re not seeing any data at all, you will need to experiment with values that are higher or lower. The second variable is the large character array <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>, used to store data received over the CAN bus and then displayed in the Serial Monitor.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch initializes the serial output <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. It then starts CAN bus communication <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, also checking whether it’s possible to communicate between the Arduino and the CAN bus using the <samp class="SANS_TheSansMonoCd_W5Regular_11">if (Canbus.init (CANSPEED_500))</samp> function. The parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">CANSPEED_500</samp> sets the CAN bus shield-to-data rate. The required speed varies depending on the car; the appropriate speed for my vehicle was 500 kbps.</p>
<p class="TX">The sketch retrieves data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Canbus.ecu_req()</samp> functions in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>. These functions have two parameters: the data type and the variable in which to store the data. For example, the sketch retrieves and places the first piece of data, speed, into the <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp> variable and then displays that data on the Serial Monitor <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. A short delay follows, after which the next parameters are retrieved and displayed and the process repeats.</p>
<p class="TX">If the project doesn’t work, you may need to change the data rate. You can change the parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">CANSPEED_125</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">CANSPEED_250</samp> for 125 kbps or 250 kpbs, respectively, trying different speeds to see what works.</p>
<p class="TX">You can learn a lot about your car using this sketch. For example, I found that the ECU in my Mitsubishi limited the throttle to 18 percent when the transmission was in park or neutral, preventing drivers from unnecessarily over-revving the engine.</p>
<p class="TX">Now that you have a basic framework to retrieve OBDII data, you’re ready to learn to save this data to a microSD card for later review. Keep the hardware for this project together, as you’ll also use it in the next project.</p>
<p class="HeadProject"><span id="h1-122"/><span aria-label=" Page 285. " epub:type="pagebreak" id="pg_285" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #48: Logging OBDII Car Data</samp></p>
<p class="TNI">In this project, you’ll log the data retrieved from the CAN bus to a microSD card, which allows you to analyze the data over time, whether the car is stationary or being driven. The required hardware and assembly are the same as the previous project, except that you’ll also need a microSD card—the type used in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> will be fine—and a power supply for your Arduino, as described at the start of this chapter.</p>
<p class="TX">Enter and upload the sketch, insert the microSD card into the CAN bus shield, and then confirm the car won’t move if you start the engine. Connect the Arduino to the power supply and start the engine. The sketch should retrieve and log the data to a text file called <i>CANBUS.TXT</i> on the microSD card, with a new entry around every second.</p>
<p class="TX">If you’re able, take your car for a drive. After you’ve finished, remove the power from the Arduino, insert the microSD card into your PC, and open it for viewing. It should include the <i>CANBUS.TXT</i> file containing all your logged data, as shown in <a href="chapter16.xhtml#fig16-8">Figure 16-8</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF EXAMPLE ECU DATA CAPTURED BY PROJECT #48" class="img1" id="fig16-8" src="../images/fig16-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-8: Example data file contents from a microSD card</samp></p></figcaption>
</figure>
<p class="TX">Open <i>CANBUS.TXT</i> in a spreadsheet, and during the opening process, delimit with a comma and a space. For example, if you’re using Microsoft Excel, you can do this using the Text Import Wizard that appears when you open a text file, as shown in <a href="chapter16.xhtml#fig16-9">Figure 16-9</a>.</p>
<figure class="IMG"><img alt="OPENING THE CANBUS.TXT FILE IN EXCEL" class="img5" id="fig16-9" src="../images/fig16-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-9: Opening the</samp> <samp class="SANS_Futura_Std_Book_11">CANBUS.TXT</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file in Excel</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 286. " epub:type="pagebreak" id="pg_286" role="doc-pagebreak"/>Now that your data is in normal spreadsheet file format, you can now open it in spreadsheet software for further analysis, such as to find relationships between speed and RPM or RPM and throttle position, as shown in <a href="chapter16.xhtml#fig16-10">Figure 16-10</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE ECU DATA DISPLAYED IN A SPREADSHEET" class="img1" id="fig16-10" src="../images/fig16-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-10: Working with example data in the spreadsheet</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how the sketch works:</p>
<span id="pro-48"/>

<pre><code>// Project #48 - Logging OBDII car data

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Canbus.h&gt;
int requestDelay = 1000;
char buffer[456];

#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
int chipselect = 9;

void setup()
{
    Serial.begin(115200);
    // Check uSD card
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> if (!SD.begin(chipselect))
    {
        Serial.println("Card failed, or not present");
        // Stop
        while (1);
    }
    Serial.println("Micro SD card initialized.");
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> if (Canbus.init(CANSPEED_500))
    {
        Serial.println("CAN initialization ok");
    } else
<span aria-label=" Page 287. " epub:type="pagebreak" id="pg_287" role="doc-pagebreak"/>    {
        Serial.println("CAN initialization error");
        while(1) {}
    }
    delay(2000);
}

void loop()
{
    // Open file on memory card
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> File dataFile = SD.open("CANBUS.TXT", FILE_WRITE);
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> if (dataFile)
    {
      <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> Canbus.ecu_req(VEHICLE_SPEED, buffer);
      <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> dataFile.print(buffer);
        delay(requestDelay);

        Canbus.ecu_req(ENGINE_RPM, buffer);
        dataFile.print(",");
        dataFile.print(buffer);
        delay(requestDelay);

        Canbus.ecu_req(THROTTLE, buffer);
        dataFile.print(",");
        dataFile.print(buffer);
        delay(requestDelay);

        Canbus.ecu_req(ENGINE_COOLANT_TEMP, buffer);
        dataFile.print(",");
        dataFile.print(buffer);
        delay(requestDelay);

        Canbus.ecu_req(O2_VOLTAGE, buffer);
        dataFile.print(",");
        dataFile.print(buffer);
        delay(requestDelay);

        Canbus.ecu_req(MAF_SENSOR, buffer);
        dataFile.print(",");
        dataFile.println(buffer);

        // Close file on memory card
      <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> dataFile.close();
        delay(1000); // Around 1-second delay between logging data
    }
}
</code></pre>

<p class="TX">The sketch includes the requisite CAN bus library and variables <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, followed by the library to use the microSD card reader and the <samp class="SANS_TheSansMonoCd_W5Regular_11">chipselect</samp> variable. This variable indicates which CS pin the microSD card socket uses, in this case using a value of 9 for Arduino digital pin 9. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch checks that the microSD card subsection is working <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and then initializes the CAN bus interface with the required bus speed <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. As in the <span aria-label=" Page 288. " epub:type="pagebreak" id="pg_288" role="doc-pagebreak"/>previous project, if the sketch doesn’t log any data, try changing the value for <samp class="SANS_TheSansMonoCd_W5Regular_11">requestDelay</samp>.</p>
<p class="TX">If the microSD card and the CAN bus initialize successfully, the sketch moves on to the main loop and opens the file on the microSD card for writing <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If a file to be written to exists <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, the sketch moves on to retrieve the first piece of data from the ECU <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>; then, instead of sending the data to the Serial Monitor, the sketch writes it to the microSD card <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. The process then repeats for the other five pieces of data from the ECU. Once finished, the sketch closes the file for writing <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. You can change the period between logging data using <samp class="SANS_TheSansMonoCd_W5Regular_11">delay()</samp>.</p>
<p class="TX">For a challenge, you could add a real-time clock IC such as the popular DS3231 series to log time and date information along with the engine parameters. You could also add a GPS module to log speed from both the ECU and the GPS, allowing you to compare the inaccuracy of your car’s speedometer.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-123"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">This chapter gave you the tools to monitor and record various parameters of information made available by your vehicle’s systems such as speed, engine RPM, throttle position, coolant temperatures, and so on that give greater insight into the operation of the engine and its sensors. Each type of vehicle is different, so by using the projects you built in this chapter, you can find data specific to your own ride.</p>
<p class="TX">In the next chapter, you’ll learn how to make an Arduino communicate with other devices using the RS232 data bus.</p>
</section>
</section>
</body>
</html>