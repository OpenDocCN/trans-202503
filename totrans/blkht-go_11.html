<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_233"/><span class="big">11</span><br/>IMPLEMENTING AND ATTACKING CRYPTOGRAPHY</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">A conversation about security isn’t complete without exploring <em>cryptography</em>. When organizations use cryptographic practices, they can help conserve the integrity, confidentiality, and authenticity of their information and systems alike. As a tool developer, you’d likely need to implement cryptographic features, perhaps for SSL/TLS communications, mutual authentication, symmetric-key cryptography, or password hashing. But developers often implement cryptographic functions insecurely, which means the offensive-minded can exploit these weaknesses to compromise sensitive, valuable data, such as social security or credit card numbers.</p>&#13;
<p class="indent">This chapter demonstrates various implementations of cryptography in Go and discusses common weaknesses you can exploit. Although we provide introductory information for the different cryptographic functions and code blocks, we’re not attempting to explore the nuances of cryptographic algorithms or their mathematical foundations. That, frankly, is far beyond our interest in (or knowledge of) cryptography. As we’ve stated <span epub:type="pagebreak" id="page_234"/>before, don’t attempt anything in this chapter against resources or assets without explicit permission from the owner. We’re including these discussions for learning purposes, not to assist in illegal activities.</p>&#13;
<h3 class="h3" id="ch11lev1sec1">Reviewing Basic Cryptography Concepts</h3>&#13;
<p class="noindent">Before we explore crypto in Go, let’s discuss a few basic cryptography concepts. We’ll make this short to keep you from falling into a deep sleep.</p>&#13;
<p class="indent">First, encryption (for the purposes of maintaining confidentiality) is just one of the tasks of cryptography. <em>Encryption</em>, generally speaking, is a two-way function with which you can scramble data and subsequently unscramble it to retrieve the initial input. The process of encrypting data renders it meaningless until it’s been decrypted.</p>&#13;
<p class="indent">Both encryption and decryption involve passing the data and an accompanying key into a cryptographic function. The function outputs either the encrypted data (called <em>ciphertext</em>) or the original, readable data (called <em>cleartext)</em>. Various algorithms exist to do this. <em>Symmetric</em> algorithms use the same key during the encryption and decryption processes, whereas <em>asymmetric</em> algorithms use different keys for encryption and decryption. You might use encryption to protect data in transit or to store sensitive information, such as credit card numbers, to decrypt later, perhaps for convenience during a future purchase or for fraud monitoring.</p>&#13;
<p class="indent">On the other hand, <em>hashing</em> is a one-way process for mathematically scrambling data. You can pass sensitive information into a hashing function to produce a fixed-length output. When you’re working with strong algorithms, such as those in the SHA-2 family, the probability that different inputs produce the same output is extremely low. That is, there is a low likelihood of a <em>collision</em>. Because they’re nonreversible, hashes are commonly used as an alternative to storing cleartext passwords in a database or to perform integrity checking to determine whether data has been changed. If you need to obscure or randomize the outputs for two identical inputs, you use a <em>salt</em>, which is a random value used to differentiate two identical inputs during the hashing process. Salts are common for password storage because they allow multiple users who coincidentally use identical passwords to still have different hash values.</p>&#13;
<p class="indent">Cryptography also provides a means for authenticating messages. A <em>message authentication code (MAC)</em> is the output produced from a special one-way cryptographic function. This function consumes the data itself, a secret key, and an initialization vector, and produces an output unlikely to have a collision. The sender of a message performs the function to generate a MAC and then includes the MAC as part of the message. The receiver locally calculates the MAC and compares it to the MAC they received. A match indicates that the sender has the correct secret key (that is, that the sender is authentic) and that the message was not changed (the integrity has been maintained).</p>&#13;
<p class="indent">There! Now you should know enough about cryptography to understand the contents of this chapter. Where necessary, we’ll discuss more specifics relevant to the given topic. Let’s start by looking at Go’s standard crypto library.</p>&#13;
<h3 class="h3" id="ch11lev1sec2"><span epub:type="pagebreak" id="page_235"/>Understanding the Standard Crypto Library</h3>&#13;
<p class="noindent">The beautiful thing about implementing crypto in Go is that the majority of cryptographic features you’ll likely use are part of the standard library. Whereas other languages commonly rely on OpenSSL or other third-party libraries, Go’s crypto features are part of the official repositories. This makes implementing crypto relatively straightforward, as you won’t have to install clumsy dependencies that’ll pollute your development environment. There are two separate repositories.</p>&#13;
<p class="indent">The self-contained <span class="literal">crypto</span> package contains a variety of subpackages used for the most common cryptographic tasks and algorithms. For example, you could use the <span class="literal">aes</span>, <span class="literal">des</span>, and <span class="literal">rc4</span> subpackages for implementing symmetric-key algorithms; the <span class="literal">dsa</span> and <span class="literal">rsa</span> subpackages for asymmetric encryption; and the <span class="literal">md5</span>, <span class="literal">sha1</span>, <span class="literal">sha256</span>, and <span class="literal">sha512</span> subpackages for hashing. This is not an exhaustive list; additional subpackages exist for other crypto functions, as well.</p>&#13;
<p class="indent">In addition to the standard <span class="literal">crypto</span> package, Go has an official, extended package that contains a variety of supplementary crypto functionality: <span class="literal">golang</span><span class="literal">.org/x/crypto</span>. The functionality within includes additional hashing algorithms, encryption ciphers, and utilities. For example, the package contains a <span class="literal">bcrypt</span> subpackage for <em>bcrypt hashing</em> (a better, more secure alternative for hashing passwords and sensitive data), <span class="literal">acme/autocert</span> for generating legitimate certificates, and SSH subpackages to facilitate communications over the SSH protocol.</p>&#13;
<p class="indent">The only real difference between the built-in <span class="literal">crypto</span> and supplementary <span class="literal">golang.org/x/crypto</span> packages is that the <span class="literal">crypto</span> package adheres to more stringent compatibility requirements. Also, if you wish to use any of the <span class="literal">golang</span><span class="literal">.org/x/crypto</span> subpackages, you’ll first need to install the package by entering the following:</p>&#13;
<pre>$ <span class="codestrong1">go get -u golang.org/x/crypto/bcrypt</span></pre>&#13;
<p class="indent">For a complete listing of all the functionality and subpackages within the official Go crypto packages, check out the official documentation at <a href="https://golang.org/pkg/crypto/"><em>https://golang.org/pkg/crypto/</em></a> and <a href="https://godoc.org/golang.org/x/crypto/"><em>https://godoc.org/golang.org/x/crypto/</em></a>.</p>&#13;
<p class="indent">The next sections delve into various crypto implementations. You’ll see how to use Go’s crypto functionality to do some nefarious things, such as crack password hashes, decrypt sensitive data by using a static key, and brute-force weak encryption ciphers. You’ll also use the functionality to create tools that use TLS to protect your in-transit communications, check the integrity and authenticity of data, and perform mutual authentication.</p>&#13;
<h3 class="h3" id="ch11lev1sec3">Exploring Hashing</h3>&#13;
<p class="noindent">Hashing, as we mentioned previously, is a one-way function used to produce a fixed-length, probabilistically unique output based on a variable-length input. You can’t reverse this hash value to retrieve the original input source. Hashes are often used to store information whose original, cleartext source <span epub:type="pagebreak" id="page_236"/>won’t be needed for future processing or to track the integrity of data. For example, it’s bad practice and generally unnecessary to store the cleartext version of the password; instead, you’d store the hash (salted, ideally, to ensure randomness between duplicate values).</p>&#13;
<p class="indent">To demonstrate hashing in Go, we’ll look at two examples. The first attempts to crack a given MD5 or SHA-512 hash by using an offline dictionary attack. The second example demonstrates an implementation of bcrypt. As mentioned previously, bcrypt is a more secure algorithm for hashing sensitive data such as passwords. The algorithm also contains a feature that reduces its speed, making it harder to crack passwords.</p>&#13;
<h4 class="h4" id="ch11lev2sec1">Cracking an MD5 or SHA-256 Hash</h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11list1">Listing 11-1</a> shows the hash-cracking code. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.) Since hashes aren’t directly reversible, the code instead tries to guess the cleartext value of the hash by generating its own hashes of common words, taken from a word list, and then comparing the resulting hash value with the hash you have in hand. If the two hashes match, you’ve likely guessed the cleartext value.</p>&#13;
<pre><span class="ent">❶</span> var md5hash = "77f62e3524cd583d698d51fa24fdff4f"&#13;
   var sha256hash =&#13;
   "95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced"&#13;
&#13;
   func main() {&#13;
       f, err := os.Open("wordlist.txt")<span class="ent">❷</span>&#13;
       if err != nil {&#13;
           log.Fatalln(err)&#13;
       }  &#13;
       defer f.Close()&#13;
&#13;
    <span class="ent">❸</span> scanner := bufio.NewScanner(f)&#13;
       for scanner.Scan() {&#13;
           password := scanner.Text()&#13;
           hash := fmt.Sprintf("%x", md5.Sum([]byte(password))<span class="ent">❹</span>)&#13;
        <span class="ent">❺</span> if hash == md5hash {&#13;
               fmt.Printf("[+] Password found (MD5): %s\n", password)&#13;
           }  &#13;
&#13;
           hash = fmt.Sprintf("%x", sha256.Sum256([]byte(password))<span class="ent">❻</span>)&#13;
        <span class="ent">❼</span> if hash == sha256hash {&#13;
               fmt.Printf("[+] Password found (SHA-256): %s\n", password)&#13;
           }  &#13;
       }  &#13;
&#13;
       if err := scanner.Err(); err != nil {&#13;
           log.Fatalln(err)&#13;
       }  &#13;
   }</pre>&#13;
<p class="caption" id="ch11list1"><em>Listing 11-1: Cracking MD5 and SHA-256 hashes (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/hashes/main.go">/ch-11/hashes/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_237"/>You start by defining two variables <span class="ent">❶</span> that hold the target hash values. One is an MD5 hash, and the other is a SHA-256. Imagine that you acquired these two hashes as part of post-exploitation and you’re trying to determine the inputs (the cleartext passwords) that produced them after being run through the hashing algorithm. You can often determine the algorithm by inspecting the length of the hash itself. When you find a hash that matches the target, you’ll know you have the correct input.</p>&#13;
<p class="indent">The list of inputs you’ll try exists in a dictionary file you’ll have created earlier. Alternatively, a Google search can help you find dictionary files for commonly used passwords. To check the MD5 hash, you open the dictionary file <span class="ent">❷</span> and read it, line by line, by creating a <span class="literal">bufio.Scanner</span> on the file descriptor <span class="ent">❸</span>. Each line consists of a single password value that you wish to check. You pass the current password value into a function named <span class="literal">md5.Sum(input</span> <span class="literal">[]byte</span><span class="literal">)</span> <span class="ent">❹</span>. This function produces the MD5 hash value as raw bytes, so you use the <span class="literal">fmt.Sprintf()</span> function with the format string <span class="literal">%x</span> to convert it to a hexadecimal string. After all, your <span class="literal">md5hash</span> variable consists of a hexadecimal string representation of the target hash. Converting your value ensures that you can then compare the target and calculated hash values <span class="ent">❺</span>. If these hashes match, the program displays a success message to stdout.</p>&#13;
<p class="indent">You perform a similar process to calculate and compare SHA-256 hashes. The implementation is fairly similar to the MD5 code. The only real difference is that the <span class="literal">sha256</span> package contains additional functions to calculate various SHA hash lengths. Rather than calling <span class="literal">sha256.Sum()</span> (a function that doesn’t exist), you instead call <span class="literal">sha256.Sum256(input []byte)</span> <span class="ent">❻</span> to force the hash to be calculated using the SHA-256 algorithm. Much as you did in the MD5 example, you convert your raw bytes to a hex string and compare the SHA-256 hashes to see whether you have a match <span class="ent">❼</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec2">Implementing bcrypt</h4>&#13;
<p class="noindent">The next example shows how to use bcrypt to encrypt and authenticate passwords. Unlike SHA and MD5, bcrypt was designed for password hashing, making it a better option for application designers than the SHA or MD5 families. It includes a salt by default, as well as a cost factor that makes running the algorithm more resource-intensive. This cost factor controls the number of iterations of the internal crypto functions, increasing the time and effort needed to crack a password hash. Although the password can still be cracked using a dictionary or brute-force attack, the cost (in time) increases significantly, discouraging cracking activities during time-sensitive post-exploitation. It’s also possible to increase the cost over time to counter the advancement of computing power. This makes it adaptive to future cracking attacks.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11list2">Listing 11-2</a> creates a bcrypt hash and then validates whether a cleartext password matches a given bcrypt hash.</p>&#13;
<pre>   import (&#13;
       "log"&#13;
       "os"&#13;
    <span epub:type="pagebreak" id="page_238"/><span class="ent">❶</span> "golang.org/x/crypto/bcrypt"&#13;
   )&#13;
&#13;
<span class="ent">❷</span> var storedHash = "$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu"&#13;
&#13;
   func main() {&#13;
       var password string&#13;
       if len(os.Args) != 2 {&#13;
           log.Fatalln("Usage: bcrypt password")&#13;
       }  &#13;
       password = os.Args[1]&#13;
&#13;
    <span class="ent">❸</span> hash, err := bcrypt.GenerateFromPassword(&#13;
           []byte(password),&#13;
           bcrypt.DefaultCost,&#13;
       )&#13;
       if err != nil {&#13;
           log.Fatalln(err)&#13;
       }  &#13;
       log.Printf("hash = %s\n", hash)&#13;
&#13;
    <span class="ent">❹</span> err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))&#13;
       if err != nil {&#13;
           log.Println("[!] Authentication failed")&#13;
           return&#13;
       }  &#13;
       log.Println("[+] Authentication successful")&#13;
   }</pre>&#13;
<p class="caption" id="ch11list2"><em>Listing 11-2: Comparing bcrypt hashes (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/bcrypt/main.go">/ch-11/bcrypt/main.go</a><em>)</em></p>&#13;
<p class="indent">For most of the code samples in this book, we’ve omitted the package imports. We’ve included them in this example to explicitly show that you’re using the supplemental Go package, <span class="literal">golang.org/x/crypto/bcrypt</span> <span class="ent">❶</span>, because Go’s built-in <span class="literal">crypto</span> package doesn’t contain the bcrypt functionality. You then initialize a variable, <span class="literal">storedHash</span> <span class="ent">❷</span>, that holds a precomputed, encoded bcrypt hash. This is a contrived example; rather than wiring our sample code up to a database to get a value, we’ve opted to hardcode a value for demonstrative purposes. The variable could represent a value that you’ve found in a database row that stores user authentication information for a frontend web application, for instance.</p>&#13;
<p class="indent">Next, you’ll produce a bcrypt-encoded hash from a cleartext password value. The main function reads a password value as a command line argument and proceeds to call two separate bcrypt functions. The first function, <span class="literal">bcrypt.GenerateFromPassword()</span> <span class="ent">❸</span>, accepts two parameters: a byte slice representing the cleartext password and a cost value. In this example, you’ll pass the constant variable <span class="literal">bcrypt.DefaultCost</span> to use the package’s default cost, which is 10 at the time of this writing. The function returns the encoded hash value and any errors produced.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>The second bcrypt function you call is <span class="literal">bcrypt.CompareHashAndPassword()</span> <span class="ent">❹</span>, which does the hash comparison for you behind the scenes. It accepts a bcrypt-encoded hash and a cleartext password as byte slices. The function parses the encoded hash to determine the cost and salt. It then uses these values with the cleartext password value to generate a bcrypt hash. If this resulting hash matches the hash extracted from the encoded <span class="literal">storedHash</span> value, you know the provided password matches what was used to create the <span class="literal">storedHash</span>.</p>&#13;
<p class="indent">This is the same method you used to perform your password cracking against SHA and MD5—run a given password through the hashing function and compare the result with the stored hash. Here, rather than explicitly comparing the resulting hashes as you did for SHA and MD5, you check whether <span class="literal">bcrypt.CompareHashAndPassword()</span> returns an error. If you see an error, you know the computed hashes, and therefore the passwords used to compute them, do not match.</p>&#13;
<p class="indent">The following are two sample program runs. The first shows the output for an incorrect password:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go someWrongPassword</span>&#13;
2020/08/25 08:44:01 hash = $2a$10$YSSanGl8ye/NC7GDyLBLUO5gE/ng51l9TnaB1zTChWq5g9i09v0AC&#13;
2020/08/25 08:44:01 [!] Authentication failed</pre>&#13;
<p class="indent">The second shows the output for the correct password:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go someC0mpl3xP@ssw0rd</span>&#13;
2020/08/25 08:39:29 hash = $2a$10$XfeUk.wKeEePNAfjQ1juXe8RaM/9EC1XZmqaJ8MoJB29hZRyuNxz.&#13;
2020/08/25 08:39:29 [+] Authentication successful</pre>&#13;
<p class="indent">Those of you with a keen eye for detail may notice that the hash value displayed for your successful authentication does not match the value you hardcoded for your <span class="literal">storedHash</span> variable. Recall, if you will, that your code is calling two separate functions. The <span class="literal">GenerateFromPassword()</span> function produces the encoded hash by using a random salt value. Given different salts, the same password will produce different resulting hashes. Hence the difference. The <span class="literal">CompareHashAndPassword()</span> function performs the hashing algorithm by using the same salt and cost as the stored hash, so the resulting hash is identical to the one in the <span class="literal">storedHash</span> variable.</p>&#13;
<h3 class="h3" id="ch11lev1sec4">Authenticating Messages</h3>&#13;
<p class="noindent">Let’s now turn our focus to message authentication. When exchanging messages, you need to validate both the integrity of data and the authenticity of the remote service to make sure that the data is authentic and hasn’t been tampered with. Was the message altered during transmission by an unauthorized source? Was the message sent by an authorized sender or was it forged by another entity?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_240"/>You can address these questions by using Go’s <span class="literal">crypto/hmac</span> package, which implements the <em>Keyed-Hash Message Authentication Code</em> (HMAC) standard. HMAC is a cryptographic algorithm that allows us to check for message tampering and verify the identity of the source. It uses a hashing function and consumes a shared secret key, which only the parties authorized to produce valid messages or data should possess. An attacker who does not possess this shared secret cannot reasonably forge a valid HMAC value.</p>&#13;
<p class="indent">Implementing HMAC in some programming languages can be a little tricky. For example, some languages force you to manually compare the received and calculated hash values byte by byte. Developers may inadvertently introduce timing discrepancies in this process if their byte-by-byte comparison is aborted prematurely; an attacker can deduce the expected HMAC by measuring message-processing times. Additionally, developers will occasionally think HMACs (which consume a message and key) are the same as a hash of a secret key prepended to a message. However, the internal functionality of HMACs differs from that of a pure hashing function. By not explicitly using an HMAC, the developer is exposing the application to length-extension attacks, in which an attacker forges a message and valid MAC.</p>&#13;
<p class="indent">Luckily for us Gophers, the <span class="literal">crypto/hmac</span> package makes it fairly easy to implement HMAC functionality in a secure fashion. Let’s look at an implementation. Note that the following program is much simpler than a typical use case, which would likely involve some type of network communications and messaging. In most cases, you’d calculate the HMAC on HTTP request parameters or some other message transmitted over a network. In the example shown in <a href="ch11.xhtml#ch11list3">Listing 11-3</a>, we’re omitting the client-server communications and focusing solely on the HMAC functionality.</p>&#13;
<pre>var key = []byte("some random key") <span class="ent">❶</span>&#13;
&#13;
func checkMAC(message, recvMAC []byte) bool { <span class="ent">❷</span>&#13;
    mac := hmac.New(sha256.New, key) <span class="ent">❸</span>&#13;
    mac.Write(message)&#13;
    calcMAC := mac.Sum(nil)&#13;
&#13;
    return hmac.Equal(calcMAC, recvMAC)<span class="ent">❹</span>&#13;
}&#13;
&#13;
func main() {&#13;
    // In real implementations, we'd read the message and HMAC value from network source&#13;
    message := []byte("The red eagle flies at 10:00") <span class="ent">❺</span>&#13;
    mac, _ := hex.DecodeString("69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d") <span class="ent">❻</span>&#13;
    if checkMAC(message, mac) { <span class="ent">❼</span>&#13;
        fmt.Println("EQUAL")&#13;
    } else {&#13;
        fmt.Println("NOT EQUAL")&#13;
    }  &#13;
}</pre>&#13;
<p class="caption" id="ch11list3"><em>Listing 11-3: Using HMAC for message authentication (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/hmac/main.go">/ch-11/hmac/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_241"/>The program begins by defining the key you’ll use for your HMAC cryptographic function <span class="ent">❶</span>. You’re hardcoding the value here, but in a real implementation, this key would be adequately protected and random. It would also be shared between the endpoints, meaning both the message sender and receiver are using this same key value. Since you aren’t implementing full client-server functionality here, you’ll use this variable as if it were adequately shared.</p>&#13;
<p class="indent">Next, you define a function, <span class="literal">checkMAC()</span> <span class="ent">❷</span>, that accepts a message and the received HMAC as parameters. The message receiver would call this function to check whether the MAC value they received matches the value they calculated locally. First, you call <span class="literal">hmac.New()</span> <span class="ent">❸</span>, passing to it <span class="literal">sha256.New</span>, which is a function that returns a <span class="literal">hash.Hash</span> instance, and the shared secret key. In this case, the <span class="literal">hmac.New()</span> function initializes your HMAC by using the SHA-256 algorithm and your secret key, and assigns the result to a variable named <span class="literal">mac</span>. You then use this variable to calculate the HMAC hash value, as you did in the earlier hashing examples. Here, you call <span class="literal">mac.Write(message)</span> and <span class="literal">mac.Sum(nil)</span>, respectively. The result is your locally calculated HMAC, stored in a variable named <span class="literal">calcMAC</span>.</p>&#13;
<p class="indent">The next step is to evaluate whether your locally calculated HMAC value is equal to the HMAC value you received. To do this in a secure manner, you call <span class="literal">hmac.Equal(calcMAC, recvMAC)</span> <span class="ent">❹</span>. A lot of developers would be inclined to compare the byte slices by calling <span class="literal">bytes.Compare(calcMAC,</span> <span class="literal">recvMAC</span><span class="literal">)</span>. The problem is, <span class="literal">bytes.Compare()</span> performs a lexicographical comparison, walking and comparing each element of the given slices until it finds a difference or reaches the end of a slice. The time it takes to complete this comparison will vary based on whether <span class="literal">bytes.Compare()</span> encounters a difference on the first element, the last, or somewhere in between. An attacker could measure this variation in time to determine the expected HMAC value and forge a request that’s processed legitimately. The <span class="literal">hmac.Equal()</span> function solves this problem by comparing the slices in a way that produces nearly constant measurable times. It doesn’t matter where the function finds a difference, because the processing times will vary insignificantly, producing no obvious or perceptible pattern.</p>&#13;
<p class="indent">The <span class="literal">main()</span> function simulates the process of receiving a message from a client. If you were really receiving a message, you’d have to read and parse the HMAC and message values from the transmission. Since this is just a simulation, you instead hardcode the received message <span class="ent">❺</span> and the received HMAC <span class="ent">❻</span>, decoding the HMAC hex string so it’s represented as a <span class="literal">[]byte</span>. You use an <span class="literal">if</span> statement to call your <span class="literal">checkMAC()</span> function <span class="ent">❼</span>, passing it your received message and HMAC. As detailed previously, your <span class="literal">checkMAC()</span> function computes an HMAC by using the received message and the shared secret key and returns a <span class="literal">bool</span> value for whether the received HMAC and calculated HMAC match.</p>&#13;
<p class="indent">Although the HMAC does provide both authenticity and integrity assurance, it doesn’t ensure confidentiality. You can’t know for sure that the message itself wasn’t seen by unauthorized resources. The next section addresses this concern by exploring and implementing various types of encryption.</p>&#13;
<h3 class="h3" id="ch11lev1sec5"><span epub:type="pagebreak" id="page_242"/>Encrypting Data</h3>&#13;
<p class="noindent">Encryption is likely the most well-known cryptographic concept. After all, privacy and data protection have garnered significant news coverage due to high-profile data breaches, often resulting from organizations storing user passwords and other sensitive data in unencrypted formats. Even without the media attention, encryption should spark the interest of black hats and developers alike. After all, understanding the basic process and implementation can be the difference between a lucrative data breach and a frustrating disruption to an attack kill chain. The following section presents the varying forms of encryption, including useful applications and use cases for each.</p>&#13;
<h4 class="h4" id="ch11lev2sec3">Symmetric-Key Encryption</h4>&#13;
<p class="noindent">Your journey into encryption will start with what is arguably its most straightforward form—<em>symmetric-key encryption</em>. In this form, both the encryption and decryption functions use the same secret key. Go makes symmetric cryptography pretty straightforward, because it supports most common algorithms in its default or extended packages.</p>&#13;
<p class="indent">For the sake of brevity, we’ll limit our discussion of symmetric-key encryption to a single, practical example. Let’s imagine you’ve breached an organization. You’ve performed the necessary privilege escalation, lateral movement, and network recon to gain access to an e-commerce web server and the backend database. The database contains financial transactions; however, the credit card number used in those transactions is obviously encrypted. You inspect the application source code on the web server and determine that the organization is using the Advanced Encryption Standard (AES) encryption algorithm. AES supports multiple operating modes, each with slightly different considerations and implementation details. The modes are not interchangeable; the mode used for decryption must be identical to that used for encryption.</p>&#13;
<p class="indent">In this scenario, let’s say you’ve determined that the application is using AES in Cipher Block Chaining (CBC) mode. So, let’s write a function that decrypts these credit cards (<a href="ch11.xhtml#ch11list4">Listing 11-4</a>). Assume that the symmetric key was hardcoded in the application or set statically in a configuration file. As you go through this example, keep in mind that you’ll need to tweak this implementation for other algorithms or ciphers, but it’s a good starting place.</p>&#13;
<pre>func unpad(buf []byte) []byte { <span class="ent">❶</span>&#13;
    // Assume valid length and padding. Should add checks&#13;
    padding := int(buf[len(buf)-1])&#13;
    return buf[:len(buf)-padding]&#13;
}&#13;
&#13;
func decrypt(ciphertext, key []byte) ([]byte, error) { <span class="ent">❷</span>&#13;
    var (&#13;
        plaintext []byte&#13;
        iv        []byte&#13;
        block     cipher.Block&#13;
        mode      cipher.BlockMode&#13;
<span epub:type="pagebreak" id="page_243"/>        err       error&#13;
    )&#13;
       &#13;
    if len(ciphertext) &lt; aes.BlockSize { <span class="ent">❸</span>&#13;
        return nil, errors.New("Invalid ciphertext length: too short")&#13;
    }&#13;
&#13;
    if len(ciphertext)%aes.BlockSize != 0 { <span class="ent">❹</span>&#13;
        return nil, errors.New("Invalid ciphertext length: not a multiple of blocksize")&#13;
    }&#13;
&#13;
    iv = ciphertext[:aes.BlockSize] <span class="ent">❺</span>&#13;
    ciphertext = ciphertext[aes.BlockSize:]&#13;
&#13;
    if block, err = aes.NewCipher(key); err != nil { <span class="ent">❻</span>&#13;
        return nil, err&#13;
    }&#13;
&#13;
    mode = cipher.NewCBCDecrypter(block, iv) <span class="ent">❼</span>&#13;
    plaintext = make([]byte, len(ciphertext))&#13;
    mode.CryptBlocks(plaintext, ciphertext) <span class="ent">❽</span>&#13;
    plaintext = unpad(plaintext) <span class="ent">❾</span>&#13;
&#13;
    return plaintext, nil&#13;
}</pre>&#13;
<p class="caption" id="ch11list4"><em>Listing 11-4: AES padding and decryption (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/aes/main.go">/ch-11/aes/main.go</a><em>)</em></p>&#13;
<p class="indent">The code defines two functions: <span class="literal">unpad()</span> and <span class="literal">decrypt()</span>. The <span class="literal">unpad()</span> function <span class="ent">❶</span> is a utility function scraped together to handle the removal of padding data after decryption. This is a necessary step, but beyond the scope of this discussion. Do some research on Public Key Cryptography Standards (PKCS) #7 padding for more information. It’s a relevant topic for AES, as it’s used to ensure that our data has proper block alignment. For this example, just know that you’ll need the function later to clean up your data. The function itself assumes some facts that you’d want to explicitly validate in a real-world scenario. Specifically, you’d want to confirm that the value of the padding bytes is valid, that the slice offsets are valid, and that the result is of appropriate length.</p>&#13;
<p class="indent">The most interesting logic exists within the <span class="literal">decrypt()</span> function <span class="ent">❷</span>, which takes two byte slices: the ciphertext you need to decrypt and the symmetric key you’ll use to do it. The function performs some validation to confirm that the ciphertext is at least as long as your block size <span class="ent">❸</span>. This is a necessary step, because CBC mode encryption uses an initialization vector (IV) for randomness. This IV, like a salt value for password hashing, doesn’t need to remain secret. The IV, which is the same length as a single AES block, is prepended onto your ciphertext during encryption. If the ciphertext length is less than the expected block size, you know that you either have an issue with the cipher text or are missing the IV. You also check whether the ciphertext length is a multiple of the AES block size <span class="ent">❹</span>. If it’s not, decryption will fail spectacularly, because CBC mode expects the ciphertext length to be a multiple of the block size.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_244"/>Once you’ve completed your validation checks, you can proceed to decrypt the ciphertext. As mentioned previously, the IV is prepended to the ciphertext, so the first thing you do is extract the IV from the ciphertext <span class="ent">❺</span>. You use the <span class="literal">aes.BlockSize</span> constant to retrieve the IV and then redefine your <span class="literal">ciphertext</span> variable to the remainder of your ciphertext via <span class="literal">ciphertext</span> <span class="literal">= [aes.BlockSize:]</span>. You now have your encrypted data separate from your IV.</p>&#13;
<p class="indent">Next, you call <span class="literal">aes.NewCipher()</span>, passing it your symmetric-key value <span class="ent">❻</span>. This initializes your AES block mode cipher, assigning it to a variable named <span class="literal">block</span>. You then instruct your AES cipher to operate in CBC mode by calling <span class="literal">cipher.NewCBCDecryptor(block, iv)</span> <span class="ent">❼</span>. You assign the result to a variable named <span class="literal">mode</span>. (The <span class="literal">crypto/cipher</span> package contains additional initialization functions for other AES modes, but you’re using only CBC decryption here.) You then issue a call to <span class="literal">mode.CryptBlocks(plaintext, ciphertext)</span> to decrypt the contents of <span class="literal">ciphertext</span> <span class="ent">❽</span> and store the result in the <span class="literal">plaintext</span> byte slice. Lastly, you <span class="ent">❾</span> remove your PKCS #7 padding by calling your <span class="literal">unpad()</span> utility function. You return the result. If all went well, this should be the plaintext value of the credit card number.</p>&#13;
<p class="indent">A sample run of the program produces the expected result:</p>&#13;
<pre><span class="codestrong1">$ go run main.go</span>&#13;
key        = aca2d6b47cb5c04beafc3e483b296b20d07c32db16029a52808fde98786646c8&#13;
ciphertext = 7ff4a8272d6b60f1e7cfc5d8f5bcd047395e31e5fc83d062716082010f637c8f21150eabace62&#13;
--<span class="codeitalic1">snip</span>--&#13;
plaintext  = 4321123456789090</pre>&#13;
<p class="indent">Notice that you didn’t define a <span class="literal">main()</span> function in this sample code. Why not? Well, decrypting data in unfamiliar environments has a variety of potential nuances and variations. Are the ciphertext and key values encoded or raw binary? If they’re encoded, are they a hex string or Base64? Is the data locally accessible, or do you need to extract it from a data source or interact with a hardware security module, for example? The point is, decryption is rarely a copy-and-paste endeavor and often requires some level of understanding of algorithms, modes, database interaction, and data encoding. For this reason, we’ve chosen to lead you to the answer with the expectation that you’ll inevitably have to figure it out when the time is right.</p>&#13;
<p class="indent">Knowing just a little bit about symmetric-key encryption can make your penetrations tests much more successful. For example, in our experience pilfering client source-code repositories, we’ve found that people often use the AES encryption algorithm, either in CBC or Electronic Codebook (ECB) mode. ECB mode has some inherent weaknesses and CBC isn’t any better, if implemented incorrectly. Crypto can be hard to understand, so often developers assume that all crypto ciphers and modes are equally effective and are ignorant of their subtleties. Although we don’t consider ourselves cryptographers, we know just enough to implement crypto securely in Go—and to exploit other people’s deficient implementations.</p>&#13;
<p class="indent">Although symmetric-key encryption is faster than asymmetric cryptography, it suffers from inherent key-management challenges. After all, to use it, you must distribute the same key to any and all systems or applications that perform the encryption or decryption functions on the data. <span epub:type="pagebreak" id="page_245"/>You must distribute the key securely, often following strict processes and auditing requirements. Also, relying solely on symmetric-key cryptography prevents arbitrary clients from, for example, establishing encrypted communications with other nodes. There isn’t a good way to negotiate the secret key, nor are there authentication or integrity assurances for many common algorithms and modes.<a id="rch11fn1" href="footnote.xhtml#ch11fn1"><sup>1</sup></a> That means anyone, whether authorized or malicious, who obtains the secret key can proceed to use it.</p>&#13;
<p class="indent">This is where asymmetric cryptography can be of use.</p>&#13;
<h4 class="h4" id="ch11lev2sec4">Asymmetric Cryptography</h4>&#13;
<p class="noindent">Many of the problems associated with symmetric-key encryption are solved by <em>asymmetric</em> (or <em>public-key</em>) <em>cryptography</em>, which uses two separate but mathematically related keys. One is available to the public and the other is kept private. Data encrypted by the private key can be decrypted only by the public key, and data encrypted by the public key can be decrypted only by the private key. If the private key is protected properly and kept, well, private, then data encrypted with the public key remains confidential, since you need the closely guarded private key to decrypt it. Not only that, but you could use the private key to authenticate a user. The user could use the private key to sign messages, for example, which the public could decrypt using the public key.</p>&#13;
<p class="indent">So, you might be asking, “What’s the catch? If public-key cryptography provides all these assurances, why do we even have symmetric-key cryptography?” Good question, you! The problem with public-key encryption is its speed; it’s a lot slower than its symmetric counterpart. To get the best of both worlds (and avoid the worst), you’ll often find organizations using a hybrid approach: they’ll use asymmetric crypto for the initial communications negotiation, establishing an encrypted channel through which they create and exchange a symmetric key (often called a <em>session key</em>). Because the session key is fairly small, using public-key crypto for this process requires little overhead. Both the client and server then have a copy of the session key, which they use to make future communications faster.</p>&#13;
<p class="indent">Let’s look at a couple of common use cases for public-key crypto. Specifically, we’ll look at encryption, signature validation, and mutual authentication.</p>&#13;
<h5 class="h5">Encryption and Signature Validation</h5>&#13;
<p class="noindent">For this first example, you’ll use public-key crypto to encrypt and decrypt a message. You’ll also create the logic to sign a message and validate that signature. For simplicity, you’ll include all of this logic in a single <span class="literal">main()</span> function. This is meant to show you the core functionality and logic so that you can implement it. In a real-world scenario, the process is a little more complex, since you’re likely to have two remote nodes communicating with each other. These nodes would have to exchange public keys. Fortunately, this exchange process doesn’t require the same security assurances as <span epub:type="pagebreak" id="page_246"/>exchanging symmetric keys. Recall that any data encrypted with the public key can be decrypted only by the related private key. So, even if you perform a man-in-the-middle attack to intercept the public-key exchange and future communications, you won’t be able to decrypt any of the data encrypted by the same public key. Only the private key can decrypt it.</p>&#13;
<p class="indent">Let’s take a look at the implementation shown in <a href="ch11.xhtml#ch11list5">Listing 11-5</a>. We’ll elaborate on the logic and cryptographic functionality as we review the example.</p>&#13;
<pre>func main() {&#13;
    var (&#13;
        err                                              error&#13;
        privateKey                                       *rsa.PrivateKey&#13;
        publicKey                                        *rsa.PublicKey&#13;
        message, plaintext, ciphertext, signature, label []byte&#13;
    )  &#13;
&#13;
    if privateKey, err = rsa.GenerateKey(rand.Reader, 2048)<span class="ent">❶</span>; err != nil {&#13;
        log.Fatalln(err)&#13;
    }  &#13;
    publicKey = &amp;privateKey.PublicKey <span class="ent">❷</span>&#13;
&#13;
    label = []byte("")&#13;
    message = []byte("Some super secret message, maybe a session key even")&#13;
    ciphertext, err = rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, message, label) <span class="ent">❸</span>&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }&#13;
    fmt.Printf("Ciphertext: %x\n", ciphertext)&#13;
&#13;
    plaintext, err = rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, label) <span class="ent">❹</span>&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }  &#13;
    fmt.Printf("Plaintext: %s\n", plaintext)&#13;
&#13;
    h := sha256.New()&#13;
    h.Write(message)&#13;
    signature, err = rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil), nil) <span class="ent">❺</span>&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }  &#13;
    fmt.Printf("Signature: %x\n", signature)&#13;
&#13;
    err = rsa.VerifyPSS(publicKey, crypto.SHA256, h.Sum(nil), signature, nil)<span class="ent">❻</span>&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }  &#13;
    fmt.Println("Signature verified")&#13;
}</pre>&#13;
<p class="caption" id="ch11list5"><em>Listing 11-5: Asymmetric, or public-key, encryption (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/public-key/main.go">/ch-11/public-key/main.go/</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_247"/>The program demonstrates two separate but related public-key crypto functions: encryption/decryption and message signing. You first generate a public/private key pair by calling the <span class="literal">rsa.GenerateKey()</span> function <span class="ent">❶</span>. You supply a random reader and a key length as input parameters to the function. Assuming the random reader and key lengths are adequate to generate a key, the result is an <span class="literal">*rsa.PrivateKey</span> instance that contains a field whose value is the public key. You now have a working key pair. You assign the public key to its own variable for the sake of convenience <span class="ent">❷</span>.</p>&#13;
<p class="indent">This program generates this key pair every time it’s run. In most circumstances, such as SSH communications, you’ll generate the key pair a single time, and then save and store the keys to disk. The private key will be kept secure, and the public key will be distributed to endpoints. We’re skipping key distribution, protection, and management here, and focusing only on the cryptographic functions.</p>&#13;
<p class="indent">Now that you’ve created the keys, you can start using them for encryption. You do so by calling the function <span class="literal">rsa.EncryptOAEP()</span> <span class="ent">❸</span>, which accepts a hashing function, a reader to use for padding and randomness, your public key, the message you wish to encrypt, and an optional label. This function returns an error (if the inputs cause the algorithm to fail) and our ciphertext. You can then pass the same hashing function, a reader, your private key, your ciphertext, and a label into the function <span class="literal">rsa.DecryptOAEP()</span> <span class="ent">❹</span>. The function decrypts the ciphertext by using your private key and returns the cleartext result.</p>&#13;
<p class="indent">Notice that you’re encrypting the message with the public key. This ensures that only the holder of the private key will have the ability to decrypt the data. Next you create a digital signature by calling <span class="literal">rsa.SignPSS()</span> <span class="ent">❺</span>. You pass to it, again, a random reader, your private key, the hashing function you’re using, the hash value of the message, and a <span class="literal">nil</span> value representing additional options. The function returns any errors and the resulting signature value. Much like human DNA or fingerprints, this signature uniquely identifies the identity of the signer (that is, the private key). Anybody holding the public key can validate the signature to not only determine the authenticity of the signature but also validate the integrity of the message. To validate the signature, you pass the public key, hash function, hash value, signature, and additional options to <span class="literal">rsa.VerifyPSS()</span> <span class="ent">❻</span>. Notice that in this case you’re passing the public key, not the private key, into this function. Endpoints wishing to validate the signature won’t have access to the private key, nor will validation succeed if you input the wrong key value. The <span class="literal">rsa.VerifyPSS()</span> function returns <span class="literal">nil</span> when the signature is valid and an error when it’s invalid.</p>&#13;
<p class="indent">Here is a sample run of the program. It behaves as expected, encrypting the message by using a public key, decrypting it by using a private key, and validating the signature:</p>&#13;
<pre><span class="codestrong1">$ go run main.go</span>&#13;
Ciphertext: a9da77a0610bc2e5329bc324361b480ba042e09ef58e4d8eb106c8fc0b5&#13;
<span class="codeitalic1">--snip--</span>&#13;
Plaintext: Some super secret message, maybe a session key even&#13;
<span epub:type="pagebreak" id="page_248"/>Signature: 68941bf95bbc12edc12be369f3fd0463497a1220d9a6ab741cf9223c6793&#13;
<span class="codeitalic1">--snip--</span>&#13;
Signature verified</pre>&#13;
<p class="indent">Next up, let’s look at another application of public-key cryptography: mutual authentication.</p>&#13;
<h5 class="h5">Mutual Authentication</h5>&#13;
<p class="noindent"><em>Mutual authentication</em> is the process by which a client and server authenticate each other. They do this with public-key cryptography; both the client and server generate public/private key pairs, exchange public keys, and use the public keys to validate the authenticity and identity of the other endpoint. To accomplish this feat, both the client and server must do some legwork to set up the authorization, explicitly defining the public key value with which they intend to validate the other. The downside to this process is the administrative overhead of having to create unique key pairs for every single node and ensuring that the server and the client nodes have the appropriate data to proceed properly.</p>&#13;
<p class="indent">To begin, you’ll knock out the administrative tasks of creating key pairs. You’ll store the public keys as self-signed, PEM-encoded certificates. Let’s use the <span class="literal">openssl</span> utility to create these files. On your server, you’ll create the server’s private key and certificate by entering the following:</p>&#13;
<pre><span class="codestrong1">$ openssl req -nodes -x509 -newkey rsa:4096 -keyout serverKey.pem -out serverCrt.pem -days 365</span></pre>&#13;
<p class="indent">The <span class="literal">openssl</span> command will prompt you for various inputs, to which you can supply arbitrary values for this example. The command creates two files: <em>serverKey.pem</em> and <em>serverCrt.pem</em>. The file <em>serverKey.pem</em> contains your private key, and you should protect it. The <em>serverCrt.pem</em> file contains the server’s public key, which you’ll distribute to each of your connecting clients.</p>&#13;
<p class="indent">For every connecting client, you’ll run a command similar to the preceding one:</p>&#13;
<pre><span class="codestrong1">$ openssl req -nodes -x509 -newkey rsa:4096 -keyout clientKey.pem -out clientCrt.pem -days 365</span></pre>&#13;
<p class="indent">This command also generates two files: <em>clientKey.pem</em> and <em>clientCrt.pem</em>. Much as with the server output, you should protect the client’s private key. The <em>clientCrt.pem</em> certificate file will be transferred to your server and loaded by your program. This will allow you to configure and identify the client as an authorized endpoint. You’ll have to create, transfer, and configure a certificate for each additional client so that the server can identify and explicitly authorize them.</p>&#13;
<p class="indent">In <a href="ch11.xhtml#ch11list6">Listing 11-6</a>, you set up an HTTPS server that requires a client to provide a legitimate, authorized certificate.</p>&#13;
<pre>func helloHandler(w http.ResponseWriter, r *http.Request) { <span class="ent">❶</span>&#13;
    fmt.Printf("Hello: %s\n", r.TLS.PeerCertificates[0].Subject.CommonName) <span class="ent">❷</span>&#13;
    fmt.Fprint(w, "Authentication successful")&#13;
<span epub:type="pagebreak" id="page_249"/>}&#13;
&#13;
func main() {&#13;
    var (&#13;
        err        error&#13;
        clientCert []byte&#13;
        pool       *x509.CertPool&#13;
        tlsConf    *tls.Config&#13;
        server     *http.Server&#13;
    )  &#13;
&#13;
    http.HandleFunc("/hello", helloHandler)&#13;
&#13;
    if clientCert, err = ioutil.ReadFile("../client/clientCrt.pem")<span class="ent">❸</span>; err != nil {&#13;
        log.Fatalln(err)&#13;
    }  &#13;
    pool = x509.NewCertPool()&#13;
    pool.AppendCertsFromPEM(clientCert) <span class="ent">❹</span>&#13;
&#13;
    tlsConf = &amp;tls.Config{ <span class="ent">❺</span>&#13;
        ClientCAs:  pool,&#13;
        ClientAuth: tls.RequireAndVerifyClientCert,&#13;
    }  &#13;
    tlsConf.BuildNameToCertificate() <span class="ent">❻</span>&#13;
&#13;
    server = &amp;http.Server{&#13;
        Addr:      ":9443",&#13;
        TLSConfig: tlsConf, <span class="ent">❼</span>&#13;
    }  &#13;
    log.Fatalln(server.ListenAndServeTLS("serverCrt.pem", "serverKey.pem")<span class="ent">❽</span>)&#13;
}</pre>&#13;
<p class="caption" id="ch11list6"><em>Listing 11-6: Setting up a mutual authentication server (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/mutual-auth/cmd/server/main.go">/ch-11/mutual-auth/cmd/server/main.go</a><em>)</em></p>&#13;
<p class="indent">Outside the <span class="literal">main()</span> function, the program defines a <span class="literal">helloHandler()</span> function <span class="ent">❶</span>. As we discussed way back in <a href="ch03.xhtml#ch3">Chapters 3</a> and <a href="ch04.xhtml#ch4">4</a>, the handler function accepts an <span class="literal">http.ResponseWriter</span> instance and the <span class="literal">http.Request</span> itself. This handler is pretty boring. It logs the common name of the client certificate received <span class="ent">❷</span>. The common name is accessed by inspecting the <span class="literal">http.Request</span>’s <span class="literal">TLS</span> field and drilling down into the certificate <span class="literal">PeerCertificates</span> data. The handler function also sends the client a message indicating that authentication was successful.</p>&#13;
<p class="indent">But how do you define which clients are authorized, and how do you authenticate them? The process is fairly painless. You first read the client’s certificate from the PEM file the client created previously <span class="ent">❸</span>. Because it’s possible to have more than one authorized client certificate, you create a certificate pool and call <span class="literal">pool.AppendCertsFromPEM(clientCert)</span> to add the client certificate to your pool <span class="ent">❹</span>. You perform this step for each additional client you wish to authenticate.</p>&#13;
<p class="indent">Next, you create your TLS configuration. You explicitly set the <span class="literal">ClientCAs</span> field to your <span class="literal">pool</span> and configure <span class="literal">ClientAuth</span> to <span class="literal">tls.RequireAndVerifyClientCert</span> <span class="ent">❺</span>. <span epub:type="pagebreak" id="page_250"/>This configuration defines your pool of authorized clients and requires clients to properly identify themselves before they’ll be allowed to proceed. You issue a call to <span class="literal">tlsConf.BuildNameToCertificate()</span> so that the client’s common and subject alternate names—the domain names for which the certificate was generated—will properly map to their given certificate <span class="ent">❻</span>. You define your HTTP server, explicitly setting your custom configuration <span class="ent">❼</span>, and start the server by calling <span class="literal">server.ListenAndServeTLS()</span>, passing to it the server certificate and private-key files you created previously <span class="ent">❽</span>. Note that you don’t use the client’s private-key file anywhere in the server code. As we’ve said before, the private key remains private; your server will be able to identify and authorize clients by using only the client’s public key. This is the brilliance of public-key crypto.</p>&#13;
<p class="indent">You can validate your server by using <span class="literal">curl</span>. If you generate and supply a bogus, unauthorized client certificate and key, you’ll be greeted with a verbose message telling you so:</p>&#13;
<pre><span class="codestrong1">$ curl -ik -X GET --cert badCrt.pem --key badKey.pem \</span>&#13;
  <span class="codestrong1">https://server.blackhat-go.local:9443/hello</span>&#13;
curl: (35) gnutls_handshake() failed: Certificate is bad</pre>&#13;
<p class="indent">You’ll also get a more verbose message on the server, something like this:</p>&#13;
<pre>http: TLS handshake error from 127.0.0.1:61682: remote error: tls: unknown certificate authority</pre>&#13;
<p class="indent">On the flip side, if you supply the valid certificate and the key that matches the certificate configured in the server pool, you’ll enjoy a small moment of glory as it successfully authenticates:</p>&#13;
<pre><span class="codestrong1">$ curl -ik -X GET --cert clientCrt.pem --key clientKey.pem \</span>&#13;
  <span class="codestrong1">https://server.blackhat-go.local:9443/hello</span>&#13;
HTTP/1.1 200 OK&#13;
Date: Fri, 09 Oct 2020 16:55:52 GMT&#13;
Content-Length: 25&#13;
Content-Type: text/plain; charset=utf-8&#13;
&#13;
Authentication successful</pre>&#13;
<p class="indent">This message tells you the server works as expected.</p>&#13;
<p class="indent">Now, let’s have a look at a client (<a href="ch11.xhtml#ch11list7">Listing 11-7</a>). You can run the client on either the same system as the server or a different one. If it’s on a different system, you’ll need to transfer <em>clientCrt.pem</em> to the server and <em>serverCrt.pem</em> to the client.</p>&#13;
<pre>func main() {&#13;
    var (&#13;
        err              error&#13;
        cert             tls.Certificate&#13;
        serverCert, body []byte&#13;
        pool             *x509.CertPool&#13;
        tlsConf          *tls.Config&#13;
<span epub:type="pagebreak" id="page_251"/>        transport        *http.Transport&#13;
        client           *http.Client&#13;
        resp             *http.Response&#13;
    )  &#13;
&#13;
    if cert, err = tls.LoadX509KeyPair("clientCrt.pem", "clientKey.pem"); err != nil { <span class="ent">❶</span>&#13;
        log.Fatalln(err)&#13;
    }  &#13;
&#13;
    if serverCert, err = ioutil.ReadFile("../server/serverCrt.pem"); err != nil { <span class="ent">❷</span>&#13;
        log.Fatalln(err)&#13;
    }  &#13;
&#13;
    pool = x509.NewCertPool()&#13;
    pool.AppendCertsFromPEM(serverCert) <span class="ent">❸</span>&#13;
&#13;
    tlsConf = &amp;tls.Config{ <span class="ent">❹</span>&#13;
        Certificates: []tls.Certificate{cert},&#13;
        RootCAs:      pool,&#13;
    }  &#13;
    tlsConf.BuildNameToCertificate()<span class="ent">❺</span>&#13;
&#13;
    transport = &amp;http.Transport{ <span class="ent">❻</span>&#13;
        TLSClientConfig: tlsConf,&#13;
    }  &#13;
    client = &amp;http.Client{ <span class="ent">❼</span>&#13;
        Transport: transport,&#13;
    }  &#13;
&#13;
    if resp, err = client.Get("https://server.blackhat-go.local:9443/hello"); err != nil { <span class="ent">❽</span>&#13;
        log.Fatalln(err)&#13;
    }  &#13;
    if body, err = ioutil.ReadAll(resp.Body); err != nil { <span class="ent">❾</span>&#13;
        log.Fatalln(err)&#13;
    }  &#13;
    defer resp.Body.Close()&#13;
&#13;
    fmt.Printf("Success: %s\n", body)&#13;
}</pre>&#13;
<p class="caption" id="ch11list7"><em>Listing 11-7: The mutual authentication client (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/mutual-auth/cmd/client/main.go">/ch-11/mutual-auth/cmd/client/main.go</a><em>)</em></p>&#13;
<p class="indent">A lot of the certificate preparation and configuration will look similar to what you did in the server code: creating a pool of certificates and preparing subject and common names. Since you won’t be using the client certificate and key as a server, you instead call <span class="literal">tls.</span><span class="literal">LoadX509KeyPair("clientCrt.pem",</span><span class="literal"/> <span class="literal">"clientKey.pem")</span> to load them for use later <span class="ent">❶</span>. You also read the server certificate, adding it to the pool of certificates you wish to allow <span class="ent">❷</span>. You then use the pool and client certificates <span class="ent">❸</span> to build your TLS configuration <span class="ent">❹</span>, and call <span class="literal">tlsConf.BuildNameToCertificate()</span> to bind domain names to their respective certificates <span class="ent">❺</span>.</p>&#13;
<p class="indent">Since you’re creating an HTTP client, you have to define a transport <span class="ent">❻</span>, correlating it with your TLS configuration. You can then use the transport <span epub:type="pagebreak" id="page_252"/>instance to create an <span class="literal">http.Client</span> struct <span class="ent">❼</span>. As we discussed in <a href="ch03.xhtml#ch3">Chapters 3</a> and <a href="ch04.xhtml#ch4">4</a>, you can use this client to issue an HTTP GET request via <span class="literal">client.Get("https://server.blackhat-go.local:9443/hello")</span> <span class="ent">❽</span>.</p>&#13;
<p class="indent">All the magic happens behind the scenes at this point. Mutual authentication is performed—the client and the server mutually authenticate each other. If authentication fails, the program returns an error and exits. Otherwise, you read the HTTP response body and display it to stdout <span class="ent">❾</span>. Running your client code produces the expected result, specifically, that there were no errors thrown and that authentication succeeds:</p>&#13;
<pre><span class="codestrong1">$ go run main.go</span>&#13;
Success: Authentication successful</pre>&#13;
<p class="indent">Your server output is shown next. Recall that you configured the server to log a hello message to standard output. This message contains the common name of the connecting client, extracted from the certificate:</p>&#13;
<pre><span class="codestrong1">$ go run main.go</span>&#13;
Hello: client.blackhat-go.local</pre>&#13;
<p class="indent">You now have a functional sample of mutual authentication. To further enhance your understanding, we encourage you to tweak the previous examples so they work over TCP sockets.</p>&#13;
<p class="indent">In the next section, you’ll dedicate your efforts to a more devious purpose: brute-forcing RC2 encryption cipher symmetric keys.</p>&#13;
<h3 class="h3" id="ch11lev1sec6">Brute-Forcing RC2</h3>&#13;
<p class="noindent"><em>RC2</em> is a symmetric-key block cipher created by Ron Rivest in 1987. Prompted by recommendations from the government, the designers used a 40-bit encryption key, which made the cipher weak enough that the US government could brute-force the key and decrypt communications. It provided ample confidentiality for most communications but allowed the government to peep into chatter with foreign entities, for example. Of course, back in the 1980s, brute-forcing the key required significant computing power, and only well-funded nation states or specialty organizations had the means to decrypt it in a reasonable amount of time. Fast-forward 30 years; today, the common home computer can brute-force a 40-bit key in a few days or weeks.</p>&#13;
<p class="indent">So, what the heck, let’s brute force a 40-bit key.</p>&#13;
<h4 class="h4" id="ch11lev2sec5">Getting Started</h4>&#13;
<p class="noindent">Before we dive into the code, let’s set the stage. First of all, neither the standard nor extended Go crypto libraries have an RC2 package intended for public consumption. However, there’s an internal Go package for it. You can’t import internal packages directly in external programs, so you’ll have to find another way to use it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_253"/>Second, to keep things simple, you’ll make some assumptions about the data that you normally wouldn’t want to make. Specifically, you’ll assume that the length of your cleartext data is a multiple of the RC2 block size (8 bytes) to avoid clouding your logic with administrative tasks like handling PKCS #5 padding. Handling the padding is similar to what you did with AES previously in this chapter (see <a href="ch11.xhtml#ch11list4">Listing 11-4</a>), but you’d need to be more diligent in validating the contents to maintain the integrity of the data you’ll be working with. You’ll also assume that your ciphertext is an encrypted credit card number. You’ll check the potential keys by validating the resulting plaintext data. In this case, validating the data involves making sure the text is numeric and then subjecting it to a <em>Luhn check</em>, which is a method of validating credit card numbers and other sensitive data.</p>&#13;
<p class="indent">Next, you’ll assume you were able to determine—perhaps from pilfering filesystem data or source code—that the data is encrypted using a 40-bit key in ECB mode with no initialization vector. RC2 supports variable-length keys and, since it’s a block cipher, can operate in different modes. In ECB mode, which is the simplest mode, blocks of data are encrypted independently of other blocks. This will make your logic a little more straightforward. Lastly, although you can crack the key in a nonconcurrent implementation, if you so choose, a concurrent implementation will be far better performing. Rather than building this thing iteratively, showing first a nonconcurrent version followed by a concurrent one, we’ll go straight for the concurrent build.</p>&#13;
<p class="indent">Now you’ll install a couple of prerequisites. First, retrieve the official RC2 Go implementation from <a href="https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go"><em>https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go</em></a>. You’ll need to install this in your local workspace so that you can import it into your brute-forcer. As we mentioned earlier, the package is an internal package, meaning that, by default, outside packages can’t import and use it. This is a little hacky, but it’ll prevent you from having to use a third-party implementation or—shudder—writing your own RC2 cipher code. If you copy it into your workspace, the non-exported functions and types become part of your development package, which makes them accessible.</p>&#13;
<p class="indent">Let’s also install a package that you’ll use to perform the Luhn check:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/joeljunstrom/go-luhn</span></pre>&#13;
<p class="indent">A Luhn check calculates checksums on credit card numbers or other identification data to determine whether they’re valid. You’ll use the existing package for this. It’s well-documented and it’ll save you from re-creating the wheel.</p>&#13;
<p class="indent">Now you can write your code. You’ll need to iterate through every combination of the entire key space (40-bits), decrypting your ciphertext with each key, and then validating your result by making sure it both consists of only numeric characters and passes a Luhn check. You’ll use a producer/consumer model to manage the work—the producer will push a key to a channel and the consumers will read the key from the channel and execute accordingly. The work itself will be a single key value. When you <span epub:type="pagebreak" id="page_254"/>find a key that produces properly validated plaintext (indicating you found a credit card number), you’ll signal each of the goroutines to stop their work.</p>&#13;
<p class="indent">One of the interesting challenges of this problem is how to iterate the key space. In our solution, you iterate it using a <span class="literal">for</span> loop, traversing the key space represented as <span class="literal">uint64</span> values. The challenge, as you’ll see, is that <span class="literal">uint64</span> occupies 64 bits of space in memory. So, converting from a <span class="literal">uint64</span> to a 40-bit (5-byte) <span class="literal">[]byte</span> RC2 key requires that you crop off 24 bits (3 bytes) of unnecessary data. Hopefully, this process becomes clear once you’ve looked at the code. We’ll take it slow, breaking down sections of the program and working through them one by one. <a href="ch11.xhtml#ch11list8">Listing 11-8</a> begins the program.</p>&#13;
<pre>   import (&#13;
       "crypto/cipher"&#13;
       "encoding/binary"&#13;
       "encoding/hex"&#13;
       "fmt"&#13;
       "log"&#13;
       "regexp"&#13;
       "sync"&#13;
&#13;
     <span class="ent">❶</span> luhn "github.com/joeljunstrom/go-luhn"&#13;
&#13;
     <span class="ent">❷</span> "github.com/bhg/ch-11/rc2-brute/rc2"&#13;
   )&#13;
&#13;
<span class="ent">❸</span> var numeric = regexp.MustCompile(`^\d{8}$`)&#13;
&#13;
<span class="ent">❹</span> type CryptoData struct {&#13;
       block cipher.Block&#13;
       key   []byte&#13;
   }</pre>&#13;
<p class="caption" id="ch11list8"><em>Listing 11-8: Importing the RC2 brute-force type (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go">/ch-11/rc2-brute/main.go</a><em>)</em></p>&#13;
<p class="indent">We’ve included the <span class="literal">import</span> statements here to draw attention to the inclusion of the third-party <span class="literal">go-luhn</span> package <span class="ent">❶</span>, as well as the inclusion of the <span class="literal">rc2</span> package <span class="ent">❷</span> you cloned from the internal Go repository. You also compile a regular expression <span class="ent">❸</span> that you’ll use to check whether the resulting plaintext block is 8 bytes of numeric data.</p>&#13;
<p class="indent">Note that you’re checking 8 bytes of data and not 16 bytes, which is the length of your credit card number. You’re checking 8 bytes because that’s the length of an RC2 block. You’ll be decrypting your ciphertext block by block, so you can check the first block you decrypt to see whether it’s numeric. If the 8 bytes of the block aren’t all numeric, you can confidently assume that you aren’t dealing with a credit card number and can skip the decryption of the second block of ciphertext altogether. This minor performance improvement will significantly reduce the time it takes to execute millions of times over.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>Lastly, you define a type named <span class="literal">CryptoData</span> <span class="ent">❹</span> that you’ll use to store your key and a <span class="literal">cipher.Block</span>. You’ll use this <span class="literal">struct</span> to define units of work, which producers will create and consumers will act upon.</p>&#13;
<h4 class="h4" id="ch11lev2sec6">Producing Work</h4>&#13;
<p class="noindent">Let’s look at the producer function (<a href="ch11.xhtml#ch11list9">Listing 11-9</a>). You place this function after your type definitions in the previous code listing.</p>&#13;
<pre><span class="ent">❶</span> func generate(start, stop uint64, out chan &lt;- *CryptoData,\&#13;
   done &lt;- chan struct{}, wg *sync.WaitGroup) {&#13;
    <span class="ent">❷</span> wg.Add(1)&#13;
    <span class="ent">❸</span> go func() {&#13;
        <span class="ent">❹</span> defer wg.Done()&#13;
           var (&#13;
               block cipher.Block&#13;
               err   error&#13;
               key   []byte&#13;
               data  *CryptoData&#13;
           )&#13;
        <span class="ent">❺</span> for i := start; i &lt;= stop; i++ {&#13;
               key = make([]byte, 8)&#13;
            <span class="ent">❻</span> select {&#13;
            <span class="ent">❼</span> case &lt;- done:&#13;
                   return&#13;
            <span class="ent">❽</span> default:&#13;
                <span class="ent">❾</span> binary.BigEndian.PutUint64(key, i)&#13;
                   if block, err = rc2.New(key[3:], 40); err != nil {&#13;
                       log.Fatalln(err)&#13;
                   }&#13;
                   data = &amp;CryptoData{&#13;
                       block: block,&#13;
                       key:   key[3:],&#13;
                   }&#13;
                <span class="ent">❿</span> out &lt;- data&#13;
               }&#13;
           }&#13;
       }()&#13;
&#13;
       return&#13;
   }</pre>&#13;
<p class="caption" id="ch11list9"><em>Listing 11-9: The RC2 producer function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go">/ch-11/rc2-brute/main.go</a><em>)</em></p>&#13;
<p class="indent">Your producer function is named <span class="literal">generate()</span> <span class="ent">❶</span>. It accepts two <span class="literal">uint64</span> variables used to define a segment of the key space on which the producer will create work (basically, the range over which they’ll produce keys). This allows you to break up the key space, distributing portions of it to each producer.</p>&#13;
<p class="indent">The function also accepts two channels: a <span class="literal">*CryptData</span> write-only channel used for pushing work to consumers and a generic <span class="literal">struct</span> channel that’ll be used for receiving signals from consumers. This second channel <span epub:type="pagebreak" id="page_256"/>is necessary so that, for example, a consumer that identifies the correct key can explicitly signal the producer to stop producing. No sense creating more work if you’ve already solved the problem. Lastly, your function accepts a <span class="literal">WaitGroup</span> to be used for tracking and synchronizing producer execution. For each concurrent producer that runs, you execute <span class="literal">wg.Add(1)</span> <span class="ent">❷</span> to tell the <span class="literal">WaitGroup</span> that you started a new producer.</p>&#13;
<p class="indent">You populate your work channel within a goroutine <span class="ent">❸</span>, including a call to <span class="literal">defer wg.Done()</span> <span class="ent">❹</span> to notify your <span class="literal">WaitGroup</span> when the goroutine exits. This will prevent deadlocks later as you try to continue execution from your <span class="literal">main()</span> function. You use your <span class="literal">start()</span> and <span class="literal">stop()</span> values to iterate a subsection of the key space by using a <span class="literal">for</span> loop <span class="ent">❺</span>. Every iteration of the loop increments the <span class="literal">i</span> variable until you’ve reached your ending offset.</p>&#13;
<p class="indent">As we mentioned previously, your key space is 40 bits, but <span class="literal">i</span> is 64 bits. This size difference is crucial to understand. You don’t have a native Go type that is 40 bits. You have only 32- or 64-bit types. Since 32 bits is too small to hold a 40-bit value, you need to use your 64-bit type instead, and account for the extra 24 bits later. Perhaps you could avoid this whole challenge if you could iterate the entire key space by using a <span class="literal">[]byte</span> instead of a <span class="literal">uint64</span>. But doing so would likely require some funky bitwise operations that may overcomplicate the example. So, you’ll deal with the length nuance instead.</p>&#13;
<p class="indent">Within your loop, you include a <span class="literal">select</span> statement <span class="ent">❻</span> that may look silly at first, because it’s operating on channel data and doesn’t fit the typical syntax. You use it to check whether your <span class="literal">done</span> channel has been closed via <span class="literal">case &lt;- done</span> <span class="ent">❼</span>. If the channel is closed, you issue a <span class="literal">return</span> statement to break out of your goroutine. When the <span class="literal">done</span> channel isn’t closed, you use the <span class="literal">default</span> case <span class="ent">❽</span> to create the crypto instances necessary to define work. Specifically, you call <span class="literal">binary.BigEndian.PutUint64(key, i)</span> <span class="ent">❾</span> to write your <span class="literal">uint64</span> value (the current key) to a <span class="literal">[]byte</span> named <span class="literal">key</span>.</p>&#13;
<p class="indent">Although we didn’t explicitly call it out earlier, you initialized <span class="literal">key</span> as an 8-byte slice. So why are you defining the slice as 8 bytes when you’re dealing with only a 5-byte key? Well, since <span class="literal">binary.BigEndian.PutUint64</span> takes a <span class="literal">uint64</span> value, it requires a destination slice of 8 bytes in length or else it throws an index-out-of-range error. It can’t fit an 8-byte value into a 5-byte slice. So, you give it an 8-byte slice. Notice throughout the remainder of the code, you use only the last 5 bytes of the <span class="literal">key</span> slice; even though the first 3 bytes will be zero, they will still corrupt the austerity of our crypto functions if included. This is why you call <span class="literal">rc2.New(key[3:], 40)</span> to create your cipher initially; doing so drops the 3 irrelevant bytes and also passes in the length, in bits, of your key: 40. You use the resulting <span class="literal">cipher.Block</span> instance and the relevant key bytes to create a <span class="literal">CryptoData</span> object, and you write it to the <span class="literal">out</span> worker channel <span class="ent">❿</span>.</p>&#13;
<p class="indent">That’s it for the producer code. Notice that in this section you’re only bootstrapping the relevant key data needed. Nowhere in the function are you actually attempting to decrypt the ciphertext. You’ll perform this work in your consumer function.</p>&#13;
<h4 class="h4" id="ch11lev2sec7"><span epub:type="pagebreak" id="page_257"/>Performing Work and Decrypting Data</h4>&#13;
<p class="noindent">Let’s review the consumer function now (<a href="ch11.xhtml#ch11list10">Listing 11-10</a>). Again, you’ll add this function to the same file as your previous code.</p>&#13;
<pre><span class="ent">❶</span> func decrypt(ciphertext []byte, in &lt;- chan *CryptoData, \&#13;
   done chan struct{}, wg *sync.WaitGroup) {&#13;
       size := rc2.BlockSize&#13;
       plaintext := make([]byte, len(ciphertext))&#13;
    <span class="ent">❷</span> wg.Add(1)&#13;
       go func() {  &#13;
        <span class="ent">❸</span> defer wg.Done()&#13;
        <span class="ent">❹</span> for data := range in {&#13;
               select {&#13;
            <span class="ent">❺</span> case &lt;- done:&#13;
                   return&#13;
            <span class="ent">❻</span> default:&#13;
                <span class="ent">❼</span> data.block.Decrypt(plaintext[:size], ciphertext[:size])&#13;
                <span class="ent">❽</span> if numeric.Match(plaintext[:size]) {&#13;
                    <span class="ent">❾</span> data.block.Decrypt(plaintext[size:], ciphertext[size:])&#13;
                    <span class="ent">❿</span> if luhn.Valid(string(plaintext)) &amp;&amp; \&#13;
                       numeric.Match(plaintext[size:]) {&#13;
                           fmt.Printf("Card [%s] found using key [%x]\n", /&#13;
                           plaintext, data.key)&#13;
                           close(done)&#13;
                           return&#13;
                       }&#13;
                   }&#13;
               }&#13;
           }&#13;
       }()&#13;
   }</pre>&#13;
<p class="caption" id="ch11list10"><em>Listing 11-10: The RC2 consumer function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go">/ch-11/rc2-brute/main.go</a><em>)</em></p>&#13;
<p class="indent">Your consumer function, named <span class="literal">decrypt()</span> <span class="ent">❶</span>, accepts several parameters. It receives the ciphertext you wish to decrypt. It also accepts two separate channels: a read-only <span class="literal">*CryptoData</span> channel named <span class="literal">in</span> that you’ll use as a work queue and a channel named <span class="literal">done</span> that you’ll use for sending and receiving explicit cancellation signals. Lastly, it also accepts a <span class="literal">*sync.WaitGroup</span> named <span class="literal">wg</span> that you’ll use for managing your consumer workers, much like your producer implementation. You tell your <span class="literal">WaitGroup</span> that you’re starting a worker by calling <span class="literal">wg.Add(1)</span> <span class="ent">❷</span>. This way, you’ll be able to track and manage all the consumers that are running.</p>&#13;
<p class="indent">Next, inside your goroutine, you call <span class="literal">defer wg.Done()</span> <span class="ent">❸</span> so that when the goroutine function ends, you’ll update the <span class="literal">WaitGroup</span> state, reducing the number of running workers by one. This <span class="literal">WaitGroup</span> business is necessary for you to synchronize the execution of your program across an arbitrary number of workers. You’ll use the <span class="literal">WaitGroup</span> in your <span class="literal">main()</span> function later to wait for your <span class="literal">goroutines</span> to complete.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_258"/>The consumer uses a <span class="literal">for</span> loop <span class="ent">❹</span> to repeatedly read <span class="literal">CryptoData</span> work structs from the <span class="literal">in</span> channel. The loop stops when the channel is closed. Recall that the producer populates this channel. As you’ll see shortly, this channel closes after the producers have iterated their entire key space subsections and pushed the relative crypto data onto the work channel. Therefore, your consumer loops until the producers are done producing.</p>&#13;
<p class="indent">As you did in the producer code, you use a <span class="literal">select</span> statement within the <span class="literal">for</span> loop to check whether the <span class="literal">done</span> channel has been closed <span class="ent">❺</span>, and if it has, you explicitly signal the consumer to stop additional work efforts. A worker will close the channel when a valid credit card number has been identified, as we’ll discuss in a moment. Your <span class="literal">default</span> case <span class="ent">❻</span> performs the crypto heavy lifting. First, it decrypts the first block (8 bytes) of ciphertext <span class="ent">❼</span>, checking whether the resulting plaintext is an 8-byte, numeric value <span class="ent">❽</span>. If it is, you have a potential card number and proceed to decrypt the second block of ciphertext <span class="ent">❾</span>. You call these decryption functions by accessing the <span class="literal">cipher.Block</span> field within your <span class="literal">CryptoData</span> work object that you read in from the channel. Recall that the producer instantiated the struct by using a unique key value taken from the key space.</p>&#13;
<p class="indent">Lastly, you validate the entirety of the plaintext against the Luhn algorithm and validate that the second block of plaintext is an 8-byte, numeric value <span class="ent">❿</span>. If these checks succeed, you can be reasonably sure that you found a valid credit card number. You display the card number and the key to <span class="literal">stdout</span> and call <span class="literal">close(done)</span> to signal the other goroutines that you’ve found what you’re after.</p>&#13;
<h4 class="h4" id="ch11lev2sec8">Writing the Main Function</h4>&#13;
<p class="noindent">By this point, you have your producer and consumer functions, both equipped to execute with concurrency. Now, let’s tie it all together in your <span class="literal">main()</span> function (<a href="ch11.xhtml#ch11list11">Listing 11-11</a>), which will appear in the same source file as the previous listings.</p>&#13;
<pre>func main() {&#13;
    var (&#13;
        err        error&#13;
        ciphertext []byte&#13;
    )&#13;
&#13;
    if ciphertext, err = hex.DecodeString("0986f2cc1ebdc5c2e25d04a136fa1a6b"); err != nil { <span class="ent">❶</span>&#13;
        log.Fatalln(err)&#13;
    }&#13;
&#13;
    var prodWg, consWg sync.WaitGroup <span class="ent">❷</span>&#13;
    var min, max, prods = uint64(0x0000000000), uint64(0xffffffffff), uint64(75)&#13;
    var step = (max - min) / prods&#13;
&#13;
    done := make(chan struct{})&#13;
    work := make(chan *CryptoData, 100)&#13;
    if (step * prods) &lt; max { <span class="ent">❸</span>&#13;
        step += prods&#13;
    }&#13;
<span epub:type="pagebreak" id="page_259"/>    var start, end = min, min + step&#13;
    log.Println("Starting producers...")&#13;
    for i := uint64(0); i &lt; prods; i++ { <span class="ent">❹</span>&#13;
        if end &gt; max {&#13;
            end = max&#13;
        }&#13;
        generate(start, end, work, done, &amp;prodWg) <span class="ent">❺</span>&#13;
        end += step&#13;
        start += step&#13;
    }&#13;
    log.Println("Producers started!")&#13;
    log.Println("Starting consumers...")&#13;
    for i := 0; i &lt; 30; i++ { <span class="ent">❻</span>&#13;
        decrypt(ciphertext, work, done, &amp;consWg) <span class="ent">❼</span>&#13;
    }&#13;
    log.Println("Consumers started!")&#13;
    log.Println("Now we wait...")&#13;
    prodWg.Wait()<span class="ent">❽</span>&#13;
    close(work)&#13;
    consWg.Wait()<span class="ent">❾</span>&#13;
    log.Println("Brute-force complete")&#13;
}</pre>&#13;
<p class="caption" id="ch11list11"><em>Listing 11-11: The RC2</em> <span class="codeitalic">main()</span> <em>function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go">/ch-11/rc2-brute/main.go</a><em>)</em></p>&#13;
<p class="indent">Your <span class="literal">main()</span> function decodes your ciphertext, represented as a hexadecimal string <span class="ent">❶</span>. Next, you create several variables <span class="ent">❷</span>. First you create <span class="literal">WaitGroup</span> variables used for tracking both producer and consumer goroutines. You also define several <span class="literal">uint64</span> values for tracking the minimum value in a 40-bit key space (0x0000000000), the maximum value in the key space (0xffffffffff), and the number of producers you intend to start, in this case <span class="literal">75</span>. You use these values to calculate a step or range, which represents the number of keys each producer will iterate, since your intent is to distribute these efforts uniformly across all your producers. You also create a <span class="literal">*CryptoData</span> work channel and a <span class="literal">done</span> signaling channel. You’ll pass these around to your producer and consumer functions.</p>&#13;
<p class="indent">Since you’re doing basic integer math to calculate your step value for the producers, there’s a chance that you’ll lose some data if the key space size isn’t a multiple of the number of producers you’ll spin up. To account for this—and to avoid losing precision while converting to a floating-point number for use in a call to <span class="literal">math.Ceil()</span>—you check whether the maximum key (<span class="literal">step * prods</span>) is less than your maximum value for the entire key space (0xffffffffff) <span class="ent">❸</span>. If it is, a handful of values in the key space won’t be accounted for. You simply increase your <span class="literal">step</span> value to account for this shortage. You initialize two variables, <span class="literal">start</span> and <span class="literal">end</span>, to maintain the beginning and ending offsets you can use to break apart the key space.</p>&#13;
<p class="indent">The math to arrive at your offsets and step size isn’t precise by any means, and it could cause your code to search beyond the end of the maximum allowable key space. However, you fix that within a <span class="literal">for</span> loop <span class="ent">❹</span> used to start each of the producers. In the loop, you adjust your ending step value, <span class="literal">end</span>, should that value fall beyond the maximum allowed key space value. <span epub:type="pagebreak" id="page_260"/>Each iteration of the loop calls <span class="literal">generate()</span> <span class="ent">❺</span>, your producer function, and passes to it the start (<span class="literal">start</span>) and end (<span class="literal">end</span>) key space offsets for which the producer will iterate. You also pass it your <span class="literal">work</span> and <span class="literal">done</span> channels, as well as your producer <span class="literal">WaitGroup</span>. After calling the function, you shift your <span class="literal">start</span> and <span class="literal">end</span> variables to account for the next range of key space that will be passed to a new producer. This is how you break up your key space into smaller, more digestible portions that the program can process concurrently, without overlapping efforts between goroutines.</p>&#13;
<p class="indent">After your producers are spun up, you use a <span class="literal">for</span> loop to create your workers <span class="ent">❻</span>. In this case, you’re creating 30 of them. For each iteration, you call your <span class="literal">decrypt()</span> function <span class="ent">❼</span>, passing to it the ciphertext, the work channel, the done channel, and the consumer <span class="literal">WaitGroup</span>. This spins up your concurrent consumers, which begin to pull and process work as the producers create it.</p>&#13;
<p class="indent">Iterating through the entire key space takes time. If you don’t handle things correctly, the <span class="literal">main()</span> function will assuredly exit before you discover a key or exhaust key space. So, you need to make sure the producers and consumers have adequate time to either iterate the entire key space or discover the correct key. This is where your <span class="literal">WaitGroups</span> come in. You call <span class="literal">prodWg.Wait()</span> <span class="ent">❽</span> to block <span class="literal">main()</span> until the producers have completed their tasks. Recall that the producers have completed their tasks if they either exhaust the key space or explicitly cancel the process via the <span class="literal">done</span> channel. After this completes, you explicitly close the <span class="literal">work</span> channel so the consumers won’t deadlock continually while trying to read from it. Finally, you block <span class="literal">main()</span> again by calling <span class="literal">consWg.Wait()</span> <span class="ent">❾</span> to give adequate time for the consumers in your <span class="literal">WaitGroup</span> to complete any remaining <span class="literal">work</span> in the work channel.</p>&#13;
<h4 class="h4" id="ch11lev2sec9">Running the Program</h4>&#13;
<p class="noindent">You’ve completed your program! If you run it, you should see the following output:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
2020/07/12 14:27:47 Starting producers...&#13;
2020/07/12 14:27:47 Producers started!&#13;
2020/07/12 14:27:47 Starting consumers...&#13;
2020/07/12 14:27:47 Consumers started!&#13;
2020/07/12 14:27:47 Now we wait...&#13;
2020/07/12 14:27:48 Card [4532651325506680] found using key [e612d0bbb6]&#13;
2020/07/12 14:27:48 Brute-force complete</pre>&#13;
<p class="indent">The program starts the producers and consumers and then waits for them to execute. When a card is found, the program displays the cleartext card and the key used to decrypt that card. Since we assume this key is the magical key for all cards, we interrupt execution prematurely and celebrate our success by painting a self-portrait (not shown).</p>&#13;
<p class="indent">Of course, depending on the key value, brute-forcing on a home computer can take a significant amount of time—think days or even weeks. For the preceding sample run, we narrowed the key space to find the key more <span epub:type="pagebreak" id="page_261"/>quickly. However, completely exhausting the key space on a 2016 MacBook Pro takes approximately seven days. Not too bad for a quick-and-dirty solution running on a laptop.</p>&#13;
<h3 class="h3" id="ch11lev1sec7">Summary</h3>&#13;
<p class="noindent">Crypto is an important topic for security practitioners, even though the learning curve can be steep. This chapter covered symmetric and asymmetric crypto, hashing, password handling with bcrypt, message authentication, mutual authentication, and brute-forcing RC2. In the next chapter, we’ll get into the nitty-gritty of attacking Microsoft Windows.<span epub:type="pagebreak" id="page_262"/></p>&#13;
</div>



  </body></html>