<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><span epub:type="pagebreak" id="page_437"/>&#13;
<h2 class="h2" id="ch20"><strong><span class="big">20</span><br/>INPUT/OUTPUT</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="noindentz">The <em>I/O subsystem</em> is what programs use to communicate with the outside world, meaning devices other than the CPU and memory. Most programs read data from one or more input devices, process the data, and then write the results to one or more output devices.</p>&#13;
<p class="indent">Keyboards and mice are typical input devices; display screens and printers are typical output devices. Although most people don’t think of them this way, devices such as magnetic disks, solid-state drives (SSDs), USB sticks, and so forth are also I/O devices.</p>&#13;
<p class="indent">I’ll start this chapter by discussing some of the timing characteristics of I/O devices compared to memory, then I’ll cover how this affects the interface between the CPU and I/O devices.</p>&#13;
<h3 class="h3" id="ch20lev1sec1"><strong>Timing Considerations</strong></h3>&#13;
<p class="noindent">Since the CPU accesses memory and I/O devices over the same buses (see <a href="ch01.xhtml#ch1fig1">Figure 1-1</a> in <a href="ch01.xhtml">Chapter 1</a>), it might seem that a program could access I/O devices in the same way as it accesses memory. That is, you might expect that I/O can be performed by using the <code>ldr</code> and <code>str</code> instructions to transfer bytes of data between the CPU and a specific I/O device. This can be done with <span epub:type="pagebreak" id="page_438"/>many devices, but some particularities must be taken into account to make it work correctly. One of the main issues lies in the timing differences between memory and I/O. Before tackling I/O timing, let’s consider memory timing characteristics.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As I’ve pointed out, the three-bus description given in this book shows the logical interaction between the CPU and I/O devices. Most modern computers employ several types of buses. The way the CPU connects to the various buses is handled in hardware. A programmer generally deals only with the logical view.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch20lev2sec1"><em><strong>Memory Timing</strong></em></h4>&#13;
<p class="noindent">An important characteristic of memory is that its timing is relatively uniform and not dependent on external events. This means memory timing can be handled by the hardware, so programmers don’t need to be concerned about it; we can simply move data to and from memory using CPU instructions.</p>&#13;
<p class="indentb">Two types of RAM are commonly used in computers:</p>&#13;
<p class="noindentin"><strong>SRAM</strong>   Holds its values as long as the power is on. It requires more components to do this, so it is more expensive and physically larger, but access times are very fast.</p>&#13;
<p class="noindentin"><strong>DRAM</strong>   Uses passive components that hold data values for only a few fractions of a second. DRAM includes circuitry that automatically refreshes the data values before the values are completely lost. It is less expensive than SRAM, but also 5 to 10 times slower.</p>&#13;
<p class="indentgt">Most of the memory on the Raspberry Pi is DRAM, because it is much less expensive and smaller than SRAM. As each instruction must be fetched from memory, slow memory access limits program execution speed.</p>&#13;
<p class="indent">Program execution speed is improved by using cache memory systems made from SRAM. The combination of SRAM cache with DRAM main memory works well to ensure minimal time delays when the CPU accesses memory.</p>&#13;
<p class="indent">It’s worth noting here that CPU speeds are still faster than memory speeds (even SRAM). Accessing memory—fetching an instruction, loading data, storing data—is typically the most important factor that slows program execution. There are techniques for improving cache performance, which improves memory access times, but employing such techniques requires a thorough understanding of the CPU and memory configuration of the system you’re using, which is beyond the scope of this book.</p>&#13;
<h4 class="h4" id="ch20lev2sec2"><em><strong>I/O Device Timing</strong></em></h4>&#13;
<p class="noindent">Almost all I/O devices are much slower than memory. Consider a common input device, the keyboard. Typing at 120 words per minute is equivalent to entering approximately 10 characters per second, or a delay of ∼100 ms between each character. A CPU running at 2 GHz can execute approximately <span epub:type="pagebreak" id="page_439"/>200 million instructions during that time. This is to say nothing of the fact that the time intervals between keystrokes are very inconsistent. Many will be much longer than this.</p>&#13;
<p class="indent">Even an SSD is slow compared to memory. For example, data can be transferred to and from a typical SSD at about 500MBps. The transfer rate for DDR4 memory (which is commonly used for main memory) is around 20GBps, some 40 times faster.</p>&#13;
<p class="indent">In addition to being much slower, I/O devices exhibit much more variance in their timing. Some people type very quickly on a keyboard, some very slowly. The required data on a magnetic disk might be just coming up to the read/write head, or it may have just passed by, in which case you’ll have to wait for nearly a full revolution of the disk for it to come under the head again.</p>&#13;
<p class="indent">As pointed out at the beginning of <a href="ch09.xhtml">Chapter 9</a>, the Raspberry Pi uses a System on a Chip (SoC), which includes one or more processor cores and many of the controllers for other parts of the computer. Most SoCs based on the ARM architecture use the Advanced Microcontroller Bus Architecture (AMBA), first introduced by Arm in 1997. This architecture specifies several protocols, which are used to select the appropriate speeds for the communications between the CPU and other functional parts in the SoC. The details are beyond the scope of this book, but if you’re interested in learning more about AMBA, a good starting point is the free online training videos at <em><a href="https://www.arm.com/architecture/system-architectures/amba">https://www.arm.com/architecture/system-architectures/amba</a></em>.</p>&#13;
<p class="indent">The SoC includes controllers for most of the external I/O interfaces. All Raspberry Pis, except the Raspberry Pi Zero, have a second chip that provides additional external I/O interfaces. The I/O chip on a Raspberry Pi 1, 1+, 2, 3, or 3+ provides Ethernet and USB 2.0 ports, and it communicates with the SoC via USB 2.0. The I/O chip on a Raspberry Pi 4 provides USB 2.0 and USB 3.0 ports, and it communicates with the SoC via a PCI Express (PCI-E) bus.</p>&#13;
<p class="indent">The Raspberry Pi 5 uses a new I/O controller chip named <em>RP1</em> that incorporates most of the controllers for the external I/O interfaces that were previously on the SoC, including USB, MIPI camera and display, Ethernet, and general-purpose input/output (GPIO). Such a device is often called a <em>southbridge</em>. The RP1 communicates with the SoC via a PCI-E bus. Moving the slower I/O functionality to a separate chip simplifies the SoC, allowing it to run faster and to focus on computation-intensive tasks.</p>&#13;
<p class="indent">Next, I’ll show you how we access the registers of an I/O device.</p>&#13;
<h3 class="h3" id="ch20lev1sec2"><strong>Accessing I/O Devices</strong></h3>&#13;
<p class="noindent">The CPU works with an I/O device through a <em>device controller</em>, the hardware that does the actual work of controlling the I/O device. For example, a keyboard controller detects which key is pressed and converts this to a bit pattern that represents the key. It also detects whether modifier keys, such as SHIFT or CTRL, are pressed and sets the bit pattern accordingly.</p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_440"/>The device controller interfaces with the CPU through a set of registers. In general, a device controller provides the following types of I/O registers:</p>&#13;
<p class="noindentin"><strong>Data</strong>   Used to send data to an output device or to read data from an input device</p>&#13;
<p class="noindentin"><strong>Status</strong>   Provides information about the current state of the device, including the controller itself</p>&#13;
<p class="noindentin"><strong>Control</strong>   Allows a program to send commands to the controller to change the settings of the device and the controller</p>&#13;
<p class="indentgt">It’s common for a device controller interface to have more than one register of the same type, especially control registers and status registers.</p>&#13;
<p class="indent">Sending data to an output device is very much like storing data in memory: you store the data in a data register on the device controller. Where the output device differs from memory is the timing. As I’ve already said, a programmer doesn’t need to be concerned about the timing when storing data in memory. However, an output device may not be ready to accept new data—it may be working on previously sent data. This is where the status register comes into play. The program needs to check the status register to see if the device controller is ready to accept new data.</p>&#13;
<p class="indent">Reading data from an input device is like loading data from memory into the CPU: you load the data from a data register on the device controller. Again, the difference from memory is that an input device may not have new data, so the program needs to check the status register of the input device controller to see if it does.</p>&#13;
<p class="indent">Most I/O devices also need to be told what to do by a control register. For example, after waiting for an output device controller to become ready for new data and then moving the data to a data register, some device controllers require that you tell them to output the data to the actual device. Or, if you want to get data from an input device, some device controllers require that you request them to get an input. You can send commands like these to a control register.</p>&#13;
<p class="indent">The CPU can access the I/O registers on a device controller in two ways: via memory-mapped I/O and port-mapped I/O. With <em>memory-mapped I/O</em>, a range of memory addresses is dedicated to the I/O ports, and each I/O register is mapped to one of the memory addresses in that range. Then, the load and store instructions are used to read from or write to the I/O registers on a device controller.</p>&#13;
<p class="indent">With <em>port-mapped I/O</em>, the I/O device controller registers are assigned addresses in a separate addressing space. The CPU uses special I/O instructions to communicate with the I/O registers.</p>&#13;
<p class="indent">The AArch64 architecture supports only memory-mapped I/O. The x86 architecture is an example of one that supports both types of I/O.</p>&#13;
<p class="indent">It’ll be easier to understand memory-mapped I/O if we first look at how memory is managed by Linux and most other operating systems when executing a program. Programs run in a <em>virtual memory</em> address space, a technique that simulates a large memory with contiguous addressing from 0 to <span epub:type="pagebreak" id="page_441"/>some maximum value. These are the addresses you see when using <code>gdb</code>—for example, the addresses in the <code>sp</code> and <code>pc</code> registers.</p>&#13;
<p class="indent">Although the AArch64 architecture allows 64-bit addressing, current CPU hardware implementations use only 52 bits for the address. This allows a maximum address of 2<sup>52</sup> bytes (4 pebibytes) to execute programs in this virtual address space. But a Raspberry Pi has only 1 to 8GiB (or gibibytes) of <em>physical memory</em>, the actual RAM installed in the computer, and a program needs to be in physical memory to be executed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>We commonly use the metric naming convention for specifying multiple-byte quantities that is based on powers of 10: kilobyte, megabyte, gigabyte, and so forth. The International Electrotechnical Commission (IEC) has also defined a naming convention that is based on powers of two: kibibyte, mebibyte, gibibyte, and so forth. For example, a kilobyte is 1,000 bytes, and a kibibyte is 1,024 bytes. You can read more about the naming conventions at</em> <a href="https://en.wikipedia.org/wiki/Byte">https://en.wikipedia.org/wiki/Byte</a>.</p>&#13;
</div>&#13;
<p class="indent">The operating system manages the placement of programs in physical memory by dividing each program into <em>pages</em>. Raspberry Pi OS uses a 4KiB (or kibibyte) page size on most models and a 16KiB page size on the model 5. Physical memory is divided into the same size <em>page frames</em>. The page of the program that contains the code currently being executed by the CPU is loaded from the place where it’s stored (for example, disk, DVD, USB stick) into a page frame of physical memory.</p>&#13;
<p class="indent">The operating system maintains a <em>page table</em> that shows where the page of the program is currently loaded in physical memory. <a href="ch20.xhtml#ch20fig1">Figure 20-1</a> shows the relationship between virtual memory and physical memory using the page table.</p>&#13;
<div class="image"><img id="ch20fig1" src="../images/pg469_Image_318.jpg" alt="Image" width="643" height="252"/></div>&#13;
<p class="figcap"><em>Figure 20-1: The relationship between virtual memory and physical memory</em></p>&#13;
<p class="indent">The SoC used on a Raspberry Pi includes a <em>memory management unit (MMU)</em>. When the CPU needs to access an item in memory, it uses the virtual address of the item. The MMU uses the virtual address as an index into the page table to locate the page in physical memory and, from there, the item. If the requested page is not currently loaded into physical memory, the MMU generates a <em>page fault exception</em>, which calls a function in the operating system to load the page into physical memory and enter its location in the page table. (You’ll learn about exceptions in <a href="ch21.xhtml">Chapter 21</a>.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_442"/>The page table is stored in main memory, so using it requires two memory accesses: one to retrieve the frame number from the page table and another to access the location in main memory. To speed things up, the MMU includes a <em>translation lookaside buffer (TLB)</em> in its hardware. The TLB is a small amount of fast memory that contains the most recently used entries from the page table. Like the memory cache you learned about in <a href="ch08.xhtml">Chapter 8</a>, the TLB uses the tendency of a program to reference nearby memory addresses over a short period of time to speed up memory accesses. The MMU first looks in the TLB. If the page table entry is there, then only one access of main memory is required.</p>&#13;
<p class="indent">Similar to how virtual memory is mapped to physical memory, virtual memory addresses can be mapped to the I/O device controller register address space. Having the controller registers associated with virtual memory addresses allows us to use the CPU instructions that access memory to access the I/O device controller registers. One advantage of memory-mapped I/O is that you can usually write the I/O functions in a higher-level language such as C without using inline assembly language.</p>&#13;
<h3 class="h3" id="ch20lev1sec3"><strong>I/O Programming</strong></h3>&#13;
<p class="noindent">Depending on the amount of data they process and the speed with which they process it, I/O devices use different techniques for communicating with the CPU. These differences are reflected in the way a device controller is programmed to perform its functions.</p>&#13;
<p class="indent">When timing is not important, we can simply use instructions to send a data item to an output device or read a data item from an input device at the point in our program where we wish to output or input it. This works for I/O devices that don’t need time to process the binary data being transferred. You’ll see an example of this technique later in this chapter, when we program an I/O device to output one of two voltage levels on a single output pin.</p>&#13;
<p class="indent">Most I/O device controllers require significant time to process input and output data. For example, when we press a key on the keyboard, the keyboard device controller needs to detect which key was pressed and then convert that knowledge into an 8-bit pattern that represents the character we pressed. If our program needs that character, we have to first check the status register of the keyboard device controller to determine if it has completed this process. If the device controller is in a ready state, then we can read data from the device controller.</p>&#13;
<p class="indent">We do this in our program using a <em>polling</em> algorithm. Polling typically involves a loop that iterates, checking the device’s status register in each iteration of the loop, until the device is in a ready state. When the device controller is ready, we load the data into a general-purpose CPU register. When programmed I/O uses a polling algorithm, it’s often called <em>polled I/O</em>.</p>&#13;
<p class="indent">Similarly, an output device controller might be busy outputting a previous data item. Our program needs to poll the device controller and wait until it’s ready to accept new output data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_443"/>The downside of polled I/O is that the CPU can be tied up for a long time waiting for the device to become ready. This would probably be acceptable if the CPU were dedicated to running only one program on the system (for example, controlling a microwave oven), but it’s not acceptable in the multiprogram environments of modern computing.</p>&#13;
<p class="indent">We could get more work out of the CPU if we could tell an I/O device to let us know when it was ready for data input or output and use the CPU for something else in the meantime. Many I/O devices include an <em>interrupt controller</em> for just this purpose: it can send an interrupt signal to the CPU when the device has completed an operation or is ready to take on another operation.</p>&#13;
<p class="indent">An interrupt from an external device causes the CPU to call an <em>interrupt handler</em>, a function within the operating system that deals with the input or output from the interrupting device. This is usually called <em>interrupt-driven I/O</em>. I’ll discuss the features of a CPU that allow it to call interrupt handlers in <a href="ch21.xhtml">Chapter 21</a>.</p>&#13;
<p class="indent">In all of these techniques, the CPU initiates the transfer of data to or from the I/O device controller. We call this <em>programmed I/O</em>.</p>&#13;
<p class="indent">I/O devices that transfer large amounts of data at high speed often have the capability of <em>direct memory access (DMA)</em>. They have a <em>DMA controller</em> that can access main memory directly without the CPU. For example, when reading from a disk, the DMA controller accepts a memory address and a command to read data from the disk. When the DMA controller has read the data from the disk into its own buffer memory, it writes that data directly to main memory. When the DMA data transfer has completed, the controller sends an interrupt to the CPU, thus invoking the disk interrupt handler that notifies the operating system that the data is now available in memory.</p>&#13;
<p class="indent">Next, we’ll look at an output that doesn’t even need to be polled: a single pin that we can place at one of two voltages.</p>&#13;
<h3 class="h3" id="ch20lev1sec4"><strong>Programming a General-Purpose I/O Device</strong></h3>&#13;
<p class="noindent">A <em>general-purpose I/O (GPIO)</em> is a signal line that can be configured to either input or output 1 bit. They were originally implemented in groups on an integrated circuit chip, with each I/O line of the GPIO circuitry connected to a pin on the chip. These days, GPIO circuits are typically included in SoC designs, where they can be used for lighting an LED, reading a switch, and so forth.</p>&#13;
<p class="indent">All Raspberry Pi models include GPIOs arranged in groups, still called chips. One of the chips has 28 lines that are connected to pins on a 40-pin <em>GPIO header</em> located on the top edge of the Raspberry Pi board that we can use to control external I/O devices. (The original Raspberry Pi 1 has a 26-pin GPIO header connected to 17 GPIO lines.)</p>&#13;
<p class="indent">In this section, I’ll show you how to program a GPIO line to output a single bit that causes its corresponding GPIO header pin to alternate between 0.0 V and +3.3 V. We don’t need to poll the GPIO line to see if it’s ready for <span epub:type="pagebreak" id="page_444"/>this 1-bit output, because it’s always ready. We’ll use these voltage alternations to blink an LED.</p>&#13;
<p class="indent">The correspondences between the 28 GPIO lines and the GPIO header pins for a 40-pin header are shown in <a href="ch20.xhtml#ch20tab1">Table 20-1</a>.</p>&#13;
<p class="tabcap" id="ch20tab1"><strong>Table 20-1:</strong>  Correspondences Between GPIO Lines and Raspberry Pi Header Pins</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th">Signal</th>&#13;
<th class="tab_th">Header</th>&#13;
<th class="tab_th">pins</th>&#13;
<th class="tab_th">Signal</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">+3.3 V power</td>&#13;
<td class="bg1">1</td>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1">+5 V power</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO2</td>&#13;
<td class="bg">3</td>&#13;
<td class="bg">4</td>&#13;
<td class="bg">+5 V power</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">GPIO3</td>&#13;
<td class="bg1">5</td>&#13;
<td class="bg1">6</td>&#13;
<td class="bg1">Ground</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO4</td>&#13;
<td class="bg">7</td>&#13;
<td class="bg">8</td>&#13;
<td class="bg">GPIO14</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Ground</td>&#13;
<td class="bg1">9</td>&#13;
<td class="bg1">10</td>&#13;
<td class="bg1">GPIO15</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO17</td>&#13;
<td class="bg">11</td>&#13;
<td class="bg">12</td>&#13;
<td class="bg">GPIO18</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">GPIO27</td>&#13;
<td class="bg1">13</td>&#13;
<td class="bg1">14</td>&#13;
<td class="bg1">Ground</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO22</td>&#13;
<td class="bg">15</td>&#13;
<td class="bg">16</td>&#13;
<td class="bg">GPIO23</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">+3.3 V power</td>&#13;
<td class="bg1">17</td>&#13;
<td class="bg1">18</td>&#13;
<td class="bg1">GPIO24</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO10</td>&#13;
<td class="bg">19</td>&#13;
<td class="bg">20</td>&#13;
<td class="bg">Ground</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">GPIO9</td>&#13;
<td class="bg1">21</td>&#13;
<td class="bg1">22</td>&#13;
<td class="bg1">GPIO25</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO11</td>&#13;
<td class="bg">23</td>&#13;
<td class="bg">24</td>&#13;
<td class="bg">GPIO8</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Ground</td>&#13;
<td class="bg1">25</td>&#13;
<td class="bg1">26</td>&#13;
<td class="bg1">GPIO7</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO0</td>&#13;
<td class="bg">27</td>&#13;
<td class="bg">28</td>&#13;
<td class="bg">GPIO1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">GPIO5</td>&#13;
<td class="bg1">29</td>&#13;
<td class="bg1">30</td>&#13;
<td class="bg1">Ground</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO6</td>&#13;
<td class="bg">31</td>&#13;
<td class="bg">32</td>&#13;
<td class="bg">GPIO12</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">GPIO13</td>&#13;
<td class="bg1">33</td>&#13;
<td class="bg1">34</td>&#13;
<td class="bg1">Ground</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">GPIO19</td>&#13;
<td class="bg">35</td>&#13;
<td class="bg">36</td>&#13;
<td class="bg">GPIO16</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">GPIO26</td>&#13;
<td class="bg1">37</td>&#13;
<td class="bg1">38</td>&#13;
<td class="bg1">GPIO20</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Ground</td>&#13;
<td class="bg">39</td>&#13;
<td class="bg">40</td>&#13;
<td class="bg">GPIO21</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The pin numbering of the GPIO header assumes we are looking down at the top of the Raspberry Pi, with the header on the right. There are two rows of header pins, with the odd-numbered pins on the left and the even-numbered pins on the right. Notice that the GPIO lines are not in the same numerical order as the GPIO header pins.</p>&#13;
<p class="indent">You can also see this information online at <em><a href="https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header">https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header</a></em>, and on the Raspberry Pi the <code>pinout</code> command will give you the pin correspondence information.</p>&#13;
<p class="indent">Much of the Raspberry Pi documentation calls the signal from the GPIO device a GPIO pin. To avoid confusion, I’ll use the names <em>GPIO line</em> for the signals and <em>GPIO header pin</em> for the physical connectors on the GPIO header. As you’ll see later in this chapter, this naming convention is consistent with the <code>gpiod</code> library, which we’ll use for programming the GPIO lines in C. We’ll start by connecting our hardware circuit for blinking an LED.</p>&#13;
<span epub:type="pagebreak" id="page_445"/>&#13;
<h4 class="h4" id="ch20lev2sec3"><em><strong>Connecting the Blinking LED Circuit</strong></em></h4>&#13;
<p class="noindent">To follow along with this project, you’ll need an LED, a 220 Ω resistor, and several connecting jumper wires. Building the circuit on a breadboard is easier than just putting the components on a desktop or a workbench.</p>&#13;
<p class="indent">Before you connect anything to the GPIO header pins on your Raspberry Pi, you should shut it down and turn off the power. The pins are close together, and it’s easy to accidentally short two of them together, which may damage your Raspberry Pi.</p>&#13;
<p class="indent">We’ll use the circuit shown in <a href="ch20.xhtml#ch20fig2">Figure 20-2</a>.</p>&#13;
<div class="image"><img id="ch20fig2" src="../images/pg473_Image_319.jpg" alt="Image" width="360" height="81"/></div>&#13;
<p class="figcap"><em>Figure 20-2: The circuit for a blinking LED</em></p>&#13;
<p class="indent">You saw the circuit symbol for a resistor in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a> in <a href="ch05.xhtml">Chapter 5</a>. The triangle with two arrows above it is the circuit symbol for an LED, and the triangular-shaped group of three horizontal lines is the symbol for ground (0.0 V). Using the information in <a href="ch20.xhtml#ch20tab1">Table 20-1</a>, we’ll connect to GPIO17 using pin 11 on the GPIO header and connect to ground using header pin 9.</p>&#13;
<p class="indent">Make sure you connect the LED correctly. The left-hand side of the LED in this figure is the <em>anode</em> and the right-hand side is the <em>cathode</em>. The manufacturer of your LED should provide documentation showing which lead is which on the LED.</p>&#13;
<p class="indent">We’ll write a program that alternates the voltage on the GPIO17 pin between +3.3 V and 0.0 V. At +3.3 V, current flows through the resistor and LED, causing the LED to turn on. The 220 Ω resistor is necessary to limit the amount of current flowing through it, as excessive current could destroy the LED. When our program switches the GPIO17 pin to 0.0 V, current no longer flows through the LED, turning it off.</p>&#13;
<p class="indent">Let’s start with a C program to make sure our circuit is connected correctly.</p>&#13;
<h4 class="h4" id="ch20lev2sec4"><em><strong>Blinking an LED in C, All Models</strong></em></h4>&#13;
<p class="noindent">Raspberry Pi OS comes with two libraries of functions that allow us to work with the GPIO in high-level languages. The <code>pigpio</code> library provides C and Python functions, and <code>gpiozero</code> provides a simple Python programming interface. You can read about them at <em><a href="https://abyz.me.uk/rpi/pigpio/">https://abyz.me.uk/rpi/pigpio/</a></em> and <em><a href="https://gpiozero.readthedocs.io/en/stable/">https://gpiozero.readthedocs.io/en/stable/</a></em>, respectively.</p>&#13;
<p class="indent">As of this writing, the <code>pigpio</code> library does not work on the Raspberry Pi 5. I installed the <code>gpiod</code> package, which includes some useful command line tools for working with the GPIO. It also installs the <code>libgpiod</code> library, which is the officially supported interface to the GPIO. I have tested this library with C and Python programs on both my Raspberry Pi 3 and my Raspberry Pi 5. <span epub:type="pagebreak" id="page_446"/>I installed the command line and development tools with the following three commands:</p>&#13;
<pre class="pre">$ <span class="codestrong1">sudo apt install gpiod</span>&#13;
$ <span class="codestrong1">sudo apt install libgpiod-dev</span>&#13;
$ <span class="codestrong1">sudo apt install libgpiod-doc</span></pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At the time of writing, this installs version 1.6.3 of the library and tools. The developers have released version 2.1.1, but it’s not yet in the Raspberry Pi OS repository. When the repository is updated, I expect additional utilities to be added, and some of the function names in the library may change. The source code for all versions is available at</em> <a href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git">https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git</a>.</p>&#13;
</div>&#13;
<p class="indent">The <code>gpiod</code> package installs six utility programs for working with the GPIO device: <code>gpiodetect</code>, <code>gpiofind</code>, <code>gpioget</code>, <code>gpioinfo</code>, <code>gpiomon</code>, and <code>gpioset</code>. The <code>libgpiod-doc</code> package installs the man pages for each of these utilities, and the <code>libgpiod-dev</code> package installs the interface to the functions in the <code>libgpiod</code> library we’ll use to program the GPIO in C.</p>&#13;
<p class="indent">Other useful tools included with Raspberry Pi OS are <code>pinout</code> and <code>pinctrl</code>. The <code>pinout</code> program has a man page that describes its use. The <code>pinctrl help</code> command shows how to use <code>pinctrl</code>. I used <code>pinctrl</code> to help debug the programs to blink an LED that you’ll see here.</p>&#13;
<p class="indent">We will use functions from the <code>libgpiod</code> library to write a program in C, which is shown in <a href="ch20.xhtml#ch20list1">Listing 20-1</a>, to blink an LED for testing the circuit in <a href="ch20.xhtml#ch20fig2">Figure 20-2</a>. The documentation for our version of the library can be found at <em><a href="https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html">https://www.lane-fu.com/linuxmirror/libgpiod/doc/html/index.html</a></em>. If you prefer to use Python, see “Your Turn” <a href="ch20.xhtml#ch20exe2">exercise 20.2</a> on <a href="ch20.xhtml#ch20you1">page 460</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>blink_led.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Blink an LED.&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;unistd.h&gt;&#13;
#include &lt;gpiod.h&gt;&#13;
&#13;
#define LINE 17                // GPIO line connected to LED&#13;
#define OFF 0                  // Pin at 0.0 V&#13;
#define ON 1                   // Pin at 3.3 V&#13;
#define BLINKS 5               // Number of blinks&#13;
#define SECONDS 3              // Time between blinks&#13;
&#13;
int main(void)&#13;
{&#13;
  <span class="ent">❶</span>  struct gpiod_chip *chip;&#13;
      struct gpiod_line *line;&#13;
      int i;&#13;
      int error; <span epub:type="pagebreak" id="page_447"/>&#13;
  <span class="ent">❷</span>  chip = gpiod_chip_open("/dev/gpiochip0");  // On RPi 5 use /dev/gpiochip4&#13;
      if(!chip) {&#13;
           puts("Cannot open chip");&#13;
           return -1;&#13;
  }&#13;
&#13;
       line = gpiod_chip_get_line(chip, LINE);&#13;
       if(line == NULL) {&#13;
            gpiod_chip_close(chip);&#13;
            puts("Cannot get GPIO line");&#13;
            return -1;&#13;
       }&#13;
       error = gpiod_line_request_output(line, "example", 0);&#13;
       if(error == -1) {&#13;
            gpiod_line_release(line);&#13;
            gpiod_chip_close(chip);&#13;
            puts("Cannot set GPIO output");&#13;
            return -1;&#13;
       }&#13;
&#13;
       for (i = 0; i &lt; BLINKS; i++) {&#13;
        <span class="ent">❸</span>  gpiod_line_set_value(line, ON);&#13;
            printf("led on...\n");&#13;
            sleep(SECONDS);&#13;
            gpiod_line_set_value(line, OFF);&#13;
            printf("...led off\n");&#13;
            sleep(SECONDS);&#13;
       }&#13;
       gpiod_line_release(line);&#13;
       gpiod_chip_close(chip);&#13;
&#13;
       return 0;&#13;
}</pre>&#13;
<p class="list" id="ch20list1"><em>Listing 20-1: A C program to blink an LED using the GPIO</em></p>&#13;
<p class="indent">When compiling this file, we need to explicitly specify the <code>libgpiod</code> library at the end of the command, as shown here:</p>&#13;
<pre class="pre">$ <span class="codestrong1">gcc -g -Wall -o blink_led blink_led.c -lgpiod</span></pre>&#13;
<p class="indent">Both <code>struct gpiod_chip</code> and <code>struct gpiod_line</code> are declared in the <em>gpiod.h</em> header file <span class="ent">❶</span> as follows:</p>&#13;
<pre class="pre">struct gpiod_chip;&#13;
struct gpiod_line;</pre>&#13;
<p class="noindent">This C syntax is a way to define the <code>chip</code> and <code>line</code> pointer variables as holding addresses.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_448"/>The Raspberry Pi has several GPIO chips. GPIO chip 0 is connected to the GPIO header pins on models 3 and 4; GPIO chip 4 is connected to the GPIO header pins on the Raspberry Pi 5, so you if you’re using that model you’ll need to change <code>gpiochip0</code> to <code>gpiochip4</code> <span class="ent">❷</span>.</p>&#13;
<p class="indent">Once the GPIO line is configured to be an output, we turn the bit on and off to blink the LED <span class="ent">❸</span>.</p>&#13;
<p class="indent">Next, let’s look at how we can use assembly language to blink the LED.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The assembly language code we’ll be using is not robust. It’s intended to provide an overview of how I/O devices are programmed. If you want to use the GPIO to control external devices, I recommend using the functions in the</em> <span class="codeitalic">libgpiod</span> <em>library. It’s integrated with the operating system to provide robust functioning of the GPIO.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch20lev2sec5"><em><strong>Blinking an LED in Assembly Language, Models 3 and 4</strong></em></h4>&#13;
<p class="noindent">The function of each GPIO device line is selected through six 32-bit registers, named GPFSEL0 through GPFSEL5. Three bits are used to select the function of a GPIO device line. Registers GPFSEL0 through GPFSEL4 each select the function of 10 lines, with 2 unused bits. The GPFSEL5 register on model 3 selects the functions of 4 lines, leaving 20 unused bits, and on model 4 the GPFSEL5 register selects the functions of 8 lines, leaving 8 unused bits.</p>&#13;
<p class="indent">I recommend downloading the datasheet for your Raspberry Pi—the Broadcom BCM2835 SoC datasheet at <em><a href="https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf">https://datasheets.raspberrypi.com/bcm2835/bcm2835-peripherals.pdf</a></em> for the model 3 or the Broadcom BCM-2711 SoC datasheet at <em><a href="https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf">https://datasheets.raspberrypi.com/bcm2711/bcm2711-peripherals.pdf</a></em> for the model 4—for reference while reading this section. It’s not easy to read the datasheets, but going back and forth between the explanation here and the datasheet for your model should help you learn how to read it.</p>&#13;
<p class="indent">Note that I only tested this program on my Raspberry Pi 3. The datasheet for the Raspberry Pi 4 shows that the GPIO registers are the same as on the model 3, so this code should also work on a model 4.</p>&#13;
<p class="indent"><a href="ch20.xhtml#ch20list2">Listing 20-2</a> shows our assembly language program to blink an LED.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>blink_led.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Blink an LED connected to GPIO line 17 every three seconds.&#13;
&#13;
// Define your RPi model: 0, 1, 2, 3, 4, 5&#13;
    <span class="ent">❶</span> .equ    RPI_MODEL, 3&#13;
// Useful constants&#13;
        .equ    N_BLINKS, 5               // Number of times to blink&#13;
        .equ    DELTA_TIME, 3             // Seconds between blinks&#13;
        .equ    GPIO_LINE, 17             // Line number&#13;
// The following are defined in /usr/include/asm-generic/fcntl.h.&#13;
// Note that the values are specified in octal.&#13;
        .equ    O_RDWR, 00000002          // Open for read/write&#13;
        .equ    O_SYNC, 04010000          // Complete writes in hardware&#13;
<span epub:type="pagebreak" id="page_449"/>// The following are defined in /usr/include/asm-generic/mman-common.h.&#13;
        .equ    PROT_READ, 0x1            // Page can be read&#13;
        .equ    PROT_WRITE, 0x2           // Page can be written&#13;
        .equ    MAP_SHARED, 0x01          // Share changes&#13;
// Beginning address of peripherals&#13;
 <span class="ent">❷</span> .if     (RPI_MODEL == 0) || (RPI_MODEL == 1)&#13;
        .equ    PERIPHS, 0x20000000 &gt;&gt; 16 // RPi 0 or 1&#13;
    .elseif (RPI_MODEL == 2) || (RPI_MODEL == 3)&#13;
        .equ    PERIPHS, 0x3f000000 &gt;&gt; 16 // RPi 2 or 3&#13;
    .elseif RPI_MODEL == 4&#13;
        .equ    PERIPHS, 0x7e000000 &gt;&gt; 16 // RPi 4&#13;
    .else&#13;
        .equ    PERIPHS, 0x1f00000000 &gt;&gt; 16   // RPi 5&#13;
    .endif&#13;
// Offset to GPIO registers&#13;
    .if     RPI_MODEL != 5&#13;
        .equ    GPIO_OFFSET, 0x200000     // Other RPi models&#13;
    .else&#13;
        .equ    GPIO_OFFSET, 0xd0000      // RPi 5&#13;
    .endif&#13;
// Amount of memory to map and flags&#13;
        .equ    MEM_SIZE, 0x400000        // Enough to include all GPIO regs&#13;
     <span class="ent">❸</span> .equ    OPEN_FLAGS, O_RDWR | O_SYNC   // Open file flags&#13;
        .equ    PROT_RDWR, PROT_READ | PROT_WRITE   // Allow read and write&#13;
        .equ    NO_ADDR_PREF, 0           // Let OS choose address of mapping&#13;
&#13;
// Stack frame&#13;
        .equ    save1920, 16              // Save regs&#13;
        .equ    save21, 32&#13;
        .equ    FRAME, 48&#13;
// Constant data&#13;
        .section .rodata&#13;
        .align  2&#13;
dev_mem:&#13;
        .asciz  "/dev/mem"&#13;
err_msg:&#13;
        .asciz  "Cannot map I/O memory.\n"&#13;
on_msg:&#13;
        .asciz  "led on...\n"&#13;
off_msg:&#13;
        .asciz  "...led off\n"&#13;
&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
<span epub:type="pagebreak" id="page_450"/>main:&#13;
        stp     fp, lr, [sp, -FRAME]!     // Create stack frame&#13;
        mov     fp, sp                    // Set our frame pointer&#13;
        stp     x19, x20, [sp, save1920]  // Save regs&#13;
        str     x21, [sp, save21]&#13;
&#13;
// Open /dev/mem for read/write and syncing.&#13;
        mov     w1, OPEN_FLAGS &amp; 0xffff   // Move 32-bit flags&#13;
        movk    w1, OPEN_FLAGS / 0xffff, lsl 16&#13;
        adr     x0, dev_mem               // I/O device memory&#13;
     <span class="ent">❹</span> bl      open&#13;
        cmp     w0, -1                    // Check for error&#13;
        b.eq    error_return              // End if error&#13;
        mov     w19, w0                   // /dev/mem file descriptor&#13;
&#13;
// Map the GPIO registers to a main memory location so we can access them.&#13;
        movz    x5, PERIPHS &amp; 0xffff, lsl 16&#13;
        movk    x5, PERIPHS / 0xffff, lsl 32&#13;
        mov     w4, w19                   // File descriptor&#13;
        mov     w3, MAP_SHARED            // Share with other processes&#13;
        mov     w2, PROT_RDWR             // Read/write this memory&#13;
        mov     w1, MEM_SIZE              // Amount of memory needed&#13;
        mov     w0, NO_ADDR_PREF          // Let kernel pick memory&#13;
     <span class="ent">❺</span> bl      mmap&#13;
        cmp     x0, -1                    // Check for error&#13;
        b.eq    error_return              // w0 also = -1, end function&#13;
        mov     x20, x0                   // Save mapped address&#13;
        mov     w0, w19                   // /dev/mem file descriptor&#13;
        bl      close                     // Close /dev/mem file&#13;
&#13;
// Make the line an output.&#13;
        mov     x0, x20                   // Get mapped memory address&#13;
        add    x0, x0, GPIO_OFFSET        // Start of GPIO registers&#13;
        mov     w1, GPIO_LINE&#13;
 <span class="ent">❻</span> .if     RPI_MODEL != 5&#13;
        bl      gpio_line_to_output&#13;
    .else&#13;
        bl      gpio_5_line_to_output&#13;
    .endif&#13;
        mov     x21, x0                   // Pointer to register base&#13;
&#13;
// Turn the line on and off.&#13;
        mov     x19, N_BLINKS             // Number of times to do it&#13;
loop:&#13;
        adr     x0, on_msg                // Tell user it's on&#13;
        bl      write_str&#13;
<span epub:type="pagebreak" id="page_451"/>        mov     w1, GPIO_LINE             // GPIO line number&#13;
        mov     x0, x21                   // Pointer to register base&#13;
 <span class="ent">❼</span> .if     RPI_MODEL != 5&#13;
        bl      gpio_line_set             // Turn LED on&#13;
    .else&#13;
        bl      gpio_5_line_set           // Turn LED on&#13;
    .endif&#13;
        mov     w0, DELTA_TIME            // Wait&#13;
        bl      sleep&#13;
&#13;
        adr     x0, off_msg               // Tell user it's off&#13;
        bl      write_str&#13;
        mov     w1, GPIO_LINE             // GPIO line number&#13;
        mov     x0, x21                   // Pointer to register base&#13;
 <span class="ent">❽</span> .if     RPI_MODEL != 5&#13;
        bl      gpio_line_clr             // Turn LED off&#13;
    .else&#13;
        bl      gpio_5_line_clr           // Turn LED off&#13;
    .endif&#13;
        mov     w0, DELTA_TIME            // Wait&#13;
        bl      sleep&#13;
&#13;
        subs    x19, x19, 1               // Decrement loop counter&#13;
        b.gt    loop                      // Loop if &gt; 0&#13;
&#13;
        mov     x0, x20                   // Our mapped memory&#13;
        mov     w1, MEM_SIZE              // Amount we mapped for GPIO&#13;
     <span class="ent">❾</span> bl      munmap                    // Unmap it&#13;
        mov     w0, wzr                   // Return 0&#13;
error_return:&#13;
        ldr     x21, [sp, save21]         // Restore regs&#13;
        ldp     x19, x20, [sp, save1920]&#13;
        ldp     fp, lr, [sp], FRAME       // Delete stack frame&#13;
        ret</pre>&#13;
<p class="list" id="ch20list2"><em>Listing 20-2: An assembly language program to blink an LED using the GPIO</em></p>&#13;
<p class="indent">The C program in <a href="ch20.xhtml#ch20list1">Listing 20-1</a> uses library functions provided by the operating system to control the GPIO line. Our assembly language program in <a href="ch20.xhtml#ch20list2">Listing 20-2</a> accesses the GPIO registers directly. The operating system only allows a user with root privileges to do that, so we need to run the program with <code>sudo</code>, like this:</p>&#13;
<pre class="pre">$ <span class="codestrong1">sudo ./blink_led</span></pre>&#13;
<p class="indent">Linux treats I/O devices as files. They are listed by name in the <em>/dev</em> directory. The <em>/dev/mem</em> file is an image of main memory. Addresses in this file represent physical memory addresses. Opening the file with the <code>open</code>  <span epub:type="pagebreak" id="page_452"/>system call function gives us access to the I/O device’s physical memory <span class="ent">❹</span>. Its man page gives us the prototype for the <code>open</code> function:</p>&#13;
<pre class="pre">int open(const char *<span class="codeitalic1">pathname</span>, int <span class="codeitalic1">flags</span>);</pre>&#13;
<p class="noindent">The <span class="codeitalic">pathname</span> is the full path and name of the file or device to be opened. The man page lists the names of the <span class="codeitalic">flags</span> that must be passed to the <code>open</code> function to specify how it can be accessed by the calling function.</p>&#13;
<p class="indent">The numerical value of each flag can be found in the header file at <em>/usr/include/asm-generic/fcntl.h</em>. The header file is written in C, so we can’t use the <code>.include</code> directive to add it into our assembly language source code. I’ve used the <code>.equ</code> directive to define the flags we need in the <code>open</code> function. The assembler supports arithmetic and logic operations on literal values. We use the OR operator (<code>|</code>) to combine the different flags we need into a single 32-bit integer for the <span class="codeitalic">flags</span> argument <span class="ent">❸</span>.</p>&#13;
<p class="indent">The operating system prevents application programs from directly accessing the I/O memory address space. We need to tell the operating system to map the GPIO memory address space into the application memory address space so we can access the GPIO registers in our application.</p>&#13;
<p class="indent">The I/O peripheral address space begins at different places, depending on the Raspberry Pi model. The GNU assembler has directives that allow us to select which lines of code to include in the assembly. We use the <code>.if</code> directive together with a series of <code>.elseif</code> directives to select the value of <code>PERIPHS</code> according to the model we’re using <span class="ent">❷</span>. Using a <code>.if</code> directive with a <code>.else</code> directive selects the correct offset of the GPIO registers from the beginning address of the I/O peripherals. A single <code>.equ</code> directive sets <code>RPI_MODEL</code> to control these <em>conditional assembly</em> directives <span class="ent">❶</span>. Don’t forget to end each <code>.if</code> construct with a <code>.endif</code> directive.</p>&#13;
<p class="indent">We use the <code>mmap</code> system call function, specified in the POSIX standard, to map the GPIO registers into application memory <span class="ent">❺</span>. Its man page gives us the prototype for the function:</p>&#13;
<pre class="pre">void *mmap(void <span class="codeitalic1">addr</span>[.<span class="codeitalic1">length</span>], size_t <span class="codeitalic1">length</span>, int <span class="codeitalic1">prot</span>,&#13;
          int <span class="codeitalic1">flags</span> int <span class="codeitalic1">fd</span>, off_t <span class="codeitalic1">offset</span>);</pre>&#13;
<p class="noindent">If <span class="codeitalic">addr</span> is <code>0</code>, the operating system chooses the application memory address for the mapping. The <span class="codeitalic">length</span> is the number of bytes we’ll need for all the registers on the device. The mapping will use an integral number of pages. I’ve chosen 4MB to ensure we include all the I/O registers used for programming the GPIO in all the Raspberry Pi models.</p>&#13;
<p class="indent">The man page for <code>mmap</code> lists the <span class="codeitalic">prot</span> values that must be passed to the function to specify how it can be accessed by the calling function. The man page also lists values for the <span class="codeitalic">flags</span>, which specify how access is treated by the operating system.</p>&#13;
<p class="indent">The numerical value of each <span class="codeitalic">prot</span> and <span class="codeitalic">flag</span> can be found in the header file <em>/usr/include/asm-generic/mman-common.h</em>. The header file is also written <span epub:type="pagebreak" id="page_453"/>in C, so I have used <code>.equ</code> directives to define the <span class="codeitalic">prot</span> and <span class="codeitalic">flags</span> we need in this function.</p>&#13;
<p class="indent">After calling the <code>open</code> and <code>mmap</code> functions to make the GPIO registers accessible through application memory, we use the <code>close</code> function to release the file descriptor. The GPIO registers remain accessible to our application program.</p>&#13;
<p class="indent">Now that we can access the I/O registers on the GPIO through application memory addressing, we program our GPIO line to be an output. As you’ll see in the next section, the method for doing this is different for the Raspberry Pi 5 <span class="ent">❻</span>. After setting up the GPIO as an output, we enter a loop where we alternately turn the LED on and off. Again, a different method is used for the Raspberry Pi 5 <span class="ent">❼</span> <span class="ent">❽</span>. We leave the LED in its on or off state for a few seconds using the <code>sleep</code> function from the <code>unistd</code> library.</p>&#13;
<p class="indent">Although the program will release the application memory we used for the GPIO registers when it ends, it’s good practice to call the <code>munmap</code> function to release the memory in your program when it’s no longer needed <span class="ent">❾</span>.</p>&#13;
<p class="indent">Specifying a GPIO line as an output is done with the function shown in <a href="ch20.xhtml#ch20list3">Listing 20-3</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>gpio_line_to_output.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Make a GPIO line an output. Assume that GPIO registers&#13;
// have been mapped to application memory.&#13;
// Calling sequence:&#13;
//      x0 &lt;- address of GPIO in mapped memory&#13;
//      w1 &lt;- GPIO line number&#13;
//      Return address of GPIO.&#13;
&#13;
// Useful constants&#13;
        .equ    FIELD_MASK, 0b111  // 3 bits&#13;
        .equ    OUTPUT, 1          // Use line for output&#13;
&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global gpio_line_to_output&#13;
        .type   gpio_line_to_output, %function&#13;
gpio_line_to_output:&#13;
// Determine register and location of line function field.&#13;
        mov     w3, 10              // 10 fields per GPFSEL register&#13;
     <span class="ent">❶</span> udiv    w4, w1, w3          // GPFSEL register number&#13;
     <span class="ent">❷</span> msub    w5, w4, w3, w1      // Relative FSEL number in register&#13;
// Compute address of GPFSEL register and line field in register.&#13;
     <span class="ent">❸</span> lsl     w4, w4, 2           // Offset to GPFSEL register&#13;
        add     x7, x0, x4          // GPFSELn memory address&#13;
        ldr     w4, [x7]            // GPFSELn register contents&#13;
&#13;
     <span class="ent">❹</span> add     w5, w5, w5, lsl 1   // 3 X relative FSEL number&#13;
        mov     w6, FIELD_MASK      // FSEL line field&#13;
<span epub:type="pagebreak" id="page_454"/>        lsl     w6, w6, w5          // Shift to relative FSEL bit position&#13;
     <span class="ent">❺</span> bic     w4, w4, w6          // Clear current FSEL&#13;
&#13;
        mov     w2, OUTPUT          // Function = output&#13;
     <span class="ent">❻</span> lsl     w2, w2, w5          // Shift function code to FSEL position&#13;
        orr     w4, w4, w2          // Insert function code&#13;
        str     w4, [x7]            // Update GPFSEL register&#13;
&#13;
        ret</pre>&#13;
<p class="list" id="ch20list3"><em>Listing 20-3: Making a GPIO line an output in most Raspberry Pi models</em></p>&#13;
<p class="indent">The GPIO has six 32-bit function-select registers, GPFSEL0 through GPFSEL5. Each of these registers is divided into 10 3-bit fields, named FSEL<em>n</em>, where <em>n</em> = 0, 1, . . . , 57. Bits 2 through 0 in GPFSEL0 are the FSEL0 field, bits 5 through 3 are the FSEL1 field, and so forth up to bits 23 through 21 in GPFSEL5 for the FSEL57 field. Bits 31 and 30 in GPFSEL0 through GPFSEL4 and bits 31 through 24 in GPFSEL5 are unused. All the lines can be configured as an input, <code>000</code>, or an output, <code>001</code>. Some lines can be configured to have other functionalities; FSEL<em>n</em> specifies the functionality of GPIO line <em>n</em>.</p>&#13;
<p class="indent">Dividing the GPIO line number by 10 gives us the number of the GPFSEL register <span class="ent">❶</span>. The remainder from this division gives us the number of the FSEL field in the register <span class="ent">❷</span>. For example, our program uses GPIO line 17, and its function is controlled by the seventh FSEL field in the GPFSEL1 register.</p>&#13;
<p class="indent">The GPFSEL registers are located at the beginning of the GPIO memory, so multiplying the GPFSEL register number by 4 gives us the memory address offset of the register <span class="ent">❸</span>. Each FSEL field is 3 bits, so we multiply the FSEL number by 3 to get the relative bit position in the GPFSEL register <span class="ent">❹</span>.</p>&#13;
<p class="indent">We need to make sure we don’t change any of the other FSEL fields in the GPFSEL register. After loading a copy of the GPFSEL register into a CPU register, we use a 3-bit mask to clear our FSEL field with the <code>bic</code> instruction <span class="ent">❺</span>:</p>&#13;
<h5 class="h5" id="ch20lev3sec1"><code>bic</code>—Bit clear</h5>&#13;
<p class="noindentin"><code>bic w</code><span class="codeitalic">d</span><code>, w</code><span class="codeitalic">s1</span><code>, w</code><span class="codeitalic">s2</span><code>{,</code><span class="codeitalic">shft amnt</span><code>}</code> performs a bitwise AND between <code>w</code><span class="codeitalic">s1</span> and <code>w</code><span class="codeitalic">s2</span>, optionally shifted <span class="codeitalic">amnt</span> bits before the AND, storing the result in <code>w</code><span class="codeitalic">d</span>. The <span class="codeitalic">shft</span> can be <code>lsl</code>, <code>lsr</code>, <code>0</code> to <code>31</code>. The default is no shift.</p>&#13;
<p class="noindentin"><code>bic x</code><span class="codeitalic">d</span><code>, x</code><span class="codeitalic">s1</span><code>, x</code><span class="codeitalic">s2</span><code>{,</code><span class="codeitalic">shft amnt</span><code>}</code> performs a bitwise AND between <code>x</code><span class="codeitalic">s1</span> and <code>x</code><span class="codeitalic">s2</span>, optionally shifted <span class="codeitalic">amnt</span> bits before the AND, storing the result in <code>x</code><span class="codeitalic">d</span>. The <span class="codeitalic">shft</span> can be <code>lsl</code>, <code>lsr</code>, <code>asr</code>, or <code>ror</code>. The <span class="codeitalic">amnt</span> can be <code>0</code> to <code>63</code>. The default is no shift.</p>&#13;
<p class="indenta">Next, we shift our function code to the FSEL field position in the GPFSEL register, use the <code>orr</code> instruction to insert the function code, and update the mapped GPIO memory <span class="ent">❻</span>.</p>&#13;
<div class="note"><span epub:type="pagebreak" id="page_455"/>&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although we have mapped the GPIO registers into application memory addresses, we can’t directly examine the contents of these registers with</em> <span class="codeitalic">gdb</span> <em>because it uses a different technique for accessing memory addresses than the</em> <span class="codeitalic">mmap</span> <em>function. I’ll show you another way to examine the register contents in</em> <span class="codeitalic">gdb</span> <em>in “Your Turn” <a href="ch20.xhtml#ch20exe3">exercise 20.3</a> on <a href="ch20.xhtml#ch20you1">page 460</a>.</em></p>&#13;
</div>&#13;
<p class="indent">Now that we have set up the GPIO line as a 1-bit output device, we can control the voltage it outputs. The line is always ready for us to change the voltage, so we don’t need to check its status. We’ll use the <code>gpio_line_set</code> function in <a href="ch20.xhtml#ch20list4">Listing 20-4</a> to set the line, which places it at +3.3 V.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>gpio_line_set.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Set a GPIO line. Assume that GPIO registers&#13;
// have been mapped to application memory.&#13;
// Calling sequence:&#13;
//       x0 &lt;- address of GPIO in mapped memory&#13;
//       w1 &lt;- line number&#13;
&#13;
// Constants&#13;
     <span class="ent">❶</span> .equ    GPSET0, 0x1c     // GPSET register offset&#13;
&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global gpio_line_set&#13;
        .type   gpio_line_set, %function&#13;
gpio_line_set:&#13;
        add     x0, x0, GPSET0  // Address of GPSET0 register&#13;
        mov     w2, 1           // Need a 1&#13;
     <span class="ent">❷</span> lsl     w2, w2, w1      // Move to specified bit position&#13;
        str     w2, [x0]        // Output&#13;
&#13;
        ret</pre>&#13;
<p class="list" id="ch20list4"><em>Listing 20-4: Setting a GPIO line in most Raspberry Pi models</em></p>&#13;
<p class="indent">The GPIO has two 32-bit output-set registers, GPSET0 and GPSET1. The GPSET0 register is located <code>0x1c</code> bytes from the beginning of GPIO memory <span class="ent">❶</span>. The GPSET1 register immediately follows at <code>0x20</code>. Bits 31 through 0 in GPSET0 control lines 31 through 0, and bits 21 through 0 in GPSET1 control lines 53 through 32. The GPIO header pins are connected only to GPIO lines 27 through 0, so this function only works with GPSET0.</p>&#13;
<p class="indent">The GPSET registers are write-only. Unlike the GPFSEL registers, we don’t load the contents of a GPSET register; we simply shift a <code>1</code> to the bit position corresponding to the line we’re using as an output and set the line with a <code>str</code> instruction, placing +3.3 V on the line <span class="ent">❷</span>. Writing a <code>0</code> to a bit position has no effect.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_456"/>When we want to change the output of the line to 0.0 V, we clear the line, as shown in <a href="ch20.xhtml#ch20list5">Listing 20-5</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>gpio_line_clr.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Clear GPIO line. Assume that GPIO registers&#13;
// have been mapped to application memory.&#13;
// Calling sequence:&#13;
//       x0 &lt;- address of GPIO in mapped memory&#13;
//       w1 &lt;- line number&#13;
&#13;
// Constants&#13;
     <span class="ent">❶</span> .equ    GPCLR0, 0x28    // GPCLR register offset&#13;
&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global gpio_line_clr&#13;
        .type   gpio_line_clr, %function&#13;
gpio_line_clr:&#13;
        add     x0, x0, GPCLR0  // Address of GPCLR0 register&#13;
        mov     w2, 1           // Need a 1&#13;
        lsl     w2, w2, w1      // Move to specified bit position&#13;
        str     w2, [x0]        // Output&#13;
&#13;
        ret</pre>&#13;
<p class="list" id="ch20list5"><em>Listing 20-5: Clearing a GPIO line in most Raspberry Pi models</em></p>&#13;
<p class="indent">Like the set registers, the GPIO has two 32-bit output-clear registers, GPCLR0 and GPCLR1. GPCLR0 is located 12 bytes beyond GPSET0 <span class="ent">❶</span>. They are programmed the same way as the GPSET registers, except that storing a <code>1</code> in a bit position corresponding to a line that is selected as an output clears the line, placing 0.0 V on the line.</p>&#13;
<p class="indent">Next, we’ll look at blinking an LED on a Raspberry Pi 5, which uses a very different programming interface to the GPIO.</p>&#13;
<h4 class="h4" id="ch20lev2sec6"><em><strong>Blinking an LED in Assembly Language, Model 5</strong></em></h4>&#13;
<p class="noindent">The <code>main</code> function in <a href="ch20.xhtml#ch20list2">Listing 20-2</a> is designed to work for the Raspberry Pi 5 if you simply change the <code>RPI_MODEL</code> to <code>5</code>. The conditional assembly directives will then select the appropriate values and function calls. But the methods for controlling the GPIO are different. Let’s see how it’s done on the Raspberry Pi 5.</p>&#13;
<p class="indent">The GPIO circuitry on the Raspberry Pi 5 is on the RP1 chip. The documentation is incomplete as of this writing, but a preliminary draft of <em>RP1 Peripherals</em> (November 2023) is available at <em><a href="https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf">https://datasheets.raspberrypi.com/rp1/rp1-peripherals.pdf</a></em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_457"/>Setting a GPIO line to be an output on a Raspberry Pi 5 is different from on the other models. <a href="ch20.xhtml#ch20list6">Listing 20-6</a> shows our function to do this.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>gpio_5_line _to_output.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Make a GPIO line an output. Assume that GPIO registers&#13;
// have been mapped to application memory.&#13;
// Calling sequence:&#13;
//      x0 &lt;- address of GPIO in mapped memory&#13;
//      w1 &lt;- GPIO line number&#13;
//      Return address of RIOBase.&#13;
&#13;
// Constants&#13;
        .equ    RIOBase, 0x10000  // Offset to RIO registers&#13;
        .equ    PADBase, 0x20000  // Offset to PAD registers&#13;
        .equ    SYS_RIO, 5        // Use RIO to control GPIO&#13;
        .equ    PAD_AMPS, 0x10    // 4 mA&#13;
        .equ    RIO_SET, 0x2000   // Set reg offset&#13;
        .equ    RIO_OE, 0x04      // Output enable&#13;
&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global gpio_5_line_to_output&#13;
        .type   gpio_5_line_to_output, %function&#13;
gpio_5_line_to_output:&#13;
     <span class="ent">❶</span> lsl    x2, x1, 3         // 8 x line number&#13;
        add    x3, x0, x2        // GPIO_line_number_STATUS&#13;
        mov    w2, SYS_RIO       // System registered I/O&#13;
     <span class="ent">❷</span> str    w2, [x3, 4]       // GPIO_line_number_CTRL&#13;
&#13;
        add    x2, x0, PADBase&#13;
        add    x2, x2, 4         // Skip over VOLTAGE_SELECT reg&#13;
        lsl    x3, x1, 2         // 4 x line number&#13;
        add    x3, x3, x2        // Pad reg address of line number&#13;
        mov    w4, PAD_AMPS      // 4 mA&#13;
     <span class="ent">❸</span> str    w4, [x3]          // Set pad amps&#13;
&#13;
        add    x0, x0, RIOBase&#13;
        mov    w2, 1             // A bit&#13;
        lsl    w2, w2, w1        // Shift to line location&#13;
        add    x3, x0, RIO_SET   // Use RIO set register&#13;
     <span class="ent">❹</span> str    w2, [x3, RIO_OE]  // Make line an output&#13;
&#13;
        ret</pre>&#13;
<p class="list" id="ch20list6"><em>Listing 20-6: A function to make a GPIO line an output on the Raspberry Pi 5</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_458"/>The Raspberry Pi 5 GPIO device has 28 pairs of registers, which are called GPIO0_STATUS, GPIO0_CTRL, GPIO1_STATUS, GPIO1_CTRL through GPIO27_STATUS, and GPIO27_CTRL. The address offset of the GPIO<em>n</em>_CTRL register corresponding to GPIO line <em>n</em> is 8 × <em>n</em> <span class="ent">❶</span>. Bits 4 through 0 set the function.</p>&#13;
<p class="indent">RP1 provides a set of <em>registered I/O (RIO)</em> registers to control the GPIO lines. To use the RIO interface, we store the <code>SYS_RIO</code> function in the GPIO control register <span class="ent">❷</span>.</p>&#13;
<p class="indent">The output circuit of a GPIO line is called a <em>pad</em>. We can set the characteristics of the output pad in several ways—for example, to either 2, 4, 8, or 12 mA. We set it to 4 mA for blinking an LED <span class="ent">❸</span>. We complete our setup of the GPIO line by making it an output device <span class="ent">❹</span>.</p>&#13;
<p class="indent">Now that we have set up the GPIO line as a 1-bit output device, we can control the voltage that it outputs. The RIO interface to the GPIO has four registers for controlling the lines. <a href="ch20.xhtml#ch20tab2">Table 20-2</a> shows the offset of each register from the RIO base.</p>&#13;
<p class="tabcap" id="ch20tab2"><strong>Table 20-2:</strong> RIO Register Offsets</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th">Offset</th>&#13;
<th class="tab_th">Action</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>0x0000</code></td>&#13;
<td class="bg1">Normal read/write</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x1000</code></td>&#13;
<td class="bg">XOR on write</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>0x2000</code></td>&#13;
<td class="bg1">Bitmask set on write</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>0x3000</code></td>&#13;
<td class="bg">Bitmask clear on write</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Bit <em>n</em> in each register corresponds to the GPIO<em>n</em> line. Storing a word to one of these registers causes the action to be taken on the GPIO line(s). Bit-mask set or clear means that only the bits that are <code>1</code> act on the corresponding GPIO lines. A <code>0</code> in a bit position has no effect on the corresponding GPIO line. The separate set and clear registers mean that we don’t need to read the contents of a register, make our changes, and write the result back.</p>&#13;
<p class="indent">A GPIO line configured for output is always ready for us to change the voltage, so we don’t need to check its status. We’ll use the <code>gpio_5_line_set</code> function in <a href="ch20.xhtml#ch20list7">Listing 20-7</a> to set the line, which places it at +3.3 V.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>gpio_5_line_set.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Set GPIO line. Assume that GPIO registers&#13;
// have been mapped to programming memory.&#13;
// Calling sequence:&#13;
//       x0 &lt;- address of RIOBase in mapped memory&#13;
//       w1 &lt;- line number&#13;
&#13;
// Constants&#13;
     <span class="ent">❶</span> .equ    RIO_SET, 0x2000     // Set reg&#13;
&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
<span epub:type="pagebreak" id="page_459"/>        .global gpio_5_line_set&#13;
        .type   gpio_5_line_set, %function&#13;
gpio_5_line_set:&#13;
        mov     w2, 1               // A bit&#13;
     <span class="ent">❷</span> lsl     w2, w2, w1          // Shift to line location&#13;
        add     x0, x0, RIO_SET     // Address of RIO set reg&#13;
        str     w2, [x0]            // Line low&#13;
        ret</pre>&#13;
<p class="list" id="ch20list7"><em>Listing 20-7: A function to set a GPIO line on the Raspberry Pi 5</em></p>&#13;
<p class="indent">We move a <code>1</code> to the bit position corresponding to our line number <span class="ent">❷</span>. Then, we store this word in the RIO set register, which places the GPIO line at the high voltage <span class="ent">❶</span>.</p>&#13;
<p class="indent">The algorithm to clear a line is the same as the one to set it, as shown in <a href="ch20.xhtml#ch20list8">Listing 20-8</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>gpio_5_line_clr.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Clear a GPIO line. Assume that GPIO registers&#13;
// have been mapped to programming memory.&#13;
// Calling sequence:&#13;
//       x0 &lt;- address of RIOBase in mapped memory&#13;
//       w1 &lt;- line number&#13;
&#13;
// Constants&#13;
     <span class="ent">❶</span> .equ    RIO_CLR, 0x3000     // Clear reg&#13;
&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global gpio_5_line_clr&#13;
        .type   gpio_5_line_clr, %function&#13;
gpio_5_line_clr:&#13;
        mov     w2, 1               // A bit&#13;
        lsl     w2, w2, w1          // Shift to line location&#13;
        add     x0, x0, RIO_CLR     // Address of RIO clear reg&#13;
        str     w2, [x0]            // Line low&#13;
        ret</pre>&#13;
<p class="list" id="ch20list8"><em>Listing 20-8: A function to clear a GPIO line on the Raspberry Pi 5</em></p>&#13;
<p class="indent">The only difference in the <code>gpio_line_clr</code> function is that we use the RIO clear register to place the GPIO line at the low voltage <span class="ent">❶</span>.</p>&#13;
<p class="indent">Blinking an LED is a very simple example of performing output. We don’t have to check to see if the line is ready for us to turn it on or off; we just send a command to the device. Most I/O isn’t this simple. It takes some time to form an image to display on a screen, or to convert a keystroke on a keyboard to a bit pattern.</p>&#13;
<p class="indent">In the next section, I’ll give you a general overview of how our program code deals with these timing issues.</p>&#13;
<div class="box"><span epub:type="pagebreak" id="page_460"/>&#13;
<p class="box-title" id="ch20you1"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch20exe1">20.1   The typical voltage drop across an LED is 2 to 3 V when it’s on, depending on its color. Compute the amount of current you expect to flow through the LED in the circuit in <a href="ch20.xhtml#ch20fig2">Figure 20-2</a> when the LED is on.</p>&#13;
<p class="box-list" id="ch20exe2">20.2   Write a program in Python to blink an LED five times at three-second intervals. Refer to<em><a href="https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python">https://www.raspberrypi.com/documentation/computers/os.html#use-gpio-from-python</a></em> for hints on how to do this.</p>&#13;
<p class="box-list" id="ch20exe3">20.3   Modify the <code>main</code> function in <a href="ch20.xhtml#ch20list2">Listing 20-2</a> to alternately blink LEDs attached to GPIO lines 16 and 17. If you’re using a Raspberry Pi model other than the 5, run the program under <code>gdb</code> and set breakpoints in the <code>gpio_line_to_output</code> function so you can see that the appropriate function codes are stored in the GPFSEL0 register. You can get a better view of this if you add an <code>ldr w7, [x0]</code> instruction to <code>gpio_line_to_output</code> just before the <code>ret</code> instruction. Programmers sometimes add code like this for debugging purposes, which is usually deleted in the final product.</p>&#13;
<p class="box-list" id="ch20exe4">20.4   Modify the assembly language LED blinking program to blink the LED every 0.5 seconds. You’ll need to use the <code>usleep</code> function. The integer argument to this function is the number of microseconds to sleep.</p>&#13;
<p class="box-list" id="ch20exe5">20.5   If you’re using a Raspberry Pi 5, write a program in assembly language to toggle an LED on and off five times using a single <code>gpio_5_line_toggle</code> function instead of the <code>gpio_5_line_set</code> and <code>gpio_5_line_clr</code> functions.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch20lev1sec5"><strong>Polled I/O Programming Algorithms</strong></h3>&#13;
<p class="noindent">Let’s look at some simple polling algorithms that show how we might program a <em>universal asynchronous receiver/transmitter (UART)</em> for I/O.</p>&#13;
<p class="indent">When used as an output device, a UART performs parallel-to-serial conversion to transmit a byte of data 1 bit at a time. As an input device, a UART receives the bits one at a time and performs serial-to-parallel conversion to reassemble the byte that was sent to it. Thus, an 8-bit byte can be transmitted and received using only three wires: transmit, receive, and common. Both the transmitting and receiving UARTs must be set at the same bit rate.</p>&#13;
<p class="indent">In the idle state, the transmitting UART places the high voltage on the transmission line. When a program outputs a byte to the UART, the transmitting UART first sends a <em>start bit</em>; it does this by placing the transmission line at the low voltage for the amount of time it takes to transmit one bit, corresponding to the agreed-upon bit rate.</p>&#13;
<p class="indent">After the start bit, the transmitter sends the data bits at the agreed-upon bit rate. The UART uses a shift register to shift the byte 1 bit at a time, setting the voltage on the output line accordingly. Most UARTs start with the low-order bit. When the entire byte has been sent, the UART returns the output line to the idle state for at least 1 bit time, thus sending at least one <em>stop bit</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_461"/><a href="ch20.xhtml#ch20fig3">Figure 20-3</a> shows how a UART with typical settings would send the two characters <em>m</em> and <em>n</em> encoded in ASCII.</p>&#13;
<div class="image"><img id="ch20fig3" src="../images/pg489_Image_320.jpg" alt="Image" width="559" height="118"/></div>&#13;
<p class="figcap"><em>Figure 20-3: A UART output to send the characters</em> m <em>and</em> n</p>&#13;
<p class="indent">The receiving UART watches the transmission line, looking for a start bit. When it detects a start bit, it uses a shift register to reassemble the individual bits into a byte, which it provides to the receiving program as input.</p>&#13;
<p class="indent">We’ll use the 16550 UART, a common type, for our programming example. The 16550 UART has 13 8-bit registers, shown in <a href="ch20.xhtml#ch20tab3">Table 20-3</a>.</p>&#13;
<p class="tabcap" id="ch20tab3"><strong>Table 20-3:</strong> The Registers of the 16550 UART</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th">Name</th>&#13;
<th class="tab_th">Address</th>&#13;
<th class="tab_th">DLAB</th>&#13;
<th class="tab_th">Purpose</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>RHR</code></td>&#13;
<td class="bg1"><code>000</code></td>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1">Receiver holding (input byte)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>THR</code></td>&#13;
<td class="bg"><code>000</code></td>&#13;
<td class="bg"><code>0</code></td>&#13;
<td class="bg">Transmitter holding (output byte)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>IER</code></td>&#13;
<td class="bg1"><code>001</code></td>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1">Interrupt enable (set type of interrupt)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>ISR</code></td>&#13;
<td class="bg"><code>010</code></td>&#13;
<td class="bg"><code>x</code></td>&#13;
<td class="bg">Interrupt status (show type of interrupt)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>FCR</code></td>&#13;
<td class="bg1"><code>010</code></td>&#13;
<td class="bg1"><code>x</code></td>&#13;
<td class="bg1">FIFO control (set FIFO parameters)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>LCR</code></td>&#13;
<td class="bg"><code>011</code></td>&#13;
<td class="bg"><code>x</code></td>&#13;
<td class="bg">Line control (set communications format)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>MCR</code></td>&#13;
<td class="bg1"><code>100</code></td>&#13;
<td class="bg1"><code>x</code></td>&#13;
<td class="bg1">Modem control (set interface with modem)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>LSR</code></td>&#13;
<td class="bg"><code>101</code></td>&#13;
<td class="bg"><code>x</code></td>&#13;
<td class="bg">Line status (show status of data transfers)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>MSR</code></td>&#13;
<td class="bg1"><code>110</code></td>&#13;
<td class="bg1"><code>0</code></td>&#13;
<td class="bg1">Modem status (show status of modem)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>SCR</code></td>&#13;
<td class="bg"><code>111</code></td>&#13;
<td class="bg"><code>x</code></td>&#13;
<td class="bg">Scratch</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>DLL</code></td>&#13;
<td class="bg1"><code>000</code></td>&#13;
<td class="bg1"><code>1</code></td>&#13;
<td class="bg1">Divisor latch (low-order byte)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>DLM</code></td>&#13;
<td class="bg"><code>001</code></td>&#13;
<td class="bg"><code>1</code></td>&#13;
<td class="bg">Divisor latch (high-order byte)</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>PSD</code></td>&#13;
<td class="bg1"><code>101</code></td>&#13;
<td class="bg1"><code>1</code></td>&#13;
<td class="bg1">Prescaler division</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The addresses in <a href="ch20.xhtml#ch20tab3">Table 20-3</a> are address offsets from the UART’s base address. You probably noticed that some of the registers have the same offset. The functionality of the register at that offset depends on how our program treats it. For example, if the program loads from offset <code>000</code>, it’s loading from the receiver holding register (<code>RHR</code>). But if the program stores to offset <code>000</code>, it’s storing to the transmitter holding register (<code>THR</code>).</p>&#13;
<p class="indent">The divisor latch access bit (DLAB) is bit number 7 in the line control register (<code>LCR</code>). When it is set to <code>1</code>, offset <code>000</code> connects to the low-order byte of the 16-bit divisor latch value and offset <code>001</code> connects to the high-order byte of the divisor latch value.</p>&#13;
<p class="indent">The 16550 UART can be programmed for interrupt-driven I/O and direct memory access. It includes 16-byte first in, first out (FIFO) buffers on both the transmitter and the receiver registers. It can also be programmed to control a serial modem.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_462"/>Older PCs typically connected the UART to a COM port. In past years, COM ports were often used to connect devices such as printers and modems to computers, but most PCs today use USB ports for serial I/O.</p>&#13;
<p class="indent">The Raspberry Pi has a 16550-like UART with the receiver and transmitter registers connected to GPIO lines. Programming the UART is beyond the scope of this book, but I’ll use C to give a general idea of how it’s done.</p>&#13;
<p class="indent">Note that the C functions we’ll write in this section are meant only to show the concepts, not to do anything useful. In fact, running them will elicit an error message from the operating system.</p>&#13;
<p class="indentb">I’ll assume the UART is installed in a computer that uses memory-mapped I/O so I can show the algorithms in C. To keep things simple, I’ll do only polled I/O here, which requires these three functions:</p>&#13;
<p class="noindentin"><span class="codestrong">UART_init</span>   Initializes the UART. This includes setting parameters in the hardware, such as the speed and communications protocol.</p>&#13;
<p class="noindentin"><span class="codestrong">UART_in</span>   Reads one character that was received by the UART.</p>&#13;
<p class="noindentin"><span class="codestrong">UART_out</span>   Writes one character to be transmitted by the UART.</p>&#13;
<p class="indentgt">These three functions would allow us to use a UART to receive a character and then transmit that same character, as shown in <a href="ch20.xhtml#ch20list9">Listing 20-9</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>UART_echo.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Use a UART to echo a single character.&#13;
// WARNING: This code does not run on any known device. It is&#13;
// meant to sketch some general I/O concepts only.&#13;
&#13;
#include "UART_functions.h"&#13;
#define UART0 (unsigned char *)0xfe200040   // Address of UART&#13;
&#13;
int UART_echo(void)&#13;
{&#13;
    unsigned char character;&#13;
&#13;
    UART_init(UART0);&#13;
    character = UART_in(UART0);&#13;
    UART_out(UART0, character);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch20list9"><em>Listing 20-9: A function to use a UART to read and write a single character</em></p>&#13;
<p class="indent">We’ll explore only a few features of the UART. Let’s start with a file that provides symbolic names for the registers and some numbers we’ll be using in our example program, as shown in <a href="ch20.xhtml#ch20list10">Listing 20-10</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>UART_def.h</em></p>&#13;
</div>&#13;
<pre class="pre">   // Definitions for a 16550 UART.&#13;
   // WARNING: This code does not run on any known device. It is&#13;
   // meant to sketch some general I/O concepts only.&#13;
<span epub:type="pagebreak" id="page_463"/>   #ifndef UART_DEFS_H&#13;
   #define UART_DEFS_H&#13;
   &#13;
   // Register offsets&#13;
   #define RHR 0x00    // Receive holding register&#13;
   #define THR 0x00    // Transmit holding register&#13;
   #define IER 0x01    // Interrupt enable register&#13;
   #define FCR 0x02    // FIFO control register&#13;
   #define LCR 0x03    // Line control register&#13;
   #define LSR 0x05    // Line status register&#13;
   #define DLL 0x00    // Divisor latch LSB&#13;
   #define DLM 0x01    // Divisor latch MSB&#13;
   &#13;
   // Status bits&#13;
   #define RxRDY 0x01  // Receiver ready&#13;
   #define TxRDY 0x20  // Transmitter ready&#13;
   &#13;
   // Commands&#13;
   #define NO_FIFO       0x00  // Don't use FIFO&#13;
   #define NO_INTERRUPT  0x00  // Polling mode&#13;
   #define MSB_38400     0x00  // 2 bytes used to&#13;
   #define LSB_38400     0x03  //   set baud 38400&#13;
   #define N_BITS        0x03  // 8 bits&#13;
   #define STOP_BIT      0x00  // 1 stop bit&#13;
   #define NO_PARITY     0x00&#13;
<span class="ent">❶</span> #define SET_COM       N_BITS | STOP_BIT | NO_PARITY&#13;
<span class="ent">❷</span> #define SET_BAUD      0x80 | SET_COM&#13;
   #endif</pre>&#13;
<p class="list" id="ch20list10"><em>Listing 20-10: The definitions for a 16550 UART</em></p>&#13;
<p class="indent">The offsets to the registers are at fixed positions relative to the start of the mapped memory address of the UART. These offsets, and the status and control bit settings, are taken from a 16550 datasheet, which you can download at <em><a href="https://www.ti.com/product/TL16C550D">https://www.ti.com/product/TL16C550D</a></em>.</p>&#13;
<p class="indent">Let’s look at how I arrived at the value for the <code>SETCOM</code> control <span class="ent">❶</span>. The communication parameters are set by writing 1 byte to the line status register. There can be 5 to 8 bits in each data frame. The datasheet tells us that setting bits 1 and 0 to <code>11</code> will specify 8 bits. Hence, I set <code>NBITS</code> to <code>0x03</code>. Setting bit 2 to <code>0</code> specifies one stop bit, so <code>STOPBIT</code> = <code>0x00</code>. I don’t use parity, which is bit 3, so <code>NOPARITY</code> = <code>0x00</code>. I combine these constants with the OR operator to create the byte that sets the communication parameters. Of course, we don’t really need the two zero values, but specifying them makes our intent explicit.</p>&#13;
<p class="indent">The unit <em>baud</em> is a measure of the speed of communication, defined as the number of symbols per second. A UART uses only two voltage levels for communication, symbolically <code>0</code> or <code>1</code>, or 1 bit. For a UART, the baud rate is equivalent to the number of bits transmitted or received per second. We <span epub:type="pagebreak" id="page_464"/>need to set the DLAB bit to <code>1</code> to place our UART in the mode that allows us to set the baud rate <span class="ent">❷</span>.</p>&#13;
<p class="indent">Next, we need a header file for declaring the functions, as shown in <a href="ch20.xhtml#ch20list11">Listing 20-11</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>UART_functions.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Initialize, read, and write functions for an abstract UART.&#13;
// WARNING: This code does not run on any known device. It is&#13;
// meant to sketch some general I/O concepts only.&#13;
&#13;
#ifndef UART_FUNCTIONS_H&#13;
#define UART_FUNCTIONS_H&#13;
void UART_init(unsigned char* UART);                  // Initialize UART&#13;
unsigned char UART_in(unsigned char* UART);           // Input&#13;
void UART_out(unsigned char* UART, unsigned char c);  // Output&#13;
#endif</pre>&#13;
<p class="list" id="ch20list11"><em>Listing 20-11: The UART function declarations</em></p>&#13;
<p class="indent">The header file declares the three basic functions for using our UART. I won’t cover the more advanced features of a UART in this book.</p>&#13;
<p class="indent">We’ll place the definitions of these three functions in one file, as shown in <a href="ch20.xhtml#ch20list12">Listing 20-12</a>, because they would typically be used together.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>UART_functions.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Initialize, read, and write functions for a 16550 UART.&#13;
// WARNING: This code does not run on any known device. It is&#13;
// meant to sketch some general I/O concepts only.&#13;
&#13;
#include "UART_defs.h"&#13;
#include "UART_functions.h"&#13;
&#13;
// UART_init initializes the UART and enables it.&#13;
void UART_init(unsigned char* UART)&#13;
{&#13;
    unsigned char* port = UART;&#13;
&#13;
    *(port+IER) = NO_INTERRUPT;   // No interrupts&#13;
    *(port+FCR) = NO_FIFO;        // No FIFO&#13;
    *(port+LCR) = SET_BAUD;       // Set frequency mode&#13;
    *(port+DLM) = MSB_38400;      // Set to 38400 baud&#13;
    *(port+DLL) = LSB_38400;      // 2 regs to set&#13;
    *(port+LCR) = SET_COM;        // Communications mode&#13;
}&#13;
&#13;
// UART_in waits until the UART has a character and then reads it.&#13;
unsigned char UART_in(unsigned char* UART)&#13;
{&#13;
    unsigned char* port = UART;&#13;
    unsigned char character;&#13;
<span epub:type="pagebreak" id="page_465"/> <span class="ent">❶</span> while ((*(port+LSR) &amp; RxRDY) != 0) {&#13;
    }&#13;
    character = *(port+RHR);&#13;
    return character;&#13;
}&#13;
&#13;
// UART_out waits until the UART is ready and then writes a character.&#13;
void UART_out(unsigned char* UART, unsigned char character)&#13;
{&#13;
    unsigned char* port = UART;&#13;
&#13;
 <span class="ent">❷</span> while ((*(port+LSR) &amp; TxRDY) != 0) {&#13;
    }&#13;
    *(port+THR) = character;&#13;
}</pre>&#13;
<p class="list" id="ch20list12"><em>Listing 20-12: The UART memory-mapped I/O function definitions in C</em></p>&#13;
<p class="indent">The <code>UART_init</code> function sets the various communication parameters for the UART. The purposes of the values I used in this example are explained after <a href="ch20.xhtml#ch20list10">Listing 20-10</a>.</p>&#13;
<p class="indent">The <code>UART_in</code> function waits in a <code>while</code> loop until the <code>RxRDY</code> bit becomes <code>1</code>, which occurs when the UART has a character ready to read from its receive holding register <span class="ent">❶</span>. The character is read from the receive holding register with an assignment to a local variable.</p>&#13;
<p class="indent">The <code>UART_out</code> function waits in a <code>while</code> loop until the <code>TxRDY</code> bit becomes <code>1</code>, which occurs when the UART is ready for us to send a character to the transmit holding register <span class="ent">❷</span>. The character is sent with an assignment to the transmit holding register.</p>&#13;
<p class="indent">These functions provide an overall view of how a UART is used in a polling mode. I’ve omitted many details here that are required to ensure robust operation. If you would like to use one of the UARTs on a Raspberry Pi, you can start with the documentation at <em><a href="https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header">https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#gpio-and-the-40-pin-header</a></em>. I recommend accessing the UART through the operating system instead of directly, as we did when blinking an LED earlier in this chapter. I have not used the UARTs on a Raspberry Pi, so I can’t vouch for any of them, but tutorials are available online.</p>&#13;
<h3 class="h3" id="ch20lev1sec6"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Virtual memory</strong> The memory address space used by a program.</p>&#13;
<p class="noindentin"><strong>Memory mapping unit (MMU)</strong> A hardware device that uses a map table to convert virtual memory addresses to physical memory addresses.</p>&#13;
<p class="noindentin"><strong>Translation lookaside buffer (TLB)</strong> Memory in the MMU where the most recently used map table entries are cached.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_466"/><strong>Memory timing</strong>   Memory access is synchronized with the timing of the CPU.</p>&#13;
<p class="noindentin"><strong>I/O timing</strong>   I/O devices are much slower than the CPU and have a wide range of characteristics, so we need to program their access.</p>&#13;
<p class="noindentin"><strong>Bus timing</strong>   Buses are often arranged in a hierarchical manner to better match the differences in timing between various I/O devices.</p>&#13;
<p class="noindentin"><strong>Port-mapped I/O</strong>   With this technique, I/O device registers have their own address space.</p>&#13;
<p class="noindentin"><strong>Memory-mapped I/O</strong>   With this technique, I/O registers are given a portion of the main memory address space.</p>&#13;
<p class="noindentin"><strong>Programmed I/O</strong>   The program transfers data directly from an input device or to an output device at the point where it’s needed.</p>&#13;
<p class="noindentin"><strong>Polled I/O</strong>   The program waits in a loop until the I/O device is ready to transfer data.</p>&#13;
<p class="noindentin"><strong>Interrupt-driven I/O</strong>   The I/O device interrupts the CPU when it is ready to transfer data.</p>&#13;
<p class="noindentin"><strong>Direct memory access</strong>   The I/O device can transfer data to and from main memory without using the CPU.</p>&#13;
<p class="noindentin"><strong>General-purpose I/O (GPIO)</strong>   A general-purpose I/O device can be programmed to input or output a single bit of information.</p>&#13;
<p class="indenta">In the next chapter, you’ll learn about the CPU features that allow it to maintain control over the I/O hardware and prevent application programs from accessing the hardware without going through the operating system.</p>&#13;
</div>
</div>
</body></html>