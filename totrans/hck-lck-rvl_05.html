<html><head></head><body>
<div id="sbo-rt-content">
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">

<header>

<hgroup>
<h2 class="CHAPTER" id="ch3">

<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label=" Page 55. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>

<span class="CT-NOBOT"><samp class="SANS_Dogma_OT_Bold_B_11">THE COMMAND LINE INTERFACE</samp></span>

</h2>
</hgroup>

<blockquote epub:type="epigraph" role="doc-epigraph">

<p class="EP"><i>Back in the days of the command-line interface, users were all Morlocks who had to convert their thoughts into alphanumeric symbols and type them in, a grindingly tedious process that stripped away all ambiguity, laid bare all hidden assumptions, and cruelly punished laziness and imprecision.</i></p>

<p class="EPC"><span class="epigraphsource_Italic">—Neal Stephenson,</span> <i>In the Beginning … Was the Command Line</i></p>
</blockquote>

</header>

<p class="COS">If you’re like most people, you interface with your computer primarily via its graphical desktop environment: you move the pointer with your mouse or trackpad and click icons to run programs and open documents. Programs open in windows that you can resize, maximize, minimize, and drag around the screen. You can run various programs at once in separate windows and switch between them. However, there’s an alternative, incredibly powerful interface you can use to communicate with your computer and give it instructions: the <i>command line interface (CLI)</i>.</p>

<p class="TX">Command line interfaces are text-based, rather than graphical, interfaces to interact with your computer. Instead of clicking on icons, you enter commands to run programs in a <i>terminal emulator</i> (normally referred to just <span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label=" Page 56. "/>as a <i>terminal</i>). After running a command, you’ll typically see text-based output displayed in the terminal.</p>

<p class="TX">In this chapter, you’ll learn the basic command line skills you need to follow along with the rest of this book. Whether you’re using Windows, macOS, or Linux, you’ll learn how to install and uninstall software via the command line, how filepaths work, how to navigate around the folders on your computer, and how to use text editors. You’ll also write your first <i>shell script</i>, a file containing a series of commands.</p>

<section epub:type="division" aria-labelledby="sec1">

<h3 class="H1" id="sec1"><span id="h-49"/><samp class="SANS_Futura_Std_Bold_B_11">Introducing the Command Line</samp></h3>

<p class="TNI">To prepare you to start working on the command line, this section explains some fundamentals: what shells are, how users and paths work in different operating systems, and the concept of privilege escalation.</p>

<section epub:type="division" aria-labelledby="sec2">

<h4 class="H2" id="sec2"><span id="h-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Shell</samp></h4>

<p class="TNI">The <i>shell</i> is the program that lets you run text-based commands, while the terminal is the graphical program that runs your shell. When you open a terminal and see a blinking text cursor waiting for commands, you’re using a shell. When hackers try to break into a computer, their initial goal is to “pop a shell,” or access the text-based interface that allows them to run whatever commands they want.</p>

<p class="TX">All operating systems, even mobile ones like Android and iOS, have shells. This book focuses on Unix shells, the kind that come with macOS and Linux (but Windows users can also use them). Most versions of Linux use a shell called bash, and macOS uses one called zsh. These shells are very similar, and for the purposes of this book you can think of them as interchangeable.</p>

<p class="TX">Windows, on the other hand, comes with two shells: an older one called Command Prompt (or <i>cmd.exe</i>) and a newer one called PowerShell. The <i>syntax</i>—rules that define what different commands mean—used by Windows shells is very different from that used by Unix shells. If you’re a Windows user, you’ll primarily work in a Unix shell for the examples in this book. Setting up your computer to run Linux directly in Windows will be this chapter’s first exercise.</p>

<p class="TX">To make your shell do something, such as run a program, you carefully enter the desired command and then press <small>ENTER</small> (or <small>RETURN</small> on Mac keyboards). To quit the shell, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp> and press <small>ENTER</small>. Shells are finicky: you need to enter commands using the correct capitalization, punctuation, and spacing, or they won’t work. Typos usually result in nothing more serious than error messages, however, and it’s easy to go back and fix a mistake in a command. I’ll explain how to do so in the <span class="Xref">“Editing Commands”</span> section on page 68.</p>

</section>

<section epub:type="division" aria-labelledby="sec3">

<h4 class="H2" id="sec3"><span id="h-51"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label=" Page 57. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Users and Paths</samp></h4>

<p class="TNI">Although operating systems like Windows, macOS, and Linux are different in some ways, they all share basic building blocks, including users and paths.</p>

<p class="TX">All operating systems have <i>users</i>, separate accounts that different people use to log in to the same computer. Users generally have home folders, also known as home directories, where their files live. <a href="#fig3-1">Figure 3-1</a> shows my terminal in Ubuntu, a popular Linux distribution.</p>
<figure class="IMG"><img class="img90" id="fig3-1" src="Images/Figure3-1.png" alt="A screenshot of the author’s terminal app in Ubuntu." width="624" height="156"/>

<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: My Ubuntu terminal</samp></p></figcaption>

</figure>

<p class="TX">My username is <i>micah</i> and the name of my Ubuntu computer is <i>rogue</i>. Your terminal will look different depending on your operating system, username, and computer name.</p>

<p class="TX">All operating systems also have filesystems, the collection of files and folders available on the computer (you got a brief introduction to filesystems in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> while encrypting your USB disk). In a filesystem, each file and folder has a <i>path</i>, which you can think of like the location, or address, of that file. For example, if your username is <i>alice</i>, the path of your home folder in different operating systems would look as follows:</p>
<ul class="BL">

<li class="BL">Windows: <i>C:\Users\alice</i></li>
<li class="BL">macOS: <i>/Users/alice</i></li>
<li class="BL">Linux: <i>/home/alice</i></li>
</ul>

<p class="TX">Windows filesystems operate differently from macOS or Linux filesystems in a few key ways. First, in Windows, disks are labeled with letters. The main disk, where Windows itself is installed, is the <i>C: drive</i>. Other disks, like USB disks, are assigned other letters. In Windows, folders in a path are separated with a backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>), while other operating systems use forward slashes (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>). In Linux, paths are case sensitive, but not in Windows and macOS (by default). For example, in Linux you can store one file called <i>Document.pdf</i> and another called <i>document.pdf</i> in the same folder. If you try to do the same in Windows, saving the second file overwrites the first.</p>

<p class="TX">Let’s look at some example paths. If your username is <i>alice</i> and you download a file called <i>Meeting Notes.docx</i> into the <i>Downloads</i> folder, here’s what that path would look like:</p>
<ul class="BL">

<li class="BL">Windows: <i>C:\Users\alice\Downloads\Meeting Notes.docx</i></li>
<li class="BL">macOS: <i>/Users/alice/Downloads/Meeting Notes.docx</i></li>
<li class="BL">Linux: <i>/home/alice/Downloads/Meeting Notes.docx</i></li>
</ul>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label=" Page 58. "/>When you plug in a USB disk, it’s mounted to different paths for different operating systems. If your disk is labeled <i>datasets</i>, the path representing the location of that disk might look as follows:</p>
<ul class="BL">

<li class="BL">Windows: <i>D:</i> (or whatever drive letter Windows decides to mount the disk to)</li>
<li class="BL">macOS: <i>/Volumes/datasets</i></li>
<li class="BL">Linux: <i>/media/alice/datasets</i></li>
</ul>

<p class="TX">It’s important to understand how to read paths, since you’ll need to include the location of your dataset or files it contains in the commands you run.</p>

</section>

<section epub:type="division" aria-labelledby="sec4">

<h4 class="H2" id="sec4"><span id="h-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">User Privileges</samp></h4>

<p class="TNI">Most users have limited privileges in an operating system. However, the <i>root user</i> in Linux and macOS and the <i>administrator user</i> in Windows have absolute power. While <i>alice</i> may not be able to save files into <i>bob</i>’s home folder, for example, the root user has permissions to save files anywhere on the computer. When a Mac asks you to enter your user password to change system preferences or install software, or when a Windows machine asks if you want to allow a program to make changes to your computer, the operating system is asking for your consent before switching from your unprivileged user account to the root or administrator user account.</p>

<p class="TX">Most of the time when you’re working in a terminal, you run commands as an unprivileged user. To run a command that requires root (or administrative) privileges in Linux and macOS, such as to install a new program, just put <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp> in front of it and press <small>ENTER</small>, and you’ll be prompted to enter the password for your regular user account.</p>

<p class="TX">As an example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">whoami</samp> command tells you which user just ran a command. On my computer, if I enter <samp class="SANS_TheSansMonoCd_W5Regular_11">whoami</samp> without <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>, the output is <samp class="SANS_TheSansMonoCd_W5Regular_11">micah</samp>. However, if I enter <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo whoami</samp>, which requires me to type my password, the output is <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp>:</p>

<pre id="pre-3"><code>micah@rogue:~$ <b>whoami</b>

micah

micah@rogue:~$ <b>sudo whoami</b>

[sudo] password for micah:

root</code></pre>

<p class="TX">If you recently ran <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>, you can run it again for a few minutes without having to re-enter your password.</p>

<p class="Warning"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp></span></p>

<p class="NOTE-TXT"><i>Be very careful when running commands as root, since running the wrong commands as the root user can accidentally delete all of your data or break your operating system. Before using sudo, make sure you have a clear understanding of what you’re about to do.</i></p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label=" Page 59. "/>You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp> to gain root access only if your current user has administrator access. If you’re the only user on your computer, you’re probably an administrator. To find out, try using <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp> and see whether you get a “permission denied” error.</p>

<p class="TX"><a href="#fig3-2">Figure 3-2</a> shows a comic by Randall Munroe from his XKCD website that succinctly demonstrates the power of <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>.</p>
<figure class="IMG"><img class="img50" id="fig3-2" src="Images/Figure3-2.png" alt="In this XKCD comic, a person says, “Make me a sandwich.” Another says, “What? Make it yourself.” The first person says, “Sudo make me a sandwich.” The other responds, “Okay.”" width="376" height="312"/>

<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Demanding a sandwich with sudo</samp></p></figcaption>

</figure>

<p class="TX">Before learning more command line code, Windows users must install Ubuntu (see Exercise 3-1). Mac or Linux users can skip to the “<span class="Xref">Basic Command Line Usage”</span> section on <span class="Xref">page 62</span>.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec5">

<h3 class="H1F" id="sec5"><span id="h-53"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3-1: Install Ubuntu in Windows</samp></h3>

<p class="TNI">To work with Ubuntu on a Windows machine, you could install both Windows and Linux or use a virtual machine within Windows, as mentioned in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>. However, for this book’s purposes, it’s simplest to use the <i>Windows Subsystem for Linux (WSL)</i>, a Microsoft technology that lets you run Linux programs directly in Windows. Opening an Ubuntu window in WSL will, in turn, open a bash shell and let you install and run Ubuntu software. (Technically, WSL does use a VM, but it’s fast, managed by Windows, and unobtrusive, running entirely behind the scenes.)</p>

<p class="TX">To install WSL, open a PowerShell window as an administrator: click <b>Start</b>, search for <b>powershell</b>, right-click <b>Windows PowerShell</b>, choose <b>Run as Administrator</b>, and click <b>Yes</b>. <a href="#fig3-3">Figure 3-3</a> shows this process, which may look slightly different depending on your version of Windows.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label=" Page 60. "/>

<figure class="IMG"><img class="img80" id="fig3-3" src="Images/Figure3-3.png" alt="A screenshot of the Run as Administrator option in the drop-down menu after the user has right-clicked on Windows PowerShell" width="601" height="477"/>

<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Running PowerShell as an administrator in Windows</samp></p></figcaption>

</figure>

<p class="TX">In your administrator PowerShell window, enter the following command and press <small>ENTER</small>:</p>

<pre id="pre-4"><code><b>wsl --install -d Ubuntu</b></code></pre>

<p class="TX">This installs the Windows Subsystem for Linux, then downloads and installs Ubuntu Linux on your computer.</p>

<p class="TX">Your screen should now look something like this:</p>

<pre id="pre-5"><code>PS C :\Windows\system32&gt; wsl --install -d Ubuntu

Installing: Windows Subsystem for Linux

Windows Subsystem for Linux has been installed.

Downloading: WSL Kernel

Installing: WSL Kernel

WSL Kernel has been installed.

Downloading: GUI App Support

Installing: GUI App Support

GUI App Support has been installed.

Downloading: Ubuntu

The requested operation is succession. Changes will not be effective until the

system is rebooted.

PS C:\Windows\system32&gt;</code></pre>

<p class="TX">The final line of this output tells you to reboot your computer. Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp> and press <small>ENTER</small> (or just close the window) to quit PowerShell, then reboot. After you log in to Windows again, you should see an Ubuntu window informing you that the installation may take a few more minutes to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label=" Page 61. "/>complete. Then the window should present you with a prompt asking you to create a new user:</p>

<pre id="pre-6"><code>Please create a default UNIX user account. The username does not need to match

your Windows username.

For more information visit: https://aka.ms/wslusers

Enter new UNIX username:</code></pre>

<p class="TX">Ubuntu needs to keep track of its own users rather than the existing users on your Windows computer.</p>

<p class="TX">With the Ubuntu terminal window in focus, enter a username and press <small>ENTER</small>. The terminal should then prompt you to create a password:</p>

<pre id="pre-7"><code>New password:</code></pre>

<p class="TX">Either use the same password you use to log in to your Windows account or create a new one and save it in your password manager. Enter your password and press <small>ENTER</small>. While you’re typing, nothing will appear in the Ubuntu terminal.</p>

<p class="TX">The terminal should now prompt you to re-enter your new password; do so and press <small>ENTER</small>, which should drop you into an Ubuntu shell with a prompt and a blinking cursor. My prompt says <samp class="SANS_TheSansMonoCd_W5Regular_11">micah@cloak:~$</samp> because my username is <i>micah</i> and the name of my Windows computer is <i>cloak</i>:</p>

<pre id="pre-8"><code>New password:

Retype new password:

passwd: password updated successfully

Installation successful!

<var>--snip--</var>

micah@cloak:~$</code></pre>

<p class="TX">You can now open Ubuntu in your Windows computer. From this point on, when instructed to open a terminal or run some command line code, use an Ubuntu terminal window unless I specify otherwise.</p>

<p class="TX">From within your Ubuntu shell, you can access your Windows disks in the <i>/mnt</i> folder. For example, you can access the <i>C:</i> drive in <i>/mnt/c</i> and the <i>D:</i> drive in <i>/mnt/d</i>. Suppose I download a document using my web browser and want to access it from Ubuntu. The path to my <i>Downloads</i> folder in Windows is <i>/mnt/c/Users/micah/Downloads</i>, so the document would be in that folder. If I want to access the BlueLeaks data that I downloaded to my USB disk from Ubuntu, then assuming that <i>D:</i> is the USB disk’s drive, the path would be <i>/mnt/d/BlueLeaks</i>.</p>

<p class="TX">For more details on using Windows and WSL, including information on common problems related to using USB disks in WSL, as well as disk performance issues and various ways to deal with them, check out <span class="Xref">Appendix A</span>. Wait until you’ve worked through at least <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> to start implementing these solutions, since the instructions involve more advanced command line concepts introduced in that chapter.</p>

</section>

<section epub:type="division" aria-labelledby="sec6">

<h3 class="H1" id="sec6"><span id="h-54"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label=" Page 62. "/><samp class="SANS_Futura_Std_Bold_B_11">Basic Command Line Usage</samp></h3>

<p class="TNI">In this section, you’ll learn to use the command line to explore files and folders on your computer. This is a prerequisite to working with datasets, which are just folders full of files and other folders. You’ll learn how to open a terminal, list files in any folder, distinguish between relative and absolute paths, switch to different folders in your shell, and look up documentation on commands from within your terminal.</p>
<blockquote>

<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>

<p class="NOTE-TXT"><i>When learning command line skills, you can always look things up if you run into problems—I still do this every day. You’re likely not the first person to encounter any given command line issue, so with a few well-worded internet searches, you can find someone else’s solution.</i></p>

<section epub:type="division" aria-labelledby="sec7">

<h4 class="H2" id="sec7"><span id="h-55"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opening a</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Terminal</samp></h4>

<p class="TNI">To get started, skip to the subsection for your operating system to learn how to open a terminal. Throughout this chapter, keep a terminal open while you’re reading to test all the commands.</p>

<section epub:type="division" aria-labelledby="sec8">

<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Windows Terminal</samp></h5>

<p class="TNI">Open the Ubuntu app by clicking <b>Start</b> in the bottom-left corner of the screen, searching for <b>ubuntu</b>, and clicking <b>Ubuntu</b>.</p>

<p class="TX">You’ll use Ubuntu most often for this book, but you may need to open the native Windows terminals occasionally as well. You can likewise open PowerShell and Command Prompt by clicking <b>Start</b> and searching for them. Check out the Microsoft program Windows Terminal (<a href="https://aka.ms/terminal"><i>https://<wbr/>aka<wbr/>.ms<wbr/>/terminal</i></a>), which lets you open different terminals in different tabs, choosing between PowerShell, Command Prompt, Ubuntu, and others. If you choose to install it, you can open it the same way.</p>

<p class="TX">Pin the Ubuntu app or Windows Terminal app to your taskbar so you can quickly open it in the future: right-click its icon and select <b>Pin to Taskbar</b>.</p>

</section>

<section epub:type="division" aria-labelledby="sec9">

<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The macOS Terminal</samp></h5>

<p class="TNI">Open the Terminal app by opening Finder, going to the <i>Applications</i> folder, double-clicking the <i>Utilities</i> folder, and double-clicking <b>Terminal</b>. <a href="#fig3-4">Figure 3-4</a> shows my macOS terminal running zsh, the default macOS shell. My username is <i>micah</i>, and the name of my Mac is <i>trapdoor</i>.</p>
<figure class="IMG"><img class="img100" id="fig3-4" src="Images/Figure3-4.png" alt="A screenshot of the Terminal app in macOS." width="695" height="91"/>

<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: My macOS terminal</samp></p></figcaption>

</figure>

<p class="TX">Pin the Terminal app to your dock so you can quickly open it in the future. To do so, after you open Terminal, press <small>CTRL</small> and click the Terminal icon on your dock, then choose <b>Options</b><span class="MenuArrow">▸</span><b>Keep in Dock</b>.</p>

</section>

<section epub:type="division" aria-labelledby="sec10">

<h5 class="H3" id="sec10"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label=" Page 63. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Linux Terminal</samp></h5>

<p class="TNI">In most Linux distributions, open the Terminal app by pressing the Windows key, typing <b>terminal</b>, and pressing <small>ENTER</small>. If you’re running Ubuntu (or any other Linux distribution that uses the GNOME graphical environment), pin the Terminal app to your dock so you can quickly open it in the future. To do so, right-click the Terminal icon and select <b>Add to Favorites</b>.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec11">

<h4 class="H2" id="sec11"><span id="h-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clearing Your Screen and Exiting the Shell</samp></h4>

<p class="TNI">As you practice using the terminal in the following sections, you’ll sometimes want to start fresh, without having to see all the previous commands you ran or their output or error messages. Run this simple command to declutter your terminal:</p>

<pre id="pre-9"><code><b>clear</b></code></pre>

<p class="TX">This clears everything off the screen, leaving you with nothing but a blank command prompt. Make sure to do this only if you no longer need to see the output of your previous commands. (In the Windows Command Prompt and PowerShell, use <samp class="SANS_TheSansMonoCd_W5Regular_11">cls</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">clear</samp>.)</p>

<p class="TX">When you’re done using the CLI, exit your shell by running this command:</p>

<pre id="pre-10"><code><b>exit</b></code></pre>

<p class="TX">You can also close the terminal window to exit. If you’re running a program when you close the terminal, that program will quit as well.</p>

</section>

<section epub:type="division" aria-labelledby="sec12">

<h4 class="H2" id="sec12"><span id="h-57"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Files and Directories</samp></h4>

<p class="TNI">When you open a terminal, your shell starts out in your user’s home folder, represented as a tilde (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>). The folder you’re currently in is your <i>current working directory</i>, or just <i>working directory</i>. If you ever forget what directory you’re in, run the <samp class="SANS_TheSansMonoCd_W5Regular_11">pwd</samp> command (short for “print working directory”) to find out.</p>

<p class="TX">Running the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> command in your terminal lists all of the files in your working directory. You can use this command to check the contents of folders you’re working with. If there are no files or only hidden files, <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> won’t list anything. To check for hidden files, modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> command using <samp class="SANS_TheSansMonoCd_W5Regular_11">-a</samp> (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--all</samp>):</p>

<pre id="pre-11"><code><b>ls -a</b></code></pre>

<p class="TX">When you add anything to the end of a command, like <samp class="SANS_TheSansMonoCd_W5Regular_11">-a</samp>, you’re using a <i>command line argument</i>. Think of arguments as settings that change how the program you’re running will act—in this case, by showing hidden files instead of hiding them.</p>

<p class="TX">By default, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> command displays files in a format intended to take up as few lines in your terminal as possible. However, you may want to display one file per line for easier reading and to get more information <span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label=" Page 64. "/>about each file, such as its size, when it was last modified, permissions, and whether it’s a folder. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> argument (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--format=long</samp>) formats the output as a list.</p>

<p class="TX">You can use both <samp class="SANS_TheSansMonoCd_W5Regular_11">-a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> at the same time like so:</p>

<pre id="pre-12"><code><b>ls -al</b></code></pre>

<p class="TX">Running this command on my Mac gives me the following output:</p>

<pre id="pre-13"><code>total 8

drwxr-x---+ 13 micah  staff   416 Nov 25 11:34 .

drwxr-xr-x   6 root   admin   192 Nov  9 15:51 ..

-rw-------   1 micah  staff     3 Nov  6 15:30 .CFUserTextEncoding

-rw-------   1 micah  staff  2773 Nov 25 11:33 .zsh_history

drwx------   5 micah  staff   160 Nov  6 15:31 .zsh_sessions

drwx------+  3 micah  staff    96 Nov  6 15:30 Desktop

drwx------+  3 micah  staff    96 Nov  6 15:30 Documents

drwx------+  3 micah  staff    96 Nov  6 15:30 Downloads

drwx------+ 31 micah  staff   992 Nov  6 15:31 Library

drwx------   3 micah  staff    96 Nov  6 15:30 Movies

drwx------+  3 micah  staff    96 Nov  6 15:30 Music

drwx------+  3 micah  staff    96 Nov  6 15:30 Pictures

drwxr-xr-x+  4 micah  staff   128 Nov  6 15:30 Public</code></pre>

<p class="TX">The first column of this output describes the type of file—whether it’s a <i>directory</i> (another name for a folder) or an ordinary file—as well as the file’s permissions. Directories start with <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>, and ordinary files start with a hyphen (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>). The second column represents the number of links in the file, which isn’t relevant for the purposes of this book.</p>

<p class="TX">The third and fourth columns represent the user and the <i>group</i> that owns the file. In addition to users, operating systems have groups of users that can have their own permissions. For example, in Linux, all users allowed to use <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp> are in the <i>sudo</i> group. If you create or download a file, its user and group are normally your username. The fifth column is the file size in bytes. For example, in the file called <i>.zsh_history</i>, my output is 2,773 bytes.</p>

<p class="TX">The next three columns of the output represent the time and date when the file was last modified, and the final column shows the filename.</p>

<p class="TX">To see a listing of files in a folder other than the working directory, add the path to that folder to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> command. For example, this is how I’d create a listing of files in my <i>code/hacks-leaks-and-revelations</i> folder, which contains the files released with this book:</p>

<pre id="pre-14"><code><b>ls -la code/hacks-leaks-and-revelations</b></code></pre>

<p class="TX">I’d get the following output:</p>

<pre id="pre-15"><code>total 96

drwxr-xr-x  22 micah  staff    704 Jul 27 09:28 .

drwxr-xr-x  12 micah  staff    384 Jul 27 09:28 ..

drwxr-xr-x  12 micah  staff    384 Jul 27 09:28 .git<span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label=" Page 65. "/>

drwxr-xr-x   3 micah  staff     96 Jul 27 09:28 .github

-rw-r--r--   1 micah  staff     30 Jul 27 09:28 .gitignore

-rw-r--r--   1 micah  staff  35149 Jul 27 09:28 LICENSE

-rw-r--r--   1 micah  staff   6997 Jul 27 09:28 README.md

drwxr-xr-x   6 micah  staff    192 Jul 27 09:28 appendix-b

drwxr-xr-x   5 micah  staff    160 Jul 27 09:28 chapter-1

drwxr-xr-x   6 micah  staff    192 Jul 27 09:28 chapter-10

drwxr-xr-x  11 micah  staff    352 Jul 27 09:28 chapter-11

drwxr-xr-x  13 micah  staff    416 Jul 27 09:28 chapter-12

drwxr-xr-x   8 micah  staff    256 Jul 27 09:28 chapter-13

drwxr-xr-x   3 micah  staff     96 Jul 27 09:28 chapter-14

drwxr-xr-x   5 micah  staff    160 Jul 27 09:28 chapter-2

drwxr-xr-x  10 micah  staff    320 Jul 27 09:28 chapter-3

drwxr-xr-x  13 micah  staff    416 Jul 27 09:28 chapter-4

drwxr-xr-x  13 micah  staff    416 Jul 27 09:28 chapter-5

drwxr-xr-x  10 micah  staff    320 Jul 27 09:28 chapter-6

drwxr-xr-x  12 micah  staff    384 Jul 27 09:28 chapter-7

drwxr-xr-x  20 micah  staff    640 Jul 27 09:28 chapter-8

drwxr-xr-x  14 micah  staff    448 Jul 27 09:28 chapter-9</code></pre>

<p class="TX">You’ll download your own copy of these files in Exercise 3-7.</p>

</section>

<section epub:type="division" aria-labelledby="sec13">

<h4 class="H2" id="sec13"><span id="h-58"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Navigating Relative and Absolute Paths</samp></h4>

<p class="TNI">Programs often require you to provide paths to files or folders, usually when you run a program that works with specific files on your computer. The path that I passed into <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> in the previous section, <i>code/hacks-leaks-and-revelations</i>, is a <i>relative</i> path, meaning it’s relative to the current working directory, my home folder. Relative paths can change. For example, if I change my working directory from my home folder (<i>/Users/micah</i>) to just <i>/Users</i>, the relative path to that folder changes to <i>micah/code/hacks-leaks-and-revelations</i>.</p>

<p class="TX">The <i>absolute</i> path to the <i>code/hacks-leaks-and-revelations</i> folder is <i>/Users/micah/code/hacks-leaks-and-revelations</i>, which always provides the location of that folder regardless of my working directory. Absolute paths start with a forward slash (<i>/</i>), which is also known as the root path.</p>

<p class="TX">You can use two keywords to access relative paths to specific folders: <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> (dot), which represents a relative path to the current folder, and <samp class="SANS_TheSansMonoCd_W5Regular_11">..</samp> (dot dot), which represents a relative path to the <i>parent folder</i> (the folder that contains the current folder).</p>

</section>

<section epub:type="division" aria-labelledby="sec14">

<h4 class="H2" id="sec14"><span id="h-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Changing Directories</samp></h4>

<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cd</samp> command (which stands for “change directory”) allows you to change to a different folder. To change your working directory to the folder, run:</p>

<pre id="pre-16"><code><b>cd </b><b><var>path</var></b></code></pre>

<p class="TX">For <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>, substitute the path to the folder to which you’d like to move. You can use either a relative or an absolute path.</p>

<p class="TX">Suppose I’m using macOS and have downloaded BlueLeaks to a <i>datasets</i> USB disk plugged into my machine. After opening a terminal, I can run the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label=" Page 66. "/>following command to change my working directory to the <i>BlueLeaks</i> folder, using the absolute path to the folder:</p>

<pre id="pre-17"><code>cd /Volumes/datasets/BlueLeaks</code></pre>

<p class="TX">Alternatively, I can use a relative path to the folder, running the following command from my home folder:</p>

<pre id="pre-18"><code>cd ../../Volumes/datasets/BlueLeaks</code></pre>

<p class="TX">Why does the relative path start with <samp class="SANS_TheSansMonoCd_W5Regular_11">../..</samp> in this example? When I open the terminal, the working directory is my home folder, which in macOS is <i>/Users/micah</i>. The relative path <samp class="SANS_TheSansMonoCd_W5Regular_11">..</samp> would be its parent folder, <i>/Users</i>; the relative path <samp class="SANS_TheSansMonoCd_W5Regular_11">../..</samp> would be <i>/</i>; the relative path <samp class="SANS_TheSansMonoCd_W5Regular_11">../../Volumes</samp> would be <i>/Volumes</i>; and so on.</p>

<p class="TX">As noted earlier, the tilde symbol (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) represents your home folder. No matter what your working directory is, you can run the following to go back to your home folder:</p>

<pre id="pre-19"><code><b>cd</b> <b><var>~</var></b></code></pre>

<p class="TX">Use the following syntax to move to a folder inside your home folder:</p>

<pre id="pre-20"><code><b>cd</b> <b><var>~/folder_name</var></b></code></pre>

<p class="TX">For example, the following command would move you to your <i>Documents</i> folder:</p>

<pre id="pre-21"><code><b>cd ~/Documents</b></code></pre>

<p class="TX">If you run <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> again after a <samp class="SANS_TheSansMonoCd_W5Regular_11">cd</samp> command, the output should show you the files in the folder to which you just moved.</p>

</section>

<section epub:type="division" aria-labelledby="sec15">

<h4 class="H2" id="sec15"><span id="h-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the help Argument</samp></h4>

<p class="TNI">Most commands let you use the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">-h</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>, which displays detailed instructions explaining what the command does and how to use it. For example, try running the following:</p>

<pre id="pre-22"><code><b>unzip --help</b></code></pre>

<p class="TX">This command should show instructions on all of the different arguments that are available to you when using the <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp> command, which is used to extract compressed ZIP files.</p>

<p class="TX">Here’s the output I got when I ran that command on my Mac:</p>

<pre id="pre-23"><code>UnZip 6.00 of 20 April 2009, by Info-ZIP.  Maintained by C. Spieler.  Send

bug reports using http://www.info-zip.org/zip-bug.html; see README for details.

<var>--snip--</var><span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label=" Page 67. "/>

  -p  extract files to pipe, no messages     -l  list files (short format)

  -f  freshen existing files, create none    -t  test compressed archive data

  -u  update files, create if necessary      -z  display archive comment only

  -v  list verbosely/show version info       -T  timestamp archive to latest

  -x  exclude files that follow (in xlist)   -d  extract files into exdir

<var>--snip--</var></code></pre>

<p class="TX">This output briefly describes what each argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp> command does. For example, if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> argument, the command shows a list of all of the files and folders inside the ZIP file without actually unzipping it.</p>

</section>

<section epub:type="division" aria-labelledby="sec16">

<h4 class="H2" id="sec16"><span id="h-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Man Pages</samp></h4>

<p class="TNI">Many commands also have manuals, otherwise known as <i>man pages</i>, which give more detail about how to use those commands. Run the following to access a command’s man page:</p>

<pre id="pre-24"><code><b>man</b> <b><var>command_name</var></b></code></pre>

<p class="TX">For example, to read the manual for the <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp> command, run:</p>

<pre id="pre-25"><code><b>man unzip</b></code></pre>

<p class="TX">The output should display a longer explanation of how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp> command and its arguments.</p>

<p class="TX">Use the up and down arrows and the page up and page down keys to scroll through the man pages, or press <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> and enter a term to search. For example, to learn more details about how the <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp> command’s <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> argument works, press <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> and enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-l</samp>, then press <small>ENTER</small>. This should bring you to the first time <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> appears on the man page. Press N to move on to the next occurrence of your search term.</p>

<p class="TX">When you’re finished, press Q to quit the man page.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec17">

<h3 class="H1" id="sec17"><span id="h-62"/><samp class="SANS_Futura_Std_Bold_B_11">Tips for Navigating the Terminal</samp></h3>

<p class="TNI">This section introduces ways to make working on the command line more convenient and efficient, along with tips for avoiding and fixing errors. It also shows how to handle problematic filenames, such as those with spaces, quotes, or other special characters. A basic understanding of these concepts will save you a lot of time in the future.</p>

<section epub:type="division" aria-labelledby="sec18">

<h4 class="H2" id="sec18"><span id="h-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Entering Commands with Tab Completion</samp></h4>

<p class="TNI">Shells have a feature called <i>tab completion</i> that saves time and prevents errors: enter the first few letters of a command or a path, then press <small>TAB</small>. Your shell will fill in the rest if possible.</p>

<p class="TX">For example, both macOS and Ubuntu come with a program called hexdump. In a terminal, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">hexd</samp> and press <small>TAB</small>. This should automatically <span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label=" Page 68. "/>fill in the rest of the hexdump command. Tab completion also works for paths. For example, Unix-like operating systems use the <i>/tmp</i> folder to store temporary files. Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls /tm</samp> and press <small>TAB</small>. Your shell should add the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> to finish typing out the full command.</p>

<p class="TX">If you enter only the first couple letters of a command or a path, there may be more than one way for your shell to complete your line of code. Assuming that you have both <i>Downloads</i> and <i>Documents</i> folders in your home folder, type <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls ~/Do</samp> and press <small>TAB</small>. You’ll hear a quiet beep, meaning that the shell doesn’t know how to proceed. Press <small>TAB</small> one more time, and it should display the options, like this:</p>

<pre id="pre-26"><code>Documents/  Downloads/</code></pre>

<p class="TX">If you enter a <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> so that your command so far is <samp class="SANS_TheSansMonoCd_W5Regular_11">ls ~/Doc</samp> and press <small>TAB</small>, the command should complete to <samp class="SANS_TheSansMonoCd_W5Regular_11">ls ~/Documents/</samp>. If you enter a <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> so that your command so far is <samp class="SANS_TheSansMonoCd_W5Regular_11">ls ~/Dow</samp> and press <small>TAB</small>, it should complete to <samp class="SANS_TheSansMonoCd_W5Regular_11">ls ~/Downloads/</samp>.</p>

<p class="TX">If you’ve already typed out the path of a folder, you can also press <small>TAB</small> to list files in that folder, or to automatically complete the filename if there’s only one file in the folder. For example, say I have my <i>datasets</i> USB disk, on which I’ve downloaded BlueLeaks, plugged into my Ubuntu computer. If I want to change to my <i>BlueLeaks</i> folder, I can enter the following and press <small>TAB</small>:</p>

<pre id="pre-27"><code>cd /Vo</code></pre>

<p class="TX">This completes the command as follows:</p>

<pre id="pre-28"><code>cd /Volumes/</code></pre>

<p class="TX">I press <small>TAB</small> again, and my computer beeps and lists the folders in <i>/Volumes</i>, which in my case are <i>Macintosh HD</i> and <i>datasets</i>. I enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">d</samp>, so my command is <samp class="SANS_TheSansMonoCd_W5Regular_11">cd /Volumes/d</samp>, and press <small>TAB</small>, and the shell completes the command as follows:</p>

<pre id="pre-29"><code>cd /Volumes/datasets/</code></pre>

<p class="TX">I press <small>TAB</small> again. My computer beeps again and lists all of the files and folders in my <i>datasets</i> USB disk. I enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">B</samp> (the first letter of BlueLeaks) and press <small>TAB</small>, which gives me:</p>

<pre id="pre-30"><code>cd /Volumes/datasets/BlueLeaks/</code></pre>

<p class="TX">Finally, I press <small>ENTER</small> to change to that folder.</p>

</section>

<section epub:type="division" aria-labelledby="sec19">

<h4 class="H2" id="sec19"><span id="h-64"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Editing Commands</samp></h4>

<p class="TNI">You can also edit commands. When you start typing a command, you can press the left and right arrow keys to move the cursor, allowing you to edit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label=" Page 69. "/>the command before running it. You can also press <small>HOME</small> and <small>END</small>—or, if you’re using a Mac keyboard, <small>CONTROL</small>-A and <small>CONTROL</small>-E—to go to the beginning and end of a line, respectively. You can also cycle between commands you’ve already run using the up and down arrows. If you just ran a command and want to run it again, or to modify it and then run it, press the up arrow to return to it. Once you find the command you’re looking for, use the arrow keys to move your cursor to the correct position, edit it, and then press <small>ENTER</small> to run it again.</p>

<p class="TX">For example, I frequently get “permission denied” errors when I accidentally run commands as my unprivileged user when I should have run them as root. When this happens, I press the up arrow, then <small>CONTROL</small>-A to go to the beginning of the line, add <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>, and press <small>ENTER</small> to successfully run the command.</p>

</section>

<section epub:type="division" aria-labelledby="sec20">

<h4 class="H2" id="sec20"><span id="h-65"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dealing with Spaces in Filenames</samp></h4>

<p class="TNI">Sometimes filenames contain multiple words separated by spaces. If you don’t explicitly tell your shell that a space is part of a filename, the shell assumes that the space is there to separate parts of your command. For example, this command lists the files in the <i>Documents</i> folder:</p>

<pre id="pre-31"><code><b>ls -lh ~/Documents</b></code></pre>

<p class="TX">Under the hood, your shell takes this string of characters and splits it into a list of parts that are separated by spaces: <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-lh</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">~/Documents</samp>. The first part, <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>, is the command to run. The rest of the parts are the command’s arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-lh</samp> argument tells the program to display the output as a list and make the file sizes human-readable. That is, it will convert the file sizes into units that are easier to read, like kilobytes, megabytes, and gigabytes, rather than a large number of bytes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">~/Documents</samp> argument means you want to list the files in that folder.</p>

<p class="TX">Suppose you want to use the same command to list the files in a folder with a space in its name, like <i>~/My Documents</i>. You’ll run into problems if you enter this command:</p>

<pre id="pre-32"><code>ls -lh ~/My Documents</code></pre>

<p class="TX">When your shell tries to separate this command into parts, it will come up with <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-lh</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">~/My</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Documents</samp>; that is, it sees <i>~/My Documents</i> as two separate arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">~/My</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Documents</samp>. It will try to list the files in the folder <i>~/My</i> (which doesn’t exist), then also list files in the folder <i>Documents</i>, which isn’t what you intended.</p>

<p class="TX">To solve this problem, put the name of the folder in quotes:</p>

<pre id="pre-33"><code><b>ls -lh "~/My Documents"</b></code></pre>

<p class="TX">The shell sees anything within quotes as a single entity. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> is the command and its arguments are <samp class="SANS_TheSansMonoCd_W5Regular_11">-lh</samp> followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">~/My Documents</samp>.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label=" Page 70. "/>Alternatively, you can use a backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) to <i>escape</i> the space:</p>

<pre id="pre-34"><code><b>ls -lh ~/My\ Documents</b></code></pre>

<p class="TX">In the Unix family of operating systems, the backslash is called the <i>escape character</i>. When the shell parses that string of characters, it treats an <i>escaped space</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp> followed by a space) as a part of the name. Again, the shell reads <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> as the command and <samp class="SANS_TheSansMonoCd_W5Regular_11">-lh</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">~/My Documents</samp> as its arguments.</p>

</section>

<section epub:type="division" aria-labelledby="sec21">

<h4 class="H2" id="sec21"><span id="h-66"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Single Quotes Around Double Quotes</samp></h4>

<p class="TNI">You can use the escape character to escape more than spaces. Suppose you want to delete a filename that has a space <i>and</i> quotes in it, like <i>Say “Hello”.txt.</i> You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">rm</samp> command to delete files, but the following syntax won’t work:</p>

<pre id="pre-35"><code>rm Say "Hello".txt</code></pre>

<p class="TX">Your shell will split this command into the words <samp class="SANS_TheSansMonoCd_W5Regular_11">rm</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Say</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello.txt</samp>. You might think you could solve this by simply adding more quotes</p>

<pre id="pre-36"><code>rm "Say "Hello".txt"</code></pre>

<p class="BodyContinued">but that won’t work either, since you’re quoting something that contains quotes already. Instead, surround the argument with single quotes ('), like this:</p>

<pre id="pre-37"><code><b>rm 'Say "Hello".txt'</b></code></pre>

<p class="TX">Your shell will read this command as <samp class="SANS_TheSansMonoCd_W5Regular_11">rm</samp> and the argument as <samp class="SANS_TheSansMonoCd_W5Regular_11">Say "Hello" .txt</samp>, exactly as you intended.</p>

<p class="TX">Avoid putting spaces, quotes, or other troublesome characters in filenames whenever possible. Sometimes you can’t avoid them, especially when working with datasets full of someone else’s files. Tab completion helps in those cases, allowing you to enter just enough of the filename so that when you press <small>TAB</small>, your shell will fill out the rest for you. To delete a file in your working directory called <i>Say “Hello”.txt</i>, for example, entering <samp class="SANS_TheSansMonoCd_W5Regular_11">rm Sa</samp>, then pressing <small>TAB</small>, completes the command to <samp class="SANS_TheSansMonoCd_W5Regular_11">rm Say\ \"Hello\".txt</samp> with the correct escape characters included, so you don’t have to provide the proper syntax yourself.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec22">

<h3 class="H1" id="sec22"><span id="h-67"/><samp class="SANS_Futura_Std_Bold_B_11">Installing and Uninstalling Software with Package Managers</samp></h3>

<p class="TNI">Of the many powerful command line tools that let you quickly work with datasets, only some come preinstalled; you’ll need to install the rest yourself. While you’re likely used to installing software by downloading an installer from a website and then running it, the command line uses <i>package</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label=" Page 71. "/><i>managers</i>, programs that let you install, uninstall, and update software. Nearly all CLI software is free and open source, so Linux operating systems come with large collections of software that you can easily install or uninstall with a single command. Package management projects are also available for macOS (Homebrew) and Windows (Chocolately).</p>

<p class="TX">If you’re using Linux, you likely use a package manager called apt. This is what the popular Linux operating systems like Ubuntu and Debian use, as well as all of the Linux distributions based on them (including Ubuntu in WSL). If your Linux distribution doesn’t use apt, you’ll need to look up the package manager documentation for your operating system.</p>
<aside class="box" aria-labelledby="box-12">

<h4 class="BH" id="box-12"><samp class="SANS_Dogma_OT_Bold_B_11">PACKAGE MANAGEMENT FOR NON-UBUNTU LINUX USERS</samp></h4>

<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You should be able to follow along with this book no matter what version of Linux you’re using. Several other Debian-based Linux distributions also rely on apt, like Linux Mint, Pop! OS, and others. If you’re using one of these, the apt commands in this book should work, though the names of software packages may be slightly different. If you encounter that issue, run</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">apt search</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">software_name</samp> <samp class="SANS_Futura_Std_Book_11">to find the name of the package that you should be installing for your operating system.</samp></p>

<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">If you’re using a version of Linux that doesn’t use apt as its package manager, you’ll need to slightly modify this book’s commands to use your Linux distribution’s package manager. For example, if you’re running Fedora, Red Hat, CentOS, or other similar Linux distributions, you’ll use a package manager called DNF (for older versions of these distributions, the package manager is called yum). See Fedora’s documentation at</samp> <a href="https://docs.fedoraproject.org/en-US/quick-docs/dnf/"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://docs.fedoraproject.org/en-US/quick-docs/dnf/</samp></a> <samp class="SANS_Futura_Std_Book_11">for more details on using DNF. Arch Linux uses a package manager called pacman (</samp><a href="https://wiki.archlinux.org/title/Pacman"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://wiki.archlinux.org/title/Pacman</samp></a><samp class="SANS_Futura_Std_Book_11">).</samp></p>

<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">If you’re using a Linux distribution not mentioned here, read your operating system’s package management documentation and learn how to search for, install, uninstall, and update software from the terminal. When you come across an apt command in this book, use your operating system’s package manager software instead. Other Linux commands covered in this book should be the same regardless of your distribution.</samp></p>
</aside>

<p class="TX">If you’re using a Mac, start with Exercise 3-2 to learn how to use Homebrew. If you’re using Linux or Windows with WSL, skip to Exercise 3-3 to learn how to use apt. This book mostly uses Unix shells and doesn’t cover Chocolately, which installs Windows software instead of Linux software.</p>

</section>

<section epub:type="division" aria-labelledby="sec23">

<h3 class="H1F" id="sec23"><span id="h-68"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label=" Page 72. "/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3-2: Manage Packages with Homebrew on macOS</samp></h3>

<p class="TNI">To install Homebrew, macOS’s package manager, open a browser and go to Homebrew’s website at <a href="https://brew.sh"><i>https://<wbr/>brew<wbr/>.sh</i></a>, where you should find the command to install the tool. Copy and paste the installation command into your terminal and press <small>RETURN</small>:</p>

<pre id="pre-38"><code><b>/bin/bash -c "$(curl -fsSL </b><b>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</b></code></pre>

<p class="TX">This command uses a program called cURL, which I’ll discuss later in this chapter, to download a shell script from GitHub. It then runs that script using the bash shell. The script itself uses <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>, meaning that if you enter your password, it will run commands as root on your computer.</p>

<p class="TX">This is what the output looks like on my Mac:</p>

<pre id="pre-39"><code>==&gt; Checking for 'sudo' access (which may request your password)...

Password:</code></pre>

<p class="TX">Enter the password you use to log in to your Mac and press <small>RETURN</small> to change your status from unprivileged user to root. No characters will appear in the terminal while you’re typing.</p>

<p class="TX">After you enter your password, Homebrew should show you a list of paths for files that it will install. The output should end with the following message:</p>

<pre id="pre-40"><code>Press RETURN to continue or any other key to abort:</code></pre>

<p class="TX">Press <small>RETURN</small> and wait for Homebrew to finish installing. If any problems arise, Homebrew will fail and show you an error message.</p>

<p class="Warning"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp></span></p>

<p class="NOTE-TXT"><i>Copying and pasting commands into your terminal can be dangerous: if a hacker tricks you into running the wrong shell script, they could hack your computer. Copy and paste commands in your terminal only from sources you trust.</i></p>

<p class="TX">Now that you’ve installed Homebrew, you have access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">brew</samp> command, which you can use to install more software. To check whether Homebrew has a certain program available to install, run:</p>

<pre id="pre-41"><code><b>brew search</b> <b><var>program_name</var></b></code></pre>

<p class="TX">For example, Neofetch is a CLI program that displays information about your computer. To see if it’s available in Homebrew, run:</p>

<pre id="pre-42"><code><b>brew search neofetch</b></code></pre>

<p class="TX">The output should list the packages that have <i>neofetch</i> in their names or descriptions; in this case, Neofetch should be listed. Similarly combine <span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label=" Page 73. "/><samp class="SANS_TheSansMonoCd_W5Regular_11">brew search</samp> with other program names to check whether they’re available to install.</p>

<p class="TX">When you find a package you want to install, run:</p>

<pre id="pre-43"><code><b>brew install</b> <b><var>program_name</var></b></code></pre>

<p class="TX">For example, to install Neofetch, run:</p>

<pre id="pre-44"><code><b>brew install neofetch</b></code></pre>

<p class="TX">This should download and install the <samp class="SANS_TheSansMonoCd_W5Regular_11">neofetch</samp> tool. Try running it:</p>

<pre id="pre-45"><code><b>neofetch</b></code></pre>

<p class="TX"><a href="#fig3-5">Figure 3-5</a> shows Neofetch running on my Mac. The figure is black-and-white in print, but if you run the command on your computer, you should see a rainbow of colors.</p>
<figure class="IMG"><img class="img100" id="fig3-5" src="Images/Figure3-5.png" alt="A screenshot of a terminal running Neofetch in macOS. It shows a rainbow-colored Apple logo made out of text characters." width="696" height="453"/>

<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: Running Neofetch on my Mac</samp></p></figcaption>

</figure>

<p class="TX">Uninstall programs with the <samp class="SANS_TheSansMonoCd_W5Regular_11">brew uninstall</samp> command. For example, run the following to uninstall Neofetch:</p>

<pre id="pre-46"><code><b>brew uninstall neofetch</b></code></pre>

<p class="TX">To update all programs you’ve installed with Homebrew to their latest versions, run:</p>

<pre id="pre-47"><code><b>brew upgrade --greedy</b></code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label=" Page 74. "/>Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew help</samp> to see some examples of how to use this command.</p>

<p class="TX">Now that you have a package manager installed, you’ll practice using the command line in Exercise 3-4.</p>

</section>

<section epub:type="division" aria-labelledby="sec24">

<h3 class="H1F" id="sec24"><span id="h-69"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3-3: Manage Packages with apt on Windows or Linux</samp></h3>

<p class="TNI">You must run most apt commands as root. Before installing or updating software, make sure your operating system has an up-to-date list of available software by opening a terminal and running the following:</p>

<pre id="pre-48"><code><b>sudo apt update</b></code></pre>

<p class="TX">When I run that command on my Linux computer, I get this output:</p>

<pre id="pre-49"><code>Hit:1 http://us.archive.ubuntu.com/ubuntu jammy InRelease

Hit:2 http://security.ubuntu.com/ubuntu jammy-security InRelease

Hit:3 http://us.archive.ubuntu.com/ubuntu jammy-updates InRelease

Hit:4 http://us.archive.ubuntu.com/ubuntu jammy-backports InRelease

Reading package lists... Done

Building dependency tree... Done

Reading state information... Done

178 packages can be upgraded. Run 'apt list --upgradable' to see them.</code></pre>

<p class="TX">This tells me I have 178 packages that can be upgraded. Run the following to upgrade your own software:</p>

<pre id="pre-50"><code><b>sudo apt upgrade</b></code></pre>

<p class="TX">Here’s the output when I run that command:</p>

<pre id="pre-51"><code>Reading package lists... Done

Building dependency tree... Done

Reading state information... Done

Calculating upgrade... Done

The following packages will be upgraded:

<var>--snip--</var>

178 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.

64 standard security updates

Need to get 365 MB of archives.

After this operation, 2,455 kB of additional disk space will be used.

Do you want to continue? [Y/n]</code></pre>

<p class="TX">Type Y and press <small>ENTER</small> to install the updates.</p>

<p class="TX">You’re now ready to install new software. To check whether the package manager has a certain program available to install, run:</p>

<pre id="pre-52"><code><b>apt search </b><b><var>program_name</var></b></code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label=" Page 75. "/>You don’t need to use <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp> with this search command because it’s not installing or uninstalling anything. However, once you find a package you want to install, run:</p>

<pre id="pre-53"><code><b>sudo apt install </b><b><var>program_name</var></b></code></pre>

<p class="TX">For example, Neofetch is a CLI program that displays information about your computer. To see if Neofetch is available in your package manager, run:</p>

<pre id="pre-54"><code><b>apt search neofetch</b></code></pre>

<p class="TX">The output should show a list of packages that have <i>neofetch</i> in their names or descriptions; in this case, Neofetch should be listed.</p>

<p class="TX">To install the <samp class="SANS_TheSansMonoCd_W5Regular_11">Neofetch</samp> tool, run:</p>

<pre id="pre-55"><code><b>sudo apt install neofetch</b></code></pre>

<p class="TX">You should see a list of packages that you must install in order to use Neofetch. Press Y and then <small>ENTER</small> to download and install them all.</p>

<p class="TX">Once installation is complete, try running Neofetch:</p>

<pre id="pre-56"><code><b>neofetch</b></code></pre>

<p class="TX"><a href="#fig3-6">Figure 3-6</a> shows Neofetch running on my Ubuntu computer. The figure is black-and-white in print, but if you run the command on your computer, the output should appear in several different colors.</p>
<figure class="IMG"><img class="img100" id="fig3-6" src="Images/Figure3-6.png" alt="A screenshot of a terminal running Neofetch in Ubuntu. It shows a red and black Ubuntu logo made out of text characters." width="696" height="474"/>

<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: Running Neofetch on my Ubuntu computer</samp></p></figcaption>

</figure>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label=" Page 76. "/>Uninstall packages with the <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo apt remove</samp> command. For example, to uninstall Neofetch, run:</p>

<pre id="pre-57"><code><b>sudo apt remove neofetch</b></code></pre>

<p class="TX">Now that you have a package manager installed, you’ll practice using the command line in Exercise 3-4.</p>

</section>

<section epub:type="division" aria-labelledby="sec25">

<h3 class="H1F" id="sec25"><span id="h-70"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3-4: Practice Using the Command Line with</samp> <samp class="SANS_Futura_Std_Heavy_B_21">cURL</samp></h3>

<p class="TNI">In this exercise, you’ll learn how to determine whether you have a command installed, download web pages, save the output from a file using redirection, and view the contents of files directly from the terminal.</p>

<p class="TX">The cURL program is a common way to load web pages from the command line. To load all of the HTML code for the website <a href="https://www.torproject.org"><i>https://<wbr/>www<wbr/>.torproject<wbr/>.org</i></a>, for example, run the following command:</p>

<pre id="pre-58"><code><b>curl </b><b>https://www.torproject.org</b></code></pre>

<p class="TX">To see if cURL is installed, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">which</samp> command:</p>

<pre id="pre-59"><code><b>which curl</b></code></pre>

<p class="TX">If cURL is installed, the output should show you the path where the program is installed on your computer (something like <i>/usr/bin/curl</i>). If not, the output should return you to the shell prompt.</p>

<p class="TX">If you don’t have cURL, use your package manager to install it. Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo apt install curl</samp> for Windows with WSL and Linux machines or <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install curl</samp> for Macs. Then run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">which curl</samp> again, and you should see the path to the cURL program.</p>

<section epub:type="division" aria-labelledby="sec26">

<h4 class="H2" id="sec26"><span id="h-71"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Download a Web Page with cURL</samp></h4>

<p class="TNI">When you load a web page, your web browser renders a human-readable version of its content based on the page’s HTML, CSS, and JavaScript code. To see the raw HTML content from the web page hosted at <i>https://<wbr/>example<wbr/>.com</i>, run the following command in your terminal:</p>

<pre id="pre-60"><code><b>curl example.com</b></code></pre>

<p class="TX">If you load that site in a browser and then view the HTML source by pressing <small>CTRL</small>-U in Windows or Linux, or <span class="greek_wingdings">z</span>-U in macOS, you should see the same HTML code that this command displays in your terminal.</p>

<p class="TX">Some websites are designed to show you text that’s easy to read in a terminal when you access them through cURL, as opposed to showing you HTML. For example, <a href="https://ifconfig.co"><i>https://<wbr/>ifconfig<wbr/>.co</i></a> will tell you your IP address, geolocate <span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label=" Page 77. "/>it, and tell you what country and city it thinks you’re in. Try running the following command:</p>

<pre id="pre-61"><code><b>curl </b><b>https://ifconfig.co</b></code></pre>

<p class="TX">This should display your IP address. Next, run the following:</p>

<pre id="pre-62"><code><b>curl </b><b>https://ifconfig.co/country</b></code></pre>

<p class="TX">When I run this command, my output is <samp class="SANS_TheSansMonoCd_W5Regular_11">United States</samp>. You can try connecting to a VPN server in another country and then run it again; it should detect your web traffic as coming from that other country.</p>

</section>

<section epub:type="division" aria-labelledby="sec27">

<h4 class="H2" id="sec27"><span id="h-72"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Save a Web Page to a File</samp></h4>

<p class="TNI">Run the following commands to load <i>https://<wbr/>example<wbr/>.com</i> and save it to a file:</p>

<pre id="pre-63"><code><b>cd /tmp</b>

<b>curl </b><b>https://example.com</b><b> &gt; example.html</b></code></pre>

<p class="TX">The first line of code changes your working directory to <i>/tmp</i>, a temporary folder where files you store get deleted automatically. The second line loads <i>https://<wbr/>example<wbr/>.com</i>, but instead of displaying the site’s contents for you in the terminal, it redirects them into the file <i>example.html</i> and doesn’t display anything in the terminal.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp> character takes the output of the command to its left and saves it into the filename to its right. This is called <i>redirection</i>. Since you changed to the <i>/tmp</i> folder before running the <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> command and the filename you provided was a relative path, it saved to the file <i>/tmp/example.html</i>.</p>

<p class="TX">Run a directory listing to make sure you’ve stored the file correctly:</p>

<pre id="pre-64"><code><b>ls -lh</b></code></pre>

<p class="TX">This should list all the files in <i>/tmp</i>, which should include a file called <i>example.html</i>. Try displaying the contents of that file in your terminal using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command:</p>

<pre id="pre-65"><code><b>cat /tmp/example.html</b></code></pre>

<p class="TX">The terminal isn’t always a good place to view a file’s contents. For example, long lines will wrap, which may make them difficult to comprehend. In the following section, you’ll learn more about the different types of files and how to work with them more easily in the command line.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec28">

<h3 class="H1" id="sec28"><span id="h-73"/><samp class="SANS_Futura_Std_Bold_B_11">Text Files vs. Binary Files</samp></h3>

<p class="TNI">There are many different types of files, but they all fit into one of two categories: <i>text files</i> and <i>binary files</i>.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label=" Page 78. "/>Text files are made up of letters, numbers, punctuation, and a few special characters. Source code, like Python scripts (discussed in <span class="Xref"><a href="chapter7.xhtml">Chapters 7</a></span> and <span class="Xref"><a href="chapter8.xhtml">8</a></span>); shell scripts; and HTML, CSS, and JavaScript files are all examples of text files. Spreadsheets in CSV (comma-separated value) format and JSON files (discussed in <span class="Xref"><a href="chapter9.xhtml">Chapters 9</a></span> and <span class="Xref"><a href="chapter11.xhtml">11</a></span>, respectively) are also text files. These files are relatively simple to work with. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command to display text files, as you did in the previous exercise.</p>

<p class="TX">Binary files are made up of data that’s more than just letters, numbers, and punctuation. They’re designed for computer programs, not humans, to understand. If you try to view the contents of a binary file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command, you’ll just see gibberish. Instead, you must use specialized programs that understand those binary formats. Office documents like PDFs, Word documents, and Excel spreadsheets are binary files, as are images (like PNG and JPEG files), videos (like MP4 and MOV files), and compressed data like ZIP files.</p>
<blockquote>

<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>

<p class="NOTE-TXT"><i>The term</i> <span class="note_Italic">binary file</span> <i>is technically a misnomer, because all files are represented by computers as binary—strings of ones and zeros.</i></p>

<p class="TX">Text files aren’t always easy to understand (if you’re not familiar with HTML, viewing it might look like gibberish), but it’s at least possible to display them in a terminal. This isn’t true for binary files. For example, if you try using <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> to display the contents of binary files like PNG images in your terminal, the output will look something like this:</p>

<pre id="pre-66"><code>?PNG



IHDR?L??

?D?ؐ???? Pd@?????Y????????u???+?2???ע???@?!N???? ^?K??Eׂ?(??U?N????E??ł??.?ʛ?u_??|?????g?s?ܙ{?@;?

?sQ

 ?x?)b?hK'?/??L???t?+???eC????+?@????L??????/@c@웗7?qĶ?F

                                                        ?L????N??4Ӈ4???!?????

<var>--snip--</var></code></pre>

<p class="TX">Your terminal can’t display all of the characters that make up PNG images, so those characters just don’t get displayed. If you want to see the information stored in a PNG, you need to open it in software that’s designed to view images.</p>

<p class="TX">To work with the files in datasets or write shell scripts and Python code, you’ll need a <i>text editor</i>, a program designed to edit text files. You’ll install a text editor in Exercise 3-5 to prepare for writing your first shell script.</p>

</section>

<section epub:type="division" aria-labelledby="sec29">

<h3 class="H1F" id="sec29"><span id="h-74"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3-5: Install the VS Code Text Editor</samp></h3>

<p class="TNI">In this exercise, you’ll download the free and open source text editor Visual Studio Code (VS Code) and practice using it to view a file. Download VS Code from <a href="https://code.visualstudio.com"><i>https://<wbr/>code<wbr/>.visualstudio<wbr/>.com</i></a> and install it. (If you’re already familiar with another text editor, feel free to keep using that one instead.)</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_79" aria-label=" Page 79. "/>VS Code comes with a command called <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp> that makes it easy to open files in VS Code directly from your terminal. Once VS Code is finished installing, run the following commands:</p>

<pre id="pre-67"><code><b>curl </b><b>https://example.com</b><b> &gt; /tmp/example.html</b>

<b>code /tmp/example.html</b></code></pre>

<p class="TX">The first line of code saves the HTML from <i>https://<wbr/>example<wbr/>.com</i> in the file <i>/tmp/example.html</i>, just like you did in Exercise 3-4. The second line opens this file in VS Code.</p>

<p class="TX">When you open new files and folders in VS Code, it asks whether you trust each file’s author, giving you the option to open the file in Restricted Mode. For the exercises in this book, you can open files without using Restricted Mode.</p>

<p class="TX">When you open <i>example.html</i>, it should look something like this:</p>

<pre id="pre-68"><code>&lt;!doctype html&gt;

&lt;html&gt;

&lt;head&gt;

    &lt;title&gt;Example Domain&lt;/title&gt;



    &lt;meta charset="utf-8" /&gt;

    &lt;meta http-equiv=”Content-type" content="text/html; charset=utf-8" /&gt;

    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;

    &lt;style type="text/css"&gt;

    body {

        background-color: #f0f0f2;

        margin: 0;

        padding: 0;

        font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", "Open Sans",

"Helvetica Neue", Helvetica, Arial, sans-serif;



    }

<var>--snip--</var></code></pre>

<p class="TX">The output shows the same HTML code that you saw in your terminal when you ran <samp class="SANS_TheSansMonoCd_W5Regular_11">cat/tmp/example.html</samp> in Exercise 3-4, but this time it should be much easier to read. VS Code and many other text editors have a feature called <i>syntax highlighting</i>, where different parts of the file appear in different colors. This makes it far quicker and easier for your brain to interpret source code, and also for you to catch mistakes in syntax.</p>

<p class="TX">VS Code is highly customizable and includes a wide variety of extensions that add extra functionality and make the program more pleasant to use. When you open new types of files, for instance, VS Code might ask if you’d like to install extensions to better support those files.</p>
<blockquote>

<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>

<p class="NOTE-TXT"><i>To learn more about VS Code’s other features, including when to use Restricted Mode, check out the documentation at</i> <a href="https://code.visualstudio.com/docs"><span class="note_LinkURL">https://code.visualstudio.com/docs</span></a><i>.</i></p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_80" aria-label=" Page 80. "/>Now that you have some experience running commands in a shell and have set up a text editor, you’ll write your first shell script in Exercise 3-6.</p>

</section>

<section epub:type="division" aria-labelledby="sec30">

<h3 class="H1F" id="sec30"><span id="h-75"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3-6: Write Your First Shell Script</samp></h3>

<p class="TNI">As mentioned earlier, a shell script is a text file that contains a list of shell commands. When you tell your shell to run the script, it runs those commands one at a time. Many commands are themselves shell scripts, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">man</samp> command you used earlier in this chapter.</p>

<section epub:type="division" aria-labelledby="sec31">

<h4 class="H2" id="sec31"><span id="h-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Navigate to Your USB Disk</samp></h4>

<p class="TNI">Make sure your <i>datasets</i> USB disk is plugged in and mounted, and open up a terminal. To change your working directory to the <i>datasets</i> disk, skip to the subsection for your operating system.</p>

<section epub:type="division" aria-labelledby="sec32">

<h5 class="H3" id="sec32"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Windows</samp></h5>

<p class="TNI">After mounting your USB disk, open File Explorer by clicking <b>This PC</b> on the left. This page will show all of your connected drives and their drive letters. Note your USB disk’s drive letter, then change your working directory to the disk by running the following command, substituting <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">d</samp> for the correct drive letter:</p>

<pre id="pre-69"><code><b>cd /mnt/</b><b><var>d</var></b><b>/</b></code></pre>

<p class="TX">Your shell’s working directory should now be your <i>datasets</i> USB disk. To check, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp> to view the files on this disk.</p>

</section>

<section epub:type="division" aria-labelledby="sec33">

<h5 class="H3" id="sec33"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">macOS</samp></h5>

<p class="TNI">After mounting your <i>datasets</i> USB disk, open a terminal and change your working directory to the disk by running the following command:</p>

<pre id="pre-70"><code><b>cd /Volumes/datasets</b></code></pre>

<p class="TX">Your shell’s working directory should now be your <i>datasets</i> USB disk. To check, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp> to view the files on this disk.</p>

</section>

<section epub:type="division" aria-labelledby="sec34">

<h5 class="H3" id="sec34"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Linux</samp></h5>

<p class="TNI">After mounting your <i>datasets</i> USB disk, open a terminal and change your working directory to the disk. In Linux, the path to your disk is probably something like <i>/media/</i><span class="symbol_Italic">&lt;</span><i>username</i><span class="symbol_Italic">&gt;</span><i>/datasets</i>. For example, my username is <i>micah</i>, so I would run this command:</p>

<pre id="pre-71"><code>cd /media/micah/datasets</code></pre>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_81" aria-label=" Page 81. "/>Your shell’s working directory should now be your <i>datasets</i> USB disk. To check, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp> to view the files on this disk.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec35">

<h4 class="H2" id="sec35"><span id="h-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create an Exercises Folder</samp></h4>

<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">mkdir</samp> command creates a new folder. Now that you’re in your USB disk drive in your terminal, run the following commands to create a new folder called <i>exercises</i>, and then switch to it:</p>

<pre id="pre-72"><code><b>mkdir exercises</b>

<b>cd exercises</b></code></pre>

<p class="TX">Now make a folder for your <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> exercises:</p>

<pre id="pre-73"><code><b>mkdir chapter-3</b></code></pre>

<p class="TX">Next, you’ll open the <i>exercises</i> folder in VS Code.</p>

</section>

<section epub:type="division" aria-labelledby="sec36">

<h4 class="H2" id="sec36"><span id="h-78"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Open a VS Code Workspace</samp></h4>

<p class="TNI">Each VS Code window is called a <i>workspace</i>. You can add folders to your workspace, which allows you to easily open any files in that folder or create new ones. To open a VS Code workspace for your <i>exercises</i> folder, run the following command:</p>

<pre id="pre-74"><code><b>code .</b></code></pre>

<p class="TX">If the argument that you pass into <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp> is a folder, like <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> (the current working directory), VS Code will add that folder to your workspace. If the path is a file, like in Exercise 3-5 when you opened <i>/tmp/example.html</i>, it will open just that file.</p>

<p class="TX">Next, create a new file in the <i>chapter-3</i> folder. To do this, right-click the <i>chapter-3</i> folder, choose <b>New File</b>, name your file <i>exercise-3-6.sh</i>, and press <small>ENTER</small>. This should create a new file that you can edit. Since the file extension is <i>.sh</i>, VS Code should correctly guess that it’s a shell script and use the right type of syntax highlighting.</p>

<p class="TX"><a href="#fig3-7">Figure 3-7</a> shows a VS Code workspace with the <i>exercises</i> folder added and the empty file <i>exercise-3-6.sh</i> created.</p>

<p class="TX">The VS Code window is split into two main parts. The Explorer panel on the left shows the contents of all of the folders added to your workspace. In this case, it shows <i>exercises</i> and everything it contains: a <i>chapter-3</i> folder and the <i>exercise-3-6.sh</i> file you just created. The right side of the window is the editor, where you’ll enter your shell script.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_82" aria-label=" Page 82. "/>

<figure class="IMG"><img class="img100" id="fig3-7" src="Images/Figure3-7.png" alt="The Explorer panel on the left shows the exercises folder, and the editor on the right shows the content of exercise-3-6.sh, which is an empty text file." width="684" height="418"/>

<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: VS Code with the</samp> <samp class="SANS_Futura_Std_Book_11">exercises</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">folder open in a workspace</samp></p></figcaption>

</figure>
</section>

<section epub:type="division" aria-labelledby="sec37">

<h4 class="H2" id="sec37"><span id="h-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Write the Shell Script</samp></h4>

<p class="TNI">Enter the following text into <i>exercise-3-6.sh</i> in VS Code and save the file:</p>

<pre id="pre-75"><code>#!/bin/bash

echo "Hello world! This is my first shell script."

# Display the current user

echo "The current user is:"

whoami

# Display the current working directory

echo "The current working directory is:"

pwd</code></pre>

<p class="TX">The first line that starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">#!</samp> is called the <i>shebang</i>, and it tells the shell which <i>interpreter</i>—the program that opens and runs the script—to use. In this case, the shell will use <samp class="SANS_TheSansMonoCd_W5Regular_11">/bin/bash</samp>, meaning you’re writing a bash script. In this book, you’ll add that same shebang to the top of all of your shell scripts. Even if you’re working from a shell besides bash, this shebang tells your computer to run the current script using bash.</p>

<p class="TX">In shell scripts, lines that start with the hash character (<samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>) are called <i>comments</i>, and they don’t affect how the code itself works; if you removed the comments from this script, it would run the same way. The first character of the shebang is a hash character, which means that it’s technically a comment in bash and zsh.</p>

<p class="TX">Comments like <samp class="SANS_TheSansMonoCd_W5Regular_11"># Display the current user</samp> work as notes to remind you what your code does when you come back to a script you wrote months or years earlier. Anyone else who works with your code, perhaps trying to fix something or add features, will appreciate your comments for the same reason.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_83" aria-label=" Page 83. "/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp> command displays text to the terminal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">whoami</samp> command displays the name of the user running the script. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pwd</samp> command displays the current working directory.</p>

</section>

<section epub:type="division" aria-labelledby="sec38">

<h4 class="H2" id="sec38"><span id="h-80"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Run the Shell Script</samp></h4>

<p class="TNI">Before you can run a script, you need to make it <i>executable</i> by giving it permission to run as a program. The <samp class="SANS_TheSansMonoCd_W5Regular_11">chmod</samp> command lets you change permissions on files with the following syntax:</p>

<pre id="pre-76"><code><b>chmod</b> <b><var>permissions filename</var></b></code></pre>

<p class="TX">To mark a file as executable, use <samp class="SANS_TheSansMonoCd_W5Regular_11">+x</samp> as the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">permissions</samp> argument. Run the following command in your terminal (from within your <i>exercises</i> folder):</p>

<pre id="pre-77"><code><b>chmod +x ./chapter-3/exercise-3-6.sh</b></code></pre>

<p class="TX">You can now run the script by entering either its absolute path or its relative path:</p>

<pre id="pre-78"><code><b>./chapter-3/exercise-3-6.sh</b></code></pre>

<p class="TX">Starting your command with <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp> tells your shell that you’re entering the relative path to a script.</p>

<p class="TX">Here’s the output I get when I run this script on my Mac:</p>

<pre id="pre-79"><code>Hello world! This is my first shell script.

The current user is:

micah

The current working directory is:

/Volumes/datasets/exercises</code></pre>

<p class="TX">The current user is <i>micah</i> and the current working directory is <i>/Volumes/datasets/exercises</i>.</p>

<p class="TX">This script shows you different output depending on your working directory. To demonstrate the differences, here’s what happens when I switch to my home folder and then run it again:</p>

<pre id="pre-80"><code>micah@trapdoor exercises % <b>cd ~</b>

micah@trapdoor ~ % <b>/Volumes/datasets/exercises/chapter-3/exercise-3-6.sh</b>

Hello world! This is my first shell script.

The current user is:

micah

The current working directory is:

/Users/micah</code></pre>

<p class="TX">This time, the current working directory in the output has changed to <i>/Users/micah</i>. Try switching to your own home folder with <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cd ~</samp> and running the script again.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_84" aria-label=" Page 84. "/>The script also shows different output depending on which user is running it. So far I’ve been running it as <i>micah</i>, but here’s what the output looks like when I run it as root:</p>

<pre id="pre-81"><code>micah@trapdoor ~ % <b>sudo /Volumes/datasets/exercises/chapter-3/exercise-3-6.sh</b>

Password:

Hello world! This is my first shell script.

The current user is:

root

The current working directory is:

/Users/micah</code></pre>

<p class="TX">This time, the output lists the current user as <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp>. Try running the script as root on your own computer.</p>

<p class="TX">You’ll write many more scripts throughout this book. I’ve included a copy of the code for every exercise in this book’s online resources. In Exercise 3-7, you’ll download a copy of all of this code.</p>

</section>
</section>

<section epub:type="division" aria-labelledby="sec39">

<h3 class="H1F" id="sec39"><span id="h-81"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 3-7: Clone the Book’s GitHub Repository</samp></h3>

<p class="TNI">Programmers store source code in <i>git repositories</i> (or <i>git repos</i> for short), which are composed of a collection of files (usually source code) and the history of how they have changed over time. By storing your scripts this way, you can host them on GitHub, a popular website for hosting git repos. Git repos help you share your code with others, and they make it easier for multiple people to write code for the same project. When you <i>clone</i> a git repo, you download a copy of it to your computer.</p>

<p class="TX">This book comes with a git repo at <a href="https://github.com/micahflee/hacks-leaks-and-revelations"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations</i></a> containing the code for every exercise and case study in this book, along with additional instructions and source code related to the book’s appendixes. In this exercise, you’ll clone this repo and store the copy locally on your computer.</p>

<p class="TX">First, check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">git</samp> program is installed on your machine:</p>

<pre id="pre-82"><code><b>which git</b></code></pre>

<p class="TX">If git is installed, you’ll see its path in the output, like <i>/usr/bin/git</i>. If it’s not installed, this command won’t display anything in the terminal. In that case, install git by entering the appropriate command for your operating system: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install git</samp> for macOS users, or <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo apt install git</samp> for Linux and WSL users.</p>

<p class="TX">Next, in your terminal, change to your USB disk folder. On my macOS computer, I do this with the following command:</p>

<pre id="pre-83"><code>cd<b> </b><var>/Volumes/datasets</var></code></pre>

<p class="TX">If necessary, replace the path in my command with the appropriate path to your <i>datasets</i> USB disk for your operating system.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_85" aria-label=" Page 85. "/>Once you’re in the <i>datasets</i> disk, run this command to clone the repo:</p>

<pre id="pre-84"><code><b>git clone </b><b>https://github.com/micahflee/hacks-leaks-and-revelations.git</b></code></pre>

<p class="TX">This should create a new folder called <i>hacks-leaks-and-revelations</i> containing all of the code from the book’s repo.</p>

<p class="TX">Finally, add the book’s git repo folder to your VS Code workspace. In VS Code, click <b>File</b><span class="MenuArrow">▸</span><b>Add Folder to Workspace</b>, then browse for the <i>hacks-leaks-and-revelations</i> folder on your USB disk. This will add the book’s code to your VS Code workspace so you can easily browse through all of the files.</p>

<p class="TX">You now have access to solutions for all future exercises! In the following chapters, I’ll walk you through the process of writing your own scripts from scratch, but you can also run the complete scripts taken from the git repo or copy and paste their code into your own code.</p>

</section>

<section epub:type="division" aria-labelledby="sec40">

<h3 class="H1" id="sec40"><span id="h-82"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>

<p class="TNI">In this chapter, you’ve learned the basics of command line theory, including how to use the shell in a terminal, run various shell commands, and navigate the shell using features like tab completion. You installed software directly in the terminal using a package manager, and you wrote your first simple shell script.</p>

<p class="TX">In the next chapters, you’ll put these techniques into practice to explore hundreds of gigabytes of data, make datasets searchable, convert email from a proprietary format to an open format, and write Python code. You’ll start in the following chapter by taking a deeper dive into the BlueLeaks dataset.</p>

</section>
</section>

</div></body></html>