- en: INTRODUCTION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Containers and Kubernetes together are changing the way that applications are
    architected, developed, and deployed. Containers ensure that software runs reliably
    no matter where it’s deployed, and Kubernetes lets you manage all of your containers
    from a single control plane.
  prefs: []
  type: TYPE_NORMAL
- en: This book is designed to help you take full advantage of these essential new
    technologies, using hands-on examples not only to try out the major features but
    also to explore how each feature works. In this way, beyond simply being ready
    to deploy an application to Kubernetes, you’ll gain the skills to architect applications
    to be performant and reliable in a Kubernetes cluster, and to quickly diagnose
    problems when they arise.
  prefs: []
  type: TYPE_NORMAL
- en: The Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest advantage of a Kubernetes cluster is that it hides the work of running
    containers across multiple hosts behind an abstraction layer. A Kubernetes cluster
    is a “black box” that runs what we tell it to run, with automatic scaling, failover,
    and upgrades to new versions of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this abstraction makes it easier to deploy and manage applications,
    it also makes it difficult to understand what a cluster is doing. For this reason,
    this book presents each feature of container runtimes and Kubernetes clusters
    from a “debugging” perspective. Every good debugging session starts by treating
    the application as a black box and observing its behavior, but it doesn’t end
    there. Skilled problem solvers know how to open the black box, diving below the
    current abstraction layer to see how the program runs, how data is stored, and
    how traffic flows across the network. Skilled architects use this deep knowledge
    of a system to avoid performance and reliability issues. This book provides the
    detailed understanding of containers and Kubernetes that only comes from exploring
    not only what these technologies do but also how they work.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part I](part01.xhtml#part01), we’ll begin by running a container, but then
    we’ll dive into the container runtime to understand what a container is and how
    we can simulate a container using normal operating system commands. In [Part II](part02.xhtml#part02),
    we’ll install a Kubernetes cluster and deploy containers to it. We’ll also see
    how the cluster works, including how it interacts with the container runtime and
    how packets flow from container to container across the host network. The purpose
    is not to duplicate the reference documentation to show every option offered by
    every feature but to demonstrate how each feature is implemented so that all that
    documentation will make sense and be useful.
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster is complicated, so this book includes extensive hands-on
    examples, with enough automation to allow you to explore each chapter independently.
    This automation, which is available at *[https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples)*,
    is published under a permissive open source license, so you can explore, experiment,
    and use it in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Running Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many of this book’s example exercises, you’ll be combining multiple hosts
    together to make a cluster, or working with low-level features of the Linux kernel.
    For this reason, and to help you feel more comfortable with experimentation, you’ll
    be running examples entirely on temporary virtual machines. That way, if you make
    a mistake, you can quickly delete the virtual machine and start over.
  prefs: []
  type: TYPE_NORMAL
- en: The example repository for this book is available at *[https://github.com/book-of-kubernetes/examples](https://github.com/book-of-kubernetes/examples)*.
    All of the instructions for setting up to run examples are provided in a *README.md*
    file within the *setup* folder of the example repository.
  prefs: []
  type: TYPE_NORMAL
- en: What You Will Need
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though you’ll be working in virtual machines, you’ll need a control machine
    to start from that can run Windows, macOS, or Linux. It can even be a Chromebook
    that supports Linux. If you are running Windows, you’ll need to use the Windows
    Subsystem for Linux (WSL) in order to get Ansible working. See the *README.md*
    in the *setup* folder for instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Run in the Cloud or Local
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make these examples as accessible as possible, I’ve provided automation to
    run them either using Vagrant or Amazon Web Services (AWS). If you have access
    to a Windows, macOS, or Linux computer with at least eight cores and 8GB of memory,
    try installing VirtualBox and Vagrant and work with local virtual machines. If
    not, you can set yourself up to work with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: We use Ansible to perform AWS setup and automate some of the tedious steps.
    Each chapter includes a separate Ansible playbook that makes use of common roles
    and collections. This means that you can work examples from chapter to chapter,
    starting with a fresh installation each time. In some cases, I’ve also provided
    an “extra” provisioning playbook that you can optionally use to skip some of the
    detailed installation steps and get straight to the learning. See the *README.md*
    in each chapter’s directory for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After you’ve used Ansible to provision your virtual machines, you’ll need to
    get at least one terminal window connected to run commands. The *README.md* file
    in each chapter will tell you how to do that. Before running any examples, you’ll
    first need to become the root user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will give you a root shell and set up your environment and home directory
    to match.
  prefs: []
  type: TYPE_NORMAL
- en: '**RUNNING AS ROOT**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve worked with Linux before, you probably have a healthy aversion to
    working as root on a regular basis, so it might surprise you that all of the examples
    in this book are run as the root user. This is a big advantage of using temporary
    virtual machines and containers; when we act as the root user, we are doing so
    in a temporary, confined space that can’t reach out and affect anything else.
  prefs: []
  type: TYPE_NORMAL
- en: As you move from learning about containers and Kubernetes to running applications
    in production, you’ll be applying security controls to your cluster that will
    limit administrative access and will ensure that containers cannot break out of
    their isolated environment. This often includes configuring your containers so
    that they run as a non-root user.
  prefs: []
  type: TYPE_NORMAL
- en: In some examples, you’ll need to open multiple terminal windows in order to
    leave one process running while you inspect it from another terminal. How you
    do that is up to you; most terminal applications support multiple tabs or multiple
    windows. If you need a way to open multiple terminals within a single tab, try
    exploring a terminal multiplexer application. All of the temporary virtual machines
    used in the examples come with both `screen` and `tmux` installed and ready to
    use.
  prefs: []
  type: TYPE_NORMAL
