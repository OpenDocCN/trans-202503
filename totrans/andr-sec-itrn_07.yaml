- en: Chapter 7. Credential Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 凭证存储
- en: The previous chapter introduced PKI and the challenges involved in managing
    trust. While the most prevalent use of PKI is for authenticating the entity you
    connect to (*server authentication*), it’s also used to authenticate you to those
    entities (*client authentication*). Client authentication is mostly found in enterprise
    environments, where it is used for everything from desktop logon to remotely accessing
    company servers. PKI-based client authentication requires the client to prove
    that it possesses an authentication key (typically an RSA private key) by performing
    certain cryptographic operations that the server can verify independently. Therefore,
    the security of client authentication relies heavily on protecting authentication
    keys from unauthorized use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了公钥基础设施（PKI）及其在管理信任过程中遇到的挑战。PKI 最常见的用途是认证你连接的实体（*服务器认证*），但它也用于认证你自己给这些实体（*客户端认证*）。客户端认证主要出现在企业环境中，用于从桌面登录到远程访问公司服务器等各种场景。基于
    PKI 的客户端认证要求客户端通过执行一些加密操作来证明其拥有认证密钥（通常是 RSA 私钥），服务器可以独立验证这些操作。因此，客户端认证的安全性在很大程度上依赖于防止未经授权的使用认证密钥。
- en: Most operating systems provide a system service that applications can use to
    securely store and access authentication keys without having to implement key
    protection themselves. Android has had such a service since version 1.6, and it
    has improved significantly since Android 4.0.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统提供系统服务，应用可以利用该服务安全地存储和访问认证密钥，而无需自己实现密钥保护。Android 自 1.6 版本起就提供了这样的服务，并且自
    Android 4.0 以来有了显著改进。
- en: Android’s credential store can be used to store credentials for built-in features
    such as Wi-Fi and VPN connectivity, as well as for third-party apps. Apps can
    access the credential store via standard SDK APIs and use it to manage their keys
    securely. Recent Android versions feature hardware-backed key storage, which provides
    enhanced key protection. This chapter discusses the architecture and implementation
    of Android’s credential store and introduces the public APIs that it provides.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的凭证存储可以用来存储内置功能的凭证，如 Wi-Fi 和 VPN 连接凭证，以及第三方应用的凭证。应用可以通过标准 SDK API 访问凭证存储，并利用它安全地管理密钥。最近的
    Android 版本引入了硬件支持的密钥存储，提供了更强的密钥保护。 本章讨论了 Android 凭证存储的架构和实现，并介绍了它提供的公共 API。
- en: VPN and Wi-Fi EAP Credentials
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VPN 和 Wi-Fi EAP 凭证
- en: '*Virtual Private Networks (VPNs)* are the preferred way to offer remote access
    to private enterprise services. We’ll discuss VPNs and related technologies in
    more detail in [Chapter 9](ch09.html "Chapter 9. Enterprise Security"), but simply
    put, a VPN allows a remote client to join a private network by creating an encrypted
    tunnel between it and a public tunnel endpoint. VPN implementations differ in
    their use of tunneling technology, but all need to authenticate the client before
    they establish a secure connection. While some VPNs use a shared key or password
    for authentication, enterprise solutions often rely on PKI-based client authentication.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟专用网络 (VPN)* 是提供远程访问私有企业服务的首选方式。我们将在[第 9 章](ch09.html "第 9 章. 企业安全")中更详细地讨论
    VPN 及相关技术，但简单来说，VPN 通过在远程客户端和公共隧道端点之间创建加密隧道，使远程客户端能够加入私有网络。VPN 的实现方式在隧道技术的使用上有所不同，但在建立安全连接之前，所有
    VPN 都需要验证客户端身份。虽然某些 VPN 使用共享密钥或密码进行认证，但企业解决方案通常依赖基于公钥基础设施（PKI）的客户端认证。'
- en: '*Extensible Authentication Protocol (EAP)* is an authentication framework frequently
    used in wireless networks and point-to-point (P2P) connections. (EAP is discussed
    in more detail in [Chapter 9](ch09.html "Chapter 9. Enterprise Security").) Like
    VPN, EAP can use many different authentication methods, but EAP-Transport Layer
    Security (EAP-TLS) is preferred in enterprise environments, especially when a
    company PKI has already been deployed.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*可扩展认证协议 (EAP)* 是一种在无线网络和点对点（P2P）连接中常用的认证框架。（EAP 在[第 9 章](ch09.html "第 9 章.
    企业安全")中有更详细的讨论。）像 VPN 一样，EAP 可以使用多种不同的认证方法，但在企业环境中，EAP-传输层安全性 (EAP-TLS) 被首选，特别是在公司
    PKI 已经部署的情况下。'
- en: Authentication Keys and Certificates
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证密钥和证书
- en: In the case of both EAP-TLS and PKI-based VPNs, clients have an authentication
    key and are issued a matching certificate, often by the company certificate authority
    (CA). Keys are sometimes stored in a portable, tamper-resistant device such as
    a smart card or USB token. This greatly increases security because keys cannot
    be exported or extracted from the device and thus authentication requires both
    physical possession of the token and the knowledge of the associated PIN or passphrase.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EAP-TLS 和基于 PKI 的 VPN 的情况下，客户端拥有身份验证密钥，并被颁发一个匹配的证书，通常由公司证书授权中心（CA）颁发。密钥有时存储在便携式、防篡改的设备中，如智能卡或
    USB 密钥。这大大提高了安全性，因为密钥不能从设备中导出或提取，因此身份验证既需要物理持有令牌，又需要知道相关的 PIN 或密码。
- en: When the security policy allows using authentication keys that are not protected
    by a hardware device, keys and associated certificates are typically stored in
    the standard PKCS#12 file format. Private keys stored in PKCS#12 files are encrypted
    with a symmetric key derived from a user-supplied password, and thus extracting
    the keys requires knowledge of the password. Some applications use PKCS#12 files
    as secure containers and only extract keys and certificates into memory when required,
    but typically they’re imported into a system- or application-specific credential
    storage before use. This is how Android works as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当安全策略允许使用不受硬件设备保护的身份验证密钥时，密钥及其相关证书通常存储在标准的 PKCS#12 文件格式中。存储在 PKCS#12 文件中的私钥使用从用户提供的密码派生的对称密钥加密，因此提取密钥需要知道密码。有些应用程序使用
    PKCS#12 文件作为安全容器，只有在需要时才将密钥和证书提取到内存中，但通常它们会在使用之前被导入到系统或应用程序特定的凭据存储中。这也是 Android
    的工作方式。
- en: 'The user-facing implementation of importing credentials on Android is rather
    simple: to import an authentication key and related certificates, users copy their
    PKCS#12 files (and, if necessary, any related CA certificates) to the device’s
    external storage (often an SD card) and select **Install from storage** from the
    **Security** system settings screen. Android searches the root of the external
    storage for matching files (with the *.pfx* or *.p12* extensions) and presents
    an import dialog (see [Figure 7-1](ch07.html#pkcshash12_file_password_dialog "Figure 7-1. PKCS#12
    file password dialog")). If the correct password is supplied, keys are extracted
    from the PKCS#12 file and imported into the system credential store.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上导入凭据的用户界面实现相当简单：为了导入身份验证密钥和相关证书，用户将其 PKCS#12 文件（如果需要，还包括任何相关的 CA
    证书）复制到设备的外部存储（通常是 SD 卡），然后从**安全性**系统设置屏幕中选择**从存储安装**。Android 会在外部存储的根目录中搜索匹配的文件（扩展名为
    *.pfx* 或 *.p12*），并呈现一个导入对话框（参见 [图 7-1](ch07.html#pkcshash12_file_password_dialog
    "图 7-1. PKCS#12 文件密码对话框")）。如果提供了正确的密码，密钥将从 PKCS#12 文件中提取并导入到系统凭据存储中。
- en: The System Credential Store
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统凭据存储
- en: 'The system credential store is a system service that encrypts imported credentials
    before storing them on disk. The encryption key is derived from a user-supplied
    password: a dedicated credential store protection password in pre-4.0 versions,
    or the device unlock swipe pattern, PIN, or password in post-4.0 versions of Android.
    Additionally, the credential store system service regulates access to stored credentials
    and guarantees that only apps explicitly granted access can access keys.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统凭据存储是一个系统服务，在将导入的凭据存储到磁盘之前，会先对它们进行加密。加密密钥来自用户提供的密码：在 4.0 版本之前为专用的凭据存储保护密码，或者在
    4.0 版本之后为设备解锁滑动模式、PIN 或密码。此外，凭据存储系统服务还会调节对存储凭据的访问，确保只有明确被授予访问权限的应用程序才能访问密钥。
- en: The original credential store was introduced in Android 1.6 and was limited
    to storing VPN and Wi-Fi EAP credentials. Only the system—not third-party apps—could
    access stored keys and certificates. Additionally, the only supported way to import
    credentials was to go through the system settings UI outlined in the previous
    section, and no public APIs for credential store management were available.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 原始凭据存储在 Android 1.6 中引入，最初仅限于存储 VPN 和 Wi-Fi EAP 凭据。只有系统—而非第三方应用程序—能够访问存储的密钥和证书。此外，导入凭据的唯一受支持方式是通过前面部分中概述的系统设置界面进行操作，并且没有公开的凭据存储管理
    API。
- en: APIs for accessing the system credential store were first introduced in Android
    4.0\. The system credential store was later extended to support hardware-backed
    credential storage and to offer not only shared system keys, but app-private keys
    as well. [Table 7-1](ch07.html#credential_store_feature_progression "Table 7-1. Credential
    Store Feature Progression") shows a summary of the major credential store enhancements
    added in each Android version. We’ll introduce these enhancements and the related
    APIs in the following sections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 访问系统凭据存储的API首次在Android 4.0中引入。系统凭据存储后来扩展为支持硬件加速的凭据存储，并提供不仅是共享系统密钥，还有应用私有密钥。[表7-1](ch07.html#credential_store_feature_progression
    "表7-1. 凭据存储功能进展")显示了每个Android版本中添加的主要凭据存储增强功能的摘要。我们将在接下来的章节中介绍这些增强功能及相关API。
- en: '![PKCS#12 file password dialog](figs/web/07fig01.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![PKCS#12文件密码对话框](figs/web/07fig01.png.jpg)'
- en: Figure 7-1. PKCS#12 file password dialog
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1. PKCS#12文件密码对话框
- en: Table 7-1. Credential Store Feature Progression
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-1. 凭据存储功能进展
- en: '| Android version | API level | Credential store changes |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Android版本 | API等级 | 凭据存储变化 |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1.6 | 4 | Added credential store for VPN and Wi-Fi. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1.6 | 4 | 增加了VPN和Wi-Fi的凭据存储支持。 |'
- en: '| 4.0 | 14 | Added public API for credential store (`KeyChain` API). |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 4.0 | 14 | 添加了凭据存储的公共API（`KeyChain` API）。 |'
- en: '| 4.1 | 16 | Added the ability to generate and use keys without exporting them.
    Introduced keymaster HAL module and initial support for hardware-backed RSA key
    storage. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 4.1 | 16 | 增加了生成和使用密钥而不导出的能力。引入了keymaster HAL模块，并对硬件加速RSA密钥存储提供了初步支持。 |'
- en: '| 4.3 | 18 | Added support for generating and accessing app-private keys using
    the *AndroidKeyStore* JCA provider, and APIs to check whether the device supports
    hardware-backed key storage for RSA keys. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 4.3 | 18 | 增加了通过*AndroidKeyStore* JCA提供程序生成和访问应用私有密钥的支持，并增加了检查设备是否支持硬件加速RSA密钥存储的API。
    |'
- en: '| 4.4 | 19 | Added ECDSA and DSA support to the *AndroidKeyStore* JCA provider.
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 4.4 | 19 | 向*AndroidKeyStore* JCA提供程序添加了对ECDSA和DSA的支持。 |'
- en: Credential Storage Implementation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 凭据存储实现
- en: We now know that Android can encrypt imported credentials and manage access
    to them. Let’s see how this is implemented under the hood.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，Android能够加密导入的凭据并管理对它们的访问。接下来我们看看这些是如何在底层实现的。
- en: The keystore Service
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凭据存储服务
- en: Credential storage management in Android was originally implemented by a single
    native daemon called *keystore*. Its functionality was initially limited to storing
    arbitrary blobs in encrypted form and verifying the credential store password,
    but it was extended with new features as Android evolved. It offered a local socket-based
    interface to its clients, and each client was responsible for managing their own
    state and socket connections. The *key-store* daemon was replaced with a centralized
    Binder service in Android 4.3 in order to better integrate it with other framework
    services and facilitate extension. Let’s see how this *keystore* service works.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的凭据存储管理最初是由一个名为*keystore*的本地守护进程实现的。其最初功能仅限于以加密形式存储任意的二进制数据并验证凭据存储密码，但随着Android的发展，它被扩展了新功能。它为客户端提供了基于本地套接字的接口，每个客户端负责管理自己的状态和套接字连接。为了更好地与其他框架服务集成并促进扩展，Android
    4.3中将*keystore*守护进程替换为集中式的Binder服务。接下来我们来看一下这个*keystore*服务是如何工作的。
- en: The *keystore* service is defined in *init.rc*, as shown in [Example 7-1](ch07.html#keystore_service_definition_in_initdotrc
    "Example 7-1. keystore service definition in init.rc").
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*keystore*服务定义在*init.rc*中，如[示例7-1](ch07.html#keystore_service_definition_in_initdotrc
    "示例7-1. keystore服务定义在init.rc")所示。'
- en: Example 7-1. keystore service definition in init.rc
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-1. keystore服务定义在init.rc
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the *keystore* service runs as a dedicated *keystore* user and
    stores its files in */data/misc/keystore/*. Let’s peek into */data/misc/keystore/*
    first. If you’re using a single-user device, such as a phone, you will only find
    a single *user_0/* directory inside the *keystore/* directory (see [Example 7-2](ch07.html#sample_contents_of_the_keystore_director
    "Example 7-2. Sample contents of the keystore directory on a single-user device"),
    timestamps removed), but on multi-user enabled devices you should find one directory
    for each Android user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*keystore*服务以专用的*keystore*用户身份运行，并将文件存储在*/data/misc/keystore/*中。我们先来看一下*/data/misc/keystore/*目录。如果你使用的是单用户设备，例如手机，你只会在*keystore/*目录下找到一个*user_0/*目录（见[示例7-2](ch07.html#sample_contents_of_the_keystore_director
    "示例7-2. 单用户设备上keystore目录的示例内容")，时间戳已删除），但在启用多用户的设备上，你应该会为每个Android用户找到一个目录。
- en: Example 7-2. Sample contents of the keystore directory on a single-user device
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-2. 单用户设备上的密钥存储目录示例内容
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, each file name consists of the UID of the app that created
    it (1000 is *system*), the entry type (CA certificate, user certificate, or private
    key), and the key name (alias), all connected with underscores. Since Android
    4.3, system and app-private keys are supported as well, and the UID reflects the
    Android user ID as well as the app ID. On multi-user devices the user ID is `UID
    / 100000`, as discussed in [Chapter 4](ch04.html "Chapter 4. User Management").
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，每个文件名由创建它的应用程序的UID（1000是*系统*）、条目类型（CA证书、用户证书或私钥）和密钥名称（别名）组成，并用下划线连接。从Android
    4.3开始，系统和应用私有密钥也得到了支持，UID反映了Android用户ID以及应用程序ID。在多用户设备中，用户ID为`UID / 100000`，如[第4章](ch04.html
    "第4章. 用户管理")中所述。
- en: In addition to system or app-owned key blobs, there is also a single *.masterkey*
    file, which we’ll discuss shortly. When an app that owns store-managed keys is
    uninstalled for a user, only keys created by that user are deleted. If an app
    is completely removed from the system, its keys are deleted for all users. Because
    key access is tied to the app ID, this feature prevents a different app that happens
    to get the same UID from accessing an uninstalled app’s keys. (Keystore reset,
    which deletes both key files and the master key, also affects only the current
    user.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统或应用程序拥有的密钥二进制数据外，还有一个单独的*.masterkey*文件，稍后我们将讨论这个文件。当一个拥有存储管理密钥的应用程序被用户卸载时，仅会删除该用户创建的密钥。如果应用程序从系统中完全删除，它的密钥会对所有用户删除。由于密钥访问与应用程序ID相关联，这个功能防止了另一个恰好获得相同UID的应用程序访问已卸载应用程序的密钥。（密钥存储重置会删除密钥文件和主密钥，并且仅影响当前用户。）
- en: 'In the default software-based implementation, these files have the following
    contents (contents may be different for hardware-backed implementations; instead
    of encrypted key material, they often store only a reference to hardware-managed
    key objects):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的软件实现中，这些文件包含以下内容（硬件支持的实现可能有所不同；它们通常存储的不是加密的密钥数据，而是仅存储指向硬件管理密钥对象的引用）：
- en: The master key (stored in *.masterkey*) is encrypted with a 128-bit AES key
    derived from the screen unlock password by applying the *PBKDF2* key derivation
    function with 8192 iterations and a randomly generated 128-bit salt. The salt
    is stored in the *.masterkey* file’s info header.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主密钥（存储在*.masterkey*中）使用从屏幕解锁密码派生的128位AES密钥进行加密，该密钥通过应用*PBKDF2*密钥派生函数，进行8192次迭代并使用随机生成的128位盐值。该盐值存储在*.masterkey*文件的头部信息中。
- en: 'All other files store key blobs. A *key blob* (binary large object) contains
    a serialized, optionally encrypted key along with some data that describes the
    key (metadata). Each keystore key blob contains a metadata header, the initial
    vector (IV) used for encryption, and a concatenation of an MD5 hash value of the
    data with the data itself, encrypted with the 128-bit AES master key in CBC mode.
    Or more concisely: `metadata || Enc(MD5(data) || data)`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他文件存储的是密钥二进制数据。*密钥二进制数据*（binary large object，简称key blob）包含一个序列化的、可选加密的密钥，以及一些描述该密钥的数据（元数据）。每个密钥存储的密钥二进制数据包含一个元数据头部、用于加密的初始向量（IV），以及一个将数据的MD5哈希值与数据本身连接的字符串，并使用128位AES主密钥进行CBC模式加密。或者更简洁地表示为：`metadata
    || Enc(MD5(data) || data)`。
- en: In practice, this architecture means that the Android keystore is pretty secure
    for a software solution. Even if you had access to a rooted device and managed
    to extract the key blobs, you would still need the keystore password to derive
    the master key. Trying different passwords in an attempt to decrypt the master
    key would require at least 8192 iterations to derive a key, which is prohibitively
    expensive. In addition, because the derivation function is seeded with a 128-bit
    random number, pre-calculated password tables cannot be used. However, the MD5-based
    integrity mechanism used does not employ a standard Message Authentication Code
    (MAC) algorithm such as HMAC and is a remnant of the original implementation.
    It’s kept for backward compatibility, but may be replaced in a future version.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种架构意味着，Android密钥存储对于软件解决方案来说是相当安全的。即使你有访问权限到一个已经获取root权限的设备，并设法提取密钥二进制数据，你仍然需要密钥存储密码来推导出主密钥。为了尝试不同的密码以解密主密钥，至少需要进行8192次迭代才能推导出一个密钥，这在成本上是不可接受的。此外，由于推导函数使用128位随机数作为种子，不能使用预计算的密码表。不过，使用的基于MD5的完整性机制并未采用标准的消息认证码（MAC）算法，例如HMAC，而是原始实现的遗留部分。它保留是为了向后兼容，但在未来的版本中可能会被替换。
- en: Key Blob Versions and Types
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥二进制数据版本和类型
- en: 'Beginning with Android 4.1, two fields were added to key blobs: *version* and
    *type*. The current version (as of Android 4.4) is *2* and keys blobs are automatically
    upgraded to the latest version when an application first accesses them. As of
    this writing, the following key types are defined:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 4.1开始，密钥数据中添加了两个字段：*version*和*type*。当前版本（截至Android 4.4）是*2*，当应用首次访问密钥时，密钥数据会自动升级到最新版本。根据目前的信息，已定义以下密钥类型：
- en: '`TYPE_ANY`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE_ANY`'
- en: '`TYPE_GENERIC`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE_GENERIC`'
- en: '`TYPE_MASTER_KEY`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE_MASTER_KEY`'
- en: '`TYPE_KEY_PAIR`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE_KEY_PAIR`'
- en: '`TYPE_ANY` is a meta key type that matches any key type. `TYPE_GENERIC` is
    used for key blobs that are saved using the original get/put interface, which
    stores arbitrary binary data, and `TYPE_MASTER_KEY` is, of course, only used for
    the keystore master key. The `TYPE_KEY_PAIR` type is used for key blobs created
    using the `generate_keypair` and `import_keypair` operations, newly introduced
    in Android 4.1\. We’ll discuss these in the “[keymaster Module and keystore Service
    Implementation](ch07.html#keymaster_module_and_keystore_service_im "keymaster
    Module and keystore Service Implementation")” section.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`TYPE_ANY`是一个元密钥类型，可以匹配任何密钥类型。`TYPE_GENERIC`用于通过原始的get/put接口保存的密钥数据，这个接口存储任意的二进制数据，而`TYPE_MASTER_KEY`当然仅用于keystore的主密钥。`TYPE_KEY_PAIR`类型用于通过`generate_keypair`和`import_keypair`操作创建的密钥数据，这些操作是Android
    4.1中新增的功能。我们将在“[keymaster模块和keystore服务实现](ch07.html#keymaster_module_and_keystore_service_im
    "keymaster模块和keystore服务实现")”一节中讨论这些内容。'
- en: Android 4.3 is the first version to use the `flags` field of key blobs. It uses
    this field to distinguish encrypted (the default) from non-encrypted key blobs.
    Key blobs that are protected by a hardware-based implementation (available on
    some devices) are stored without additional encryption.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.3是第一个使用密钥数据的`flags`字段的版本。它使用这个字段来区分加密的（默认）和未加密的密钥数据。受硬件实现保护的密钥数据（某些设备上可用）会在没有额外加密的情况下存储。
- en: Access Restrictions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问限制
- en: 'Key blobs are owned by the *keystore* user, so on a regular (not rooted) device,
    you need to go through the *keystore* service in order to access them. The *keystore*
    service applies the following access restrictions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥数据由*keystore*用户拥有，因此在普通（非root）设备上，你需要通过*keystore*服务才能访问它们。*keystore*服务施加以下访问限制：
- en: The *root* user cannot lock or unlock the keystore, but can access system keys.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*root*用户无法锁定或解锁keystore，但可以访问系统密钥。'
- en: The *system* user can perform most keystore management operations (like initialization,
    reset, and so on) in addition to storing keys. However, the *system* user cannot
    use or retrieve other users’ keys.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*system*用户可以执行大多数keystore管理操作（如初始化、重置等），并存储密钥。然而，*system*用户无法使用或检索其他用户的密钥。'
- en: Non-system users can insert, delete, and access keys, but can only see their
    own keys.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非系统用户可以插入、删除和访问密钥，但只能查看自己的密钥。
- en: Now that we know what the *keystore* service does, let’s look at the actual
    implementation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了*keystore*服务的作用，接下来让我们看看实际的实现。
- en: keymaster Module and keystore Service Implementation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: keymaster模块和keystore服务实现
- en: While the original daemon-based implementation included both key blob management
    and encryption in a single binary, Android 4.1 introduced a new *keymaster Hardware
    Abstraction Layer (HAL)* system module responsible for generating asymmetric keys
    and signing/verifying data without the need to export the keys first.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原始的守护进程实现将密钥数据管理和加密功能合并在一个二进制文件中，但Android 4.1引入了新的*keymaster硬件抽象层(HAL)*系统模块，负责生成非对称密钥以及签名/验证数据，而无需先导出密钥。
- en: The *keymaster* module is meant to decouple the *keystore* service from the
    underlying asymmetric key operations implementation and to allow for easier integration
    of device-specific, hardware-backed implementations. A typical implementation
    would use a vendor-provided library to communicate with the crypto-enabled hardware
    and provide a “glue” HAL library, which the *keystore* daemon links with.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*keymaster*模块旨在将*keystore*服务与底层的非对称密钥操作实现解耦，并允许更容易地集成特定设备的硬件支持实现。一个典型的实现会使用厂商提供的库与加密硬件进行通信，并提供一个“粘合”HAL库，供*keystore*守护进程链接使用。'
- en: Android also comes with a default *softkeymaster* module that performs all key
    operations in software only (using the system OpenSSL library). This module is
    used on the emulator and included in devices that lack dedicated cryptographic
    hardware. The key size of generated keys was initially fixed at 2048 bits and
    only RSA keys were supported. Android 4.4 added support for specifying key size,
    as well as the Digital Signature Algorithm (DSA) and Elliptic Curve DSA (ECDSA)
    algorithms and their respective keys.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Android还自带了一个默认的*softkeymaster*模块，该模块仅通过软件执行所有密钥操作（使用系统的OpenSSL库）。该模块在模拟器中使用，并包含在缺少专用加密硬件的设备中。生成的密钥大小最初固定为2048位，并且只支持RSA密钥。Android
    4.4添加了对指定密钥大小的支持，并支持数字签名算法（DSA）和椭圆曲线DSA（ECDSA）算法及其相应的密钥。
- en: 'As of this writing, the default *softkeymaster* module supports RSA and DSA
    keys with sizes between 512 and 8192 bits. If the key size is not explicitly specified,
    DSA keys default to 1024 bits, and RSA ones to 2048 bits. For EC keys, the key
    size is mapped to a standard curve with the respective field size. For example,
    when 384 is specified as the key size, the *secp384r1* curve is used to generate
    keys. Currently the following standard curves are supported: *prime192v1*, *secp224r1*,
    *prime256v1*, *secp384r1*, and *secp521r1*. Keys for each of the supported algorithms
    can be imported as well if they are converted to the standard PKCS#8 format.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，默认的*softkeymaster*模块支持RSA和DSA密钥，密钥大小范围为512至8192位。如果没有明确指定密钥大小，DSA密钥默认是1024位，RSA密钥默认是2048位。对于EC密钥，密钥大小将映射到一个标准曲线及其相应的字段大小。例如，当指定密钥大小为384时，将使用*secp384r1*曲线来生成密钥。目前支持以下标准曲线：*prime192v1*、*secp224r1*、*prime256v1*、*secp384r1*和*secp521r1*。如果将它们转换为标准的PKCS#8格式，支持的算法的密钥也可以导入。
- en: The HAL module interface is defined in *hardware/keymaster.h* and defines the
    operations listed below.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: HAL模块接口定义在*hardware/keymaster.h*中，并定义了以下操作。
- en: '`generate_keypair`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_keypair`'
- en: '`import_keypair`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import_keypair`'
- en: '`sign_data`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sign_data`'
- en: '`verify_data`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verify_data`'
- en: '`get_keypair_public`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_keypair_public`'
- en: '`delete_keypair`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_keypair`'
- en: '`delete_all`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_all`'
- en: All asymmetric key operations exposed by the *keystore* service are implemented
    by calling the system *keymaster* module. Thus if the *keymaster* HAL module is
    backed by a hardware cryptographic device, all upper-level commands and APIs that
    use the *keystore* service interface automatically get to use hardware crypto.
    Aside from asymmetric key operations, all other credential store operations are
    implemented by the *keystore* system service and do not depend on HAL modules.
    The service registers itself to Android’s `ServiceManager` with the *android.security.keystore*
    name and is started at boot. Unlike most Android services, it is implemented in
    C++ and the implementation resides in *system/security/keystore/*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由*keystore*服务暴露的非对称密钥操作都是通过调用系统的*keymaster*模块来实现的。因此，如果*keymaster* HAL模块由硬件加密设备支持，那么所有使用*keystore*服务接口的上层命令和API将自动使用硬件加密。除了非对称密钥操作外，所有其他凭证存储操作都由*keystore*系统服务实现，并不依赖于HAL模块。该服务通过*android.security.keystore*名称注册到Android的`ServiceManager`，并在启动时启动。与大多数Android服务不同，它是用C++实现的，且实现位于*system/security/keystore/*目录下。
- en: Nexus 4 Hardware-Backed Implementation
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nexus 4 硬件支持实现
- en: To give some perspective to the whole “hardware-backed” idea, let’s briefly
    discuss how it’s implemented on the Nexus 4\. The Nexus 4 is based on Qualcomm’s
    Snapdragon S4 Pro APQ8064 system on a chip (SoC). Like most recent ARM SoCs, it
    is TrustZone-enabled, with Qualcomm’s Secure Execution Environment (QSEE) implemented
    on top of that.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家更好地理解“硬件支持”的概念，我们简要讨论一下Nexus 4上如何实现这一点。Nexus 4基于高通的Snapdragon S4 Pro APQ8064芯片系统（SoC）。像大多数最新的ARM
    SoC一样，它支持TrustZone，并且在此基础上实现了高通的安全执行环境（QSEE）。
- en: 'ARM’s TrustZone technology provides two virtual processors backed by hardware-based
    access control, which allows a SoC system to be partitioned into two virtual “worlds”:
    the *Secure world* for the security subsystem, and the *Normal world* for everything
    else. Applications running in the Secure world are referred to as *trusted applications*
    and can only be accessed by Normal world applications (which the Android OS and
    apps run in) through a limited interface that they explicitly expose. [Figure 7-2](ch07.html#trustzone_software_architecture
    "Figure 7-2. TrustZone software architecture") shows a typical software configuration
    for a TrustZone-enabled system.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的TrustZone技术提供了两个由硬件访问控制支持的虚拟处理器，这使得SoC系统可以被划分为两个虚拟“世界”：用于安全子系统的*安全世界*，以及用于其他所有内容的*普通世界*。运行在安全世界中的应用程序被称为*受信应用程序*，并且只能通过它们显式公开的有限接口，供普通世界应用程序（Android操作系统和应用程序运行的地方）访问。[图7-2](ch07.html#trustzone_software_architecture
    "图7-2. TrustZone软件架构")显示了一个典型的TrustZone启用系统的软件配置。
- en: '![TrustZone software architecture](figs/web/07fig02.png.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![TrustZone软件架构](figs/web/07fig02.png.jpg)'
- en: Figure 7-2. TrustZone software architecture
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2. TrustZone软件架构
- en: As usual, implementation details are quite scarce, but on the Nexus 4 the only
    way to interact with trusted applications is through the controlled interface
    that the */dev/qseecom* device provides. Android applications that wish to interact
    with the QSEE load the proprietary *libQSEEComAPI.so* library and use its functions
    to send commands to the QSEE.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，实施细节相当稀缺，但在Nexus 4中，唯一与受信应用程序交互的方式是通过*/dev/qseecom*设备提供的受控接口。希望与QSEE交互的Android应用程序会加载专有的*libQSEEComAPI.so*库，并使用其函数向QSEE发送命令。
- en: 'As with most other SEEs, the *QSEECom* communication API is quite low level
    and basically only allows for exchanging opaque blobs (typically commands and
    replies), the contents of which depend entirely on the secure app you’re communicating
    with. In the case of the Nexus 4 *keymaster*, the commands used are: `GENERATE_KEYPAIR`,
    `IMPORT_KEYPAIR`, `SIGN_DATA`, and `VERIFY_DATA`. The *keymaster* implementation
    merely creates command structures, sends them via the *QSEECom* API, and parses
    the replies. It does not contain any cryptographic code.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他SEE（安全执行环境）一样，*QSEECom*通信API相当低级，基本上只允许交换不透明的二进制数据（通常是命令和响应），其内容完全依赖于你正在与之通信的安全应用程序。在Nexus
    4的*keymaster*中，使用的命令有：`GENERATE_KEYPAIR`、`IMPORT_KEYPAIR`、`SIGN_DATA`和`VERIFY_DATA`。*keymaster*的实现仅创建命令结构，通过*QSEECom*
    API发送它们，并解析响应。它不包含任何加密代码。
- en: One interesting detail is that the QSEE *keystore* trusted app (which may not
    be a dedicated app, but part of a more general-purpose trusted application) doesn’t
    return simple references to protected keys; it uses proprietary encrypted key
    blobs. In this model, the only thing that is actually protected by hardware is
    some form of master key-encryption key (KEK); user-generated keys are only indirectly
    protected by being encrypted with the KEK.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的细节是，QSEE的*密钥存储*受信应用程序（这可能不是一个专用应用程序，而是一个更通用的受信应用程序的一部分）不会返回简单的受保护密钥引用；它使用专有的加密密钥二进制数据。在这种模型中，唯一由硬件实际保护的是某种形式的主密钥加密密钥（KEK）；用户生成的密钥仅通过使用KEK加密间接受到保护。
- en: This method allows for a practically unlimited number of protected keys, but
    it has the disadvantage that if the KEK is compromised, all externally stored
    key blobs are compromised as well. (Of course, the actual implementation might
    generate a dedicated KEK for each key blob created, or the key can be fused in
    hardware; either way no details are available about the internal implementation.)
    That said, Qualcomm *keymaster* key blobs are defined in AOSP code (shown in [Example 7-3](ch07.html#qsee_keymaster_blob_definition_left_pare
    "Example 7-3. QSEE keymaster blob definition (for Nexus 4)")) and the definition
    suggests that private exponents are encrypted using AES ➊, most probably in CBC
    mode, with an added HMAC-SHA256 ➋ to check encrypted data integrity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许几乎无限数量的受保护密钥，但它的缺点是，如果KEK被破解，所有外部存储的密钥二进制数据也将被破解。（当然，实际的实现可能会为每个创建的密钥二进制数据生成专用的KEK，或者密钥可以被硬件烧录；无论如何，对于内部实现没有可用的细节。）话虽如此，高通*keymaster*密钥二进制数据在AOSP代码中有定义（在[示例7-3](ch07.html#qsee_keymaster_blob_definition_left_pare
    "示例7-3. QSEE keymaster二进制数据定义（针对Nexus 4）")中显示），该定义表明私钥指数使用AES ➊加密，最有可能采用CBC模式，并添加了HMAC-SHA256
    ➋来检查加密数据的完整性。
- en: Example 7-3. QSEE keymaster blob definition (for Nexus 4)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-3. QSEE keymaster二进制数据定义（针对Nexus 4）
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in [Example 7-3](ch07.html#qsee_keymaster_blob_definition_left_pare
    "Example 7-3. QSEE keymaster blob definition (for Nexus 4)"), the QSEE key blob
    contains the key modulus ➌, public exponent ➍, the IV ➎ used for private exponent
    encryption, the private exponent itself ➏, and the HMAC value ➐.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[示例 7-3](ch07.html#qsee_keymaster_blob_definition_left_pare "示例 7-3. QSEE
    密钥大师 blob 定义（适用于 Nexus 4）")中看到的，QSEE 密钥 blob 包含密钥模数 ➌、公钥指数 ➍、用于私钥加密的 IV ➎、私钥本身
    ➏ 和 HMAC 值 ➐。
- en: Since the QSEE used in the Nexus 4 is implemented using the TrustZone functions
    of the processor, in this case the “hardware” of the hardware-backed credential
    store is simply the ARM SoC. Are other implementations possible? Theoretically,
    a hardware-backed *keymaster* implementation does not need to be based on TrustZone.
    Any dedicated device that can generate and store keys securely can be used, with
    the usual candidates being embedded Secure Elements (SE) and Trusted Platform
    Modules (TPMs). We’ll discuss SEs and other tamper-resistant devices in [Chapter 11](ch11.html
    "Chapter 11. NFC and Secure Elements"), but as of this writing no mainstream Android
    devices have dedicated TPMs and recent flagship devices have begun shipping without
    embedded SEs. Therefore, implementations using dedicated hardware are unlikely
    to show up in mainstream devices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Nexus 4 中使用的 QSEE 是通过处理器的 TrustZone 功能实现的，因此在这种情况下，硬件支持的凭证存储的“硬件”实际上只是 ARM
    SoC。是否可能有其他实现？理论上，基于硬件的*密钥大师*实现不需要依赖于 TrustZone。任何能够安全生成和存储密钥的专用设备都可以使用，常见的候选设备包括嵌入式安全元件（SE）和受信平台模块（TPM）。我们将在[第
    11 章](ch11.html "第 11 章. NFC 和安全元件")中讨论 SE 和其他防篡改设备，但截至目前，没有主流 Android 设备配备专用的
    TPM，最近的旗舰设备也开始出货时不再内置 SE。因此，使用专用硬件的实现不太可能出现在主流设备中。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Of course, all mobile devices have some form of* Universal Integrated Circuit
    Card (UICC)*, colloquially known as a SIM card, which typically can generate and
    store keys, but Android still doesn’t have a standard API to access the UICC even
    though vendor firmware often includes one. So while one could theoretically implement
    a UICC-based* keymaster *module, it would only work on custom Android builds and
    would depend on network operators to include support in their UICCs.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*当然，所有移动设备都有某种形式的*通用集成电路卡（UICC）*，通常被称为 SIM 卡，通常可以生成和存储密钥，但 Android 仍然没有标准 API
    来访问 UICC，尽管供应商的固件通常包含该功能。因此，虽然理论上可以实现基于 UICC 的*密钥大师*模块，但它只适用于定制的 Android 版本，并且需要运营商在其
    UICC 中包括支持。*'
- en: Framework Integration
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架集成
- en: While managing credentials securely is the key feature of Android’s credential
    storage, its main purpose is to provide this service seamlessly to the rest of
    the system. Let’s briefly discuss how it integrates with the rest of Android before
    presenting the public APIs that are available for third-party apps.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安全地管理凭证是 Android 凭证存储的关键特性，但其主要目的是无缝地向系统的其余部分提供此服务。在介绍可供第三方应用程序使用的公共 API 之前，我们简要讨论它如何与
    Android 的其余部分集成。
- en: Because the *keystore* service is a standard Binder service, in order to use
    it potential clients only need to get a reference to it from the `ServiceManager`.
    The Android framework provides the singleton `android.security.KeyStore` hidden
    class, which is responsible for obtaining a reference to the *keystore* service
    and serves as a proxy to the `IKeystoreService` interface it exposes. Most system
    applications, such as the PKCS#12 file importer (see [Figure 7-1](ch07.html#pkcshash12_file_password_dialog
    "Figure 7-1. PKCS#12 file password dialog")), and the implementations of some
    of the public APIs use the `KeyStore` proxy class to communicate with the *keystore*
    service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*密钥库*服务是一个标准的 Binder 服务，所以潜在的客户端只需要从`ServiceManager`获取对它的引用即可使用它。Android 框架提供了一个单例的`android.security.KeyStore`隐藏类，该类负责获取对*密钥库*服务的引用，并充当它暴露的`IKeystoreService`接口的代理。大多数系统应用程序，如
    PKCS#12 文件导入器（参见[图 7-1](ch07.html#pkcshash12_file_password_dialog "图 7-1. PKCS#12
    文件密码对话框")）以及一些公共 API 的实现，使用`KeyStore`代理类与*密钥库*服务进行通信。
- en: In the case of lower-level libraries that are not part of the Android framework,
    such as native libraries and JCA classes in the core Java library, integration
    with the system credential store is provided indirectly through an OpenSSL engine
    called the *Android keystore engine*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些较低级别的库（如原生库和核心 Java 库中的 JCA 类），它们不是 Android 框架的一部分，系统凭证存储的集成是通过一个名为*Android
    密钥库引擎*的 OpenSSL 引擎间接提供的。
- en: An OpenSSL engine is a pluggable cryptographic module implemented as a dynamic
    shared library. The *keystore* engine is one such module that implements all of
    its operations by calling the system *keymaster* HAL module. It supports only
    loading and signing with RSA, DSA, or EC private keys, but that’s enough to implement
    key-based authentication (such as SSL client authentication). The *keystore* engine
    makes it possible for native code that uses OpenSSL APIs to use private keys saved
    in the system credential store without the need for code modifications. It also
    has a Java wrapper (`OpenSSLEngine`), which is used to implement access to keystore-managed
    private keys in the JCA framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 引擎是一个可插拔的加密模块，作为动态共享库实现。*keystore* 引擎就是一个这样的模块，它通过调用系统的 *keymaster*
    HAL 模块来实现所有操作。它仅支持使用 RSA、DSA 或 EC 私钥加载和签名，但足以实现基于密钥的身份验证（如 SSL 客户端身份验证）。*keystore*
    引擎使得使用 OpenSSL API 的原生代码能够使用保存在系统凭据存储中的私钥，而无需修改代码。它还具有一个 Java 包装器（`OpenSSLEngine`），用于在
    JCA 框架中实现对 keystore 管理的私钥的访问。
- en: Public APIs
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共 API
- en: While system applications can access the *keystore* daemon AIDL interface directly
    or through the `android.security.KeyStore` proxy class, those interfaces are too
    closely coupled with the implementation to be part of the public API. Android
    provides higher-level abstractions for third-party apps with the `KeyChain` API
    and the *AndroidKeyStoreProvider* JCA provider. We’ll show how these APIs are
    used and provide some implementation details in the following sections.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然系统应用可以直接通过 `android.security.KeyStore` 代理类或通过 *keystore* 守护进程 AIDL 接口访问，但这些接口与实现过于紧密耦合，不适合作为公共
    API 的一部分。Android 提供了更高级的抽象层，供第三方应用使用 `KeyChain` API 和 *AndroidKeyStoreProvider*
    JCA 提供程序。我们将在以下部分展示如何使用这些 API，并提供一些实现细节。
- en: The KeyChain API
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KeyChain API
- en: Android has offered a system-wide credential store since version 1.6, but it
    was only usable by built-in VPN and Wi-Fi EAP clients. It was possible to install
    a private key/certificate pair using the Settings app, but the installed keys
    were not accessible by third-party applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Android 1.6 起，Android 提供了一个系统范围的凭据存储，但当时仅限内建的 VPN 和 Wi-Fi EAP 客户端使用。虽然可以通过设置应用安装私钥/证书对，但已安装的密钥无法被第三方应用访问。
- en: Android 4.0 introduced SDK APIs for both trusted certificate management and
    secure credential storage via the `KeyChain` class. This feature was extended
    in Android 4.3 to support the newly introduced hardware-backed features. We’ll
    discuss how it’s used and review its implementation in the following sections.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.0 引入了用于受信任证书管理和安全凭据存储的 SDK API，提供了 `KeyChain` 类。此功能在 Android 4.3 中得到扩展，支持新引入的硬件支持功能。我们将在以下部分讨论如何使用此功能，并回顾其实现。
- en: The KeyChain Class
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KeyChain 类
- en: 'The `KeyChain` class is quite simple: it offers six public static methods,
    which are sufficient for most certificate- and key-related tasks. We’ll look at
    how to install a private key/certificate pair and then use that pair to access
    the credential-store-managed private key.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyChain` 类非常简单：它提供了六个公共静态方法，足以完成大多数与证书和密钥相关的任务。我们将看看如何安装私钥/证书对，并使用该对访问凭据存储管理的私钥。'
- en: The `KeyChain` API lets you install a private key/certificate pair bundled in
    a PKCS#12 file. The `KeyChain.createInstallIntent()` factory method is the gateway
    to this functionality. It takes no parameters and returns a system intent that
    can parse and install keys and certificates. (This is actually the same intent
    that is used internally by the Settings system app.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyChain` API 允许你安装捆绑在 PKCS#12 文件中的私钥/证书对。`KeyChain.createInstallIntent()`
    工厂方法是访问此功能的入口。它不接受任何参数，并返回一个系统意图，该意图可以解析并安装密钥和证书。（这实际上是系统设置应用程序内部使用的相同意图。）'
- en: Installing a PKCS#12 File
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 PKCS#12 文件
- en: 'To install a PKCS#12 file, you have to read it to a byte array, store it under
    the `EXTRA_PKCS12` key in the intent’s extras, and start the associated activity
    (see [Example 7-4](ch07.html#installing_a_pkcshash12_file_using_the_k "Example 7-4. Installing
    a PKCS#12 file using the KeyChain API")):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 PKCS#12 文件，你必须将其读取到字节数组中，存储在意图的 extras 中的 `EXTRA_PKCS12` 键下，然后启动相关的活动（参见
    [示例 7-4](ch07.html#installing_a_pkcshash12_file_using_the_k "示例 7-4：使用 KeyChain
    API 安装 PKCS#12 文件")）：
- en: Example 7-4. Installing a PKCS#12 file using the `KeyChain` API
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-4：使用 `KeyChain` API 安装 PKCS#12 文件
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Private key and certificate import dialog](figs/web/07fig03.png.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![私钥和证书导入对话框](figs/web/07fig03.png.jpg)'
- en: Figure 7-3. Private key and certificate import dialog
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：私钥和证书导入对话框
- en: This should prompt you for the PKCS#12 password in order to extract and parse
    the key and certificate. If the password is correct, you should be prompted for
    a certificate name, as shown in [Figure 7-3](ch07.html#private_key_and_certificate_import_dialo
    "Figure 7-3. Private key and certificate import dialog"). If the PKCS#12 has a
    friendly name attribute, it will be shown as the default; if not, you’ll just
    get a long hexadecimal hash string. The string you enter here is the key or certificate
    alias you can use later to look up and access keys via the `KeyChain` API. You
    should be prompted to set a lock screen PIN or password to protect the credential
    storage if you haven’t already set one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Using a Private Key
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use a private key stored in the system credential store, you need to obtain
    a reference to the key using its alias and request key access permission from
    the user. If you’ve never accessed a key before and don’t know its alias, you
    need to first call `KeyChain.choosePrivateKeyAlias()` and provide a callback implementation
    that receives the selected alias as shown in [Example 7-5](ch07.html#using_a_private_key_stored_in_the_system
    "Example 7-5. Using a private key stored in the system credential store").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5. Using a private key stored in the system credential store
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first parameter ➊ is the current context; the second ➋ is the callback to
    invoke; and the third and fourth specify the acceptable keys ➌ (`RSA`, `DSA`,
    or `null` for any) and acceptable certificate issuers ➍ for the certificate matching
    the private key. The next two parameters are the host ➎ and port number ➏ of the
    server requesting a certificate, and the last one ➐ is the alias to preselect
    in the key selection dialog. We leave all but the key type as unspecified (`null`
    or `-1`) here in order to be able to select from all available certificates. Note
    that the `alias()` ➑ callback will not be called on the main thread, so don’t
    try to directly manipulate the UI from it. (It’s called on a binder thread.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Using the key requires user authorization, so Android should display a key selection
    dialog (see [Figure 7-4](ch07.html#key_selection_dialog "Figure 7-4. Key selection
    dialog")) which also serves to grant access to the selected key. Once the user
    has granted key access to an app, it can look up that key directly without going
    through the key selection dialog.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Key selection dialog](figs/web/07fig04.png.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4. Key selection dialog
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 7-6](ch07.html#getting_a_key_instance_and_its_certifica "Example 7-6. Getting
    a key instance and its certificate chain") shows how to use the `KeyChain` API
    to obtain a reference to a private key managed by the system keystore.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6. Getting a key instance and its certificate chain
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To get a reference to a private key, you need to call the `KeyChain.getPrivateKey()`
    ➊ method, passing it the key alias name received in the previous step. If you
    try to call this method on the main thread, you’ll get an exception, so make sure
    to call it from a background thread like the one created by the `AsyncTask` utility
    class. The `getCertificateChain()` ➋ method returns the certificate chain associated
    with the private key (see [Example 7-6](ch07.html#getting_a_key_instance_and_its_certifica
    "Example 7-6. Getting a key instance and its certificate chain")). If a key or
    certificate with the specified alias doesn’t exist, the `getPrivateKey()` and
    `getCertificateChain()` methods will return `null`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取私钥的引用，您需要调用`KeyChain.getPrivateKey()` ➊方法，传入在前一步中收到的密钥别名。如果你尝试在主线程中调用此方法，会抛出异常，因此确保从后台线程中调用它，像`AsyncTask`工具类创建的线程那样。`getCertificateChain()`
    ➋方法返回与私钥相关的证书链（见[示例7-6](ch07.html#getting_a_key_instance_and_its_certifica "示例7-6：获取密钥实例及其证书链")）。如果指定别名的密钥或证书不存在，`getPrivateKey()`和`getCertificateChain()`方法将返回`null`。
- en: Installing a CA Certificate
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装CA证书
- en: Installing a CA certificate is not very different from installing a PKCS#12
    file. To do so, load the certificate in a byte array and pass it as an extra to
    the install intent under the `EXTRA_CERTIFICATE` key, as shown in [Example 7-7](ch07.html#installing_a_ca_certificate_using_the_ke
    "Example 7-7. Installing a CA certificate using the KeyChain API").
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 安装CA证书与安装PKCS#12文件没有太大区别。为此，将证书加载到字节数组中，并作为额外参数传递给安装意图下的`EXTRA_CERTIFICATE`键，如[示例7-7](ch07.html#installing_a_ca_certificate_using_the_ke
    "示例7-7：使用KeyChain API安装CA证书")所示。
- en: Example 7-7. Installing a CA certificate using the `KeyChain` API
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-7. 使用`KeyChain` API安装CA证书
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Android parses the certificate, and if its *Basic Constraints* extension is
    set to `CA:TRUE`, considers it a CA certificate and imports it into the user trust
    store. You need to authenticate in order to import the certificate.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Android解析证书，如果其*基本约束*扩展设置为`CA:TRUE`，则认为它是一个CA证书并将其导入用户信任存储。你需要进行身份验证才能导入证书。
- en: Unfortunately, the import dialog (see [Figure 7-5](ch07.html#ca_certificate_import_dialog-id00013
    "Figure 7-5. CA certificate import dialog")) shows neither the certificate DN
    nor its hash value. The user has no way of knowing what they’re importing until
    it’s done. Very few people bother to check a certificate’s validity, so this could
    be a potential security threat because malicious applications could trick people
    into installing rogue certificates.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，导入对话框（见[图7-5](ch07.html#ca_certificate_import_dialog-id00013 "图7-5：CA证书导入对话框")）既没有显示证书的DN，也没有显示其哈希值。用户在完成操作之前无法知道自己导入的是什么。很少有人会检查证书的有效性，因此这可能是一个潜在的安全威胁，因为恶意应用程序可能会欺骗用户安装恶意证书。
- en: After the certificate is imported, it should show up in the Trusted credentials
    screen’s User tab (Settings ▸Security ▸Trusted credentials). Tap the certificate
    entry to display a details dialog where you can check the subject, issuer, validity
    period, serial number, and SHA-1/SHA-256 fingerprints. To remove a certificate,
    press the **Remove** button (see [Figure 7-6](ch07.html#certificate_details_dialog
    "Figure 7-6. Certificate details dialog")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 证书导入后，应显示在受信任凭证屏幕的用户选项卡中（设置 ▸ 安全性 ▸ 受信任凭证）。点击证书条目以显示详细信息对话框，你可以查看主题、颁发者、有效期、序列号和SHA-1/SHA-256指纹。要移除证书，请按**移除**按钮（见[图7-6](ch07.html#certificate_details_dialog
    "图7-6：证书详细信息对话框")）。
- en: '![CA certificate import dialog](figs/web/07fig05.png.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![CA证书导入对话框](figs/web/07fig05.png.jpg)'
- en: Figure 7-5. CA certificate import dialog
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-5. CA证书导入对话框
- en: '![Certificate details dialog](figs/web/07fig06.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![证书详细信息对话框](figs/web/07fig06.png.jpg)'
- en: Figure 7-6. Certificate details dialog
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-6. 证书详细信息对话框
- en: Deleting Keys and User Certificates
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除密钥和用户证书
- en: While you can delete individual CA certificates, there is no way to delete individual
    keys and user certificates, although the Clear credentials option in the Credential
    Storage section of the security settings will delete all keys and user certificates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以删除单个CA证书，但无法删除单个密钥和用户证书，尽管在安全设置中的凭证存储部分有清除凭证选项，它会删除所有的密钥和用户证书。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As long as you have keys in the credential store, you can’t remove the screen
    lock because it is used to protect access to the keystore.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*只要凭证存储中有密钥，就无法移除屏幕锁，因为它用于保护密钥库的访问。*'
- en: Getting Information about Supported Algorithms
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取支持的算法信息
- en: Android 4.3 added two methods to the `KeyChain` class related to the newly introduced
    hardware support. According to the API documentation, `isBoundKeyAlgorithm(String
    algorithm)` “returns `true` if the current device’s `KeyChain` implementation
    binds any `PrivateKey` of the given algorithm to the device once imported or generated.”
    In other words, if you pass the string *RSA* to this method, it should return
    `true` if generated or imported RSA keys have hardware protection and cannot simply
    be copied off the device. The `isKeyAlgorithmSupported(String algorithm)` method
    should return `true` if the current `KeyChain` implementation supports keys of
    the specified type (RSA, DSA, EC, and so on).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.3 向 `KeyChain` 类添加了与新引入的硬件支持相关的两个方法。根据 API 文档，`isBoundKeyAlgorithm(String
    algorithm)` 方法“如果当前设备的 `KeyChain` 实现将给定算法的任何 `PrivateKey` 绑定到设备上（无论是导入还是生成），则返回
    `true`。”换句话说，如果你将字符串 *RSA* 传递给此方法，如果生成或导入的 RSA 密钥具有硬件保护，不能简单地从设备上复制，它应返回 `true`。`isKeyAlgorithmSupported(String
    algorithm)` 方法应返回 `true`，如果当前的 `KeyChain` 实现支持指定类型的密钥（如 RSA、DSA、EC 等）。
- en: We’ve introduced the main features of the `KeyChain` API. Now let’s look at
    the underlying Android implementation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 `KeyChain` API 的主要功能。现在让我们来看一下底层的 Android 实现。
- en: KeyChain API Implementation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KeyChain API 实现
- en: 'The public `KeyChain` class and supporting interfaces reside in the `android.security`
    Java package. The package also contains two hidden AIDL files: `IKeyChainService.aidl`
    and `IKeyChainAliasCallback`. This is a hint that the actual keystore functionality,
    like most Android OS services, is implemented as a remote service to which the
    public APIs bind. The interface `IKeyChainAliasCallback` is called when you select
    a key via `KeyStore.choosePrivateKeyAlias()`, so it’s of little interest. `IKeyChainService.aidl`
    defines the actual system interface that services use, so we’ll describe it in
    more detail.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的 `KeyChain` 类和支持的接口位于 `android.security` Java 包中。该包还包含两个隐藏的 AIDL 文件：`IKeyChainService.aidl`
    和 `IKeyChainAliasCallback`。这暗示了实际的 keystore 功能，像大多数 Android 操作系统服务一样，是作为一个远程服务实现的，公共
    API 会绑定到该服务。接口 `IKeyChainAliasCallback` 在你通过 `KeyStore.choosePrivateKeyAlias()`
    选择密钥时被调用，因此它的兴趣不大。`IKeyChainService.aidl` 定义了服务使用的实际系统接口，我们将在这里详细描述它。
- en: The `IKeyChainService` interface has one implementation, the `KeyChainService`
    class in the `KeyChain` system application. In addition to `KeyChainService`,
    the application includes an activity, `KeyChain`, and a broadcast receiver, `KeyChainBroadcastReceiver`.
    The `KeyChain` application has its `sharedUserId` is set to *android.uid.system*
    and therefore inherits all privileges of the *system* user. This allows its components
    to send management commands to the native *keystore* service. Let’s examine the
    service first.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`IKeyChainService` 接口有一个实现，即 `KeyChain` 系统应用中的 `KeyChainService` 类。除了 `KeyChainService`，该应用还包含一个活动
    `KeyChain` 和一个广播接收器 `KeyChainBroadcastReceiver`。`KeyChain` 应用的 `sharedUserId`
    被设置为 *android.uid.system*，因此继承了 *system* 用户的所有权限。这允许其组件向本地 *keystore* 服务发送管理命令。我们首先来检查这个服务。'
- en: 'The `KeyChainService` is a wrapper for the `android.security.KeyStore` proxy
    class that directly communicates with the native *keystore* service. It provides
    four main services:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyChainService` 是 `android.security.KeyStore` 代理类的封装器，直接与本地 *keystore* 服务通信。它提供了四个主要服务：'
- en: 'Keystore management: methods for getting private keys and certificates.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keystore 管理：用于获取私钥和证书的方法。
- en: 'Trust store management: methods for installing and deleting CA certificates
    in the user trust store.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信任存储管理：用于在用户信任存储中安装和删除 CA 证书的方法。
- en: 'Key and trust store initialization: a `reset()` method that deletes all key-store
    entries, including the master key, thus returning the keystore to an uninitialized
    state; it also removes all user-installed trusted certificates.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥和信任存储初始化：一个 `reset()` 方法，删除所有密钥存储条目，包括主密钥，从而将 keystore 恢复到未初始化状态；它还会移除所有用户安装的受信任证书。
- en: Methods for querying and adding entries to the key access grant database.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和添加条目到密钥访问授权数据库的方法。
- en: Controlling Access to the Keystore
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制对 Keystore 的访问
- en: Since the `KeyChain` application runs as the *system* user, any process that
    binds to its remote interface would technically be able to perform all key and
    trust store operations. To prevent this, the `KeyChainService` imposes additional
    access control on its users by controlling access to credential store operations
    based on the caller’s UID and using a key access grant database to regulate access
    to individual keys. Only the *system* user can delete a CA certificate and reset
    the key and trust stores (operations typically called via the Settings app’s UI,
    which runs as *system*). By the same token, only the *system* user or the certificate
    installer application (`com.android.certinstaller` package) can install a trusted
    CA certificate.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`KeyChain`应用以*系统*用户身份运行，任何绑定到其远程接口的进程在技术上都可以执行所有密钥和信任存储操作。为了防止这种情况，`KeyChainService`通过基于调用者的UID控制对凭据存储操作的访问，并使用密钥访问授权数据库来调节对各个密钥的访问。只有*系统*用户可以删除CA证书并重置密钥和信任存储（这些操作通常通过设置应用的UI进行调用，而设置应用以*系统*身份运行）。同样，只有*系统*用户或证书安装应用（`com.android.certinstaller`包）可以安装受信任的CA证书。
- en: Controlling access to individual keys in the credential store is a little bit
    more interesting than operation restrictions. The `KeyChainService` maintains
    a grants database (in */data/data/com.android.keychain/databases/grants.db*) that
    maps UIDs to the key aliases they are allowed to use. Let’s have a look inside
    in [Example 7-8](ch07.html#schema_and_contents_of_the_grants_databa "Example 7-8. Schema
    and contents of the grants database").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 控制对凭据存储中单个密钥的访问比操作限制更有意思。`KeyChainService`维护一个授权数据库（位于*/data/data/com.android.keychain/databases/grants.db*），该数据库将UID与其被允许使用的密钥别名映射。我们可以在[示例7-8](ch07.html#schema_and_contents_of_the_grants_databa
    "示例7-8. 授权数据库的模式和内容")中查看其内部结构。
- en: Example 7-8. Schema and contents of the grants database
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-8. 授权数据库的模式和内容
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the application with UID *10044* ➋ is granted access to the
    keys with the `test` ➊ and `key1` ➌ aliases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，UID为*10044* ➋的应用被授权访问别名为`test` ➊和`key1` ➌的密钥。
- en: Each call to `getPrivateKey()` or `getCertificate()` is subject to a check against
    the grants database, and results in an exception if a grant for the required alias
    is not found. As stated before, `KeyChainService` has APIs for adding and querying
    grants, and only the *system* user can call them. But who is responsible for actually
    granting and revoking access?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`getPrivateKey()`或`getCertificate()`时，都会对照授权数据库进行检查，如果未找到所需别名的授权，则会抛出异常。如前所述，`KeyChainService`具有用于添加和查询授权的API，并且只有*系统*用户可以调用这些API。但谁负责实际授权和撤销访问权限呢？
- en: Remember the private key selection dialog ([Figure 7-4](ch07.html#key_selection_dialog
    "Figure 7-4. Key selection dialog"))? When you call `KeyChain.choosePrivateKeyAlias()`,
    it starts the `KeyChainActivity` (introduced above), which checks to see if the
    keystore is unlocked; if so, `KeyChainActivity` shows the key selection dialog.
    Clicking the **Allow** button returns to the `KeyChainActivity`, which then calls
    `KeyChainService.setGrant()` with the selected alias, adding it to the grants
    database. Thus, even if the activity requesting access to a private key has the
    needed permissions, the user must unlock the keystore and explicitly authorize
    access to each individual key.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 记得私钥选择对话框吗？([图7-4](ch07.html#key_selection_dialog "图7-4. 私钥选择对话框"))？当你调用`KeyChain.choosePrivateKeyAlias()`时，它会启动`KeyChainActivity`（如上所述），该活动检查密钥库是否已解锁；如果已解锁，`KeyChainActivity`会显示私钥选择对话框。点击**允许**按钮后，返回`KeyChainActivity`，它会调用`KeyChainService.setGrant()`并使用选定的别名，将其添加到授权数据库中。因此，即使请求访问私钥的活动具有所需的权限，用户仍然需要解锁密钥库并明确授权访问每个单独的密钥。
- en: Besides controlling private key storage, the `KeyChainService` also offers trust
    store management by using the newly added `TrustedCertificateStore` class (part
    of *libcore*). This class provides both the ability to add user-installed trusted
    CA certificates and remove (mark as not trusted) system (preinstalled) CAs. [Chapter 6](ch06.html
    "Chapter 6. Network Security and PKI") discusses the details of its implementation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控制私钥存储外，`KeyChainService`还通过使用新添加的`TrustedCertificateStore`类（属于*libcore*）提供信任存储管理功能。该类既可以添加用户安装的受信任CA证书，也可以移除（标记为不受信任）系统（预安装）CA证书。[第6章](ch06.html
    "第6章 网络安全和公钥基础设施")详细讨论了其实现细节。
- en: KeyChainBroadcastReceiver
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KeyChainBroadcastReceiver
- en: 'The last component of the `KeyChain` app is the `KeyChainBroadcastReceiver`.
    It listens for the `android.intent.action.PACKAGE_REMOVED` system broadcast and
    simply forwards control to the `KeyChainService`. On receiving the `PACKAGE_REMOVED`
    action, the service does some grant database maintenance: it goes through all
    entries and deletes any referencing packages that are no longer available (that
    is, ones that have been uninstalled).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyChain` 应用的最后一个组件是 `KeyChainBroadcastReceiver`。它监听 `android.intent.action.PACKAGE_REMOVED`
    系统广播，并将控制转发给 `KeyChainService`。在接收到 `PACKAGE_REMOVED` 操作时，服务会进行一些授权数据库维护：它会遍历所有条目并删除任何不再可用的包（即已卸载的包）。'
- en: Credential and Trust Store Summary
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 凭据和信任存储总结
- en: Android 4.0 introduces a new service that grants access to both the system keystore
    (managed by the *keystore* system service) and the trust store (managed by the
    `TrustedCertificateStore` class) that backs the `KeyChain` API exposed in the
    public SDK. This feature makes it possible to control access to keys based on
    both the calling process’s UID and the key access grant database, thus allowing
    for fine-grained, user-driven control over which keys each application can access.
    The components of Android’s credential and trust store and their relationship
    are presented in [Figure 7-7](ch07.html#system_credential_store_components "Figure 7-7. System
    credential store components").
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.0 引入了一项新服务，它授予对系统密钥库（由*密钥库*系统服务管理）和信任存储（由 `TrustedCertificateStore`
    类管理）的访问权限，这两个存储支持公共 SDK 中暴露的 `KeyChain` API。此功能使得可以根据调用进程的 UID 和密钥访问授权数据库来控制密钥的访问，从而实现细粒度、由用户驱动的控制，决定每个应用可以访问哪些密钥。Android
    凭据和信任存储的组件及其关系展示在[图 7-7](ch07.html#system_credential_store_components "图 7-7.
    系统凭据存储组件")中。
- en: '![System credential store components](figs/web/07fig07.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![系统凭据存储组件](figs/web/07fig07.png)'
- en: Figure 7-7. System credential store components
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-7. 系统凭据存储组件
- en: Android Keystore Provider
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android Keystore 提供者
- en: While the `KeyChain` API introduced in Android 4.0 allows applications to import
    keys into the system credential store, those keys are owned by the *system* user
    and any application can request access to them. Android 4.3 adds support for *app-private*
    keys, which allows any app to generate and save private keys that can only be
    accessed and used by itself and are not visible to other apps.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Android 4.0 中引入的 `KeyChain` API 允许应用将密钥导入系统凭据存储区，但这些密钥归*系统*用户所有，任何应用都可以请求访问这些密钥。Android
    4.3 增加了对*应用私有*密钥的支持，这使得任何应用都可以生成并保存只能由其自身访问和使用的私密密钥，且这些密钥对其他应用不可见。
- en: Instead of introducing yet another Android-specific API, keystore access is
    exposed via standard JCA APIs, namely `java.security.KeyPairGenerator` and `java.security.KeyStore`.
    Both are backed by a new Android JCA provider, *AndroidKeyStoreProvider*, and
    are accessed by passing *AndroidKeyStore* as the `type` parameter of the respective
    factory methods. [Example 7-9](ch07.html#generating_and_accessing_rsa_keys_using
    "Example 7-9. Generating and accessing RSA keys using the AndroidKeyStoreProvider")
    shows how to generate and access RSA keys using the *AndroidKeyStoreProvider.*
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与其引入另一个 Android 特有的 API，不如通过标准 JCA API 来暴露密钥库访问，即 `java.security.KeyPairGenerator`
    和 `java.security.KeyStore`。这两个 API 都由新的 Android JCA 提供者 *AndroidKeyStoreProvider*
    支持，并通过将 *AndroidKeyStore* 作为相应工厂方法的 `type` 参数来访问。[示例 7-9](ch07.html#generating_and_accessing_rsa_keys_using
    "示例 7-9. 使用 AndroidKeyStoreProvider 生成和访问 RSA 密钥") 展示了如何使用 *AndroidKeyStoreProvider*
    生成和访问 RSA 密钥。
- en: Example 7-9. Generating and accessing RSA keys using the AndroidKeyStoreProvider
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-9. 使用 AndroidKeyStoreProvider 生成和访问 RSA 密钥
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First ➊ you create a `KeyPairGeneratorSpec` describing the keys you want to
    generate and the automatically created self-signed certificate each key is associated
    with. You can specify the key type (*RSA*, *DSA*, or *EC*) using the `setKeyType()`
    method, and key size with the `setKeySize()` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先 ➊ 你创建一个 `KeyPairGeneratorSpec`，描述你想要生成的密钥以及每个密钥所关联的自动创建的自签名证书。你可以使用 `setKeyType()`
    方法指定密钥类型（*RSA*、*DSA* 或 *EC*），并使用 `setKeySize()` 方法指定密钥大小。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Each `PrivateKeyEntry` managed by a `KeyStore` object needs to be associated
    with a certificate chain. Android automatically creates a self-signed certificate
    when you generate a key, but you can replace the default certificate with one
    signed by a CA later.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个由 `KeyStore` 对象管理的 `PrivateKeyEntry` 都需要与一个证书链相关联。Android 在生成密钥时会自动创建一个自签名证书，但你可以稍后将默认证书替换为由
    CA 签名的证书。*'
- en: Next, you initialize a `KeyPairGenerator` ➋ with the `KeyPairGeneratorSpec`
    instance and then generate the keys by calling `generateKeyPair()` ➌.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用`KeyPairGenerator` ➋ 和 `KeyPairGeneratorSpec` 实例进行初始化，然后通过调用 `generateKeyPair()`
    ➌ 来生成密钥。
- en: The most important parameter is the alias. You pass the alias to `KeyStore.getEntry()`
    ➍ in order to get a reference to the generated keys later. The returned key object
    does not contain the actual key material; it is only a pointer to a hardware-managed
    key object. Therefore, it is not usable with cryptographic providers that rely
    on key material being directly accessible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的参数是别名。你将别名传递给`KeyStore.getEntry()` ➍，以便稍后获取生成的密钥的引用。返回的密钥对象不包含实际的密钥材料；它只是指向硬件管理的密钥对象的指针。因此，它不能与依赖密钥材料直接访问的加密提供者一起使用。
- en: If the device has a hardware-backed keystore implementation, keys will be generated
    outside the Android OS and won’t be directly accessible even to the system (or
    *root*) user. If the implementation is software only, keys will be encrypted with
    a per-user key-encryption master key derived from the unlock PIN or password.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备有硬件支持的密钥存储实现，密钥将会在 Android 操作系统之外生成，并且即使是系统（或*root*）用户也无法直接访问这些密钥。如果实现仅为软件，则密钥将使用从解锁
    PIN 或密码派生的每用户密钥加密主密钥进行加密。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As you’ve learned in this chapter, Android has a system credential store that
    can be used to store credentials for built-in features such as Wi-Fi and VPN connectivity,
    as well as for use by third-party apps. Android 4.3 and later versions provide
    standard JCA APIs for generating and accessing app-private keys, which makes it
    easier for non-system apps to store their keys securely without needing to implement
    key protection themselves. Hardware-backed key storage, which is available on
    supported devices, guarantees that even apps with *system* or *root* privileges
    cannot extract the keys. Most current hardware-backed credential storage implementations
    are based on ARM’s TrustZone technology and do not use dedicated tamper-resistant
    hardware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中学到的，Android 有一个系统凭据存储，可以用于存储 Wi-Fi 和 VPN 连接等内置功能的凭据，以及供第三方应用使用。Android
    4.3 及更高版本提供了标准的 JCA API，用于生成和访问应用私有密钥，这使得非系统应用可以更加容易地安全地存储它们的密钥，而无需自己实现密钥保护。硬件支持的密钥存储在支持的设备上提供，保证即使是拥有*系统*或*root*权限的应用也无法提取密钥。大多数当前基于硬件的凭据存储实现基于
    ARM 的 TrustZone 技术，并且不使用专用的防篡改硬件。
