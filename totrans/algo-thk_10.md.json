["```\n14 4\n1 3 4 2 1 1 2 4 1 2 2 4 1 1\n3\n3 11\n8 11\n5 6\n```", "```\nint random_piece(int left, int width) {\n❶ return (rand() % width) + left;\n}\n```", "```\nint lowest_index(int pieces[], int num_pieces, int at_least) {\n  int low, high, mid;\n❶ low = 0;\n➋ high = num_pieces;\n➌ while (high - low >= 1) {\n     mid = (low + high) / 2;\n     if (pieces[mid] < at_least)\n       low = mid + 1;\n     else\n       high = mid;\n  }\n➍ return low;\n}\n```", "```\nint num_in_range(int pieces[], int num_pieces, int left, int right) {\n❶ int left_index = lowest_index(pieces, num_pieces, left);\n➋ int right_index = lowest_index(pieces, num_pieces, right + 1);\n➌ return right_index - left_index;\n}\n```", "```\nvoid solve(int yokan[], int *pieces_for_flavor[],\n           int num_of_flavor[], int left, int right)\n```", "```\nvoid solve(int yokan[], int *pieces_for_flavor[],\n           int num_of_flavor[], int left, int right) {\n  int attempt, rand_piece, flavor, result;\n  int width = right - left + 1;\n❶ double threshold = width / 3.0;\n   int first_flavor = 0;\n\n➋ for (attempt = 0; attempt < NUM_ATTEMPTS; attempt++) {\n  ➌ rand_piece = random_piece(left, width);\n     flavor = yokan[rand_piece];\n  ➍ result = num_in_range(pieces_for_flavor[flavor],\n                           num_of_flavor[flavor], left, right);\n  ➎ if (result >= 2 * threshold) {\n       printf(\"YES\\n\");\n       return;\n     }\n ➏ if (result >= threshold)\n    ❼ first_flavor = flavor;\n  }\n\n  if (first_flavor == 0) {\n    printf(\"NO\\n\");\n    return;\n  }\n\n❽ for (attempt = 0; attempt < NUM_ATTEMPTS; attempt++) {\n     rand_piece = random_piece(left, width);\n     flavor = yokan[rand_piece];\n  ❾ if (flavor == first_flavor)\n       continue;\n     result = num_in_range(pieces_for_flavor[flavor],\n                           num_of_flavor[flavor], left, right);\n     if (result >= threshold) {\n       printf(\"YES\\n\");\n       return;\n     }\n  }\n\n  printf(\"NO\\n\");\n}\n```", "```\n#define NUM_ATTEMPTS 60\n```", "```\n#define MAX_FLAVORS 200000\n\nvoid init_flavor_arrays(int yokan[], int num_pieces,\n                        int *pieces_for_flavor[]) {\n❶ static int cur_of_flavor[MAX_FLAVORS + 1];\n   int i, flavor, j;\n   for (i = 1; i <= num_pieces; i++) {\n     flavor = yokan[i];\n  ➋ j = cur_of_flavor[flavor];\n     pieces_for_flavor[flavor][j] = i;\n     cur_of_flavor[flavor]++;\n   }\n}\n```", "```\n#define MAX_PIECES 200000\n\nint main(void) {\n  static int yokan[MAX_PIECES + 1];\n  static int num_of_flavor[MAX_FLAVORS + 1];\n  static int *pieces_for_flavor[MAX_FLAVORS + 1];\n  int num_pieces, num_flavors, i, num_queries, l, r;\n❶ srand((unsigned) time(NULL));\n   scanf(\"%d%d\", &num_pieces, &num_flavors);\n\n➋ for (i = 1; i <= num_pieces; i++) {\n     scanf(\"%d\", &yokan[i]);\n     num_of_flavor[yokan[i]]++;\n   }\n\n➌ for (i = 1; i <= num_flavors; i++) {\n  ➍ pieces_for_flavor[i] = malloc(num_of_flavor[i] * sizeof(int));\n     if (pieces_for_flavor[i] == NULL) {\n       fprintf(stderr, \"malloc error\\n\");\n       exit(1);\n     }\n  }\n\n➎ init_flavor_arrays(yokan, num_pieces, pieces_for_flavor);\n\n  scanf(\"%d\", &num_queries);\n for (i = 0; i < num_queries; i++) {\n    scanf(\"%d%d\", &l, &r);\n  ➏ solve(yokan, pieces_for_flavor, num_of_flavor, l, r);\n  }\n\n  return 0;\n}\n```", "```\nint main(void) {\n  int n, cap_num, bottle_num, result;\n❶ scanf(\"%d\", &n);\n  for (cap_num = 1; cap_num <= n; cap_num++)\n    for (bottle_num = 1; bottle_num <= n; bottle_num++) {\n   ➋ printf(\"0 %d %d\\n\", cap_num, bottle_num);\n   ➌ scanf(\"%d\", &result);\n      if (result == 0) {\n     ➍ printf(\"1 %d %d\\n\", cap_num, bottle_num);\n        break;\n      }\n   }\n   return 0;\n}\n```", "```\n#define MAX_N 10000\n\nint main(void) {\n  int n, i;\n❶ int cap_nums[MAX_N], bottle_nums[MAX_N];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n ➋ cap_nums[i] = i + 1;\n ➌ bottle_nums[i] = i + 1;\n  }\n  solve(cap_nums, bottle_nums, n);\n  return 0;\n}\n```", "```\nvoid *malloc_safe(int size) {\n  char *mem = malloc(size);\n  if (mem == NULL) {\n    fprintf(stderr, \"malloc error\\n\");\n    exit(1);\n }\n  return mem;\n}\n\nvoid solve(int cap_nums[], int bottle_nums[], int n) {\n  int small_count, big_count, cap_num, i, result, matching_bottle;\n  int *small_caps = malloc_safe(n * sizeof(int));\n  int *small_bottles = malloc_safe(n * sizeof(int));\n  int *big_caps = malloc_safe(n * sizeof(int));\n  int *big_bottles = malloc_safe(n * sizeof(int));\n  if (n == 0)\n    return;\n\n  small_count = 0;\n  big_count = 0;\n\n❶ cap_num = cap_nums[0];\n\n➋ for (i = 0; i < n; i++) {\n    printf(\"0 %d %d\\n\", cap_num, bottle_nums[i]);\n    scanf(\"%d\", &result);\n  ➌ if (result == 0) {\n      printf(\"1 %d %d\\n\", cap_num, bottle_nums[i]);\n      matching_bottle = bottle_nums[i];\n    } else if (result == -1) {\n      big_bottles[big_count] = bottle_nums[i];\n      big_count++;\n    } else {\n      small_bottles[small_count] = bottle_nums[i];\n      small_count++;\n    }\n  }\n\n  small_count = 0;\n  big_count = 0;\n➍ for (i = 0; i < n; i++) {\n    printf(\"0 %d %d\\n\", cap_nums[i], matching_bottle);\n    scanf(\"%d\", &result);\n    if (result == -1) {\n      small_caps[small_count] = cap_nums[i];\n      small_count++;\n    } else if (result == 1) {\n      big_caps[big_count] = cap_nums[i];\n      big_count++;\n    }\n  }\n➎ solve(small_caps, small_bottles, small_count);\n➏ solve(big_caps, big_bottles, big_count);\n}\n```", "```\ncap_num = cap_nums[0];\n```", "```\ncap_num = cap_nums[rand() % n];\n```", "```\n#define N 10\n\nvoid *malloc_safe(int size) {\n  char *mem = malloc(size);\n  if (mem == NULL) {\n    fprintf(stderr, \"malloc error\\n\");\n    exit(1);\n }\n  return mem;\n}\n\nvoid swap(int *x, int *y) {\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nvoid quicksort(int values[], int n) {\n  int i, small_count, big_count, pivot_index, pivot;\n  int *small_values = malloc_safe(n * sizeof(int));\n  int *big_values = malloc_safe(n * sizeof(int));\n  if (n == 0)\n    return;\n\n  small_count = 0;\n  big_count = 0;\n\n❶ pivot_index = rand() % n;\n➋ swap(&values[0], &values[pivot_index]);\n   pivot = values[0];\n\n➌ for (i = 1; i < n; i++) {\n     if (values[i] > pivot) {\n       big_values[big_count] = values[i];\n       big_count++;\n     } else {\n       small_values[small_count] = values[i];\n       small_count++;\n     }\n  }\n\n  quicksort(small_values, small_count);\n  quicksort(big_values, big_count);\n\n➍ for (i = 0; i < small_count; i++)\n    values[i] = small_values[i];\n➎ values[small_count] = pivot;\n➏ for (i = 0; i < big_count; i++)\n    values[small_count + 1 + i] = big_values[i];\n}\n\nint main(void) {\n  static int values[N] = {96, 61, 36, 74, 45, 60, 47, 6, 95, 93};\n  int i;\n srand((unsigned) time(NULL));\n\n  quicksort(values, N);\n\n  for (i = 0; i < N; i++)\n    printf(\"%d \", values[i]);\n  printf(\"\\n\");\n  return 0;\n}\n```"]