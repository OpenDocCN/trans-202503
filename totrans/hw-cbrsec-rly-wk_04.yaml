- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Password Thefts and Other Account Access Tricks
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use access control procedures to ensure that only authorized people can
    access a system, open a file, or run a piece of software. It’s part of an organization’s
    everyday management; every person who works for a business deals with it in some
    form or fashion, whether by logging into an email account or sharing a file with
    a client. To better manage such a sizable and critical topic, the security world
    often divides access control into three categories: authentication, authorization,
    and accounting.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore how various methods of authentication and authorization
    can keep your systems safe, and how we use accounting to keep track of everything
    done in a system. Throughout the chapter, you’ll also learn how black hats circumvent
    access control.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Authentication* is verifying that someone is who they say they are. Let’s
    say a knight comes to your castle’s gate. He could be an enemy knight or a friendly
    knight, depending on his shield’s crest. To authenticate the knight, you send
    a squire to check the knight’s crest. If he has a friendly crest, you let him
    in. If he has an enemy crest, you keep the gate closed.'
  prefs: []
  type: TYPE_NORMAL
- en: Cybersecurity professionals meticulously distinguish authentication from a related
    concept, *identification*. You might use some form of identification to state
    who you’re trying to authenticate as, whereas authentication proves you’re actually
    that person. For example, when you enter a username and password, the username
    identifies you. But the username alone doesn’t prove you’re truly that user. By
    entering the password, you validate that you’re the user associated with that
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can authenticate a person or system in many ways: using a password, using
    DNA, or even by knowing the way a person speaks. Each of these authentication
    methods has its own strengths and drawbacks. To better classify different methods,
    cybersecurity specialists group them into the following five types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type 1: Something You Know'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Type 1, something you know, is typically a piece of information you’ve memorized.
    The most widely used version is the password, because passwords are incredibly
    easy to set up and maintain, and a vast array of systems can use them. Consider
    how many times a day you use passwords to access accounts or systems.
  prefs: []
  type: TYPE_NORMAL
- en: But passwords aren’t the only form of Type 1 authentication. Another common
    one is the security question, also known as the *cognitive password*. Typically,
    you’d use one of these to reset a regular password when you forget it. The answer
    to the question the system asks is a response that only you would know, such as
    your mother’s maiden name or the street you grew up on. However, with the spread
    of social media, it’s become easier for black hats to discover the answers to
    these questions and use them to reset your password.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, Type 1 is the easiest form of authentication to break, because it’s
    not necessarily unique or complex. Think of the passwords you use, and answer
    these questions honestly. How many passwords do you have that are:'
  prefs: []
  type: TYPE_NORMAL
- en: Only used in one place?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 12 characters long?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made up of lowercase and uppercase letters, numbers, and symbols?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of your passwords fail to meet the preceding requirements, they’re susceptible
    to attack. Adversaries use a few clever techniques to try to break passwords,
    including brute force. To brute-force a password, a computer system automatically
    runs through every combination of possible password characters, and then attempts
    to use them to log in to a system. Often, this process takes mere hours to accomplish
    a guessing task that a person would waste months doing manually. Although this
    technique might seem time-consuming, given enough time brute-force attacks always
    work, even if it takes years to go through every possible combination. The shorter
    the password, the easier it is to crack. In addition, you never know when an attacker
    might get lucky on the first try.
  prefs: []
  type: TYPE_NORMAL
- en: Another attack adversaries use is the *dictionary attack*. This attack relies
    on common words or combinations to shorten the amount of time it takes to brute-force
    a password. For example, one of the top passwords, year after year, is *qwerty*
    (the letters on the top row of a standard US keyboard). A dictionary attack might
    run through all the passwords stored in a file, including *qwerty* and some other
    common ones, narrowing down the combinations the attacker must try. The less complex
    a password is, the easier it is to break using a dictionary attack.
  prefs: []
  type: TYPE_NORMAL
- en: That said, black hats typically don’t have to brute-force a password or use
    a dictionary attack. It’s much easier to get the user to tell them the password.
    Using social engineering, or by simply looking for the password on a sticky note
    at a person’s desk, attackers constantly get people to reveal their passwords.
    Once they have it, there is nothing to stop attackers from using it. Type 1 authentication
    doesn’t use additional checks to confirm the person entering the password is who
    they claim to be; it merely reads the password, and if it’s correct, lets them
    in. So although Type 1 authentication might be cheap and easy to deploy, it’s
    not the most secure, which is why we rely on other types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type 2: Something You Have'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Something you have is an entity, whether it’s a physical object or a digital
    artifact on a computer, that you must present to authenticate to the system. The
    object, which is unique to you, usually provides a code or key to the system.
    There are many ways to implement Type 2 authentication; examples include smart
    cards, key generators, and digital certificates, which you’ll learn more about
    in Chapter 9.
  prefs: []
  type: TYPE_NORMAL
- en: Type 2 authentication is stronger than Type 1, because the attacker needs to
    steal the object to bypass authentication, which is much harder to do than guessing
    a password. But Type 2 is also more complex and expensive to implement, which
    is why it’s not as common. The reason is that Type 2 requires special equipment
    and additional hardware. For example, if you added a key card reader system to
    log in to your computer, not only would you have to purchase, install, and maintain
    the reader, but you’d have to purchase key cards for every user, as well as keep
    additional cards on hand for when someone inevitably loses one. However, over
    the last several years, new ways of implementing Type 2 authentication have made
    it much cheaper to use. The most familiar of these is the text verification code.
  prefs: []
  type: TYPE_NORMAL
- en: Systems that use text verification codes usually prompt you to enter a phone
    number when you first set up an account. To access your account later, the system
    asks you for permission to send a verification code to your phone. Once you agree,
    the code is sent by text message (or phone call, although this isn’t as common).
    You then enter this code in a field on the system or app. This process proves
    that you’re the owner of the account, because theoretically, only you have access
    to that phone number.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most secure methods of Type 2 authentication is the smart card.
    In a system that uses smart cards, each person receives a unique card. On the
    card is a chip that contains an encryption key (we’ll discuss these keys in Chapter
    9). When you slide the card through a chip reader, the reader checks the key and
    authenticates you. No card? No key? No login. The use of an encryption key instead
    of a code makes it an even stronger authentication, because it’s nearly impossible
    to guess the key. This method has become more common over the years: chips have
    been used on credit cards since the mid-1990s but didn’t become ubiquitous in
    the United States until 2015\. [Figure 5-1](#figure5-1) shows an example of a
    *Common Access Card* *(CAC**)*, a type of smart card the US federal government
    and military use to access desktops and buildings.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/501287c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: A Navy Common Access Card'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Type 2 authentication object doesn’t have to be physical. It can also be
    a digital entity, such as a *digital certificate*: a piece of data stored on a
    computer that identifies and authenticates it when it tries to access another
    system. For example, when a system queries a database for information, that system
    might send the database a digital certificate to prove it’s authorized to make
    the query. The certificate is stored on the hardware, sometimes in a special chip
    known as a *Trusted Platform Module (TPM)*. There are many layers of security
    between the TPM and the other hardware on the system, making it extremely difficult
    for a black hat to access the certificate without having physical access to the
    machine. We’ll discuss certificates and encryption in more detail in Chapter 9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type 3: Something You Are'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although Type 1 and Type 2 authentication provide a lot of protection, they
    both have the same drawback: neither can be uniquely tied to a single person,
    making it possible for someone else to use their credentials. This is where Type
    3 authentication excels. Type 3 systems use a person’s unique biometric signature
    as the authentication method.'
  prefs: []
  type: TYPE_NORMAL
- en: A *biometric* is some physical or behavioral attribute of a person. The most
    common example of a biometric used for authentication is a fingerprint, but others
    include retina scans, facial recognition, voice, or even DNA. A biometric might
    also be a behavior, such as the way a person walks, or their signature. In theory,
    these attributes are universally unique, meaning no other person in the world
    will have the same attribute as another. [Table 5-1](#table5-1) lists some commonly
    used biometrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-1: Types of Biometrics'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Biometric type** | **Scanning data** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Fingerprint scanner | The swirls on the pads of fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Hand scanner | Unique patterns on fingers and palm |'
  prefs: []
  type: TYPE_TB
- en: '| Iris scanner | Shape of eyeball |'
  prefs: []
  type: TYPE_TB
- en: '| Retina scanner | Pattern of blood vessels at back of eyeball |'
  prefs: []
  type: TYPE_TB
- en: '| Face scanner | Pattern and shape of face |'
  prefs: []
  type: TYPE_TB
- en: To set up a biometric system, the people using it must provide their biometric
    signatures, which are stored in a database. For example, if your workplace wanted
    to use fingerprint scanners on all doors, it would have to scan your fingertips.
    When you used the scanner at the door, the signature gathered would be compared
    to the signature stored in the database. If they’re the same, you’d be allowed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a tricky process, because every scanner has a different sensitivity
    level. For example, if the back door’s scanner is too sensitive, it might deny
    you entry, even though it should have allowed you access via that door. The rate
    at which this happens is known as the *false rejection rate* *(FRR**)*. On the
    other side of the scale, if the scanner’s sensitivity is too low, it might grant
    access to someone who isn’t in the database. The rate at which this occurs is
    known as the *false acceptance rate* *(FAR**)*. People who design these systems
    must figure out how to set the scanner in a way that minimizes both the FRR and
    the FAR. We call this sweet spot the *crossover error rate* *(CER**)*. The need
    to find the CER makes installing a biometric system a bit of a trial-and-error
    process. Also, the type of scanner will affect the system’s success, because simpler
    scanners don’t create as complete or complex a signature as more sophisticated
    scanners.
  prefs: []
  type: TYPE_NORMAL
- en: Type 3 is the strongest form of authentication. Despite what movies would have
    you believe, it’s extremely difficult to impersonate a biometric signature, especially
    if you’re using a high-quality scanner. Some of the scanners currently in use
    can even detect a heartbeat in a finger to determine whether it’s connected to
    a living person. This means that to get the signature, the correct person must
    use the scanner. This severely reduces an adversary’s ability to break into the
    system or steal credentials, the way they might with Type 1 or Type 2 authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to a high-quality scanner, these systems need large databases in
    which to store the signatures. These requirements make biometrics considerably
    more expensive to implement. Even though scanners have become cheaper, the ones
    placed into mobile devices don’t provide the same accuracy as those used as stand-alone
    systems. This leads to the second issue with biometrics: bad scanning. Because
    a signature is extremely unique, any change to it can lead to an FRR error. For
    example, if you burn the finger you use for a fingerprint scanner, the scanner
    might no longer work. Even doing something like shaving a beard can confuse facial
    scanners.'
  prefs: []
  type: TYPE_NORMAL
- en: Biometrics can be difficult to use and adjust, so it’s important to have a backup
    authentication system should the biometric system fail. For example, on a mobile
    phone with a fingerprint or facial scanner, the authentication system usually
    provides an option to enter a pin number if the scanner doesn’t recognize the
    person. This way, you can adjust the biometric scanner’s sensitivity over time
    without fear that it will lock you out of the system you’re trying to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types 4 and 5: Something You Do and Somewhere You Are'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The other two types of authentication typically supplement one of the other
    forms of authentication rather than acting as stand-alone methods. They serve
    as part of multi-factor authentication (discussed in more detail next).
  prefs: []
  type: TYPE_NORMAL
- en: Something you do (Type 4) is an action you must take to authenticate. For example,
    to get into a mad scientist’s secret lab, you might have to pull a certain book
    on a bookcase to reveal the entrance. Only the people who know which book to pull
    will be able to authenticate. Another example of Type 4 is the *CAPTCHA*, which
    is a test that proves you’re a human, not a script designed to automatically log
    in to an account. By choosing the right pictures, such as images of cars from
    a group of photos, you prove that you’re a real person. The Type 4 authentication
    method doesn’t provide adequate protection on its own, however, because anyone
    can perform the action, as long as they know what needs to be done. (In the mad
    scientist’s case, an adversary could simply watch through a cracked door or over
    someone’s shoulder to see what choices a person makes to authenticate.)
  prefs: []
  type: TYPE_NORMAL
- en: Somewhere you are (Type 5) is the location of a person when an authentication
    is made. If the person isn’t in the right location, the authentication fails.
    On its own, Type 5 falls short in the same way as Type 4; there’s just no way
    to verify that the individual in the location is the right person without using
    other authentication methods. However, when paired with different authentication
    types, Type 5 provides additional protection from black hats trying to access
    an account. For example, if you register your account as being in Little Rock,
    Arkansas, and someone tries to log in to the account from Hong Kong, the system
    can recognize that it’s probably not you and send an alert. Although it’s possible
    to spoof your location on the internet (more on that topic in Chapter 6), this
    protection adds another layer of defense that the attacker must bypass to access
    the account. The more layers in the way, the harder it is for an adversary to
    succeed in breaking into the system.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Factor Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using more than one type of authentication is called *multi-factor authentication*.
    It can help make up for the weaknesses of any one type of authentication. Recall
    the problems with Type 1 authentication. Something you know is guessable, can
    be written down or transferred to other people, and anyone can use it regardless
    of whether they created it. But if we add Type 2 authentication to a system that
    already uses Type 1, we fix many of those problems. Because they must have some
    additional item to authenticate, such as a verification code from a text message,
    an attacker can’t just guess the password to get in.
  prefs: []
  type: TYPE_NORMAL
- en: You must have multi-factor authentication if you want to protect your system
    from the modern techniques black hats use. The most common multi-factor authentication
    strategy today is adding a phone number or email address to an account and having
    a verification code sent to it when you attempt to log in. You’re then prompted
    to enter this code after you enter your password. This might seem like an unnecessary
    nuisance to get into your social media account, but as discussed previously, attackers
    can obtain passwords in many ways. Having multi-factor authentication makes this
    more difficult for adversaries, and many times, they’ll give up once they run
    into obstacles. At the very least, it provides extra time for you to react to
    the adversary’s actions before they break into the account.
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra defenses is a security strategy known as *defense in depth*. Basically,
    the more barriers you put up, the harder it is for an attacker to easily gain
    access. This not only helps supplement weaknesses found in individual defenses
    (like the weaknesses in guessable passwords, for example), but also gives white
    hats time to become aware of, learn about, and respond to the black hat activity.
    As discussed in Chapter 1, awareness is poison to attackers; the more layers you
    construct, the more likely it is that white hats will be alerted to the nefarious
    activity and stop it.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once users authenticate, they must be *authorize**d* to do certain actions.
    The friendly knight from the earlier example doesn’t necessarily get into the
    tower where the princess lives just because he’s friendly. Instead, he might be
    authorized to enter the castle but not the tower. As with authentication, authorization
    is based on who you are in an organization. A friendly knight and the king might
    be able to enter the castle, but only the king, princess, and princess’s attendants
    might be authorized to enter the princess’s tower.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization is vitally important. To use a more modern example, if your company
    has two engineers authorized to make changes to the web server, it can be difficult
    to track who is actually making changes. When an attacker breaks in or a malicious
    action occurs, finding the source could be more difficult. If only one engineer
    is authorized to make changes to the web server, you know exactly who is responsible
    for any changes or even any malicious actions that might happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *security kernel* program, which is part of an operating system, typically
    enforces authorization for changes made on that system. How the security kernel
    enforces authorization depends on the type of access control scheme in use. There
    are five common access control schemes: mandatory access control (MAC), rule-based
    and role-based access control (both commonly abbreviated as RBAC, though I’ll
    use the full names to avoid confusion), attribute-based access control (ABAC),
    and discretionary access control (DAC). Let’s examine each in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory Access Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MAC is a centralized system in which a central authority strictly enforces access
    control. MAC provides a high level of control over who can access files, systems,
    or software, but it doesn’t allow a lot of flexibility. The system tests all attempts
    to access a resource against a central security policy to determine whether to
    grant access. If the type of access requested doesn’t exactly fit into the policy,
    it’s denied. A single administrator or group of administrators controls the policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create such a policy, the administrators might use labels to determine what
    sort of authorization a person should need to access each resource. For example,
    the military uses a system of classifications with three base categories: confidential,
    secret, and top secret. Any new file gets assigned a classification based on the
    policy. If a document is given top-secret classification, only people who are
    authorized at the top-secret clearance level can access it, and a person with
    secret clearance can’t override the system to view top-secret documents.'
  prefs: []
  type: TYPE_NORMAL
- en: Rule-Based Access Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rule-based access control uses specific rules to determine what type of authorization
    to grant. This is an incredibly rigid system. Variations in context matter little,
    and if no rule matches the access request, most systems use an *implicit deny*,
    meaning they automatically reject the action. This helps prevent the rule-based
    access control policy from becoming too bloated. It’s much easier to define what
    you want to happen in a system rather than trying to keep track of everything
    you don’t want to happen. That said, this system forces the administrator to map
    every possible authorized action, or people will likely get denied. In certain
    contexts, such as complex environments with many requirements, it might not be
    feasible to use a rule-based access control system. Unlike MAC, a rule-based scheme
    must separately set rules on every asset.
  prefs: []
  type: TYPE_NORMAL
- en: A great example of rule-based access control is file permissions. Most operating
    systems grant access to files based on rules that take into account who is accessing
    the file and what actions they’re authorized to do. Each file has its own set
    of these rules, which the system reads to determine whether to grant access. For
    example, a system administrator might be able to read and write (meaning *change*)
    a system file, whereas a standard user would only be able to read it.
  prefs: []
  type: TYPE_NORMAL
- en: Role-Based Access Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Role-based access control uses a user’s role to determine their access to the
    system. Unlike with rule-based access control, the roles apply across the entire
    system, not to individual objects like files. For example, if you work in human
    resources, you might be given the role of Human Resources Officer. This means
    that when you log in to your computer, you can access the human resources department’s
    shared folder and log in to the employee record database.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control provides a lot more flexibility than either MAC or
    rule-based access control. The system administrator can create new roles as needed
    to provide the necessary level of access. This method also makes it much easier
    to manage the access of a large group of people. For example, every person working
    in a call center might need access to a set of resources, such as a list of customer
    accounts. By creating the role Call Center Employee, the system administrator
    can easily give every call center employee the authorization to do their job without
    having to go into the system and individually grant access to every resource.
  prefs: []
  type: TYPE_NORMAL
- en: The main drawback of role-based access control is that it often leads to *privilege
    creep*. Privilege creep occurs when an individual or group gradually gets more
    authorizations, until they have permission to do more than what their job requires.
    This becomes a problem when the controls can no longer keep an account from doing
    something it’s not actually authorized to do. For example, you might take over
    a role in your company temporarily while a new person is hired. If the authorization
    granted by that role remains once the new person joins, you might have access
    to resources you shouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: The roles can also be too broad. To guarantee that a large subset of people
    fit a role, each role might have a wide range of access. For example, the administrator
    role often receives a full set of permissions, whether or not that user needs
    all administrator functions. Or a human resources employee might not necessarily
    need to see every document pertaining to an employee. They might only be a recruiter,
    so they don’t need access to current employee files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such broad access roles make it easier for a black hat to gain access to files,
    accounts, or systems. To counteract privilege creep, security professionals usually
    apply the concepts of least privilege and separation of duties. Someone who has
    *least privilege* has only the privileges necessary to do their job. For example,
    a graphic designer might be able to update pictures on a website but not log in
    to the administrator side and change the website name. A task with *separation
    of duties* requires multiple people to finish it. For instance, two people might
    be needed to create a check and pay a vendor: someone to draft the check and another
    to sign it once they’ve verified it’s a valid payment.'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-Based Access Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ABAC is similar in flexibility to role-based access control but helps alleviate
    the drawbacks of privilege creep. Essentially, ABAC uses descriptors (aptly named
    attributes) to determine what sort of access a person or system needs. You can
    think of each attribute as its own mini-role. When a person or system tries to
    access a resource, the system reviews their attributes to authorize access.
  prefs: []
  type: TYPE_NORMAL
- en: This scheme solves the human resources problem mentioned earlier. With an ABAC
    system, a member of this department would receive the attribute *human resources*
    on their account. However, if they’re also a recruiter, they would have the attribute
    *recruiter* as well. The human resources attribute allows them to read general
    human resource documents, but because they also have the recruiter attribute,
    they can’t read the files of current employees.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes can be combined in many ways, allowing you to fine-tune access control
    while still maintaining the broadness and flexibility of role-based access control.
    Privilege creep remains a possibility; however, it’s much easier to protect against
    it with ABAC, because it’s possible to severely limit the access of attributes
    without making the system cumbersome, like a strict MAC system.
  prefs: []
  type: TYPE_NORMAL
- en: Discretionary Access Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DAC is the most flexible and least secure of all the access control systems.
    Under DAC, whoever owns the object, whether it’s a file, application, or system,
    decides who has access to it. This creates plenty of flexibility, because the
    owner can grant and deny access as necessary. But this system is also insecure,
    because no central authority decides how access is granted or denied, making it
    more likely for someone to receive unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: A great example of DAC is in document services, such as OneDrive or Google Drive.
    When you create a document in one of these services, it’s placed in your personal
    account. You can then grant access to that document by sharing it with a third
    party, like a co-worker who is working on the same project. No system tells you
    who can or can’t receive the document. It’s up to you to decide who you share
    it with, and once they no longer need access, you can remove them from the share.
  prefs: []
  type: TYPE_NORMAL
- en: This scheme can lead to issues; for example, if you enter the wrong email address
    or share the file with an employee in another department who doesn’t need to see
    the document. Therefore, we typically only use DAC for very limited applications,
    like sharing documents, rather than as a full access control system like MAC.
  prefs: []
  type: TYPE_NORMAL
- en: Accounting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Accounting* is making sure that every action taken on a system or network
    generates a record. Although accounting doesn’t protect an account or system from
    direct access by an attacker, it’s still vitally important to maintaining an organization’s
    security. If you’re unable to verify the activity happening in an account or system
    at any given time, you won’t be able to know whether you’ve maintained security.
    In addition, if an incident does happen, it can be difficult to find the attack
    details and remove the adversary from the environment. Therefore, it’s important
    to maintain accounting using a twofold process: enabling logging and performing
    routine auditing.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logging is a catchall term for capturing events that happen on a system during
    its operation. Each system has its own logging method. For example, if you’re
    logging an application, the logs would include records of exactly what the application
    code did when the application ran. If you’re logging an account, it would include
    a timeline of when the account signed in, from where, and what was accessed. Most
    logging follows similar conventions when it processes events. This includes the
    level of severity, what information is gathered, and where that log is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Events in logs are usually broken down into levels to indicate an issue’s severity.
    The standard ranking method is known as *Syslog*, which starts at 7 as the least
    severe and ends with 0 as the most severe. [Table 5-2](#table5-2) lists each level
    and its associated severity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-2: Log Severity Levels'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Severity** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Emergency | System is unusable. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Alert | Action must be taken immediately. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Critical | Critical conditions. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Error | Error conditions. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Warning | Warning conditions. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Notice | Normal but requires special handling. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Informational | Informational messages. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Debug | Debugging messages. |'
  prefs: []
  type: TYPE_TB
- en: 'The most important events, at level 0, indicate that system hardware had a
    failure that caused it to break down. Level 1 indicates a failure that is causing
    the system to run improperly, for example, because it crashed. Level 2 is used
    for failures that are causing operations within the system to malfunction, such
    as an application crash, despite the system continuing to run. Level 3 includes
    conditions that cause an error but don’t necessarily disrupt operations; for example,
    trying to access a document that doesn’t exist anymore might result in an error,
    but that error probably won’t crash the computer. Levels 4 and 5 provide information
    on events that might need an additional look but aren’t generally considered security
    risks. An example might be a user failing to log in to their account once in an
    hour. Level 6 events provide information about what the system did: for example,
    if it opened a file or made an authorized connection. We use level 7 only in rare
    cases when we’re trying to find a problem with a system’s underlying operations.
    Usually, level 7 isn’t turned on by default, and you should only use it with extreme
    caution. Logging generates many entries, and it’s possible to fill up log storage
    with level 7 events alone.'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you should log as much information as possible while still maintaining
    the information’s usefulness. If you log too little, you’ll miss events that might
    help you understand an incident. If you log too much, you’ll be drowning in data
    that might conceal key information you need to find quickly. Many logging agents
    allow you to filter out events to make the logs more digestible. You could filter
    out events at level 6, such as successful logins, to make other events, like a
    failed login attempt, easier to find. But you must carefully tune this filtering
    to avoid missing malicious events. (I discuss what those malicious events might
    look like later in the chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you must decide how long to keep the logs. Organizations normally
    make this decision by considering the type of log, how much information the log
    contains, how much storage is available, if there are any legal or compliance
    requirements, and other factors. The primary concern is whether you’ll be able
    to determine what happened if you need to go back to a certain event or date.
    For example, if you find out that an employee’s computer was breached, you’ll
    need to access all the activity on your network from that computer on that day
    to determine what the black hat did.
  prefs: []
  type: TYPE_NORMAL
- en: Most organizations used to keep logs for 90 days, but many have now transitioned
    to yearly logs as storage becomes less expensive. They usually store their logs
    on large servers with solid-state hard drives to best protect them against problems
    that might take the system offline or erase its data. Whichever media you choose,
    you should store it offsite. That way, the logs are more likely to survive a disaster,
    such as a ransomware infection, at the main site. Cloud services also offer the
    ability to stores logs for a customer.
  prefs: []
  type: TYPE_NORMAL
- en: No person should have write access—the ability to change a log—or the ability
    to remove a log from the system. The entire point of logging is that it’s an accurate
    account of every event that’s happened on a system or network. If a person can
    modify those events, the log becomes less trustworthy. Making the logs uneditable
    helps eliminate inside threats.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as important as capturing logging information is looking through the information.
    We *audit* not only to find malicious activity, but also for routine maintenance.
    For auditing to work, we can’t do it only when we have a problem. We need to catch
    problems as soon as they happen, before a hardware failure, a software bug, or
    a black hat compromise does significant damage to our systems.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, every event on a system should produce a log. Deciding
    how many of those logs to audit can be tricky. If you audit too much, you’ll waste
    time slogging through normal events. If you audit too little, you’ll miss key
    indicators of malicious activity. Instead, you’ll need to prioritize your organization’s
    critical assets. For example, it’s not reasonable to audit every workstation in
    your organization, but you could prioritize critical servers on your network to
    check every day.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you narrow down the critical assets, there are still likely thousands
    of events that you might have to review. To help narrow those down even more,
    the next step in auditing is to set up alerts about important events. This is
    where Syslog can come in handy. By using the various levels of severity in the
    Syslog standard, you can have high-level alerts sent directly to you. Events such
    as remote logins, password changes, and account lockouts could also generate alerts.
  prefs: []
  type: TYPE_NORMAL
- en: But setting alerts might still not be enough to capture malicious activities
    in your organization, because attackers have become adept at hiding. Instead of
    brazenly attacking a network or system, adversaries will combine different small
    attacks that culminate in a bigger compromise. They’re also incredibly patient,
    slowly trying different attacks before finally finding a way in. For example,
    instead of brute-forcing a login by trying several passwords in quick succession,
    adversaries might try one password every six hours. Once they find the correct
    password, they might wait weeks or even months before they log in to the account.
    Then they’ll sit and wait, watching internal network traffic or activities on
    the system as they gather information to use in a final big attack that infects
    a database with ransomware.
  prefs: []
  type: TYPE_NORMAL
- en: This type of attack methodology is difficult to detect through alerting alone,
    because none of the activity, up until the attack on the database, is out of the
    ordinary. Even though there might be indicators of oddity—for example, if the
    black hat logs in from an unusual location—these might not be enough to trigger
    an alert, especially if the strange events occur across multiple devices.
  prefs: []
  type: TYPE_NORMAL
- en: To better track this type of malicious behavior, you can use a *security information
    and event management* *(SIEM**)* system. A SIEM system correlates logs from across
    all the devices and networks in your organization. This means that every event
    captured in your organization is fed into the SIEM system for processing. The
    SIEM system then weeds out the normal events, or any false positives, and provides
    an audit log of every suspicious event. You can also program it to generate alerts
    when critical events occur, like a brute-force attack on an account. The best
    part is that because the SIEM system gets logs from multiple devices, it can correlate
    activities to identify suspicious behavior. For example, a remote login to a workstation
    isn’t necessarily suspicious. But a change to the firewall to allow remote connections
    to a workstation, followed by a remote connection to that workstation, might raise
    red flags. The SIEM system would make special note of that activity in its logs.
    If that workstation then connects to a database as an administrator and begins
    downloading all the files, this series of unusual events could warrant a full-blown
    alert.
  prefs: []
  type: TYPE_NORMAL
- en: SIEM systems are very robust, but they require upkeep. At their core, they still
    rely on rules and other indicators to determine whether an event, or set of events,
    is malicious. As organizations evolve, they must update these rules to ensure
    they remain in line with the current state of their systems and network. For example,
    if you add a new server, you’ll need to add its logs to the SIEM system and create
    rules based on what services that server provides. If you fail to maintain your
    SIEM system, you’ll likely miss critical events that you could use to find a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Indicators of Attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Indicators of Attack (IoAs)* are events that point to malicious activity taking
    place on a network, device, or account. This activity could be the result of malware,
    a black hat, or an insider threat. [Table 5-3](#table5-3) describes several common
    IoAs, some examples of each, and what they might indicate. This list is not exhaustive
    by any means, but it should give you a good idea of what you need to consider
    when setting up logging, auditing, or SIEM rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-3: Indicators of Attack'
  prefs: []
  type: TYPE_NORMAL
- en: '| **IoA** | **Example** | **Possible activity** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Unusual outbound traffic** | Device connecting to known malicious IP address;
    device using unusual protocols, like FTP; large amount of queries to a particular
    website or group of websites | Malware contacting a command-and-control server;
    files being removed; backdoor being accessed |'
  prefs: []
  type: TYPE_TB
- en: '| **Internal device running network scans** | Workstation or server sending
    out ping packets | Malware or black hat looking for other systems to compromise
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Account login from location outside business area** | Logins from foreign
    countries; logins from multiple different locations at the same time | Compromise
    of account credentials by black hat or botnet |'
  prefs: []
  type: TYPE_TB
- en: '| **Changes to system settings** | Firewall changes or port changes to allow
    new traffic to connect, such as opening FTP ports; new accounts added to the system;
    an account given administrator access; new automated tasks created | Compromise
    of system by malware or black hat |'
  prefs: []
  type: TYPE_TB
- en: '| **Changes to email settings** | New inbox rules created; new mail flow rules;
    dramatic increase in email activity from an account | Compromise of email account;
    use of email to send out spam or phishing attacks |'
  prefs: []
  type: TYPE_TB
- en: '| **Application or system making irregular connections** | System in an external
    network connecting to an internal system; application making new or unusual requests,
    such as trying to download data from a read-only database; system attempting to
    access a device it’s not authorized to or that is outside its normal workflow
    (for example, a front desk workstation trying to connect to an HR database) |
    Compromise of application or system by malware or black hat; attacker then uses
    compromise to attempt to steal data from, or gain access to, other systems on
    the network |'
  prefs: []
  type: TYPE_TB
- en: '| **Multiple rapid failures** | Several failed login attempts; multiple access
    request failures; multiple system failures | Black hat is attempting to access
    a system or account, for example, using a brute-force attack on an account login;
    might be trying to use system failures to bypass normal security controls |'
  prefs: []
  type: TYPE_TB
- en: '| **Unauthorized programs or processes running** | Programs are set to run
    on startup and aren’t part of normal business software; processes consume a lot
    of memory or CPU resources | Malware, particularly a trojan |'
  prefs: []
  type: TYPE_TB
- en: '| **Activity outside of normal operation time** | Website queries, emails sent,
    applications run, or logins made during non-business hours | Compromise of system
    by malware or black hat, including possible backdoor or trojan |'
  prefs: []
  type: TYPE_TB
- en: 'Exercise: Setting Up Accounts in Windows 10 and macOS'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to understand how authentication and authorization systems can
    affect your use of a system is to manage the accounts on your home computer. Whether
    you use a Windows or Apple system, you should be able to create accounts and then
    control the access they have to certain parts of the system. In this exercise,
    you’ll configure the security settings for your account on either a Windows or
    Apple computer. You’ll then create a new account and give it access to a shared
    folder. Although simple, this exercise uses all aspects of the authentication
    and authorization principles discussed in this chapter and will give you a real-world
    sense of how you can protect these systems against unwanted access.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows comes with a variety of built-in security features that you can use
    to protect your account from unauthorized access. Many of these features are already
    on by default. But it’s a good idea to check them to make sure you’re getting
    the most protection for your system. To do this, enter **security** in the search
    bar in the lower-left corner of your screen. The task menu appears, containing
    a list of several applications. Click **Windows Security** to open the security
    settings. [Figure 5-2](#figure5-2) shows the Windows Security dialog that should
    open.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/501287c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: The Windows Security dialog'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in Chapter 4, this is where you can access many of the security
    features that a Windows system includes. This time, you’ll click **Account Protection**.
    [Figure 5-3](#figure5-3) shows the resulting dialog.
  prefs: []
  type: TYPE_NORMAL
- en: In this dialog, you can see the settings that relate to account sign-ins. At
    the top, you should see the name of the account that you’re currently signed in
    with. Just below that is the *Windows Hello* sign-in option. Windows Hello provides
    a biometric login by using your facial structure to unlock your system. (Note
    that this feature is only available on compatible systems that have a web camera.)
    Although biometric logins are stronger than your traditional password, it’s important
    to note that this feature has had problems recognizing faces and allowing other,
    similar-shaped faces to log in.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](image_fi/501287c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The Account Protection dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Just below Windows Hello is the *Dynamic Lock* option. This allows your system
    to pair with another device, such as a laptop, tablet, or phone via Bluetooth,
    and automatically lock the computer’s screen when it loses its connection to that
    device. Dynamic lock can offer peace of mind whenever you have to leave your system
    unattended, but it might become frustrating if you move around a lot and have
    to keep unlocking your screen. Also, even though Bluetooth is a short-range radio
    technology, it can connect over surprisingly long distances. For example, leaving
    your office to go to the break room for a cup of coffee might not be far enough
    to lock the computer, so it might remain open for any passerby to access.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re more familiar with some of the security features in Windows
    10, let’s look at the specific account settings you can change. In the Account
    Protection dialog, within the Windows Hello section, click **Manage Sign-in Options**.
    [Figure 5-4](#figure5-4) shows the dialog that should appear.
  prefs: []
  type: TYPE_NORMAL
- en: From this dialog, you can investigate and change how your system logs in to
    your account. The list of options is diverse enough to provide the level of security
    you need while also making it easy to use. Keep in mind that if a password or
    other authentication activity isn’t easy for users to implement, they’ll likely
    use it incorrectly or bypass it altogether.
  prefs: []
  type: TYPE_NORMAL
- en: The *Windows Hello Fingerprint* option is a biometric fingerprint scanner. It
    requires either a built-in or attached fingerprint scanning device to work (and
    as you can see, the computer in [Figure 5-3](#figure5-3) doesn’t have this option
    available). The *Windows Hello PIN* option provides a PIN that you can use to
    log in as an alternative to a traditional password. It’s meant to be faster to
    use; but remember, you still need to make sure you create a long, difficult-to-guess
    pin (at least six to eight numbers) to guard against a brute-force attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/501287c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: The Sign-in Options dialog'
  prefs: []
  type: TYPE_NORMAL
- en: The *Security Key* option generates a token—a Type 2 authentication factor—whose
    unique key lets you log in to the system. You must have a physical security token
    to pair with this device. Typically you’ll only find these keys used in businesses
    that can afford to buy them, but inexpensive commercial tokens, such as the Duo
    or Google Authenticator apps for phones, are also available.
  prefs: []
  type: TYPE_NORMAL
- en: Windows also offers two password options, a traditional password and a picture
    password. The picture password requires you to choose a picture and then draw
    on it. For example, you could choose a picture of a face and then draw circles
    around the eyes. To access the system, you’ll need to replicate your actions when
    shown the picture at login. This is Type 4 authentication (something you do).
    It’s usually considered the weakest form of authentication, because most people’s
    gestures follow the natural paths of the picture. For example, if you chose a
    picture of a flag on a flagpole, you might draw a line down the flagpole, which
    is fairly easy for an attacker to guess, because it’s a predictable action.
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to try each option to see which one you like the best. Just because
    you’ve always used a password doesn’t mean it’s right for you. Adding a different
    type of authentication might provide better security or functionality for your
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, let’s look at one last setting. Below the different sign-in
    options is a drop-down menu for *Require Sign-In*. This lets you determine at
    which point your system should require you to log back in after being inactive
    for a time: the two options are *Never* and *When PC Wakes Up from Sleep*. You
    should always require a new login after the system wakes up. This keeps your system
    safe from unauthorized access should you stop using it but forget to log out.
    This setting should be turned on by default.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a New Account
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve chosen your security settings, you can create a new account.
    To do this, click the **Family & Other Users** option in the sidebar on the left.
    [Figure 5-5](#figure5-5) shows the screen that appears.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05005](image_fi/501287c05/f05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: The Family & other users dialog'
  prefs: []
  type: TYPE_NORMAL
- en: This dialog allows you to add other accounts to your system. At the top is the
    *Your Family* section. In the Windows 10 ecosystem, a family member is an account
    with additional auditing features and parental controls to help keep children
    safe. This feature also allows you to share apps and other purchases across accounts.
    But for this exercise, we’ll focus on the second section, *Other Users*. This
    option lets you add another, traditional user account to your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a new account. Later in this exercise, you’ll learn how to share a
    folder between the current account you’re using and the new account you create.
    Click the plus icon next to *Add Someone Else To This PC*. A dialog opens asking
    how the new user should be able to sign in and for a corresponding Microsoft account.
    If the new user doesn’t have a Microsoft account, click **I Don’t Have This Person’s
    Sign In Information**. Similarly, on the next page, click **Create Without a Microsoft
    Account**. [Figure 5-6](#figure5-6) shows the dialog that appears now.
  prefs: []
  type: TYPE_NORMAL
- en: Create a local account for the system. A *local account* is linked to only one
    computer rather than being part of a larger network. In [Figure 5-6](#figure5-6),
    I created a user called Sparkle Kitten, but you can name your new user whatever
    you want. Fill out the information and click **Next** when you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05006](image_fi/501287c05/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Creating a new account'
  prefs: []
  type: TYPE_NORMAL
- en: After creating the account, you need to decide whether or not to make it an
    Administrator account in the Change Account Type dialog ([Figure 5-7](#figure5-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05007](image_fi/501287c05/f05007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: The Change Account Type dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Administrator accounts can access system files and make other changes to the
    system that could potentially be harmful, so determine whether the person using
    the account really needs to be an administrator before assigning them that type
    of account. Remember to keep the principle of least privilege in mind when making
    this decision. For this exercise, a Standard User account will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a Folder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An important part of access control is being able to limit control based on
    the principles of least privilege and a need-to-know basis. Let’s use those principles
    now by creating a folder and sharing it with the new account you just made. Create
    a new folder in the original account by right-clicking an empty area on the Desktop
    and clicking **New**▶**Folder**. It doesn’t matter where you create the folder,
    but Documents or Desktop are probably the most convenient locations.
  prefs: []
  type: TYPE_NORMAL
- en: Once the folder is created, you’ll need to access its properties to share it.
    Right-click the folder and then click **Properties**. [Figure 5-8](#figure5-8)
    shows the dialog that appears.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05008](image_fi/501287c05/f05008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Folder properties'
  prefs: []
  type: TYPE_NORMAL
- en: With the Properties dialog open, click the **Sharing** tab at the top. This
    tab contains settings you’ll use to share the folder ([Figure 5-9](#figure5-9)).
  prefs: []
  type: TYPE_NORMAL
- en: In this dialog, click **Advanced Sharing**, which brings up the dialog shown
    in [Figure 5-10](#figure5-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05009](image_fi/501287c05/f05009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-9: The Sharing dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05010](image_fi/501287c05/f05010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-10: The Advanced Sharing dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Share This Folder** option, which opens a new option that asks
    you for a share name and displays a Permissions button. For now, click **Permissions**
    ([Figure 5-11](#figure5-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05011](image_fi/501287c05/f05011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-11: Sharing permissions'
  prefs: []
  type: TYPE_NORMAL
- en: The Share Permissions dialog is similar to the ones you might see in many access
    control systems. For each group or user, it shows you a list of permissions corresponding
    to the folder. Although basic, these permissions provide a full spectrum of control.
    *Read* allows a user to see what’s in the folder but not delete or rename the
    folder. *Change* allows a user to rename or remove the folder, and *Full Control*
    grants the user complete access to read, write, rename, or delete the folder.
  prefs: []
  type: TYPE_NORMAL
- en: To add a specific user, click the **Add** button to display the dialog shown
    in [Figure 5-12](#figure5-12).
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can add other users to the folder’s permission list, and then
    give them the appropriate permissions. Just enter the name of the user in the
    white box near the bottom of the dialog. Because I named my new user Sparkle Kitten,
    I entered that name. Next, click **Check Names**, and the system should automatically
    fill in the complete username, as shown in [Figure 5-12](#figure5-12). If the
    username doesn’t fill in as shown in the figure, be sure to check your spelling.
    It must be precise to find the correct username.
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK**, and the user you selected should appear in the list below Everyone
    in the Share Permissions dialog. You can then click that username and set its
    permissions. Generally, it’s best to default to just Read access, so users can
    see what’s in the folder but not make changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05012](image_fi/501287c05/f05012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-12: Adding a user'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also look at the Security tab next to the Sharing tab in the Properties
    dialog. The Security tab provides some of the same functionality as Sharing. Essentially,
    the Security tab shows every user or group with access to the file or folder and
    the permissions they have. You can use this tab much in the same way you used
    the Advanced Sharing feature: to add a user and give them permissions to the folder.
    It’s important to note that any files or folders you place in the shared folder
    will need to have the same user permissions as the shared folder for the user
    to access them. The shared folder permissions only give users access to the folder,
    not necessarily to the contents within. [Figure 5-13](#figure5-13) shows an example
    of what the Security tab looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05013](image_fi/501287c05/f05013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-13: The Security tab'
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to configure the security settings on your account, add a user,
    and give that user permission to view a shared folder. Although this exercise
    might not seem that significant, we just covered nearly all of the access control
    principles, including authentication, authorization, least privilege, and even
    the DAC model. Now let’s look at how to configure the security settings on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Access Control on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: macOS provides its own access control and authentication challenges. One challenge
    is that Apple systems streamline many of the controls that are normally accessible
    in a Window environment. This gives the user a limited amount of control over
    how to manage their systems unless they’re prepared to do a deep dive into system
    files and edit them manually. This isn’t recommended unless you have a lot of
    experience, because you can easily edit a system file incorrectly and break your
    system. In this section, I’ll provide a general overview of the controls available
    to you and where you can locate them.
  prefs: []
  type: TYPE_NORMAL
- en: Account Management
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s begin by looking at account management for macOS. This operating system
    provides some useful controls that you can use to further secure your system,
    specifically how and when the system automatically logs out for you. To start,
    click the Apple symbol in the top-left corner of your screen, and then click **System
    Preferences** to open the application ([Figure 5-14](#figure5-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05014](image_fi/501287c05/f05014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-14: The System Preferences application'
  prefs: []
  type: TYPE_NORMAL
- en: This app is your one-stop shop for most settings and configurations for your
    system. Click **Security & Privacy** to display the dialog in [Figure 5-15](#figure5-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05015](image_fi/501287c05/f05015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-15: The Security & Privacy dialog'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the dialog, there aren’t many options to choose from. You
    should set the timer that determines how long your system can be inactive before
    requiring a password to at least five minutes, if not lower, depending on your
    security needs. You can also access advanced settings, as shown in [Figure 5-16](#figure5-16),
    by clicking the lock icon in the bottom-left corner, entering your password, and
    then clicking the **Advanced** button in the bottom-right corner. (You’ll need
    to have administrator permissions to do this.) The advanced settings allow you
    to add additional security to your system by requiring an administrator password
    to change any settings that would affect more than one user. You can also change
    the log-out timer for inactivity. This timer is different than the previous inactivity
    timer, because it fully logs you out of the system rather than simply requiring
    you to enter your password again. It’s best to set this option to at most 30 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve configured these settings, return to System Preferences. Then click
    **Users & Groups** in the last row of icons. A dialog should open showing all
    the users for the system. Once again, by clicking the lock icon in the bottom-left
    corner and entering your password, you can access some additional settings for
    each user. At the bottom of the Users & Groups dialog, click **Login Options**
    to display the dialog shown in [Figure 5-17](#figure5-17).
  prefs: []
  type: TYPE_NORMAL
- en: These settings mostly pertain to which options appear on the login menu, such
    as password hints or the ability to shut down or restart the computer without
    logging in first. You can also add new users to the system by clicking the plus
    icon just below Login Options in the bottom-left corner. Now let’s look at how
    to share files between user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05016](image_fi/501287c05/f05016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-16: The advanced Security & Privacy settings'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05017](image_fi/501287c05/f05017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-17: Login options'
  prefs: []
  type: TYPE_NORMAL
- en: File Sharing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: macOS streamlines file sharing; every system has a built-in file share associated
    with each user account. You can control and grant access to this file share from
    a central dialog. Return to System Preferences and click the **Sharing** icon
    to display its dialog, as shown in [Figure 5-18](#figure5-18).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05018](image_fi/501287c05/f05018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-18: The Sharing dialog'
  prefs: []
  type: TYPE_NORMAL
- en: From this dialog, you can control settings for all forms of sharing, including
    remote login, file sharing, screen sharing, and more. In the Sharing dialog, you
    can see a list of shared folders. By clicking the plus icon at the bottom of this
    list, you can add another folder you want to share. Clicking a shared folder in
    the list will also display options for who can access it, as well as what type
    of access they can have. There are fewer options here than on Windows, but they’re
    extremely easy to understand. *Read* lets someone see the folder, whereas *Write*
    lets them add items to or remove items from the folder.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now learned the basics of account management, access control, and file
    sharing for Windows and macOS. Using this knowledge, you can better control who
    has access to your system and how you share information with others. Remember
    to only grant people the bare minimum of access they need for their given tasks.
    Giving someone full rights when they only need Read permissions is just asking
    for disaster.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the three parts of a robust access control
    system: authentication, authorization, and accounting. When authenticating users,
    make sure you’re using a method that fits your environment’s needs while still
    maintaining security. Multi-factor authentication can provide an extra layer of
    security, and this precaution can determine whether your accounts get compromised.
    When authorizing users to perform tasks on your systems, use an access control
    system that ensures people maintain the least amount of privilege they need to
    do their job. You should also distribute duties between multiple individuals to
    guarantee that no one person has too much authority.'
  prefs: []
  type: TYPE_NORMAL
- en: Auditing lets you maintain a good grasp of what is happening inside your organization.
    To audit effectively, set up logs, establish good practices, and watch out for
    various IoAs. With these processes in place, you’ll create a reliable and efficient
    access control program in your organization. You’ll let the right people in, keep
    the wrong people out, and ensure you’ve tracked every event.
  prefs: []
  type: TYPE_NORMAL
