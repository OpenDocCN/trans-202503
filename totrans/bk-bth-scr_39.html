<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="appB" epub:type="appendix" role="doc-appendix">
<hgroup>
<h2 class="title" id="appB">
<span class="cn"><span aria-label=" Page 431. " epub:type="pagebreak" id="pg_431" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">B</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">ARRAY AND HASH TABLE OBJECTS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/></figure>
<p class="chapterintro">In <span class="xref1"><a href="chapter29.xhtml" class="calibre4">Chapter 29</a></span>, I demonstrated how to build, access, and update arrays and hash tables. These data structures, not often associated with bat files, are great applications of the equally atypical real-world Batch objects discussed in <span class="xref1"><a href="chapter33.xhtml" class="calibre4">Chapter 33</a></span>.</p>
<p class="tx">In this appendix, I’ll bring these concepts together by presenting a well-commented object bat file for each data structure.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="h" id="sec1"><span id="h1-228"/><span class="sans_futura_std_bold_b_">The Array Object</span></h2>
<p class="tni">Here are the full contents of the array object, <i class="calibre6">oArray.bat</i>:</p>
<pre class="pre"><code class="calibre11">:: ****** Array Object ****** 
:: Parm 1 – Name of Array
:: Parm 2 - Name of Method: 
::       AddElemAt - Insert One Element at an Index
<span aria-label=" Page 432. " epub:type="pagebreak" id="pg_432" role="doc-pagebreak"/>::               Parm 3 - Index of Element being Added
::               Parm 4 - Value of Element being Added
::       AddElem - Add One Element to the Array 
::               Parm 3 - Element being Added
::       GetElem - Get the Element at an Index
::               Parm 3 - Index of Element
::               Parm 4 - Returned Variable Name
::       GetFirst - Get the First Element in the Array
::               Parm 3 - Returned Variable Name
::       GetNext - Get the Next Element in the Array; call after
::                      :GetElem or :GetFirst or gets first element
::               Parm 3 - Returned Variable Name
::       GetSize - Get the Number of Elements in the Array
::               Parm 3 - Returned Variable Name
::       RemoveElemAt - Remove One Element from the Array
::               Parm 3 - Index of Element being Removed
::       Clear - Empty the Array of all its Elements
::       IndexOf - Get the Index of a Specific Value
::                      or return -1 if Not Found
::               Parm 3 - Value of Search Element
::               Parm 4 - Returned Variable Name
::       Contains - Get a Boolean Indicating if a Value is 
::                        Anywhere in the Array
::               Parm 3 - Value of Search Element
::               Parm 4 - Returned Boolean Name
::       Clone - Create a Copy of the Array
::               Parm 3 - Name of New Array
:: Global Variables:
::   &lt;arrayName&gt;Size = Size or Length of the Array
::   &lt;arrayName&gt;Index = Index or Pointer to the Next Element
::   &lt;arrayName&gt;[n] = Nth Element of the Array

  cmd /C exit 0
  call :%~2 "%~1" "%~3" "%~4" || (
     &gt; C:\Batch\Log.txt echo ** ERROR - Invalid Method Name "%~2"
     exit
  )
  goto :eof
  
 :AddElemAt
  call :GetSize %~1 size
  if %~2 gtr %size% (
     echo ** Invalid Index "%~2" greater than Array Size "%size%"
     goto :eof
  )
  set /A startIndex = !%size! - 1
  for /L %%i in (%startIndex%, -1, %~2) do (
     set /A nextIndex = %%i + 1
     for /F %%n in ("!nextIndex!") do (
       set %~1[%%n]=!%~1[%%i]!
  )  )
  set %~1[%~2]=%~3
  set /A %~1Size += 1
  goto :eof
  
<span aria-label=" Page 433. " epub:type="pagebreak" id="pg_433" role="doc-pagebreak"/> :AddElem
  call :GetSize "%~1" size
  set %~1[!size!]=%~2
  set /A %~1Size += 1
  goto :eof
  
 :GetElem
  set %~3=!%~1[%~2]!
  set /A %~1Index = %~2 + 1
  goto :eof
  
 :GetFirst
  set %~2=!%~1[0]!
  set %~1Index=1
  goto :eof
  
 :GetNext
  if not defined %~1Index  set %~1Index=0
  call :GetSize "%~1" size
  set targIndex=!%~1Index!
  if %targIndex% geq %size% (
      set %~2=No More Elements
  ) else (
      set %~2=!%~1[%targIndex%]!
      set /A %~1Index += 1
  )
  goto :eof
  
 :GetSize
  if not defined %~1Size  set %~1Size=0
  set %~2=!%~1Size!
  goto :eof
  
 :RemoveElemAt
  call :GetSize "%~1" size
  if %~2 geq %size% (
     echo ** Nothing to do, Index "%~2" greater than Array Size "%size%"
     goto :eof
  )
  set /A %~1Size -= 1
  for /L %%i in (%~2, 1, !%~1Size!) do (
      set /A nextIndex = %%i + 1
      for /F %%n in ("!nextIndex!") do (
        set %~1[%%i]=!%~1[%%n]!
  )  )
  set %~1[!nextIndex!]=&amp;
  goto :eof
  
 :Clear
  for /F "usebackq delims==" %%a in (`set %~1`) do (
      set %%a=&amp;rem
  )
  set %~1Size=0
  goto :eof
  
<span aria-label=" Page 434. " epub:type="pagebreak" id="pg_434" role="doc-pagebreak"/> :IndexOf
  set %~3=-1
  set /A sizeLess1 = %~1Size - 1
  for /L %%i in (0, 1, %sizeLess1%) do (
      if "%~2" equ "!%~1[%%i]!" (
         set %~3=%%i
  )  )
  goto :eof
  
 :Contains
  call :IndexOf "%~1" "%~2" indexOf
  if %indexOf% equ -1 (
     set %~3=false==x
  ) else (
     set %~3=true==true
  )
  goto :eof
  
 :Clone
  call :Clear "%~2"
  for /F "usebackq tokens=1,2 delims==" %%p in (`set %~1`) do (
     set oldArrayItem=%%p
     set !oldArrayItem:%~1=%~2!=%%q
  )
  goto :eof
</code></pre>
<p class="tni">This bat file should be called often, so I’m using <span class="sans_thesansmonocd_w5regular_">::</span> (two colons) for the remarks instead of the <span class="sans_thesansmonocd_w5regular_">rem</span> command just to cut down on what the interpreter writes to stdout.</p>
<p class="tx">Every call to this object passes at least two arguments: the name of an array and the method or action being invoked; depending on the method, another argument or two might be required. You can add elements to the end of an array or at a specific index; you can retrieve the first element, the next element, or an element at a particular index. The object has methods for removing an element at a certain index, getting the size of the array, and clearing or emptying the array. You can get the index of the first instance of a specific value or retrieve a boolean telling you whether that value exists anywhere in the array. You can even clone or copy the array.</p>
<p class="tx">Instead of stepping through each method, I’ll let the comments do the talking. Notice that I’ve included a brief description of each method along with their required arguments.</p>
<p class="tx">There are, however, a few interesting bits of code worthy of mention. You’ll find plenty of examples of delayed expansion in this listing. In fact, a couple methods use nested <span class="sans_thesansmonocd_w5regular_">for</span> commands solely because of delayed expansion; each <span class="sans_thesansmonocd_w5regular_">for</span> command transforms a variable assigned in the outer <span class="sans_thesansmonocd_w5regular_">for</span> command into a variable resolvable with percent signs (<span class="xref"><a href="chapter20.xhtml" class="calibre3">Chapter 20</a></span>). Also, the <span class="sans_thesansmonocd_w5regular_">:IndexOf</span> and <span class="sans_thesansmonocd_w5regular_">:Contains</span> methods perform similar functions. Instead of duplicating work, the latter calls the former, converting the result into a boolean. Likewise, multiple methods retrieve the array size by calling <span class="sans_thesansmonocd_w5regular_">:GetSize</span>. The <span class="sans_thesansmonocd_w5regular_">:Clone</span> method assigns all variables associated with one array <span aria-label=" Page 435. " epub:type="pagebreak" id="pg_435" role="doc-pagebreak"/>to another, taking advantage of text replacement and the fact that array elements are thinly disguised ordinary variables.</p>
<p class="tx">You can call the object from another bat file to perform all of these functions. Here’s a small sampling:</p>
<pre class="pre"><code class="calibre11">call C:\Batch\oArray.bat friends AddElem Walter
call C:\Batch\oArray.bat friends AddElem Donny
call C:\Batch\oArray.bat friends AddElemAt 1 Maude
call C:\Batch\oArray.bat friends RemoveElemAt 0
call C:\Batch\oArray.bat friends GetFirst oneFriend
call C:\Batch\oArray.bat friends GetNext anotherFriend
</code></pre>
<p class="tni">This code populates <span class="sans_thesansmonocd_w5regular_">oneFriend</span> and <span class="sans_thesansmonocd_w5regular_">anotherFriend</span> with <span class="sans_thesansmonocd_w5regular_">Maude</span> and <span class="sans_thesansmonocd_w5regular_">Donny</span>, respectively.</p>
<p class="tx">For the sake of readability, this object has minimal error handling and validation of the incoming parameters, but these relatively few lines of code stand ready to create, modify, and access any number of arrays.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="h" id="sec2"><span id="h1-229"/><span class="sans_futura_std_bold_b_">The Hash Table Object</span></h2>
<p class="tni">Here are the full contents of the hash table object, <i class="calibre6">oHashTable.bat</i>:</p>
<pre class="pre"><code class="calibre11">:: ****** Hash Table Object ****** 
:: Parm 1 – Name of Hash Table
:: Parm 2 - Name of Method: 
::       Clear - Empty the Hash Table of all its Keys and Values
::       Put - Put One Key-Value Pair into the Hash Table
::               Parm 3 - Key being Added
::               Parm 4 - Value being Added
::       Get - Get a Value Given a Key
::               Parm 3 - Search Key
::               Parm 4 - Returned Variable Name
::       GetSize - Get the Number of Key-Value Pairs in the Hash Table
::               Parm 3 - Returned Variable Name
::       Remove - Remove One Key and its Value from the Hash Table
::               Parm 3 - Key being Removed
::       ContainsKey - Get a Boolean Indicating if a Key is 
::                       Anywhere in the Hash Table
::               Parm 3 - Search Key
::               Parm 4 - Returned Boolean Name
::       ContainsValue - Get a Boolean Indicating if a Value is 
::                       Anywhere in the Hash Table
::               Parm 3 - Search Key
::               Parm 4 - Returned Boolean Name
::       Clone - Create a Copy of the Hash Table
::               Parm 3 - Name of New Hash Table
:: Global Variable:
::    &lt;hashTable&gt;Size = Size or Length of the Hash Table

<span aria-label=" Page 436. " epub:type="pagebreak" id="pg_436" role="doc-pagebreak"/>  cmd /C exit 0
  call :%~2 "%~1" "%~3" "%~4" || (
     &gt; C:\Batch\Log.txt echo ** ERROR - Invalid Method Name "%~2"
     exit
  )
  goto :eof
  
 :Clear
  for /F "usebackq delims==" %%a in (`set %~1`) do (
      set %%a=&amp;rem
  )
  set %~1Size=0
  goto :eof
  
 :Put
  call :ContainsKey "%~1" "%~2" bool
  set %~1{%~2}=%~3
  if not %bool% (
     set /A %~1Size += 1
  )
  goto :eof
  
 :Get
  call :ContainsKey "%~1" "%~2" bool
  if %bool% (
     set %~3=!%~1{%~2}!
  ) else (
     set %~3=Key Does Not Exist
  )
  goto :eof
  
 :GetSize
  if not defined %~1Size  set %~1Size=0
  set %~2=!%~1Size!
  goto :eof
  
 :Remove
  call :ContainsKey "%~1" "%~2" bool
  if %bool% (
     set /A %~1Size -= 1
  )
  set %~1{%~2}=&amp;
  goto :eof
  
 :ContainsKey
  if defined %~1{%~2} (
     set %~3=true==true
  ) else (
     set %~3=false==x
  )
  goto :eof
  
<span aria-label=" Page 437. " epub:type="pagebreak" id="pg_437" role="doc-pagebreak"/> :ContainsValue
  set %~3=false==x
  for /F "usebackq tokens=2 delims==" %%v in (`set %~1{`) do (
     if "%%v" equ "%~2" (
        set %~3=true==true
  )  )
  goto :eof
  
 :Clone
  call :Clear "%~2"
  for /F "usebackq tokens=1,2 delims==" %%p in (`set %~1`) do (
     set oldHashTblItem=%%p
     set !oldHashTblItem:%~1=%~2!=%%q
  )
  goto :eof
</code></pre>
<p class="tx">This object also accepts at least two parameters: the name of a hash table and the method or action being invoked. You can add a key-value pair to the data structure by invoking the <span class="sans_thesansmonocd_w5regular_">:Put</span> method and retrieve a value given a key via the <span class="sans_thesansmonocd_w5regular_">:Get</span> method. Other methods clear the entire hash table or remove just one pair. You can get the number of pairs and retrieve a boolean showing whether a key or value is present, and as in the array object, there is a clone method.</p>
<p class="tx">Each method and its corresponding parameters are described in the comments at the beginning of the bat file. The most interesting method is <span class="sans_thesansmonocd_w5regular_">:ContainsValue</span>, which preemptively sets the boolean to false before performing a search for the value by looking at every pair. However, determining whether a key exists in the hash table requires little more than an <span class="sans_thesansmonocd_w5regular_">if defined</span>.</p>
<p class="tx">Here are a few lines of code demonstrating a simple test of the object’s features:</p>
<pre class="pre"><code class="calibre11">call C:\Batch\oHashTable.bat jobs Put Lincoln President
call C:\Batch\oHashTable.bat jobs Put Poe Poet
call C:\Batch\oHashTable.bat jobs Put Darwin Naturalist
call C:\Batch\oHashTable.bat jobs Get Poe aJob
</code></pre>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">aJob</span> variable contains the value <span class="sans_thesansmonocd_w5regular_">Poet</span> after the completion of these commands.</p>
<p class="tx">You can call this object from multiple bat files and even build multiple hash tables from a single process. Now look for other instances where you can keep your main code simple by placing the interesting logic in a reusable object bat file.</p>
</section>
</section>
</div></body></html>