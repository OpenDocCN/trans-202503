<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_31" title="31"/>3</span><br/>&#13;
<span class="ChapterTitle">A Software Implementation of the I<sup>2</sup>C Bus</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Although the vast majority of widely used I<sup>2</sup>C functionality comes as part of a peripheral IC or a CPU on an SBC, occasionally you may need to develop firmware for hardware that does not provide I<sup>2</sup>C support. In that case, you’ll have to implement the I<sup>2</sup>C protocol in software.</p>&#13;
<p>This chapter shows how to implement both controller and peripheral devices using nothing more than GPIO pins on a standard microcontroller (MCU). I will use the Teensy 3.2 as an example, though the same principles apply to almost any device with at least two programmable I/O pins. If you want to use this code for some other MCU, you’ll probably have to tweak and optimize it a bit, particularly on MCUs with lower performance and less memory than the Teensy 3.2. Chapter 17 (online at <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a>) provides an example of just such an optimization.</p>&#13;
<p><span epub:type="pagebreak" id="Page_32" title="32"/>This chapter does not provide a drop-in, ready-to-use, software-based I<sup>2</sup>C library. Almost any MCU you will use in an environment where you need I<sup>2</sup>C will provide hardware support—the Teensy 3.2 itself provides two independent hardware I<sup>2</sup>C buses. That said, a software implementation makes it clearer exactly what is happening in the hardware, so you’ll benefit from studying this code.</p>&#13;
<h2 id="h1-502468c03-0001">	3.1	A Software I<sup>2</sup>C Implementation on the Teensy 3.2</h2>&#13;
<p class="BodyFirst">The Teensy 3.2 is a 32-bit ARM (Cortex M4) that runs at 72 MHz, though it is often overclocked to 96 MHz. It features 256KB of flash storage for code, 64KB of RAM for data, 2,048KB of EEPROM for nonvolatile storage, and a huge amount of I/O, including three UARTs, two I<sup>2</sup>C buses, and one SPI bus, all on a tiny—er, <em>teensy</em>, approximately 1.4 inch by 0.7 inch—PCB. Teensy has its own 3.3-V regulator on board, so the processor runs off 3.3 V, but all the I/O pins are 5-V tolerant. Typically, you program the Teensy using the Arduino IDE, and most Arduino code runs just fine on the Teensy 3.2.</p>&#13;
<p>Software implementation of I<sup>2</sup>C on the Teensy 3.2 is primarily an educational exercise: since the Teensy 3.2 supports two hardware I<sup>2</sup>C interfaces, there are few reasons to run a software-based I<sup>2</sup>C system. The Teensy is very powerful, and it’s possible to write the I<sup>2</sup>C module in C/C++ without often having to drop down into hardware-specific code. Most of the code in this chapter is stock Arduino code, which should be much more approachable and understandable than I<sup>2</sup>C optimized for lower-powered MCUs. </p>&#13;
<p>The following subsections describe two variants of a software-based I<sup>2</sup>C system on the Teensy: a controller implementation and a peripheral implementation. For those interested in a hardware-based I<sup>2</sup>C implementation, see Chapter 6 and section 11.1, “Teensy 4.<em>x</em> Controller Programming,” in Chapter 11.</p>&#13;
<h3 id="h2-502468c03-0001">3.1.1	A Software-Based I<sup>2</sup>C Controller for the Teensy 3.2</h3>&#13;
<p class="BodyFirst">The code in <a href="#listing3-1" id="listinganchor3-1">Listing 3-1</a> implements a software-based I<sup>2</sup>C controller running on a Teensy 3.2 by using Arduino library calls. I discuss each function and various code segments in the text between various sections of the listing. </p>&#13;
<p>This code is just meant to demonstrate how to implement an I<sup>2</sup>C controller in software, so don’t treat it as an I<sup>2</sup>C library module for production use. It’s intended to clarify the I<sup>2</sup>C protocol in a concrete and formal manner for purely educational purposes.</p>&#13;
<p>As a test example, this particular program reads a value from an Adafruit ADS1115 I<sup>2</sup>C ADC module from input A0, translates the binary input to the comparable range on the MCP4725, and then writes the result to a SparkFun MCP4725 DAC module (see <a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a> for the wiring diagram). </p>&#13;
<span epub:type="pagebreak" id="Page_33" title="33"/><figure>&#13;
<img alt="" class="" height="806" src="image_fi/502468c03/f03001.png" width="692"/>&#13;
<figcaption><p><a id="figure3-1">Figure 3-1</a>: Circuit for the Teensy-based controller example</p></figcaption>&#13;
</figure>&#13;
<p>Inputting a voltage in the range of 0 V to 4.1 V should produce a similar voltage on the DAC output. This example program tests both reading from and writing to I<sup>2</sup>C peripherals using the software-based I<sup>2</sup>C controller software.</p>&#13;
<p>The <code>MCP4725_ADDR</code> and <code>ADS1115_ADDR</code> symbols specify the addresses of these modules. The DAC address should be 0x60 or 0x61, depending on the address jumper on the SparkFun board (the schematic in <a href="#figure3-1">Figure 3-1</a> wires ADDR to Gnd, selecting address 0x60). Note that although the code in <a href="#listing3-1">Listing 3-1</a> writes to a SparkFun board, you could also write to an Adafruit MCP4725 breakout board. In that case, the DAC address would be 0x62 or 0x63, depending on the on-board address setting. The ADS1115 address would be 0x48, 0x49, 0x4A, or 0x4B, depending how the address pin is jumpered on the breakout board; the schematic in <a href="#figure3-1">Figure 3-1</a> assumes <span epub:type="pagebreak" id="Page_34" title="34"/>you’ve wired the ADDR pin to Gnd to use address 0x48. See the Adafruit documentation for more details (in “For More Information” at the end of this chapter).</p>&#13;
<p>The following code fragment begins <a href="#listing3-1">Listing 3-1</a>, which continues throughout this section with interspersed comments and annotations. You can find the full code file, <em>Listing3-1.ino</em>, at <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a>.</p>&#13;
<pre><code>// <a id="listing3-1">Listing3-1</a>.ino&#13;
//&#13;
// Software-based I2C controller device for&#13;
// the Teensy 3.2.&#13;
//&#13;
// Copyright 2020, Randall Hyde.&#13;
// All rights reserved.&#13;
// Released under Creative Commons 4.0.&#13;
&#13;
#include &lt;arduino.h&gt;&#13;
&#13;
// I2C address of the SparkFun MCP4725 I2C-based&#13;
// digital-to-analog converter.&#13;
&#13;
#define MCP4725_ADDR 0x60&#13;
#define ADS1115_ADDR 0x48&#13;
&#13;
// Pins on the Teensy 3.2 to use for the&#13;
// software SCL and SDA lines:&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define SCL 0&#13;
#define SDA 1&#13;
&#13;
// digitalWriteFast is a Teensy-specific function. Change&#13;
// to digitalWrite for standard Arduino.&#13;
&#13;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> #define pinWrite digitalWriteFast </code></pre>&#13;
<p>The <code>SCL</code> and <code>SDA</code> symbols define the Arduino-based pin numbers to use for the I<sup>2</sup>C clock and data lines <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Pins 0 and 1 were arbitrary choices. Any available digital I/O pins will work fine here.</p>&#13;
<p>The <code>pinWrite</code> symbol maps to an Arduino-compatible <code>digitalWrite()</code> function <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Under normal circumstances, this would be the <code>digitalWrite()</code> function itself. However, the Teensy library has a special function, <code>digitalWriteFast()</code>, that is call-compatible with the Arduino <code>digitalWrite()</code> function but runs about three times faster by mapping <code>pinWrite()</code> to the Teensy function. If you’re going to run this code on a different MCU, change the definition to <code>digitalWrite()</code>.</p>&#13;
<p>The I<sup>2</sup>C SDA and SCL lines are <em>bidirectional</em>; that is, the controller must be able to read data from these two lines as well as write data to them. As a general rule, Arduino GPIO pins are inputs or outputs, but not both at the same time. To simulate bidirectional I/O, the Teensy 3.2 software-based I<sup>2</sup>C module takes advantage of the fact that Arduino-compatible GPIO pins can be dynamically switched between inputs and <span epub:type="pagebreak" id="Page_35" title="35"/>outputs. For the most part, the controller always knows when the signal line must be input or output so it can switch the pin’s mode on the fly to accommodate the I<sup>2</sup>C bus’s needs.</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Pin set functions.&#13;
//&#13;
// setSCL-&#13;
//&#13;
// Sets the SCL pin high (1) by changing the pin mode to&#13;
// input and relying on the I2C bus pullup resistor to&#13;
// put a 1 on the bus.&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void setSCL( void )&#13;
{&#13;
    pinMode( SCL, INPUT );&#13;
}&#13;
&#13;
// clrSCL-&#13;
// &#13;
// Sets the SCL pin low by changing the pin mode to output and&#13;
// writing a 0 to the pin. This will pull down the SCL line.&#13;
&#13;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void clrSCL( void )&#13;
{&#13;
    pinMode( SCL, OUTPUT );&#13;
    pinWrite( SCL, 0 );&#13;
}&#13;
&#13;
// setSDA, clrSDA-&#13;
// &#13;
// Same as setSCL and clrSCL except they set/clr the SDA line.&#13;
&#13;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> void setSDA( void )&#13;
{&#13;
    pinMode( SDA, INPUT );&#13;
}&#13;
&#13;
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> void clrSDA( void )&#13;
{&#13;
    pinMode( SDA, OUTPUT );&#13;
    pinWrite( SDA, 0 );&#13;
}</code></pre>&#13;
<p>The <code>setSCL()</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>, <code>clrSCL()</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, <code>setSDA()</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>, and <code>clrSDA()</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span> functions are responsible for writing a 0 or a 1 on the SCL and SDA lines. Writing a 1 to either line consists of switching the corresponding pin to the input mode. This puts the pin in a high-impedance state (open-collector or tri-state) without putting an actual signal on the line. The pullup resistor on the line then pulls the line high (1). Writing a 0 to either pin consists of changing the pin’s mode to output and then writing a 0 to that pin. This pulls the line low, even in the presence of the pullup resistor.</p>&#13;
<p><span epub:type="pagebreak" id="Page_36" title="36"/>It is important to leave the SCL and SDA lines high when you are not actively writing a 0 to these lines. This is a requirement not only of this software but also of the I<sup>2</sup>C bus in general—remember, other devices may be trying to pull the lines low.</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Reading the SCL and SDA pins.&#13;
//&#13;
// readSCL-&#13;
// &#13;
// Reads SCL pin until it gets the same value twice in&#13;
// a row. This is done to filter noise.&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> inline byte readSCL( void )&#13;
{&#13;
    byte first;&#13;
    byte second;&#13;
    do&#13;
    {&#13;
        first = digitalRead( SCL );&#13;
        second = digitalRead( SCL );&#13;
    }while( first != second );&#13;
&#13;
    return first;&#13;
}&#13;
&#13;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> // readSDA-&#13;
// &#13;
// Reads SDA pin until it gets the same value twice in&#13;
// a row. This is done to filter noise.&#13;
&#13;
inline byte readSDA( void )&#13;
{&#13;
    byte first;&#13;
    byte second;&#13;
    do&#13;
    {&#13;
        first = digitalRead( SDA );&#13;
        second = digitalRead( SDA );&#13;
 <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> }while( first != second );&#13;
    return first;&#13;
}</code></pre>&#13;
<p>The<code> readSCL()</code> function <span aria-label="annotation1" class="CodeAnnotation">❶</span> reads the data currently on the SCL line. The<code> readSDA()</code> function <span aria-label="annotation2" class="CodeAnnotation">❷</span> reads the data currently on the SDA line. The I<sup>2</sup>C standard requires filtering on the inputs to remove any glitches less than or equal to 50 nsec (nanoseconds) in duration <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Typically, this is done with an active filter (hardware) design. Although it is possible to attach such hardware to the pins on your microcontroller, this software-only I<sup>2</sup>C package performs this glitch filtering in software by reading all inputs twice and returning only once it has read the same value twice in a row. On most microprocessors, this will filter out glitches that are significantly greater than 50 nsec in length. However, <span epub:type="pagebreak" id="Page_37" title="37"/>as this software implementation handles only standard-speed I<sup>2</sup>C operation (100 kHz), anything less than a microsecond could easily be considered noise.</p>&#13;
<p>These functions do not switch the pin to input mode before reading them. Most of the time these functions get called several times in a row, so it’s more efficient to have the caller set the pin mode rather than having these functions set the mode every time they get called. Beyond that, some code calls these functions to verify that the signal lines have actually reached their final state after being set to 0 (handling delays due to bus capacitance, and so on).</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Setting the start condition on the SCL and SDA lines.&#13;
//&#13;
// setStartCond-&#13;
//&#13;
// First checks to see if the bus is being used, which requires&#13;
// a full 10 usec. If the bus is being used by some other bus&#13;
// controller, this function returns false.&#13;
//&#13;
// If the bus is not being used, this function issues a start&#13;
// condition for 5 usec (SDA = 0, SCL = 1) and then raises SDL&#13;
// in preparation for an address byte transmission. If it&#13;
// successfully sends a start condition, this code returns true.&#13;
//&#13;
// Postcondition:&#13;
//     SDA and SCL will both be low if this function is &#13;
//     successful. They will be unaffected if this function &#13;
//     returns false.&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> int setStartCond( void )&#13;
{&#13;
    byte bothPins;&#13;
&#13;
    pinMode( SDA, INPUT ); // Going to be reading pins&#13;
    pinMode( SCL, INPUT );&#13;
    bothPins = readSDA() &amp;&amp; readSCL();&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationHang">❷</span> delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    delayMicroseconds(1);&#13;
<span epub:type="pagebreak" id="Page_38" title="38"/>    bothPins &amp;= readSDA() &amp;&amp; readSCL();&#13;
    if( bothPins )&#13;
    {&#13;
        // Both pins have remained high for around 10 usec&#13;
        // (one I2C clock period at 100 kHz). Chances&#13;
        // are, the bus isn't currently being used.&#13;
        // Go ahead and signal the start condition&#13;
        // by setting SDA = 0.&#13;
&#13;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> clrSDA();&#13;
        delayMicroseconds( 4 );&#13;
        clrSCL();&#13;
        return 1; // In theory, this code has the bus&#13;
&#13;
    }&#13;
    return 0;     // Bus is busy&#13;
&#13;
}</code></pre>&#13;
<p>The <code>setStartCond()</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span> function allows the caller to take control of the I<sup>2</sup>C bus. This function handles two primary tasks: it makes sure the bus isn’t currently in use, and then if the bus is available, it transmits a start signal on the bus to claim the bus for its own use. </p>&#13;
<p>To see if the bus is already in use, the <code>setStartCond()</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span> function checks the SCL and SDA lines every microsecond for 10 μsec. If either line is (or goes) low during these 10 μsec, the bus is in use, and this function returns failure (<code>0</code>). If both lines remain high for the duration, the bus is free, and the code can acquire the bus for its own purposes.</p>&#13;
<p>To acquire the bus, the code places the start condition on it <span aria-label="annotation3" class="CodeAnnotation">❸</span>. This start condition begins with both lines high for 5 μsec (one-half clock cycle). This is followed by a transition on the SDA line from high to low and then a half clock period with SDA low and SCL high (see <a href="#figure3-2" id="figureanchor3-2">Figure 3-2</a>).</p>&#13;
<figure>&#13;
<img alt="" class="" height="399" src="image_fi/502468c03/f03002.png" width="695"/>&#13;
<figcaption><p><a id="figure3-2">Figure 3-2</a>: The start condition</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_39" title="39"/>If the <code>setStartCond()</code> function successfully places the start condition on the bus, it returns <code>1</code> as the function result. When this function returns to the caller, the caller tests the return result to determine whether it can begin using the I<sup>2</sup>C bus or whether it must wait and try to obtain the bus another time.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	This code generally does not supply the exact time specified by the I<sup>2</sup>C standard as an argument to the <code>delayMicroseconds()</code> function. For example, you will often see calls such as <code>delayMicroseconds(3)</code> or <code>delayMicroseconds(4)</code> when specifying a half clock cycle. The code uses these smaller numbers because surrounding statements consume the other time in the half cycle. During development, I used a logic analyzer to choose appropriate values that were greater than or equal to 5 μsec when the standard called for a half cycle (typically 4.7 μsec in the I<sup>2</sup>C standard).</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Outputting a stop condition on the SCL and SDA lines.&#13;
//&#13;
// setStopCond-&#13;
//&#13;
// Generates an end-of-transmission stop sequence.&#13;
//&#13;
// Precondition: &#13;
//     SCL must be low when this is called.&#13;
// Postcondition: &#13;
//     SCL and SDA will be high.&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void setStopCond( void )&#13;
{&#13;
    clrSDA();               // Initialize for stop condition&#13;
    delayMicroseconds( 1 ); // Give SDA time to go high&#13;
    setSCL();&#13;
    while( !readSCL() )&#13;
    {&#13;
        // Clock stretching-&#13;
        //&#13;
        // Wait while the peripheral is holding the clock&#13;
        // line low.&#13;
    }&#13;
    delayMicroseconds( 4 ); // SCL = 1, SDA = 0 for 5 usec&#13;
    setSDA();               // Signal stop condition&#13;
}</code></pre>&#13;
<p>When the software is done transmitting or receiving data and is ready to give up the I<sup>2</sup>C bus, it must put a stop condition on the bus, as shown in the <code>setStopCond()</code> code <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>&#13;
<p><a href="#figure3-3" id="figureanchor3-3">Figure 3-3</a> shows the stop condition appearing on the I<sup>2</sup>C bus. The <code>setStopCode()</code> function brings the SCL line high (while SDA is low) and then pulls SCL high 5 µsec later.</p>&#13;
<span epub:type="pagebreak" id="Page_40" title="40"/><figure>&#13;
<img alt="" class="" height="370" src="image_fi/502468c03/f03003.png" width="694"/>&#13;
<figcaption><p><a id="figure3-3">Figure 3-3</a>: An I<sup>2</sup>C stop condition</p></figcaption>&#13;
</figure>&#13;
<p>The following code demonstrates how to detect and wait for a stop condition.</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Waiting for the stop condition to occur.&#13;
//&#13;
// waitForStop-&#13;
//&#13;
// If the bus is busy when this controller&#13;
// tries to use the I2C bus, this code&#13;
// must wait until a stop condition occurs&#13;
// before trying to use the bus again.&#13;
//&#13;
// Stop condition is:&#13;
//     SCL is high.&#13;
//     SDA goes from low to high.&#13;
&#13;
void waitForStop( void )&#13;
{&#13;
    setSCL();   // Just make sure these are high;&#13;
    setSDA();   // they already should be&#13;
&#13;
    do&#13;
    {&#13;
&#13;
        while( !(readSCL() &amp;&amp; !readSDA()) )&#13;
        {&#13;
                // Wait until the SCL line is high&#13;
                // and the SDA line is low&#13;
        }&#13;
&#13;
        // Stop condition might have begun. Wait&#13;
        // for the data line to go high while&#13;
<span epub:type="pagebreak" id="Page_41" title="41"/>        // the SCL line remains high:&#13;
&#13;
        while( !readSDA() &amp;&amp; readSCL() )&#13;
        {&#13;
                // Wait for data line to go high&#13;
        }&#13;
&#13;
        // Is the SCL line still high?&#13;
        // If not, you are just getting&#13;
        // some data and the code needs to &#13;
        // repeat until SCL is high again.&#13;
&#13;
    }while( !readSCL() );&#13;
}</code></pre>&#13;
<p>If some other controller is already using the I<sup>2</sup>C bus, this software must wait until the other controller is done with the bus. That occurs when the other controller places a stop condition on the bus. The <code>waitForStop()</code> function watches the bus and waits for the stop condition to appear (SCL is high and SDA transitions from low to high).</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Transmitting a single bit on the I2C bus.&#13;
//&#13;
// sdaOut-&#13;
//&#13;
// bit: &#13;
//     Bit to transmit.&#13;
//     Transmits a single bit over the SDA/SCL lines.&#13;
//&#13;
// Returns:&#13;
//     1: If successful.&#13;
//     0: If arbitration failure or other error.&#13;
//&#13;
// Note: &#13;
//     Caller is responsible for setting SCL and SDA&#13;
//     high if there is an arbitration fault.&#13;
&#13;
int sdaOut( byte bit )&#13;
{&#13;
    bit = !!bit;    // Force 0/1&#13;
&#13;
    // Take SCL low so you can write to the&#13;
    // data line. Wait until SCL is actually&#13;
    // low before proceeding:&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> clrSCL();&#13;
    while( readSCL() );&#13;
&#13;
    // Set the SDA line appropriately:&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if( bit )&#13;
    {&#13;
<span epub:type="pagebreak" id="Page_42" title="42"/>        setSDA();&#13;
    }&#13;
    else&#13;
    {&#13;
        clrSDA();&#13;
    }&#13;
&#13;
    // Wait for 1/2 of the I2C clock period&#13;
    // while SCL is low:&#13;
&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> delayMicroseconds( 3 );&#13;
&#13;
    // Check to see if the value put on&#13;
    // the SDA line can be read back. The code&#13;
    // needed to delay before this call in order &#13;
    // to allow signal time to rise on the&#13;
    // SDA line.&#13;
&#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if( readSDA() != bit )&#13;
    {&#13;
        // If the bit just written does not&#13;
        // match the bit just read, then&#13;
        // the code must have written a 1 and&#13;
        // some other controller has written&#13;
        // a 0 to the SDA line. In this&#13;
        // case, the controller loses the &#13;
        // arbitration test.&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    // Raise the SCL line to indicate to the&#13;
    // peripheral that the data is valid:&#13;
&#13;
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> setSCL();&#13;
&#13;
    // Must hold SCL line high for 5 usec:&#13;
&#13;
    delayMicroseconds( 4 );&#13;
&#13;
    // Clock stretching or synchronization&#13;
    // is handled here. Wait for the SCL&#13;
    // line to go high (it can be held&#13;
    // low by the peripheral or by another&#13;
    // controller):&#13;
&#13;
  <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> while( !readSCL() )&#13;
    {&#13;
        // Wait for SCL to go high&#13;
    }&#13;
&#13;
    // Return success&#13;
&#13;
    return 1;&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_43" title="43"/>The <code>sdaOut()</code> function writes a single bit to the I<sup>2</sup>C bus. Writing a bit to the I<sup>2</sup>C bus consists of the following sequence:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Set the SCL line low and verify that it is low <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Except for the start and stop conditions, the SDA line can change only while SCL is low.</li>&#13;
<li value="2">Put the bit on the SDA line <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</li>&#13;
<li value="3">Wait about a one-half clock period <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</li>&#13;
<li value="4">Verify that the data on the SDA line matches the data just written (that is, verify that bus contention is not occurring). Fail (return 0) if the data does not match <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</li>&#13;
<li value="5">Set the SCL line high <span aria-label="annotation5" class="CodeAnnotation">❺</span>.</li>&#13;
<li value="6">Wait for the SCL line to go high (clock stretching and synchronization) <span aria-label="annotation6" class="CodeAnnotation">❻</span>.</li>&#13;
</ol>&#13;
<p>Bus contention occurs if two controllers are trying to access the bus at the same time. This code detects bus contention if it writes a 1 to the SDA line and reads back a 0, which means the other controller is writing a 0. The I<sup>2</sup>C arbitration rule is “whoever writes the zero wins.” If this code returns failure to the caller, it must cease the transmission and restart it when the next stop condition comes along.</p>&#13;
<pre><code>// Listing3-1.ino (cont.):&#13;
//&#13;
// Transmitting a byte on the I2C bus.&#13;
//&#13;
// xmitByte-&#13;
//&#13;
// Transmits a byte across the I2C bus.&#13;
//&#13;
// Returns:&#13;
//     1: If ACK received after the transmission.&#13;
//     0: If NAK received after the transmission or &#13;
//        if there was bus contention (and this code&#13;
//        has to give up the bus).&#13;
//&#13;
// Precondition:  &#13;
//     SCL must be low.&#13;
//&#13;
// Postcondition:&#13;
//     If arbitration failure, SDA and SCL will &#13;
//     both be high (to avoid conflicts with some &#13;
//     other controller).&#13;
//&#13;
// If successful:&#13;
//     SCL will be low.&#13;
&#13;
int xmitByte( byte xmit )&#13;
{&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> int result = sdaOut( xmit &amp; 0x80 ); // MSB first!&#13;
    if( result )&#13;
<span epub:type="pagebreak" id="Page_44" title="44"/>        result = sdaOut( xmit &amp; 0x40 ); // Bit 6&#13;
    if( result )&#13;
        result = sdaOut( xmit &amp; 0x20 ); // Bit 5&#13;
    if( result )&#13;
        result = sdaOut( xmit &amp; 0x10 ); // Bit 4&#13;
    if( result )&#13;
        result = sdaOut( xmit &amp; 0x8 );  // Bit 3&#13;
    if( result )&#13;
        result = sdaOut( xmit &amp; 0x4 );  // Bit 2&#13;
    if( result )&#13;
        result = sdaOut( xmit &amp; 0x2 );  // Bit 1&#13;
    if( result )&#13;
        result = sdaOut( xmit &amp; 0x1 );  // Bit 0&#13;
&#13;
    if( result )&#13;
    {&#13;
        // And now the code must wait for &#13;
        // the acknowledge bit:&#13;
&#13;
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> clrSCL();&#13;
        delayMicroseconds( 1 );&#13;
        pinMode( SDA, INPUT );  // It's an input&#13;
        delayMicroseconds( 3 ); // 1/2 clock cycle&#13;
&#13;
        // Raise the clock line and wait for it&#13;
        // to go high, which also handles clock&#13;
        // stretching and synchronization.&#13;
&#13;
        setSCL();               // Raise clock line&#13;
        while( !readSCL() );&#13;
&#13;
        // Note that the clock line is high, so&#13;
        // this code can read the SDA bit (acknowledge).&#13;
&#13;
        delayMicroseconds( 3 ); // Data valid for 5 usec&#13;
        result = readSDA();&#13;
&#13;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> clrSCL();               // Exit with SCL = 0&#13;
        while( readSCL() );&#13;
        return !result;&#13;
    }&#13;
&#13;
    // If there is an arbitration failure,&#13;
    // then try to transmit a 1 bit while the&#13;
    // other controller transmits a 0 bit.&#13;
    // The 0 bit always wins, so this function &#13;
    // sets SDA and SCL to 1 to avoid creating &#13;
    // other problems for the other controller.&#13;
&#13;
    setSCL();&#13;
    setSDA();&#13;
    return 0;   // Arbitration failure&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_45" title="45"/>The <code>xmitByte()</code> function transmits a whole byte across the I<sup>2</sup>C bus. Obviously, this function calls <code>sdaOut()</code> eight times to transmit the 8 bits <span aria-label="annotation1" class="CodeAnnotation">❶</span>. As per the I<sup>2</sup>C standard, this code ships the bits out from the MSB down to the LSB. If at any time a call to <code>sdaOut()</code> returns failure, this function also returns failure.</p>&#13;
<p>At the end of the byte transmission, this code sets the SDA line high and issues an additional pulse on the SCL line <span aria-label="annotation2" class="CodeAnnotation">❷</span>. While SCL is high, this code reads the SDA line. This retrieves either the acknowledge bit (0) from the peripheral, or, if there is not acknowledgment, a default NAK of 1. This function returns true if the transmission was properly acknowledged, and false otherwise.</p>&#13;
<p>After reading the acknowledgment bit, this code sets SCL low and continuously reads the line, waiting for it to actually go low <span aria-label="annotation3" class="CodeAnnotation">❸</span>. </p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
// &#13;
// Transmitting a sequence of bytes on the I2C bus.&#13;
//&#13;
// xmitBytes-&#13;
//&#13;
// Transmit a block of bytes (in write mode)&#13;
// via the I2C bus. adrs is the I2C device&#13;
// address. bytes is the array of bytes&#13;
// to transmit (after the address byte).&#13;
// cnt is the number of bytes to transmit&#13;
// from the bytes array. addStop is true&#13;
// if this function is to add a stop condition&#13;
// at the end of the transmission.&#13;
//&#13;
// Note that, including the address byte,&#13;
// this function actually transmits cnt + 1&#13;
// bytes over the bus.&#13;
&#13;
int xmitBytes&#13;
(&#13;
    byte adrs,&#13;
    byte bytes[],&#13;
    int cnt,&#13;
    int addStop&#13;
)&#13;
{&#13;
    int result;&#13;
&#13;
    // Send the start condition.&#13;
&#13;
    result = setStartCond();&#13;
    if( result )&#13;
    {&#13;
        // If bus was not in use, transmit&#13;
        // the address byte:&#13;
&#13;
        result = xmitByte( adrs &lt;&lt; 1 );&#13;
        if( result )&#13;
        {&#13;
            // If there wasn't bus contention,&#13;
            // ship out the bytes (as long as&#13;
<span epub:type="pagebreak" id="Page_46" title="46"/>            // bus contention does not occur):&#13;
&#13;
            for( int i=0; i &lt; cnt; ++i )&#13;
            {&#13;
                result = xmitByte( bytes[i] );&#13;
                if( !result ) break;&#13;
            }&#13;
        }&#13;
        // If the transmission was correct to this&#13;
        // point, transmit the stop condition.&#13;
        // Note: if addStop() is false, don't send a &#13;
        // stop condition after this transmission&#13;
        // because a repeated start is about&#13;
        // to happen.&#13;
&#13;
        if( result &amp;&amp; addStop )&#13;
        {&#13;
            setStopCond();&#13;
        }&#13;
    }&#13;
    return result;&#13;
}</code></pre>&#13;
<p>The <code>xmitBytes()</code> function handles a complete I<sup>2</sup>C write transmission. The caller passes it the I<sup>2</sup>C address of the peripheral, an array of bytes (along with a count), and a special “stop” flag, and this function sends out the appropriate start condition and address byte and writes all the data bytes. If the <code>addStop</code> flag is <code>true</code>, this function also attaches a stop condition to the end of the transmission. If <code>addStop</code> is <code>false</code>, this function transmits the data without the stop condition—presumably because you want to hold the I<sup>2</sup>C bus and issue a repeated start condition shortly thereafter.</p>&#13;
<p>This function returns <code>true</code> or <code>false</code> based on success or failure of the transmission. If this function returns <code>false</code>, either the bus is already in use or there was bus contention, and this code lost the arbitration battle. Whatever the reason, if this function returns <code>false</code>, the caller must retry the transmission later.</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Receiving a single bit on the I2C bus.&#13;
//&#13;
// sdaIn-&#13;
//&#13;
// Retrieves a single bit from the SDA line.&#13;
&#13;
byte sdaIn( void )&#13;
{&#13;
&#13;
    // Take SCL low before writing to the&#13;
    // data line. Wait until SCL is actually&#13;
    // low before proceeding:&#13;
&#13;
    clrSCL();&#13;
<span epub:type="pagebreak" id="Page_47" title="47"/>    while( readSCL() );&#13;
&#13;
    // Wait for 1/2 clock period for &#13;
    // the peripheral to put the data&#13;
    // on the SDA line:&#13;
&#13;
    delayMicroseconds( 4 );&#13;
&#13;
    // Bring the clock line high.&#13;
&#13;
    setSCL();&#13;
&#13;
    // Wait until it actually goes high&#13;
    // (stretching or syncing might be&#13;
    // happening here).&#13;
&#13;
    while( !readSCL() );&#13;
&#13;
    // Wait for 1/2 of the I2C clock period&#13;
    // while SCL is high:&#13;
&#13;
    delayMicroseconds( 3 );&#13;
&#13;
    // Read the data from the SDA line:&#13;
&#13;
    byte input = readSDA();&#13;
&#13;
    // Hold SCL line high for the&#13;
    // remainder of this 1/2&#13;
    // clock period:&#13;
&#13;
    delayMicroseconds( 2 );&#13;
&#13;
    // Return result.&#13;
&#13;
    return input;&#13;
}</code></pre>&#13;
<p>The <code>sdaIn()</code> function reads a single bit from the I<sup>2</sup>C bus. This function is similar to <code>sdaOut()</code>, except that it reads the data from SDA rather than writing data. Also, there is no need to check for arbitration failure when reading, though this function still handles clock stretching and synchronization. Although the data is coming from the peripheral, it is still the controller’s responsibility to drive the clock signal on the SCL line.</p>&#13;
<pre><code>// Listing3-1.ino (cont.):&#13;
//&#13;
// Receiving a byte on the I2C bus.&#13;
//&#13;
// rcvByte-&#13;
//&#13;
// Receives a byte from the I2C bus.&#13;
//&#13;
<span epub:type="pagebreak" id="Page_48" title="48"/>// Precondition:  &#13;
//    SCL must be low.&#13;
// Postcondition: &#13;
//    SCL will be low.&#13;
&#13;
byte rcvByte( void )&#13;
{&#13;
    setSDA();           // Before reading inputs&#13;
    byte result = sdaIn()  7;&#13;
    result |= sdaIn() &lt;&lt; 6;&#13;
    result |= sdaIn() &lt;&lt; 5;&#13;
    result |= sdaIn() &lt;&lt; 4;&#13;
    result |= sdaIn() &lt;&lt; 3;&#13;
    result |= sdaIn() &lt;&lt; 2;&#13;
    result |= sdaIn() &lt;&lt; 1;&#13;
    result |= sdaIn();&#13;
&#13;
    // Generate the ACK bit:&#13;
&#13;
    clrSCL();&#13;
    while( readSCL() ); // Wait until it's low&#13;
    delayMicroseconds( 2 );&#13;
    clrSDA();&#13;
    delayMicroseconds( 2 );&#13;
    setSCL();&#13;
    while( !readSCL() )&#13;
    {&#13;
        // Wait until SCL goes high (could be&#13;
        // waiting for stretching or syncing).&#13;
    }&#13;
    delayMicroseconds( 4 );&#13;
&#13;
    // Leave SCL low for the next byte&#13;
    // or the beginning of the stop&#13;
    // condition:&#13;
&#13;
    clrSCL();&#13;
    return result;&#13;
&#13;
}</code></pre>&#13;
<p>The <code>rcvByte()</code> function reads an 8-bit byte from the I<sup>2</sup>C bus by calling the <code>sdaIn()</code> function eight times. After the function reads those 8 bits, the controller is responsible for putting the ACK signal (a 0) on the SDA line to inform the peripheral that everything has gone well. This function returns the byte read as the function result.</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Receiving a sequence of bytes on the I2C bus.&#13;
&#13;
int rcvBytes( byte adrs, byte bytes[], int cnt, int addStop )&#13;
{&#13;
<span epub:type="pagebreak" id="Page_49" title="49"/>    int result;&#13;
&#13;
    // Send the start condition.&#13;
&#13;
    result = setStartCond();&#13;
    if( result )&#13;
    {&#13;
        // If bus was not in use, transmit&#13;
        // the address byte:&#13;
&#13;
        result = xmitByte( (adrs &lt;&lt; 1) | 1 );&#13;
        if( result )&#13;
        {&#13;
            // Read the specified number of&#13;
            // bytes from the bus:&#13;
&#13;
            for( int i=0; i &lt; cnt; ++i )&#13;
            {&#13;
                bytes[i] = rcvByte();&#13;
            }&#13;
        }&#13;
&#13;
        // If no errors at this point, transmit&#13;
        // the stop condition.&#13;
        // Note: if addStop is false, don't send&#13;
        // a stop condition after this transmission&#13;
        // because a repeated start is about&#13;
        // to happen.&#13;
&#13;
        if( result &amp;&amp; addStop )&#13;
        {&#13;
            setStopCond();&#13;
        }&#13;
    }&#13;
    return result;&#13;
}</code></pre>&#13;
<p>The <code>rcvBytes()</code> function is the input analog to the <code>xmitBytes()</code> function. It acquires the I<sup>2</sup>C bus, transmitting a start condition; transmits the address byte with a high R/W bit; and then receives some specified number of bytes from the peripheral device. Optionally, this function will transmit a stop condition after receiving the bytes.</p>&#13;
<p>The code, up to this point, for <em>Listing3-1.ino</em> is the complete set of routines needed to implement a software-based I<sup>2</sup>C controller. The remainder of <em>Listing3-1.ino </em>contains the usual Arduino initialization (<code>setup</code>) and main <code>loop</code> functions. </p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Arduino setup() function for Listing3-1.ino.&#13;
//&#13;
// Standard Arduino initialization code:&#13;
&#13;
void setup( void )&#13;
<span epub:type="pagebreak" id="Page_50" title="50"/>{&#13;
    pinMode( SCL, INPUT ); // Begin with SCL/SDA = 1&#13;
    pinMode( SDA, INPUT );&#13;
&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "teensyTest" );&#13;
}</code></pre>&#13;
<p>The <code>setup()</code> function sets up the SCL and SDA pins as inputs so they are left in the high condition to avoid interfering with other controllers.</p>&#13;
<pre><code>// Listing3-1.ino (cont.): &#13;
//&#13;
// Arduino main loop() function for Listing3-1.ino.&#13;
//&#13;
// Arduino main loop:&#13;
&#13;
void loop( void )&#13;
{&#13;
    static  int     result;&#13;
    static  word    adcValue;&#13;
    static  byte    bytes[16];&#13;
&#13;
    // Read a 12-bit value from&#13;
    // an Adafruit ADS1115 breakout&#13;
    // board. The following configuration&#13;
    // is for:&#13;
    //&#13;
    // * AIN[0]&#13;
    // * 0-4.096 V operation&#13;
    // * 1600 samples/second&#13;
    // * Disabled comparator&#13;
&#13;
    adcValue    = 0;&#13;
    bytes[0]    = 1;        // Point at config reg&#13;
    bytes[1]    = 0xc2;     // MSB of config&#13;
    bytes[2]    = 0x03;     // LSB of config&#13;
&#13;
    // adcValue = ADS1115.readADC_SingleEnded( 0 );&#13;
    // Serial.print( "ADC: ");&#13;
    // Serial.println( adcValue, 16 );&#13;
&#13;
    result  = xmitBytes( ADS1115_ADDR, bytes, 3, true );&#13;
    if( result )&#13;
    {&#13;
    // Point at the conversion register. Note that&#13;
    // this is a repeated start condition command&#13;
    // but ends with a stop condition.&#13;
&#13;
        bytes[0] = 0;&#13;
        result = xmitBytes( ADS1115_ADDR, bytes, 1, true );&#13;
&#13;
        // Read the ADC value from the ADS1115.&#13;
&#13;
<span epub:type="pagebreak" id="Page_51" title="51"/>        if( result )&#13;
        {&#13;
            // This really should go into a loop&#13;
            // testing bit 16 of the config (status)&#13;
            // register, but this is easier:&#13;
&#13;
            delay( 1 );&#13;
&#13;
            result = rcvBytes( ADS1115_ADDR, bytes, 2, true );&#13;
            if( result )&#13;
            {&#13;
                adcValue = (bytes[0] &lt;&lt; 8) | bytes[1];&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // Start by writing 64 (0x40) to&#13;
    // the DAC register (command byte&#13;
    // which states that the next two&#13;
    // bytes go into the DAC register).&#13;
&#13;
    bytes[0] = 64;&#13;
&#13;
    // The next two bytes to write are the&#13;
    // 12 bits of the DAC value. The HO&#13;
    // 4 bits are put in the first byte&#13;
    // and the LO 8 bits appear in the&#13;
    // second byte.&#13;
&#13;
    float volts = (((float) adcValue) * 4.096 / 32768.0 );&#13;
    Serial.print( "Volts: " ); Serial.print( volts, 3 );&#13;
    adcValue    = (word) (volts * 65536.0/5);&#13;
    bytes[1]    = (adcValue &gt;&gt; 8) &amp; 0xff;&#13;
    bytes[2]    = (adcValue &amp; 0xf0);&#13;
&#13;
    // Transmit the data to the DAC IC:&#13;
&#13;
    if( !xmitBytes( MCP4725_ADDR, bytes, 3, true ) )&#13;
    {&#13;
        // If there was an arbitration failure,&#13;
        // wait for a start condition to come along.&#13;
&#13;
        waitForStop();&#13;
    }&#13;
    Serial.println();&#13;
    delay( 100 );&#13;
&#13;
}</code></pre>&#13;
<p>The main <code>loop()</code> function reads data from an ADS1115 analog-to-digital converter (ADC), translates the input, and writes the data to an MCP4725 digital-to-analog converter (DAC). Though the conversion isn’t perfect, this effectively copies the input voltage present on A0 of the ADC to the analog output on the DAC. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" id="Page_52" title="52"/><h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	For more information on the MCP4725, see Chapter 15. For more information on the ADS1115, see Chapter 14.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>As explained earlier, this code is just an example to demonstrate how you would implement an I<sup>2</sup>C controller in software, so it’s not really intended to be used. For one thing, it’s written using standard functions rather than classes and methods, which makes it easier to understand but harder to use. It also may not port directly to other MCUs; although I wrote this code using mostly standard Arduino calls, I ran it through a logic analyzer to hand-tune all the delays to produce reasonable timing on a 96-MHz Teensy 3.2. I suspect the timing values might vary a bit too much on other faster or slower MCUs. </p>&#13;
<p>The other problem with this code is that it uses a single pair of I/O pins for the SDA and SCL lines. Constantly changing the data direction on the pins to make them bidirectional is the standard way of doing things in software I<sup>2</sup>C implementations. While this approach probably works just fine in single-controller environments and when working with peripherals that don’t implement too many optional features, I’m not confident it will work flawlessly in multicontroller environments. Unfortunately, the race conditions that might exist—possible errant calculations based on the timing of your program’s execution—are difficult to create (for testing).</p>&#13;
<h3 id="h2-502468c03-0002">3.1.2	A Software-Based I<sup>2</sup>C Peripheral for the Teensy 3.2</h3>&#13;
<p class="BodyFirst">The previous section provided a software implementation of an I<sup>2</sup>C controller device. This section provides the companion to that implementation: a software-controlled I<sup>2</sup>C peripheral device. The code in this section turns a Teensy 3.2 into an I<sup>2</sup>C peripheral with the following features:</p>&#13;
<ul>&#13;
<li>It saves any byte value written to it.</li>&#13;
<li>When the controller reads a byte from it, it returns the last value written, or 0 if there was no previously written byte.</li>&#13;
</ul>&#13;
<p>Effectively, this code turns the Teensy into a 1-byte I<sup>2</sup>C memory unit. Although this is a lame I<sup>2</sup>C peripheral, it completely demonstrates everything you need in order to develop your own software-based I<sup>2</sup>C peripheral.</p>&#13;
<p>In many respects, the peripheral software is easier to write. The peripheral doesn’t have to worry about bus contention, clock synchronization, and many other issues. On the other hand, the peripheral should respond to several optional messages that controllers don’t have to worry about.</p>&#13;
<p>The following code ignores all the reserved address values. For the general call address reset function, it might be reasonable to set the stored memory value to 0 (though it’s easy enough to write a 0 to this peripheral if you want). You could also create a device ID for this peripheral; I will leave that exercise to you.</p>&#13;
<p><span epub:type="pagebreak" id="Page_53" title="53"/><a href="#listing3-2" id="listinganchor3-2">Listing 3-2</a> provides the source code for this simple peripheral. </p>&#13;
<pre><code>// <a id="listing3-2">Listing3-2</a>.ino&#13;
// &#13;
// Software-based I2C peripheral device for&#13;
// the Teensy 3.2.&#13;
//&#13;
// Copyright 2020, Randall Hyde.&#13;
// All rights reserved.&#13;
// Released under Creative Commons 4.0.&#13;
&#13;
#include &lt;arduino.h&gt;&#13;
&#13;
// Pins on the Teensy 3.2 to use for the&#13;
// software SCL and SDA lines:&#13;
&#13;
#define SCL 0&#13;
#define SDA 1&#13;
&#13;
// PeriphAddress is the address of this PeripheralAddress.&#13;
&#13;
#define PeriphAddress (0x50)&#13;
#define PeripheralAddress ((PeriphAddress) &lt;&lt; 1)&#13;
&#13;
// digitalWriteFast is a Teensy-specific function. Change&#13;
// to digitalWrite for standard Arduino.&#13;
// Likewise, digitalReadFast changes to digitalRead for&#13;
// standard Arduino.&#13;
&#13;
#define pinWrite digitalWriteFast&#13;
#define pinRead  digitalReadFast</code></pre>&#13;
<p>As for the controller code, the two identifiers <code>SCL</code> and <code>SDA</code> define the pin numbers on the Teensy 3.2 that this code will use for the SCL and SDA lines. The <code>PeriphAddress</code> definition specifies the I<sup>2</sup>C address to which this peripheral will respond. To finish the definitions, <code>pinRead</code> and <code>pinWrite</code> expand to Teensy-specific (fast) versions of the Arduino <code>digitalRead()</code> and <code>digitalWrite()</code> functions.</p>&#13;
<pre><code>// Listing3-2.ino (cont):  &#13;
// &#13;
// Pin control functions.&#13;
//&#13;
// setSCL-&#13;
// &#13;
// Sets the SCL pin high (1) by changing the pin mode&#13;
// to input and relying on the I2C bus pullup resistor&#13;
// to put a 1 on the bus.&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void setSCL( void )&#13;
{&#13;
    pinMode( SCL, INPUT );&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="Page_54" title="54"/>// clrSCL-&#13;
//&#13;
// Sets the SCL pin low. Changes the pin mode to output and&#13;
// writes a 0 to the pin to pull down the SCL line. Used&#13;
// mainly for clock stretching.&#13;
&#13;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void clrSCL( void )&#13;
{&#13;
    pinMode( SCL, OUTPUT );&#13;
    pinWrite( SCL, 0 );&#13;
}&#13;
&#13;
// setSDA, clrSDA-&#13;
//&#13;
// Same as setSCL and clrSCL except they set or clr the SDA line.&#13;
&#13;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> void setSDA( void )&#13;
{&#13;
    pinMode( SDA, INPUT );&#13;
}&#13;
&#13;
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> void clrSDA( void )&#13;
{&#13;
    pinMode( SDA, OUTPUT );&#13;
    pinWrite( SDA, 0 );&#13;
}&#13;
&#13;
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span> // readSCL-&#13;
//&#13;
// Reads SCL pin until it gets the same value twice in&#13;
// a row. This is done to filter noise.&#13;
&#13;
inline byte readSCL( void )&#13;
{&#13;
    byte first;&#13;
    byte second;&#13;
    do&#13;
    {&#13;
        first = pinRead( SCL );&#13;
        second = pinRead( SCL );&#13;
    }while( first != second );&#13;
    return first;&#13;
}&#13;
&#13;
<span aria-label="annotation6" class="CodeAnnotationHang">❻</span> // readSDA-&#13;
//&#13;
// Reads SDA pin until it gets the same value twice in&#13;
// a row. This is done to filter noise.&#13;
&#13;
inline byte readSDA( void )&#13;
{&#13;
    byte first;&#13;
    byte second;&#13;
    do&#13;
    {&#13;
<span epub:type="pagebreak" id="Page_55" title="55"/>        first = pinRead( SDA );&#13;
        second = pinRead( SDA );&#13;
    }while( first != second );&#13;
    return first;&#13;
}</code></pre>&#13;
<p>The <code>setSCL()</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span>, <code>clrSCL()</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, <code>setSDA()</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span>, and <code>clrSDA()</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span> functions were copied straight over from the controller code; they set or clear the SCL and SDA lines. Likewise, the <code>readSCL()</code> <span aria-label="annotation5" class="CodeAnnotation">❺</span> and <code>readSDA()</code> <span aria-label="annotation6" class="CodeAnnotation">❻</span> functions (also copied from the controller code) read the current values on the SDA and SCL lines. Refer back to the sections of <em>Listing3-1.ino</em> that begin with the comments <code>Pin set functions</code> and <code>Reading the SCL and SDA pins</code> for more details.</p>&#13;
<pre><code>// Listing3-2.ino (cont.): &#13;
//&#13;
// Transmitting a single bit on the I2C bus.&#13;
//&#13;
// sdaOut-&#13;
//&#13;
//     bit: Bit to transmit.&#13;
//     Transmits a single bit over the SDA/SCL lines.&#13;
//&#13;
// Returns:&#13;
//     1: If successful.&#13;
//     0: If arbitration failure or other error.&#13;
&#13;
void sdaOut( byte bit )&#13;
{&#13;
    unsigned long time;&#13;
&#13;
    bit = !!bit;    // Force 0/1&#13;
&#13;
    // Wait until SCL is low.&#13;
    // It's okay to change SDA&#13;
    // when SCL is low:&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> while( readSCL() );&#13;
&#13;
    // Set the SDA line appropriately.&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if( bit )&#13;
    {&#13;
        setSDA();&#13;
    }&#13;
    else&#13;
    {&#13;
        clrSDA();&#13;
    }&#13;
&#13;
    // Wait for the SCL line to go high and&#13;
    // then back to low. After that, release&#13;
    // the SDA line by setting it to 1.&#13;
&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> while( !readSCL() );&#13;
&#13;
<span epub:type="pagebreak" id="Page_56" title="56"/>    time = micros() + 15;&#13;
    while( readSCL() )&#13;
    {&#13;
        // If stuck in this loop for&#13;
        // more than 15 usec, then bail.&#13;
        // Need a timeout so it doesn't&#13;
        // hold SDA low for an extended&#13;
        // period of time.&#13;
&#13;
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if( micros() &gt; time ) break;&#13;
    }&#13;
&#13;
    // Release the SDA line by setting it high.&#13;
&#13;
    setSDA();&#13;
}</code></pre>&#13;
<p>The <code>sdaOut()</code> function places a single bit, passed as an argument, on the SDA line in response to an SCL clock transition. Unlike the controller code, the peripheral code does not control the SCL line. Instead, the controller must pulse the clock line. </p>&#13;
<ol class="decimal">&#13;
<li value="1">The <code>sdaOut()</code> function must wait until the clock line is low <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</li>&#13;
<li value="2">Then it can write the data to the SDA line <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</li>&#13;
<li value="3">Finally, it waits for the SCL line to go high and then back low again before returning <span aria-label="annotation3" class="CodeAnnotation">❸</span>. </li>&#13;
</ol>&#13;
<p>Note that this code has a timeout while waiting for the SCL line to go high. If for some reason the controller doesn’t bring the SCL line back high, this code will break out of the wait loop after about 15 µsec rather than just hang up <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>&#13;
<pre><code>// Listing3-2.ino (cont.): &#13;
//&#13;
// Transmitting a byte on the I2C bus.&#13;
//&#13;
// xmitByte-&#13;
//&#13;
// Transmits a whole byte by call sdaOut&#13;
// eight times.&#13;
&#13;
void xmitByte( byte xmit )&#13;
{&#13;
    unsigned long time;&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> sdaOut( xmit &amp; 0x80 );&#13;
    sdaOut( xmit &amp; 0x40 );&#13;
    sdaOut( xmit &amp; 0x20 );&#13;
    sdaOut( xmit &amp; 0x10 );&#13;
    sdaOut( xmit &amp; 0x8 );&#13;
    sdaOut( xmit &amp; 0x4 );&#13;
    sdaOut( xmit &amp; 0x2 );&#13;
    sdaOut( xmit &amp; 0x1 );&#13;
&#13;
<span epub:type="pagebreak" id="Page_57" title="57"/>    // The controller will generate the ACK&#13;
    // bit. This code will ignore it.&#13;
    // However, it does have to wait for&#13;
    // the clock pulse (low-&gt;high-&gt;low)&#13;
    // to come along.&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> while( readSCL() ); // Wait for low clock&#13;
&#13;
    time = micros()+25;&#13;
    while( !readSCL() )&#13;
    {&#13;
        // Wait until SCL goes high (could be&#13;
        // waiting for stretching or syncing).&#13;
        // Bail if there is a timeout, though.&#13;
&#13;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if( micros() &gt; time ) break;&#13;
    }&#13;
&#13;
    // Okay, SCL is (probably) high; wait for it&#13;
    // to go low again:&#13;
&#13;
    while( readSCL() );&#13;
}</code></pre>&#13;
<p>The <code>xmitByte()</code> function transmits an 8-bit byte on the SDA line by calling <code>sdaOut()</code> eight times <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This code also consumes the clock cycle for the ninth bit—the acknowledge bit <span aria-label="annotation2" class="CodeAnnotation">❷</span>—though it ignores that bit’s state, since some controllers don’t bother putting the ACK bit on the SDA line. This code also has a timeout <span aria-label="annotation3" class="CodeAnnotation">❸</span> in case the SCL line never goes high while it is waiting for the acknowledge bit.</p>&#13;
<pre><code>// Listing3-2.ino (cont.): &#13;
//&#13;
// Receiving a single bit on the I2C bus.&#13;
//&#13;
// sdaIn-&#13;
//&#13;
// Retrieves a single bit from the SDA line.&#13;
// Note: no timeout on the loops because this&#13;
// code doesn't mess with the SDA line.&#13;
&#13;
byte sdaIn( void )&#13;
{&#13;
    byte input;&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> while( readSCL() );&#13;
&#13;
    // Wait until the SCL line is high.&#13;
    // That is when data will be valid&#13;
    // on the SDA line:&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> while( !readSCL() );&#13;
&#13;
<span epub:type="pagebreak" id="Page_58" title="58"/>    // Wait for a small amount of time for the&#13;
    // controller's data to be stabilized&#13;
    // on the SDA line:&#13;
&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> delayMicroseconds( 1 );&#13;
&#13;
    // Read the data from the SDA line:&#13;
&#13;
    input = readSDA();&#13;
&#13;
    // Return result:&#13;
&#13;
    return input;&#13;
}</code></pre>&#13;
<p>The <code>sdaIn()</code> function reads a bit appearing on the SDA line. It begins by waiting until the SCL line is low <span aria-label="annotation1" class="CodeAnnotation">❶</span>, if it wasn’t already. Then it waits for the SCL line to go high (the start of the read cycle) because SDA data is valid only while the clock line is high <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Once the clock line goes high, this function delays for a microsecond to give the data time to settle, and then this function reads the data from the SDA line <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>&#13;
<pre><code>// Listing3-2.ino (cont.): &#13;
//&#13;
// Receiving a byte on the I2C bus.&#13;
//&#13;
// rcvByte-&#13;
//&#13;
// Receives a byte from the I2C bus.&#13;
&#13;
byte rcvByte( void )&#13;
{&#13;
    unsigned long time;&#13;
&#13;
    pinMode( SDA, INPUT );&#13;
&#13;
    // Read 8 bits from the SDA line:&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> byte result7 = sdaIn() &lt;&lt; 7;&#13;
    byte result6 = sdaIn() &lt;&lt; 6;&#13;
    byte result5 = sdaIn() &lt;&lt; 5;&#13;
    byte result4 = sdaIn() &lt;&lt; 4;&#13;
    byte result3 = sdaIn() &lt;&lt; 3;&#13;
    byte result2 = sdaIn() &lt;&lt; 2;&#13;
    byte result1 = sdaIn() &lt;&lt; 1;&#13;
    byte result0 = sdaIn();&#13;
    byte result = result7&#13;
        |   result6&#13;
        |   result5&#13;
        |   result4&#13;
        |   result3&#13;
        |   result2&#13;
        |   result1&#13;
        |   result0;&#13;
&#13;
<span epub:type="pagebreak" id="Page_59" title="59"/>    // Generate the ACK bit.&#13;
    // Wait for the SCL line to go low,&#13;
    // pull SDA low, then wait for the&#13;
    // SCL line to go high and low:&#13;
&#13;
    while( readSCL() );&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> clrSDA();&#13;
    time = micros()+25;&#13;
    while( !readSCL() )&#13;
    {&#13;
&#13;
    // Wait until SCL goes high (could be&#13;
    // waiting for stretching or syncing).&#13;
    // Bail if there is a timeout, though.&#13;
&#13;
        if( micros() &gt; time ) break;&#13;
    }&#13;
&#13;
    // Okay, SCL is (probably) high; wait for it to go&#13;
    // low again and then release the SDA line:&#13;
&#13;
    while( readSCL() );&#13;
    setSDA(); // Set SDA high (releases SDA)&#13;
&#13;
    return result;&#13;
}</code></pre>&#13;
<p>The <code>rcvByte()</code> function calls <code>sdaIn()</code> eight successive times to read a byte from the I<sup>2</sup>C bus <span aria-label="annotation1" class="CodeAnnotation">❶</span>. At the end of those 8 bits <span aria-label="annotation2" class="CodeAnnotation">❷</span>, this function must pull the SDA line low to acknowledge the data: the ACK bit. The function pulls the SDA line low while SCL is low and leaves the SDA line while SCL is high, with the usual timeout check in case the controller leaves SCL high for too long.</p>&#13;
<pre><code>// Listing3-2.ino (cont.): &#13;
//&#13;
// Waiting for a start condition, while allowing other work.&#13;
//&#13;
// waitForStart-&#13;
//&#13;
// Wait until a start condition arrives.&#13;
// The peripheral address byte will follow.&#13;
//&#13;
// Start condition is:&#13;
//&#13;
//    SCL is high.&#13;
//    SDA goes from high to low.&#13;
//&#13;
// An address byte immediately follows the&#13;
// start condition. Read it. Return&#13;
// one of the following values:&#13;
//&#13;
<span epub:type="pagebreak" id="Page_60" title="60"/>// Negative:&#13;
//           Address does not match or&#13;
//           start condition yet to be&#13;
//           received.&#13;
//        0: Address match, R/W = 0 (W)&#13;
//        1: Address match, R/W = 1 (R)&#13;
//&#13;
// This function is a state machine that&#13;
// rapidly returns. It has the following&#13;
// states:&#13;
//&#13;
// -1: Waiting for SCL and SDA to both&#13;
//     be high.&#13;
// -2: SCL and SDA are both high, waiting&#13;
//     for SDA to go low.&#13;
&#13;
int waitForStart( void )&#13;
{&#13;
    static int  state = -1;&#13;
    byte        sdaVal;&#13;
    byte        sclVal;&#13;
&#13;
    switch( state )&#13;
    {&#13;
        case -1:&#13;
&#13;
            // Wait until the SCL line is high and the&#13;
            // SDA line is high.&#13;
&#13;
            if( readSCL() &amp;&amp; readSDA() )&#13;
            {&#13;
                state = -2;&#13;
            }&#13;
            return state;&#13;
&#13;
        case -2:&#13;
&#13;
            // Start condition may have begun. Wait&#13;
            // for the data line to go low while&#13;
            // the SCL line remains high:&#13;
&#13;
            sdaVal = readSDA();&#13;
            sclVal = readSCL();&#13;
            if( !sdaVal &amp;&amp; sclVal )&#13;
            {&#13;
                break;&#13;
            }&#13;
&#13;
            // If code sees anything other than&#13;
            // SCL = 1 and SDA = 1 at this point,&#13;
            // it has to reset the state machine&#13;
            // to -1.&#13;
&#13;
            if( !( sclVal &amp;&amp; sdaVal ) )&#13;
            {&#13;
<span epub:type="pagebreak" id="Page_61" title="61"/>                state = -1;&#13;
            }&#13;
            return state;&#13;
&#13;
        // Just a fail-safe case:&#13;
&#13;
        default:&#13;
            state = -1;&#13;
            return state;&#13;
&#13;
    }   // Switch&#13;
&#13;
    // Reset the state machine for the next invocation:&#13;
&#13;
    state = -1;&#13;
&#13;
    // Okay, there is a start condition.&#13;
    // Read the address byte.&#13;
&#13;
    byte address = rcvByte();&#13;
    if( (address &amp; 0xFE) == PeripheralAddress )&#13;
    {&#13;
        return address &amp; 1;&#13;
    }&#13;
    return -1;  // Not our address&#13;
}</code></pre>&#13;
<p>The <code>waitForStart()</code> function doesn’t actually wait for a start condition to happen. Instead, it is a state machine that traverses between states on each call based on the state of the SDA and SCL lines. This function returns 0, 1, or some negative number. </p>&#13;
<p>A 0 return result indicates an address match with a write operation. A return value of 1 indicates an address match with a read operation. A negative return value indicates that nothing of interest has come along just yet and the caller should repeat the call in the near future, fast enough to catch an incoming start condition.</p>&#13;
<p>The <code>waitForStart()</code> function was written this way—rather than not returning until a start condition and valid address have come along—because it allows the CPU to do other work while waiting for a start condition.</p>&#13;
<pre><code>// Listing3-2.ino (cont.): &#13;
//&#13;
// Standard Arduino setup() function.&#13;
//&#13;
// Standard Arduino initialization code:&#13;
&#13;
void setup( void )&#13;
{&#13;
    pinMode( SCL, INPUT ); // Begin with SCL/SDA = 1&#13;
    pinMode( SDA, INPUT );&#13;
&#13;
    Serial.begin( 9600 );&#13;
<span epub:type="pagebreak" id="Page_62" title="62"/>    delay( 1000 );&#13;
    Serial.println( "teensy Peripheral Test" );&#13;
}</code></pre>&#13;
<p>The standard Arduino <code>setup()</code> function just initializes the SDA and SCL lines as inputs, putting a 1 on these lines, so that this peripheral does not interfere with any other activity taking place on the bus. This particular code also prints a message to the <code>Serial</code> output for debugging purposes.</p>&#13;
<pre><code>// Listing3-2.ino (cont.): &#13;
//&#13;
// Standard Arduino loop() function.&#13;
//&#13;
// Arduino main loop:&#13;
&#13;
void loop( void )&#13;
{&#13;
    static byte memory = 0; // Holds I2C memory byte&#13;
&#13;
    // Wait for a start condition to arrive.&#13;
    // If not a start condition yet, just&#13;
    // keep looping.&#13;
    //&#13;
    // Assumption: Arduino code outside this&#13;
    // loop takes less than about 5 usec&#13;
    // to execute. If that is not the case,&#13;
    // then waitForStart() should be called&#13;
    // in a hard loop to continuously poll&#13;
    // for a start condition.&#13;
&#13;
    int gotStart = waitForStart();&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if( gotStart == 0 )         // Write request&#13;
    {&#13;
        // On write operation, read the next byte&#13;
        // coming from the I2C bus and store it&#13;
        // into the memory location.&#13;
&#13;
        memory = rcvByte();&#13;
&#13;
        Serial.print( "Memory=" );&#13;
        Serial.println( memory, 16 );&#13;
    }&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> else if( gotStart == 1 )    // Read request&#13;
    {&#13;
        // On a read request, transmit the&#13;
        // value in memory across the I2C bus.&#13;
&#13;
        xmitByte( memory );&#13;
        Serial.print( "Transmitted " );&#13;
        Serial.println( memory );&#13;
&#13;
    }&#13;
<span epub:type="pagebreak" id="Page_63" title="63"/>  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> // else: not of interest to us.&#13;
&#13;
}</code></pre>&#13;
<p>The Arduino loop function is the main body of the peripheral program. It calls the <code>waitForStart()</code> function and checks the return value. It handles the following three cases:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">0</span>  A write operation (from controller to peripheral) is taking place. In this case the code reads the next byte available from the I<sup>2</sup>C bus and stores this value into the memory location <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</li>&#13;
<li><span class="RunInHead">1</span>  A read operation (controller is reading the peripheral) is taking place. In this case the code writes the value of the memory variable onto the I<sup>2</sup>C bus as the controller clocks out the next byte <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</li>&#13;
<li><span class="RunInHead">A negative value</span>  The main loop does nothing in this case; it just returns to the caller, which, after some possible internal bookkeeping work, calls the <code>loop()</code> function again <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</li>&#13;
</ol>&#13;
<p><a href="#listing3-3" id="listinganchor3-3">Listing 3-3</a> is a short Teensy 3.2/Arduino program I used to test the software-based I<sup>2</sup>C peripheral code appearing in <a href="#listing3-2">Listing 3-2</a>. </p>&#13;
<pre><code>// <a id="listing3-3">Listing3-3</a>.ino&#13;
//&#13;
// Software-based I2C test program.&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
#define LED 13&#13;
&#13;
void setup( void )&#13;
{&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "test.ino" );&#13;
    Wire.begin();&#13;
    pinMode( LED, OUTPUT );&#13;
}&#13;
&#13;
void loop( void )&#13;
{&#13;
    static byte value = 0;&#13;
&#13;
    digitalWrite( LED, 0 );&#13;
    Serial.print( "Writing: " );&#13;
    Serial.print( value, 16 );&#13;
    Wire.beginTransmission( 0x50 );&#13;
    Wire.write( value );&#13;
    Wire.endTransmission();&#13;
    delay( 250 );&#13;
&#13;
    digitalWrite( LED, 1 );&#13;
    Wire.requestFrom( 0x50, 1 );&#13;
    while( Wire.available() )&#13;
<span epub:type="pagebreak" id="Page_64" title="64"/>    {&#13;
        byte data = Wire.read();&#13;
        Serial.print( ", read=" );&#13;
        Serial.print( data, 16 );&#13;
        Serial.print( ", value=" );&#13;
        Serial.print( value, 16 );&#13;
    }&#13;
    Serial.println();&#13;
    ++value;&#13;
    delay( 250 );&#13;
}</code></pre>&#13;
<p>The code in <a href="#listing3-3">Listing 3-3</a> can run on a Teensy 3.2 or just about any Arduino-compatible system. It repeatedly writes a value to the peripheral and then reads that value back. See Chapter 8 for more details about how this sample program works.</p>&#13;
<h3 id="h2-502468c03-0003">3.1.3	Some Final Comments on the Teensy 3.2 Software I<sup><em>2</em></sup>C Code</h3>&#13;
<p class="BodyFirst">The software in the previous two sections was hand-tuned to work on a Teensy 3.2. It may not work on different systems, and it likely won’t work on significantly faster or slower systems. If you want to use this code for some other MCU, you’ll probably have to tweak and optimize it a bit, particularly on MCUs with lower performance and less memory than the Teensy 3.2. To provide an example of just such an optimization, Chapter 17 (online at <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a>) describes how to implement a controller and peripheral using an ATtiny84 CPU running at only 8 MHz.</p>&#13;
<p>There are a couple of issues with the Teensy software implementation of the I<sup>2</sup>C bus. First, this code is relatively fragile with respect to timing. It uses software delay loops to measure the I<sup>2</sup>C clock cycles. Interrupts and other activities that can suspend the execution of such delay code may produce incorrect timings, resulting in improper operation. Although there are a few timeout checks on various loops, a real-world project would require more of these checks to prevent the code from hanging up if an errant controller or peripheral is on the bus. While this chapter avoids too many timeout checks because they would have cluttered up the code and made it harder to understand, if you intend to use this code as the basis for a real-world project, you should address that shortcoming.</p>&#13;
<h2 id="h1-502468c03-0002">	3.2	Basic ATtiny84 and ATtiny85 Hardware</h2>&#13;
<p class="BodyFirst">The example code given thus far runs on a high-performance Teensy microcontroller. While that code is useful as an educational tool, in reality you usually won’t have to implement the I<sup>2</sup>C protocol on such a powerful processor—such processors will include built-in I<sup>2</sup>C hardware. Software-based I<sup>2</sup>C packages are far more common on low-end CPUs, such as the ATtiny84.</p>&#13;
<p>The ATtiny84 is a typical 8-bit AVR microcontroller similar to those found on low-end Arduino boards. These microcontrollers typically cost less than $3 (US) from vendors such as SparkFun (<a class="LinkURL" href="https://www.sparkfun.com/products/11232">https://www.sparkfun.com/products/11232</a>), <span epub:type="pagebreak" id="Page_65" title="65"/>and you can find them in small quantities (25 or so) for much less on Amazon or eBay. They have the following features:</p>&#13;
<ul>&#13;
<li>8-KB flash memory</li>&#13;
<li>512-bytes EEPROM</li>&#13;
<li>512 bytes of RAM</li>&#13;
<li>12-MHz operation using internal clock, 20 MHz using external crystal</li>&#13;
<li>One 8-bit and one 16-bit counter</li>&#13;
<li>10-bit ADCs</li>&#13;
<li>On-chip analog comparator</li>&#13;
<li>12 I/O pins (in 14-pin dual-in-line [DIP] package)</li>&#13;
<li>Nearly 12 MIPS operation at 12 MHz (1 MIPS/MHz)</li>&#13;
</ul>&#13;
<p class="BodyContinued">This CPU is great for handling 100-kHz I<sup>2</sup>C operations, assuming non-I<sup>2</sup>C activities are not especially compute intensive.</p>&#13;
<p>The ATtiny85 microcontroller IC is a similar device in an 8-pin DIP package with six GPIO pins. It has fewer peripheral devices built in (due to packing constraints), and the timers are both 8 bits, but otherwise it does the same job as the ATtiny84. Most source codes that don’t use the extra ATtiny84 features will run on both MCUs.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Technically, the ATtiny84 and ATtiny85 MCUs have a Universal Serial Interface (USI) port that you can program to support hardware I<sup>2</sup>C operations. However, that port might not be available; if it’s being used for SPI or other serial communication, this forces you to implement the I<sup>2</sup>C protocol in software.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>You can find the complete code for a SparkFun Atto84 device programmed as an I<sup>2</sup>C controller in Chapter 17 online. This code isn’t identical to the Teensy code in this chapter, but much of it is similar; the code was placed in the online chapter to avoid redundancy in this chapter. </p>&#13;
<h3 id="h2-502468c03-0004">3.2.1	Atto84 Software-Based I<sup><em>2</em></sup>C Peripheral</h3>&#13;
<p class="BodyFirst">Unfortunately, the Atto84 is just slightly too underpowered to support a reliable I<sup>2</sup>C peripheral mode in software. I spent several days attempting this with the following compromises:</p>&#13;
<ul>&#13;
<li>Dropping filtering on the SDA and SCL input lines</li>&#13;
<li>Removing timeout checks on loops</li>&#13;
<li>In-lining most of the functions that manipulate I/O port bits (including reading bits, waiting for the clock line to go high or low, and many other functions)</li>&#13;
<li>Dropping down into AVR assembly language for time-critical code</li>&#13;
</ul>&#13;
<p>In the end, the Atto84 managed to support peripheral mode once in a while but was not at all consistent. The Atto84 can act as a controller <span epub:type="pagebreak" id="Page_66" title="66"/>because it controls the clock frequency; if<sup> </sup>one-half clock periods wind up being stretched to 5.5 μsec, 6.0 μsec, or even 7.1 μsec, any normal peripheral can handle that just fine. However, as a peripheral, the Atto84 must be capable of always keeping up with a 100-kHz clock (5-μsec one-half clock periods), and even using straight-line assembly language code with all the compromises listed earlier is not quite good enough to do the job. The Atto84 still misses putting the ACK bit on the SDA line every now and then. Of course, once you remove all the timeouts from the loops, the code gets out of sync when it misses a bit, and things go very badly after that point.</p>&#13;
<p>This is not to say that you cannot use the Atto84 (or generic ATtiny84) as an I<sup>2</sup>C peripheral device. The generic ATtiny84 can run at up to 20 MHz with an external crystal, which might be fast enough to work. More importantly, the ATtiny84 has built-in hardware (the USI) that provides hardware support for I<sup>2</sup>C operations. I’ll return to this subject in Chapter 16.</p>&#13;
<h2 id="h1-502468c03-0003">	3.3	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter provided a software implementation of the I<sup>2</sup>C protocol running on a Teensy 3.2 microcontroller as an educational tool. It began by describing a small hardware setup using a Teensy 3.2, an Adafruit ADS1115 ADC breakout board, and a SparkFun MCP4725 DAC breakout board. After the basic hardware introduction, it presented a software implementation of an I<sup>2</sup>C controller and an I<sup>2</sup>C peripheral. Finally, it briefly reviewed issues with software-based I<sup>2</sup>C protocol implementation on an ATtiny84 microcontroller.</p>&#13;
<p>Carefully studying a software implementation of the I<sup>2</sup>C protocol will help solidify your understanding of its low-level details. That information becomes particularly important when you begin debugging I<sup>2</sup>C signals using logic and protocol analyzers. The next chapter will delve into that subject with a discussion of I<sup>2</sup>C debugging tools.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<ol class="none">&#13;
<li>Another Arduino-compatible software-based I<sup>2</sup>C library: <a class="LinkURL" href="https://www.arduinolibraries.info/libraries/soft-wire">https://www.arduinolibraries.info/libraries/soft-wire</a></li>&#13;
<li>Adafruit ADS1115 documentation: <a class="LinkURL" href="https://www.adafruit.com/product/1085">https://www.adafruit.com/product/1085</a></li>&#13;
<li>Adafruit MCP4725 documentation: <a class="LinkURL" href="https://www.adafruit.com/product/935">https://www.adafruit.com/product/935</a></li>&#13;
<li>Information about AVR assembly language, for those brave enough to try to best my attempts at a software-based I<sup>2</sup>C peripheral system using the Atto84:&#13;
<ol class="none sub">&#13;
<li>AVR Assembler documentation: <a class="LinkURL" href="https://ww1.microchip.com/downloads/en/devicedoc/40001917a.pdf%20">https://ww1.microchip.com/downloads/en/devicedoc/40001917a.pdf </a></li>&#13;
<li>More AVR Assembler documentation: <a class="LinkURL" href="https://academy.cba.mit.edu/classes/embedded_programming/doc1022.pdf">https://academy.cba.mit.edu/classes/embedded_programming/doc1022.pdf</a></li>&#13;
</ol>&#13;
</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>