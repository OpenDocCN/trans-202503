["```\n{-# OPTIONS_GHC -Wall #-}\n{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}\n```", "```\nmodule Mechanics1D where\n```", "```\nimport Graphics.Gnuplot.Simple\n```", "```\nimport Newton2 ( fAir )\n```", "```\nimport SimpleVec ( R )\n```", "```\ntype Time     = R\ntype TimeStep = R\ntype Mass     = R\ntype Position = R\ntype Velocity = R\ntype Force    = R\n```", "```\ntype State1D = (Time,Position,Velocity)\n```", "```\nnewtonSecond1D :: Mass\n               -> [State1D -> Force]  -- force funcs\n               -> State1D             -- current state\n               -> (R,R,R)             -- deriv of state\nnewtonSecond1D m fs (t,x0,v0)\n    = let fNet = sum [f (t,x0,v0) | f <- fs]\n          acc = fNet / m\n      in (1,v0,acc)\n```", "```\neuler1D :: R                     -- time step dt\n        -> (State1D -> (R,R,R))  -- differential equation\n        -> State1D -> State1D    -- state-update function\neuler1D dt deriv (t0,x0,v0)\n    = let (_, _, dvdt) = deriv (t0,x0,v0)\n          t1 = t0 + dt\n          x1 = x0 + v0 * dt\n          v1 = v0 + dvdt * dt\n      in (t1,x1,v1)\n```", "```\nupdateTXV :: R                   -- time interval dt\n          -> Mass\n          -> [State1D -> Force]  -- list of force funcs\n          -> State1D -> State1D  -- state-update function\nupdateTXV dt m fs = euler1D dt (newtonSecond1D m fs)\n```", "```\nstatesTXV :: R                   -- time step\n          -> Mass\n          -> State1D             -- initial state\n          -> [State1D -> Force]  -- list of force funcs\n          -> [State1D]           -- infinite list of states\nstatesTXV dt m txv0 fs = iterate (updateTXV dt m fs) txv0\n```", "```\n-- assume that dt is the same between adjacent pairs\nvelocity1D :: [State1D]         -- infinite list\n           -> Time -> Velocity  -- velocity function\nvelocity1D sts t\n    = let (t0,_,_) = sts !! 0\n          (t1,_,_) = sts !! 1\n          dt = t1 - t0\n          numSteps = abs $ round (t / dt)\n          (_,_,v0) = sts !! numSteps\n      in v0\n```", "```\nvelocityFtxv :: R                   -- time step\n             -> Mass\n             -> State1D             -- initial state\n             -> [State1D -> Force]  -- list of force funcs\n             -> Time -> Velocity    -- velocity function\nvelocityFtxv dt m txv0 fs = velocity1D (statesTXV dt m txv0 fs)\n```", "```\n-- assume that dt is the same between adjacent pairs\nposition1D :: [State1D]           -- infinite list\n           -> Time -> Position    -- position function\nposition1D sts t\n    = let (t0,_,_) = sts !! 0\n          (t1,_,_) = sts !! 1\n          dt = t1 - t0\n          numSteps = abs $ round (t / dt)\n          (_,x0,_) = sts !! numSteps\n      in x0\n```", "```\npositionFtxv :: R                   -- time step\n             -> Mass\n             -> State1D             -- initial state\n             -> [State1D -> Force]  -- list of force funcs\n             -> Time -> Position    -- position function\npositionFtxv dt m txv0 fs = position1D (statesTXV dt m txv0 fs)\n```", "```\nspringForce :: R -> State1D -> Force\nspringForce k (_,x0,_) = -k * x0\n```", "```\ndampedHOForces :: [State1D -> Force]\ndampedHOForces = [springForce 0.8\n                 ,\\(_,_,v0) -> fAir 2 1.225 (pi * 0.02**2) v0\n                 ,\\_ -> -0.0027 * 9.80665\n                 ]\n```", "```\ndampedHOStates :: [State1D]\ndampedHOStates = statesTXV 0.001 0.0027 (0.0,0.1,0.0) dampedHOForces\n```", "```\nPrelude> :l Mechanics1D\n[1 of 2] Compiling Newton2         ( Newton2.hs, interpreted )\n[2 of 2] Compiling Mechanics1D     ( Mechanics1D.hs, interpreted )\nOk, two modules loaded.\n*Mechanics1D> dampedHOStates !! 0\n(0.0,0.1,0.0)\n*Mechanics1D> dampedHOStates !! 5\n(5.0e-3,9.960571335911717e-2,-0.1970379672671094)\n*Mechanics1D> take 2 dampedHOStates\n[(0.0,0.1,0.0),(1.0e-3,0.1,-3.943627962962963e-2)]\n```", "```\ndampedHOGraph :: IO ()\ndampedHOGraph\n    = plotPath [Title \"Ping Pong Ball on a Slinky\"\n               ,XLabel \"Time (s)\"\n               ,YLabel \"Position (m)\"\n               ,PNG \"dho.png\"\n               ,Key Nothing\n               ] [(t,x) | (t,x,_) <- take 3000 dampedHOStates]\n```", "```\npingpongPosition :: Time -> Velocity\npingpongPosition = positionFtxv 0.001 0.0027 (0,0.1,0) dampedHOForces\n```", "```\ndampedHOGraph2 :: IO ()\ndampedHOGraph2\n    = plotFunc [Title \"Ping Pong Ball on a Slinky\"\n               ,XLabel \"Time (s)\"\n               ,YLabel \"Position (m)\"\n               ,Key Nothing\n               ] [0,0.01..3] pingpongPosition\n```", "```\npingpongVelocity :: Time -> Velocity\npingpongVelocity = velocityFtxv 0.001 0.0027 (0,0.1,0) dampedHOForces\n```", "```\ndampedHOGraph3 :: IO ()\ndampedHOGraph3\n    = plotFunc [Title \"Ping Pong Ball on a Slinky\"\n               ,XLabel \"Time (s)\"\n               ,YLabel \"Velocity (m/s)\"\n               ,PNG \"dho2.png\"\n               ,Key Nothing\n               ] [0,0.01..3] pingpongVelocity\n```", "```\neulerCromer1D :: R                     -- time step dt\n              -> (State1D -> (R,R,R))  -- differential equation\n              -> State1D -> State1D    -- state-update function\neulerCromer1D dt deriv (t0,x0,v0)\n    = let (_, _, dvdt) = deriv (t0,x0,v0)\n          t1 = t0 + dt\n          x1 = x0 + v1 * dt\n          v1 = v0 + dvdt * dt\n      in (t1,x1,v1)\n```", "```\nupdateTXVEC :: R                   -- time interval dt\n            -> Mass\n            -> [State1D -> Force]  -- list of force funcs\n            -> State1D -> State1D  -- state-update function\nupdateTXVEC dt m fs = eulerCromer1D dt (newtonSecond1D m fs)\n```", "```\ntype UpdateFunction s = s -> s\n```", "```\ntype DifferentialEquation s ds = s -> ds\n```", "```\ntype NumericalMethod s ds = DifferentialEquation s ds -> UpdateFunction s\n```", "```\nsolver :: NumericalMethod s ds -> DifferentialEquation s ds -> s -> [s]\nsolver method = iterate . method\n```", "```\nclass RealVectorSpace ds where\n      (+++) :: ds -> ds -> ds\n      scale :: R -> ds -> ds\n```", "```\ninstance RealVectorSpace (R,R,R) where\n    (dtdt0, dxdt0, dvdt0) +++ (dtdt1, dxdt1, dvdt1)\n        = (dtdt0 + dtdt1, dxdt0 + dxdt1, dvdt0 + dvdt1)\n    scale w (dtdt0, dxdt0, dvdt0) = (w * dtdt0, w * dxdt0, w * dvdt0)\n```", "```\nclass RealVectorSpace ds => Diff s ds where\n    shift :: R -> ds -> s -> s\n```", "```\ninstance Diff State1D (R,R,R) where\n    shift dt (dtdt,dxdt,dvdt) (t,x,v)\n        = (t + dtdt * dt, x + dxdt * dt, v + dvdt * dt)\n```", "```\neuler :: Diff s ds => R -> (s -> ds) -> s -> s\neuler dt deriv st0 = shift dt (deriv st0) st0\n```", "```\nrungeKutta4 :: Diff s ds => R -> (s -> ds) -> s -> s\nrungeKutta4 dt deriv st0\n    = let m0 = deriv                 st0\n          m1 = deriv (shift (dt/2) m0 st0)\n          m2 = deriv (shift (dt/2) m1 st0)\n          m3 = deriv (shift  dt    m2 st0)\n      in shift (dt/6) (m0 +++ m1 +++ m1 +++ m2 +++ m2 +++ m3) st0\n```", "```\nexponential :: DifferentialEquation (R,R,R) (R,R,R)\nexponential (_,x0,v0) = (1,v0,x0)\n```", "```\n*Mechanics1D> solver (euler 0.01) exponential (0,1,1) !! 800\n(7.999999999999874,2864.8311229272326,2864.8311229272326)\n*Mechanics1D> solver (eulerCromer1D 0.1) exponential (0,1,1) !! 80\n(7.999999999999988,3043.379244966009,2895.0121485099035)\n*Mechanics1D> solver (rungeKutta4 1) exponential (0,1,1) !! 8\n(8.0,2894.789038540849,2894.789038540849)\n```", "```\nupdate2 :: (R,R,R)  -- starting state\n        -> (R,R,R)  -- ending state\nupdate2 = undefined\n```", "```\nearthGravity :: Mass -> State1D -> Force\nearthGravity m _ = let g = 9.80665\n                   in -m * g\n```", "```\ntype MState = (Time,Mass,Position,Velocity)\n```", "```\nearthGravity2 :: MState -> Force\nearthGravity2 (_,m,_,_) = let g = 9.80665\n                          in -m * g\n```", "```\npositionFtxv2 :: R                  -- time step\n              -> MState             -- initial state\n              -> [MState -> Force]  -- list of force funcs\n              -> Time -> Position   -- position function\npositionFtxv2 = undefined\n\nstatesTXV2 :: R                 -- time step\n          -> MState             -- initial state\n          -> [MState -> Force]  -- list of force funcs\n          -> [MState]           -- infinite list of states\nstatesTXV2 = undefined\n\nupdateTXV2 :: R                  -- dt for stepping\n           -> [MState -> Force]  -- list of force funcs\n           -> MState             -- current state\n           -> MState             -- new state\nupdateTXV2 = undefined\n```", "```\ninstance RealVectorSpace (R,R) where\n    (dtdt0, dvdt0) +++ (dtdt1, dvdt1) = (dtdt0 + dtdt1, dvdt0 + dvdt1)\n    scale w (dtdt0, dvdt0) = (w * dtdt0, w * dvdt0)\n\ninstance Diff (Time,Velocity) (R,R) where\n    shift dt (dtdt,dvdt) (t,v)\n        = (t + dtdt * dt, v + dvdt * dt)\n```", "```\nupdateTV' :: R                           -- dt for stepping\n          -> Mass\n          -> [(Time,Velocity) -> Force]  -- list of force funcs\n          -> (Time,Velocity)             -- current state\n          -> (Time,Velocity)             -- new state\nupdateTV' = undefined\n```", "```\nforces :: R -> [State1D -> R]\nforces mu = [\\(_t,x,_v) -> undefined x\n            ,\\(_t,x, v) -> undefined mu x v]\n\nvdp :: R -> [(R,R)]\nvdp mu = map (\\(_,x,v) -> (x,v)) $ take 10000 $\n         solver (rungeKutta4 0.01) (newtonSecond1D 1 $ forces mu) (0,2,0)\n\nvdpPhasePlanePlot :: IO ()\nvdpPhasePlanePlot = plotPaths [Title \"Van der Pol oscillator\"\n                             ,XLabel \"x\"\n                             ,YLabel \"v\"\n                             ,PNG \"VanderPol.png\"\n                             ,Key Nothing] (undefined :: [[(R,R)]])\n```"]