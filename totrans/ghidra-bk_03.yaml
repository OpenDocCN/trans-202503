- en: '## **2'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **2'
- en: REVERSING AND DISASSEMBLY TOOLS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程与反汇编工具**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: With some disassembly background under our belts, and before we begin our dive
    into the specifics of Ghidra, it will be useful to understand some of the other
    tools that are used for reverse engineering binaries. Many of these tools predate
    Ghidra and continue to be useful for quick glimpses into files as well as for
    double-checking the work that Ghidra does. As we will see, Ghidra rolls many of
    the capabilities of these tools into its user interface to provide a single, integrated
    environment for reverse engineering.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握了一些反汇编的基本背景后，在深入了解 Ghidra 的具体细节之前，了解一些其他用于逆向工程二进制文件的工具将非常有用。这些工具中的许多在 Ghidra
    之前就已经存在，并且仍然对快速查看文件以及核对 Ghidra 工作结果非常有用。正如我们将看到的，Ghidra 将这些工具的许多功能集成到其用户界面中，提供了一个单一的、集成的逆向工程环境。
- en: '**Classification Tools**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分类工具**'
- en: When first confronted with an unknown file, it is often useful to answer simple
    questions such as, “What is this thing?” The first rule of thumb when attempting
    to answer that question is to *never* rely on a file extension to determine what
    a file actually is. That is also the second, third, and fourth rules of thumb.
    Once you have become an adherent of the *file extensions are meaningless* line
    of thinking, you may wish to familiarize yourself with one or more of the following
    utilities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次遇到未知文件时，回答一些简单问题通常是很有帮助的，比如“这是什么东西？”解决这个问题的首要原则是 *绝不* 依赖文件扩展名来确定文件的真实类型。这也是第二、第三和第四个原则。一旦你开始认同
    *文件扩展名毫无意义* 的观点，你可能会希望熟悉以下一种或多种工具。
- en: '***file***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***file***'
- en: The `file` command is a standard utility, included with most *nix-style operating
    systems as well as the Windows Subsystem for Linux (WSL).^([1](footnotes.xhtml#ch02fn1))
    This command is also available to Windows users by installing either Cygwin or
    MinGW.^([2](footnotes.xhtml#ch02fn2)) The `file` command attempts to identify
    a file’s type by examining specific fields within the file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 命令是一个标准工具，包含在大多数 *nix 风格的操作系统中，以及 Windows Subsystem for Linux (WSL)
    中。^([1](footnotes.xhtml#ch02fn1)) 通过安装 Cygwin 或 MinGW，Windows 用户也可以使用该命令。^([2](footnotes.xhtml#ch02fn2))
    `file` 命令通过检查文件中的特定字段来识别文件类型。'
- en: In some cases, `file` recognizes common strings such as `#!/bin/sh` (a shell
    script) and `<html>` (an HTML document).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`file` 能够识别常见的字符串，如 `#!/bin/sh`（一个 shell 脚本）和 `<html>`（一个 HTML 文档）。
- en: Files containing non-ASCII content present somewhat more of a challenge. In
    such cases, `file` attempts to determine whether the content appears to be structured
    according to a known file format. In many cases, it searches for specific tag
    values (often referred to as *magic numbers*)^([3](footnotes.xhtml#ch02fn3)) known
    to be unique to specific file types. The following hex listings show several examples
    of magic numbers used to identify some common file types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 含有非 ASCII 内容的文件会带来一些挑战。在这种情况下，`file` 会尝试确定文件内容是否按照已知的文件格式进行结构化。在许多情况下，它会寻找特定的标签值（通常称为
    *magic numbers*）^([3](footnotes.xhtml#ch02fn3))，这些标签值被认为是特定文件类型的独特标识。以下的十六进制列表示例展示了几种用于识别常见文件类型的
    magic numbers。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `file` command has the capability to identify many file formats, including
    several types of ASCII text files and various executable and data file formats.
    The magic number checks performed by `file` are governed by rules contained in
    a *magic file*. The default magic file varies by operating system, but common
    locations include */usr/share/file/magic*, */usr/share/misc/magic*, and */etc/magic*.
    Please refer to the documentation for `file` for more information concerning magic
    files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 命令有能力识别多种文件格式，包括几种类型的 ASCII 文本文件和各种可执行文件及数据文件格式。`file` 执行的 magic number
    检查是根据 *magic 文件* 中的规则进行的。默认的 magic 文件因操作系统而异，但常见的位置包括 */usr/share/file/magic*、*/usr/share/misc/magic*
    和 */etc/magic*。有关 magic 文件的更多信息，请参考 `file` 的文档。'
- en: In some cases, `file` can distinguish variations within a given file type. The
    following listing demonstrates `file`’s ability to identify not only several variations
    of ELF binaries but also information pertaining to how the binary was linked (statically
    or dynamically) and whether the binary was stripped.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`file` 可以区分给定文件类型中的不同变种。以下列表演示了 `file` 不仅能够识别 ELF 二进制文件的多个变种，还能识别与二进制文件如何链接（静态或动态）以及是否经过剥离相关的信息。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**THE WSL ENVIRONMENT**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**WSL 环境**'
- en: The Windows Subsystem for Linux provides a GNU/Linux command line environment
    directly within Windows without the need to create a virtual machine. During WSL
    installation, users choose a Linux distribution and can then run it on the WSL.
    This provides access to common command line free software (`grep`, `awk`), compilers
    (`gcc`, `g++`), interpreters (Perl, Python, Ruby), networking utilities (`nc`,
    `ssh`), and many others. Once WSL has been installed, many programs written for
    use with Linux can be compiled and executed on Windows systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Subsystem for Linux 提供了一个直接在 Windows 中运行的 GNU/Linux 命令行环境，无需创建虚拟机。在
    WSL 安装过程中，用户可以选择一个 Linux 发行版，然后在 WSL 上运行它。这提供了对常见命令行自由软件的访问（`grep`、`awk`）、编译器（`gcc`、`g++`）、解释器（Perl、Python、Ruby）、网络工具（`nc`、`ssh`）以及其他许多工具。一旦安装了
    WSL，许多为 Linux 编写的程序就可以在 Windows 系统上进行编译和执行。
- en: 'The `file` utility and similar utilities are not foolproof. It is quite possible
    for a file to be misidentified simply because it happens to bear the identifying
    marks of a particular file format. You can see this for yourself by using a hex
    editor to modify the first 4 bytes of any file to the Java magic number sequence:
    `CA FE BA BE`. The `file` utility will incorrectly identify the newly modified
    file as *compiled Java class data*. Similarly, a text file containing only the
    two characters `MZ` will be identified as an *MS-DOS executable*. A good approach
    to take in any reverse engineering effort is to never fully trust the output of
    any tool until you have correlated that output with several tools and manual analysis.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 工具和类似的工具并非万无一失。很有可能由于文件恰巧带有特定文件格式的标识符，导致其被错误地识别。你可以通过使用十六进制编辑器，将任何文件的前
    4 个字节修改为 Java 魔术数字序列：`CA FE BA BE`，来亲自验证这一点。`file` 工具会错误地将这个新修改的文件识别为 *编译过的 Java
    类数据*。类似地，一个仅包含字符 `MZ` 的文本文件会被识别为 *MS-DOS 可执行文件*。在进行任何逆向工程时，一个好的做法是，在将任何工具的输出作为最终结果之前，首先通过多种工具和手动分析来验证这些输出。'
- en: '**STRIPPING BINARY EXECUTABLE FILES**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**去除二进制可执行文件中的符号**'
- en: '*Stripping* a binary is the process of removing symbols from the binary file.
    Binary object files contain symbols as a result of the compilation process. Some
    of these symbols are utilized during the linking process to resolve references
    between files when creating the final executable file or library. In other cases,
    symbols may be present to provide additional information for use with debuggers.
    Following the linking process, many of the symbols are no longer required. Options
    passed to the linker can cause the linker to remove the unnecessary symbols at
    build time. Alternatively, a utility named `strip` may be used to remove symbols
    from existing binary files. While a stripped binary will be smaller than its unstripped
    counterpart, the behavior of the stripped binary will remain unchanged.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*去除*二进制文件符号是从二进制文件中去除符号的过程。二进制目标文件由于编译过程而包含符号。这些符号中的一些在链接过程中被使用，以在创建最终可执行文件或库时解析文件之间的引用。在其他情况下，符号可能存在，以便为调试器提供附加信息。链接过程完成后，许多符号已不再需要。传递给链接器的选项可以使链接器在构建时去除不必要的符号。或者，可以使用名为
    `strip` 的工具从现有二进制文件中去除符号。虽然去除符号的二进制文件比未去除符号的二进制文件小，但去除符号后的二进制文件行为保持不变。'
- en: '***PE Tools***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***PE 工具***'
- en: PE Tools is a collection of tools useful for analyzing both running processes
    and executable files on Windows systems.^([4](footnotes.xhtml#ch02fn4)) [Figure
    2-1](ch02.xhtml#fig2_1) shows the primary interface offered by PE Tools, which
    displays a list of active processes and provides access to all of the PE Tools
    utilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PE 工具是一组有助于分析 Windows 系统上正在运行的进程和可执行文件的工具集合。^[4](footnotes.xhtml#ch02fn4) [图
    2-1](ch02.xhtml#fig2_1) 展示了 PE 工具提供的主要界面，界面显示了活动进程的列表，并提供访问所有 PE 工具实用程序的功能。
- en: From the process list, users can dump a process’s memory image to a file or
    utilize the PE Sniffer utility to determine what compiler was used to build the
    executable or whether the executable was processed by any known obfuscation utilities.
    The Tools menu offers similar options for analysis of disk files. Users can view
    a file’s PE header fields by using the embedded PE Editor utility, which also
    allows for easy modification of any header values. Modification of PE headers
    is often required when attempting to reconstruct a valid PE from an obfuscated
    version of that file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从进程列表中，用户可以将进程的内存镜像转储到文件中，或使用 PE Sniffer 工具确定构建可执行文件时使用的编译器，或确定该可执行文件是否经过任何已知的混淆工具处理。工具菜单提供类似的选项，用于分析磁盘文件。用户可以使用嵌入式
    PE 编辑器工具查看文件的 PE 头字段，该工具还允许轻松修改任何头部值。在尝试从混淆版本的文件重构有效的 PE 时，通常需要修改 PE 头部。
- en: '![image](Images/fig2-1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig2-1.jpg)'
- en: '*Figure 2-1: The PE Tools utility*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：PE Tools 工具*'
- en: '**BINARY FILE OBFUSCATION**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制文件混淆**'
- en: '*Obfuscation* is any attempt to obscure the true meaning of something. When
    applied to executable files, obfuscation is any attempt to hide the true behavior
    of a program. Programmers may employ obfuscation for a number of reasons. Commonly
    cited examples include protecting proprietary algorithms and obscuring malicious
    intent. Nearly all forms of malware utilize obfuscation in an effort to hinder
    analysis. Tools are widely available to assist program authors in generating obfuscated
    programs. Obfuscation tools and techniques and their associated impact on the
    reverse engineering process are discussed further in [Chapter 21](ch21.xhtml#ch21).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*混淆*是任何试图掩盖某物真实含义的行为。当应用于可执行文件时，混淆就是试图隐藏程序的真实行为。程序员可能出于多种原因使用混淆技术。常见的例子包括保护专有算法和掩盖恶意意图。几乎所有形式的恶意软件都会利用混淆技术来阻碍分析。有很多工具可以帮助程序作者生成混淆的程序。混淆工具和技术及其对逆向工程过程的影响将在[第
    21 章](ch21.xhtml#ch21)中进一步讨论。'
- en: '***PEiD***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***PEiD***'
- en: PEiD is another Windows tool whose primary purposes are to identify the compiler
    used to build a particular Windows PE binary and to identify any tools used to
    obfuscate a Windows PE binary.^([5](footnotes.xhtml#ch02fn5)) [Figure 2-2](ch02.xhtml#fig2_2)
    shows the use of PEiD to identify the tool (ASPack in this case) used to obfuscate
    a variant of the Gaobot worm.^([6](footnotes.xhtml#ch02fn6))
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PEiD 是另一个 Windows 工具，其主要功能是识别用于构建特定 Windows PE 二进制文件的编译器，并识别任何用于混淆 Windows PE
    二进制文件的工具。^([5](footnotes.xhtml#ch02fn5)) [图 2-2](ch02.xhtml#fig2_2) 显示了使用 PEiD
    来识别用于混淆 Gaobot 蠕虫变种的工具（此案例中为 ASPack）。^([6](footnotes.xhtml#ch02fn6))
- en: '![image](Images/fig2-2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig2-2.jpg)'
- en: '*Figure 2-2: The PEiD utility*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：PEiD 工具*'
- en: Many additional capabilities of PEiD overlap those of PE Tools, including the
    ability to summarize PE file headers, collect information on running processes,
    and perform basic disassembly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PEiD 的许多附加功能与 PE Tools 重叠，包括概述 PE 文件头信息、收集正在运行的进程信息以及执行基本的反汇编操作。
- en: '**Summary Tools**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**汇总工具**'
- en: Since our goal is to reverse engineer binary program files, we are going to
    need more sophisticated tools to extract detailed information following initial
    classification of a file. The tools discussed in this section, by necessity, are
    far more aware of the formats of the files that they process. In most cases, these
    tools understand a very specific file format, and the tools are utilized to parse
    input files to extract very specific information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是逆向工程二进制程序文件，我们需要更复杂的工具来提取文件初步分类后的详细信息。本节讨论的工具，必然会更加了解它们所处理的文件格式。在大多数情况下，这些工具理解非常特定的文件格式，且它们被用来解析输入文件，以提取非常具体的信息。
- en: '***nm***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***nm***'
- en: When source files are compiled to object files, compilers must embed information
    regarding the location of any global (external) symbols so that the linker will
    be able to resolve references to those symbols when it combines object files to
    create an executable. Unless instructed to strip symbols from the final executable,
    the linker generally carries symbols from the object files over into the resulting
    executable. According to the man page, the `nm` utility “lists symbols from object
    files.”
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当源文件被编译为目标文件时，编译器必须嵌入有关任何全局（外部）符号位置的信息，以便链接器能够在合并目标文件以创建可执行文件时解析对这些符号的引用。除非指示从最终可执行文件中剥离符号，否则链接器通常会将目标文件中的符号携带到生成的可执行文件中。根据
    man 页面，`nm` 工具“列出目标文件中的符号”。
- en: 'When `nm` is used to examine an intermediate object file (a *.o* file rather
    than an executable), the default output yields the names of any functions and
    global variables declared in the file. Sample output of the `nm` utility is shown
    next:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当`nm`用于检查中间目标文件（*.o*文件而不是可执行文件）时，默认输出将显示文件中声明的任何函数和全局变量的名称。接下来是`nm`工具的示例输出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here we see that `nm` lists each symbol, along with information about the symbol.
    The letter codes are used to indicate the type of symbol being listed. In this
    example, we see the following letter codes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`nm`列出了每个符号，并提供了关于符号的信息。字母代码用于表示列出的符号的类型。在这个例子中，我们看到了以下字母代码：
- en: U An undefined symbol (usually an external symbol reference).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: U 一个未定义的符号（通常是外部符号引用）。
- en: T A symbol defined in the text section (usually a function name).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: T 在文本段中定义的符号（通常是一个函数名）。
- en: t A local symbol defined in the text section. In a C program, this usually equates
    to a static function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: t 在文本段中定义的局部符号。在C程序中，这通常等同于静态函数。
- en: D An initialized data value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: D 一个初始化的数据值。
- en: C An uninitialized data value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C 一个未初始化的数据值。
- en: '**NOTE**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Uppercase letter codes are used for global symbols, whereas lowercase letter
    codes are used for local symbols. More information, including a full explanation
    of the letter codes, can be found in the man page for* nm.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*大写字母代码用于全局符号，而小写字母代码用于局部符号。更多信息，包括字母代码的完整解释，可以在* nm的手册页中找到。*'
- en: 'Somewhat more information is displayed when `nm` is used to display symbols
    from an executable file. During linking, symbols are resolved to virtual addresses
    (when possible), which results in more information being available when `nm` is
    run. Truncated sample output from `nm` used on an executable is shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nm`显示可执行文件中的符号时，会显示更多信息。在链接过程中，符号会被解析为虚拟地址（如果可能的话），这会导致在运行`nm`时显示更多的信息。以下是`nm`在可执行文件上的截断示例输出：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, some of the symbols (`main`, for example) have been assigned
    virtual addresses, new ones (`__libc_csu_init`) have been introduced as a result
    of the linking process, some (`my_unitialized_global`) have had their symbol type
    changed, and others remain undefined as they continue to reference external symbols.
    In this case, the binary we are examining is dynamically linked, and the undefined
    symbols are defined in the shared C library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，一些符号（例如`main`）已经被分配了虚拟地址，新的符号（如`__libc_csu_init`）由于链接过程而引入，一些符号（如`my_unitialized_global`）已更改了符号类型，另一些符号仍未定义，因为它们继续引用外部符号。在这种情况下，我们正在检查的二进制文件是动态链接的，未定义的符号在共享的C库中定义。
- en: '***ldd***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ldd***'
- en: 'When an executable is created, the location of any library functions referenced
    by that executable must be resolved. The linker has two methods for resolving
    calls to library functions: *static linking* and *dynamic linking*. Command line
    arguments provided to the linker determine which of the two methods is used. An
    executable may be statically linked, dynamically linked, or both.^([7](footnotes.xhtml#ch02fn7))'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个可执行文件时，必须解决该可执行文件引用的任何库函数的位置。链接器有两种方法来解决对库函数的调用：*静态链接*和*动态链接*。提供给链接器的命令行参数决定使用哪种方法。一个可执行文件可以是静态链接的、动态链接的，或者是两者都有的。^([7](footnotes.xhtml#ch02fn7))
- en: When static linking is requested, the linker combines an application’s object
    files with a copy of the required library to create an executable file. At runtime,
    there is no need to locate the library code because it is already contained within
    the executable. Advantages of static linking are that (1) it results in slightly
    faster function calls and (2) distribution of binaries is easier because no assumptions
    need be made regarding the availability of library code on users’ systems. Disadvantages
    of static linking include (1) larger resulting executables and (2) greater difficulty
    upgrading programs when library components change. Programs are more difficult
    to update because they must be relinked every time a library is changed. From
    a reverse engineering perspective, static linking complicates matters somewhat.
    If we are faced with the task of analyzing a statically linked binary, there is
    no easy way to answer the questions “Which libraries are linked into this binary?”
    and “Which of these functions is a library function?” [Chapter 13](ch13.xhtml#ch13)
    discusses the challenges encountered while reverse engineering statically linked
    code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求静态链接时，链接器将应用程序的目标文件与所需库的副本结合起来，以创建可执行文件。在运行时，无需查找库代码，因为它已经包含在可执行文件中。静态链接的优点包括：(1)
    它能使函数调用稍微更快，(2) 由于不需要假设用户系统上是否有库代码，二进制文件的分发变得更容易。静态链接的缺点包括：(1) 生成的可执行文件较大，(2)
    当库组件发生变化时，程序的升级更加困难。程序更新变得更加困难，因为每次库发生更改时，程序必须重新链接。从逆向工程的角度来看，静态链接在某种程度上使问题变得更加复杂。如果我们面临分析一个静态链接的二进制文件的任务，就没有简单的方法来回答“这个二进制文件链接了哪些库？”以及“这些函数中哪些是库函数？”[第13章](ch13.xhtml#ch13)讨论了在逆向工程静态链接代码时遇到的挑战。
- en: Dynamic linking differs from static linking in that the linker has no need to
    make a copy of any required libraries. Instead, the linker simply inserts references
    to any required libraries (often *.so* or *.dll* files) into the final executable,
    usually resulting in much smaller executable files. Upgrading library code is
    much easier when dynamic linking is utilized. Since a single copy of a library
    is maintained and that copy is referenced by many binaries, replacing the single
    outdated library with a new version results in any new process based on a binary
    that dynamically links to that library using the updated version. One of the disadvantages
    of using dynamic linking is that it requires a more complicated loading process.
    All of the necessary libraries must be located and loaded into memory, as opposed
    to loading one statically linked file that happens to contain all of the library
    code. Another disadvantage of dynamic linking is that vendors must distribute
    not only their own executable file but also all library files upon which that
    executable depends. Attempting to execute a program on a system that does not
    contain all the required library files will result in an error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接与静态链接的不同之处在于，链接器不需要复制任何所需的库。相反，链接器仅在最终可执行文件中插入对所需库（通常是*.so*或*.dll*文件）的引用，这通常会导致生成的可执行文件更小。当使用动态链接时，库代码的升级变得更加容易。由于只维护一个库的副本，并且该副本被多个二进制文件引用，替换掉过时的库副本并用新版本替代，将导致任何基于动态链接到该库的二进制文件的进程使用更新的版本。使用动态链接的一个缺点是，它需要更复杂的加载过程。所有必要的库必须被定位并加载到内存中，而不像静态链接文件那样，加载的文件已经包含了所有的库代码。动态链接的另一个缺点是，供应商不仅必须分发他们自己的可执行文件，还必须分发所有该可执行文件所依赖的库文件。如果在没有所有必需库文件的系统上尝试执行程序，将会导致错误。
- en: 'The following output demonstrates the creation of dynamically and statically
    linked versions of a program, the size of the resulting binaries, and the manner
    in which `file` identifies those binaries:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出演示了程序的动态和静态链接版本的创建、生成的二进制文件的大小，以及`file`如何识别这些二进制文件：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order for dynamic linking to function properly, dynamically linked binaries
    must indicate which libraries they depend on, along with the specific resources
    required from each of those libraries. As a result, unlike statically linked binaries,
    it is quite simple to determine the libraries on which a dynamically linked binary
    depends. The `ldd` (*list dynamic dependencies*) utility is a tool used to list
    the dynamic libraries required by any executable. In the following example, `ldd`
    is used to determine the libraries on which the Apache web server depends:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使动态链接正常工作，动态链接的二进制文件必须指明它们所依赖的库，以及每个库所需的特定资源。因此，与静态链接的二进制文件不同，确定动态链接的二进制文件所依赖的库非常简单。`ldd`（*列出动态依赖项*）工具用于列出任何可执行文件所需的动态库。在以下示例中，`ldd`用于确定Apache
    web服务器所依赖的库：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ldd` utility is available on Linux and BSD systems. On macOS systems,
    similar functionality is available using the `otool` utility with the `-L` option:
    `otool -L` filename. On Windows systems, the `dumpbin` utility, part of the Visual
    Studio tool suite, can be used to list dependent libraries: `dumpbin /dependents`
    filename.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldd`工具可在Linux和BSD系统上使用。在macOS系统上，可以使用`otool`工具配合`-L`选项来实现类似功能：`otool -L` 文件名。在Windows系统上，可以使用`dumpbin`工具，这是Visual
    Studio工具套件的一部分，用于列出依赖库：`dumpbin /dependents` 文件名。'
- en: '**BEWARE YOUR TOOLS!**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**小心你的工具！**'
- en: While `ldd` may appear to be a simple tool, the `ldd` man page states that “you
    should never employ `ldd` on an untrusted executable, since this may result in
    the execution of arbitrary code.” While this is unlikely in most cases, it provides
    a reminder that running even apparently simple software reverse engineering (SRE)
    tools may have unintended consequences when examining untrusted input files. While
    it is hopefully obvious that executing untrusted binaries is unlikely to be safe,
    it is wise to take precautions even when statically analyzing untrusted binaries,
    and to assume that the computer on which you perform SRE tasks, along with any
    data on it or other hosts connected to it, may be compromised as a result of SRE
    activities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`ldd`看起来像是一个简单的工具，但`ldd`的手册页面指出，“你永远不应该在不可信的可执行文件上使用`ldd`，因为这可能会导致执行任意代码。”虽然在大多数情况下这种情况不太可能发生，但它提醒我们，当检查不可信的输入文件时，甚至像`ldd`这样的简单软件逆向工程（SRE）工具也可能会产生意想不到的后果。虽然执行不可信的二进制文件显然不安全，但即使是在静态分析不可信二进制文件时，也应该采取预防措施，并假设进行SRE任务的计算机以及与其连接的任何数据或其他主机，可能会因SRE活动而被入侵。
- en: '***objdump***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***objdump***'
- en: 'Whereas `ldd` is fairly specialized, `objdump` is extremely versatile. The
    purpose of `objdump` is to “display information from object files.”^([8](footnotes.xhtml#ch02fn8))
    This is a fairly broad goal, and to accomplish it, `objdump` responds to more
    than 30 command line options tailored to extract various pieces of information
    from object files. The `objdump` tool can be used to display the following data
    (and much more) related to object files:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ldd`是一个相对专业的工具，但`objdump`则非常多功能。`objdump`的目的是“显示目标文件中的信息”。^([8](footnotes.xhtml#ch02fn8))
    这是一个相当广泛的目标，为了实现这一目标，`objdump`支持超过30个命令行选项，用于从目标文件中提取各种信息。`objdump`工具可以用来显示与目标文件相关的以下数据（还有更多）：
- en: '**Section headers** Summary information for each of the sections in the program
    file.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**段头信息** 程序文件中各个部分的摘要信息。'
- en: '**Private headers** Program memory layout information and other information
    required by the runtime loader, including a list of required libraries, such as
    that produced by `ldd`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有头文件** 程序内存布局信息和运行时加载器所需的其他信息，包括所需库的列表，类似于`ldd`产生的输出。'
- en: '**Debugging information** Any debugging information embedded in the program
    file.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试信息** 程序文件中嵌入的任何调试信息。'
- en: '**Symbol information** Symbol table information, dumped in a manner similar
    to the `nm` utility.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号信息** 符号表信息，类似于`nm`工具的输出方式。'
- en: '**Disassembly listing** The `objdump` tool performs a linear sweep disassembly
    of sections of the file marked as code. When disassembling x86 code, `objdump`
    can generate either AT&T or Intel syntax, and the disassembly can be captured
    as a text file. Such a text file is called a disassembly *dead listing*, and while
    these files can certainly be used for reverse engineering, they are difficult
    to navigate effectively and even more difficult to modify in a consistent and
    error-free manner.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**反汇编清单** `objdump`工具对标记为代码的文件部分执行线性遍历反汇编。当反汇编x86代码时，`objdump`可以生成AT&T或Intel语法，并且可以将反汇编结果保存为文本文件。这类文本文件称为反汇编*死清单*，虽然这些文件可以用于逆向工程，但它们难以有效导航，并且更难以一致且无错误地修改。'
- en: The `objdump` tool is available as part of the GNU binutils tool suite and can
    be found on Linux, FreeBSD, and Windows (via WSL or Cygwin).^([9](footnotes.xhtml#ch02fn9))
    Note that `objdump` relies on the *Binary File Descriptor library (libbfd)*, a
    component of binutils, to access object files and thus is capable of parsing file
    formats supported by libbfd (ELF and PE among others). For ELF-specific parsing,
    a utility named `readelf` is also available. The `readelf` utility offers most
    of the same capabilities as `objdump`, and the primary difference between the
    two is that `readelf` does not rely upon libbfd.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`objdump`工具作为GNU binutils工具套件的一部分可用，可以在Linux、FreeBSD和Windows（通过WSL或Cygwin）上找到。^([9](footnotes.xhtml#ch02fn9))
    注意，`objdump`依赖于*二进制文件描述符库（libbfd）*，这是binutils的一个组件，用于访问目标文件，因此能够解析libbfd支持的文件格式（例如ELF和PE）。对于ELF特定的解析，还提供了一个名为`readelf`的工具。`readelf`工具提供了与`objdump`大致相同的功能，主要的区别是`readelf`不依赖于libbfd。'
- en: '***otool***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***otool***'
- en: 'The `otool` utility is most easily described as an `objdump`-like option for
    macOS, and it is useful for parsing information about macOS Mach-O binaries. The
    following listing demonstrates how `otool` displays the dynamic library dependencies
    for a Mach-O binary, thus performing a function similar to `ldd`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`otool`工具最简单的描述就是类似于`objdump`的macOS选项，它对于解析macOS Mach-O二进制文件的信息非常有用。以下清单展示了`otool`如何显示Mach-O二进制文件的动态库依赖性，从而执行类似`ldd`的功能：'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `otool` utility can be used to display information related to a file’s headers
    and symbol tables and to perform disassembly of the file’s code section. For more
    information regarding the capabilities of `otool`, please refer to the associated
    man page.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`otool`工具可以用于显示与文件头和符号表相关的信息，并对文件的代码段执行反汇编。有关`otool`功能的更多信息，请参考相关的man页面。'
- en: '***dumpbin***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***dumpbin***'
- en: 'The `dumpbin` command line utility is included with Microsoft’s Visual Studio
    suite of tools. Like `otool` and `objdump`, `dumpbin` is capable of displaying
    a wide range of information related to Windows PE files. The following listing
    shows how `dumpbin` displays the dynamic dependencies of the Windows notepad program
    in a manner similar to `ldd`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumpbin`命令行工具包含在微软的Visual Studio工具套件中。与`otool`和`objdump`类似，`dumpbin`能够显示与Windows
    PE文件相关的广泛信息。以下清单展示了`dumpbin`如何以类似`ldd`的方式显示Windows记事本程序的动态依赖：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Additional `dumpbin` options offer the ability to extract information from various
    sections of a PE binary, including symbols, imported function names, exported
    function names, and disassembled code. Additional information related to the use
    of `dumpbin` is available via the Microsoft website.^([10](footnotes.xhtml#ch02fn10))
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的`dumpbin`选项提供了从PE二进制文件的各种部分提取信息的能力，包括符号、导入的函数名、导出的函数名和反汇编代码。有关使用`dumpbin`的更多信息，可以通过微软网站获取。^([10](footnotes.xhtml#ch02fn10))
- en: '***c++filt***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***c++filt***'
- en: 'Languages that allow function overloading must have a mechanism for distinguishing
    among the many overloaded versions of a function since each version has the same
    name. The following C++ example shows the prototypes for several overloaded versions
    of a function named `demo`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 支持函数重载的语言必须有一种机制来区分多个重载版本的函数，因为每个版本的函数名称相同。以下C++示例展示了名为`demo`的函数几个重载版本的原型：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As a general rule, it is not possible to have two functions with the same name
    in an object file. To allow overloading, compilers derive unique names for overloaded
    functions by incorporating information describing the type sequence of the function
    arguments. The process of deriving unique names for functions with identical names
    is called *name mangling*.^([11](footnotes.xhtml#ch02fn11)) If we use `nm` to
    dump the symbols from the compiled version of the preceding C++ code, we might
    see something like the following (filtered to focus on versions of `demo`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在目标文件中不可能有两个同名的函数。为了支持函数重载，编译器通过结合描述函数参数类型顺序的信息来为重载函数生成唯一的名称。为具有相同名称的函数生成唯一名称的过程称为*名称混淆*。^([11](footnotes.xhtml#ch02fn11))
    如果我们使用`nm`从编译后的C++代码中转储符号，我们可能会看到类似以下内容（已过滤，专注于`demo`的版本）：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The C++ standard does not define a standard name mangling scheme, leaving compiler
    designers to develop their own. To decipher the mangled variants of `demo` shown
    here, we need a tool that understands our compiler’s (`g++` in this case) name
    mangling scheme. This is precisely the purpose of `c++filt`. This utility treats
    each input word as if it were a mangled name and then attempts to determine the
    compiler that was used to generate that name. If the name appears to be a valid
    mangled name, it outputs the demangled version of the name. When `c++filt` does
    not recognize a word as a mangled name, it simply outputs the word with no changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准并没有定义一个标准的名称混淆方案，因此编译器设计者需要自行开发。这是用来解密显示的`demo`混淆变体的工具所需的，我们需要一个理解我们编译器（在此案例中为`g++`）名称混淆方案的工具。`c++filt`正是为了这个目的设计的。这个工具将每个输入单词当作一个混淆后的名称，然后尝试确定用于生成该名称的编译器。如果该名称看起来是有效的混淆名称，它会输出去混淆后的名称。当`c++filt`无法将一个单词识别为混淆名称时，它会原样输出该单词。
- en: 'If we pass the results of `nm` from the preceding example through `c++filt`,
    it is possible to recover the demangled function names, as seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面示例中`nm`的结果传递给`c++filt`，我们就可以恢复去混淆后的函数名称，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is important to note that mangled names contain additional information about
    functions that `nm` does not normally provide. This information can be extremely
    helpful in reverse engineering situations, and in more complex cases, this extra
    information may include data regarding class names or function-calling conventions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，**混淆后的名称**包含了关于函数的附加信息，而`nm`通常不会提供这些信息。这些信息在逆向工程中非常有用，在更复杂的情况下，这些额外的信息可能包括关于类名或函数调用约定的数据。
- en: '**Deep Inspection Tools**'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**深度检查工具**'
- en: So far, we have discussed tools that perform a cursory analysis of files based
    on minimal knowledge of those files’ internal structure. We have also seen tools
    capable of extracting specific pieces of data from files based on very detailed
    knowledge of a file’s structure. In this section, we discuss tools designed to
    extract specific types of information independently of the type of file being
    analyzed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了基于对文件内部结构的最少了解进行简要分析的工具。我们还看到了能够根据文件结构的详细知识提取特定数据的工具。在这一节中，我们将讨论旨在独立于被分析文件类型提取特定类型信息的工具。
- en: '***strings***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串***'
- en: It is occasionally useful to ask more generic questions regarding file content—
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，提出一些关于文件内容的更一般性的问题是有用的——
- en: questions that don’t necessarily require any specific knowledge of a file’s
    structure. One such question is “Does this file contain any embedded strings?”
    Of course, we must first answer the question “What exactly constitutes a string?”
    Let’s loosely define a *string* as a consecutive sequence of printable characters.
    This definition is often augmented to specify a minimum length and a specific
    character set. Thus, we could specify a search for all sequences of at least four
    consecutive ASCII printable characters and print the results to the console. Searches
    for such strings are generally not limited in any way by the structure of a file.
    You can search for strings in an ELF binary just as easily as you can search for
    strings in a Microsoft Word document.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定需要了解文件结构的特定知识的问题。其中一个问题是：“这个文件包含任何嵌入的字符串吗？”当然，我们首先需要回答的问题是：“什么构成了字符串？”我们可以宽泛地定义*字符串*为一串连续的可打印字符。这个定义通常会被扩展，指定一个最小长度和特定的字符集。因此，我们可以指定搜索所有至少包含四个连续ASCII可打印字符的序列，并将结果打印到控制台。此类字符串的搜索通常不受文件结构的任何限制。你可以在ELF二进制文件中搜索字符串，就像你在Microsoft
    Word文档中搜索字符串一样轻松。
- en: 'The `strings` utility is designed specifically to extract string content from
    files, often without regard for the format of those files. Using `strings` with
    its default settings (7-bit ASCII sequences of at least four characters) might
    yield something like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings`工具专门用于从文件中提取字符串内容，通常不考虑文件的格式。使用`strings`的默认设置（7位ASCII序列，至少四个字符）可能会得到如下内容：'
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**WHY DID STRINGS CHANGE?**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么STRINGS发生了变化？**'
- en: Historically, when `strings` was used on executable files, it would, by default,
    search only for character sequences in the loadable, initialized data sections
    of the binary file. This required that `strings` parse the binary file to find
    those sections, using libraries such as libbfd. When it was used for parsing untrusted
    binaries, vulnerabilities in libraries could potentially result in arbitrary code
    execution.^([12](ch02.xhtml#ch02fn12)) As a result, the default behavior for `strings`
    was changed to examine the entire binary file without parsing for loadable initialized
    data sections (synonymous with the use of the `-a` flag.) The historical behavior
    can be invoked using the `-d` flag.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，当`strings`用于可执行文件时，默认只会搜索二进制文件中可加载的初始化数据区段的字符序列。这需要`strings`解析二进制文件，以查找这些区段，并使用像libbfd这样的库。当它用于解析不受信任的二进制文件时，库中的漏洞可能会导致任意代码执行。^([12](ch02.xhtml#ch02fn12))
    因此，`strings`的默认行为已更改为检查整个二进制文件，而不解析可加载的初始化数据区段（与使用`-a`标志的效果相同）。可以使用`-d`标志来调用历史行为。
- en: '[12](ch02.xhtml#ch02fn12a). See CVE-2014-8485 and *[https://lcamtuf.blogspot.com/2014/10/psa-dont-run-strings-on-untrusted-files.html](https://lcamtuf.blogspot.com/2014/10/psa-dont-run-strings-on-untrusted-files.html)*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[12](ch02.xhtml#ch02fn12a)。参见CVE-2014-8485和*[https://lcamtuf.blogspot.com/2014/10/psa-dont-run-strings-on-untrusted-files.html](https://lcamtuf.blogspot.com/2014/10/psa-dont-run-strings-on-untrusted-files.html)*。'
- en: Unfortunately, while we see some strings that look like they might be output
    by the program, other strings appear to be function names and library names. We
    should be careful not to jump to any conclusions regarding the behavior of the
    program. Analysts often fall into the trap of attempting to deduce the behavior
    of a program based on the output of `strings`. Remember, the presence of a string
    within a binary in no way indicates that the string is ever used in any manner
    by that binary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管我们看到一些看起来像是程序输出的字符串，但其他一些字符串似乎是函数名和库名。我们应当小心，不要根据`strings`的输出草率推断程序的行为。分析人员常常会陷入试图根据`strings`的输出推断程序行为的陷阱。记住，二进制文件中的字符串的存在并不意味着该字符串以任何方式被该二进制文件使用。
- en: 'Here are some final notes on the use of `strings`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于`strings`使用的一些最后说明：
- en: By default, `strings` gives no indication of where, within a file, a string
    is located. Use the `-t` command line argument to have `strings` print file offset
    information for each string found.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`strings`不会指示字符串在文件中的位置。使用`-t`命令行参数，可以让`strings`为每个找到的字符串打印文件偏移信息。
- en: Many files utilize alternate character sets. Utilize the `-e` command line argument
    to cause `strings` to search for wide characters such as 16-bit Unicode.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多文件使用替代字符集。使用`-e`命令行参数，可以使`strings`搜索宽字符，如16位Unicode字符。
- en: '***Disassemblers***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反汇编器***'
- en: As mentioned earlier, tools are available to generate dead listing–style disassemblies
    of binary object files. PE, ELF, and Mach-O binaries can be disassembled using
    `dumpbin`, `objdump`, and `otool`, respectively. None of those, however, can deal
    with arbitrary blocks of binary data. You will occasionally be confronted with
    a binary file that does not conform to a widely used file format, in which case
    you will need tools capable of beginning the disassembly process at user-specified
    offsets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，已经有工具可以生成二进制对象文件的死列表式反汇编。PE、ELF和Mach-O二进制文件可以分别使用`dumpbin`、`objdump`和`otool`进行反汇编。然而，这些工具都无法处理任意的二进制数据块。你有时会遇到不符合广泛使用文件格式的二进制文件，在这种情况下，你需要能够从用户指定的偏移量开始反汇编过程的工具。
- en: Two examples of such *stream disassemblers* for the x86 instruction set are
    `ndisasm` and `diStorm`.^([13](footnotes.xhtml#ch02fn13)) The utility `ndisasm`
    is included with the NASM.^([14](footnotes.xhtml#ch02fn14)) The following example
    illustrates the use of `ndisasm` to disassemble a piece of shellcode generated
    using the Metasploit framework:^([15](footnotes.xhtml#ch02fn15))
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两个适用于x86指令集的*流式反汇编工具*的示例是`ndisasm`和`diStorm`。^([13](footnotes.xhtml#ch02fn13))
    工具`ndisasm`包含在NASM中。^([14](footnotes.xhtml#ch02fn14)) 以下示例展示了如何使用`ndisasm`反汇编通过Metasploit框架生成的一段shellcode：^([15](footnotes.xhtml#ch02fn15))
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The flexibility of stream disassembly is useful in many situations. One scenario
    involves the analysis of computer network attacks in which network packets may
    contain shellcode. Stream disassemblers can be used to disassemble the portions
    of the packet that contain shellcode in order to analyze the behavior of the malicious
    payload. Another situation involves the analysis of ROM images for which no layout
    reference can be located. Portions of the ROM will contain data, while other portions
    will contain code. Stream disassemblers can be used to disassemble just those
    portions of the image thought to be code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 流式反汇编的灵活性在许多情况下都非常有用。一种场景涉及计算机网络攻击的分析，其中网络数据包可能包含shellcode。流式反汇编工具可以用来反汇编数据包中包含shellcode的部分，以便分析恶意负载的行为。另一种情况是分析没有布局参考的ROM镜像。ROM的某些部分包含数据，而其他部分则包含代码。流式反汇编工具可以用来仅反汇编那些被认为是代码的镜像部分。
- en: '### **Summary**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '### **总结**'
- en: The tools discussed in this chapter are not necessarily the best of their breed.
    They do, however, represent tools commonly available for anyone who wishes to
    reverse engineer binary files. More important, they represent the types of tools
    that motivated much of the development of Ghidra. In future chapters, we occasionally
    highlight stand-alone tools that provide functionality similar to that integrated
    into Ghidra. An awareness of these tools will greatly enhance your understanding
    of the Ghidra user interface and the many informational displays that Ghidra offers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的工具不一定是同类中最优秀的。然而，它们确实代表了任何希望反向工程二进制文件的人常用的工具。更重要的是，它们代表了促使Ghidra开发的工具类型。在未来的章节中，我们偶尔会介绍一些独立工具，这些工具提供与Ghidra集成的功能类似的功能。了解这些工具将极大提升你对Ghidra用户界面和Ghidra所提供的众多信息展示的理解。
