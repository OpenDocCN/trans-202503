- en: CRYPTO DICTIONARY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2013'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The year of Edward Snowden’s leaks about the NSA’s classified activities, a
    turning point in cryptography. End-to-end encryption suddenly becomes an appealing
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: '65537'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common RSA public exponent; large enough to not be insecure, small
    enough to make exponentiation fast, and of a form that optimizes implementations’
    speed (65537 = 2^(16) + 1).
  prefs: []
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A5/0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the three encryption modes in early mobile telephony standards (GSM).
    A5/0 just means *no encryption*; therefore, the audio content from a mobile call
    would be received and transmitted in the clear between a mobile device and the
    nearest base station. It’s as secure as early TLS versions’ *null cipher*.
  prefs: []
  type: TYPE_NORMAL
- en: A5/1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default GSM cipher in Western countries (prior to 3G and 4G technologies)
    that encrypts encoded audio mobile communications. A stream cipher based on a
    curious mechanism involving three linear feedback shift registers irregularly
    clocked; so the update of a register depends on the values of certain bits in
    the two other registers. Sophisticated cryptanalytic attacks have broken A5/1\.
    But in practice, the most effective attack is relatively simple: it’s a time-memory
    trade-off that exploits the short state of A5/1 (64 bits) and involves the precomputation
    of large rainbow tables. The A5/1 specification was initially confidential and
    unavailable to the public until it was reverse engineered in the late 1990s.'
  prefs: []
  type: TYPE_NORMAL
- en: A5/2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The export version of A5/1, a euphemism meaning its technical requirements
    include something like *must be easy to break by Western nations’ intelligence
    agencies*. Designed to be insecure, A5/2 didn’t turn out to be outrageously insecure:
    after being reverse engineered around the same time as A5/1, academic researchers
    quickly found attacks on A5/2\. But these attacks were more efficient on paper
    than in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: A5/3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At last, a real cipher in mobile phones. An upgrade to the do-it-yourself A5/1
    that applies an algorithm already public and vetted, namely the block cipher KASUMI.
    KASUMI was used in 2G (along with A5/1), in 3G as A5/4 (along with SNOW 3G), and
    was no longer supported in 4G.
  prefs: []
  type: TYPE_NORMAL
- en: See [*KASUMI*](#KASUMI).
  prefs: []
  type: TYPE_NORMAL
- en: A5/4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A5/3 but with a key of 128 bits instead of 64 bits; A5/4 is secure, whereas
    A5/3 isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attack in which the attacker’s actions depend on what they observe during
    the attack and the protocol’s execution. For example, in an adaptive chosen-plaintext
    attack, the attacker sends plaintext messages that depend on the responses to
    their previous queries. In a nonadaptive attack, the list of plaintexts for which
    the attacker queries the ciphertexts must be predetermined.
  prefs: []
  type: TYPE_NORMAL
- en: AEAD (authenticated encryption with associated data)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type of symmetric cipher that encrypts and authenticates data by producing
    a ciphertext as well as an authentication tag. The decryption step then only succeeds
    if the tag is valid, which proves that the ciphertext was created by someone who
    knows the key. To validate the tag, the receiving end generally computes it from
    the encrypted message and verifies that the computed value is identical to the
    one received.
  prefs: []
  type: TYPE_NORMAL
- en: AES (Advanced Encryption Standard)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ubiquitous block cipher standardized by NIST in 2000\. Designed by Belgian
    cryptographers Joan Daemen and Vincent Rijmen, and winner of the AES competition,
    its use is universal today under its various modes of operation, such as CBC,
    GCM, and SIV.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Rijndael*](#Rijndael).
  prefs: []
  type: TYPE_NORMAL
- en: AES-CCM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AES in counter-with-CBC-MAC mode, which combines the CTR encryption mode with
    CBC-MAC authentication. AES-CCM is a NIST standard and is supported in TLS 1.3
    and several other protocols, including Bluetooth Low Energy. But it’s much less
    popular than its sibling AES-GCM. The reason is that AES-CCM is generally slower
    and less convenient to use than AES-GCM. A research paper titled “A Critique of
    CCM” describes the limitations of the CCM mode.
  prefs: []
  type: TYPE_NORMAL
- en: AES-CCM sometimes fits better than AES-GCM in embedded platforms because it
    only needs an AES algorithm and no additional logic (unlike GCM’s GMAC).
  prefs: []
  type: TYPE_NORMAL
- en: AES-GCM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AES in Galois counter mode, the most common authenticated encryption primitive
    at the time of writing. Also the primitive that ended the reign of HMAC authenticators.
    In GCM mode, a message is encrypted in CTR mode and the Galois MAC (GMAC, aka
    GHASH) generates an authentication tag from the ciphertext and associated data
    blocks. The carry-less multiplication instruction PCLMULQDQ was introduced in
    Intel CPUs in the 2010s to speed up GMAC computations.
  prefs: []
  type: TYPE_NORMAL
- en: AES-GCM-SIV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variant of AES-GCM where the encryption nonce is determined from the tag
    computed by authenticating the plaintext (and any associated data). AES-GCM-SIV’s
    MAC, called *POLYVAL*, is slightly different from GCM’s GMAC: whereas AES-GCM
    is of the encrypt-then-MAC form, AES-GCM-SIV is a MAC-and-encrypt construction.
    The main benefit of AES-GCM-SIV compared to AES-GCM is that the former remains
    secure if a same nonce is reused—a property called *misuse resistance*.'
  prefs: []
  type: TYPE_NORMAL
- en: AES-NI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Officially AES New Instructions but often called native instructions, which
    might be a better term. AES-NIs are CPU instructions that compute AES using hardware
    logic in the chip’s silicon as opposed to a combination of arithmetic operations
    using the chip’s ALU. When introduced by Intel in 2008, AES-NIs made AES software
    about 10 times faster, and as a by-product, immune to cache-timing attacks.
  prefs: []
  type: TYPE_NORMAL
- en: AES-SIV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*SIV-AES*](#SIV-AES).
  prefs: []
  type: TYPE_NORMAL
- en: AIM (Advanced INFOSEC Machine)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A chipset designed by Motorola in the late 1990s that includes separate FPGAs
    for red and black operations. Pompously advertised as *one of the most revolutionary
    advances in cryptography, ever*. The NSA uses it to protect classified and sensitive
    national security information. The off-the-shelf AIM didn’t include classified
    (Suite A) algorithms, but users could program the FPGAs to support algorithms,
    such as ACCORDION or BATON.
  prefs: []
  type: TYPE_NORMAL
- en: AKA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 3GPP standards parlance, the authenticated key agreement operation between
    users of a cellular network and the user’s home network, which might be different
    from the serving network.
  prefs: []
  type: TYPE_NORMAL
- en: AKS (Agrawal–Kayal–Saxena)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first deterministic primality test, as opposed to randomized ones. The 2002
    research paper presenting the AKS algorithm, “PRIMES is in P,” was the first proof
    that the problem of primality testing is in the P complexity class, or the class
    of problems for which a nonrandomized polynomial-time algorithm exists.
  prefs: []
  type: TYPE_NORMAL
- en: See [*PRIMES*](#PRIMES).
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic cryptanalysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A form of cryptanalysis where the target problem (typically key recovery, but
    also forgery, distinguishing, and so on) is modeled as a system of multivariate
    equations to which a solution is found by generic or ad hoc techniques. Algebraic
    cryptanalysis has been used to attack symmetric and asymmetric cryptosystems.
    An example target is stream ciphers based on feedback shift registers with low
    algebraic degree logic, giving rise to underlying equations exploitable by algebraic
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Gröbner basis*](#Gr%C3%B6bner-basis).
  prefs: []
  type: TYPE_NORMAL
- en: Alice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bob’s partner in crime, but who never met Bob in person. According to their
    official biography in John Gordon’s 1984 speech: “Alice and Bob have tried to
    defraud insurance companies, they’ve played poker for high stakes by mail, and
    they’ve exchanged secret messages over tapped telephones. (. . .) Alice and Bob
    have very powerful enemies. One of their enemies is the Tax Authority. Another
    is the Secret Police. This is a pity, since their favorite topics of discussion
    are tax frauds and overthrowing the government.”'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Bob*](#Bob).
  prefs: []
  type: TYPE_NORMAL
- en: All-or-nothing transform (AONT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A reversible transformation where you need every bit of the output to determine
    any bit of the input. When an encryption scheme is an AONT, the decryption key
    is useless to determine the plaintext if you miss some bits of the ciphertext
    (unless the missing bits are so few that they can be brute-forced). The OAEP construction
    used for RSA encryption is an example of AONT. CBC or GCM encryption modes aren’t
    AONTs.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A signature that doesn’t reveal the identity (public key) of the signer and
    therefore needs some interaction with the signer to verify it. It implies invisibility.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Invisible signature*](#Invisible-signature).
  prefs: []
  type: TYPE_NORMAL
- en: '*Applied Cryptography*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 1996 book by Bruce Schneier that has been the main reference in the field
    for many years; it introduced many students and engineers to cryptography. Famous
    for its opening paragraph: “There are two kinds of cryptography in this world:
    cryptography that will stop your kid sister from reading your files, and cryptography
    that will stop major governments from reading your files. This book is about the
    latter.”'
  prefs: []
  type: TYPE_NORMAL
- en: Inevitably outdated 25 years after its publication, *Applied Cryptography* isstill
    worth keeping on your shelf as long as you don’t blindly follow all of its recommendations.
    It’s also much less outdated than Schneier’s two prior books, *E‑Mail Security*
    and *Protect Your Macintosh*.
  prefs: []
  type: TYPE_NORMAL
- en: Applied cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The part of cryptography that emphasizes direct applications. In contrast, theoretical
    cryptography is less about engineering and more about fundamental understanding
    and analysis. The term *applied* is deceiving; both applied and theoretical cryptography
    can (and ought to?) be equally relevant to real applications.
  prefs: []
  type: TYPE_NORMAL
- en: ARC4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original name of the RC4 stream cipher; also written as ARCFOUR. Before
    the reverse engineered RC4 was confirmed to be the actual RC4, it was prudently
    referred to as *alleged RC4*, which was shortened to ARC4.
  prefs: []
  type: TYPE_NORMAL
- en: Argon2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A password hashing function developed during the Password Hashing Competition.
    Also, a de facto standard for processing passwords or any low-entropy secret to
    derive cryptographic keys or store a verifier in a way that prevents efficient
    cracking using GPUs, FPGAs, dedicated hardware, precomputed tables, or side-channel
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike PBKDF2, Argon2 can enforce the use of a certain amount of memory in addition
    to a configurable number of iterations. Unlike bcrypt, this amount of memory can
    be an arbitrary value rather than fixed. Unlike scrypt and the two others, Argon2
    offers a user-friendly interface to easily pick time and memory parameters. It’s
    also a simple design that only uses the hash function BLAKE2 internally rather
    than a combination of all the cryptography ever designed.
  prefs: []
  type: TYPE_NORMAL
- en: See [*bcrypt*](#bcrypt), [*scrypt*](#scrypt), [*PBKDF2 (Password-Based Key Derivation
    Function 2)*](#PBKDF2-Password-Based-Key-Derivation-Function-2).
  prefs: []
  type: TYPE_NORMAL
- en: ARX (Add-Rotate-XOR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An abbreviation that denotes cryptographic algorithms only doing integer additions,
    word bit shifts or rotations, and XORs (as opposed to, for example, algorithms
    using S-boxes). It was coined by cryptography and security researcher Ralf-Philipp
    Weinmann in 2009\.
  prefs: []
  type: TYPE_NORMAL
- en: ASIACRYPT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asia’s top academic cryptography conference, held every autumn in a different
    location in the Asia-Pacific region since 1990\. The only IACR conference that
    includes *IACR* as a substring of its name. Researchers present peer-reviewed
    research papers with titles such as “Structure-Preserving and Re-Randomizable
    RCCA-Secure Public Key Encryption and Its Applications”and “Cryptanalysis of GSM
    Encryption in 2G/3G Networks Without Rainbow Tables.”
  prefs: []
  type: TYPE_NORMAL
- en: See [*CHES*](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems),
    [*CRYPTO*](#CRYPTO), [*Eurocrypt*](#Eurocrypt), [*FSE*](#FSE-Fast-Software-Encryption),
    [*PKC*](#PKC), [*Real World Crypto*](#Real-World-Crypto-RWC), [*TCC*](#TCC).
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Public-key cryptography*](#Public-key-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: Attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of cryptanalysis, the demonstration of a technique, described
    as an algorithm, that violates a security claim made by the designers of the primitive
    or protocol attacked.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based encryption (ABE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A generalization of identity-based encryption from one attribute (the identity)
    to more than one. It allows you to encrypt a message not to a given recipient,
    but to a set of attributes in such a way that only parties satisfying a valid
    combination of attributes can decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: ABE sounds powerful but hasn’t found many real applications. Allegedly, the
    reason is due to its relatively complex construction (using elliptic-curve pairings)
    and the need for a trusted third party (holding the master key needed to generate
    private keys).
  prefs: []
  type: TYPE_NORMAL
- en: See [*Identity-based encryption*](#Identity-based-encryption).
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*AEAD*](#AEAD-authenticated-encryption-with-associated-data-).
  prefs: []
  type: TYPE_NORMAL
- en: Axolotl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original name of the Signal application’s end-to-end messaging protocol.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Signal protocol*](#Signal-protocol).
  prefs: []
  type: TYPE_NORMAL
- en: B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backdoor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A covert feature to bypass an algorithm or protocol’s security. Trapdoors are
    known by users to exist; backdoors usually are not. A backdoor was once defined
    as *a feature or defect that allows surreptitious access to data*. A good backdoor
    must be undetectable, NOBUS (no-one-but-us, or exclusively exploitable by its
    architects), reusable, unmodifiable, and deniable.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, backdoors in cryptographic algorithms are difficult to design
    and are more easily added in implementations, especially when the internal logic
    isn’t open and hard to deobfuscate. The NSA backdoor in Dual_EC_DRBG is a notable
    exception. Unfortunately, the most interesting research about backdoors isn’t
    presented at IACR conferences.
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking resistance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Term notably used by NIST to refer to a notion similar to forward secrecy. The
    opposite of prediction resistance.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Forward secrecy*](#Forward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: Backward secrecy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The opposite of forward secrecy: backward secrecy is the property that if an
    attacker compromises some secret values, future messages remain protected. If
    an entire system’s state is compromised—­including long-term and short-term keys
    as well as any secret state or counter—backward secrecy is often impossible. An
    exception is pseudorandom generators, where uncertainty can be brought into the
    system via reseeding from reliable entropy sources, preventing an attacker from
    determining future output bits from a past snapshot of the system. In the context
    of secure messaging, some models assume that an attacker would compromise only
    certain sets of keys, but not necessarily the entire local secret state: in this
    case, some form of backward secrecy might be guaranteed.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Forward secrecy*](#Forward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: Base64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not encryption.
  prefs: []
  type: TYPE_NORMAL
- en: BassOmatic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cipher initially designed by Phil Zimmermann, the creator of PGP, to encrypt
    data in PGP. It was found to be insecure and replaced by IDEA in 1991\. As Zimmermann
    commented in the source code, “BassOmatic gets its name from an old Dan Aykroyd
    *Saturday Night Live* skit involving a blender and a whole fish. The BassOmatic
    algorithm does to data what the original BassOmatic did to the fish.”
  prefs: []
  type: TYPE_NORMAL
- en: BB84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first quantum key distribution (QKD) construction. It was described by Bennett
    and Brassard in 1984 and was based on ideas from the concept of quantum money,
    introduced a year earlier.
  prefs: []
  type: TYPE_NORMAL
- en: bcrypt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A hash algorithm: it doesn’t encrypt. Defined to address the obsolescence of
    the 1976 crypt utility in the 1999 paper “A Future-Adaptable Password Scheme.”
    In this paper, the authors made the following prediction: “Failing a major breakthrough
    in complexity theory, these algorithms should allow password-based systems to
    adapt to hardware improvements and remain secure 20 years into the future.”'
  prefs: []
  type: TYPE_NORMAL
- en: You can argue that this prophecy was accurate, because you can tune bcrypt to
    be slow enough to defeat password cracking. On the other hand, bcrypt’s 4KB memory
    usage is now too low to prevent efficient cracking.
  prefs: []
  type: TYPE_NORMAL
- en: Biclique cryptanalysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attack against cryptographic algorithms that works by searching for bicliques.
    In graph theory, a clique is a subset of nodes that are all connected to each
    other. A biclique is composed of two subsets of nodes; each node from the first
    subset is connected to all nodes from the second.
  prefs: []
  type: TYPE_NORMAL
- en: This concept was applied to refine differential attacks on AES and lead to attacks
    that, in theory, perform fewer operations than a brute-force search (2^(126) instead
    of 2^(127)). The bicliques used in this context are composed of a first set of
    bits from the internal state, a second set of bits from the ciphertext, and dependencies
    between these two sets conditioned by key bits. The idea of the attack is then
    to identify certain bits of the key as those for which the biclique conditions
    are satisfied (in terms of XOR differences).
  prefs: []
  type: TYPE_NORMAL
- en: BIKE (Bit Flipping Key Encapsulation)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sounds like SIKE: also a KEM; also post-quantum, but based on a decoding problem
    rather than an isogeny problem.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*SIKE (Supersingular Isogeny Key Encapsulation)*](#SIKE-Supersingular-Isogeny-Key-Encapsulation).
  prefs: []
  type: TYPE_NORMAL
- en: BIP (Bitcoin improvement proposal)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A misleading name, because the most famous BIPs are no longer just proposals
    but de facto standards that apply to more cryptocurrencies than just Bitcoin.
    These BIPs include:'
  prefs: []
  type: TYPE_NORMAL
- en: BIP 32, which defines a tree-based mechanism to derive key pairs and addresses
    from a secret seed to create wallets of multiple accounts from a single secret
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BIP 44, which assigns semantics to BIP 32 tree levels and defines a syntax for
    paths within this tree (consisting of purpose, coin type, account, address type,
    and address index).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BIP 39, which defines a representation of a secret value as a high- entropy
    list of dictionary words, or mnemonic, which is then hashed to a seed that will
    be the root of a BIP 32 hierarchy of accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bit Gold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The closest predecessor of Bitcoin.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An experiment that went out of control, for better or for worse.
  prefs: []
  type: TYPE_NORMAL
- en: Black
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NSA jargon referring to encrypted values. A black key is an encrypted key that
    uses, for example, a key wrapping mechanism so that it can be safely distributed
    on lower-security-level systems or networks. In the context of data-at-rest protection,
    black data is classified data that has been encrypted twice using appropriate
    encryption layers.
  prefs: []
  type: TYPE_NORMAL
- en: See [*EKMS (Electronic Key Management System)*](#EKMS-Electronic-Key-Management-System).
  prefs: []
  type: TYPE_NORMAL
- en: BLAKE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash function submitted to the SHA-3 competition in 2008\. It was one of five
    finalists but wasn’t selected (the winner was Keccak). BLAKE reuses the permutation
    of the ChaCha stream cipher with rotations done in the opposite directions. Some
    have suspected an advanced optimization, but in fact it originates from a typo
    in the original BLAKE specifications.
  prefs: []
  type: TYPE_NORMAL
- en: BLAKE2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An evolution of BLAKE proposed shortly after the end of the SHA-3 competition
    in 2012\. It was adopted in many software applications because it’s faster than
    SHA-2 and SHA-3\. Several cryptocurrencies’ proof-of-work systems use BLAKE2.
  prefs: []
  type: TYPE_NORMAL
- en: BLAKE3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash function that combines a reduced-round BLAKE2 and a Merkle tree construction,
    making it significantly faster than BLAKE2\. BLAKE3 was announced at the Real
    World Crypto 2020 conference.
  prefs: []
  type: TYPE_NORMAL
- en: Bleichenbacher attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The epitome of a padding oracle attack. Discovered in 1998 by Daniel Bleichenbacher,
    this is an adaptive chosen-ciphertext attack against the PKCS#1 v1.5 RSA encryption
    method. Ironically, Bleichenbacher’s attack exploits safeguards against other
    attacks (the mandatory padding bytes) to craft another attack, which after a few
    million chosen-ciphertext queries allows an attacker to recover a ciphertext’s
    plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Blind signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A signature scheme where the signer (knowing the private key) creates a signature
    without knowing the number signed in a way that randomizes the value that the
    private key operation is applied to. This is clearer in the straightforward RSA
    blind signature construction: instead of using *md* mod *N*, the signer computes
    *s*[0] = *m*[0]^(*d*) where *m*[0] = (*m* · *r*^(*e*)) mod *N* where *r* is some
    random value. You can then get the real signature of *m* by dividing *s*[0] by
    *r*. Details are left as an exercise for you to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: This construction might look familiar because it’s the same trick the blinding
    defense uses against side-channel attacks to prevent attackers from controlling
    the data the private-key operation processes.
  prefs: []
  type: TYPE_NORMAL
- en: Block cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cipher that transforms a block of data to another block of the same length
    with a key as a parameter. It must be possible to decrypt the block. So the block
    cipher operation must be bijective (that is, one-to-one and reversible). That’s
    why block ciphers are also *keyed permutations* or *pseudorandom permutations*.
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt more than a single block, which is usually a 64-bit or 128-bit chunk,
    you need to use a mode of operation (using the ECB mode is usually a bad idea,
    CBC is better, and CTR or SIV might be even better).
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both a curse and a blessing to cryptography. Comparable to when a subculture
    goes mainstream and its pioneers miss the old days, and sadly and bitterly contemplate
    the newly acquired wealth of those who might not deserve it the most.
  prefs: []
  type: TYPE_NORMAL
- en: Blockcipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative spelling of block cipher, introduced in research papers by Phillip
    Rogaway.
  prefs: []
  type: TYPE_NORMAL
- en: Blowfish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most popular block ciphers in the 1990s. It owes its recognition
    to its memorable name and to its designer Bruce Schneier.
  prefs: []
  type: TYPE_NORMAL
- en: BLS (Boneh-Lynn-Shacham) signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A signature scheme that leverages elliptic-curve pairings, allowing signatures
    to be shorter than ECDSA and Schnorr signatures. The reason is that each signature
    consists of a single group element. That is, for a similar security level as a
    512-bit ECDSA signature, a BLS signature would be only 256 bits long.
  prefs: []
  type: TYPE_NORMAL
- en: BLS signatures have the useful property of supporting aggregation, whereby multiple
    public keys and signatures can be combined into a single public key and a single
    signature, and batch verification can be done efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Combined with distributed key generation, you can use BLS signatures to build
    threshold signature schemes, which proved useful in cryptocurrency applications
    to distribute transaction signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Bob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subversive stockbroker and Alice’s co-conspirator.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Alice*](#Alice).
  prefs: []
  type: TYPE_NORMAL
- en: Boolean function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function whose arguments are binary values (that is, either 0 or 1), and that
    returns a single 0 or 1 bit. For example, *f*(*a*, *b*, *c*) = *a* + *b* + *ac*
    + *bc* + 1, where *a*, *b*, and *c* are binary values, is a Boolean function.
    Here, the plus sign behaves like XOR (because there are only 0s and 1s in Boolean
    functions), and *ab* means *a* times *b*, which is equivalent to a logical AND
    operation (giving 1 if and only if *a* = *b* = 1).
  prefs: []
  type: TYPE_NORMAL
- en: Boomerang attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A differential cryptanalysis technique in which you first *throw* a pair of
    plaintexts with a given difference into the cipher. You then obtain two ciphertexts
    and set another difference in these two ciphertexts to obtain two new ciphertexts.
    Finally, you *catch* the plaintexts obtained by decrypting them. The boomerang
    attack is essentially a trick to exploit differential characteristics that only
    cover part of the cipher.
  prefs: []
  type: TYPE_NORMAL
- en: BQP (bounded-error quantum polynomial time)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class of problems that quantum algorithms, and therefore a hypothetical
    quantum computer, can efficiently solve. BQP contains problems that classical
    computers can solve efficiently but also problems that today’s computers cannot.
    The latter are problems for which a superpolynomial quantum speedup exists.
  prefs: []
  type: TYPE_NORMAL
- en: Braid group cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attempt to build a new type of public-key cryptography using noncommutative
    groups of elements. Such elements can be viewed as braids with a fixed number
    of strands, and group operations are computationally efficient. As a side benefit,
    braid group cryptosystems were expected to be resistant to quantum algorithms.
    But none of the proposed key agreement schemes proved very cryptographically valuable
    due to their insufficient security.
  prefs: []
  type: TYPE_NORMAL
- en: Brainpool curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Elliptic curves designed by the German Federal information security authority
    (*Bundesamt für Sicherheit in der Informationstechnik*, or BSI). Brainpool curves
    have some suboptimal security properties, but unlike other standards, they provide
    a 512-bit curve (rather than a 521-bit one).
  prefs: []
  type: TYPE_NORMAL
- en: Break-in recovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A notion similar to backward secrecy and indistinguishable from future secrecy.
    The term was coined in the context of the Signal protocol.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Backward secrecy*](#Backward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type of encryption where the same ciphertext is broadcast to a set of receivers
    so only authorized ones can decrypt it, and receivers can be revoked to no longer
    decrypt it. Challenges of broadcast encryption are to be secure against collusion
    of receivers and to minimize ciphertext and keys’ lengths.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-force attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type of attack that attempts to recover a secret by consecutively trying all
    the possible values of that secret. You can start a brute-force attack against
    most ciphers. But as long as the secret is long enough, the attack will never
    terminate (unless you’re impossibly lucky), because there are too many values
    to try.
  prefs: []
  type: TYPE_NORMAL
- en: Bulletproof
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A zero-knowledge proof proposed as an efficient range proof for cryptocurrencies.
    The major advantage of bulletproofs is that they don’t require a trusted setup.
    Specifically, they don’t need an initialization of the parameters, or *rules of
    the game*, which must be trusted for the protocol to be secure. Bulletproofs are
    notably used in Monero.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Range proof*](#Range-proof).
  prefs: []
  type: TYPE_NORMAL
- en: Byzantine fault tolerance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An umbrella term for a class of consensus protocols that don’t directly rely
    on mining and proof-of-something. pBFT (and variants thereof) and Tendermint are
    such protocols; they work by having a fixed number of hosts working together to
    reliably maintain a common state while distributing trust across hosts.
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CAESAR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Competition for Authenticated Encryption: Security, Applicability, and
    Robustness, a non-NIST cryptographic competition that took place from 2014 to
    2019\. Partially funded by but not supervised by NIST, CAESAR identified new authenticated
    ciphers for several use cases, including *lightweight applications (resource constrained
    environments)*, *high-performance applications*, and *defense in depth*.'
  prefs: []
  type: TYPE_NORMAL
- en: Caesar’s cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ancient cipher that encrypts a message by shifting each of its letters by
    three positions, so ABC becomes EFG, CAESAR becomes FDHVDU, and so on. Needless
    to say, Caesar’s cipher isn’t very secure.
  prefs: []
  type: TYPE_NORMAL
- en: CAVP (Cryptographic Algorithm Validation Program)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NIST’s process to assess that an algorithm’s implementation conforms to the
    standard specification of that algorithm. Prerequisite of a cryptographic module’s
    validation through CMVP in the context of FIPS 140-2 certification. CAVP is essentially
    about checking test vectors, whereas CMVP covers the other FIPS 140-2 evaluation
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: See [*CMVP (Cryptographic Module Validation Program)*](#CMVP-Cryptographic-Module-Validation-Program),
    [*FIPS 140-2*](#FIPS-140-2).
  prefs: []
  type: TYPE_NORMAL
- en: CBC (cipher block chaining)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A mode of operation for block ciphers that has nothing to do with blockchains.
    CBC encrypts a series of blocks *P*[i]to ciphertext blocks *C*[i]by computing
    *C*[i]= Enc(*K*, *P*[i]⊕*C*[i][–1]), for *i* = 1, . . . , *n*. The initial value
    of (IV) is *C*[0],which should be unpredictable to guarantee semantic security.
    CBC has the useful property that decryption is parallelizable (whereas encryption
    isn’t). Unfortunately, CBC is vulnerable to padding oracle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: CECPQ (combined elliptic-curve and post-quantum)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hybrid key agreement scheme including an elliptic-curve and a post-quantum
    scheme. CECPQ was developed by Google as a way to hedge TLS connections against
    the risks of quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: The first version, CECPQ1, combined X25519 with the lattice-based scheme NewHope,
    and was deployed in 2016 for a few months in the Chrome Canary browser. Announced
    in 2019, CECPQ2 replaces NewHope with the NTRU-based scheme HRSS, and the variant
    CECPQ2b uses the isogeny-based scheme SIKE.
  prefs: []
  type: TYPE_NORMAL
- en: Cellular automata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Useless in cryptography. It’s a source of many bad papers.
  prefs: []
  type: TYPE_NORMAL
- en: Ceremony
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A procedure during which important keys, secrets, or sensitive parameters are
    generated. A ceremony includes procedural and technical security controls to provide
    assurance about the keys’ secure generation and backup—and thus about the software,
    hardware, processes, and people involved. It’s more than picking an acceptable
    PRNG, which is actually the easiest part. For example, a ceremony involves participants
    with well-defined roles (such as auditors and operators), a predefined sequence
    of operations (known as a script or storybook), and the writing of detailed minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Ceremonies are typically held to generate root keys of certificate authorities
    or master keys (seeds) of blockchain wallets in financial institutions. They are
    then called *key ceremonies*. Ceremonies can also be called *trusted setups* when
    they aim to generate parameters of a zero-knowledge proof system.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source of many troubles, including encoding formats, parsing bugs, unrenewed
    expired certificates, broken chains, untrusted authorities, self signatures, revocation
    lists, and so on. But often it’s the least-bad solution we have.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate authority (CA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A trusted third party in public-key infrastructures, or the type of component
    that cryptographers try to avoid but inevitably must live with.
  prefs: []
  type: TYPE_NORMAL
- en: A CA is the entity you must ultimately trust when verifying the validity of
    a certificate, because the CA can issue certificates as well as intermediate signing
    certificates. If the CA is compromised, it might grant certificates to malicious
    entities to perform phishing or man-in-the-middle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Even some blockchain platforms that claim to be fully decentralized and distributed
    ultimately rely on a CA.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate transparency (CT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Google initiative that reduces the risk from rogue or compromised CAs by creating
    a public log of certificates being issued. Certificate transparency makes it easier
    for the domain owner to know whether certificates have been issued for their domain.
    CT is a kind of public ledger, but it’s not a blockchain and has been criticized
    by blockchain advocates.
  prefs: []
  type: TYPE_NORMAL
- en: ChaCha20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variant of the Salsa20 stream cipher that is currently one of the most used
    stream ciphers in the world. This is because it’s supported in recent TLS and
    SSH versions and is the default cipher in many protocols, such as WireGuard.
  prefs: []
  type: TYPE_NORMAL
- en: CHES (Conference on Cryptographic Hardware and Embedded Systems)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most *real-world* conference of all IACR conferences before Real World Crypto
    existed. It’s held every year in a different location. Researchers present peer-reviewed
    research papers with titles such as “Electromagnetic Information Extortion from
    Electronic Devices Using Interceptor, Its Countermeasure”and “Make Some Noise.
    Unleashing the Power of Convolutional Neural Networks for Profiled Side-Channel
    Analysis.”
  prefs: []
  type: TYPE_NORMAL
- en: See [*Asiacrypt*](#ASIACRYPT), [*CRYPTO*](#CRYPTO), [*Eurocrypt*](#Eurocrypt),
    [*FSE*](#FSE-Fast-Software-Encryption), [*PKC*](#PKC), [*Real World Crypto*](#Real-World-Crypto-RWC),
    [*TCC*](#TCC).
  prefs: []
  type: TYPE_NORMAL
- en: CIA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three cardinal principles of information security: confidentiality, integrity,
    and availability. The cryptographer’s version of the principles replaces *availability*
    with *authenticity*.'
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext stealing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A technique to encrypt with a block cipher in CBC mode such that the ciphertext
    is of the same bit length as the plaintext. Instead of padding the last plaintext
    block with fixed values, as in PKCS#7 padding, it appends ciphertext bytes from
    the previous blocks to obtain a full block. It also strips off said bytes of the
    previous encrypted block to retain the original message size. This trick only
    works if the message is longer than one block. Standardized by NIST in three different
    versions (CS1, CS2, and CS3), ciphertext stealing is rarely used in practice,
    because most of the time a small overhead is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Clipper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple solution proposed for a complex problem: the Clipper chip aimed to
    enable encrypted communications for US citizens and businesses while allowing
    full interception by authorized parties (namely, government and law enforcement).
    Proposed in the early 1990s by the NSA, the Clipper chip was part of a key escrow
    architecture where each chip’s secret keys would also be shared with US Federal
    agencies. This has been called a backdoor, but strictly speaking isn’t really
    one because the door’s existence wasn’t a secret.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its questionable security architecture, the Clipper chip suffered
    from a poor technical execution and included a number of security flaws, which
    helped its opponents halt the project.
  prefs: []
  type: TYPE_NORMAL
- en: CMVP (Cryptographic Module Validation Program)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NIST’s process for validating cryptographic modules submitted to the FIPS 140-2
    certification. To be evaluated within CMVP, a cryptographic component must implement
    at least one NIST-standard algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: See [*CAVP (Cryptographic Algorithm Validation Program)*](#CAVP-Cryptographic-Algorithm-Validation-Program),
    [*FIPS 140-2*](#FIPS-140-2).
  prefs: []
  type: TYPE_NORMAL
- en: Code-based cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Post-quantum schemes relying on hardness of decoding a linear code with insufficient
    information. Many code-based schemes are variants of the 1978 McEliece construction,
    whose public key describes a random linear code. The encryption process consists
    of encoding a message while adding some errors to the codeword. Decryption is
    possible due to a trapdoor that converts the codeword into another code for which
    decoding is doable.
  prefs: []
  type: TYPE_NORMAL
- en: The submission *Classic McEliece* to NIST’s post-quantum competition in 2017
    is almost identical to McEliece’s 1978 scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Commitment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also known as bit commitment, a protocol in which a prover temporarily hides
    a message that cannot be changed. The prover does this by publishing some value
    that doesn’t reveal the value committed (a feature called the *hiding property*)
    and must also prevent the prover from revealing a different value than the one
    committed (called the *binding property*). The term *bit commitment* initially
    referred to coin-flipping protocols in which you commit only one bit. But it’s
    now used for values of any size. The hash values that security people mysteriously
    post on Twitter so they can claim prior discovery of some 0-day vulnerability
    are basic commitments.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent zero-knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Zero-knowledge proofs secure in concurrent settings, that is, when the attacker
    can observe and disrupt multiple independent executions of the proof protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Consensus protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An old concept from the field of distributed computing that became cool again
    due to its role in blockchain systems.
  prefs: []
  type: TYPE_NORMAL
- en: Control word
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A secret key used to encrypt audio and video content in pay-TV systems. This
    key is 48 bits long in legacy systems, 64 bits long in less old ones, and 128
    bits long in the latest generation. Although 48 bits might seem ridiculously short,
    when the key is changed every 5 or 10 seconds, it can be long enough.
  prefs: []
  type: TYPE_NORMAL
- en: COPACOBANA (Cost-Optimized PArallel COde Breaker)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An academic proof of concept of an FPGA-based DES cracker. Created in approximately
    2007, COPACOBANA is capable of breaking a 56-bit DES key within a week in a cost-effective
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Cothority (collective authority)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A framework for creating decentralized protocols where an operation involves
    multiple parties so none has greater authority than the others. You can use cothorities
    to perform operations, such as threshold signature, consensus, or distributed
    public randomness generation. Although it sounds very blockchain-y, few blockchains
    have used cothorities.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptanalysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The practice of analyzing cryptographic algorithms to break them—that is, violate
    their security assumptions—or to understand why they cannot be broken.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animals like bigfoots, unicorns, the Kraken, or the Mongolian death worm. As
    rare as good cryptography software.
  prefs: []
  type: TYPE_NORMAL
- en: Crypto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shorthand for cryptography and sometimes for cryptocurrency. Use in the latter
    sense tends to irritate orthodox cryptographers who rally under the banner “crypto
    is for cryptography.”
  prefs: []
  type: TYPE_NORMAL
- en: CRYPTO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The top academic cryptography conference held every summer since 1981 in Santa
    Barbara, California. Researchers present peer-reviewed papers with titles such
    as “iO Without Multilinear Maps: New Paradigms via Low-Degree Weak Pseudorandom
    Generators and Security Amplification” and “Seedless Fruit Is the Sweetest: Random
    Number Generation, Revisited.”'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Asiacrypt*](#ASIACRYPT), [*CHES*](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems),
    [*Eurocrypt*](#Eurocrypt), [*FSE*](#FSE-Fast-Software-Encryption), [*PKC*](#PKC),
    [*Real World Crypto*](#Real-World-Crypto-RWC), [*TCC*](#TCC).
  prefs: []
  type: TYPE_NORMAL
- en: Crypto AG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The “Swiss” company known for literally being owned by the CIA and German intelligence
    between 1970 and 1994\. It allowed the agencies to read the secret communications
    of several world governments.
  prefs: []
  type: TYPE_NORMAL
- en: Crypto period
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lifetime of a key in some key management systems, such as the NSA’s EKMS.
    In pay-TV systems, the crypto period is the time during which the same control
    word (that is, the secret key) is used to encrypt audio and video content. Typical
    crypto periods are 5 and 10 seconds. These periods might seem short, but they’re
    not short enough to prevent some control-word sharing attacks, whereby the key
    from one legitimate subscriber is distributed to a large number of pirate boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Crypto variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original name for cryptographic keys in the NSA. It was in use until the
    director of the NSA decided the agency should use the word *key* instead.
  prefs: []
  type: TYPE_NORMAL
- en: Crypto wars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bellicose term referring to the open disagreements and debates between the
    US government (and governments of some other Western countries) on the one hand
    and activists, including researchers and privacy advocates, on the other. The
    governments wanted more control and surveillance capabilities, typically via proprietary
    algorithms, export control regulations, key escrow mechanisms, and so on; the
    latter parties pleading in favor of the right to develop and use any cryptographic
    mechanism as a way to support privacy rights.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptobiosis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nothing to do with cryptography but fascinating nonetheless: a near-death state
    that certain living organisms can enter in response to adverse conditions. When
    danger subsides, the organisms can return to their original metabolic state. The
    tardigrade, sometimes used as an allegory for strong cryptography, can enter into
    cryptobiosis.'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptocurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Crypto*](#Crypto).
  prefs: []
  type: TYPE_NORMAL
- en: Crypto-Gram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The monthly cryptography digest by Bruce Schneier published since 1998.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Cryptology*](#Cryptology).
  prefs: []
  type: TYPE_NORMAL
- en: '*Cryptologia*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the oldest scholarly journal about cryptography; published since 1977.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Cryptography*](#Cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: '*Cryptonomicon*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A 1,000-page novel that references cryptography on about every other page. It
    was written by Neal Stephenson and was published in 1999\. It’s not very Lovecraftian,
    despite what its title might suggest.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other books in which the crypto is mostly made up and laughably unrealistic,
    *Cryptonomicon* relies on historical facts and genuine cryptographic techniques.
    Readers might remember the cipher Solitaire (which Bruce Schneier created for
    the book) and the van Eck phreaking technique.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Solitaire*](#Solitaire).
  prefs: []
  type: TYPE_NORMAL
- en: Cryptorchidism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A condition better kept confidential.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptovirology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Popularized by the 2004 book *Malicious Cryptography: Exposing Cryptovirology*.
    The book describes cryptovirology as “the dark side of cryptography—that device
    developed to defeat Trojan horses, viruses, password theft, and other cyber-crime
    (. . .) the art of turning the very methods designed to protect your data into
    a means of subverting it.”'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Kleptography*](#Kleptography).
  prefs: []
  type: TYPE_NORMAL
- en: CRYPTREC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Japanese government’s Cryptography Research and Evaluation Commit­tees in
    charge of establishing official cryptography recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: CSIDH (Commutative Supersingular Isogeny Diffie–Hellman)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pronounced *seaside*, the oldest isogeny-based scheme, revisited for efficiency.
    Also the only post-quantum scheme to have attracted some interest despite a well-known
    subexponential quantum attack. The proposed parameters “provide relatively little
    quantum security,” in the words of its cryptanalysts; however, its defenders point
    to its unique applications in the post-quantum arena, such as static key exchange.
    It’s not the same as SIDH.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Diffie–Hellman*](#Diffie%E2%80%93Hellman), [*Post-quantum cryptography*](#Post-quantum-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: CTF (capture the flag)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A popular competition in the information security community. In the last 15
    years, the crypto challenges presented in CTFs have evolved from Vigenère ciphers
    and visual puzzles to tasks involving state-of-the-art research. For example,
    participants in the 2020 edition of PlaidCTF had to break an isogeny-based cryptosystem
    (SIDH) and solve a multivariate system of equations.
  prefs: []
  type: TYPE_NORMAL
- en: Cube attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type of higher-order differential cryptanalysis technique, described in 2008
    to attack lightweight stream ciphers. The *cube* refers to the combination of
    bits over which to compute the higher-order differential, extending the notion
    of a 3D cube to arbitrary dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Curve25519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A reliable alternative to standardized elliptic curves, albeit somewhat clumsily
    named: *25519* doesn’t refer to the number 25519, but to 2^(255) − 19, the number
    of elements in the finite field that Curve25519 is defined over. As a result,
    there are three types of cryptographers: the *twenty-five five nineteen* ones,
    the *two five five nineteen* ones, and the *two five five one nine* ones. Fortunately,
    the curve’s technical design is much better than its name thanks to its parameters
    optimized for speed and safe implementation, as well as its absence of unexplained
    constants, unlike in NIST curves.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use Curve25519 for Diffie–Hellman key agreement, signature, or encryption
    (via ECIES).
  prefs: []
  type: TYPE_NORMAL
- en: See [*Ed25519*](#Ed25519), [*X25519*](#X25519).
  prefs: []
  type: TYPE_NORMAL
- en: Curve448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lesser-known little sibling of Curve25519\. It provides 224-bit security instead
    of 128-bit security due to its use of a finite field with 2^(448) − 2^(224) −
    1 elements. Its signature and Diffie–Hellman primitives, Ed448 and X448, are supported
    in TLS 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Curve25519*](#Curve25519).
  prefs: []
  type: TYPE_NORMAL
- en: Cypher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alternative spelling of cipher used in pop culture. Its use is considered heresy
    in academic literature.
  prefs: []
  type: TYPE_NORMAL
- en: D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Daemon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A misspelling of the last name of Joan Daemen, who co-designed AES and SHA-3.
  prefs: []
  type: TYPE_NORMAL
- en: Davies–Meyer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common technique to create a compression function from a block cipher
    (or keyed permutation). It’s used, for example, in MD5, SHA-1, and SHA-2\. Instead
    of using the block cipher to encrypt as Enc(*K*, *M*), you use it to compress
    a message block *M* and a hash value *H* to obtain the new hash value Enc(*M*,
    *H*) ⊕*H*, where *M* acts as the cipher’s key. Alone, a compression function is
    a bit useless, but it’s easy to turn it into a proper hash function, using, for
    example, the Merkle–Damgård construction.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, there’s no legitimate reason to build your own hash from a block
    cipher (as an exercise, figure out why it’s a bad idea to do so with AES in Davies–Meyer
    mode); yet the possible use of block ciphers to construct hash functions motivated
    cryptanalysts to investigate known-key and chosen-key attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized private computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A combination of trusted execution and private blockchain token transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Déchiffrer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: French for *to decrypt* when you have the key.
  prefs: []
  type: TYPE_NORMAL
- en: Décrypter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: French for *to decrypt* when you don’t have the key and thus must use cryptanalysis.
  prefs: []
  type: TYPE_NORMAL
- en: Deniable encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Randomized public-key encryption where the encrypting party, if coerced to reveal
    the plaintext and randomness used, can choose different valid combinations of
    plaintext and randomness, thus preventing self-incrimination.
  prefs: []
  type: TYPE_NORMAL
- en: Deniable encryption can also loosely refer to systems where different keys can
    decrypt to different legitimate-looking plaintexts, again to dissimulate the real
    plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Although motivated by potential real-world problems, deniable encryption is
    usually not the solution to such problems.
  prefs: []
  type: TYPE_NORMAL
- en: DES (Data Encryption Standard)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first modern block cipher, standardized by NIST’s predecessor, the National
    Bureau of Standards. It’s broken by linear cryptanalysis more efficiently than
    brute force if you can find 2^(43) plaintext/ciphertext pairs. If not, it’s now
    broken by design because of its too short keys.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A worthless book now that the internet exists.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attack that guesses passwords based on a list of words. Passwords have low
    entropy because they’re often composed of dictionary words and common proper nouns.
    An attacker can build a list of candidate passwords, ranked in order of popularity,
    and try them one after another, or in parallel, to find the password that hashes
    to the value they obtained from some password hash database.
  prefs: []
  type: TYPE_NORMAL
- en: Differential cryptanalysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class of cryptanalysis techniques that study the propagation of differences
    throughout internal computations to exploit some pattern or statistical bias in
    the output. Most of the attacks on symmetric cryptographic algorithms (block ciphers,
    hash functions, and so on) are some type of differential cryptanalysis.
  prefs: []
  type: TYPE_NORMAL
- en: The differences exploited might be taken between two input values or between
    more than two, as in higher-order cryptanalysis and its variants (integral cryptanalysis,
    cube attacks, and so on). A related technique, linear cryptanalysis, looks a bit
    different but is ultimately related to differential cryptanalysis. In addition,
    linear attacks often imply the possibility of pure differential attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Diffie–Hellman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lots of people working in cryptography have no deep concern with real application
    issues. They are trying to discover things clever enough to write papers about.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Whitfield Diffie
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A fairly simple mathematical trick that is behind most key agreement protocols,
    and that indirectly powers many more cryptosystems.
  prefs: []
  type: TYPE_NORMAL
- en: You'll often find security proofs relying on the hardness of the Diffie–Hellman
    problem (given *g*^(*a*) and *g*^(*b*), find *g*^(*ab*)) or variants thereof.
  prefs: []
  type: TYPE_NORMAL
- en: The *decisional* Diffie–Hellman problem (DDH) was called a “gold mine” by cryptographer
    Dan Boneh, and was leveraged to build encryption schemes (such as the Cramer–Shoup
    construction) as well as complex protocols such as threshold signature schemes.
  prefs: []
  type: TYPE_NORMAL
- en: See [*New Directions in Cryptography*](#New-Directions-in-Cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: Disclosure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More effective when the vulnerability is named with a clever acronym and accompanied
    by a nifty website, including a Q&A and a logo. Researchers first took this approach
    to tell the world about Heartbleed; then they used it to describe subsequent attacks
    on SSL/TLS. This allowed them to better communicate the new vulnerability (and
    spend less time responding to emails from journalists). Notable examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: BREACH  Browser Reconnaissance and Exfiltration via Adaptive Compression of
    Hypertext
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CRIME  Compression Ratio Info-leak Made Easy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DROWN  Decrypting RSA with Obsolete and Weakened eNcryption
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: POODLE  Padding Oracle On Downgraded Legacy Encryption
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ROBOT  Return Of Bleichenbacher’s Oracle Threat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discrete logarithm problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem of finding *d* in *y* = *x*^(*d*) mod *p* for a prime *p*, or in
    *dG* = *P* in elliptic-curve groups of points. The discrete logarithm problem
    is now the most important computational problem in cryptography, before factoring,
    because Diffie–Hellman–like protocols have become more common than RSA and Paillier
    cryptosystems.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An algorithm used in attacks against a scheme’s indistinguishability. For example,
    if you find a statistical bias in the output of a pseudo­random generator, that
    bias would serve as a distinguisher, thereby breaking the PRNG.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Indistinguishability*](#Indistinguishability).
  prefs: []
  type: TYPE_NORMAL
- en: Distributed randomness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Randomness generated by a group of parties that don’t necessarily trust each
    other; therefore, they don’t want any party to be capable of influencing the outcome.
    In this context, a simple protocol such as performing an XOR of each participant’s
    random contribution isn’t secure. The reason is that the last contributor can
    set their value to one that, when XORed with the combination of all previous values,
    produces the result they want to be returned. Publishing commitments in advance
    partially addresses the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Dolev–Yao model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first formal model for defining cryptographic protocols. Also a symbolic
    framework for describing and analyzing their security. Cryptographers sometimes
    refer to the Dolev–Yao model when they mean the *active attacker adversarial model*—that
    is, the model wherein the attacker can eavesdrop, intercept, and modify data transmitted.
    But the Dolev–Yao model is more than that: it’s a general symbolic framework to
    describe and analyze protocols’ security.'
  prefs: []
  type: TYPE_NORMAL
- en: Double ratchet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subprotocol of the Signal messaging protocol. It determines each ­message’s
    unique keys in such a way that an attacker who knows the message keys at a given
    time can determine neither past nor future message keys, thereby providing forward
    secrecy and some form of backward secrecy.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Signal protocol*](#Signal-protocol).
  prefs: []
  type: TYPE_NORMAL
- en: Dragonfly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PAKE defined for the authentication standard EAP-pwd used in the Wi-Fi security
    suite WPA3\. Attackers can bypass implementations of Dragonfly by exploiting the
    timing side channels in the hash-to-curve operations.
  prefs: []
  type: TYPE_NORMAL
- en: See [*PAKE (password-authenticated key agreement)*.](#PAKE-password-authenticated-key-exchange)
  prefs: []
  type: TYPE_NORMAL
- en: DRBG (deterministic random bit generator)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An oxymoronic-sounding term referring to a component that deterministically
    generates a long string of random-looking bits when given some actually random
    value (called a *seed*, a *key*, or sometimes just *entropy*). An operating system’s
    random generator usually includes an entropy extraction mechanism that generates
    some unpredictable bits from some analog source and pushes these bits to an entropy
    pool from which a DRBG takes its seed.
  prefs: []
  type: TYPE_NORMAL
- en: A DRBG is different from a PRNG; the terms PRBG and DRNG are rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Pseudorandom generator (PRNG)*](#Pseudorandom-number-generator-PRNG).
  prefs: []
  type: TYPE_NORMAL
- en: DSA (Digital Signature Algorithm)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The public-key signature scheme designed and patented by the NSA. It was standardized
    as part of the DSS (Digital Signature Standard) in 1991\. This choice drew some
    criticism to which NIST responded as follows in the magazine *Federal Computer
    Week*:'
  prefs: []
  type: TYPE_NORMAL
- en: NIST made the final choice. We obtained technical assistance from NSA, and we
    received technical inputs from others as well, but [NIST] made the final choice.
  prefs: []
  type: TYPE_NORMAL
- en: At the time, the criticisms of DSA were about its efficiency, incompleteness
    (it didn’t specify a hash function), risk of patent infringement, and security.
  prefs: []
  type: TYPE_NORMAL
- en: See [*DSS (Digital Signature Standard)*](#DSS-Digital-Signature-Standard).
  prefs: []
  type: TYPE_NORMAL
- en: DSS (Digital Signature Standard)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name of the NIST standard about digital signatures; not a single algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In 1982, NIST (then called the NBS) published a “Solicitation for Public Key
    Cryptographic Algorithms.” NIST later did the same for block ciphers and hash
    functions, resulting in the AES and SHA-3 standards. In 1987, NIST cancelled the
    DSS project upon request from the NSA. The standardization effort later resumed,
    leading to several standards established in 1991, including the NSA-designed DSA.
  prefs: []
  type: TYPE_NORMAL
- en: DSS is also the abbreviation of the sodium trimethylsilylpropane­sulfonate chemical
    compound, which is somehow related to cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: DVB-CSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Common Scrambling Algorithm: an algorithm standardized by the Digital Video
    Broadcasting consortium to protect video content in pay-TV systems, typically
    by encrypting MPEG transport stream packets.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Control word*](#Control-word).
  prefs: []
  type: TYPE_NORMAL
- en: E
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream cipher used in Bluetooth. Broken in theory but not in practice. The
    more recent Bluetooth Low Energy standard uses AES-CCM instead.
  prefs: []
  type: TYPE_NORMAL
- en: ECB (electronic codebook)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most obvious way to use a block cipher, where each block is processed independently
    of the others. ECB is the most robust mode against repeated IVs and nonces. But
    everybody knows ECB is insecure because you can see the penguin.
  prefs: []
  type: TYPE_NORMAL
- en: ECC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An acronym for either elliptic-curve cryptography or error-correcting code,
    depending on the context; confusion between the two can lead to unfortunate situations.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Elliptic-curve cryptography*](#Elliptic-curve-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: ECDLP (Elliptic-curve discrete logarithm problem)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arguably the most important computational problem as far as cryptographic security
    is concerned: given the points *P* and *xP*, find the number *x*, where multiplication
    happens in the group of an elliptic curve over a finite field.'
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic-curve schemes have replaced many instances of RSA or classical Diffie–Hellman,
    for example, in the TLS 1.3 standard.
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA (Elliptic-curve DSA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elliptic-curve counterpart of DSA, whose security requires the hardness
    of ECDLP, but is not totally equivalent to it. As far as we know, ECDLP’s hardness
    only implies ECDSA’s security (unforgeability) in the generic group model, which
    is an abstraction of ECDSA but not exactly ECDSA.
  prefs: []
  type: TYPE_NORMAL
- en: See [*DSA (Digital Signature Algorithm)*](#DSA-Digital-Signature-Algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: ECIES (Elliptic-curve IES)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elliptic-curve version of the IES public-key encryption scheme. Like IES,
    ECIES is a hybrid encryption scheme, therefore it needs a symmetric cipher to
    actually encrypt messages.
  prefs: []
  type: TYPE_NORMAL
- en: See [*IES (Integrated Encryption Scheme)*](#IES-Integrated-Encryption-Scheme).
  prefs: []
  type: TYPE_NORMAL
- en: Ed25519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EdDSA signatures using Curve25519’s Edwards representation rather than the Montgomery
    format used by X25519, which causes developers a lot of headaches.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Curve25519*](#Curve25519), [*EdDSA*](#EdDSA).
  prefs: []
  type: TYPE_NORMAL
- en: EdDSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A deterministic elliptic-curve signature scheme based on Schnorr’s scheme. The
    main alternative to the ECDSA standard. In its purest form, it’s resilient to
    non-collision-resistant hash functions and is famously used by Ed25519.
  prefs: []
  type: TYPE_NORMAL
- en: EKMS (Electronic Key Management System)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A legacy key management system designed by NSA to secure communications for
    the US Army and other organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Electronic codebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cipher, in archaic NSA parlance. For example: “Electronic codebooks, such
    as the Advanced Encryption Standard, are both widely used and difficult to attack
    cryptanalytically.”'
  prefs: []
  type: TYPE_NORMAL
- en: ElGamal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For many years, the only public-key encryption scheme used and taught in crypto
    classes other than RSA. Introduced in the 1985 article “A Public Key Cryptosystem
    and a Signature Scheme Based on Discrete Logarithms,” which modestly started with
    the following abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: A new signature scheme is proposed together with an implementation of the Diffie–Hellman
    key distribution scheme that achieves a public key cryptosystem. The security
    of both systems relies on the difficulty of computing discrete logarithms over
    finite fields.
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA eventually overshadowed the signature scheme, and currently, ElGamal encryption
    is rarely used. Instead, cryptographers use ECIES except in applications in which
    the message must be directly public-key-encrypted (as in some e-voting systems).
  prefs: []
  type: TYPE_NORMAL
- en: 'The in-the-exponent variant of ElGamal encryption has two interesting properties:
    it is additively homomorphic, and decryption is impossible (unless you solve a
    discrete logarithm problem). Despite the latter suboptimal property, this version
    proved useful in threshold signature schemes.'
  prefs: []
  type: TYPE_NORMAL
- en: Elligator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method of encoding elliptic-curve points as random-looking strings to make
    public keys indistinguishable from encrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic curve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not an ellipsis, not a curved line. A set of points on the plane whose (*x*,
    *y*) coordinates satisfy the curve’s equation, which usually has the form *y*²
    = *x*³ + *ax* + *b*, where *a* and *b* are fixed parameters. Crypto­graphic applications
    only work with points whose coordinates belong to some finite field; therefore,
    the curve has a finite set of points.
  prefs: []
  type: TYPE_NORMAL
- en: Elliptic-curve cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Public-key cryptography relying on elliptic curves and related hardness problems
    (the discrete logarithm, or a variant thereof). Elliptic-curve cryptography can
    do almost everything that legacy public-key cryptography can do, in a way that
    is often faster and uses shorter keys. That includes encryption, key agreement,
    and signature. In addition, you can use it for more exotic cryptographic schemes
    due to its support of pairings.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Pairing-based cryptography*](#Pairing-based-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: Encipherment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A synonym of encryption with emphasis on the act and operations carried out
    during the encryption process. *To encipher*, like the French verb *chiffrer*,
    comes from the Arabic رفص (*sifr*, the digit zero), whereas *to encrypt*, like
    the verb *crypter*, comes from the Greek *kryptos* (concealed, secret).
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end encryption (E2EE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encryption is said to be end-to-end when only the dedicated recipient(s) can
    decrypt the messages. It sounds straightforward but is actually an arduous engineering
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: As usual in cryptography, the hard part of such a system is key management and
    distribution, not the actual encryption, which is why many E2EE systems need a
    central server. Many E2EE systems also rely on trust-but-verify mechanisms and
    are only end-to-end as long as participants perform some manual verification,
    such as checking a conversation’s fingerprint.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, E2EE systems sometimes ultimately rely on a central CA to enable
    trusted TLS connections (which you can think of as simply end-to-end encryption
    over the transport layer rather than the application layer).
  prefs: []
  type: TYPE_NORMAL
- en: Enigma
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The electromechanical encryption machine used by the Nazis during World War
    II. The Enigma was analyzed by Polish and British cryptanalysts, including Alan
    Turing, using techniques that researchers would later rediscover and call differential
    cryptanalysis, related-key attacks, and side-channel attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Entropy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A notion introduced around 1865 by Rudolf Clausius, arguably the founder of
    modern thermodynamics. But entropy wasn’t named until three years after his first
    formalization of the second law of thermodynamics (which states that entropy,
    at a microscopic level, cannot decrease in a closed system). Claude Shannon’s
    concept of information entropy came much later in his famous 1948 paper. Cryptography
    uses information entropy to assess a cryptosystem’s security by quantifying its
    amount of uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: ePrint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Officially the Cryptology ePrint Archive, at [https://eprint.iacr.org/](https://eprint.iacr.org/).
    A website where cryptography researchers can post their papers online prior to
    formal, double-blind, peer-reviewed publication and be sure they’ll be noticed.
    Most cryptography researchers check the new papers published on ePrint at least
    once a week.
  prefs: []
  type: TYPE_NORMAL
- en: Erathosthenes’ sieve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method of enumerating all prime numbers up to some upper bound; a 2,000-year-old
    algorithm typically taught in high school. It was rediscovered during the Black
    Hat 2019 conference.
  prefs: []
  type: TYPE_NORMAL
- en: eSTREAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cryptography competition, officially a *project*, organized by the EU-funded
    ECRYPT project between 2004 and 2008\. Of the 34 submitted ciphers, eight made
    it to the final portfolio, which included two categories: software (those with
    128-bit keys) and hardware (those with 80-bit keys). By far the most successful
    design from eSTREAM is Salsa20, a cipher that later evolved to ChaCha20, which
    became central to the BLAKE family of hash functions. Of the other portfolio ciphers,
    Trivium and Grain (or variants thereof) are used in niche applications, and F-FCSR
    was broken.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Grain*](#Grain), [*Salsa20*](#Salsa20), [*Trivium*](#Trivium).
  prefs: []
  type: TYPE_NORMAL
- en: Ethereum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An important blockchain platform for decentralized applications, such as tokens.
    Ethereum has led to some of the most interesting cryptography research and open
    problems, based on novel challenges faced by their unique decentralized deployment,
    adversarial model, and Turing-complete functionality. For example, consider the
    following, all of which are admittedly more exciting than yet another new block
    cipher: proof-of-stake security, smart contract formal verification, atomic swaps,
    and sharding.'
  prefs: []
  type: TYPE_NORMAL
- en: Eurocrypt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Europe’s largest academic cryptography conference, held every spring in a different
    European location since 1987\. Researchers present peer-reviewed research papers
    with titles such as “Indistinguishability Obfuscation Without Multilinear Maps:
    New Methods for Bootstrapping and Instantiation” and “A Quantum-Proof Non-Malleable
    Extractor with Application to Privacy Amplification Against Active Quantum Adversaries.”'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Asiacrypt*](#ASIACRYPT), [*CHES*](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems),
    [*CRYPTO*](#CRYPTO), [*FSE*](#FSE-Fast-Software-Encryption), [*PKC*](#PKC), [*Real
    World Crypto*](#Real-World-Crypto-RWC), [*TCC*](#TCC).
  prefs: []
  type: TYPE_NORMAL
- en: Eve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alice and Bob’s nemesis.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Alice*](#Alice), [*Bob*](#Bob).
  prefs: []
  type: TYPE_NORMAL
- en: E-voting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A topic that cryptographers like to publish papers about but don’t like to see
    deployed in reality because it’s perceived as unacceptably risky. E-voting is
    nonetheless cryptographically fascinating. It involves nontrivial cryptography,
    such as homomorphic encryption schemes used to encrypt ballots and aggregate them
    in a privacy-preserving way, and noninteractive zero-knowledge proofs, which are
    used to prove a vote’s correctness.
  prefs: []
  type: TYPE_NORMAL
- en: F
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Factoring problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given *n* = *pq*, find the primes *p* and *q*. Easy to solve if you have a large
    enough quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback shift register
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array of values, usually bits or bytes, that updates by shifting the values
    over and then filling the empty slot with the result of some function of the previous
    state’s values. Historically, this cipher mechanism came after electromechanical
    machines and preceded modern ciphers. It’s still used in some hardware-oriented
    algorithms and in the mobile communication standard SNOW 3G.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of feedback shift registers. In linear ones (LFSRs), this
    update function is linear, which renders the output predictable but can also provide
    guarantees that the period of LFSR is maximal. In nonlinear ones (NFSRs), after
    a few cycles of updates, the output values are highly nonlinear functions of the
    initial state, but guarantees on the period are difficult to compute. Concretely,
    linear update functions only do additions, whereas nonlinear ones do additions
    and multiplications.
  prefs: []
  type: TYPE_NORMAL
- en: A good design strategy is to combine LFSRs and NFSRs.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Grain*](#Grain), [*SNOW 3G*](#SNOW-3G), [*Trivium*](#Trivium).
  prefs: []
  type: TYPE_NORMAL
- en: Feistel network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method of constructing a block cipher from a smaller block cipher or hash
    function. It works by splitting the message block in two halves, *L* and *R*,and
    updating it by repeatedly replacing (*L*, *R*) with (*R*, *L* ⊕*f*(*R*)), where
    *f*() is the smaller function and can take a secret value as a parameter. Feistel
    network is sometimes called *Luby–Rackoff construction* after the researchers
    who formally analyzed its security. The XOR operation can be replaced by another
    group operation.
  prefs: []
  type: TYPE_NORMAL
- en: See [*DES (Data Encryption Standard)*](#DES-Data-Encryption-Standard), [*Lucifer*](#Lucifer).
  prefs: []
  type: TYPE_NORMAL
- en: Fialka (Фиалка)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Soviet counterpart to the Enigma machine created after World War II. Unlike
    Western encryption machines, Фиалка supported Cyrillic characters.
  prefs: []
  type: TYPE_NORMAL
- en: Fiat–Shamir
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A technique for turning an interactive proof (a protocol between a prover and
    a verifier that involves multiple rounds) into a noninteractive one (a single
    message from the prover) using hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: FIPS 140-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set of security requirements for cryptographic modules (software or hardware),
    established by NIST in 2001\. It’s been superseded by FIPS 140-3 since 2019.
  prefs: []
  type: TYPE_NORMAL
- en: FIPS 140-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New version of FIPS 140-2 since 2019\. It introduces requirements against noninvasive
    attacks and the concepts of *Normal Operation* and *Degraded Operation*, among
    others.
  prefs: []
  type: TYPE_NORMAL
- en: See [*FIPS 140-2*](#FIPS-140-2).
  prefs: []
  type: TYPE_NORMAL
- en: Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attack whose goal is not to recover some secret but to create a supposedly
    hard-to-generate value without the knowledge of some secret. Unforgeability is
    the corresponding security notion and is most commonly associated with signatures
    and MACs. More generally, unforgeability must apply to any scheme for which an
    attacker should have trouble creating a valid output. These include ciphertexts
    in authentication encryption and zero-knowledge proof protocol transcripts.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes forgeability is a desirable property (for example, to achieve deniability.
  prefs: []
  type: TYPE_NORMAL
- en: Formal verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A form of testing that relies on mathematical guarantees. Applied to security
    protocols, formal verification includes symbolic and computational verification
    techniques, which assess whether a protocol satisfies properties such as confidentiality
    and authentication. Another example is programming languages that can certify
    that an implementation is functionally correct with respect to a specification,
    or that it’s free of certain classes of side channels.
  prefs: []
  type: TYPE_NORMAL
- en: High-assurance applications often receive some sort of formal verification,
    such as the Common Criteria security evaluation framework’s EAL7 assurance level.
    Still, don’t be fooled into thinking formal verification means *proof that everything
    about a crypto implementation is secure*.
  prefs: []
  type: TYPE_NORMAL
- en: Format-preserving encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type of encryption that produces a ciphertext with the same format as the
    original message. For example, the format-preserving encryption of a 16-digit
    credit card number would produce another 16-digit number. Format-preserving encryption
    is often useful for encrypting database entries whose field type must have a specific
    format, such as social security numbers, IP addresses, and ZIP codes. Although
    the problem sounds simple, it requires sophisticated techniques, especially for
    the more general problem of creating ciphers from arbitrary domains of values.
  prefs: []
  type: TYPE_NORMAL
- en: Forward secrecy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The notion that something remains secure if something else is compromised at
    a later time. What counts as *something*, *something else*, and *a later time*
    depends on the context. Forward secrecy is usually a relevant security notion
    for key agreement protocols, secure messaging protocols (and their ratchetting
    mechanisms), pseudorandom generators, pseudorandom functions, MACs, and other
    stateful objects.
  prefs: []
  type: TYPE_NORMAL
- en: It’s usually easier to achieve forward secrecy than backward secrecy, because
    it’s easier to erase the past than to make the future unpredictable (in cryptography,
    at least).
  prefs: []
  type: TYPE_NORMAL
- en: See [*Backward secrecy*](#Backward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: FOX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*IDEA NXT*](#IDEA-NXT).
  prefs: []
  type: TYPE_NORMAL
- en: FSE (Fast Software Encryption)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A conference focused on the design and cryptanalysis of symmetric cryptography
    primitives, including slow and hardware-oriented hash functions. FSE is sometimes
    viewed as an applied cryptography conference, despite the fact that it rarely
    focuses on real-world algorithms, let alone real-world attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Researchers present peer-reviewed papers with titles such as “Improving the
    MILP-Based Security Evaluation Algorithm Against Differential/Linear Cryptanalysis
    Using a Divide-and-Conquer Approach” and “Low AND Depth and Efficient Inverses:
    A Guide on S-boxes for Low-Latency Masking.”'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Asiacrypt*](#ASIACRYPT), [*CHES*](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems),
    [*CRYPTO*](#CRYPTO), [*Eurocrypt*](#Eurocrypt), [*PKC*](#PKC), [*Real World Crypto*](#Real-World-Crypto-RWC),
    [*TCC*](#TCC).
  prefs: []
  type: TYPE_NORMAL
- en: Fully homomorphic encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Homomorphic encryption*](#Homomorphic-encryption).
  prefs: []
  type: TYPE_NORMAL
- en: Functional encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A type of cryptographic scheme that looks like magic: when designed for some
    function *f*(), decrypting Enc(*M*) yields not *M* but *f*(*M*). But like many
    of the magic cryptographic schemes, it’s of limited use in practice, because it
    can efficiently support only simple functionalities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build functional encryption schemes, cryptographers can use the trick of
    leveraging indistinguishability obfuscation: in other words, the decryption process
    that finds *f*(*M*) would consist of an obfuscated program that first retrieves
    *M* and then computes *f*(*M*) without ever exposing *M*.'
  prefs: []
  type: TYPE_NORMAL
- en: Future secrecy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A term coined in the context of the Signal protocol to refer to a notion similar
    to backward secrecy. Indistinguishable from break-in recovery.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Backward secrecy*](#Backward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy extractor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A scheme for extracting the value of some high-entropy secret from multiple
    noisy readings, each with different random errors, to derive a key. This might
    sound a lot like an error-correcting code, but it’s different: first, the value
    read is not a codeword (which has redundancy in it and thus is suboptimal entropy),
    but instead is a value of potentially maximal entropy; second, the value is not
    read once but multiple times; and third, the enrollment data used to decode the
    secret must not leak information about said secret. Therefore, you can store it
    without privacy leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: You might find fuzzy extractors used in biometric authentication applications,
    which have to extract a value that uniquely identifies an individual. These applications
    typically must extract this value from noisy measurements and without relying
    on a database of sensitive data, such as data about each individual. Conversely,
    in a traditional approach to authentication, you would compare a new measurement
    to a registered one to identify a person.
  prefs: []
  type: TYPE_NORMAL
- en: G
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generalized birthday problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem of finding values *X*[1], . . . , *X*[k] such that Hash(*X*[1])
    ⊕ · · · ⊕ Hash(*X*[k]) = 0\. The special case of a classical collision is that
    of finding two distinct values, such that Hash(*X*[1]) ⊕ Hash(*X*[2]) = 0\. The
    *birthday attack* finds such pairs in *O*(2^(*n*)^(/2)) queries to the hash function,
    where *n* is the output bit size.
  prefs: []
  type: TYPE_NORMAL
- en: In the generalized birthday problem, it’s easy to see that the larger the value
    *k*, the easier the problem. More precisely, the cost of a collision becomes O(*k2*^(n/(1+log[2])^(^(*k*))))
    time and space, or of the order of 2^(*n*)^(/3) for *k* = 4.
  prefs: []
  type: TYPE_NORMAL
- en: GNFS (General Number Field Sieve)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best (nonquantum) algorithm for factoring large integers.
  prefs: []
  type: TYPE_NORMAL
- en: GOST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The USSR national standard block cipher designed in the 1970s and included in
    the GOST 28147-89 standard series. Whereas the American DES cipher, designed in
    the same era, uses keys that are only 64 bits long, GOST works with 256-bit keys
    and comes with customizable S-boxes. Constructed as a Feistel network like DES,
    GOST hasn’t been meaningfully broken, although research papers have described
    some attacks against it that perform fewer than 2^(256) operations. Russian authorities
    officially deprecated GOST in 2019\. Its successor is the block cipher Кузнечик
    (Kuznyechik).
  prefs: []
  type: TYPE_NORMAL
- en: Grain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A family of minimalistic hardware-oriented stream ciphers: Grain (80-bit key),
    Grain 128, and Grain 128a (128-bit key).'
  prefs: []
  type: TYPE_NORMAL
- en: Gröbner basis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A canonical representation of a system of multivariate equations. Computing
    a Gröbner basis for a multivariate system is one of the possible definitions of
    “solving” it, because it can be used, for example, to find its numeric solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general problem of computing Gröbner bases is NP-hard. The actual time
    and memory required to compute one for a specific system of equations, as found
    in multivariate cryptography or in algebraic cryptanalysis, is usually large and
    hard to estimate: but when it’s not, it produces spectacular cryptanalyses.'
  prefs: []
  type: TYPE_NORMAL
- en: Group signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A signature scheme involving a group of potential signers. Any group member
    can issue a signature on behalf of the group, and a verifier can learn the identity
    of the group members but not of the actual signer. There’s an exception: groups
    must work with a trusted entity, called the *group manager*, which can trace signatures
    back to their original signer. Ring signatures don’t have this traceability property
    or the need for a group manager.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Ring signature*](#Ring-signature).
  prefs: []
  type: TYPE_NORMAL
- en: Grover’s algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A quantum algorithm that in theory can break symmetric ciphers in *O*(2^(*n*)^(/2))
    instead of *O*(2^(*n*)) complexity, where *n* is the key length.
  prefs: []
  type: TYPE_NORMAL
- en: H
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardcore predicate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A key concept in the theoretical definition of one-way functions and permutations:
    for some one-way function *f*(), a hardcore predicate is some bit of information
    about an input *x* that is easy to compute from *x* but hard from *f*(*x*). By
    definition, you should be able to find a hardcore predicate for any given one-way
    function and its permutations.'
  prefs: []
  type: TYPE_NORMAL
- en: Hash function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest cryptographic object, and at first glance, the dumbest operation
    ever. A hash function takes a single input of any type, format, or size, and returns
    a single output that is a fixed size and looks totally unrelated to its input.
    Yet equipped with such a trivial tool, you can construct secure symmetric ciphers,
    pseudorandom generators, key derivation functions, and even public-key signatures,
    as well as a variety of security protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Hash-based cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most secure but slowest form of post-quantum cryptography. You can use hash
    functions to create various cryptographic objects, such as stream ciphers or pseudorandom
    generators. But when you hear *hash-based cryptography*, it refers to public-key
    signatures built from only hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Simple hash-based signatures, as proposed by Lamport, Merkle, and Winternitz
    in the late 1970s, have severe shortcomings. For example, you can use them only
    a limited number of times or only on very short messages. Like many problems in
    computer science, researchers have addressed the problem of scaling hash-based
    signatures by throwing trees, trees, and even more trees at it. This has notably
    led to the SPHINCS and XMSS designs.
  prefs: []
  type: TYPE_NORMAL
- en: See [*SPHINCS*](#SPHINCS), [*XMSS*](#XMSS-eXtended-Merkle-Signature-Scheme).
  prefs: []
  type: TYPE_NORMAL
- en: Heartbleed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bug in OpenSSL that revived interest in the security of TLS and its implementation.
    Ultimately, Heartbleed led to a safer OpenSSL, as well as the TLS 1.3 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Hedged signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type of signature that reintroduces randomness as a defense against fault
    attacks. Fault attacks affect signature schemes, such as EdDSA and deterministic
    ECDSA, that don’t need a random or unique value to be secure. (By contrast, ECDSA
    requires a fresh secret random value per signature.) Such derandomized signature
    schemes protect against poor randomness but have been shown to be vulnerable to
    fault attacks that partially exploit their determinism. Hedged signatures aim
    to correct this without allowing lower-quality randomness to reduce the scheme’s
    security. Such hedged signatures include the XEdDSA variant, as well as the post-quantum
    schemes qTESLA and Picnic2.
  prefs: []
  type: TYPE_NORMAL
- en: HFE (Hidden Field Equations)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A family of multivariate public-key schemes, including encryption and signature
    schemes. As modestly stated in the 1996 paper that introduced it, “the security
    of HFE is not proved but *apparently* it seems to be related to the problem of
    solving a system of multivariate quadratic equations over a finite field.”
  prefs: []
  type: TYPE_NORMAL
- en: HMAC (Hash-based MAC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many developers, a synonym of *MAC*. Strictly speaking, however, an HMAC
    isn’t a MAC but a way to construct a MAC from a hash function.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can construct a MAC atop SHA-256, which is called *HMAC-SHA-256*.
    Keep in mind that HMACs are not the only—and not necessarily the best—ways of
    constructing MACs.
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphic encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An encryption that satisfies Dec(Enc(*M*[1]) ⦾Enc(*M*[2])) = *M*[1]⦿*M*[2]
    for some operators ⦾ and ⦿ that might be identical or distinct, and are usually
    some type of addition or multiplication. For example, encrypting a message with
    textbook RSA by doing *M*^(*d*) mod *n* for some message *M* is homomorphic with
    respect to multiplication: the ­product of two ­ciphertexts is the ciphertext
    of the product of the plaintexts.'
  prefs: []
  type: TYPE_NORMAL
- en: Homomorphism can be a security issue and a feature, depending on the context.
    For example, certain e-voting systems leverage the homomorphic property of Paillier’s
    cryptosystem to aggregate ballots without decrypting them individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fully homomorphic encryption is a more general and powerful property but is
    also harder to realize: a fully homomorphic encryption can be homomorphic with
    respect to any operation performed on the ciphertext instead of just a single
    group operation.'
  prefs: []
  type: TYPE_NORMAL
- en: HPC (Hasty Pudding Cipher)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A mostly forgotten block cipher submitted in 1998 to the AES competition. Its
    designer called it “the first Omni-Cipher: It can encrypt any blocksize with any
    keysize.”'
  prefs: []
  type: TYPE_NORMAL
- en: HSM (hardware security module)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hardware equipment dedicated to running cryptographic operations and other security
    tasks. HSMs can come in different form factors, such as rack servers or USB dongles.
    HSMs don’t necessarily run cryptographic operations using dedicated hardware (as
    in a dedicated silicon circuit). Actually, most of the time, they run all cryptography
    in software, executed by some general-purpose processor. The S in HSM refers to
    the functionality it implements; it doesn’t necessarily mean the HSM is more secure
    than a normal computer.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*QUIC (Quick UDP Internet Connections)*](#QUIC-Quick-UDP-Internet-Connections).
  prefs: []
  type: TYPE_NORMAL
- en: Hyperelliptic-curve cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like elliptic-curve cryptography but using a higher-dimensional object: the
    Jacobian of a hyperelliptic curve. We can’t explain what a Jacobian is in terms
    of anything else that is familiar to most readers, to paraphrase Richard Feynman.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of hyperelliptic curves is that, owing to the additional
    dimensions, the same finite field generates larger groups than it would with an
    elliptic curve. This strength is also a weakness: when the number of dimensions
    becomes too high (usually more than three), discrete logarithms become easier.'
  prefs: []
  type: TYPE_NORMAL
- en: I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IACR (International Association for Cryptologic Research)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptographers’ union, a nonprofit that organizes the largest academic cryptography
    conferences and manages the reference preprint platform ePrint.
  prefs: []
  type: TYPE_NORMAL
- en: IDEA (International Data Encryption Algorithm)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A 64-bit block cipher from the early 1990s. One of the rare block ciphers that
    uses the Lai–Massey construction, not a Feistel or substitution–permutation network.
  prefs: []
  type: TYPE_NORMAL
- en: Despite a rather heuristic design approach, IDEA resisted cryptanalysis for
    years. The first attack against it that proved potentially faster than brute force
    didn’t appear until 2012\. (This was a biclique attack with 2^(126) operations.)
  prefs: []
  type: TYPE_NORMAL
- en: IDEA is one of the few ciphers that uses integer multiplication operations,
    which has some security benefits but makes protecting against side-channel attacks
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: IDEA NXT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A block cipher with little similarity to IDEA except for their shared Lai–Massey
    construction. Also like IDEA, it was designed for the Mediacrypt AG company and
    patented. Initially named and published as FOX, IDEA NXT proved very useful in
    antipiracy initiatives, not only because of its cryptographic merits.
  prefs: []
  type: TYPE_NORMAL
- en: Identity-based encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A means of sending an encrypted message without knowing someone’s public key.
    For instance, when Alice wants to send an encrypted message to Bob but doesn’t
    know his public key, identity-based encryption (IBE) allows her to compute it
    using the name *Bob* and some master public key. The only caveat is that IBE requires
    a trusted third party, called the *key server*, which knows some master private
    key and uses it to generate users’ private keys. Bob therefore needs to authenticate
    to the key server, proving that he’s the real Bob, to receive his private key.
  prefs: []
  type: TYPE_NORMAL
- en: IES (Integrated Encryption Scheme)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public-key encryption scheme that doesn’t involve a public-key encryption
    primitive. Instead, the sender chooses a random key pair, computes a Diffie–Hellman
    shared secret between the fresh private key and the recipient’s public key, derives
    a symmetric key from it, and encrypts the message with some authenticated cipher.
    Neither party performs a public-key operation to encrypt the data.
  prefs: []
  type: TYPE_NORMAL
- en: Impatient saboteur
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Dolev–Yao model, an archetypal attacker who can transmit data but not
    receive it. Or in Dolev and Yao’s own words, “one who only initiates conversations
    (and does not rely on being spoken to.)”
  prefs: []
  type: TYPE_NORMAL
- en: Impossibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptographer Moti Yung once said, “When a software engineer says [a security
    engineering problem] is impossible, that really just means it’s cryptographically
    interesting.”
  prefs: []
  type: TYPE_NORMAL
- en: Impossible differential attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A differential attack that exploits abnormally unlikely events rather than abnormally
    likely ones. Differential cryptanalysis generally exploits patterns of unusually
    high probability that occur in the differences between outputs and inputs with
    a specific difference. Impossible differential attacks exploit the opposite type
    of pattern, namely those that have zero chance of being observed under certain
    conditions. If cryptanalysts notice these patterns, they can deduce that the condition
    doesn’t hold. This information could help recover a cipher’s secret key or subkey.
  prefs: []
  type: TYPE_NORMAL
- en: IND-CCA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indistinguishability of ciphertexts under chosen-ciphertext attacks. The strongest
    security notion for encryption schemes (both public-key and symmetric-key schemes).
    The chosen-ciphertext might intuitively make little sense in practice. The reason
    is that you’ll rarely find systems where attackers can decrypt any ciphertexts
    they want, but encryption that can do more can do less. In addition, there are
    cases in which you do have a decryption oracle, such as some DRM systems.
  prefs: []
  type: TYPE_NORMAL
- en: IND-CPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indistinguishability of ciphertexts under chosen-plaintext attacks. Also known
    as semantic security. It’s the idea that a ciphertext shouldn’t reveal anything
    about a plaintext other than its approximate length, even to an active attacker
    capable of retrieving the ciphertext corresponding to the plaintexts of their
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: IND-CPA is the standard security notion for symmetric encryption. For example,
    block ciphers in CTR or in CBC mode are secure if the underlying block cipher
    is secure, and if CTR nonces are unique or CBC initial values are unpredictable.
    That’s a lot of ifs, which in practice can lead to security flaws in otherwise
    IND-CPA schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Indelibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Property belonging to a transaction, or series thereof, that is timestamped
    implicitly or explicitly and cannot be backdated or otherwise altered. Cryptographic
    ledger mechanisms, such as blockchains, can often address this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Indifferentiability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Property of a construction, such as of a hash function, that is guaranteed
    to lead to a secure primitive if the building blocks have no security flaw. In
    the context of hash functions, we talk of *indifferentiability from a random oracle*,
    meaning that if the underlying compression function or permutation is ideal, the
    hash function has as many structural properties as a random oracle: that is, none.'
  prefs: []
  type: TYPE_NORMAL
- en: Indistinguishability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The property in which something that isn’t really random appears the same as
    something that is actually random. If the two are indistinguishable, you cannot
    extract information from the not-really-random thing. In the case of encryption,
    the not-really-random thing is the ciphertext, and the information you’re unable
    to extract is about the plaintext. Indistinguishability applies to other cryptographic
    functionalities as well.
  prefs: []
  type: TYPE_NORMAL
- en: Indistinguishability obfuscation (iO)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mathematization of the intuitive concept of software obfuscation. In cryptography,
    as in software security, the obfuscation process takes as input a program and
    produces a second program that in some sense hides how the first program works:
    its internal variables, secret arguments, and so on. Unlike in software security,
    cryptography sees a program as one of the possible abstract representations, most
    commonly a Boolean circuit with AND, OR, and NOT gates.'
  prefs: []
  type: TYPE_NORMAL
- en: iO can be seen as a raw encoding of the input–output relations that hides its
    implementation details, such as subprocedures or intermediate variables. The notion
    of indistinguishability is just a formal way to express the idea that, given obfuscations
    of two distinct yet equivalent programs, an attacker shouldn’t be able to identify
    which of the programs is which.
  prefs: []
  type: TYPE_NORMAL
- en: Although iO sounds like the solution to many problems, in practice it’s not
    because of its high complexity and inefficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Information-theoretic security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security that even infinite computational power cannot compromise. For example,
    imagine that you encrypt some 128-bit secret key *K*[0] with AES by using another
    secret key *K* as the AES key. Let’s assume that the attacker has no way to verify
    whether or not they got the valid *K*[0]. In this case, even if the attacker could
    try all possible values of *K*, they would have no way of identifying the correct
    value of *K*, because they’d have no way of identifying the *K*[0] that they’re
    after.
  prefs: []
  type: TYPE_NORMAL
- en: INT-CTXT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrity of ciphertexts. The security notion, applicable to authenticated encryption
    schemes, that it should be practically impossible for an attacker to create a
    valid ciphertext, even if they know many valid ciphertexts for messages of their
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related theorem: if an authenticated cipher is IND-CPA and INT-CTXT, it’s
    also IND-CCA. I leave it to you to Google the proof for this result.'
  prefs: []
  type: TYPE_NORMAL
- en: Invisible signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A public-key signature that cannot be identified as valid or invalid unless
    the signer has agreed to reveal that information. An invisible signature might
    appear to make the signature anonymous (that is, because the signature doesn’t
    reveal the signer’s identity or public key), but this isn’t necessarily the case.
    Consider this counterexample: if you additionally sign the signature with a noninvisible
    signature scheme, the scheme remains invisible but is clearly not anonymous.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Anonymous signature*](#Anonymous-signature), [*Undeniable signature*](#Undeniable-signature).
  prefs: []
  type: TYPE_NORMAL
- en: IOTA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By its own definition, a blockchain with no blocks and no chain. Probably the
    most mocked blockchain platform, because it has made some unfortunate cryptographic
    choices, such as designing a new hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptography enthusiasts and IOTA supporters have posted hundreds of inflammatory
    tweets about IOTA’s questionable design choices. Here is a very brief summary
    of the debate: the crypto enthusiasts yelled, “IOTA is broken because its signature
    scheme is broken.” In response, IOTA fans responded, “IOTA isn’t broken because
    it can’t be exploited.” There is some truth to both sides.'
  prefs: []
  type: TYPE_NORMAL
- en: IPES (Improved Proposed Encryption Standard)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative name for the IDEA block cipher.
  prefs: []
  type: TYPE_NORMAL
- en: See [*IDEA*](#IDEA-International-Data-Encryption-Algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: IPSec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the major open secure channel protocols along with TLS and SSH. Despite
    its widespread use, it remains much less known in the cryptography community and
    among engineers. Indeed, you don’t need to understand IPSec if you’re developing
    mobile or web applications. Also, its design and subprotocols look cryptographically
    boring. A product of DARPA- and NSA-sponsored efforts that began in the 1970s,
    IPSec nonetheless remains the standard for network layer security. In addition,
    its design and implementations have proven more robust than early SSL and TLS
    versions except for the weak IKEv1 subprotocol.
  prefs: []
  type: TYPE_NORMAL
- en: ISO standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buy this definition for $180\. Please note that a paper format is currently
    unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Isogeny-based cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The youngest class of post-quantum cryptography methods; initiated in the early
    2000s. An isogeny is a function that maps points of an elliptic curve to points
    of another elliptic curve and that satisfies specific mathematical properties.
    You can then draw a graph whose nodes are elliptic curves and whose edges are
    isogenies between them, and walk through this graph in a pseudorandom way. After
    throwing a lot of cool math at the study of these objects—graph theory, quaternion
    algebras, and so on—you end up with hard computational problems that you can use
    for crypto applications.
  prefs: []
  type: TYPE_NORMAL
- en: J
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Journal of Cryptology* (JoC)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography’s *Nature* minus the publication fees.
  prefs: []
  type: TYPE_NORMAL
- en: K
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KASUMI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variant of the 1995 block cipher MISTY1; used in 3G telecommunications standards
    as the A5/3 cipher. KASUMI is broken, because a practical key-recovery attack
    exists. KASUMI is also not broken, because said attack requires chosen-ciphertext
    queries in the related-key model, which isn’t realistic.
  prefs: []
  type: TYPE_NORMAL
- en: Keccak
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hash function family standardized as SHA-3; it is built from a single permutation
    according to the sponge function framework. Keccak’s permutation performs a clever
    combination of XORs and logical ANDs. It’s also optimized for efficiency and easily
    scales to different widths.
  prefs: []
  type: TYPE_NORMAL
- en: The original Keccak design and its sponge mode have led to several other algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Permutation-based cryptography*](#Permutation-based-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: KeeLoq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most expensive broken cipher ever. One of the rare block ciphers to rely
    on a feedback shift register.
  prefs: []
  type: TYPE_NORMAL
- en: KEM (key encapsulation mechanism)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public-key encryption scheme designed to encrypt and decrypt short, fixed-size
    chunks of data; commonly used to encapsulate a symmetric key. You can think of
    a KEM as a key agreement in which one party gets to choose the key; a KEM’s encryption
    function picks a random symmetric key and encrypts it, whereas the KEM’s decryption
    function decrypts it to recover the symmetric key. It can then continue to decrypt
    any data encrypted using that key with some symmetric primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ancestor of single sign-on systems, designed in the late 1980s to provide
    secure authentication and authorization to MIT’s distributed computing platform
    Athena. Admittedly an elder technology, Kerberos is one of the security protocols
    that relatively few people know despite its major impact and the fact that it’s
    still used in many places, such as in the Radius authentication protocol. Indeed,
    in spite of its old age, Kerberos remains a decently secure protocol. It implements
    often forgotten concepts, such as not trusting any party until they’re authenticated
    and not exposing passwords in clear. It has some limitations; for instance, Kerberos
    must rely on a trusted third party. But then again, how many security protocols
    ultimately don’t? Sometimes known as a protocol that uses only symmetric cryptography,
    Kerberos can also support public-key crypto, as well as various authentication
    forms, such as one-time passwords, hardware tokens, and biometrics.
  prefs: []
  type: TYPE_NORMAL
- en: Kerckhoffs’ principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The six principles, or *desiderata*, of security established by the 19th-century
    Dutch cryptographer Auguste Kerckhoffs in his article “La cryptographie militaire”(in
    French).
  prefs: []
  type: TYPE_NORMAL
- en: Key derivation function (KDF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function that hashes stuff to obtain a key. A simple hash function doesn’t
    always do the trick, because the *stuff* to be hashed typically includes a combination
    of secret and nonsecret values. A KDF’s interface helps process these values securely
    to avoid collisions between different sets of stuff. There is another reason hash
    functions aren’t sufficient: a KDF must often generate keys of arbitrary size,
    whereas most hash functions generate values of a fixed size.'
  prefs: []
  type: TYPE_NORMAL
- en: A special case arises whenever the key can’t be just any string of bits (as
    in the case of a symmetric key) but a public/private key pair. In those situations,
    rather than generating the key pair as part of the KDF, you would generally use
    a second algorithm to deterministically create a key pair from a seed.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, when the stuff’s secret is a password, passphrase, or other
    low-entropy value, you need a special kind of KDF, called a *password hash function*.
    These have some additional security requirements.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Password hash function*](#Password-hash-function).
  prefs: []
  type: TYPE_NORMAL
- en: Key escrow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of entrusting an organization or entity with the custody of secret
    keys and therefore the rights associated with them, for example, to decrypt communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As told by the European Council in a meeting in May 1998:'
  prefs: []
  type: TYPE_NORMAL
- en: The Council Resolution of 17 January 1995 recognised that lawfully authorised
    interception of communications is an important tool for the investigation of serious
    crime. The Council notes that law enforcement agencies may require lawful access
    to encryption keys, without the knowledge of the user of the cryptographic service,
    in order to maintain this capability. To this end, the Council recognises that
    one possible approach amongst others, which might meet law enforcement interests,
    might be the promotion of confidentiality services which involve the depositing
    of an encryption key or other information with a third party. Such services are
    often known as “key escrow” or “key recovery” services. Law enforcement agencies
    may also require lawful access to encryption keys where it is necessary to decrypt
    material which has been seized as part of a criminal investigation.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, key escrow sounds easy and a fair solution to real problems. But
    in practice, key escrow raises a lot of procedural, technological, and political
    problems, and its benefits might not be worth the additional cost and risks, depending
    on your metric.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Key management*](#Key-management).
  prefs: []
  type: TYPE_NORMAL
- en: Key management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The single hardest problem in cryptography. Key management won’t be solved by
    quantum computers or with an NP oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Key wrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To symmetric cryptography, what KEMs are to public-key cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Kleptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A term coined to refer to cryptography used in malware and other unholy applications,
    particularly when their aim is to steal information in a covert way; for example,
    via subliminal channels or obfuscation.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Cryptovirology*](#Cryptovirology).
  prefs: []
  type: TYPE_NORMAL
- en: Known-key attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An adversarial model that assumes the attacker already knows the secret key
    of some symmetric cipher. Therefore, the attack’s goal isn’t to recover a key
    but to identify structural properties that the attacker might exploit when the
    cipher is used in a hash function or some other construction where its key might
    not be secret.
  prefs: []
  type: TYPE_NORMAL
- en: Kupyna (Купина)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ukrainian national hash function standard; established in 2014 and named
    after the plant *Polygonatum multiflorum*. Kupyna is based on a fairly unusual
    compression function construction: given a message block *M* and an initial hash
    value *H*, the next hash value is computed as *H* ⊕ Perm[1](*M*) ⊕ Perm[2](*M*
    ⊕*H*), where Perm[1] and Perm[2] are permutations similar to AES with no key and
    a wider state.'
  prefs: []
  type: TYPE_NORMAL
- en: L
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laconic zero-knowledge proof
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interactive proof protocol where the prover sends very few bits to the verifier.
  prefs: []
  type: TYPE_NORMAL
- en: Lai–Massey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A secure way to build a block cipher, although much less common than the Feistel
    substitution-permutation networks. The Lai–Massey construction is notably used
    by IDEA and FOX.
  prefs: []
  type: TYPE_NORMAL
- en: Lamport signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first hash-based signature scheme, and in its original form, the simplest
    signature scheme ever: to sign a one-bit message, you’d first generate a private
    key composed of two random values *K*[0] and *K*[1]. Then you’d share the public
    key (Hash(*K*[0]), Hash(*K*[1])). To sign the message *0*, you’d attach *K*[0]
    as a signature, and you’d attach *K*[1] otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: This works, but it’s not very useful, because 1) a key pair can sign only one
    message, and 2) the key size is proportional to that of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Lattice-based cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most promising class of post-quantum cryptography schemes, as far as real
    applications are concerned. Lattice-based cryptography usually relies on some
    version of the learning with errors (LWE) problem and in particular its relation
    to lattice problems. It can provide encryption/KEM and signature schemes. It’s
    generally considered the most promising type of post-quantum scheme due to its
    combination of acceptable security assurance, performance, and diversity of constructions.
  prefs: []
  type: TYPE_NORMAL
- en: Lattice-based schemes represent 39 percent of round one submissions to NIST’s
    post-quantum competition, 46 percent of submissions selected in round two, and
    71 percent of the finalists.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Learning with errors (LWE)*](#Learning-with-errors-LWE).
  prefs: []
  type: TYPE_NORMAL
- en: Le Chiffre
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A character in an Ian Fleming spy book. Anyone whose name means *The Cipher*
    can only be a villain:'
  prefs: []
  type: TYPE_NORMAL
- en: Mostly expensive, but discreet. Large sexual appetites. Flagellant. Expert driver
    of fast cars. Adept with small arms and other forms of personal combat, including
    knives. Carries three Eversharp razor blades, in hatband, heel of left shoe, and
    cigarette case. Knowledge of accountancy and mathematics. Fine gambler.
  prefs: []
  type: TYPE_NORMAL
- en: Leakage-resilient cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attempt to model side-channel information leaks using abstract models of
    computation and memory leakage. Such models include the Bounded Retrieval Model,
    Continual Memory Leakage, Auxiliary Memory Leakage, and Only Computation Leaks,
    among others. Building secure schemes within these models has proved an interesting
    exercise, yet of questionable practical interest, because the models largely fail
    to capture the complex reality of side channels and physical attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Learning with errors (LWE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem of solving a system of linear equations when the equations have
    errors in them. LWE generalizes the *learning parity with noise* (*LPN*) problem
    so it has arbitrary dimensions and numbers greater than 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Lattice-based cryptography schemes often rely on the hardness of some LWE problem.
    The reason is that, on average, LWE is as hard as the hardest instances of a lattice
    problem, such as GapSVP. The resulting cryptographic constructions should be,
    in turn, at least as hard to break as LWE.
  prefs: []
  type: TYPE_NORMAL
- en: Length extension attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The property of certain hash functions that given Hash(*X*), and without knowing
    *X*, it’s trivial to find the value of Hash(*X* ||pad|| *Y*) for any *Y*, where
    pad is padding bits followed by the encoding of *X*’s length. Hash functions vulnerable
    to length extension include all those built with the Merkle–Damgård construction,
    such as SHA-256 and RIPEMD-160\. More recent hash functions, such as SHA-3 or
    BLAKE3, aren’t vulnerable to length extension.
  prefs: []
  type: TYPE_NORMAL
- en: Length-preserving encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encryption that creates ciphertexts of exactly the same bit size as their corresponding
    plaintext; for example, encrypting any 16-byte plaintext into a 16-byte ciphertext,
    any 1-byte plaintext into a 1-byte ciphertext, any 2-bit plaintext into a 2-bit
    ciphertext, and so on. In applications where the payload length is fixed, length-preserving
    encryption is necessary to encrypt payload data.
  prefs: []
  type: TYPE_NORMAL
- en: Length-preserving encryption shouldn’t be confused with *format-preserving encryption*.
  prefs: []
  type: TYPE_NORMAL
- en: LFSR (linear feedback shift register)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Feedback shift register*](#Feedback-shift-register).
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography optimized for IoT devices and other platforms that have memory
    and logic constraints. But these constrained platforms usually have unique limitations
    and therefore require unique designs. Consequently, academic research about lightweight
    cryptography has been of disappointing practical relevance, sometimes because
    embedded platforms often include an AES logic.
  prefs: []
  type: TYPE_NORMAL
- en: Linear cryptanalysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cryptanalysis technique for symmetric ciphers that exploits patterns described
    in terms of linear equations, or equations consisting only of XORs between bits.
  prefs: []
  type: TYPE_NORMAL
- en: Linear cryptanalysis might look totally different from differential cryptanalysis,
    but it’s actually closely related to it. The most successful linear attack is
    arguably the one on DES.
  prefs: []
  type: TYPE_NORMAL
- en: Linkability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property of a signature scheme that allows an attacker to determine whether
    two signatures were issued by the same signer. Of course, standard signatures,
    such as ECDSA signatures, are linkable by design, which is fine. But nonlinkability
    is a requirement for ring signatures.
  prefs: []
  type: TYPE_NORMAL
- en: LM hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Short for LAN Manager hash, the function that hashes users’ passwords in earlier
    Microsoft Windows versions. LM hash is the predecessor of NT hash, which is a
    stronger hash.
  prefs: []
  type: TYPE_NORMAL
- en: See [*NT hash*](#NT-hash).
  prefs: []
  type: TYPE_NORMAL
- en: Luby–Rackoff
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Feistel network*](#Feistel-network).
  prefs: []
  type: TYPE_NORMAL
- en: Lucifer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The block cipher designed by Horst Feistel at IBM that led to the DES standard.
    It wasn’t originally a Feistel network, but a substitution-permutation network
    like AES, with blocks of 32, 48, or 128 bits. Lucifer was initially implemented
    in APL (A Programming Language) and codenamed *Demonstration*. But the APL workspace
    restricted projects’ name length, so *Demonstration* became *Demon* and later
    *Lucifer*.
  prefs: []
  type: TYPE_NORMAL
- en: M
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MAC (message authentication code)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not a signature, but very close: like a public-key signature a MAC should be
    unforgeable without the key, but unlike a public-key signature a MAC doesn’t provide
    nonrepudiation.'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, a MAC can be unforgeable yet leak information about the message,
    but in practice most MACs don’t.
  prefs: []
  type: TYPE_NORMAL
- en: MAGENTA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An unfortunate candidate at the AES competition, broken literally minutes after
    it was presented at the first AES conference. A conference participant commented:
    “It got so bad that a few of the participants started doing real-time cryptanalysis
    and suggesting attacks that would break the algorithm right there and then. I
    marvelled that the German guy managed to keep his composure. The whole spectacle
    was rather shameful.”'
  prefs: []
  type: TYPE_NORMAL
- en: Malleability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An underappreciated security notion: an encryption scheme is nonmalleable if
    an attacker cannot turn a ciphertext Enc(*K*, *M*) into another valid ciphertext
    Enc(*K*, *f*(*M*)) for some specified function *f*(). A nonmalleable scheme is
    therefore more secure than a malleable one. In the chosen-ciphertext model, nonmalleability
    is equivalent to indistinguishability (the strongest security notion).'
  prefs: []
  type: TYPE_NORMAL
- en: Manger attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A padding oracle attack on RSA encryption in OAEP mode. The Manger attack is
    less well known than the Bleichenbacher attack on older RSA encryption, because
    it’s generally harder to exploit. Indeed, as Manger’s original paper noted, the
    PKCS standard already described a partial mitigation against his attack when saying
    that “it is important that the error messages output in steps 4 [integer-to-octets
    conversion] and 5 [OAEP decoding] be the same.” But as with Bleichenbacher’s attack,
    Manger’s attack also works if the attacker exploits timing leaks instead of error
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Man-in-the-middle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class of attacks where the attacker surreptitiously captures and modifies
    traffic from two or more correspondents. The FREAK (Factoring RSA Export Keys)
    attack on TLS implementations is an example of a man-in-the-middle attack in which
    the attacker modifies session initiation data to force the use of a weak cipher
    suite.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Meet-in-the-middle*](#Meet-in-the-middle).
  prefs: []
  type: TYPE_NORMAL
- en: MASH (Modular Arithmetic Secure Hash)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An early attempt at a hash function relying on the same operations as RSA.
  prefs: []
  type: TYPE_NORMAL
- en: See [*VSH (Very Smooth Hash)*](#VSH-Very-Smooth-Hash).
  prefs: []
  type: TYPE_NORMAL
- en: McEliece encryption scheme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Code-based cryptography*](#Code-based-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: MD4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hash function even weaker than MD5.
  prefs: []
  type: TYPE_NORMAL
- en: MD5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously a synonym of *checksum* and *hash function*, now a sign of poor cryptography
    design because it isn’t collision resistant. But MD5 is still secure against preimage
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: MDC (Message Digest Cipher)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Old-fashioned name for hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: MDC-2 (Modification Detection Code 2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A construction that turns an *n*-bit block cipher into a hash function with
    2*n*-bit output. The resulting hash is less secure than an ideal 2*n*-bit hash
    but more secure than an *n*-bit hash. MDC-2 was mainly used with DES as *MDC-2DES*
    except when IBM’s patent was a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Meet-in-the-middle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A folklore cryptanalysis technique mainly known for its application in attacking
    symmetric primitives. A meet-in-the-middle is applicable when consecutive encryption
    layers (also called *rounds* or *cipher instances*) work with independent keys.
    For example, when encrypting a message *M* as *C* = Enc²(*K*[2], Enc¹(*K*[1],
    *M*)) with two *n*-bit keys *K*[1] and *K*[2] and two distinct ciphers Enc¹ and
    Enc², you might expect a security of 2*n* bits (as if it were equivalent to encrypting
    with a 2*n*-bit key). But the actual security is closer to *n* bits: the reason
    is that, given a pair (*C*, *M*) you can compute *X* = Dec²(*K*, *C*) for all
    the 2^(*n*) values of *K*, and then compute *Y* = Enc¹(*K''*, *M*) for all 2^(*n*)
    values of *K''*. The pair (*K''*, *K*) for which *X* = *Y* is then likely to be
    (*K*[1], *K*[2]).'
  prefs: []
  type: TYPE_NORMAL
- en: You can view this trick as one instance of a more general optimization technique
    found in many cryptanalytic attacks. Those attacks include the baby-step giant-step
    algorithm (to compute discrete logarithms), the GHS isogeny-based attack on ECDLP,
    or attacks on isogeny-based schemes.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Man-in-the-middle*](#Man-in-the-middle).
  prefs: []
  type: TYPE_NORMAL
- en: Merkle puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The closest thing to public-key cryptography before (secure) public-key cryptography
    was invented.
  prefs: []
  type: TYPE_NORMAL
- en: Merkle tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A solution to many problems in cryptography and computing. Essentially, a hash
    tree. It can, for example, be used to demonstrate the knowledge of some large
    set of data in a compact and efficient way: you can prove that a piece of data
    is in the tree by showing the list of nodes required to compute the root node
    from the said data’s node (usually a leaf). This list of values has been called
    the *authentication path*, *inclusion proof*, and *Merkle proof*.'
  prefs: []
  type: TYPE_NORMAL
- en: Merkle trees are the main components of hash-based signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Merkle–Damgård construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A straightforward technique for hashing messages of any length when using a
    hash function that hashes only short messages. It does this in such a way that,
    if the short-length hash is secure, the resulting hash of any length is secure
    as well. This is one of the earliest security proofs in symmetric cryptography.
    But this proof is only about collision resistance and preimage resistance, not
    about security in the most absolute sense. For example, Merkle–Damgård hash functions,
    such as SHA-256, are vulnerable to length extension attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Mersenne twister
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not a cryptographic pseudorandom generator.
  prefs: []
  type: TYPE_NORMAL
- en: Message franking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol to allow the reporting of abusive messages in an end-to-end encryption
    conversation while maintaining an acceptable level of security. Motivated by Facebook’s
    problem of deploying end-to-end encryption in Messenger, yet with the possibility
    of users to report messages to Facebook in a way that their sender can’t cryptographically
    deny their sending. Therefore, it requires quite the opposite of plausible deniability.
  prefs: []
  type: TYPE_NORMAL
- en: Miller–Rabin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common probabilistic primality test. Under certain conditions, you
    can fool the test into declaring that a composite number is prime.
  prefs: []
  type: TYPE_NORMAL
- en: See [*PRIMES*](#PRIMES).
  prefs: []
  type: TYPE_NORMAL
- en: MINERVA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Crypto AG*](#Crypto-AG).
  prefs: []
  type: TYPE_NORMAL
- en: Mining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hashing for money.
  prefs: []
  type: TYPE_NORMAL
- en: Misuse resistance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defense-in-depth applied to cryptography. Misuse resistance counters the fact
    that some ciphers, such as AES-GCM, are secure only if you never call them twice
    with the same nonce. (A nonce is the auxiliary input that ensures that you’ll
    get a different ciphertext if you encrypt the same plaintext twice with the same
    key.) Misuse-resistant ciphers attempt to eliminate this problem. Their only limitation
    is that if you encrypt the same message with the same key and nonce twice, the
    output will be the same. (As an exercise, find why this limitation can’t be avoided.)
    The only security flaw is that an attacker will learn when you’ve encrypted the
    same message twice. SIV-AES is an example of such a cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Misuse resistance can extend to cases other than symmetric encryption. It also
    applies to APIs to prevent disasters when the caller forgets to read the documentation
    (if it exists).
  prefs: []
  type: TYPE_NORMAL
- en: Mixnet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A multi-party protocol that provides anonymity by shuffling a sequence of ciphertexts
    *C*[1], *. . .* , *C*[n]into another sequence *C'*[1], *. . .* , *C'*[n], so that
    for each *C*[i]there exists a *C'*[j]whose value is distinct but decrypts to the
    same plaintext. The protocol might also include a zero-knowledge proof that shows
    that the criterion is satisfied without leaking any information about the permutation
    or plaintexts.
  prefs: []
  type: TYPE_NORMAL
- en: MQV (Menezes–Qu–Vanstone)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Diffie–Hellman on steroids. Invented in 1995, yet rarely used, in part because
    of patents covering it. It’s the sister of HMQV and ECMQV (once in NSA’s Suite
    B). Today, MQV is perhaps best known for its use in the password-based key agreement
    protocol OPAQUE.
  prefs: []
  type: TYPE_NORMAL
- en: Multicollision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For hash functions, a collision between more than two messages. It takes less
    time to find multicollisions on iterated hash functions (such as SHA-256) than
    for a hash function accessed as a black box. If intermediate chaining values of
    the iterated hash are *n*-bit, then a *k*-collision can be found in ⌈log[2]*k*⌉
    · 2^(*n*)^(/2) against *k*!^(1/)^(*k*)· 2^(*n*)^(^(*k*) ^(– 1))^(*k*)for an ideal,
    black-box hash.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-party computation (MPC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class of cryptographic techniques for computing a function’s output without
    knowing the inputs’ original values. MPC is a rich field of research, yet with
    few major application until cryptocurrency wallets, which also use the MPC-like
    threshold signatures. Many more real-world MPC applications are expected.
  prefs: []
  type: TYPE_NORMAL
- en: Multivariate cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class of post-quantum schemes based on the hardness of solving systems of
    nonlinear equations in multiple variables. The hardness of such problems is related
    to that of Multivariate Quadratics (MQ), the problem of solving a random system
    of degree-2 equations, known to be NP-complete.
  prefs: []
  type: TYPE_NORMAL
- en: Most multivariate schemes are signature schemes that produce short signatures
    (good) but require long public keys (not so good).
  prefs: []
  type: TYPE_NORMAL
- en: N
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NBS (National Bureau of Standards)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previous name for NIST.
  prefs: []
  type: TYPE_NORMAL
- en: See [*NIST (National Institute of Standards and Technology)*](#NIST-National-Institute-of-Standards-and-Technology).
  prefs: []
  type: TYPE_NORMAL
- en: NESSIE (New European Schemes for Signatures, Integrity, and Encryption)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A project that ran from 2000 to 2003 and was headed by seven European institutions.
    It selected 17 recommended algorithms among 42 submissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'NESSIE’s selected algorithms didn’t become formal standards, only informal
    recommendations, which in hindsight drew little interest: does anyone remember
    ACE Encrypt, SHACAL-2, or SFLASH?'
  prefs: []
  type: TYPE_NORMAL
- en: “New Directions in Cryptography”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Invited research paper published in IEEE Transactions on Information Theory
    in November 1976, by Whitfield Diffie and Martin Hellman. Today, the Diffie–Hellman
    operation is used in almost every software or hardware system that performs cryptographic
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: NFSR (nonlinear feedback shift register)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Feedback shift register*](#Feedback-shift-register).
  prefs: []
  type: TYPE_NORMAL
- en: NIST (National Institute of Standards and Technology)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The agency responsible for US Federal standards in various technical fields,
    including cryptography. NIST cryptography standards and recommendations have included
    algorithms (such as DSS, AES, SHA-2, SHA-3, and so on), block cipher operation
    modes, SHA-3 variants (such as cSHAKE, KMAC, and TupleHash), key management, random
    generation, and statistical tests.
  prefs: []
  type: TYPE_NORMAL
- en: The design of NIST-standardized algorithms, such as AES and SHA-3, was crowdsourced
    to cryptographers from all around the world through a public, transparent process.
    This approach is believed to be more reliable than delegating cryptographic algorithms
    design to NSA.
  prefs: []
  type: TYPE_NORMAL
- en: NIZK (non-interactive zero-knowledge)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A NIZK proof is a zero-knowledge proof that comes as a single message, as opposed
    to an interactive protocol involving multiple messages between a prover and a
    verifier. NIZK proofs often use the Fiat–Shamir heuristic to turn an interactive
    protocol into a noninteractive one.
  prefs: []
  type: TYPE_NORMAL
- en: Noekeon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A block cipher with a rare property: the encryption algorithm is the same as
    the decryption algorithm. This is convenient in environments with limited code,
    silicon, or developer time.'
  prefs: []
  type: TYPE_NORMAL
- en: Noise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A framework for designing protocols using the Diffie–Hellman protocol. A Noise
    protocol can sometimes (but not always) replace TLS to implement transport security.
    This offers multiple potential benefits, including greater simplicity, identity
    hiding, and lower bandwidth usage.
  prefs: []
  type: TYPE_NORMAL
- en: Nonce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of cryptography, a *number used only once*. An additional input
    to some cryptographic operation whose value should always be unique. This ensures
    that the operation will always produce different outputs, even if all inputs are
    identical. In practice, guaranteeing nonce uniqueness isn’t always straightforward,
    and nonces are typically generated at random. Authenticated ciphers will usually
    use a nonce to ensure that if you encrypt the same message twice, the output ciphertext
    will look different, thereby preventing an attacker from noticing that the same
    message was encrypted again.
  prefs: []
  type: TYPE_NORMAL
- en: Non-committing encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sounds like deniable encryption, but not necessarily deniable. Using non-committing
    encryption, a fake ciphertext can be created in such a way that it looks like
    a real one. It can be shown to have been created from any plaintext by revealing
    a key pair and random bits that connect the ciphertext to the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Non-outsourceability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A property of a proof-of-work scheme whose work cannot be outsourced without
    revealing the private key of the prover. So it prevents pooled mining, where third
    parties perform a share of the work and are supposed to get a share of the mining
    reward. Such a proof must be efficiently verifiable without the private key.
  prefs: []
  type: TYPE_NORMAL
- en: Non-slanderability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of ring signatures, a security property that prevents an attacker
    from forging a valid signature that can be linked to a specific member of the
    group of authorized signers. Although expressed in slightly different terms, non-slanderability
    is equivalent to unforgeability.
  prefs: []
  type: TYPE_NORMAL
- en: NSA (National Security Agency)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptographers’ favorite three-letter agency. The NSA employs many cryptographers
    but never publishes in peer-reviewed conferences. However, it’s active in cryptography
    research, having designed established public standards (such as DSA, SHA-2, and
    the unfortunate Dual_EC_DRBG), unclassified candidate standards (the block ciphers
    SIMON and SPECK), declassified systems (the Fortezza crypto card, including the
    Skipjack block cipher), and many classified algorithms. The NSA’s cryptanalysis
    capabilities remain largely undocumented.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Suite A*](#Suite-A).
  prefs: []
  type: TYPE_NORMAL
- en: NT hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Colloquially known as NTLM hash, the password hash function used in MS Windows’
    NT LAN Manager (NTLM) protocol suite, and an upgrade from the legacy LAN Manager
    protocol. NT hash is just an MD4 hash of the encoded user password. It’s better
    than LM hash but is also easily cracked.
  prefs: []
  type: TYPE_NORMAL
- en: See [*LM hash*](#LM-hash).
  prefs: []
  type: TYPE_NORMAL
- en: NTRU (*N*th degree Truncated polynomial Ring Units)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first lattice-based cryptosystems, designed in 1996\. Under­studied
    for many years, perhaps because it was patented and commercialized.
  prefs: []
  type: TYPE_NORMAL
- en: Renewed interest in NTRU culminated in the 2016 design of NTRU Prime, an NTRU
    variant succinctly defined by its authors as “an efficient implementation of high-security
    prime-degree large-Galois-group inert-modulus ideal-lattice-based cryptography,”
    where “*Prime degree* etc. are three features that (. . .) take various mathematical
    tools away from the attacker.” NTRU Prime was submitted to NIST’s post-quantum
    competition.
  prefs: []
  type: TYPE_NORMAL
- en: Null cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A term that means *no encryption* when encountered as a cipher suite. For example,
    early TLS versions supported the null cipher. The null cipher needs no key, and
    I suppose you could consider it the fastest cipher.
  prefs: []
  type: TYPE_NORMAL
- en: O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAEP (Optimal Asymmetric Encryption Padding)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method for securely padding a message before public-key encryption with RSA
    or Rabin’s schemes. Computing *m*^(*e*)mod *n* is indeed not a very safe way to
    use the RSA operation to encrypt a message *m*. Instead, OAEP can convert the
    message into a randomized string that breaks plain RSA’s malleability and homomorphicity.
    RSA-OAEP is now the recommended way to encrypt with RSA, following the PKCS#1
    v2.2 standard.
  prefs: []
  type: TYPE_NORMAL
- en: See [*All-or-nothing transform (AONT)*](#All-or-nothing-transform-AONT), [*Manger
    attack*](#Manger-attack).
  prefs: []
  type: TYPE_NORMAL
- en: Oblivious key management system (OKMS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service that holds master keys and interacts with clients to derive keys without
    knowing said keys due to (partially) oblivious PRFs used for key derivation.
  prefs: []
  type: TYPE_NORMAL
- en: Oblivious PRF (OPRF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A two-party protocol where a server knows the key *K* and a client computes
    PRF(*K*, *X*) for some *X* without learning *K* by interacting with the server,
    which must learn nothing about *X* or PRF(*K*, *X*).
  prefs: []
  type: TYPE_NORMAL
- en: Partially oblivious PRFs (pOPRFs) are a variant wherein the server can supply
    an additional nonsecret input.
  prefs: []
  type: TYPE_NORMAL
- en: Oblivious RAM (ORAM)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An abstract model of secure memory, designed so an attacker learns nothing when
    they observe the content and access patterns of the memory a program uses. In
    particular, they shouldn’t learn what piece of data is being accessed or (to some
    extent) whether the access is a read or a modification of the stored data. In
    theory, an ORAM deals with actual RAM—as in memory a program uses—but in practice
    is more about ROM, a filesystem, or a database.
  prefs: []
  type: TYPE_NORMAL
- en: Oblivious transfer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol to transfer data between two parties, where the receiver chooses
    which piece of data they want to receive among a multitude of pieces, but the
    sender doesn’t know which piece it is.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want to buy and download an ebook from the No Starch Press online
    store but don’t want the publisher, Bill, to know which book you purchased. Normally,
    your ebook purchase request would ultimately lead to a query to No Starch’s database,
    a file transfer from some storage media to No Starch’s ebook service, and then
    to your device. The publisher could therefore find out which book you bought by
    monitoring the disk activity, database queries, file transfers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Oblivious transfer prevents anyone from finding out which file was accessed,
    even if they monitored the precise data read from the storage medium. In addition,
    oblivious transfer guarantees to No Starch Press that you’re retrieving only one
    book, and that you’re not collecting information about others (the main feature
    that makes oblivious transfer different than private information retrieval).
  prefs: []
  type: TYPE_NORMAL
- en: Obscurity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A heresy for cryptographers. But in reality, when cryptography is just a part
    of a broader security system, you sometimes need to obscure its logic to meet
    your security goals.
  prefs: []
  type: TYPE_NORMAL
- en: OCB (offset codebook mode)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest and most efficient authenticated encryption modes for block
    ciphers and a demonstration of cryptography’s fragility. Attackers managed to
    break OCB2, the second version of OCB, in spite of security proofs and standardization.
    OCB1 and OCB3, although very similar, seem to be secure.
  prefs: []
  type: TYPE_NORMAL
- en: One-time pad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often described as the paragon of encryption, or the perfect cipher, because
    it’s mathematically proven to be absolutely secure. But the one-time pad used
    on its own is actually a weak cipher: it’s trivially malleable, unauthenticated,
    and not misuse resistant.'
  prefs: []
  type: TYPE_NORMAL
- en: One-way function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cornerstone of modern cryptography. Easy to compute but hard to invert:
    a function *f*() is one-way if, given *f*(*x*) for a random unknown input *x*,
    finding a value *y* so that *f*(*y*) = *f*(*x*) is computationally hard. (The
    formal definition is more rigorous than this.)'
  prefs: []
  type: TYPE_NORMAL
- en: You can construct most cryptographic primitives if all you have is a one-way
    function; in practice, many functions in cryptography, such as hash functions,
    appear to be one-way. But in theory, we have no proof that one-way functions actually
    exist. In fact, the existence of one-way functions implies P ≠ NP (the proof is
    left as an exercise for you to complete).
  prefs: []
  type: TYPE_NORMAL
- en: Onion-AE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The notion of strong authenticated encryption in the context of Tor’s onion
    routing. In onion-AE encryption, the authenticity of a message must only be checked
    at the last (exit) node, yet covers the entire route of the message, from its
    initial sender.
  prefs: []
  type: TYPE_NORMAL
- en: OPAQUE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pronounced *O-PAKE*. The O represents oblivious PRF, the most interesting part
    of the OPAQUE password-authenticated key agreement (PAKE). It allows the client
    to compute the hash of a combination of two values when it knows only one of the
    two (its password).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some caveats: although authentication is about proving knowledge
    of a password, the client also needs a traditional public-key pair and must therefore
    protect its private key. Also, to get a full PAKE with secure shared key agreement,
    it must be combined with another protocol, such as HMQV.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Oblivious PRF (OPRF)*](#Oblivious-PRF-OPRF).
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important pieces of cryptographic software. Foremost a command
    line utility that supports a multitude of cryptographic operations (key generation,
    signature, encryption, certificate creation, encoding/decoding of various formats,
    and so on) for a multitude of algorithms (block ciphers, hash functions, elliptic
    curves, and so on, as well as legacy algorithms) and their parameters, and that
    runs on numerous CPU types and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If that isn’t enough, OpenSSL also provides two libraries: a cryptographic
    library (libcrypto) and an implementation of the SSL and TLS protocols (libssl),
    which uses libcrypto.'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather like a crystal ball, an abstract entity that will respond to your requests,
    which cryptographers call oracle queries.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of cryptographic oracles comes from the *oracles* of complexity theory,
    where, for example, you attempt to solve problem 1 using an oracle that magically
    gives you solutions to problem 2, given the description of an instance of problem
    2\. Given a factoring oracle, for instance, you can break RSA.
  prefs: []
  type: TYPE_NORMAL
- en: Oracles are an abstraction used in research papers as a device to simplify security
    arguments, proofs, or cryptanalytic attacks. You might encounter encryption oracles,
    decryption oracles, factorization oracles, and many more. Random oracles are the
    most common because of their unique role in proofs of security.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Random oracle*](#Random-oracle).
  prefs: []
  type: TYPE_NORMAL
- en: OTR (Off-the-Record)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The end-to-end encryption protocol initially designed for synchronous communications.
    Capable of running atop messaging protocols, such as XMPP or IRC. A unique aspect
    of OTR is its deniability property, whereby peers can deny having sent a message
    by leaking the MAC key used to sign it. OTR is the basis for what became known
    as the Signal protocol.
  prefs: []
  type: TYPE_NORMAL
- en: P
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Padding oracle attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class of side-channel attacks that exploit information about whether the padding
    of some encrypted message is valid. An attacker could learn that information by
    measuring the decryption execution time, which sometimes depends on the padding’s
    correctness. The most common padding oracle attacks are those applied to the CBC
    block cipher mode, the Bleichenbacher attack on PKCS#1 v1.5, and Manger attack
    on OAEP (PKCS#1 v2) encryption. The idea of padding oracles can be generalized
    to format oracles, which reveal the existence of some known pattern in the decrypted
    message (for example, a specific encoding or character set).
  prefs: []
  type: TYPE_NORMAL
- en: Developers have sometimes deployed countermeasures to padding oracle attacks
    accidentally—namely, when certain implementations don’t check the padding correctly
    (but this creates other problems).
  prefs: []
  type: TYPE_NORMAL
- en: See [*Bleichenbacher attack*](#Bleichenbacher-attack), [*CBC (cipher block chaining)*](#CBC-cipher-block-chaining),
    [*Manger attack*](#Manger-attack).
  prefs: []
  type: TYPE_NORMAL
- en: Paillier cryptosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public-key encryption scheme that is a bit more mathematically interesting
    than RSA, ElGamal, and IES. Paillier’s encryption has the rare property of additive
    homomorphism, meaning that Dec(Enc(*M*[1]) × Enc(*M*[2])) = *M*[1] + *M*[2]. Its
    security is based on the hardness of the factoring problem as well as that of
    a related problem—the decisional composite residuosity problem, introduced with
    Paillier’s cryptosystem, which is about deciding whether there exists *x* such
    that *y* = *x*^(*d*)mod *n*² given *n* and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In public-key cryptography, nothing to do with the Bluetooth pairing operation.
    A pairing is a map *e*() of two group elements to an element from another group,
    with the following property, for any *R*, *S*, *T*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*e*(*R* + *S*, *T*) = *e*(*R*, *T*)*e*(*S*, *T*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called bilinearity and is what makes pairings useful in cryptography.
    These properties hold as well for a bilinear pairing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*e*(*S*, −*T*) = *e*(−*S*, *T*) = *e*(*S*, *T*)^(−1)'
  prefs: []
  type: TYPE_NORMAL
- en: '*e*(*aS*, *bT*) = *e*(*S*, *T*)^(*ab*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*The bilinear counterpart of the Diffie–Hellman problem for pairings is the
    following: given *P*, *aP*, *bP*, *cP*, find *e*(*P*, *P*)^(*abc*). For well-chosen
    types of pairing and elliptic curves, this problem is believed to be about as
    hard as its classical version.'
  prefs: []
  type: TYPE_NORMAL
- en: Pairing-based cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography that uses pairings, duh. Pairings on elliptic curves allow the
    creation of bilinear maps, which allow you to construct—under some hardness assumptions—secure
    functionalities that classical, discrete, logarithm-based elliptic-curve cryptography
    cannot. These functionalities include one-round three-party key agreement, identity-based
    encryption, attribute-based encryption, short signatures, and verifiable random
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**## PAKE (password-authenticated key exchange)'
  prefs: []
  type: TYPE_NORMAL
- en: An authenticated key agreement (or exchange) protocol where the client’s authentication
    relies on the knowledge of a password. In most PAKEs, the server doesn’t know
    the password but only some data derived from it. PAKEs where both parties know
    the password are called balanced PAKEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'PAKEs try to prevent the straightforward password-guessing attacks possible
    in send-the-password-or-its-hash methods of key exchange. But this small benefit
    comes at a high cost: PAKEs add complexity and deployment cost, which is why they’re
    rarely used. As Matthew Green wrote, “Many people don’t want to run a *key exchange*
    protocol in the first place! They just want to verify that a user knows a password.”'
  prefs: []
  type: TYPE_NORMAL
- en: Paradigm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An overused word in cryptography, especially when preceded by *new*.
  prefs: []
  type: TYPE_NORMAL
- en: Password hash function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash function whose goal is to be slow rather than fast.
  prefs: []
  type: TYPE_NORMAL
- en: PBKDF2 (Password-Based Key Derivation Function 2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Password-based key derivation function, second version of the standard. PBKDF2
    is the poor man’s password hash. It’s good enough in most cases when tuned with
    enough iterations, but it’s not as cool as Argon2.
  prefs: []
  type: TYPE_NORMAL
- en: PCT (Private Communications Technology)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft’s secure communication protocol. PCT competed with SSL v3 in the mid-1990s.
    PCT intended to address SSL v2’s flaws yet be somewhat compatible with it. But
    only Microsoft has used it, and it was ultimately replaced by SSL v3 or TLS everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: PEP (Plaintext equivalence proof)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol that checks whether two ciphertexts are encryptions of the same value.
    Participants cannot cheat.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect forward secrecy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Forward secrecy*](#Forward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: Permutation-based cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptographic schemes that leverage a single permutation to provide other functionalities.
    It’s based on research related to the Keccak hash function.
  prefs: []
  type: TYPE_NORMAL
- en: PES (Proposed Encryption Standard)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A block cipher presented at Eurocrypt 1990\. It didn’t become a standard.
  prefs: []
  type: TYPE_NORMAL
- en: See [*IDEA*](#IDEA-International-Data-Encryption-Algorithm), [*IPES*](#IPES-Improved-Proposed-Encryption-Standard).
  prefs: []
  type: TYPE_NORMAL
- en: PET (Plaintext equivalence test)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol that checks whether two ciphertexts are encryptions of the same value.
    But participants can cheat.
  prefs: []
  type: TYPE_NORMAL
- en: PFS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A secret advanced cryptography think tank.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Forward secrecy*](#Forward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: PGP (Pretty Good Privacy)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first major, public cryptography software, developed in the early 1990s.
    PGP later became an enterprise encryption product. Currently, pgp.com redirects
    to broadcom.com, because Symantec acquired the PGP company and Broadcom later
    acquired Symantec. The OpenPGP message format and the GnuPG (GPG) software are
    the open source legacies of PGP. In 2020, PGP remains the de facto standard for
    email encryption and is used by major enterprise and open source email encryption
    software.
  prefs: []
  type: TYPE_NORMAL
- en: PGP is often called broken, mostly because the 1990s design didn’t anticipate
    security requirements of the 2010s. Also, its software implementations turned
    out to have security flaws—as pretty much all software does.
  prefs: []
  type: TYPE_NORMAL
- en: Photuris
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Latin name for a genus of fireflies. Also, a session-key management protocol
    for IPSec that is, according to *informed speculation*, similar to NSA’s FIREFLY
    protocol (allegedly part of Suite A and used in EKMS).
  prefs: []
  type: TYPE_NORMAL
- en: See [*Suite A*](#Suite-A).
  prefs: []
  type: TYPE_NORMAL
- en: Picnic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A post-quantum signature scheme that doesn’t fit in any of the established categories
    of post-quantum schemes. A Picnic signature proves the signer’s knowledge of the
    key to a block cipher, given a plaintext-ciphertext pair as a public key.
  prefs: []
  type: TYPE_NORMAL
- en: Picnic achieves this by using a noninteractive proof of knowledge and a block
    cipher (lowMC) that lends itself to such proofs.
  prefs: []
  type: TYPE_NORMAL
- en: PKC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Officially, “The International Conference on Practice and Theory in Public Key
    Cryptography.” The PKC conference is to public-key cryptography what FSE is to
    symmetric cryptography, but it covers more diverse and mathematical topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Researchers present peer-reviewed research papers with titles such as “Safety
    in Numbers: On the Need for Robust Diffie–Hellman Parameter Validation”and “Committed
    MPC—Maliciously Secure Multiparty Computation from Homomorphic Commitments.”'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Asiacrypt*](#ASIACRYPT), [*CHES*](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems),
    [*CRYPTO*](#CRYPTO), [*Eurocrypt*](#Eurocrypt), [*FSE*](#FSE-Fast-Software-Encryption),
    [*Real World Crypto*](#Real-World-Crypto-RWC), [*TCC*](#TCC).
  prefs: []
  type: TYPE_NORMAL
- en: PKCS (Public Key Cryptography Standards)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A series of cryptographic standards issued by the RSA Security firm in the
    1990s. Of the 15 PKCS standards, the best known are probably the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PKCS#1, also RFC 8017, is about RSA-based encryption and signature. An earlier
    version (1.5) defined an RSA encryption scheme vulnerable to Bleichenbacher’s
    padding oracle attack. Later versions, starting with 2.0, defined instead OAEP-based
    RSA encryption, which is less vulnerable to padding oracle attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PKCS#7, also RFC 2315, is best known for its definition of the block cipher
    padding scheme but is mainly about data formatting and encoding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PKCS#11 is a standard API to interact with a cryptographic module, such as that
    of an HSM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poly1305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A one-time MAC best known as the authenticator component in the *ChaChaPoly*
    authenticated cipher, as well as ChaCha20-Poly1305\. It’s supported in TLS, OpenSSH,
    and many other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Polynomial complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practical complexity, most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Post-compromise security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A term used mostly in the context of secure messaging to denote a notion similar
    to backward secrecy.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Backward secrecy*](#Backward-secrecy).
  prefs: []
  type: TYPE_NORMAL
- en: Post-quantum cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography schemes designed to remain unbreakable by quantum algorithms. Therefore,
    they can resist the hypothetical quantum computers of the future. Also termed
    quantum-safe and quantum-resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Post-quantum RSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RSA so big that it’s practically immune to quantum attacks as well as to any
    practical application. A public key of post-quantum RSA is of the order of one
    terabyte. Post-quantum RSA has been submitted to NIST’s post-quantum cryptography
    standardization project.
  prefs: []
  type: TYPE_NORMAL
- en: Prediction resistance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A term notably used by NIST to refer to a notion similar to backward secrecy.
    Prediction resistance is the opposite of backtracking resistance.
  prefs: []
  type: TYPE_NORMAL
- en: See *Backward secrecy*.
  prefs: []
  type: TYPE_NORMAL
- en: Preimage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hash function problem of finding some *M* so that Hash(*M*) = *H* given
    the value *H*. If *H* was chosen by picking some *M*[0] at random (among a large
    enough finite set of possible messages) and computing *H* = Hash(*M*[0]), then
    even with unlimited computational power, an attacker can never identify *M*[0]
    with certainty unless *M*[0] is the only value that hashes to *H*.
  prefs: []
  type: TYPE_NORMAL
- en: But in practice, the message sets we deal with are much larger than the hash
    size; thus, any *H* will have many preimages. Also, nobody actually has unlimited
    computational power. Finding any preimage would cost 2^(*n*), which is practically
    impossible, even if the hash values are as short as *n* = 128 bits.
  prefs: []
  type: TYPE_NORMAL
- en: PRESENT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anagram of Serpent. A block cipher that works a lot like Serpent (­surprise)
    but smaller. Marketed as an *ultra lightweight cipher*, PRESENT has 64-bit blocks
    like DES and supports 80-bit and 128-bit keys. According to some very academic
    understanding of *broken*, PRESENT is broken by biclique cryptanalysis, with respectively
    2^(79.76) and 2^(127.91) complexities. But PRESENT remains safe to use, and it
    was standardized by ISO. A variant of PRESENT, named *GIFT*, is described as *a
    small PRESENT*.
  prefs: []
  type: TYPE_NORMAL
- en: PRIMES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decisional problem of determining whether a given integer is a prime number.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy-preserving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A broad qualifier encompassing techniques and technologies that attempt to minimize
    the exposure of privacy-sensitive data, such as personally identifiable information,
    geolocation, social graph, online activity, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Private information retrieval (PIR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to oblivious transfer except the amount of information to be retrieved
    isn’t limited. Both PIR and oblivious transfer attempt to conceal the client’s
    activity to the database host, but PIR assumes *self-service*, whereas oblivious
    transfer restricts the client’s access to one-in-many access.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Oblivious transfer*](#Oblivious-transfer).
  prefs: []
  type: TYPE_NORMAL
- en: Proof of burn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most straightforward type of resource usage proof proposed for a
    consensus protocol. Proof of burn consists of nullifying the value of tokens or
    other digital assets associated with the protocol, for example, by sending them
    to some unspendable address, the blockchain equivalent of `/dev/null`. This differs
    from proofs of stake, where the value owned isn’t destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of catalytic space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variant of proofs of space wherein the space isn’t completely wasted but can
    be used to store data unrelated to the proof. This leverages the concept of catalytic
    space computation, where a program can use some memory region even if it’s already
    used to store data, and return said region in its original state after completing
    its task.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of human work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proof of work whose work isn’t a computationally intensive task but one that
    is relatively easy for humans, yet hard for computers and AI programs. An idea
    proposed it to rely on CAPTCHAs generated using obfuscated programs to prevent
    the machine generating CAPTCHAs to solve them.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of replication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An extension of proof of storage to prove that multiple replicas of a piece
    of data are being stored instead of a single real copy and pointers to it. One
    technique used to realize proof of replication involves depth-robust graphs, a
    notion from graph theory rediscovered in the context of memory-hard password hashing.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of reserve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not a proof of resource associated to consensus protocols, but a proof that
    one account or organization owns a certain amount of coins. A proof of reserve
    can be publicly verifiable, for example, by issuing a special transaction from
    an address that controls the funds to be verified. It can also be private and/or
    notarized on a private ledger, for example, by signing a timestamped message provided
    by auditors.
  prefs: []
  type: TYPE_NORMAL
- en: A proof of reserve can be considered a proof of stake without the lottery mechanism
    and without being tied to any decentralized protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Security proof*](#Security-proof).
  prefs: []
  type: TYPE_NORMAL
- en: Proof of sequential work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proof of work for which parallelism is useless, because operations must be carried
    out sequentially. As with parallelizable proofs of work, a solution to the puzzle
    must be verifiable efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Like verifiable delay functions (VDFs), proofs of sequential work can be used
    to add an incompressible delay in decentralized applications. They also face the
    same technical challenges of associating an actual time latency to a series of
    operations. Unlike with VDFs, a proof of sequential work doesn’t admit a unique
    precomputable solution, which restricts its number of applications.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Time-lock puzzle*](#Time-lock-puzzle), [*Verifiable delay function (VDF)*](#Verifiable-delay-function-VDF).
  prefs: []
  type: TYPE_NORMAL
- en: Proof of space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A demonstration that a prover has certain amount of memory at their disposal.
    For example, a prover might have to allocate one terabyte to convince a verifier,
    and the verifier won’t accept any proof from a prover that allocated less than
    a terabyte. Wasting memory with proofs of space is arguably more ecological than
    wasting CPU time with proofs of work.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of spacetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An extension of proof of storage to efficiently demonstrate that a piece of
    data (or multiple replicas thereof) has been stored throughout a given period
    of time. Proofs of spacetime can be realized by combining proofs of replication.
    Used by the Filecoin project, proofs of spacetime ensure that hosts rewarded to
    store data aren’t cheating.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of stake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An environment-friendly counterpart of proofs of work where miners holding a
    greater amount of tokens have a greater chance to validate transactions; they
    receive the reward by a kind of lottery system. The richest thus get richer faster
    by doing nothing other than *staking*, by running a node and keeping it online.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of stake blockchains usually require a certain table stake amount to participate
    on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proof that some piece of data is being stored (or at least known, or possible
    to be generated). Concepts such as provable data possession and proof of retrieveability
    are examples of proofs of storage. The most straightforward proof system is one
    where the verifier sends some challenge *c* and the prover returns Hash(*c*||*M*)
    where *M* is the data whose storage is to be verified.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of useful work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the proof of work is not completely wasteful, but compute time is used
    to contribute to solving some computational problem.
  prefs: []
  type: TYPE_NORMAL
- en: Proof of work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography’s contribution to environmental problems.
  prefs: []
  type: TYPE_NORMAL
- en: Provable security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For some cryptographers, the only acceptable security—as opposed to unscientific,
    unacceptably risky heuristic security.
  prefs: []
  type: TYPE_NORMAL
- en: This simplistic goal is now less common, and provable security is now considered
    more of an additional insurance than as something required by all means necessary.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an algorithm such as AES is not *provably secure*, and public-key
    schemes, such as RSA or ECDSA, are only proven secure insofar as their underlying
    computational problems are hard.
  prefs: []
  type: TYPE_NORMAL
- en: Provably secure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “If it’s provably secure, it’s probably not,” to quote cryptographer Lars Knudsen
    (then in the context of block ciphers). This folklore adage might come from the
    block cipher COCONUT98, which was proven to be secure against a class of differential
    cryptanalysis techniques but ended up being broken by a yet unknown type of differential
    attack (boomerang).
  prefs: []
  type: TYPE_NORMAL
- en: Proxy re-encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public-key encryption scheme where a ciphertext for Alice (created using her
    public key) can be turned into a ciphertext for Bob without exposing the plaintext—in
    other words, without decrypting and re-encrypting. For example, proxy re-encryption
    can be realized (in theory) thanks to indistinguishability obfuscation by creating
    an obfuscated program that decrypts and re-encrypts a ciphertext without exposing
    the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-random
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hyphenated spelling of *pseudorandom*. But in English, compounds created by
    the addition of a prefix are usually not hyphenated (for example, pseudoscience,
    cryptocommunist, and antisocial). Among research papers on the IACR ePrint archive,
    the use of *pseudorandom* is about twice as frequent as *pseudo-random*.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudorandom function (PRF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not actually a single function but a family of many functions; each is indexed
    by its secret key. The security goal of a PRF is to be indistinguishable from
    a truly random function if you don’t know the key and only see input–output pairs,
    even when choosing input values.
  prefs: []
  type: TYPE_NORMAL
- en: You can use PRFs as secure MACs, but a secure MAC isn’t necessarily a secure
    PRF.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudorandom number generator (PRNG)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A system generating random-looking data with the security guarantee that an
    attacker that knows any subset of the output bits cannot determine any other output
    bits. The theoretical definition of a PRNG differs from its colloquial usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, a PRNG is a (deterministic) algorithm that takes as input a value
    (seed) of fixed size and returns a longer output value. In practice, a PRNG often
    refers to all the components involved in the generation of pseudorandom bits,
    for example, in the context of an operating system’s PRNG. Such a PRNG usually
    includes the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Entropy collectors from analog sources, such as user activity, temperature measurements,
    and on-chip sensors—sometimes referred to as true random generators, although
    their (digital) output is rarely guaranteed to be cryptographically safe, or even
    uniformly distributed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mechanism to store an internal state, such as *entropy pools*, including the
    logic to update it and perform *reseeding* operations from entropy collectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deterministic random bit generator (DRBG), which produces an arbitrarily long
    output from a seed derived from the internal state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pseudorandom permutation (PRP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To a permutation what a PRF is to a hash function. A block cipher is a PRP.
  prefs: []
  type: TYPE_NORMAL
- en: Public-key cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All cryptography, excluding symmetric cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: PUF (physically unclonable function)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A physical component on semiconductor devices that leverages minute differences
    between each different platform to generate unpredictable values, such as identifiers.
    Although sometimes advertised as semi-magical technology, many PUFs have been
    shown to be cryptographically weaker than claimed.
  prefs: []
  type: TYPE_NORMAL
- en: Puncturable encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Public-key encryption augmented with a *puncture* operation. This operation
    creates a new private key to replace the current one to forever revoke the decryption
    capability for certain ciphertexts that the previous key could decrypt. One motivation
    for this is to be able to provide forward secrecy for certain messages, even though
    they were encrypted with the same public key.
  prefs: []
  type: TYPE_NORMAL
- en: You can create puncturable symmetric encryption from puncturable PRFs.
  prefs: []
  type: TYPE_NORMAL
- en: Puncturable pseudorandom function (PPRF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to puncturable encryption. PRFs whose keys can be updated to revoke
    the capability to process certain values.
  prefs: []
  type: TYPE_NORMAL
- en: Q
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantum computer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to some experts, has a 1/7 chance of breaking RSA-2048 by 2026 and
    a 1/2 chance by 2031\. In truth, nobody knows if you’ll see a quantum computer
    breaking RSA-2048 in your lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptographic operations that rely on quantum phenomena and don’t necessarily
    need a quantum computer, such as quantum key distribution. Quantum cryptography
    happens to be post-quantum but doesn’t belong to the field of post-quantum cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encryption of quantum states as opposed to strings of classical bits. The most
    basic form of this is the quantum one-time pad, which you can think of as a combination
    of quantum teleportation (to transmit the encrypted state) and a classical one-time
    pad (the bits required to read the decrypted state).
  prefs: []
  type: TYPE_NORMAL
- en: The quantum one-time pad looks less efficient than its classical counterpart,
    requiring two classical bits of key for each bit of information encrypted. But
    it’s also more powerful, because it can be leveraged to build secure homomorphic
    and multi-party computation schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum key distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes confused with post-quantum cryptography, but different and of lower
    practical value. The best known is the *BB84* key agreement protocol
  prefs: []
  type: TYPE_NORMAL
- en: See [*BB84*](#BB84).
  prefs: []
  type: TYPE_NORMAL
- en: Quantum signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An impossible scheme, because the classical notion of a signature doesn’t apply
    to quantum states. Intuitively, you should see why: any party that can learn information
    about a quantum state can also modify it. In particular, it’s impossible to attach
    a signature to a quantum state, as you would do with a classical message. More
    generally, quantum states cannot be authenticated unless they’re also encrypted,
    so that only the intended recipient can decrypt them. But although quantum signing
    isn’t possible, quantum signcryption is.'
  prefs: []
  type: TYPE_NORMAL
- en: QUIC (Quick UDP Internet Connections)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A transport security protocol designed to make HTTPS connections more reliable
    under poor conditions (packet loss, IP roaming, and so on), notably by running
    over UDP rather than TCP. Using UDP saves it from the latency cost of the TCP
    handshake. It also includes some mechanism to mitigate the problem of UDP’s unreliability.
    HTTP-over-QUIC has been officially standardized by IETF and has been named HTTP/3.
  prefs: []
  type: TYPE_NORMAL
- en: R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rabin cryptosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RSA with 2 as a public exponent, kinda. Because computing modular square roots
    is proven to be equivalent to factoring, breaking Rabin encryption is as hard
    as factoring its modulus *n = pq*. The equivalence between breaking RSA and factoring
    is harder to demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: Rainbow tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time-memory trade-off technique mostly applied to password cracking, such as
    Windows NTLM passwords. Rainbow tables are a specific, optimized type of look-up
    tables precomputed once, in the *offline* stage, to significantly speed up the
    cracking of passwords (*online* stage).
  prefs: []
  type: TYPE_NORMAL
- en: Rainbow tables are also successfully applied to crack pay-TV control words within
    short cryptoperiods (such as 10 seconds). They’re designed and often also made
    in Switzerland.
  prefs: []
  type: TYPE_NORMAL
- en: Random bits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bits that have been generated at random. We often talk of random bits when strictly
    speaking they’ve only been pseudorandomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: Random oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An abstract concept used to prove that a protocol is secure in theory: you
    can imagine a random oracle as a function *f*() that, every time you send it an
    input *x*, it picks a random value *y* and returns it as the output while registering
    *f*(*x*) = *y*. This sounds similar to how a hash function ought to behave, yet
    a random oracle relies on a slightly different assumption than that of a secure
    hash function. Assuming that a hash function is a random oracle makes it easier
    to write security proofs. But such proofs are perceived as less reliable because,
    unlike secure hash functions, random oracles can’t exist in practice, but in practice
    that’s not a concern.'
  prefs: []
  type: TYPE_NORMAL
- en: Randomness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important thing in cryptography. Without randomness, you couldn’t generate
    random secret values so there would be no secret keys and therefore no encryption.
    Even if you already have keys, you need randomness to achieve the highest public-key
    encryption security level (called *semantic security, or IND-CPA*).
  prefs: []
  type: TYPE_NORMAL
- en: Range proof
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proof that a number lies in a certain interval without having to reveal the
    number (the zero-knowledge part). Some cryptocurrencies use range proofs to hide
    the amounts transferred, and to ensure the correctness of a protocol’s execution,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: RC4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rivest’s Cipher 4, designed in 1987\. A stream cipher with a tumultuous history:
    initially, it was a proprietary algorithm from the firm RSA Security and was then
    reverse engineered and published in 1994\. It withstood cryptanalysis surprisingly
    well despite its extreme simplicity and lack of academic peer-review seal of approval—until
    it didn’t, and was found to be insecure (because of statistical biases in the
    first bytes it generates). Still, it was less insecure than most proprietary algorithms
    from that era. RC4 was the basis of WEP, the first Wi-Fi encryption scheme, which
    was broken in part because of RC4’s properties but in larger part because of WEP’s
    flawed design. RC4 was also used in TLS, where its statistical biases could be
    exploited to decrypt data that is encrypted under many different keys. Because
    of its small size, RC4 is also used in malware to obfuscate code or encrypt data
    sent to the malware’s server.'
  prefs: []
  type: TYPE_NORMAL
- en: RC5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cipher whose only commonality with RC4 is its designer Ronald Rivest; unlike
    RC4, RC5 is not a stream cipher but a block cipher. RC5 is one of the few ciphers
    to use data-dependent rotations, an idea that at first sounds like it makes the
    cipher more complicated. But it also turned out to facilitate cryptanalysis, because
    an attacker could then control the rotation values.
  prefs: []
  type: TYPE_NORMAL
- en: RC6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to RC5\. Also a block cipher that uses data-dependent rotations and
    was patented by RSA Security. Designed by Ronald Rivest (along with other people)
    as well, RC6 was one of the candidates in the AES competition. It wasn’t chosen
    by NIST to be the AES but was later used in a software implant allegedly designed
    by the NSA.
  prefs: []
  type: TYPE_NORMAL
- en: Real world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Academic cryptography’s term to refer to reality, as opposed to the *ideal world*
    of the security models needed to rigorously analyze the security of cryptographic
    schemes. If attackers in the real world are less powerful than in the ideal world,
    then security proofs on paper guarantee real security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term is often the source of pleonasms, for example: *previous works don’t
    clarify how the code should be instantiated concretely in the real world*, *real-world
    applications*, and *practical real-world protocols*.'
  prefs: []
  type: TYPE_NORMAL
- en: Real World Crypto (RWC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cryptography conference focused on current real applications of cryptography,
    as opposed to research conferences less concerned with direct applications. Attended
    by participants from academia and industry, it’s the largest cryptography conference
    in terms of participants. RWC is held alternately on the US West Coast, East Coast,
    in Europe, and in the Asia-Pacific region. Speakers present contributed talks
    (which aren’t necessarily from formal research papers) with titles such as “Privacy-Preserving
    Telemetry in Firefox” and “Weaknesses in the Moscow Internet Voting System.”
  prefs: []
  type: TYPE_NORMAL
- en: See [*Asiacrypt*,](#ASIACRYPT) [*CHES*](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems),
    [*CRYPTO*](#CRYPTO), [*Eurocrypt*](#Eurocrypt), [*FSE*](#FSE-Fast-Software-Encryption),
    [*PKC*](#PKC), [*TCC*](#TCC).
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An improvement of the boomerang attack, created to attack the block cipher Serpent.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Boomerang attack*.](#Boomerang-attack)
  prefs: []
  type: TYPE_NORMAL
- en: Related-key attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attack that makes encryption or decryption queries for instances of the cipher
    whose key is a modified version of the original key, so the modification (as a
    function) is chosen by the attacker. For example, a related-key attack on a block
    cipher might make encryption queries Enc(*K* ⊕*M*, *P*) where *M* is a fixed value
    defined by the attacker without knowing the key.
  prefs: []
  type: TYPE_NORMAL
- en: You can only use this attack model against symmetric primitives, because it
    would be too powerful and effective against public-key schemes. Related-key attacks
    aren’t a very realistic threat when the key is secret.
  prefs: []
  type: TYPE_NORMAL
- en: Research papers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What academic researchers must write to keep their jobs. The IACR’s ePrint server
    received 69 research papers in 2000, 661 in 2010, and 1,499 in 2019\. No one has
    time to read all these articles, which is why it’s crucial for researchers to
    write succinct, informative abstracts, as well as clear and appealing titles.
  prefs: []
  type: TYPE_NORMAL
- en: Revocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem solved in theory but rarely in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Rijndael
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The block cipher that became known as AES after winning the AES competition
    in 2000\. The Rijndael name is a portmanteau of the last names of its designers,
    Belgian cryptographers Joan Daemen and Vincent Rijmen. The Google query *how do
    you say rijndael* returns about 100,000 results.
  prefs: []
  type: TYPE_NORMAL
- en: See [*AES*](#AES-Advanced-Encryption-Standard).
  prefs: []
  type: TYPE_NORMAL
- en: Ring signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First described in the paper “How to Leak a Secret” by Rivest, Shamir, and Tauman.
    Ring signatures involve a group of signers such that any signer can create a signature
    that is signer-ambiguous with respect to the subset of signers of their choice.
    In other words, verifiers have no way of identifying the signer; they can only
    know the group of potential signers that they’re in. Unlike with group signatures,
    there is no way to deanonymize the signer.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Group signature*](#Group-signature).
  prefs: []
  type: TYPE_NORMAL
- en: RIPEMD-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash function designed in 1992\. RIPEMD-160 got a second life due to its use
    in Bitcoin and many other cryptocurrencies.
  prefs: []
  type: TYPE_NORMAL
- en: Rivest–Shamir–Adleman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The authors of the 1978 paper “A Method for Obtaining Digital Signatures and
    Public-Key Cryptosystems” that described the RSA cryptosystem. RSA’s then unique
    property was that the key used for encryption is different from the one used for
    decryption. RSA has evolved into standardized schemes to encrypt and sign securely
    (such as the OAEP and PSS standards, respectively). But its market share has declined
    while elliptic-curve cryptography has gained greater adoption. But RSA’s support
    for *native*, non-hybrid encryption, as well as fast signature verification, sometimes
    makes it the best option when these properties are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: ROBOT (Return Of Bleichenbacher’s Oracle Threat)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bleichenbacher’s attack, 20 years later.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Bleichenbacher attack*.](#Bleichenbacher-attack)
  prefs: []
  type: TYPE_NORMAL
- en: ROS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Random inhomogeneities in an Overdetermined Solvable system of linear equations:
    the hardest of all crypto abbreviations to memorize.'
  prefs: []
  type: TYPE_NORMAL
- en: RSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest conference in the information security industry.
  prefs: []
  type: TYPE_NORMAL
- en: Rubber-hose cryptanalysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Term popularized by XKCD’s comic 538\. A reminder that mathematical cryptographic
    adversarial models often fail to capture more mundane risks from procedural or
    human flaws.
  prefs: []
  type: TYPE_NORMAL
- en: Rumba20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only hash function from the Salsa20 family. Rumba20 was created in the context
    of new results regarding the generalized birthday problem.
  prefs: []
  type: TYPE_NORMAL
- en: S
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SAEP (Simplified OAEP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variant of OAEP that is slightly simpler and achieves the same level of chosen-ciphertext
    security.
  prefs: []
  type: TYPE_NORMAL
- en: See [*OAEP (Optimal Asymmetric Encryption Padding)*.](#OAEP-Optimal-Asymmetric-Encryption-Padding)
  prefs: []
  type: TYPE_NORMAL
- en: Salsa20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Undoubtedly one of the most influential cryptographic algorithms. It led to
    the stream cipher ChaCha20 (used in TLS, SSH, and many other places). This in
    turn was reused in the BLAKE2 hash function, a component of the Argon2 password
    hash and protocols such as WireGuard. More generally, Salsa20 popularized simple,
    easy to implement add-rotate-xor (ARX) constructions. A few years earlier, NIST
    had standardized a more complicated cipher whose understanding required the knowledge
    of concepts such as polynomials, matrix inversion, and finite fields.
  prefs: []
  type: TYPE_NORMAL
- en: The 20 in Salsa20 is for its number of rounds, a conservative value initially
    chosen by its designer and later relaxed in some applications, decreasing to 12
    or even 8.
  prefs: []
  type: TYPE_NORMAL
- en: Sandwich attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A refinement of the boomerang attack often used to cryptanalyze block ciphers.
    A sandwich attack relies on a distinguisher divided into three parts: “A thick
    slice (bread) at the top, a thin slice (meat) in the middle, and a thick slice
    (bread) at the bottom.” It was invented to find the first practical attack on
    the block cipher KASUMI.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Boomerang attack*.](#Boomerang-attack)
  prefs: []
  type: TYPE_NORMAL
- en: S-box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A look-up table used in block ciphers to implement a nonlinear transformation
    with measurable security properties (such as nonlinearity or branch number), although
    S-boxes are not necessarily implemented as look-up tables. In the context of differential
    cryptanalysis, an active S-box is one for which the values from the two (different)
    inputs yield a different input value to the S-box, and thus a different output.
  prefs: []
  type: TYPE_NORMAL
- en: S-boxes are usually 4-bit (16 values, as in Serpent) or 8-bit (256 values, as
    in Rijndael/AES).
  prefs: []
  type: TYPE_NORMAL
- en: Scalar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number, as opposed to a vector or group element, for example. When you hear
    *scalar multiplication* in cryptography, it often just means multiplication of
    a point on an elliptic curve by a number, according to the addition law defined
    on said curve.
  prefs: []
  type: TYPE_NORMAL
- en: sci.crypt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with sci.crypt.research, Usenet newsgroup where people discussed cryptography
    before Twitter and Slack. It’s notorious for its can-you-break-my-cipher-here’s-a-ciphertext
    posts.
  prefs: []
  type: TYPE_NORMAL
- en: Scrambler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Former term for ciphers used in telecommunications and audio/video content processing.
    The first of these algorithms were cryptographically weak, because they didn’t
    really encrypt the signal but effectively just made it unintelligible. The later
    algorithms evolved into actual cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: See [*DVB-CSA*.](#DVB-CSA)
  prefs: []
  type: TYPE_NORMAL
- en: scrypt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A password hash function with configurable time memory usage, pronounced *ess-crypt*.
    scrypt pioneered memory-hard password hashing and inspired subsequent designs
    as well as the Password Hashing Competition.
  prefs: []
  type: TYPE_NORMAL
- en: scrypt has a modular, if not outright minimalistic, design. It includes, as
    subcomponents, the PBKDF2 construction based on HMAC-SHA-256 as well as the Salsa20/8
    stream cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Searchable encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encryption of database records that allows a search on encrypted data. For example,
    it permits a search that given an encrypted keyword retrieves the encrypted items
    that, when decrypted, include the keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Searchable encryption schemes that are possibly practical and useful leak some
    information about the encrypted data. In contrast, those with the highest security
    guarantees are severely limited functionality- and performance-wise (for example,
    those using functional encryption, homomorphic encryption, and oblivious RAMs).
  prefs: []
  type: TYPE_NORMAL
- en: secp256k1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elliptic curve used by Bitcoin, Ethereum, and many other cryptocurrencies
    for their ECDSA signatures of transactions. The *k* indicates a Koblitz curve.
    Unlike other standard curves, and in particular unlike the ubiquitous secp256r1
    (also known as the NIST p-256), secp256k1 doesn’t rely on pseudorandom parameters
    and is in principle less likely to have been manipulated. The actual reasons why
    Satoshi Nakamoto, or whoever, chose to use secp256k1 remain unclear.
  prefs: []
  type: TYPE_NORMAL
- en: Secret sharing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Threshold secret sharing*.](#Threshold-secret-sharing)
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect of cryptographic schemes. Security of a cryptographic scheme
    on paper doesn’t imply security in reality (to some extent, the reverse is also
    true). Even the existence of a formal proof that a cryptographic scheme is secure
    doesn’t necessarily mean it’s secure in all real-life conditions, because the
    definition of “secure in practice” is often undefinable in mathematical terms.
  prefs: []
  type: TYPE_NORMAL
- en: Security proof
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The demonstration that finding an algorithm to break some new crypto scheme
    is at least as hard as finding an algorithm to break some other crypto scheme
    or notoriously hard math problem, or a reduction of one problem to another. Security
    proofs only prove an algorithm’s security insofar as their assumptions about attackers’
    capabilities are accurate. Also, the scheme on which it’s based must really be
    practically unbreakable. Other caveats include the fact that the reduction might
    be too loose to be meaningful, and that, in reality, breaking cryptography isn’t
    always about attacking an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*IND-CPA*.](#IND-CPA)
  prefs: []
  type: TYPE_NORMAL
- en: '*Serious Cryptography*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yet another book about cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Serpent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In hindsight, would have been a good choice as the AES standard: its design
    is easy to understand, because it contains no finite fields, polynomials, matrix
    multiplication, or other such math; its implementation logic doesn’t stray too
    far from the specification; and it poses no risk of cache-timing attacks. But
    its security margin (in other words, number of rounds) involved perhaps too much
    crypto compared to Rijndael.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*PRESENT*.](#PRESENT)
  prefs: []
  type: TYPE_NORMAL
- en: SHA-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First draft of SHA-1.
  prefs: []
  type: TYPE_NORMAL
- en: SHA-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A secure hash function if the only security you need is preimage resistance.
    It took approximately 12 years to progress from the collision attack described
    in a 2005 paper to a demonstrable collision in 2017.
  prefs: []
  type: TYPE_NORMAL
- en: SHA-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not one but four hash functions:'
  prefs: []
  type: TYPE_NORMAL
- en: SHA-256 looks like SHA-1 but with more rounds and more complex internals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-224 is SHA-256 with 224-bit output instead of 256-bit output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-512 looks like SHA-256 with 64-bit words instead of 32-bit words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-384 is SHA-512 with 384-bit output instead of 512-bit output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike SHA-1, SHA-2 algorithms aren’t broken and are unlikely to ever be.
  prefs: []
  type: TYPE_NORMAL
- en: SHA-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When someone tells you they use SHA-3, you should ask which version of SHA-3
    they use: it could be SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, or SHAKE256\.
    If it’s one of the latter two, you might want to know what output length they
    use, because these aren’t simple hash functions but XOF (extendable-output functions).'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Keccak*.](#Keccak)
  prefs: []
  type: TYPE_NORMAL
- en: SHA-3 competition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Officially the *NIST hash function competition*. The 2008 to 2012 selection
    process for SHA-3 eventually settled on Keccak after a final round that included
    BLAKE, Grøstl, JH, and Skein. Of 64 submissions received by NIST, 51 were accepted
    as valid.
  prefs: []
  type: TYPE_NORMAL
- en: SHACAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A block cipher extracted from the compression function used in SHA-1\. More
    precisely, SHACAL is the keyed permutation in SHA-1’s instance of a Davies–Meyer
    construction. Likewise, SHACAL-2 is SHA-256’s block cipher; it was submitted to
    the NESSIE project and was selected.
  prefs: []
  type: TYPE_NORMAL
- en: '*SHACAL* is pronounced like the French *chacal*, meaning jackal.'
  prefs: []
  type: TYPE_NORMAL
- en: Shamir’s secret database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A list of all prime numbers—and therefore all RSA private keys—that Adi Shamir
    is rumored to have created to instantaneously break RSA. To the best of our knowledge,
    this rumor has never been confirmed or denied.
  prefs: []
  type: TYPE_NORMAL
- en: Shor’s algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A quantum algorithm that solves factoring and discrete logarithms with practical
    complexity. Shor’s algorithm is the reason the field of post-quantum cryptography
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: SHS (Secure Hash Standard)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FIPS 180-4 document that specifies the SHA-1 and SHA-2 algorithms, “for
    computing a condensed representation of electronic data (message).”
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA-3 is specified in a separate document titled “SHA-3 Standard: Permutation-Based
    Hash and Extendable-Output Functions”(FIPS 202).'
  prefs: []
  type: TYPE_NORMAL
- en: Side channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any way to obtain information about a cryptographic operation other than the
    specified output values.
  prefs: []
  type: TYPE_NORMAL
- en: Side-channel attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attack that leverages some side-channel information, either passively or
    actively, locally or remotely, based on physical or logical properties. A side-channel
    attack doesn’t necessarily require physical access to the module attacked.
  prefs: []
  type: TYPE_NORMAL
- en: Sigaba
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The American Enigma, designed in the 1930s. It was never officially broken.
  prefs: []
  type: TYPE_NORMAL
- en: Signal protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The combination of the X3DH session initialization protocol and the double ratchet
    state update and key update protocol, as used by the Signal application. A similar
    protocol was integrated in WhatsApp and Facebook Messenger, reusing libraries
    developed for Signal. The cryptographic research and engineering behind the Signal
    protocol had a major impact on secure messaging applications.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Double ratchet*](#Double-ratchet), [*X3DH*](#X3DH).
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Public-key signature, or digital signature, but different from electronic signature,
    e-signature, or electromagnetic signature. It’s sometimes sacrilegiously defined
    as *encrypting with the private key*.
  prefs: []
  type: TYPE_NORMAL
- en: Signcryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To public-key cryptography what authenticated encryption is to symmetric cryptography.
    In other words, signcryption is signature and encryption within a single primitive.
  prefs: []
  type: TYPE_NORMAL
- en: SIKE (Supersingular Isogeny Key Encapsulation)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sounds like BIKE. SIKE is also a post-quantum KEM but is based on an isogeny
    problem rather than a decoding problem.
  prefs: []
  type: TYPE_NORMAL
- en: SIKE is based on SIDH (Supersingular Isogeny Diffie–Hellman), the main isogeny-based
    key agreement scheme, and is a candidate in NIST’s post-quantum project.
  prefs: []
  type: TYPE_NORMAL
- en: See [*BIKE (Bit Flipping Key Encapsulation)*](#BIKE-Bit-Flipping-Key-Encapsulation),
    [*Isogeny-based cryptography*](#Isogeny-based-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: SIMECK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SIMON + SPECK = SIMECK. It’s a block cipher that borrows from the SIMON and
    SPECK NSA-designed ciphers to create an algorithm suitable for software- and hardware-constrained
    implementations. SIMECK is not from the NSA.
  prefs: []
  type: TYPE_NORMAL
- en: SIMON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with its brother SPECK, block ciphers designed to qualify as lightweight,
    optimized for hardware and software, respectively. SIMON would likely be used
    in many projects if it wasn’t designed by the NSA. Indeed, arguing that Caesar’s
    wife must be above suspicion, many cryptographers objected to the use of SIMON
    and SPECK after Snowden publicly questioned the NSA’s trustworthiness.
  prefs: []
  type: TYPE_NORMAL
- en: SipHash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not a hash but a pseudorandom function. SipHash is used as a secure MAC and
    is optimized for short input values. It was designed to prevent hash-flooding
    attacks against hash tables.
  prefs: []
  type: TYPE_NORMAL
- en: SIV-AES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AES in SIV mode. For some reason, it’s not called AES-SIV. Instead, it goes
    by the official name of *Synthetic Initialization Vector* (*SIV*) *Authenticated
    Encryption Using the Advanced Encryption Standard* (*AES*)*. Not to be confused
    with AES-GCM-SIV.*
  prefs: []
  type: TYPE_NORMAL
- en: '*## Skipjack'
  prefs: []
  type: TYPE_NORMAL
- en: A block cipher designed by the NSA in the late 1980s. It’s famous for its role
    in the Clipper fiasco and is currently often used as a toy cipher in cryptanalysis
    classes. Skipjack hasn’t been fully broken or shown to include a backdoor.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Clipper*.](#Clipper)
  prefs: []
  type: TYPE_NORMAL
- en: Slide attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An attack introduced in a 1999 paper that began as follows: “It is a general
    belief among the designers of block-ciphers that even a relatively weak cipher
    may become very strong if its number of rounds is made very large.”'
  prefs: []
  type: TYPE_NORMAL
- en: The paper then goes on to describe a type of attack on block ciphers that works
    regardless of the number of rounds used.
  prefs: []
  type: TYPE_NORMAL
- en: SM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A suite of Chinese national cryptographic standards, including publicly available
    algorithms that certain products in China are required to use. The SM suite includes
    elliptic-curve public-key cryptography (SM2), a hash function (SM3), a block cipher
    (SM4), and, interestingly, identity-based cryptography (SM9).
  prefs: []
  type: TYPE_NORMAL
- en: Smart contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs running on blockchain platforms. Bugs in smart contracts tend to have
    catastrophic consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Snake-oil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bruce Schneier’s snake-oil warning signs from 1999 are still applicable today:'
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-mathematical gobbledygook
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New mathematics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proprietary cryptography
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extreme cluelessness
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ridiculous key lengths
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One-time pads
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unsubstantiated claims
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security proofs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cracking contests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SNARK (succinct non-interactive argument of knowledge)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A powerful and efficient type of proof of knowledge. Introduced in the 2011
    article “From Extractable Collision Resistance to Succinct Non-Interactive Arguments
    of Knowledge, and Back Again.” It’s a variant of a SNARG (succinct non-interactive
    argument), because a SNARK is a *SNARG of knowledge*. SNARKs can, for example,
    be used for (noninteractive) delegation of computation, where a worker uses a
    SNARK to prove that they performed the correct computation.
  prefs: []
  type: TYPE_NORMAL
- en: When a SNARK is zero-knowledge, we talk of zk-SNARK, which was famously used
    in the Zcash blockchain protocol to anonymize transactions via a proof that tokens
    have been transferred from a sender to a recipient without disclosing either’s
    identity or the amount transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Post-quantum SNARKs exist but are less efficient than pre-­quantum ones.
  prefs: []
  type: TYPE_NORMAL
- en: SNIP (secret-shared non-interactive proof)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A zero-knowledge protocol with one prover and several verifiers that each holds
    a share of a proof of correctness. Each verifier holds a share of the secret value;
    the prover sends distinct proof strings to each verifier, allowing the verifiers
    to collaborate to check the validity of the secret according to some predefined
    predicate without leaking any information on said secret. SNIPs were introduced
    as a tool to build privacy-preserving aggregate statistics schemes.
  prefs: []
  type: TYPE_NORMAL
- en: SNOW 3G
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream cipher used in 3G, 4G, and 5G communications to encrypt voice communications.
    Like its early predecessor A5/1, SNOW 3G works by updating a state composed of
    feedback shift registers, which makes it simple to implement and efficient. Unlike
    A5/1, SNOW 3G is secure. A new version of SNOW 3G for 5G networks called *SNOW-V*
    was proposed in 2020 to be faster in software, because 5G relies a lot more on
    software and virtualized environments than previous standards.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Feedback shift register*](#Feedback-shift-register).
  prefs: []
  type: TYPE_NORMAL
- en: Solitaire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stream cipher created by Bruce Schneier for the novel *Cryptonomicon*. The
    novel’s characters use it without accessing a computer. As Schneier describes:'
  prefs: []
  type: TYPE_NORMAL
- en: Solitaire gets its security from the inherent randomness in a shuffled deck
    of cards. By manipulating this deck, a communicant can create a string of *random*
    letters that he then combines with his message. Of course Solitaire can be simulated
    on a computer, but it is designed to be implemented by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Solitaire is broken by today’s academic standards (it has a statistical bias),
    but it’s quite secure for a pen-and-paper cipher, and practically safe when used
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Cryptonomicon*.](#Cryptonomicon)
  prefs: []
  type: TYPE_NORMAL
- en: SPECK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An NSA lightweight cipher.
  prefs: []
  type: TYPE_NORMAL
- en: See [*SIMON*.](#SIMON)
  prefs: []
  type: TYPE_NORMAL
- en: SPEKE (Simple Password Exponential Key Exchange)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PAKE invented long before PAKEs were cool (in 1996).
  prefs: []
  type: TYPE_NORMAL
- en: SPHINCS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash-based signature scheme that, unlike XMSS, is stateless. But it’s even
    more complicated than XMSS. Gravity-SPHINCS and SPHINCS+ are SPHINCS variants
    that were submitted to NIST’s post-quantum competition. Not to be confused with
    the SPHINX mixnet.
  prefs: []
  type: TYPE_NORMAL
- en: See [*XMSS*](#XMSS-eXtended-Merkle-Signature-Scheme).
  prefs: []
  type: TYPE_NORMAL
- en: Sponge function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to design a hash function. A sponge function uses only a permutation
    algorithm—as opposed to a keyed permutation—or a block cipher. Pioneered by Keccak,
    now SHA-3, it leads to a multitude of permutation-based schemes.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Keccak*](#Keccak), [*Permutation-based cryptography*](#Permutation-based-cryptography).
  prefs: []
  type: TYPE_NORMAL
- en: SRP (Secure Remote Password)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PAKE relying on the Diffie–Hellman problem. SRP can be combined with TLS and
    is notably used in iCloud Keychain. But overall, it’s found in very few applications,
    most likely because of vulnerabilities in earlier versions of SRP, and because
    the minor security benefit is often not worth SRP’s extra complexity compared
    to a straightforward password authentication.
  prefs: []
  type: TYPE_NORMAL
- en: SSH (Secure Shell)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A secure channel over TCP. SSH relies on neither PKI nor X.509 certificates.
    Instead, it has a trust-on-first-use (TOFU) trust model. Fewer security issues
    have been found in SSH than in TLS.
  prefs: []
  type: TYPE_NORMAL
- en: SSL (Secure Socket Layer)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not TLS. SSL is the predecessor of that ubiquitous transport security protocol;
    it was designed in the 1990s by Netscape and had three versions, the first of
    which was never released because it was too insecure. SSL v2 shipped with Netscape
    Navigator 1.1 in March 1995, and SSL v3 was released shortly after to notably
    mitigate a man-in-the-middle attack (working by downgrading to a weak cipher suite).
    Nonetheless, many systems continued to support SSL v2, sometimes for backward
    compatibility. Twenty years later, the DROWN attack exploited such legacy support
    of SSL v2 to attack recent TLS versions.
  prefs: []
  type: TYPE_NORMAL
- en: See [*TLS*](#TLS-Transport-Layer-Security).
  prefs: []
  type: TYPE_NORMAL
- en: STARK (scalable transparent arguments of knowledge)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variants of SNARKs. STARKs were motivated by applications requiring efficient
    and scalable zero-knowledge proofs with fewer constraints than with SNARKs. Here
    are the main differences between STARKs and SNARKs:'
  prefs: []
  type: TYPE_NORMAL
- en: STARKs don’t require a *trusted setup*—a process that must be performed by trusted
    parties so that subsequent proofs are secure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STARKs can be safe against quantum algorithms, whereas known SNARK constructions
    usually aren’t (or with some constraints).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STARKs are a bit faster to create and a bit slower to verify.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [*SNARK (succinct non-interactive argument of knowledge)*](#SNARK-succinct-non-interactive-argument-of-knowledge).
  prefs: []
  type: TYPE_NORMAL
- en: Steganography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Covert communication techniques that belong more to the field of signal processing
    than to cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Stream cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type of cipher you can think of as a one-time pad cryptographically generated
    from a key and a (unique) nonce. The block cipher DES was designed in the 1970s
    with hardware implementations in mind; later the stream cipher RC4 was designed
    to be software friendly due to its byte-oriented mechanism. Yet in the 1990s stream
    ciphers were often thought of as *hardware ciphers* and were frequently based
    on feedback shift registers with minimal surrounding logic, like Grain or SNOW
    3G. On the other hand, block ciphers are considered software ciphers, as the AES
    competition requirements made clear in 2000\. Indeed, you’ll find stream ciphers
    used in niche, constrained applications, even before the term *lightweight cryptography*
    existed, when block ciphers were too costly.
  prefs: []
  type: TYPE_NORMAL
- en: Today, stream ciphers are no longer a niche market, and many of the encryption
    modes used in modern applications are technically stream ciphers because they
    run in CTR mode.
  prefs: []
  type: TYPE_NORMAL
- en: Substitution-permutation network (SPN)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Construction of permutations, as used in block ciphers and hash functions,
    in which a round includes two layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Substitution, typically via S-boxes, to transform chunks of blocks into other
    chunks in a nonlinear manner (that is, with a complex input–output relation).
    This strong but very local transformation is sometimes said to bring *confusion*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permutation, typically via shuffling of bits or a matrix operation to make sure
    that each output bit will eventually depend on all input bits. This is weak, but
    block-wise transformation is said to provide *diffusion*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In an SPN, these two layers are complementary, and this separation of duties
    often simplifies the analysis of the cipher and the calculation of bounds on the
    success rate of certain attack techniques. AES, Serpent, and PRESENT are examples
    of SPNs.
  prefs: []
  type: TYPE_NORMAL
- en: Suck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As defined by cryptographer Matthew Green: “In cryptography *suck* is a purely
    technical term meaning *slow*, *complex*, and *probably insecure*.”'
  prefs: []
  type: TYPE_NORMAL
- en: Sugar beet auctions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, the only known real-world application of multi-party computation
    (MPC). Sugar beet auctions occurred in Denmark in 2008 with the support of Aarhus
    University researchers. They were described in detail in the paper “Secure Multiparty
    Computation Goes Live” and cited in numerous other papers as evidence that MPC
    isn’t useless. Thanks to blockchain protocols, there are now many more MPC applications.
  prefs: []
  type: TYPE_NORMAL
- en: Suite A
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NSA’s suite of classified cryptographic algorithms and techniques. Suite
    A is used, for example, in military secure communication devices. It’s not available
    to the public.
  prefs: []
  type: TYPE_NORMAL
- en: See [*NSA (National Security Agency)*](#NSA-National-Security-Agency).
  prefs: []
  type: TYPE_NORMAL
- en: SUPERCOP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System for Unified Performance Evaluation Related to Cryptographic Operations
    and Primitives. It’s a successor of BATMAN and eBASH.
  prefs: []
  type: TYPE_NORMAL
- en: SUPERCOP estimates the optimal speed of an algorithm by trying out many different
    implementations of it. It also compiles each implementation with many different
    compiler options and then runs the compiled program multiple times to reliably
    measure its execution time. As of May 2020, SUPERCOP has benchmarked more than
    1,000 different algorithms and more than 2,800 implementations of them, as well
    as multiple compilers and compiler options.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of CPU usage, running SUPERCOP is to cryptography implementers what
    Bitcoin mining is to cryptocurrency people.
  prefs: []
  type: TYPE_NORMAL
- en: Superpolynomial complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practically impossible complexity, according to Cobham’s thesis (and empirical
    observation).
  prefs: []
  type: TYPE_NORMAL
- en: SVP (shortest vector problem)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main computational problem in lattice-based cryptography. SVP involves finding
    a combination of multidimensional vectors whose length (with respect to a given
    norm) is the smallest.
  prefs: []
  type: TYPE_NORMAL
- en: Many lattice-based cryptosystems indirectly leverage the worst-case hardness
    of an SVP-like problem, such as GapSVP, due to results relating the learning with
    errors (LWE) problem to SVP problems.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric-key cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The oldest form of post-quantum cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: T
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Theory of Cryptography Conference “focuses on paradigms, approaches, and
    techniques used to conceptualize, define, and provide solutions to natural cryptographic
    problems.”
  prefs: []
  type: TYPE_NORMAL
- en: TCC indeed covers both theoretical cryptography—an intellectually interesting
    topic but of low practical relevance, for example, when concerned with concepts
    such as quantum random oracles—and the theoretical aspects of applied cryptography,
    where fundamental results can be of high practical interest.
  prefs: []
  type: TYPE_NORMAL
- en: Researchers present peer-reviewed research papers with titles such as “Obfuscated
    Fuzzy Hamming Distance and Conjunctions from Subset Product Problems” and “Fully
    Homomorphic NIZK and NIWI Proofs.”
  prefs: []
  type: TYPE_NORMAL
- en: See [*Asiacrypt*](#ASIACRYPT), [*CHES*](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems),
    [*CRYPTO*](#CRYPTO), [*Eurocrypt*](#Eurocrypt), [*FSE*](#FSE-Fast-Software-Encryption),
    [*PKC*](#PKC), [*Real World Crypto*](#Real-World-Crypto-RWC).
  prefs: []
  type: TYPE_NORMAL
- en: Test vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alas, often the only tests found in cryptosystems’ implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Threefish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third member of the Blowfish family but very different from Blowfish and
    Twofish. It has no Feistel network, no MDS matrices, no S-box, but just an ARX
    construction allegedly inspired by ChaCha and that later inspired SipHash.
  prefs: []
  type: TYPE_NORMAL
- en: Threshold encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strictly speaking, doesn’t exist. But threshold decryption does exist. It’s
    where the decryption key is threshold-shared among *N* parties, *t* ≤ *N* of which
    must collaborate to decrypt a ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: Threshold secret-sharing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Or just secret sharing. A mechanism whereby a secret is split into *N* shares
    so that *t* ≤ *N* are required to recover the secret, and fewer than *t* don’t
    reveal information about the secret. Shamir’s method, based on polynomial interpolation,
    is the standard way to realize secret sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Verifiable secret-sharing (VSS) is a variant wherein parties can cryptographically
    verify that the correct secret has been recovered and that each party provided
    their correct share.
  prefs: []
  type: TYPE_NORMAL
- en: Threshold signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A signature scheme where signing capabilities (that is, keys) are distributed
    across *N* potential signers and where a signature requires at least *t* ≤ *N*
    signatures from distinct signers. It’s notably used for custody of cryptocurrency
    in cold storage systems of certain exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: Time AI™
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fyre Festival of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Time-lock encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cryptographic time capsule. Time-lock encryption attempts to make decryption
    impossible—even with the decryption key—until a certain date, when the algorithm
    authorizes noninteractive decryption. Like many cryptographic functionalities,
    you can achieve it using a trusted execution environment under fairly realistic
    assumptions. It’s also possible to create time-locked ciphertexts by leveraging
    so-called computational reference clocks, like those obtained from blockchains.
  prefs: []
  type: TYPE_NORMAL
- en: Time-lock puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first instance of *timed-release crypto*. It was defined in 1996 as a way
    to “send information into the future” by creating a problem whose solution is
    known by its creator but the recovery of which otherwise requires a large amount
    of computation. It later inspired time-lock encryption.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Proof of sequential work*](#Proof-of-sequential-work), [*Verifiable delay
    function (VDF)*](#Verifiable-delay-function-VDF).
  prefs: []
  type: TYPE_NORMAL
- en: Timing attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attack that takes advantage of timing differences to discover a secret and
    more generally compromise a cryptosystem’s security. Sometimes, the running time
    of the algorithm depends on the value of secret inputs, which might trigger things,
    such as if–then patterns or some other ­variable-time operation. For example,
    some processors’ arithmetic units will execute a multiplication instruction in
    fewer cycles if one of the inputs is zero. The textbook example of a timing attack
    targets square-and-multiply exponentiation (or double-and-add multiplication)
    where the private exponent (or scalar) is scanned bit per bit.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers can also exploit timing leaks to identify the outcome of a cryptographic
    operation (such as padding validation) or the type of error that occurs when no
    detailed error code is returned (as with mitigations against Manger’s attack).
  prefs: []
  type: TYPE_NORMAL
- en: TLS (Transport Layer Security)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol to establish a secure channel over TCP (and over UDP with DTLS).
    TLS used PKI, X.509 certificates, and too many cipher suites until TLS 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: See [*SSL*](#SSL-Secure-Socket-Layer), [*Heartbleed*](#Heartbleed).
  prefs: []
  type: TYPE_NORMAL
- en: Tor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of all cryptographic applications, Tor has one of the highest ratios between
    real-world impact and academic contribution and interest. The Tor anonymity network,
    also known as the *onion router*, provides untraceability guarantees if used correctly.
    Those for whom these are vital (criminals and law enforcement, as well as some
    journalists and political activists) use Tor to increase their life expectancy.
    You can also use Tor to bypass network restrictions (such as government censorship)
    and mitigate tracking and surveillance, which is why using it might get you in
    trouble in certain places.
  prefs: []
  type: TYPE_NORMAL
- en: Traitor tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encryption schemes where different parties have a different decryption key
    to decrypt the same ciphertext. Traitor tracing aims, for example, to identify
    the source of a content leak and revoke access. But in practice, pirates can use
    a simple workaround: redistribute the content rather than the key. And anyway,
    large pay-TV deployments haven’t really used purely cryptographic traitor tracing
    schemes.'
  prefs: []
  type: TYPE_NORMAL
- en: Transfinite cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cryptography over transfinite numbers, that is, infinite numbers like ℵ[0] (the
    cardinal of countable sets, such as that of integers ℕ), ![](Images/i01002.jpg)(cardinality
    of the continuum, that is, of the set of real numbers ℝ), or ℵ[1] (the cardinality
    of Ω, the set of all countable ordinal numbers—itself an uncountable set).
  prefs: []
  type: TYPE_NORMAL
- en: Transfinite cryptography describes a computational model for working with such
    infinite numbers, as well as analogues of stream ciphers, block ciphers, and hash
    functions, and public-key signatures using said hash functions (via Lamport’s
    construction).
  prefs: []
  type: TYPE_NORMAL
- en: An example of a definition is that of ℵ[0]-one-way functions, which are functions
    computable in ℵ[0] operations and *practically* *impossible* to invert with *only*ℵ[0]
    operations. If such a function takes strings of length ℵ[0] as input, there are
    therefore ![](Images/i01003.jpg) possible inputs, an uncountable number, preventing
    brute force even with infinite computational capabilities. Such a hash function
    isn’t known to exist and intuitively sounds impossible to define.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, transfinite cryptography can only be implemented in a Platonic
    universe of mathematical objects, not on your computer or on a future quantum
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: Trapdoor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not a backdoor. A trapdoor for some cryptographic function is a value, known
    to exist, that allows you to perform some operation that would otherwise be computationally
    hard. The best-known example is the RSA trapdoor permutation, which you can only
    invert using the RSA private key. A lesser-known example is that of trapdoor hash
    functions, such as VSH, for which collisions can only be found using the trapdoor.
  prefs: []
  type: TYPE_NORMAL
- en: Triple DES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Known as TDEA in NIST’s official parlance. A cipher that consists not in three
    instances of DES but in one DES encryption, one DES decryption, and a second DES
    encryption. This is designed to emulate DES, because the Triple DES engine sets
    the same key for the first two instances, which then cancel themselves out. A
    Triple DES key can be up to 3 × 64 = 192 bits long. But Triple DES can’t boast
    192-bit security, because 1) each 64-bit DES key only has 56 bits of information,
    thus bounding Triple DES’ security to 168 bits, and 2) meet-in-the-middle attacks
    can break Triple DES in approximately 2^(56 × 2) = 2^(112) operations. Like DES,
    Triple DES’ security is also limited by its 64-bit block size. So, even though
    Triple DES still found in legacy applications isn’t practically breakable, you’ve
    no reason to use it today. It fits best in crypto museums rather than modern applications.
    NIST retired Triple DES in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: Trivium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A minimalistic hardware-oriented stream cipher that uses an 80-bit key. For
    several years, its circular representation was used on the banner of the DEFCON
    conference website.
  prefs: []
  type: TYPE_NORMAL
- en: True random number generator (TRNG)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [*Pseudorandom generator (PRNG)*](#Pseudorandom-number-generator-PRNG).
  prefs: []
  type: TYPE_NORMAL
- en: Trusted third party
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution to most cryptography problems. Sometimes a trusted third party
    is inevitable, and the cryptographers’ job is to design protocols that minimize
    the level of trust required or that make any breach of trust detectable and recoverable.
  prefs: []
  type: TYPE_NORMAL
- en: Tweakable block cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A block cipher that takes an additional parameter, called the *tweak*, to ensure
    it produces different outputs with different tweaks. Unlike a key, a tweak isn’t
    necessarily secret and usually changes more often than the key. Changing the value
    of a tweak should incur only a negligible performance penalty, unlike a key change,
    which usually involves a costly key schedule operation. Tweakable block ciphers
    have been used for disk encryption, for example, and for exotic proprietary constructions
    that need additional inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The location of the best and worst discussions about cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Twofish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AES candidate and finalist. Twofish is the little brother of Blowfish and has
    128-bit-long blocks instead of 64-bit-long ones.
  prefs: []
  type: TYPE_NORMAL
- en: U
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Undeniable signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A signature that cannot be verified without the signer’s cooperation, whether
    or not the signature is valid. Verifiers shouldn’t be able to determine if a signature
    is valid without interacting with the signer, and the signer shouldn’t be able
    to convince a prover that a valid signature is invalid, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Invisible signature*](#Invisible-signature).
  prefs: []
  type: TYPE_NORMAL
- en: Universal composability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A theoretical framework for analyzing the security of combining cryptographic
    components, seeing as combining two secure protocols doesn’t automatically result
    in a secure protocol. It’s rarely applied to real use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Universal hash function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash function used in cryptography that isn’t the same as a cryptographic
    hash function. Unlike a general-purpose cryptographic hash, a universal hash function
    is parameterized by a secret key. Therefore, it’s actually a family of functions,
    like a pseudorandom function.
  prefs: []
  type: TYPE_NORMAL
- en: 'But unlike a pseudorandom function, a universal hash function isn’t pseudorandom
    in the cryptographic sense, only in the statistical sense: there exist no two
    input values *M*[1] and *M*[2] such that Hash(*M*[1]) = Hash(*M*[2]) with abnormally
    high probability.'
  prefs: []
  type: TYPE_NORMAL
- en: This property shouldn’t be mistaken for collision resistance, however. Collisions
    are usually easy to find for universal hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: Updatable encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An encryption scheme that can directly turn one ciphertext into another ciphertext,
    which can only be decrypted with a new, different key. A goal of updatable encryption
    is to perform key rotation on an untrusted system, as an alternative to the naive
    decrypt-encrypt approach.
  prefs: []
  type: TYPE_NORMAL
- en: V
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verifiable delay function (VDF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function whose computation cannot be sped up by extra parallelism or storage;
    therefore, it must be computed sequentially, like a proof of sequential work.
    But unlike the latter, VDFs admit only one solution.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Proof of sequential work*](#Proof-of-sequential-work), [*Time-lock puzzle*](#Time-lock-puzzle).
  prefs: []
  type: TYPE_NORMAL
- en: Verifiable random function (VRF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The public-key counterpart of a pseudorandom function, where the public key
    can be used to verify that the output has been computed correctly by verifying
    the proof of correctness generated along with the function’s output.
  prefs: []
  type: TYPE_NORMAL
- en: 'VRFs sound similar to public-key signatures but differ in two main aspects:
    a VRF’s result is always deterministic (whereas a message can admit many valid
    ECDSA signatures, for example), and a VRF can generate a result and a proof (where
    the proof might be randomized).'
  prefs: []
  type: TYPE_NORMAL
- en: VRFs have been used to build (theoretical versions of) lottery systems and transaction
    escrow schemes, and are used in several blockchain platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Verifiable unpredictable function (VUF)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function that somehow occupies a niche between signatures and VRFs: a VUF
    is like a VRF but isn’t necessarily pseudorandom, only unpredictable. But unlike
    a signature, there must be only one valid output for a given message. A VUF scheme
    can thus be regarded as a unique signature.'
  prefs: []
  type: TYPE_NORMAL
- en: See [*Verifiable random function (VRF)*](#Verifiable-random-function-VRF).
  prefs: []
  type: TYPE_NORMAL
- en: Vigenère cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cipher more secure than Caesar’s.
  prefs: []
  type: TYPE_NORMAL
- en: VSH (Very Smooth Hash)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash function with provable collision resistance, based on the hardness of
    factoring integers. But VSH (second) preimage resistance doesn’t have as strong
    security guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: W
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wallet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In cryptocurrencies, a set of accounts managed by a single individual or organization.
    Each account consists of a private key used for signing and an address somehow
    derived from the public key. Typically, these accounts are organized hierarchically,
    from one or more seeds, using BIP32 or a similar hierarchical derivation. This
    is convenient, because you can then manage a practically infinite number of accounts
    by storing only a single secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'By extension, a wallet refers to any application or device that implements
    account management functionalities. Hardware wallets offer the best feeling of
    security, and sometimes they really are more secure. That said, they don’t protect
    any better than software wallets against the most common risk: the lack of reliable
    backups.'
  prefs: []
  type: TYPE_NORMAL
- en: Watermarking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The practice of embedding a value in some analog information (such as an image,
    video, or sound), usually during digital encoding, in such a way that the value
    can’t be extracted or removed. In its most robust forms, it also survives noise,
    transcoding, and digital-analog-digital conversion.
  prefs: []
  type: TYPE_NORMAL
- en: White-box cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obfuscation at the algorithm level. Put otherwise, a means of implementing,
    say, AES in such a way that the implementation for a given key doesn’t reveal
    the key. This sounds like magic, and like real magic, it doesn’t actually exist,
    although advanced techniques give the illusion that it does. Most white-box techniques
    have indeed been broken, at least on paper. But in practice, they contribute to
    making reverse engineering harder, due to being supplemented by software-level
    defenses (such as software obfuscation, anti-tampering, anti-debugging, device
    binding, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, white-box cryptography is about transforming a symmetric cipher
    into an asymmetric one. If that were feasible, it would mean that we could create
    public-key encryption from a symmetric primitive, which would be surprising (despite
    the fact that we can construct public-key signatures from hash functions.)
  prefs: []
  type: TYPE_NORMAL
- en: Winternitz signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An extension of Lamport hash-based signatures that can hash values greater than
    one. For example, to hash 4-bit messages, or integers between 0 and 15, you would
    publish Hash^(16)(*K*) as a public key, and then sign a message *M* ∈ [0, 15]
    by computing Hash^(*M*)(*K*), where *M* is the number of hash iterations.
  prefs: []
  type: TYPE_NORMAL
- en: This works better than Lamport’s binary scheme, but it still doesn’t scale—just
    imagine the work involved in signing a 64-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: WireGuard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network-layer protocol for peer-to-peer secure channels that grew out of a
    kernel rootkit project. WireGuard was designed for SSH-like usage and VPN functionality.
    As per its creator’s words, WireGuard is “cryptographically opinionated,” which
    means it consists of a single suite of algorithms, as well as minimal cryptographic
    bureaucracy. Notably, it excludes certificates and thus ASN.1 or X.509 parsing.
    Unlike many projects, WireGuard has focused its efforts on cryptography and implementation
    quality with a much smaller code base than its alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Initially regarded with suspicion by the cryptographic intelligent­sia, WireGuard’s
    success and security track record now speak for themselves.
  prefs: []
  type: TYPE_NORMAL
- en: X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: X25519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Diffie–Hellman with Curve25519.
  prefs: []
  type: TYPE_NORMAL
- en: See [*Curve25519*](#Curve25519).
  prefs: []
  type: TYPE_NORMAL
- en: X3DH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extended triple Diffie–Hellman, a variant of Diffie–Hellman popularized by its
    use in the Signal protocol. X3DH combines multiple key pairs to compute one shared
    secret instead of using just one key pair per participant, as in basic Diffie–Hellman.
  prefs: []
  type: TYPE_NORMAL
- en: XMSS (eXtended Merkle Signature Scheme)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public-key signature scheme that uses only a hash function and a tree structure.
    XMSS’s statefulness—or obligation to keep track of a counter over signature operations—has
    been called *a huge foot-cannon*. Even so, XMSS has become an IETF standard and
    was experimentally integrated in OpenSSH.
  prefs: []
  type: TYPE_NORMAL
- en: See [*SPHINCS*](#SPHINCS).
  prefs: []
  type: TYPE_NORMAL
- en: XOF (extendable output function)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hash function whose output can be of variable size. The function can also
    extend the length of the output if needed. By contrast, in nonextendable, variable-size
    output functions, output values of different sizes are completely distinct, and
    the shorter ones aren’t prefixes of the longer.
  prefs: []
  type: TYPE_NORMAL
- en: XOR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exclusive OR logical operation, written as ⊕. XOR obeys the following rules:
    true XOR false equals true; true XOR true equals false; and false XOR false equal
    false. When viewed as a binary operator, the rules produce the following results:
    1 ⊕ 1 = 0 ⊕ 0 = 0, 0 ⊕ 1 = 1 ⊕ 0 = 1\. Extended to bit strings, you’d get 0111
    ⊕ 1101 = 1010, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: XOR encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A straightforward form of encryption, sometimes used in malware as an obfuscation
    layer. It’s similar to a one-time pad except that the XORed value isn’t always
    secret or used only once.
  prefs: []
  type: TYPE_NORMAL
- en: Z
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zerocash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Came after Zerocoin but before Zcash.
  prefs: []
  type: TYPE_NORMAL
- en: ZKP (zero-knowledge proof)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol where a prover convinces a verifier that they know some mathematical
    statement (such as the solution to a hard problem) without revealing said statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now a mainstream concept among crypto enthusiasts, ZKPs were once an obscure
    field at the intersection of cryptography and theoretical computer science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero-knowledge is a broad and rich discipline, arguably still in its infancy
    as far as applications are concerned. There have been a few ZKPs advancing from
    conference proceedings to the real world: these applications include e-voting
    and blockchain applications, wherein noninteractive ZKPs help protect the privacy
    of transactions. ZKPs are also a component of threshold signing schemes as used
    for certain cold storage systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic zero-knowledge shouldn’t be confused with the security engineering
    concept of zero-knowledge architecture or with the marketing term zero-knowledge
    referring to client-side encryption.
  prefs: []
  type: TYPE_NORMAL
- en: See [*NIZK (non-interactive zero-knowledge)*](#NIZK-non-interactive-zero-knowledge).
  prefs: []
  type: TYPE_NORMAL
- en: ZRTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key agreement procedure for RTP connections and used in voice-over-IP connections
    between two peers. Initially present in the Signal application to enable end-to-end
    encrypted calls, ZRTP was later discarded in favor of keys derived from the text
    messaging session state, which turned out to be simpler and more secure. The Z
    in ZRTP represents Phil Zimmermann.
  prefs: []
  type: TYPE_NORMAL
- en: Index of Terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[2013](#2013)'
  prefs: []
  type: TYPE_NORMAL
- en: '[65537](#65537)'
  prefs: []
  type: TYPE_NORMAL
- en: '[A5/0](#A5-0)'
  prefs: []
  type: TYPE_NORMAL
- en: '[A5/1](#A5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[A5/2](#A5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[A5/3](#A5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[A5/4](#A5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Adaptive attack](#Adaptive-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AEAD (authenticated encryption with associated data)](#AEAD-authenticated-encryption-with-associated-data-)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AES (Advanced Encryption Standard)](#AES-Advanced-Encryption-Standard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AES-CCM](#AES-CCM)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AES-GCM](#AES-GCM)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AES-GCM-SIV](#AES-GCM-SIV)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AES-NI](#AES-NI)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AES-SIV](#AES-SIV)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AIM (Advanced INFOSEC Machine)](#AIM-Advanced-INFOSEC-Machine)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AKA](#AKA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[AKS (Agrawal–Kayal–Saxena)](#AKS-Agrawal%E2%80%93Kayal%E2%80%93Saxena)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Algebraic cryptanalysis](#Algebraic-cryptanalysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Alice](#Alice)'
  prefs: []
  type: TYPE_NORMAL
- en: '[All-or-nothing transform (AONT)](#All-or-nothing-transform-AONT)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Anonymous signature](#Anonymous-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Applied Cryptography](#Applied-Cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Applied cryptography](#Applied-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ARC4](#ARC4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Argon2](#Argon2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ARX (Add-Rotate-XOR)](#ARX-Add-Rotate-XOR)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ASIACRYPT](#ASIACRYPT)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Asymmetric cryptography](#Asymmetric-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Attack](#Attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Attribute-based encryption (ABE)](#Attribute-based-encryption-ABE)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Authenticated cipher](#Authenticated-cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Axolotl](#Axolotl)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Backdoor](#Backdoor)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Backtracking resistance](#Backtracking-resistance)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Backward secrecy](#Backward-secrecy)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Base64](#Base64)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BassOmatic](#BassOmatic)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BB84](#BB84)'
  prefs: []
  type: TYPE_NORMAL
- en: '[bcrypt](#bcrypt)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Biclique cryptanalysis](#Biclique-cryptanalysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BIKE (Bit Flipping Key Encapsulation)](#BIKE-Bit-Flipping-Key-Encapsulation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BIP (Bitcoin improvement proposal)](#BIP-Bitcoin-improvement-proposal)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bit Gold](#Bit-Gold)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bitcoin](#Bitcoin)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Black](#Black)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BLAKE](#BLAKE)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BLAKE2](#BLAKE2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BLAKE3](#BLAKE3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bleichenbacher attack](#Bleichenbacher-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blind signature](#Blind-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Block cipher](#Block-cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blockchain](#Blockchain)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blockcipher](#Blockcipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blowfish](#Blowfish)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BLS (Boneh-Lynn-Shacham) signature](#BLS-Boneh-Lynn-Shacham-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bob](#Bob)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Boolean function](#Boolean-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Boomerang attack](#Boomerang-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[BQP (bounded-error quantum polynomial time)](#BQP-bounded-error-quantum-polynomial-time)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Braid group cryptography](#Braid-group-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Brainpool curves](#Brainpool-curves)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Break-in recovery](Images/#Break-in-recovery)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Broadcast encryption](#Broadcast-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Brute-force attack](#Brute-force-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bulletproof](#Bulletproof)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Byzantine fault tolerance](#Byzantine-fault-tolerance)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CAESAR](#CAESAR)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Caesar’s cipher](#Caesar%E2%80%99s-cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CAVP (Cryptographic Algorithm Validation Program)](#CAVP-Cryptographic-Algorithm-Validation-Program)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CBC (cipher block chaining)](#CBC-cipher-block-chaining)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CECPQ (combined elliptic-curve and post-quantum)](#CECPQ-combined-elliptic-curve-and-post-quantum)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cellular automata](#Cellular-automata)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ceremony](#Ceremony)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Certificate](#Certificate)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Certificate authority (CA)](#Certificate-authority-CA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Certificate transparency (CT)](#Certificate-transparency-CT)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ChaCha20](#ChaCha20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CHES (Conference on Cryptographic Hardware and Embedded Systems)](#CHES-Conference-on-Cryptographic-Hardware-and-Embedded-Systems)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CIA](#CIA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ciphertext stealing](#Ciphertext-stealing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clipper](#Clipper)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CMVP (Cryptographic Module Validation Program)](#CMVP-Cryptographic-Module-Validation-Program)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Code-based cryptography](#Code-based-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Commitment](#Commitment)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Concurrent zero-knowledge](#Concurrent-zero-knowledge)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Consensus protocol](#Consensus-protocol)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Control word](#Control-word)'
  prefs: []
  type: TYPE_NORMAL
- en: '[COPACOBANA (Cost-Optimized PArallel COde Breaker)](#COPACOBANA-Cost-Optimized-PArallel-COde-Breaker)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cothority (collective authority)](#Cothority-collective-authority)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptanalysis](#Cryptanalysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptids](#Cryptids)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crypto](#Crypto)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CRYPTO](#CRYPTO)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crypto AG](#Crypto-AG)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crypto period](#Crypto-period)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crypto variable](#Crypto-variable)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crypto wars](#Crypto-wars)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptobiosis](#Cryptobiosis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptocurrency](#Cryptocurrency)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crypto-Gram](#Crypto-Gram)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptography](#Cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Cryptologia*](#Cryptologia)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptology](#Cryptology)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Cryptonomicon*](#Cryptonomicon)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptorchidism](#Cryptorchidism)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cryptovirology](#Cryptovirology)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CRYPTREC](#CRYPTREC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CSIDH (Commutative Supersingular Isogeny Diffie–Hellman)](#CSIDH-Commutative-Supersingular-Isogeny-Diffie%E2%80%93Hellman)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CTF (capture the flag)](#CTF-capture-the-flag)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cube attack](#Cube-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Curve25519](#Curve25519)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Curve448](#Curve448)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cypher](#Cypher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Daemon](#Daemon)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Davies–Meyer](#Davies%E2%80%93Meyer)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Decentralized private computation](#Decentralized-private-computation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Déchiffrer](#D%C3%A9chiffrer)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Décrypter](#D%C3%A9crypter)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Deniable encryption](#Deniable-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[DES (Data Encryption Standard)](#DES-Data-Encryption-Standard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Dictionary](#Dictionary)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Dictionary attack](#Dictionary-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Differential cryptanalysis](#Differential-cryptanalysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Diffie–Hellman](#Diffie%E2%80%93Hellman)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Disclosure](#Disclosure)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Discrete logarithm problem](#Discrete-logarithm-problem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Distinguisher](#Distinguisher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Distributed randomness](#Distributed-randomness)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Dolev–Yao model](#Dolev%E2%80%93Yao-model)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Double ratchet](#Double-ratchet)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Dragonfly](#Dragonfly)'
  prefs: []
  type: TYPE_NORMAL
- en: '[DRBG (deterministic random bit generator)](#DRBG-deterministic-random-bit-generator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[DSA (Digital Signature Algorithm)](#DSA-Digital-Signature-Algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[DSS (Digital Signature Standard)](#DSS-Digital-Signature-Standard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[DVB-CSA](#DVB-CSA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[E0](#E0)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ECB (electronic codebook)](#ECB-electronic-codebook)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ECC](#ECC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ECDLP (Elliptic-curve discrete logarithm problem)](#ECDLP-Elliptic-curve-discrete-logarithm-problem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ECDSA (Elliptic-curve DSA)](#ECDSA-Elliptic-curve-DSA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ECIES (Elliptic-curve IES)](#ECIES-Elliptic-curve-IES)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ed25519](#Ed25519)'
  prefs: []
  type: TYPE_NORMAL
- en: '[EdDSA](#EdDSA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[EKMS (Electronic Key Management System)](#EKMS-Electronic-Key-Management-System)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Electronic codebook](#Electronic-codebook)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ElGamal](#ElGamal)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Elligator](#Elligator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Elliptic curve](#Elliptic-curve)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Elliptic-curve cryptography](#Elliptic-curve-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Encipherment](#Encipherment)'
  prefs: []
  type: TYPE_NORMAL
- en: '[End-to-end encryption (E2EE)](#End-to-end-encryption-E2EE)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Enigma](#Enigma)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Entropy](#Entropy)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ePrint](#ePrint)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Erathosthenes’ sieve](#Erathosthenes%E2%80%99-sieve)'
  prefs: []
  type: TYPE_NORMAL
- en: '[eSTREAM](#eSTREAM)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ethereum](#Ethereum)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Eurocrypt](#Eurocrypt)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Eve](#Eve)'
  prefs: []
  type: TYPE_NORMAL
- en: '[E-voting](#E-voting)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Factoring problem](#Factoring-problem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Feedback shift register](#Feedback-shift-register)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Feistel network](#Feistel-network)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fialka (Фиалка)](#Fialka-%D0%A4%D0%B8%D0%B0%D0%BB%D0%BA%D0%B0)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fiat–Shamir](#Fiat%E2%80%93Shamir)'
  prefs: []
  type: TYPE_NORMAL
- en: '[FIPS 140-2](#FIPS-140-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[FIPS 140-3](#FIPS-140-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Forgery](#Forgery)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Formal verification](#Formal-verification)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Format-preserving encryption](#Format-preserving-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Forward secrecy](#Forward-secrecy)'
  prefs: []
  type: TYPE_NORMAL
- en: '[FOX](#FOX)'
  prefs: []
  type: TYPE_NORMAL
- en: '[FSE (Fast Software Encryption)](#FSE-Fast-Software-Encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fully homomorphic encryption](#Fully-homomorphic-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Functional encryption](#Functional-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Future secrecy](#Future-secrecy)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fuzzy extractor](#Fuzzy-extractor)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Generalized birthday problem](#Generalized-birthday-problem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[GNFS (General Number Field Sieve)](#GNFS-General-Number-Field-Sieve)'
  prefs: []
  type: TYPE_NORMAL
- en: '[GOST](#GOST)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Grain](#Grain)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Gröbner basis](#Gr%C3%B6bner-basis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Group signature](#Group-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Grover’s algorithm](#Grover%E2%80%99s-algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hardcore predicate](#Hardcore-predicate)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hash function](#Hash-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hash-based cryptography](#Hash-based-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Heartbleed](#Heartbleed)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hedged signature](#Hedged-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HFE (Hidden Field Equations)](#HFE-Hidden-Field-Equations)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HMAC (Hash-based MAC)](#HMAC-Hash-based-MAC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Homomorphic encryption](#Homomorphic-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HPC (Hasty Pudding Cipher)](#HPC-Hasty-Pudding-Cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HSM (hardware security module)](#HSM-hardware-security-module)'
  prefs: []
  type: TYPE_NORMAL
- en: '[HTTP/3](#HTTP-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hyperelliptic-curve cryptography](#Hyperelliptic-curve-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IACR (International Association for Cryptologic Research)](#IACR-International-Association-for-Cryptologic-Research)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IDEA (International Data Encryption Algorithm)](#IDEA-International-Data-Encryption-Algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IDEA NXT](#IDEA-NXT)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Identity-based encryption](#Identity-based-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IES (Integrated Encryption Scheme)](#IES-Integrated-Encryption-Scheme)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Impatient saboteur](#Impatient-saboteur)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Impossibility](#Impossibility)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Impossible differential attack](#Impossible-differential-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IND-CCA](#IND-CCA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IND-CPA](#IND-CPA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Indelibility](#Indelibility)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Indifferentiability](#Indifferentiability)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Indistinguishability](#Indistinguishability)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Indistinguishability obfuscation (iO)](#Indistinguishability-obfuscation-iO)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Information-theoretic security](#Information-theoretic-security)'
  prefs: []
  type: TYPE_NORMAL
- en: '[INT-CTXT](#INT-CTXT)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Invisible signature](#Invisible-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IOTA](#IOTA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IPES (Improved Proposed Encryption Standard)](#IPES-Improved-Proposed-Encryption-Standard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IPSec](#IPSec)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ISO standard](#ISO-standard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Isogeny-based cryptography](#Isogeny-based-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Journal of Cryptology* (JoC)](#Journal-of-Cryptology-JoC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[KASUMI](#KASUMI)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Keccak](#Keccak)'
  prefs: []
  type: TYPE_NORMAL
- en: '[KeeLoq](#KeeLoq)'
  prefs: []
  type: TYPE_NORMAL
- en: '[KEM (key encapsulation mechanism)](#KEM-key-encapsulation-mechanism)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kerberos](#Kerberos)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kerckhoffs’ principles](#Kerckhoffs%E2%80%99-principles)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key derivation function (KDF)](#Key-derivation-function-KDF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key escrow](#Key-escrow)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key management](#Key-management)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key wrapping](#Key-wrapping)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kleptography](#Kleptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Known-key attack](#Known-key-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Kupyna (Купина)](#Kupyna-%D0%9A%D1%83%D0%BF%D0%B8%D0%BD%D0%B0)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Laconic zero-knowledge proof](#Laconic-zero-knowledge-proof)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lai–Massey](#Lai%E2%80%93Massey)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lamport signature](#Lamport-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lattice-based cryptography](#Lattice-based-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Le Chiffre](#Le-Chiffre)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Leakage-resilient cryptography](#Leakage-resilient-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Learning with errors (LWE)](#Learning-with-errors-LWE)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Length extension attack](#Length-extension-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Length-preserving encryption](#Length-preserving-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[LFSR (linear feedback shift register)](#LFSR-linear-feedback-shift-register)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lightweight cryptography](#Lightweight-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Linear cryptanalysis](#Linear-cryptanalysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Linkability](#Linkability)'
  prefs: []
  type: TYPE_NORMAL
- en: '[LM hash](#LM-hash)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Luby–Rackoff](#Luby%E2%80%93Rackoff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lucifer](#Lucifer)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MAC (message authentication code)](#MAC-message-authentication-code)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MAGENTA](#MAGENTA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Malleability](#Malleability)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Manger attack](#Manger-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Man-in-the-middle](#Man-in-the-middle)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MASH (Modular Arithmetic Secure Hash)](#MASH-Modular-Arithmetic-Secure-Hash)'
  prefs: []
  type: TYPE_NORMAL
- en: '[McEliece encryption scheme](#McEliece-encryption-scheme)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MD4](#MD4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MD5](#MD5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MDC (Message Digest Cipher)](#MDC-Message-Digest-Cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MDC-2 (Modification Detection Code 2)](#MDC-2-Modification-Detection-Code-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Meet-in-the-middle](#Meet-in-the-middle)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Merkle puzzle](#Merkle-puzzle)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Merkle tree](#Merkle-tree)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Merkle–Damgård construction](#Merkle%E2%80%93Damg%C3%A5rd-construction)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mersenne twister](#Mersenne-twister)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Message franking](#Message-franking)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Miller–Rabin](#Miller%E2%80%93Rabin)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MINERVA](#MINERVA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mining](#Mining)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Misuse resistance](#Misuse-resistance)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mixnet](#Mixnet)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MQV (Menezes–Qu–Vanstone)](#MQV-Menezes%E2%80%93Qu%E2%80%93Vanstone)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Multicollision](#Multicollision)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Multi-party computation (MPC)](#Multi-party-computation-MPC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Multivariate cryptography](#Multivariate-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NBS (National Bureau of Standards)](#NBS-National-Bureau-of-Standards)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NESSIE (New European Schemes for Signatures, Integrity, and Encryption)](#NESSIE-New-European-Schemes-for-Signatures,-Integrity,-and-Encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[“New Directions in Cryptography”](#New-Directions-in-Cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NFSR (nonlinear feedback shift register)](#NFSR-nonlinear-feedback-shift-register)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NIST (National Institute of Standards and Technology)](#NIST-National-Institute-of-Standards-and-Technology)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NIZK (non-interactive zero-knowledge)](#NIZK-non-interactive-zero-knowledge)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Noekeon](#Noekeon)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Noise](#Noise)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Nonce](#Nonce)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Non-committing encryption](#Non-committing-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Non-outsourceability](#Non-outsourceability)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Non-slanderability](#Non-slanderability)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NSA (National Security Agency)](#NSA-National-Security-Agency)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NT hash](#NT-hash)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NTRU (*N*th degree Truncated polynomial Ring Units)](#NTRU-Nth-degree-Truncated-polynomial-Ring-Units)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Null cipher](#Null-cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[OAEP (Optimal Asymmetric Encryption Padding)](#OAEP-Optimal-Asymmetric-Encryption-Padding)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oblivious key management system (OKMS)](#Oblivious-key-management-system-OKMS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oblivious PRF (OPRF)](#Oblivious-PRF-OPRF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oblivious RAM (ORAM)](#Oblivious-RAM-ORAM)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oblivious transfer](#Oblivious-transfer)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Obscurity](#Obscurity)'
  prefs: []
  type: TYPE_NORMAL
- en: '[OCB (offset codebook mode)](#OCB-offset-codebook-mode)'
  prefs: []
  type: TYPE_NORMAL
- en: '[One-time pad](#One-time-pad)'
  prefs: []
  type: TYPE_NORMAL
- en: '[One-way function](#One-way-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Onion-AE](#Onion-AE)'
  prefs: []
  type: TYPE_NORMAL
- en: '[OPAQUE](#OPAQUE)'
  prefs: []
  type: TYPE_NORMAL
- en: '[OpenSSL](#OpenSSL)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle](#Oracle)'
  prefs: []
  type: TYPE_NORMAL
- en: '[OTR (Off-the-Record)](#OTR-Off-the-Record)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Padding oracle attack](#Padding-oracle-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Paillier cryptosystem](#Paillier-cryptosystem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pairing](#Pairing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pairing-based cryptography](#Pairing-based-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PAKE (password-authenticated key exchange)](#PAKE-password-authenticated-key-exchange)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Paradigm](#Paradigm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Password hash function](#Password-hash-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PBKDF2 (Password-Based Key Derivation Function 2)](#PBKDF2-Password-Based-Key-Derivation-Function-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PCT (Private Communications Technology)](#PCT-Private-Communications-Technology)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PEP (Plaintext equivalence proof)](#PEP-Plaintext-equivalence-proof)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Perfect forward secrecy](#Perfect-forward-secrecy)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Permutation-based cryptography](#Permutation-based-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PES (Proposed Encryption Standard)](#PES-Proposed-Encryption-Standard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PET (Plaintext equivalence test)](#PET-Plaintext-equivalence-test)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PFS](#PFS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PGP (Pretty Good Privacy)](#PGP-Pretty-Good-Privacy)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Photuris](#Photuris)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Picnic](#Picnic)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PKC](#PKC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PKCS (Public Key Cryptography Standards)](#PKCS-Public-Key-Cryptography-Standards)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Poly1305](#Poly1305)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Polynomial complexity](#Polynomial-complexity)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Post-compromise security](#Post-compromise-security)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Post-quantum cryptography](#Post-quantum-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Post-quantum RSA](#Post-quantum-RSA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Prediction resistance](#Prediction-resistance)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Preimage](#Preimage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRESENT](#PRESENT)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRIMES](#PRIMES)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Privacy-preserving](#Privacy-preserving)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Private information retrieval (PIR)](#Private-information-retrieval-PIR)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of burn](#Proof-of-burn)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of catalytic space](#Proof-of-catalytic-space)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of human work](#Proof-of-human-work)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of replication](#Proof-of-replication)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of reserve](#Proof-of-reserve)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of security](#Proof-of-security)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of sequential work](#Proof-of-sequential-work)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of space](#Proof-of-space)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of spacetime](#Proof-of-spacetime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of stake](#Proof-of-stake)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of storage](#Proof-of-storage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of useful work](#Proof-of-useful-work)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proof of work](#Proof-of-work)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Provable security](#Provable-security)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Provably secure](#Provably-secure)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Proxy re-encryption](#Proxy-re-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pseudo-random](#Pseudo-random)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pseudorandom function (PRF)](#Pseudorandom-function-PRF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pseudorandom number generator (PRNG)](#Pseudorandom-number-generator-PRNG)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pseudorandom permutation (PRP)](#Pseudorandom-permutation-PRP)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Public-key cryptography](#Public-key-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PUF (physically unclonable function)](#PUF-physically-unclonable-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Puncturable encryption](#Puncturable-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Puncturable pseudorandom function (PPRF)](#Puncturable-pseudorandom-function-PPRF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum computer](#Quantum-computer)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum cryptography](#Quantum-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum encryption](#Quantum-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum key distribution](#Quantum-key-distribution)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantum signature](#Quantum-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[QUIC (Quick UDP Internet Connections)](#QUIC-Quick-UDP-Internet-Connections)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rabin cryptosystem](#Rabin-cryptosystem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rainbow tables](#Rainbow-tables)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Random bits](#Random-bits)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Random oracle](#Random-oracle)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Randomness](#Randomness)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Range proof](#Range-proof)'
  prefs: []
  type: TYPE_NORMAL
- en: '[RC4](#RC4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[RC5](#RC5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[RC6](#RC6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Real world](#Real-world)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Real World Crypto (RWC)](#Real-World-Crypto-RWC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rectangle attack](#Rectangle-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Related-key attack](#Related-key-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Research papers](#Research-papers)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Revocation](#Revocation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rijndael](#Rijndael)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ring signature](#Ring-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[RIPEMD-160](#RIPEMD-160)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rivest–Shamir–Adleman](#Rivest%E2%80%93Shamir%E2%80%93Adleman)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ROBOT (Return Of Bleichenbacher’s Oracle Threat)](#ROBOT-Return-Of-Bleichenbacher%E2%80%99s-Oracle-Threat)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ROS](#ROS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[RSA](#RSA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rubber-hose cryptanalysis](#Rubber-hose-cryptanalysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Rumba20](#Rumba20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SAEP (Simplified OAEP)](#SAEP-Simplified-OAEP)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Salsa20](#Salsa20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sandwich attack](#Sandwich-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[S-box](#S-box)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Scalar](#Scalar)'
  prefs: []
  type: TYPE_NORMAL
- en: '[sci.crypt](#sci.crypt)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Scrambler](#Scrambler)'
  prefs: []
  type: TYPE_NORMAL
- en: '[scrypt](#scrypt)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Searchable encryption](#Searchable-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[secp256k1](#secp256k1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Secret sharing](#Secret-sharing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Security](#Security)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Security proof](#Security-proof)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Semantic security](#Semantic-security)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Serious Cryptography*](#Serious-Cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Serpent](#Serpent)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SHA-0](#SHA-0)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SHA-1](#SHA-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SHA-2](#SHA-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SHA-3](#SHA-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SHA-3 competition](#SHA-3-competition)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SHACAL](#SHACAL)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Shamir’s secret database](#Shamir%E2%80%99s-secret-database)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Shor’s algorithm](#Shor%E2%80%99s-algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SHS (Secure Hash Standard)](#SHS-Secure-Hash-Standard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Side channel](#Side-channel)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Side-channel attack](#Side-channel-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sigaba](#Sigaba)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Signal protocol](#Signal-protocol)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Signature](#Signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Signcryption](#Signcryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SIKE (Supersingular Isogeny Key Encapsulation)](#SIKE-Supersingular-Isogeny-Key-Encapsulation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SIMECK](#SIMECK)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SIMON](#SIMON)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SipHash](#SipHash)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SIV-AES](#SIV-AES)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Skipjack](#Skipjack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Slide attack](#Slide-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SM](#SM)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Smart contract](#Smart-contract)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Snake-oil](#Snake-oil)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SNARK (succinct non-interactive argument of knowledge)](#SNARK-succinct-non-interactive-argument-of-knowledge)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SNIP (secret-shared non-interactive proof)](#SNIP-secret-shared-non-interactive-proof)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SNOW 3G](#SNOW-3G)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Solitaire](#Solitaire)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SPECK](#SPECK)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SPEKE (Simple Password Exponential Key Exchange)](#SPEKE-Simple-Password-Exponential-Key-Exchange)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SPHINCS](#SPHINCS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sponge function](#Sponge-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SRP (Secure Remote Password)](#SRP-Secure-Remote-Password)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SSH (Secure Shell)](#SSH-Secure-Shell)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SSL (Secure Socket Layer)](#SSL-Secure-Socket-Layer)'
  prefs: []
  type: TYPE_NORMAL
- en: '[STARK (scalable transparent arguments of knowledge)](#STARK-scalable-transparent-arguments-of-knowledge)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Steganography](#Steganography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Stream cipher](#Stream-cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Substitution-permutation network (SPN)](#Substitution-permutation-network-SPN)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Suck](#Suck)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sugar beet auctions](#Sugar-beet-auctions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Suite A](#Suite-A)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SUPERCOP](#SUPERCOP)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Superpolynomial complexity](#Superpolynomial-complexity)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SVP (shortest vector problem)](#SVP-shortest-vector-problem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Symmetric-key cryptography](#Symmetric-key-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[TCC](#TCC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Test vectors](#Test-vectors)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Threefish](#Threefish)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Threshold encryption](#Threshold-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Threshold secret-sharing](#Threshold-secret-sharing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Threshold signature](#Threshold-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Time AI](#Time-AI%E2%84%A2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Time-lock encryption](#Time-lock-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Time-lock puzzle](#Time-lock-puzzle)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Timing attack](#Timing-attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '[TLS (Transport Layer Security)](#TLS-Transport-Layer-Security)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Tor](#Tor)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Traitor tracing](#Traitor-tracing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Transfinite cryptography](#Transfinite-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Trapdoor](#Trapdoor)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Triple DES](#Triple-DES)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Trivium](#Trivium)'
  prefs: []
  type: TYPE_NORMAL
- en: '[True random number generator (TRNG)](#True-random-number-generator-TRNG)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Trusted third party](#Trusted-third-party)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Tweakable block cipher](#Tweakable-block-cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Twitter](#Twitter)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Twofish](#Twofish)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Undeniable signature](#Undeniable-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Universal composability](#Universal-composability)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Universal hash function](#Universal-hash-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Updatable encryption](#Updatable-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Verifiable delay function (VDF)](#Verifiable-delay-function-VDF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Verifiable random function (VRF)](#Verifiable-random-function-VRF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Verifiable unpredictable function (VUF)](#Verifiable-unpredictable-function-VUF)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Vigenère cipher](#Vigenere-cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[VSH (Very Smooth Hash)](#VSH-Very-Smooth-Hash)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Wallet](#Wallet)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Watermarking](#Watermarking)'
  prefs: []
  type: TYPE_NORMAL
- en: '[White-box cryptography](#White-box-cryptography)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Winternitz signature](#Winternitz-signature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[WireGuard](#WireGuard)'
  prefs: []
  type: TYPE_NORMAL
- en: '[X25519](#X25519)'
  prefs: []
  type: TYPE_NORMAL
- en: '[X3DH](#X3DH)'
  prefs: []
  type: TYPE_NORMAL
- en: '[XMSS (eXtended Merkle Signature Scheme)](#XMSS-eXtended-Merkle-Signature-Scheme)'
  prefs: []
  type: TYPE_NORMAL
- en: '[XOF (extendable output function)](#XOF-extendable-output-function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[XOR](#XOR)'
  prefs: []
  type: TYPE_NORMAL
- en: '[XOR encryption](#XOR-encryption)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Zerocash](#Zerocash)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ZKP (zero-knowledge proof)](#ZKP-zero-knowledge-proof)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ZRTP](#ZRTP)****'
  prefs: []
  type: TYPE_NORMAL
