<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_201"/><span class="big">11</span><br/>DIFFIE–HELLMAN</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">In November 1976, Stanford researchers Whitfield Diffie and Martin Hellman published a research paper titled “New Directions in Cryptography” that revolutionized cryptography forever. In their paper, they introduced the notion of public-key encryption and signatures, though they didn’t actually have any of those schemes; they simply had what they termed a <em>public-key distribution scheme</em>, a protocol that allows two parties to establish a shared secret by exchanging information visible to an eavesdropper. This protocol is now known as the <em>Diffie–Hellman (DH) protocol</em>.</p>
<p class="indent">Prior to Diffie–Hellman, establishing a shared secret required performing tedious procedures such as manually exchanging sealed envelopes. Once communicating parties have established a shared secret value with the DH protocol, that secret can be used to establish a <em>secure channel</em> by turning the secret into one or more symmetric keys that are then used to <span epub:type="pagebreak" id="page_202"/>encrypt and authenticate subsequent communication. The DH protocol—and its variants—are therefore called key agreement protocols.</p>
<p class="indent">In the first part of this chapter, I review the mathematical foundations of the Diffie–Hellman protocol, including the computational problems that DH relies on to perform its magic. I then describe different versions of the Diffie–Hellman protocol used to create secure channels in the second part of this chapter. Finally, because Diffie–Hellman schemes are only secure when their parameters are well chosen, I conclude the chapter by examining scenarios where Diffie–Hellman can fail.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Diffie and Hellman received the prestigious Turing Award in 2015 for their invention of public-key cryptography and digital signatures, but others deserve credit as well. In 1974, two years before the seminal Diffie–Hellman paper, computer scientist Ralph Merkle introduced the idea of public-key cryptography with what are now called Merkle’s puzzles. Around that same year, researchers at GCHQ (Government Communications Headquarters), the British equivalent of the NSA, had also discovered the principles behind RSA and Diffie–Hellman key agreement, though that fact would only be declassified decades later.</em></p>
</div>
<h3 class="h3" id="lev1sec74">The Diffie–Hellman Function</h3>
<p class="noindent">In order to understand DH key agreement protocols, you must first understand their core operation, the <em>DH</em> <em>function</em>. The DH function will usually work with groups denoted <strong>Z</strong><sub><em>p</em></sub><sup>*</sup>. Recall from <a href="ch09.xhtml#ch9">Chapter 9</a> that these groups are formed of nonzero integer numbers modulo a prime number, denoted <em>p</em>. Another public parameter is the <em>base number</em>, <em>g</em>. All arithmetic operations are performed modulo <em>p</em>.</p>
<p class="indent">The DH function involves two private values chosen randomly by the two communicating parties from the group <strong>Z</strong><sub><em>p</em></sub><sup>*</sup>, denoted <em>a</em> and <em>b</em>. A private value <em>a</em> has a public value associated with <em>A</em> = <em>g</em><sup><em>a</em></sup> mod <em>p</em>, or <em>g</em> raised to the power <em>a</em> modulo <em>p</em>. This value is sent to the other party through a message that is visible to eavesdroppers. The public value associated with <em>b</em> is <em>B</em> = <em>g</em><sup><em>b</em></sup> mod <em>p</em>, or <em>g</em> raised to the power <em>b</em> modulo <em>p</em>, which is sent to the owner of <em>a</em> through a publicly readable message.</p>
<p class="indent">DH works its magic by combining either public value with the other private value, such that the result is the same in both cases: <em>A</em><sup><em>b</em></sup> = (<em>g</em><sup><em>a</em></sup>)<sup><em>b</em></sup> = <em>g</em><sup><em>ab</em></sup> and <em>B</em> <sup><em>a</em></sup> = (<em>g</em><sup><em>b</em></sup>)<sup><em>a</em></sup> = <em>g</em><sup><em>ba</em></sup> = <em>g</em><sup><em>ab</em></sup>. The resulting value, <em>g</em><sup><em>ab</em></sup>, is the <em>shared secret</em>; it is then passed to a <em>key derivation function (KDF)</em> in order to generate one or more shared symmetric keys. A KDF is a kind of hash function that will return a random-looking string the size of the desired key length.</p>
<p class="indent">And that’s it. Like many great scientific discoveries (gravity, relativity, quantum computing, or RSA), the Diffie–Hellman trick is terribly simple in hindsight.</p>
<p class="indent">Diffie–Hellman’s simplicity can be deceiving, however. For one thing, it won’t work with just any prime <em>p</em> or base number <em>g</em>. For example, some values of <em>g</em> will restrict the shared secrets <em>g</em><sup><em>ab</em></sup> to a small subset of possible <span epub:type="pagebreak" id="page_203"/>values, whereas you’d expect to have about as many possible values as elements in <strong>Z</strong><sub><em>p</em></sub><sup>*</sup>, and therefore as many possible values for the shared secret. To ensure the highest security, safe DH parameters should work with a prime <em>p</em> such that (<em>p</em> – 1) / 2 is also prime. Such a <em>safe prime</em> guarantees that the group doesn’t have small subgroups that would make DH easier to break. With a safe prime, DH can notably work with <em>g</em> = 2, which makes computations slightly faster. But generating a safe prime <em>p</em> takes more time than generating a totally random prime.</p>
<p class="indent">For example, the <code>dhparam</code> command of the OpenSSL toolkit will only generate safe DH parameters, but the extra checks built into the algorithm result increase the execution time considerably, as shown in <a href="ch11.xhtml#ch11list1">Listing 11-1</a>.</p>
<pre>$ <span class="codestrong">time openssl dhparam 2048</span><br/>Generating DH parameters, 2048 bit long safe prime, generator 2<br/>This is going to take a long time<br/>--<span class="codeitalic">snip</span>--<br/>-----BEGIN DH PARAMETERS-----<br/>MIIBCAKCAQEAoSIbyA9e844q7V89rcoEV8vd/l2svwhIIjG9EPwWWr7FkfYhYkU9<br/>fRNttmilGCTfxc9EDf+4dzw+AbRBc6oOL9gxUoPnOd1/G/YDYgyplF5M3xeswqea<br/>SD+B7628pWTaCZGKZham7vmiN8azGeaYAucckTkjVWceHVIVXe5fvU74k7+C2wKk<br/>iiyMFm8th2zm9W/shiKNV2+SsHtD6r3ZC2/hfu7XdOI4iT6ise83YicU/cRaDmK6<br/>zgBKn3SlCjwL4M3+m1J+Vh0UFz/nWTJ1IWAVC+aoLK8upqRgApOgHkVqzP/CgwBw<br/>XAOE8ncQqroJ0mUSB5eLqfpAvyBWpkrwQwIBAg==<br/>-----END DH PARAMETERS-----<br/>openssl dhparam 2048  154.53s user 0.86s system 99% cpu 2:36.85 total</pre>
<p class="figcap"><a id="ch11list1"/><em>Listing 11-1: Measuring the execution time of generating 2048-bit Diffie–Hellman parameters with the OpenSSL toolkit</em></p>
<p class="indentt">As you can see in <a href="ch11.xhtml#ch11list1">Listing 11-1</a>, it took 154.53 seconds to generate the DH parameters using the OpenSSL toolkit. Now, for the sake of comparison, <a href="ch11.xhtml#ch11list2">Listing 11-2</a> shows how long it takes on the same system to generate RSA parameters of the same size (that is, two prime numbers, <em>p</em> and <em>q</em>, each half the size of the <em>p</em> used for DH).</p>
<pre>$ <span class="codestrong">time openssl genrsa 2048</span><br/>Generating RSA private key, 2048 bit long modulus<br/>...................................................+++<br/>.............................................................+++<br/>e is 65537 (0x10001)<br/>-----BEGIN RSA PRIVATE KEY-----<br/>--<span class="codeitalic">snip</span>--<br/>-----END RSA PRIVATE KEY-----<br/>openssl genrsa 2048  0.16s user 0.01s system 95% cpu 0.171 total</pre>
<p class="figcap"><a id="ch11list2"/><em>Listing 11-2: Generating 2048-bit RSA parameters while measuring the execution time</em></p>
<p class="indentt">Generating DH parameters took about 1000 times longer than generating RSA parameters of the same security level, mainly due to the extra constraint imposed on the prime generated to create DH parameters.</p>
<h3 class="h3" id="lev1sec75"><span epub:type="pagebreak" id="page_204"/>The Diffie–Hellman Problems</h3>
<p class="noindent">The security of DH protocols relies on the hardness of computational problems, especially on that of the discrete logarithm problem (DLP) introduced in <a href="ch09.xhtml#ch9">Chapter 9</a>. Clearly, DH can be broken by recovering the private value <em>a</em> from its public value <em>g</em><sup><em>a</em></sup>, which boils down to solving a DLP instance. But we don’t care only about the discrete logarithm problem when using DH to compute shared secrets. We also care about two DH-specific problems, as explained next.</p>
<h4 class="h4" id="lev2sec135"><em>The Computational Diffie–Hellman Problem</em></h4>
<p class="noindent">The <em>computational Diffie–Hellman (CDH)</em> problem is that of computing the shared secret <em>g</em><sup><em>ab</em></sup> given only the public values <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup>, and not any of the secret values <em>a</em> or <em>b</em>. The motivation is obviously to ensure that even if an eavesdropper captures <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup>, they should not be able to determine the shared secret <em>g</em><sup><em>ab</em></sup>.</p>
<p class="indent">If you can solve DLP, then you can also solve CDH; to put it simply, if you can solve DLP, then given <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup>, you’ll be able to derive <em>a</em> and <em>b</em> to compute <em>g</em><sup><em>ab</em></sup>. In other words, DLP is <em>at least</em> as hard as CDH. But we don’t know for sure whether CDH is at least as hard as DLP, which would make the problems equally hard. In other words, DLP is to CDH what the factoring problem is to the RSA problem. (Recall that factoring allows you to solve the RSA problem, but not necessarily the converse.)</p>
<p class="indent">Diffie–Hellman shares another similarity with RSA in that DH will deliver the same security level as RSA for a given modulus size. For example, the DH protocol with a 2048-bit prime <em>p</em> will get you about the same security that RSA with a 2048-bit modulus <em>n</em> offers, which is about 90 bits. Indeed, the fastest way we know to break CDH is to solve DLP using an algorithm called the <em>number field sieve</em>, a method similar but not identical to the fastest one that breaks RSA by factoring its modulus: the general number field sieve (GNFS).</p>
<h4 class="h4" id="lev2sec136"><em>The Decisional Diffie–Hellman Problem</em></h4>
<p class="noindent">Sometimes we need something stronger than CDH’s hardness assumption. For example, imagine that an attacker can compute the first 32 bits of <em>g</em><sup><em>ab</em></sup> given the 2048-bit values of <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup>, but that they can’t compute all 2048 bits. Although CDH would still be unbroken because 32 bits aren’t enough to completely recover <em>g</em><sup><em>ab</em></sup>, the attacker would still have learned something about the shared secret, which might still allow them to compromise an application’s security.</p>
<p class="indent">To ensure that an attacker can’t learn anything about the shared secret <em>g</em><sup><em>ab</em></sup>, this value needs only to be indistinguishable from a random group element, just as an encryption scheme is secure when ciphertexts are indistinguishable from random strings. The computational problem formalizing this intuition is called the <em>decisional Diffie–Hellman (DDH)</em> problem. Given <em>g</em><sup><em>a</em></sup>, <em>g</em><sup><em>b</em></sup>, and a value that is either <em>g</em><sup><em>ab</em></sup> or <em>g</em><sup><em>c</em></sup> for some random <em>c</em> (each of the two with a chance of 1/2), the DDH problem consists of <span epub:type="pagebreak" id="page_205"/>determining whether <em>g</em><sup><em>ab</em></sup> (the shared secret corresponding to <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup>) was chosen. The assumption that no attacker can solve DDH efficiently is called the <em>decisional Diffie–Hellman assumption</em><em>.</em></p>
<p class="indent">If DDH is hard, then CDH is also hard, and you can’t learn anything about <em>g</em><sup><em>ab</em></sup>. But if you can solve CDH, you can also solve DDH: given a triplet (<em>g</em><sup><em>a</em></sup>, <em>g</em><sup><em>b</em></sup>, <em>g</em><sup><em>c</em></sup>), you would be able to derive <em>g</em><sup><em>ab</em></sup> from <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup> and check whether the result is equal to the given <em>g</em><sup><em>c</em></sup>. The bottom line is that DDH is fundamentally less hard than CDH, yet DDH hardness is a prime assumption in cryptography, and one of the most studied. We can be confident that both CDH and DDH are hard when Diffie–Hellman parameters are well chosen.</p>
<h4 class="h4" id="lev2sec137"><em>More Diffie–Hellman Problems</em></h4>
<p class="noindent">Sometimes cryptographers devise new schemes and prove that they are at least as hard to break as it is to solve some problem related to CDH or DDH but not identical to either of these. Ideally, we’d like to demonstrate that breaking a cryptosystem is as hard as solving CDH or DDH, but this isn’t always possible with advanced cryptographic mechanisms, typically because such schemes involve more complex operations than basic Diffie–Hellman protocols.</p>
<p class="indent">For example, in one DH-like problem, given <em>g</em><sup><em>a</em></sup>, an attacker would attempt to compute <em>g</em><sup>1/<em>a</em></sup>, where 1/<em>a</em> is the inverse of <em>a</em> in the group (typically <strong>Z</strong><sub><em>p</em></sub><sup>*</sup> for some prime <em>p</em>). In another, an attacker might distinguish the pairs (<em>g</em><sup><em>a</em></sup>, <em>g</em><sup><em>b</em></sup>) from the pairs (<em>g</em><sup><em>a</em></sup>, <em>g</em><sup>1/<em>a</em></sup>) for random <em>a</em> and <em>b</em>. Finally, in what is called the <em>twin Diffie–Hellman problem</em>, given <em>g</em><sup><em>a</em></sup>, <em>g</em><sup><em>b</em></sup>, and <em>g</em><sup><em>c</em></sup>, an attacker would attempt to compute the two values <em>g</em><sup><em>ab</em></sup> and <em>g</em><sup><em>ac</em></sup>. Sometimes such DH variants turn out to be as hard as CDH or DDH, and sometimes they’re fundamentally easier—and therefore provide lower security guarantees. As an exercise, try to find connections between the hardness of these problems and that of CDH and DDH. (Twin Diffie–Hellman is actually <em>as hard</em> as CDH, but that isn’t easy to prove!)</p>
<h3 class="h3" id="lev1sec76">Key Agreement Protocols</h3>
<p class="noindent">The Diffie–Hellman problem is designed to build secure key agreement protocols—protocols designed to secure communication between two or more parties communicating over a network with the aid of a shared secret. This secret is turned into one or more <em>session keys</em>—symmetric keys used to encrypt and authenticate the information exchanged for the duration of the session. But before studying actual DH protocols, you should know what makes a key agreement protocol secure or insecure, and how simpler protocols work. We’ll begin our discussion with a widely used key agreement protocol that doesn’t rely on DH.</p>
<h4 class="h4" id="lev2sec138"><em>An Example of Non-DH Key Agreement</em></h4>
<p class="noindent">To give you a sense of how a key agreement protocol works and what it means for it to be secure, let’s look at the protocol used in the 3G and 4G <span epub:type="pagebreak" id="page_206"/>telecommunications standards to establish communication between a SIM card and a telecom operator. The protocol is often referred to as <em>AKA</em>, for <em>authenticated key agreement</em>. It doesn’t use the Diffie–Hellman function, but instead uses only symmetric-key operations. The details are a bit boring, but essentially the protocol works as shown in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>.</p>
<div class="image"><img src="../images/f11-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch11fig1"/><em>Figure 11-1: The authenticated key agreement protocol in 3G and 4G telecommunication</em></p>
<p class="indentt">In this implementation of the protocol, the SIM card has a secret key, <em>K</em>, that the operator knows. The operator begins the session by selecting a random value, <em>R</em>, and then computes two values, <em>SK</em> and <em>V</em><sub>1</sub>, based on two pseudorandom functions, <strong>PRF</strong>0 and <strong>PRF</strong>1. Next, the operator sends a message to the SIM card containing the values <em>R</em> and <em>V</em><sub>1</sub>, which are visible to attackers. Once the SIM card has <em>R</em>, it has what it needs in order to compute <em>SK</em> with <strong>PRF</strong>0, and it does so. The two parties in this session end up with a shared key, <em>SK</em>, that attackers are unable to determine by simply looking at the messages exchanged between the parties, or even by modifying them or injecting new ones. The SIM card verifies that it’s talking to the operator by recomputing <em>V</em><sub>1</sub> with <strong>PRF</strong>1, <em>K</em>, and <em>R</em>, and then checking to make sure that the calculated <em>V</em><sub>1</sub> matches the <em>V</em><sub>1</sub> sent by the operator. The SIM card then computes a verification value, <em>V</em><sub>2</sub>, with a new function, <strong>PRF</strong>2, with <em>K</em> and <em>R</em> as input, and sends <em>V</em><sub>2</sub> to the operator. The operator verifies that the SIM card knows <em>K</em> by computing <em>V</em><sub>2</sub> and checking that the computed value matches the <em>V</em><sub>2</sub> it received.</p>
<p class="indent">But this protocol is not immune to all kinds of attacks: in principle there’s a way to fool the SIM card with a replay attack. Essentially, if an attacker captures a pair (<em>R</em>, <em>V</em><sub>1</sub>), they may send it to the SIM card and trick the SIM into believing that the pair came from a legitimate operator that knows <em>K</em>. To prevent this attack, the protocol includes additional checks to ensure that the same <em>R</em> isn’t reused.</p>
<p class="indent">Problems can also arise if <em>K</em> is compromised. For example, an attacker who compromises <em>K</em> can perform a man-in-the-middle attack and listen to all cleartext communication. Such an attacker could send messages <span epub:type="pagebreak" id="page_207"/>between the two parties while pretending to be both the legitimate SIM card operator and the SIM card. The greater risk is that an attacker can record communications and any messages exchanged during the key agreement, and later decrypt those communications by using the captured <em>R</em> values. An attacker could then determine the past session keys and use them to decrypt the recorded traffic.</p>
<h4 class="h4" id="lev2sec139"><em>Attack Models for Key Agreement Protocols</em></h4>
<p class="noindent">There is no single definition of security for key agreement protocols, and you can never say that a key protocol is completely secure without context and without considering the attack model and the security goals. You can, for example, argue that the previous 3G/4G protocol is secure because a passive attacker won’t find the session keys, but you could also argue that it’s insecure because once the key <em>K</em> leaks, then all previous and future communications are compromised.</p>
<p class="indentb">There are different notions of security in key agreement protocols as well as three main attack models that depend on the information the protocol leaks. From weakest to strongest, these are the <em>eavesdropper</em>, the <em>data leak</em>, and the <em>breach</em>:</p>
<p class="hang"><strong>The eavesdropper</strong> This attacker observes the messages exchanged between the two legitimate parties running a key agreement protocol and can record, modify, drop, or inject messages. To protect against an eavesdropper, a key agreement protocol must not leak any information on the shared secret established.</p>
<p class="hang"><strong>The data leak</strong> In this model, the attacker acquires the session key and all <em>temporary</em> secrets (such as <em>SK</em> in the telecom protocol example discussed previously) from one or more executions of the protocol, but not the long-term secrets (like <em>K</em> in that same protocol).</p>
<p class="hang"><strong>The breach (or corruption)</strong> In this model, the attacker learns the long-term key of one or more of the parties. Once a breach occurs, security is no longer attainable because the attacker can impersonate one or both parties in subsequent sessions of the protocol. Nonetheless, the attacker shouldn’t be able to recover secrets from sessions executed before gathering the key.</p>
<p class="indent1">Now that we’ve looked at the attack models and seen what an attacker can do, let’s explore the security goals—that is, the security guarantees that the protocol should offer. A key agreement protocol can be designed to satisfy several security goals. The four most relevant ones are described here, in order from simplest to most sophisticated.</p>
<p class="hang"><strong>Authentication</strong> Each party should be able to authenticate the other party. That is, the protocol should allow for <em>mutual authentication</em>. Authenticated key agreement (AKA) occurs when a protocol authen­ticates both parties.</p>
<p class="hang"><span epub:type="pagebreak" id="page_208"/><strong>Key control</strong> Neither party should be able to choose the final shared secret or coerce it to be in a specific subset. The 3G/4G key agreement protocol discussed earlier lacks this property because the operator chooses the value for <em>R</em> that entirely determines the final shared key.</p>
<p class="hang"><strong>Forward secrecy</strong> This is the assurance that even if all long-term secrets are exposed, shared secrets from previous executions of the protocol won’t be able to be computed, even if an attacker records all previous executions or is able to inject or modify messages from previous executions. A <em>forward-secret</em> protocol guarantees that even if you have to deliver your devices and their secrets to some authority or other, they won’t be able to decrypt your prior encrypted communications. (The 3G/4G key agreement protocol doesn’t provide forward secrecy.)</p>
<p class="hang"><strong>Resistance to key-compromise impersonation (KCI)</strong> KCI occurs when an attacker compromises a party’s long-term key and is able to use it to impersonate another party. For example, the 3G/4G key agreement protocol allows trivial key-compromise impersonation because both parties share the same key <em>K</em>. A key agreement protocol should ideally prevent this kind of attack.</p>
<h4 class="h4" id="lev2sec140"><em>Performance</em></h4>
<p class="noindent">To be useful, a key agreement protocol should be not only secure but also efficient. Several factors should be taken into account when considering a key agreement protocol’s efficiency, including the number of messages exchanged, the length and number of messages, the computational effort to implement the protocol, and whether precomputations can be made to save time. A protocol is generally more efficient if fewer, shorter messages are exchanged, and it’s best if interactivity is kept minimal so that neither party has to wait to receive a message before sending the next one. A common measure of a protocol’s efficiency is its duration in terms of <em>round trips</em>, or the time it takes to send a message and receive a response.</p>
<p class="indent">Round-trip time is usually the main cause of latency in protocols, but the amount of computation to be carried out also counts; the fewer the computations required the better, and the more precomputations that can be done in advance, the better.</p>
<p class="indent">For example, the 3G/4G key agreement protocol discussed earlier exchanges two messages of a few hundred bits each, which must be sent in a certain order. Pre-computation can be used with this protocol to save time since the operator can pick many values of <em>R</em> in advance; precompute the matching values of <em>SK</em>, <em>V</em><sub>1</sub>, and <em>V</em><sub>2</sub>; and store them all in a database. In this case, precomputation has the advantage of reducing the exposure of the long-term key.</p>
<h3 class="h3" id="lev1sec77"><span epub:type="pagebreak" id="page_209"/>Diffie–Hellman Protocols</h3>
<p class="noindent">The Diffie–Hellman function is the core of most of the deployed public-key agreement protocols. However, there is no single Diffie–Hellman protocol, but rather a variety of ways to use the DH function in order to establish a shared secret. We’ll review three of those protocols in the sections that follow. In each discussion, I’ll stick to the usual crypto placeholder names and call the two parties Alice and Bob, and the attacker Eve. I’ll write <em>g</em> as the basis of the group used for arithmetic operations, a value fixed and known in advance to Alice and Bob.</p>
<h4 class="h4" id="lev2sec141"><em>Anonymous Diffie–Hellman</em></h4>
<p class="noindent"><em>Anonymous Diffie–Hellman</em> is the simplest of the Diffie–Hellman protocols. It’s called anonymous because it’s not authenticated; the participants have no identity that can be verified by either party, and neither party holds a long-term key. Alice can’t prove to Bob that she’s Alice, and vice versa.</p>
<p class="indent">In anonymous Diffie–Hellman, each party picks a random value (<em>a</em> for Alice and <em>b</em> for Bob) to use as a private key, and sends the corresponding public key to the other peer. <a href="ch11.xhtml#ch11fig2">Figure 11-2</a> shows the process in a bit more detail.</p>
<div class="image"><img src="../images/f11-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch11fig2"/><em>Figure 11-2: The anonymous Diffie–Hellman protocol</em></p>
<p class="indentt">As you can see, Alice uses her exponent <em>a</em> and the group basis <em>g</em> to compute <em>A</em> = <em>g</em><sup><em>a</em></sup>, which she sends to Bob. Bob receives <em>A</em> and computes <em>A</em><sup><em>b</em></sup>, which is equal to (<em>g</em><sup><em>a</em></sup>)<sup><em>b</em></sup>. Bob now obtains the value <em>g</em><sup><em>ab</em></sup> and computes <em>B</em> from his random exponent <em>b</em> and the value <em>g</em>. He then sends <em>B</em> to Alice and she uses it to compute <em>g</em><sup><em>ab</em></sup>. Alice and Bob end up with the same value, <em>g</em><sup><em>ab</em></sup>, after performing similar operations, which involve raising both <em>g</em> and the value received to their private exponent’s power. Pure, simple, but only secure against the laziest of attackers.</p>
<p class="indent">Anonymous DH can be taken down with a man-in-the-middle attack. An eavesdropper simply needs to intercept messages and pretend to be Bob (to Alice) and pretend to be Alice (to Bob), as shown in <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_210"/><img src="../images/f11-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch11fig3"/><em>Figure 11-3: A man-in-the-middle attack on the anonymous Diffie–Hellman protocol</em></p>
<p class="indentt">As in the previous exchange, Alice and Bob pick random exponents, <em>a</em> and <em>b</em>. Alice now computes and sends <em>A</em>, but Eve intercepts and drops the message. Eve then picks a random exponent, <em>c</em>, and computes <em>C</em> = <em>g</em><sup><em>c</em></sup> to send to Bob. Because this protocol has no authentication, Bob believes he is receiving <em>C</em> from Alice and goes on to compute <em>g</em><sup><em>bc</em></sup>. Bob then computes <em>B</em> and sends that value to Alice, but Eve intercepts and drops the message again. Eve now computes <em>g</em><sup><em>bc</em></sup>, picks a new exponent, <em>d</em>, computes <em>g</em><sup><em>ad</em></sup>, computes <em>D</em> from <em>g</em><sup><em>d</em></sup>, and sends <em>D</em> to Alice. Alice then computes <em>g</em><sup><em>ad</em></sup> as well.</p>
<p class="indent">As a result of this attack, the attacker Eve ends up sharing a secret with Alice (<em>g</em><sup><em>ad</em></sup>) and another secret with Bob (<em>g</em><sup><em>bc</em></sup>), though Alice and Bob believe that they’re sharing a single secret with each other. After completing the protocol execution, Alice will derive symmetric keys from <em>g</em><sup><em>ad</em></sup> in order to encrypt data sent to Bob, but Eve will intercept the encrypted messages, decrypt them, and re-encrypt them to Bob using another set of keys derived from <em>g</em><sup><em>bc</em></sup>—after potentially modifying the cleartext. All of this happens with Alice and Bob unaware. That is, they’re doomed.</p>
<p class="indent">To foil this attack, you need a way to authenticate the parties so that Alice can prove that she’s the real Alice and Bob can prove that he’s the real Bob. Fortunately, there is a way to do so.</p>
<h4 class="h4" id="lev2sec142"><em>Authenticated Diffie–Hellman</em></h4>
<p class="noindent"><em>Authenticated Diffie–Hellman</em> was developed to address the sort of man-in-the-middle attacks that can affect anonymous DH. Authenticated DH equips the two parties with both a private and a public key, thereby allowing Alice and Bob to sign their messages in order to stop Eve from sending messages on their behalf. Here, the signatures aren’t computed with a DH function, <span epub:type="pagebreak" id="page_211"/>but a public-key signature scheme such as RSA-PSS. As a result, in order to successfully send messages on behalf of Alice, an attacker would need to forge a valid signature, which is impossible with a secure signature scheme.</p>
<p class="indentb"><a href="ch11.xhtml#ch11fig4">Figure 11-4</a> shows how authenticated DH works.</p>
<div class="image"><img src="../images/f11-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch11fig4"/><em>Figure 11-4: The authenticated Diffie–Hellman protocol</em></p>
<p class="indentt">The <strong>Alice</strong> (<em>priv</em><sub><em>A</em></sub>, <em>pub</em><sub><em>B</em></sub>) label on the first line means that Alice holds her own private key, <em>priv</em><sub><em>A</em></sub>, as well as Bob’s public key, <em>pub</em><sub><em>B</em></sub>. This sort of <em>priv</em>/<em>pub</em> key pair is called a <em>long-term key</em> because it’s fixed in advance and remains constant through consecutive runs of the protocol. Of course, these long-term private keys should be kept secret, while the public keys are considered to be known to an attacker.</p>
<p class="indent">Alice and Bob begin by picking random exponents, <em>a</em> and <em>b</em>, as in anonymous DH. Alice then calculates <em>A</em> and a signature <em>sig</em><sub><em>A</em></sub> based on a combination of her signing function <strong>sign</strong>, her private key <em>priv</em><sub><em>A</em></sub>, and <em>A</em>. Now Alice sends <em>A</em> and <em>sig</em><sub><em>A</em></sub> to Bob, who verifies <em>sig</em><sub><em>A</em></sub> with her public key <em>pub</em><sub><em>A</em></sub>. If the signature is invalid, Bob knows that the message didn’t come from Alice, and he discards <em>A</em>.</p>
<p class="indent">If the signature is correct, Bob will compute <em>g</em><sup><em>ab</em></sup> from <em>A</em> and his random exponent <em>b</em>. He would then compute <em>B</em> and his own signature from a combination of the <strong>sign</strong> function, his private key <em>priv</em><sub><em>B</em></sub>, and <em>B</em>. Now he sends <em>B</em> and <em>sig</em><sub><em>B</em></sub> to Alice, who attempts to verify <em>sig</em><sub><em>B</em></sub> with Bob’s public key <em>pub</em><sub><em>B</em></sub>. Alice will only compute <em>g</em><sup><em>ab</em></sup> if Bob’s signature is successfully verified.</p>
<h5 class="h5">Security Against Eavesdroppers</h5>
<p class="noindent">Authenticated DH is secure against eavesdroppers because attackers can’t learn any bit of information on the shared secret <em>g</em><sup><em>ab</em></sup> since they ignore the DH exponents. Authenticated DH also provides forward secrecy: even if an attacker corrupts any of the parties at some point, as in the <em>breach</em> attack model discussed earlier, they would learn the private signing keys but not any of the ephemeral DH exponents; hence, they’d be unable to learn the value of any previously shared secrets.</p>
<p class="indent">Authenticated DH also prevents any party from controlling the value of the shared secret. Alice can’t craft a special value of <em>a</em> in order to predict the value of <em>g</em><sup><em>ab</em></sup> because she doesn’t control <em>b</em>, which influences <em>g</em><sup><em>ab</em></sup> as much <span epub:type="pagebreak" id="page_212"/>as <em>a</em> does. (One exception would be if Alice were to choose <em>a</em> = 0, in which case we’d have <em>g</em><sup><em>ab</em></sup> = 1 for any <em>b</em>. But 0 isn’t an authorized value and should be rejected by the protocol.)</p>
<p class="indent">That said, authenticated DH isn’t secure against all types of attack. For one thing, Eve can record previous values of <em>A</em> and <em>sig</em><sub><em>A</em></sub> and replay them later to Bob, in order to pretend to be Alice. Bob will then believe that he’s sharing a secret with Alice when he isn’t, even though Eve would not be able to learn that secret. This risk is eliminated in practice by adding a procedure called <em>key confirmation</em>, wherein Alice and Bob prove to each other that they own the shared secret. For example, Alice and Bob may perform key confirmation by sending respectively <strong>Hash</strong>(<em>pub</em><sub><em>A</em></sub> || <em>pub</em><sub><em>B</em></sub>, <em>g</em><sup><em>ab</em></sup>) and <strong>Hash</strong>(<em>pub</em><sub><em>B</em></sub> || <em>pub</em><sub><em>A</em></sub>, <em>g</em><sup><em>ab</em></sup>) for some hash function <strong>Hash</strong>; when Bob receives <strong>Hash</strong>(<em>pub</em><sub><em>A</em></sub> || <em>pub</em><sub><em>B</em></sub>, <em>g</em><sup><em>ab</em></sup>) and Alice receives <strong>Hash</strong>(<em>pub</em><sub><em>B</em></sub> || <em>pub</em><sub><em>A</em></sub>, <em>g</em><sup><em>ab</em></sup>), both can verify the correctness of these hash values using <em>pub</em><sub><em>A</em></sub>, <em>pub</em><sub><em>B</em></sub>, and <em>g</em><sup><em>ab</em></sup>. The different order of public keys (<em>pub</em><sub><em>A</em></sub> || <em>pub</em><sub><em>B</em></sub> and <em>pub</em><sub><em>B</em></sub> || <em>pub</em><sub><em>A</em></sub>) ensures that Alice and Bob will send different values, and that an attacker can’t pretend to be Alice by copying Bob’s hash value.</p>
<h5 class="h5">Security Against Data Leaks</h5>
<p class="noindent">Authenticated DH’s vulnerability to data leak attackers is of greater concern. In this type of attack, the attacker learns the value of ephemeral, short-term secrets (namely, the exponents <em>a</em> and <em>b</em>) and uses that information to impersonate one of the communicating parties. If Eve is able to learn the value of an exponent <em>a</em> along with the matching values of <em>A</em> and <em>sig</em><sub><em>A</em></sub> sent to Bob, she could initiate a new execution of the protocol and impersonate Alice, as shown in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>.</p>
<div class="image"><img src="../images/f11-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch11fig5"/><em>Figure 11-5: An impersonation attack on the authenticated Diffie–Hellman protocol</em></p>
<p class="indentt">In this attack scenario, Eve learns the value of an <em>a</em> and replays the corresponding <em>A</em> and its signature <em>sig</em><sub><em>A</em></sub>, pretending to be Alice. Bob verifies the signature and computes <em>g</em><sup><em>ab</em></sup> from <em>A</em> and sends <em>B</em> and <em>sig</em><sub><em>B</em></sub>, which Eve then uses to compute <em>g</em><sup><em>ab</em></sup>, using the stolen <em>a</em>. This results in the two having a shared secret. Bob now believes he is talking to Alice.</p>
<p class="indent"><span epub:type="pagebreak" id="page_213"/>One way to make authenticated DH secure against the leak of ephemeral secrets is to integrate the long-term keys into the shared secret computation so that the shared secret can’t be determined without knowing the long-term secret.</p>
<h4 class="h4" id="lev2sec143"><em>Menezes–Qu–Vanstone (MQV)</em></h4>
<p class="noindent">The <em>Menezes–Qu–Vanstone (MQV)</em> protocol is a milestone in the history of DH-based protocols. Designed in 1998, MQV had been approved to protect most critical assets when the NSA included it in its Suite B, a portfolio of algorithms designed to protect classified information. (NSA eventually dropped MQV, allegedly because it wasn’t used. I’ll discuss the reasons why in a bit.)</p>
<p class="indent">MQV is Diffie–Hellman on steroids. It’s more secure than authenticated DH, and it improves on authenticated DH’s performance properties. In particular, MQV allows users to send only two messages, independently of each other, in arbitrary order. Other benefits are that users can send shorter messages than they would be able to with authenticated DH, and they don’t need to send explicit signature or verification messages. In other words, you don’t need to use a signature scheme in addition to the Diffie–Hellman function.</p>
<p class="indent">As with authenticated DH, in MQV Alice and Bob each hold a long-term private key as well as the long-term public key of the other party. The difference is that the MQV keys aren’t signing keys: the keys used in MQV are composed of a private exponent, <em>x</em>, and a public value, <em>g</em><sup><em>x</em></sup>. <a href="ch11.xhtml#ch11fig6">Figure 11-6</a> shows the operation of the MQV protocol.</p>
<div class="image"><img src="../images/f11-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch11fig6"/><em>Figure 11-6: The MQV protocol</em></p>
<p class="indentt">The <em>x</em> and <em>y</em> in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a> are Alice and Bob’s respective long-term private keys, and <em>X</em> and <em>Y</em> are their public keys. Bob and Alice start out with their own private keys and each other’s public keys, which are <em>g</em> to the power of a private key. Each chooses a random exponent, and then Alice calculates <em>A</em> and sends it to Bob. Bob then calculates <em>B</em> and sends it to Alice. Once Alice gets Bob’s ephemeral public key <em>B</em>, she combines it with her long-term private key <em>x</em>, her ephemeral private key <em>a</em>, and Bob’s long-term public key <em>Y</em> by calculating the result of (<em>B</em> × <em>Y</em><sup><em>B</em></sup>)<sup>(<em>a</em> + <em>xA</em>)</sup>, as defined in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>. Developing this expression, we obtain the following:</p>
<p class="center">(<em>B</em> × <em>Y<sup>B</sup></em>)<sup>(<em>a</em> + <em>xA</em>)</sup> = (<em>g<sup>b</sup></em> × (<em>g<sup>y</sup></em>)<sup><em>B</em></sup>)<sup>(<em>a</em> + <em>xA</em>)</sup> = (<em>g</em><sup><em>b</em> + <em>yB</em></sup>)<sup>(<em>a</em> + <em>xA</em>)</sup> = <em>g</em><sup>(<em>b</em> + <em>yB</em>)(<em>a</em> + <em>xA</em>)</sup></p>
<p class="indent1"><span epub:type="pagebreak" id="page_214"/>Meanwhile, Bob calculates the result of (<em>A</em> × <em>X</em><sup><em>A</em></sup>)<sup>(<em>b</em> + <em>yB</em>)</sup>, and we can verify that it’s equal to the value calculated by Alice:</p>
<p class="center">(<em>A</em> × <em>X<sup>A</sup></em>)<sup>(<em>b</em> + <em>yB</em>)</sup> = (<em>g<sup>a</sup></em> × (<em>g<sup>x</sup></em>)<sup><em>A</em></sup>)<sup>(<em>b</em> + <em>yB</em>)</sup> = (<em>g</em><sup><em>a</em> + <em>xA</em></sup>)<sup>(<em>b</em> + <em>yB</em>)</sup> = <em>g</em><sup>(<em>a</em> + <em>xA</em>)(<em>b</em> + <em>yB</em>)</sup> = <em>g</em><sup>(<em>b</em> + <em>yB</em>)(<em>a</em> + <em>xA</em>)</sup></p>
<p class="indentt">As you can see, we get the same value for both Alice and Bob, namely <em>g</em><sup>(<em>b</em> + <em>yB</em>)(<em>a</em> + <em>xA</em>)</sup>. This tells us that Alice and Bob share the same secret.</p>
<p class="indent">Unlike authenticated DH, MQV can’t be broken by a mere leak of the ephemeral secrets. Knowledge of <em>a</em> or <em>b</em> won’t let an attacker determine the final shared secret because they would need the long-term private keys to compute it.</p>
<p class="indent">What happens in the strongest attack model, the breach model, where a long-term key is compromised? If Eve compromises Alice’s long-term private key <em>x</em>, the previously established shared secrets are safe because their computation also involved Alice’s ephemeral private keys.</p>
<p class="indent">However, MQV doesn’t provide <em>perfect</em> forward secrecy because of the following attack. Say, for example, that Eve intercepts Alice’s <em>A</em> message and replaces it with her <em>A</em> = <em>g</em><sup><em>a</em></sup> for some <em>a</em> that Eve has chosen. In the meantime, Bob sends <em>B</em> to Alice (and Eve records <em>B</em>’s value) and computes the shared key. If Eve later compromises Alice’s long-term private key <em>x</em>, she can determine the key that Bob had computed during this session. This breaks forward secrecy, since Eve has now recovered the shared secret of a previous execution of the protocol. In practice, however, the risk can be eliminated by a key-confirmation step that would have Alice and Bob realize that they don’t share the same key, and they would therefore abort the protocol before deriving any session keys.</p>
<p class="indent">Despite its elegance and security, MQV is rarely used in practice. One reason is because it used to be encumbered by patents, which hampered its widespread adoption. Another reason is that it’s harder than it looks to get MQV right in practice. In fact, when weighed against its increased complexity, MQV’s security benefits are often perceived as low in comparison to the simpler authenticated DH.</p>
<h3 class="h3" id="lev1sec78">How Things Can Go Wrong</h3>
<p class="noindent">Diffie–Hellman protocols can fail spectacularly in a variety of ways. I highlight some of the most common ones in the next sections.</p>
<h4 class="h4" id="lev2sec144"><em>Not Hashing the Shared Secret</em></h4>
<p class="noindent">I’ve alluded to the fact that the shared secret that concludes a DH session exchange (<em>g</em><sup><em>ab</em></sup> in our examples) is taken as input to derive session keys but is not a key itself. And it shouldn’t be. A symmetric key should look random, and each bit should either be 0 or 1 with the same probability. But <em>g</em><sup><em>ab</em></sup> is not a random string; it’s a random element within some mathematical group whose bits may be biased toward 0 or 1. And a random group element is different from a random string of bits.</p>
<p class="indent"><span epub:type="pagebreak" id="page_215"/>Imagine, for example, that we’re working within the multiplicative group <strong>Z</strong><sub>13</sub><sup>*</sup> = {1, 2, 3, … , 12} using <em>g</em> = 2 as a generator of the group, meaning that <em>g</em><sup><em>i</em></sup> spans all values of <strong>Z</strong><sub>13</sub><sup>*</sup> for <em>i</em> in 1, 2, … 12: <em>g</em><sup>1</sup> = 2, <em>g</em><sup>2</sup> = 4, <em>g</em><sup>3</sup> = 8, <em>g</em><sup>4</sup> = 13, and so on. If <em>g</em>’s exponent is random, you’ll get a random element of <strong>Z</strong><sub>13</sub><sup>*</sup>, but the encoding of a <strong>Z</strong><sub>13</sub><sup>*</sup> element as a 4-bit string won’t be uniformly random: not all bits will have the same probability of being a 0 or a 1. In <strong>Z</strong><sub>13</sub><sup>*</sup>, seven values have 0 as their most significant bit (the numbers from 1 to 7 in the group), but only five have 1 as their most significant bit (from 8 to 12). That is, this bit is 0 with probability 7 / 12 ≈ 0.58, whereas, ideally, a random bit should be 0 with probability 0.5. Moreover, the 4-bit sequences 1101, 1110, and 1111 will never appear.</p>
<p class="indent">To avoid such biases in the session keys derived from a DH shared secret, you should use a cryptographic hash function such as BLAKE2 or SHA-3—or, better yet, a key derivation function (KDF). An example of KDF construction is HKDF, or HMAC-based KDF (as specified in RFC 5869), but today BLAKE2 and SHA-3 feature dedicated modes to behave as KDFs.</p>
<h4 class="h4" id="lev2sec145"><em>Legacy Diffie–Hellman in TLS</em></h4>
<p class="noindent">The TLS protocol is the security behind HTTPS secure websites as well as the secure mail transfer protocol (SMTP). TLS takes several parameters, including the type of Diffie–Hellman protocol it will use, though most TLS implementations still support anonymous DH for legacy reasons, despite its insecurity.</p>
<h4 class="h4" id="lev2sec146"><em>Unsafe Group Parameters</em></h4>
<p class="noindent">In January 2016, the maintainers of the OpenSSL toolkit fixed a high-severity vulnerability (CVE-2016-0701) that allowed an attacker to exploit unsafe Diffie–Hellman parameters. The root cause of the vulnerability was that OpenSSL allowed users to work with unsafe DH group parameters (namely, an unsafe prime <em>p</em>) instead of throwing an error and aborting the protocol altogether before performing any arithmetic operation.</p>
<p class="indent">Essentially, OpenSSL accepted a prime number <em>p</em> whose multiplicative group <strong>Z</strong><sub><em>p</em></sub><sup>*</sup> (where all DH operations happen) contained small subgroups. As you learned at the beginning of this chapter, the existence of small subgroups within a larger group in a cryptographic protocol is bad because it confines shared secrets to a much smaller set of possible values than if it were to use the whole group <strong>Z</strong><sub><em>p</em></sub><sup>*</sup>. Worse still, an attacker can craft a DH exponent <em>x</em> that, when combined with the victim’s public key <em>g</em><sup><em>y</em></sup>, will reveal information on the private key <em>y</em> and eventually its entirety.</p>
<p class="indent">Although the actual vulnerability is from 2016, the principle the attack used dates back to the 1997 paper “A Key Recovery Attack on Discrete Log-based Schemes Using a Prime Order Subgroup” by Lim and Lee. The fix for the vulnerability is simple: when accepting a prime <em>p</em> as group modulus, the protocol must check that <em>p</em> is a safe prime by verifying that (<em>p</em> – 1) / 2 is prime as well in order to ensure that the group <strong>Z</strong><sub><em>p</em></sub><sup>*</sup> won’t have small subgroups, and that an attack on this vulnerability will fail.</p>
<h3 class="h3" id="lev1sec79"><span epub:type="pagebreak" id="page_216"/>Further Reading</h3>
<p class="noindent">Here’s a rundown of some things that I didn’t cover in this chapter but are useful to learn about.</p>
<p class="indent">You can dig deeper into the DH key agreement protocols by reading a number of standards and official publications, including ANSI X9.42, RFC 2631 and RFC 5114, IEEE 1363, and NIST SP 800-56A. These serve as references to ensure interoperability, and to provide recommendations for group parameters.</p>
<p class="indent">To learn more about advanced DH protocols (such as MQV and its cousins HMQV and OAKE, among others) and their security notions (such as unknown-key share attacks and group representation attacks), read the 2005 article “HMQV: A High-Performance Secure Diffie–Hellman Protocol” by Hugo Krawczyk (<em><a href="https://eprint.iacr.org/2005/176/">https://eprint.iacr.org/2005/176/</a></em>) and the 2011 article “A New Family of Implicitly Authenticated Diffie–Hellman Protocols” by by Andrew C. Yao and Yunlei Zhao (<em><a href="https://eprint.iacr.org/2011/035/">https://eprint.iacr.org/2011/035/</a></em>). You’ll notice in these articles that Diffie–Hellman operations are expressed differently than in this chapter. For example, instead of <em>g</em><sup><em>x</em></sup>, you’ll find the shared secret represented as <em>xP</em>. Generally, you’ll find multiplication replaced with addition and exponentiation replaced with multiplication. The reason is that those protocols are usually not defined over groups of integers, but over <em>elliptic curves</em>, as discussed in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>
</body></html>