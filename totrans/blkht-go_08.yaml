- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RAW PACKET PROCESSING
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to capture and process network packets. You
    can use packet processing for many purposes, including to capture cleartext authentication
    credentials, alter the application functionality of the packets, or spoof and
    poison traffic. You can also use it for SYN scanning and for port scanning through
    SYN-flood protections, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll introduce you to the excellent `gopacket` package from Google, which will
    enable you to both decode packets and reassemble the stream of traffic. This package
    allows you to filter traffic by using the Berkeley Packet Filter (BPF), also called
    tcpdump syntax; read and write *.pcap* files; inspect various layers and data;
    and manipulate packets.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll walk through several examples to show you how to identify devices, filter
    results, and create a port scanner that can bypass SYN-flood protections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Your Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before working through the code in this chapter, you need to set up your environment.
    First, install `gopacket` by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `gopacket` relies on external libraries and drivers to bypass the operating
    system’s protocol stack. If you intend to compile the examples in this chapter
    for use on Linux or macOS, you’ll need to install `libpcap-dev`. You can do this
    with most package management utilities such as `apt`, `yum`, or `brew`. Here’s
    how you install it by using `apt` (the installation process looks similar for
    the other two options):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you intend to compile and run the examples in this chapter on Windows, you
    have a couple of options, based on whether you’re going to cross-compile or not.
    Setting up a development environment is simpler if you don’t cross-compile, but
    in that case, you’ll have to create a Go development environment on a Windows
    machine, which can be unattractive if you don’t want to clutter another environment.
    For the time being, we’ll assume you have a working environment that you can use
    to compile Windows binaries. Within this environment, you’ll need to install WinPcap.
    You can download an installer for free from *[https://www.winpcap.org](https://www.winpcap.org)/*.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Devices by Using the pcap Subpackage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can capture network traffic, you must identify available devices
    on which you can listen. You can do this easily using the `gopacket/pcap` subpackage,
    which retrieves them with the following helper function: `pcap.FindAllDevs() (ifs
    []Interface, err error)`. [Listing 8-1](ch08.xhtml#ch8list1) shows how you can
    use it to list all available interfaces. (All the code listings at the root location
    of / exist under the provided github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Listing the available network devices (*[/ch-8/identify/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-8/identify/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: You enumerate your devices by calling `pcap.FindAllDevs()` ❶. Then you loop
    through the devices found ❷. For each device, you access various properties, including
    the `device.Name` ❸. You also access their IP addresses through the `Addresses`
    property, which is a slice of type `pcap.InterfaceAddress`. You loop through these
    addresses ❹, displaying the IP address and netmask to the screen ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Executing your utility produces output similar to [Listing 8-2](ch08.xhtml#ch8list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Output showing the available network interfaces*'
  prefs: []
  type: TYPE_NORMAL
- en: The output lists the available network interfaces—`enp0s5`, `any`, and `lo`—as
    well as their IPv4 and IPv6 addresses and netmasks. The output on your system
    will likely differ from these network details, but it should be similar enough
    that you can make sense of the information.
  prefs: []
  type: TYPE_NORMAL
- en: Live Capturing and Filtering Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to query available devices, you can use `gopacket`’s features
    to capture live packets off the wire. In doing so, you’ll also filter the set
    of packets by using BPF syntax. BPF allows you to limit the contents of what you
    capture and display so that you see only relevant traffic. It’s commonly used
    to filter traffic by protocol and port. For example, you could create a filter
    to see all TCP traffic destined for port 80\. You can also filter traffic by destination
    host. A full discussion of BPF syntax is beyond the scope of this book. For additional
    ways to use BPF, take a peek at [*http://www.tcpdump.org/manpages/pcap-filter.7.html*](http://www.tcpdump.org/manpages/pcap-filter.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-3](ch08.xhtml#ch8list3) shows the code, which filters traffic so
    that you capture only TCP traffic sent to or from port 80.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Using a BPF filter to capture specific network traffic (*[/ch-8/filter/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-8/filter/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code starts by defining several variables necessary to set up the packet
    capture ❶. Included among these is the name of the interface on which you want
    to capture data, the snapshot length (the amount of data to capture for each frame),
    the `promisc` variable (which determines whether you’ll be running promiscuous
    mode), and your time-out. Also, you define your BPF filter: `tcp and port 80`.
    This will make sure you capture only packets that match those criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: Within your `main()` function, you enumerate the available devices ❷, looping
    through them to determine whether your desired capture interface exists in your
    device list ❸. If the interface name doesn’t exist, then you panic, stating that
    it’s invalid.
  prefs: []
  type: TYPE_NORMAL
- en: What remains in the rest of the `main()` function is your capturing logic. From
    a high-level perspective, you need to first obtain or create a `*pcap.Handle`,
    which allows you to read and inject packets. Using this handle, you can then apply
    a BPF filter and create a new packet data source, from which you can read your
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: You create your `*pcap.Handle` (named `handle` in the code) by issuing a call
    to `pcap.OpenLive()` ❹. This function receives an interface name, a snapshot length,
    a boolean value defining whether it’s promiscuous, and a time-out value. These
    input variables are all defined prior to the `main()` function, as we detailed
    previously. Call `handle.SetBPFFilter(filter)` to set the BPF filter for your
    handle ❺, and then use `handle` as an input while calling `gopacket.NewPacketSource(handle,
    handle.LinkType())` to create a new packet data source ❻. The second input value,
    `handle.LinkType()`, defines the decoder to use when handling packets. Lastly,
    you actually read packets from the wire by using a loop on `source.Packets()`
    ❼, which returns a channel.
  prefs: []
  type: TYPE_NORMAL
- en: As you might recall from previous examples in this book, looping on a channel
    causes the loop to block when it has no data to read from the channel. When a
    packet arrives, you read it and print its contents to screen.
  prefs: []
  type: TYPE_NORMAL
- en: The output should look like [Listing 8-4](ch08.xhtml#ch8list4). Note that the
    program requires elevated privileges because we’re reading raw content off the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Captured packets logged to stdout*'
  prefs: []
  type: TYPE_NORMAL
- en: Although the raw output isn’t very digestible, it certainly contains a nice
    separation of each layer. You can now use utility functions, such as `packet.ApplicationLayer()`
    and `packet.Data()`, to retrieve the raw bytes for a single layer or the entire
    packet. When you combine the output with `hex.Dump()`, you can display the contents
    in a much more readable format. Play around with this on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing and Displaying Cleartext User Credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s build on the code you just created. You’ll replicate some of the functionality
    provided by other tools to sniff and display cleartext user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Most organizations now operate by using switched networks, which send data directly
    between two endpoints rather than as a broadcast, making it harder to passively
    capture traffic in an enterprise environment. However, the following cleartext
    sniffing attack can be useful when paired with something like Address Resolution
    Protocol (ARP) poisoning, an attack that can coerce endpoints into communicating
    with a malicious device on a switched network, or when you’re covertly sniffing
    outbound traffic from a compromised user workstation. In this example, we’ll assume
    you’ve compromised a user workstation and focus solely on capturing traffic that
    uses FTP to keep the code brief.
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of a few small changes, the code in [Listing 8-5](ch08.xhtml#ch8list5)
    is nearly identical to the code in [Listing 8-3](ch08.xhtml#ch8list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Capturing FTP authentication credentials (*[/ch-8/ftp/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-8/ftp/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: The changes you made encompass only about 10 lines of code. First, you change
    your BPF filter to capture only traffic destined for port 21 (the port commonly
    used for FTP traffic) ❶. The rest of the code remains the same until you process
    the packets.
  prefs: []
  type: TYPE_NORMAL
- en: To process packets, you first extract the application layer from the packet
    and check to see whether it actually exists ❷, because the application layer contains
    the FTP commands and data. You look for the application layer by examining whether
    the response value from `packet.ApplicationLayer()` is `nil`. Assuming the application
    layer exists in the packet, you extract the payload (the FTP commands/data) from
    the layer by calling `appLayer.Payload()` ❸. (There are similar methods for extracting
    and inspecting other layers and data, but you only need the application layer
    payload.) With your payload extracted, you then check whether the payload contains
    either the `USER` or `PASS` commands ❹, indicating that it’s part of a login sequence.
    If it does, display the payload to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run that captures an FTP login attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can improve this code. In this example, the payload will be displayed
    if the words `USER` or `PASS` exist anywhere in the payload. Really, the code
    should be searching only the beginning of the payload to eliminate false-positives
    that occur when those keywords appear as part of file contents transferred between
    client and server or as part of a longer word such as `PASSAGE` or `ABUSER`. We
    encourage you to make these improvements as a learning exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Port Scanning Through SYN-flood Protections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml#ch2), you walked through the creation of a port scanner.
    You improved the code through multiple iterations until you had a high-performing
    implementation that produced accurate results. However, in some instances, that
    scanner can still produce incorrect results. Specifically, when an organization
    employs SYN-flood protections, typically all ports—open, closed, and filtered
    alike—produce the same packet exchange to indicate that the port is open. These
    protections, known as SYN *cookies*, prevent SYN-flood attacks and obfuscate the
    attack surface, producing false-positives.
  prefs: []
  type: TYPE_NORMAL
- en: When a target is using SYN cookies, how can you determine whether a service
    is listening on a port or a device is falsely showing that the port is open? After
    all, in both cases, the TCP three-way handshake is completed. Most tools and scanners
    (Nmap included) look at this sequence (or some variation of it, based on the scan
    type you’ve chosen) to determine the status of the port. Therefore, you can’t
    rely on these tools to produce accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you consider what happens after you’ve established a connection—an
    exchange of data, perhaps in the form of a service banner—you can deduce whether
    an actual service is responding. SYN-flood protections generally won’t exchange
    packets beyond the initial three-way handshake unless a service is listening,
    so the presence of any additional packets might indicate that a service exists.
  prefs: []
  type: TYPE_NORMAL
- en: Checking TCP Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To account for SYN cookies, you have to extend your port-scanning capabilities
    to look beyond the three-way handshake by checking to see whether you receive
    any additional packets from the target after you’ve established a connection.
    You can accomplish this by sniffing the packets to see if any of them were transmitted
    with a TCP flag value indicative of additional, legitimate service communications.
  prefs: []
  type: TYPE_NORMAL
- en: '*TCP flags* indicate information about the state of a packet transfer. If you
    look at the TCP specification, you’ll find that the flags are stored in a single
    byte at position 14 in the packet’s header. Each bit of this byte represents a
    single flag value. The flag is “on” if the bit at that position is set to 1, and
    “off” if the bit is set to 0\. [Table 8-1](ch08.xhtml#ch8tab1) shows the positions
    of the flags in the byte, as per the TCP specification.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** TCP Flags and Their Byte Positions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| **Flag** | CWR | ECE | URG | ACK | PSH | RST | SYN | FIN |'
  prefs: []
  type: TYPE_TB
- en: 'Once you know the positions of the flags you care about, you can create a filter
    that checks them. For example, you can look for packets containing the following
    flags, which might indicate a listening service:'
  prefs: []
  type: TYPE_NORMAL
- en: ACK and FIN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACK and PSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because you have the ability to capture and filter certain packets by using
    the `gopacket` library, you can build a utility that attempts to connect to a
    remote service, sniffs the packets, and displays only the services that communicate
    packets with these TCP headers. Assume all other services are falsely “open” because
    of SYN cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Building the BPF Filter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Your BPF filter needs to check for the specific flag values that indicate packet
    transfer. The flag byte has the following values if the flags we mentioned earlier
    are turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ACK and FIN: 00010001 (0x11)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACK: 00010000 (0x10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ACK and PSH: 00011000 (0x18)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We included the hex equivalent of the binary value for clarity, as you’ll use
    the hex value in your filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, you need to check the 14th byte (offset 13 for a 0-based index)
    of the TCP header, filtering only for packets whose flags are 0x11, 0x10, or 0x18\.
    Here’s what the BPF filter looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Excellent. You have your filter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Port Scanner
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll use the filter to build a utility that establishes a full TCP connection
    and inspects packets beyond the three-way handshake to see whether other packets
    are transmitted, indicating that an actual service is listening. The program is
    shown in [Listing 8-6](ch08.xhtml#ch8list6). For the sake of simplicity, we’ve
    opted to not optimize the code for efficiency. However, you can greatly improve
    this code by making optimizations similar to those we made in [Chapter 2](ch02.xhtml#ch2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Scanning and processing packets with SYN-flood protections (*[/ch-8/syn-flood/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-8/syn-flood/main.go)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: Broadly speaking, your code will maintain a count of packets, grouped by port,
    to represent how confident you are that the port is indeed open. You’ll use your
    filter to select only packets with the proper flags set. The greater the count
    of matching packets, the higher your confidence that the service is listening
    on the port.
  prefs: []
  type: TYPE_NORMAL
- en: Your code starts by defining several variables for use throughout ❶. These variables
    include your filter and a map named `results` that you’ll use to track your level
    of confidence that the port is open. You’ll use target ports as keys and maintain
    a count of matching packets as the map value.
  prefs: []
  type: TYPE_NORMAL
- en: Next you define a function, `capture()`, that accepts the interface name and
    target IP for which you’re testing ❷. The function itself bootstraps the packet
    capture much in the same way as previous examples. However, you must use different
    code to process each packet. You leverage the `gopacket` functionality to extract
    the packet’s network and transport layers ❸. If either of these layers is absent,
    you ignore the packet; that’s because the next step is to inspect the source IP
    and port of the packet ❹, and if there’s no transport or network layer, you won’t
    have that information. You then confirm that the packet source matches the IP
    address that you’re targeting ❺. If the packet source and IP address don’t match,
    you skip further processing. If the packet’s source IP and port match your target,
    you increment your confidence level for the port ❻. Repeat this process for each
    subsequent packet. Each time you get a match, your confidence level increases.
  prefs: []
  type: TYPE_NORMAL
- en: In your `main()` function, use a goroutine to call your `capture()` function
    ❼. Using a goroutine ensures that your packet capture and processing logic runs
    concurrently without blocking. Meanwhile, your `main()` function proceeds to parse
    your target ports, looping through them one by one ❽ and calling `net.DialTimeout`
    to attempt a TCP connection against each ❾. Your goroutine is running, actively
    watching these connection attempts, looking for packets that indicate a service
    is listening.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve attempted to connect to each port, process all of your results
    by displaying only those ports that have a confidence level of 1 or more (meaning
    at least one packet matches your filter for that port) ❿. The code includes several
    calls to `time.Sleep()` to ensure you’re leaving adequate time to set up the sniffer
    and process packets.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a sample run of the program, shown in [Listing 8-7](ch08.xhtml#ch8list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: Port-scanning results with confidence ratings*'
  prefs: []
  type: TYPE_NORMAL
- en: The test successfully determines that both port 80 and 443 are open. It also
    confirms that no service is listening on ports 8123 and 65530\. (Note that we’ve
    changed the IP address in the example to protect the innocent.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You could improve the code in several ways. As learning exercises, we challenge
    you to add the following enhancements:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the network and transport layer logic and source checks from the `capture()`
    function. Instead, add additional parameters to the BPF filter to ensure that
    you capture only packets from your target IP and ports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the sequential logic of port scanning with a concurrent alternative,
    similar to what we demonstrated in previous chapters. This will improve efficiency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than limiting the code to a single target IP, allow the user to supply
    a list of IPs or network blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve completed our discussion of packet captures, focusing primarily on passive
    sniffing activities. In the next chapter, we’ll focus on exploit development.
  prefs: []
  type: TYPE_NORMAL
