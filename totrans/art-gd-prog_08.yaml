- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Graphics and Animation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 61: Layering'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the key features of modern graphics programs like Photoshop is the idea
    of layers. That’s the creation of a set of graphical objects (images) that are
    placed on top of each other to achieve a complex effect. Transparency makes it
    possible to see objects on lower layers. This sketch uses three layers: an image
    of the moon, a circle around a crater, and a targeting display (reticle). Using
    the keyboard, the user can reposition the moon image. The goal of the interface
    is to allow the user to align the reticle with the target circle.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Drawing inside the sketch window involves using a graphics object class called
    `PGraphics`. The `background()`, `line()`, and `ellipse()` functions, and many
    others, are part of the `PGraphics` class, though we can use them without a `PGraphics`
    object. Alternatively, our drawing can take place in one of these objects and
    then be displayed on the screen later by calling `image()`. This sketch will draw
    the moon image with an ellipse highlighting a crater inside of a `PGraphics` instance,
    and we’ll then display it in the sketch window.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable used for the `PGraphics` object is named `pg`, and the function
    that creates one is called (reasonably enough) `createGraphics()` 1:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `moon` is the `PImage` variable that holds the background image of the
    moon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw in a `PGraphics` object, we use the graphics functions that we have
    used before, but specify the `pg` variable as the target 2:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Drawing is preceded by a call to `beginDraw()`, a function that is similar to
    a bracket; the corresponding end bracket is a call to `endDraw()`. If you don’t
    use these calls, Processing doesn’t initialize the object, and drawing will not
    work (even though Processing may not generate an error). The preceding code draws
    the moon image in the `PGraphics` objects and draws a circle around a target.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function displays the `PGraphics` object using the call `image(pg,
    xoff, yoff)`, where `xoff` and `yoff` are positional offsets that are controlled
    using key presses of W, A, S, and D in the traditional way 3. (A `PGraphics` object
    has many of the properties of a `PImage`, since `image()` can display both.) The
    values of `xoff` and `yoff` are generally negative so that the underlying graphic
    gets shifted left and up under the window, which remains stable, from its starting
    point in the upper-left corner. The `draw()` function also draws the reticle as
    a small set of lines that point to the center of the window 4.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 62: Seeing the World Through a Window'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many games, animations, and simulations (driving or space travel, for example)
    use a view through a window as a part of the interface. This sketch implements
    a window that looks out on a 3D scene and allows the user to move about that scene
    while looking through the window.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: This is a more advanced application of `PGraphics`. We’ll render a simple 3D
    scene to a `PGraphics` instance named `pg`, read a 2D image with transparent sections
    (the window) into a `PGraphics` instance named `g2`, and draw the two graphics
    objects to the screen using calls to `image()`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The 3D primitives we’ll use to draw the 3D scene are all part of `PGraphics`.
    We’ll enable the 3D rendering engine with a parameter to `createGraphics()` 1,
    instead of to `size()` as in Sketch 51, and then we’ll set up the 3D parameters
    with calls to `camera()` 2 and `ambientLight()`. The basic call to `size()` sets
    up the graphics window; each `PGraphics` instance is like having a distinct window
    to draw in, and all of the usual graphics methods can be used via the dot notation:
    `pg.line()`, `pg.ellipse()`, and so on. No `PGraphics` object is visible until
    drawn in the graphics window. Thus we can create a simulated 3D space inside the
    `pg` object, drawing four cubes there that provide targets to be viewed through
    the window.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The 2D portion involves displaying a 2D image (a `PImage` variable named `back`)
    that represents the window ([Figure 62-1](#figure62-1)). The GIF image has transparent
    sections, created by defining a color (in this case green) as transparent using
    an image editor like Photoshop. We call this kind of image a stencil.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![f062001](Images/f062001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'Figure 62-1: The stencil for the window'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The sketch draws the two images on the window, `pg` first (the 3D rendering)
    3 followed by `g2` (the stencil) 4. The transparent parts of `g2` allow the 3D
    scene to be seen through the window portions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The user can control the viewpoint for the 3D scene using the keyboard in the
    usual way 5. The 3D scene changes as a consequence of the change in the viewpoint,
    but the 2D scene does not. The result is that the window stays in the same place
    but the view seen through it (the transparent portions) changes as a function
    of that viewpoint, as if the user were inside a moving vehicle looking at a scene
    outside.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 63: The PShape Object—A Rotating Planet'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sketch will display a rotating planet (a sphere) and allow the user to
    move around it in 3D. The new part in this sketch is texture-mapping the planet’s
    surface onto the sphere, which is really a collection of polygons. One way to
    do this would be to build a model of a sphere out of polygons and do the texture-mapping
    within a `beginShape()` and `endShape()` block. An easier way is to use a `PShape`
    object, which is a data type for storing arbitrary shapes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the rotating planet, we’ll create a `PShape` object through a
    call to `createShape()`, which allows us to build arbitrarily complex shapes using
    the large set of drawing operations provided by the `PShape` class. It is possible
    to create almost anything using a `PShape`, and the documentation available online
    is necessary for complex creations. Our case is simple, because a sphere is one
    of the shapes provided. This is the call that makes the planet, where `globe`
    is a `PShape` object 1:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The texture, a map of Mars as a `PImage` variable named `timg`, is applied using
    `globe.setTexture(timg)` 2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we display the planet in `draw()` using a call to the `shape()` function
    3:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code positions the sphere in the center of the field of view and rotates
    it about its own axis before displaying it. The usual keys allow the user to change
    the viewing position.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 64: Splines—Drawing Curves'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve rendered simple geometric objects like lines, ellipses, rectangles,
    and spheres using predefined Processing functions. But many real-world objects
    are not linear or elliptical; they have complex shapes. Examples are legion, including
    cars, fan blades, jewelry, clothing, and living things—even graphs of data. In
    Processing, complex shapes are rendered using curves. To demonstrate, this sketch
    allows the user to draw curves using a series of mouse clicks and to see how the
    selected “control points” affect the curves.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Processing uses *splines* to render curves. In the earlier days of drafting,
    when people used pencils and T-squares, people used something called a spline
    to draw smooth, oddly shaped curves. It was a long, flexible metal strip that
    could hold a shape, align with points on paper, and allow the drafter to connect
    them using a pencil. Mathematically, a spline is a polynomial function that approximates
    a curve by using a set of points. The details can be complex, but the idea is
    to use many polynomials connected end to end to build the curve. Processing hides
    the complexity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Processing provides a function named `curve()` that implements a type of polynomial
    named the Catmull-Rom spline. This function uses four points to define each section
    of the curve. The first two define the direction the curve will have at the beginning,
    and the second two define the direction it will have at the end. The curve itself
    consists of a set of points (pixels) between the middle two points. As seen in
    [Figure 64-1](#figure64-1), the angle defined by the first two points establishes
    the direction of the curve at point P[1], which defines the shape of the polygon
    between P[1] and P[2]; we establish the direction of the curve at P[2] by the
    direction between P[2] and P[3]. In the figure, the points P[1] and P[2] in the
    two examples are the same, but the curves have a different shape due to the different
    positions of P[0] and P[3].
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![f064001](Images/f064001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 64-1: Control points of a spline curve'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the function call used in Processing to draw a curve section between
    P[1]=(x1,y1) and P[2]=(x2,y2):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The start and end points, (`x0`, `y0`) and (`x3`, `y3`), control the shape 1.
    To draw a longer curve, we need multiple calls to `curve()`, with the endpoints
    of one being the beginning of the next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This sketch allows the user to select points, drawn as small red circles using
    mouse clicks 2, and to observe the shape change caused by the position of the
    next point as the mouse moves. Four points define a curve, so when the user selects
    the fourth point, a red curve is drawn using the points specified, and then a
    blue curve that changes as the mouse moves is drawn from the final point to the
    mouse position, (`mouseX`, `mouseY`). Clicking again will add a new point to the
    curve, extending the red portion to include the new point and showing a new blue
    section. Pressing the BACKSPACE key deletes the last point in the curve 3, and
    the spacebar turns the drawing of the final (blue) section on and off 4.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This sketch keeps the point coordinates in arrays `x` and `y` and passes successive
    groups of four coordinates to `curve()`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 65: A Driving Simulation with Waypoints'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sketch 60 allowed a user to drive around a track in 3D, and Sketch 64 illustrated
    how to create curves, like a track that a simulated car could drive on. Computer
    driving games often have automated vehicles that compete with the player, giving
    the impression of being a real opponent. This sketch will implement a system for
    computer-controlled cars that is similar to the methods used in those computer
    games.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to realize that games and simulations do not necessarily do things
    the way people do. A human driver would orient the car based on the next turn
    they could see and would steer continually to remain on the track. We could build
    a computer program to do this too, but it would be pretty complicated. Another
    option is to use predetermined knowledge about the track to steer the vehicle.
    In this case, the programmer has to provide more information to the program at
    the outset, but the resulting simplicity in the code is worth the effort.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: To be specific, the programmer breaks up the track into linear pieces. The linear
    pieces should be as long as possible and join to each other at vertices called
    waypoints, places where the direction of the line, and hence the car, changes.
    (We can dissect any curve this way.) Each waypoint has a number or a label assigned
    by the programmer. When the car is at waypoint 1, the program will change its
    direction of motion to move toward waypoint 2\. When it arrives at waypoint 2,
    it will steer to waypoint 3\. Because the segments are lines, we don’t need to
    steer between waypoints.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch implements waypoints as a collection of arrays, each array containing
    one dimension of the waypoints. The location of waypoint `i` is in the array locations
    `wpx[i]` and `wpy[i]` 1. In a more accurate simulation, a waypoint would have
    much more information associated with it: changes in speed and acceleration, rate
    of change of the turn, and perhaps graphical information like brake lights turning
    on. In the current sketch, the only other thing needed is the angle between the
    current and the next waypoint so that we can rotate the car to face the new direction.
    We could calculate this, but it would take more code, and the positions of the
    waypoints and the angles between them can be determined in advance. We declare
    arrays `wpx`, `wpy`, and `wpa` 2 and initialize them with the position and angle
    data, which implicitly defines the size of the arrays. (It is not possible to
    both specify the size of an array using a number and initialize it using data.)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the vehicle’s assigned `speed` (changed using W and S), we compute its
    position change during each frame as `dx = speed * ( wpx(i+1) - wpx(i) )/d(i,i+1)`where
    `d(i,i+1)` is the distance between waypoints `i` and `i+1` 4. We say that the
    vehicle has arrived at waypoint `i` when it is within `speed` pixels of it, at
    which point it changes direction and aims for the next waypoint, `i+1` 3. The
    `wayPoint` variable indicates the last waypoint encountered, meaning that the
    vehicle is aiming for `wayPoint+1`. The waypoint count wraps around at the end,
    so we increment modulo-*N* where *N* is the number of waypoints: the waypoint
    following *N* is 0.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the spacebar allows the user to see where the waypoints and paths are.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 66: Many Small Objects—A Snowstorm'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Processing program redraws the screen many times each second. Visible objects
    must be redrawn in each frame, and to do so the program must save the graphical
    parameters (size, location, shape, and color) of all of them. Drawing each object
    takes time, so if there are many, is it still possible to redraw them all quickly
    enough? In many cases it is, if the objects themselves are not complex. This sketch
    will draw snow falling, with each snowflake being an object that moves realistically
    between frames.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Snowflakes are, in fact, very complex shapes, but from a distance they are just
    white blobs. We’ll draw them as small rectangles whose width and height vary by
    a small random value each frame to simulate the effect of the snowflake fluttering
    as it falls 1. We set the dimensions with the formula `width = size + random(3)-1.5`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`size` is a constant set to `3`, and the value of `random(3)` is a number between
    0 and 3, so `random(3)-1.5` will have a value between −1.5 and +1.5, creating
    a change in the size between 1.5 and 4.5\. Each snowflake also has a slightly
    different falling speed 5. This gives the illusion of depth because flakes that
    fall faster appear nearer to the viewer than ones that fall slower. The speed
    is selected at random, but it yields the desired effect.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 是一个常量，设置为 `3`，而 `random(3)` 的值是介于 0 和 3 之间的一个数字，因此 `random(3)-1.5` 的值将介于
    −1.5 和 +1.5 之间，从而导致大小在 1.5 和 4.5 之间变化。每个雪花的下落速度也略有不同。这种差异造成了深度的假象，因为下落更快的雪花看起来离观察者更近，而下落较慢的雪花则更远。速度是随机选择的，但它达到了预期的效果。'
- en: 'The program creates snowflakes at the top of the screen and gives them a downward
    (+y) speed, which will make them appear to fall. To track the position, size,
    and speed in both the x- and y-directions, we use arrays: for example, the array
    `x` stores the x position, and `x[i]` is the x location of the `i`^(th) snowflake.
    The array size, given by the constant `SIZE`, is the maximum number of snowflakes.
    (The value here is 5,000, found by trial and error based on the observed number
    needed given the background and the maximum rate of snowfall.)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会在屏幕顶部生成雪花，并给它们设置一个向下（+y）速度，这样它们看起来就会下落。为了追踪每片雪花的位置信息、大小和速度（在 x 和 y 方向上），我们使用数组：例如，数组
    `x` 存储 x 位置，`x[i]` 是第 `i` 个雪花的 x 位置。数组大小由常量 `SIZE` 给出，表示最大雪花数量。（这个值是 5,000，是通过试验和误差，根据观察到的背景和最大降雪速率确定的。）
- en: Snow does not normally fall straight down; we observe it drifting and floating
    with air currents. The speed at which the snowflakes fall remains constant, but
    the x position of each flake changes a bit at random as it falls to try to give
    the illusion of real snow 2. If we set `dx` to a nonzero value, it simulates a
    wind, and snow will blow in the specified direction.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 雪花通常不会垂直下落；我们看到它们随着气流飘动和漂浮。雪花下落的速度保持不变，但每片雪花的 x 位置会在下落过程中随机变化一些，以模拟真实的雪花效果。如果我们将
    `dx` 设置为非零值，它就模拟了风的作用，雪花将会在指定的方向上吹动。
- en: 'Each frame, we generate up to 30 new snowflakes with random horizontal positions
    and y-coordinates of 0 4 (at the top of the window, to maintain the illusion).
    The number of snowflakes created during each frame is random but is a function
    of the y position of the mouse 3. The nearer the mouse is to the top of the screen,
    the less snow will appear to fall. This is the number of flakes created:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧，我们生成最多 30 片新的雪花，随机设置它们的横向位置和 y 坐标为 0 4（位于窗口顶部，以保持假象）。每帧生成的雪花数量是随机的，但它与鼠标的
    y 位置有关。鼠标越接近屏幕顶部，看到的雪花就越少。以下是生成的雪花数量：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that almost no flakes will fall for small values of `mouseY`, while
    the maximum of up to 30 new snowflakes during each frame occurs when `mouseY/height`
    is at its maximum of 1.0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，对于小的 `mouseY` 值，几乎没有雪花会落下，而当 `mouseY/height` 达到最大值 1.0 时，每帧会最多生成 30 片新的雪花。
- en: The global variable `SIZE` has a value of 5,000, which is the number of snowflakes
    that can be on the screen at any time. Initially there are only a few, but the
    array will fill up quickly. When all 5,000 array elements are occupied, we start
    over again at 0, assuming that the snowflakes at the beginning of the array have
    fallen past the bottom of the screen and are not visible. This technique is referred
    to as a circular array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `SIZE` 的值为 5,000，这是屏幕上可以同时显示的最大雪花数量。最初只有几个雪花，但数组会迅速填满。当所有 5,000 个数组元素被占用时，我们会从
    0 开始重新计数，假设数组开始位置的雪花已经掉过屏幕底部并且不可见。这个技术被称为循环数组。
- en: 'Sketch 67: Particle Graphics—Smoke'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 67：粒子图形—烟雾
- en: 'Some things are difficult to model using polygons: soft and amorphous shapes
    like water, fire, clouds, and smoke, for example. Such things can move in unpredictable
    ways and expand to fill arbitrary shapes. This sketch will draw smoke emitting
    from a smokestack and illustrate a key method in modern computer graphics: a particle
    system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西用多边形建模很困难，例如水、火、云和烟雾等柔软且无定形的物体。这些物体的运动方式不可预测，并且可以扩展以填充任意形状。这个草图将绘制从烟囱中冒出的烟雾，并展示现代计算机图形学中的一个关键方法：粒子系统。
- en: 'A particle system combines a large number of small objects to form a complex
    shape. The objects are usually simple, like spheres or circles, and have a set
    of parameters that control their display. The basic parameters of a circle are
    position, velocity, color, and size. Initial parameters usually have a random
    element: speed plus or minus a random number, for example. An emitter is the location
    where the system creates new particles (circles), usually with a small, random
    displacement, so the particles aren’t exactly at the emitter.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统将大量小物体组合起来，形成复杂的形状。这些物体通常很简单，比如球体或圆形，并具有一组控制其显示的参数。圆形的基本参数包括位置、速度、颜色和大小。初始参数通常包含随机元素，例如速度加上或减去一个随机数。发射器是系统创建新粒子（圆形）的地方，通常带有一个小的随机位移，这样粒子就不会完全位于发射器位置。
- en: The particle system in this sketch produces a large number of overlapping circles,
    possibly somewhat transparent, moving with slightly different speeds (not unlike
    the previous sketch except for density). The previous sketch drew a large number
    of small objects that could still be seen as individual snowflakes. In this sketch,
    if enough of these particles exist, we can’t distinguish them individually, and
    they form an object in combination. As the number increases and the objects overlap,
    the result looks like fog or smoke.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图中的粒子系统生成了大量重叠的圆形，这些圆形可能是半透明的，以略微不同的速度移动（与之前的草图相比，唯一不同的是密度）。之前的草图绘制了大量小物体，仍然可以看作是单独的雪花。而在这个草图中，如果粒子的数量足够多，我们就无法区分它们的个体，它们会组合成一个物体。随着数量的增加和物体的重叠，结果看起来像雾气或烟雾。
- en: 'The sketch defines a large number of circles to be created (`SIZE`) and declares
    arrays to hold the position, speed, and size of each one: the value of `x[121]`
    is the x position of the 121st circle, for example. Initially there are none,
    and the variable `last` holds the index of the last one defined. We increment
    `last` each frame as we create new circles, and we reset it to zero when the number
    exceeds `SIZE`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图定义了要创建的大量圆形（`SIZE`），并声明了数组来保存每个圆形的位置、速度和大小。例如，`x[121]`的值表示第121个圆形的x位置。初始时没有圆形，变量`last`保存最后一个定义的圆形的索引。每一帧我们创建新的圆形时都会增加`last`的值，当圆形的数量超过`SIZE`时，我们会将其重置为零。
- en: The `draw()` function first runs through the arrays and draws each circle that
    exists (meaning `x[i] > 0`) 1. It changes the circle’s position by a small random
    amount, may change the size slightly, and gives it a color that varies around
    RGB = (205, 205, 150). It then creates a random number of new circles, giving
    them positions near the emitter, a vertical speed, and a small size 2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数首先遍历数组，绘制每一个存在的圆形（意味着`x[i] > 0`）1。它会将圆形的位置稍微改变，可能会略微改变大小，并赋予它一个围绕RGB
    = (205, 205, 150)变化的颜色。然后，它会创建一个随机数量的新圆形，赋予它们靠近发射器的位置、垂直的速度和一个较小的大小2。'
- en: The effect is striking. With up to 800 circles, the system yields a remarkably
    good impression of smoke moving upward. The sketch reads and displays a background
    image of a smokestack for a better visual effect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 效果非常引人注目。通过多达800个圆形，系统能极好地模拟烟雾向上升腾的效果。该草图展示并呈现了一个烟囱的背景图，以增强视觉效果。
- en: The outline around the circles has been turned off with `noStroke()`, but it
    is educational to delete that statement and run the program so that the particles
    can be seen. The way the particles move and overlap is clearer, as in [Figure
    67-1](#figure67-1).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形的轮廓已经通过`noStroke()`关闭，但将该语句删除并运行程序，可以看到粒子的形态。这样，粒子的移动和重叠变得更加清晰，如[图67-1](#figure67-1)所示。
- en: '![f067001](Images/f067001.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![f067001](Images/f067001.png)'
- en: 'Figure 67-1: Particles showing the outline of the circles'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图67-1：粒子显示圆形的轮廓
- en: 'Sketch 68: Saving a State—A Spinning Propeller'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 68：保存状态——旋转螺旋桨
- en: This sketch will draw a spinning propeller. We can code this in many ways, some
    of them simpler than the method in this sketch, but the purpose here is to use
    a simple example to explain how and why to save (and restore) the geometric state
    of a sketch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图将绘制一个旋转的螺旋桨。我们可以用多种方式编写代码，有些方式比这个草图中的方法更简单，但这里的目的是通过一个简单的例子来解释如何以及为什么要保存（和恢复）草图的几何状态。
- en: The geometric state is the resultant combination of all the translation, rotation,
    and scaling that accumulate during the display of an object up to a specific point
    in the drawing process. Rotating an object about its center means first translating
    the origin to the center of the object, doing the rotation, and then translating
    the origin back to the original location. If the state is not restored by undoing
    the translation, then all objects drawn from that time on will translate to the
    location of the object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几何状态是所有平移、旋转和缩放的结果组合，这些操作在绘制过程中的某一特定时刻累积。围绕物体的中心旋转意味着首先将原点平移到物体的中心，进行旋转，然后再将原点平移回原位置。如果不通过撤销平移来恢复状态，那么从此时起绘制的所有物体都会平移到该物体的位置。
- en: 'The current state, whatever it is, including all rotation, translation, and
    scaling, is saved using a call to the function `pushMatrix()` and is restored
    by a call to `popMatrix()`. These calls must always occur in pairs, like brackets;
    a call to `pushMatrix()` always has a corresponding call to `popMatrix()`. For
    example, you could save and restore state while rotating a triangle about its
    center at (100, 100), shown in [Figure 68-1](#figure68-1), as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态，无论是什么，包括所有的旋转、平移和缩放，都是通过调用函数`pushMatrix()`来保存的，并通过调用`popMatrix()`来恢复。这些调用必须始终成对出现，就像括号一样；调用`pushMatrix()`总是有一个对应的`popMatrix()`调用。例如，您可以在围绕(100,
    100)的中心旋转一个三角形时，保存并恢复状态，如[图68-1](#figure68-1)所示，代码如下：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, the origin and rotation angle are back to their original values,
    and the next object can be drawn from a clean state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，原点和旋转角度已恢复到原始值，接下来可以从一个干净的状态绘制下一个物体。
- en: 'This sketch draws a propeller with four sections, each being one blade, which
    is an image. We draw this blade four times: once in the original orientation,
    and then three times each rotated about the propeller center point by 90 degrees
    1. Each section drawn uses a save and restore:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图绘制了一个四部分的螺旋桨，每个部分是一片刀片，即一张图片。我们绘制这片刀片四次：一次是原始方向，然后是围绕螺旋桨中心点每次旋转90度，共三次。每个部分的绘制都使用了保存和恢复状态：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The four-section propeller is drawn inside a `drawProp(x,y)` function that saves
    the state on entering the function, then translates to (`x`, `y`), scales the
    image, rotates it, updates the angle so the next call to `drawProp()` draws the
    propeller at a different angle 2, and draws the four sections. We use multiple
    calls to the `drawProp()` function to draw a rotating propeller at multiple locations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个四部分的螺旋桨绘制在一个`drawProp(x, y)`函数中，该函数在进入时保存状态，然后平移到(`x`, `y`)，缩放图像，旋转图像，更新角度，以便下次调用`drawProp()`时绘制出不同角度的螺旋桨，并绘制四个部分。我们通过多次调用`drawProp()`函数，在多个位置绘制旋转中的螺旋桨。
- en: '![f068001](Images/f068001.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f068001](Images/f068001.png)'
- en: 'Figure 68-1: The transformations needed to rotate an object about its center'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-1：围绕物体中心旋转所需的变换
- en: 'Sketch 69: L-Systems—Drawing Plants'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图69：L系统——绘制植物
- en: Drawing realistic-looking plants is difficult. Living things do not usually
    contain straight lines, which is what computers draw best. In addition, there
    is a random nature to life forms that humans recognize, so we are critical of
    renderings. In 1968 a botanist named Aristid Lindenmayer developed a scheme for
    describing the growth of fungi and algae, and then later expanded it to deal with
    more advanced plant life. This was in turn adapted by computer graphics practitioners
    into a scheme for drawing plants. We call this scheme an L-system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制逼真的植物是困难的。生物体通常没有直线，而直线是计算机最擅长绘制的形状。此外，生命形式有一种人类能够识别的随机性，因此我们对渲染的结果会产生批判。1968年，一位名叫阿里斯蒂德·林登梅耶的植物学家开发了一种描述真菌和藻类生长的方案，后来将其扩展到处理更高级的植物生命。此方案随后被计算机图形学从业者改编成一种绘制植物的方案。我们称这种方案为L系统。
- en: 'An L-system is technically a grammar, which is a set of rules for making strings.
    If a grammar has two rules, X -> Xf and X -> z, then it is showing how to take
    a symbol, X, and transform it into a sequence of characters. For each X, we choose
    which replacement rule to follow, and we continue replacing capital Xs (referred
    to as non-terminal symbols) until there are no more left to replace. Here’s an
    example expansion for this grammar: X -> Xf -> Xff -> Xfff -> zfff.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: L系统在技术上是一种语法，是一组用于生成字符串的规则。如果语法有两条规则，X -> Xf 和 X -> z，那么它就展示了如何将一个符号X转换成一个字符序列。对于每个X，我们选择遵循哪个替换规则，并继续替换大写X（称为非终结符号），直到没有更多可以替换的X。以下是该语法的一个扩展示例：X
    -> Xf -> Xff -> Xfff -> zfff。
- en: 'In an L-system, a grammar that can define a plant, the final string represents
    a recipe for drawing something. It uses the following symbols:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: f Draw a straight line segment.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ Save the current state (`pushMatrix()`).'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '] Go back to the previous state (`popMatrix()`).'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: + Rotate by a fixed positive angle.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- Rotate by a fixed negative angle.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The grammar uses two rules to produce a string of these symbols:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: X -> ff
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: X -> f–[[X]+X]+f[+fX]–X
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless the plant consists of only two straight lines (ff), the first step would
    be X –> f–[[X]+X]+f[+fX]–X. Then each X would be replaced by the right side of
    a production, so the second step might be f–[[X]+X]+f[+fX]–X –> f–[[ f–[[X]+X]+f[+fX]–X]+ff]+f[+ff]–ff,
    followed perhaps by f–[[ f–[[ff]+ff]+f[+fff]–ff]+ff]+f[+ff]–ff, which can now
    be drawn.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The `makeString()` function 1 calls itself to expand the non-terminal X symbols
    into strings and append these to the string being constructed. It will only call
    itself to a depth specified by the first parameter, `levels`, and will then return,
    thus guaranteeing that the program will eventually end. The string generated by
    the grammar is passed to the `drawPlant()` function 2, which executes each character
    as a graphical operation, thus drawing the plant. In the function `void` `drawPlant(float
    length, float angle, String s, int drawLevel)`, the first parameter, `length`,
    is the length of the line to draw (for the symbol f); the `angle` is the rotation
    angle for the + and - characters; `s` is the string generated by `makeString()`;
    and `drawLevel` indicates a depth level for drawing lines. Essentially, `makeString()`
    creates a string that is a program for how to draw the plant, and `drawPlant()`
    executes that program.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 70: Warping an Image'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1991 the general public saw morphing for the first time, an effect that uses
    a computer to smoothly convert one image into another. The computer produces a
    small sequence of images so that, when played back as a video sequence, an object
    appears to continuously change shape to become the other. The film *Terminator
    2* used it and, probably most strikingly, the Michael Jackson music video for
    the song “Black or White” used it in a sequence where faces morphed into one another.
    This sketch performs a warp or bending of an image, but does not do a complete
    morph.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The principle underlying the morphing method is something called a polynomial
    warp. Imagine we place an image over a regular grid and then bend the grid using
    a mathematical function and take the image with it. The result is an image that
    changes in a particular way—a warp. Morphing between two images requires that
    we establish a correspondence between the image, usually by a human. A function
    bends (maps) one image into another (a warp) while the pixel color values change
    systematically from the source to the destination values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: If the image is a face and the warp is based on a sine curve, we get an effect
    that looks like a funhouse mirror, as shown in [Figure 70-1](#figure70-1). The
    geometry of the original face bends (maps) into that of the new one according
    to the function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![f070001](Images/f070001.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'Figure 70-1: Warping a face'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch implements an image warp. We read an image and display the pixels
    according to a sine function transformation of coordinates. The original image
    is `source`, and this is the mapping between original and new pixel coordinates:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This mapping is arbitrary, chosen for an amusing effect. The loop that does
    the mapping 2 has to map pixel values from the destination back to the source,
    not the other way around. Each pixel in the source does correspond to a pixel
    in the destination, but there may be unmapped pixels in the result if we do the
    mapping the other way. So for each pixel `(x,y)` in the destination image, we
    transform it to `(newX, newY)` values using the desired function and then find
    the corresponding pixel in the source image. We then set the destination `(x,y)`
    to the source `(newX, newY)`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: In the sketch, the values of `ds` and `size` are parameters to the transformation
    function, and they change slightly each frame 1, creating a cyclical change in
    the image that a person will perceive as an animation of the bending or warping
    motion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
