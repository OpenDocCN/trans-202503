- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Graphics and Animation
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 61: Layering'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the key features of modern graphics programs like Photoshop is the idea
    of layers. That’s the creation of a set of graphical objects (images) that are
    placed on top of each other to achieve a complex effect. Transparency makes it
    possible to see objects on lower layers. This sketch uses three layers: an image
    of the moon, a circle around a crater, and a targeting display (reticle). Using
    the keyboard, the user can reposition the moon image. The goal of the interface
    is to allow the user to align the reticle with the target circle.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing inside the sketch window involves using a graphics object class called
    `PGraphics`. The `background()`, `line()`, and `ellipse()` functions, and many
    others, are part of the `PGraphics` class, though we can use them without a `PGraphics`
    object. Alternatively, our drawing can take place in one of these objects and
    then be displayed on the screen later by calling `image()`. This sketch will draw
    the moon image with an ellipse highlighting a crater inside of a `PGraphics` instance,
    and we’ll then display it in the sketch window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable used for the `PGraphics` object is named `pg`, and the function
    that creates one is called (reasonably enough) `createGraphics()` 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `moon` is the `PImage` variable that holds the background image of the
    moon.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw in a `PGraphics` object, we use the graphics functions that we have
    used before, but specify the `pg` variable as the target 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Drawing is preceded by a call to `beginDraw()`, a function that is similar to
    a bracket; the corresponding end bracket is a call to `endDraw()`. If you don’t
    use these calls, Processing doesn’t initialize the object, and drawing will not
    work (even though Processing may not generate an error). The preceding code draws
    the moon image in the `PGraphics` objects and draws a circle around a target.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function displays the `PGraphics` object using the call `image(pg,
    xoff, yoff)`, where `xoff` and `yoff` are positional offsets that are controlled
    using key presses of W, A, S, and D in the traditional way 3. (A `PGraphics` object
    has many of the properties of a `PImage`, since `image()` can display both.) The
    values of `xoff` and `yoff` are generally negative so that the underlying graphic
    gets shifted left and up under the window, which remains stable, from its starting
    point in the upper-left corner. The `draw()` function also draws the reticle as
    a small set of lines that point to the center of the window 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 62: Seeing the World Through a Window'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many games, animations, and simulations (driving or space travel, for example)
    use a view through a window as a part of the interface. This sketch implements
    a window that looks out on a 3D scene and allows the user to move about that scene
    while looking through the window.
  prefs: []
  type: TYPE_NORMAL
- en: This is a more advanced application of `PGraphics`. We’ll render a simple 3D
    scene to a `PGraphics` instance named `pg`, read a 2D image with transparent sections
    (the window) into a `PGraphics` instance named `g2`, and draw the two graphics
    objects to the screen using calls to `image()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 3D primitives we’ll use to draw the 3D scene are all part of `PGraphics`.
    We’ll enable the 3D rendering engine with a parameter to `createGraphics()` 1,
    instead of to `size()` as in Sketch 51, and then we’ll set up the 3D parameters
    with calls to `camera()` 2 and `ambientLight()`. The basic call to `size()` sets
    up the graphics window; each `PGraphics` instance is like having a distinct window
    to draw in, and all of the usual graphics methods can be used via the dot notation:
    `pg.line()`, `pg.ellipse()`, and so on. No `PGraphics` object is visible until
    drawn in the graphics window. Thus we can create a simulated 3D space inside the
    `pg` object, drawing four cubes there that provide targets to be viewed through
    the window.'
  prefs: []
  type: TYPE_NORMAL
- en: The 2D portion involves displaying a 2D image (a `PImage` variable named `back`)
    that represents the window ([Figure 62-1](#figure62-1)). The GIF image has transparent
    sections, created by defining a color (in this case green) as transparent using
    an image editor like Photoshop. We call this kind of image a stencil.
  prefs: []
  type: TYPE_NORMAL
- en: '![f062001](Images/f062001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 62-1: The stencil for the window'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch draws the two images on the window, `pg` first (the 3D rendering)
    3 followed by `g2` (the stencil) 4. The transparent parts of `g2` allow the 3D
    scene to be seen through the window portions.
  prefs: []
  type: TYPE_NORMAL
- en: The user can control the viewpoint for the 3D scene using the keyboard in the
    usual way 5. The 3D scene changes as a consequence of the change in the viewpoint,
    but the 2D scene does not. The result is that the window stays in the same place
    but the view seen through it (the transparent portions) changes as a function
    of that viewpoint, as if the user were inside a moving vehicle looking at a scene
    outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 63: The PShape Object—A Rotating Planet'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sketch will display a rotating planet (a sphere) and allow the user to
    move around it in 3D. The new part in this sketch is texture-mapping the planet’s
    surface onto the sphere, which is really a collection of polygons. One way to
    do this would be to build a model of a sphere out of polygons and do the texture-mapping
    within a `beginShape()` and `endShape()` block. An easier way is to use a `PShape`
    object, which is a data type for storing arbitrary shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the rotating planet, we’ll create a `PShape` object through a
    call to `createShape()`, which allows us to build arbitrarily complex shapes using
    the large set of drawing operations provided by the `PShape` class. It is possible
    to create almost anything using a `PShape`, and the documentation available online
    is necessary for complex creations. Our case is simple, because a sphere is one
    of the shapes provided. This is the call that makes the planet, where `globe`
    is a `PShape` object 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The texture, a map of Mars as a `PImage` variable named `timg`, is applied using
    `globe.setTexture(timg)` 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we display the planet in `draw()` using a call to the `shape()` function
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code positions the sphere in the center of the field of view and rotates
    it about its own axis before displaying it. The usual keys allow the user to change
    the viewing position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 64: Splines—Drawing Curves'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve rendered simple geometric objects like lines, ellipses, rectangles,
    and spheres using predefined Processing functions. But many real-world objects
    are not linear or elliptical; they have complex shapes. Examples are legion, including
    cars, fan blades, jewelry, clothing, and living things—even graphs of data. In
    Processing, complex shapes are rendered using curves. To demonstrate, this sketch
    allows the user to draw curves using a series of mouse clicks and to see how the
    selected “control points” affect the curves.
  prefs: []
  type: TYPE_NORMAL
- en: Processing uses *splines* to render curves. In the earlier days of drafting,
    when people used pencils and T-squares, people used something called a spline
    to draw smooth, oddly shaped curves. It was a long, flexible metal strip that
    could hold a shape, align with points on paper, and allow the drafter to connect
    them using a pencil. Mathematically, a spline is a polynomial function that approximates
    a curve by using a set of points. The details can be complex, but the idea is
    to use many polynomials connected end to end to build the curve. Processing hides
    the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Processing provides a function named `curve()` that implements a type of polynomial
    named the Catmull-Rom spline. This function uses four points to define each section
    of the curve. The first two define the direction the curve will have at the beginning,
    and the second two define the direction it will have at the end. The curve itself
    consists of a set of points (pixels) between the middle two points. As seen in
    [Figure 64-1](#figure64-1), the angle defined by the first two points establishes
    the direction of the curve at point P[1], which defines the shape of the polygon
    between P[1] and P[2]; we establish the direction of the curve at P[2] by the
    direction between P[2] and P[3]. In the figure, the points P[1] and P[2] in the
    two examples are the same, but the curves have a different shape due to the different
    positions of P[0] and P[3].
  prefs: []
  type: TYPE_NORMAL
- en: '![f064001](Images/f064001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 64-1: Control points of a spline curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the function call used in Processing to draw a curve section between
    P[1]=(x1,y1) and P[2]=(x2,y2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The start and end points, (`x0`, `y0`) and (`x3`, `y3`), control the shape 1.
    To draw a longer curve, we need multiple calls to `curve()`, with the endpoints
    of one being the beginning of the next.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch allows the user to select points, drawn as small red circles using
    mouse clicks 2, and to observe the shape change caused by the position of the
    next point as the mouse moves. Four points define a curve, so when the user selects
    the fourth point, a red curve is drawn using the points specified, and then a
    blue curve that changes as the mouse moves is drawn from the final point to the
    mouse position, (`mouseX`, `mouseY`). Clicking again will add a new point to the
    curve, extending the red portion to include the new point and showing a new blue
    section. Pressing the BACKSPACE key deletes the last point in the curve 3, and
    the spacebar turns the drawing of the final (blue) section on and off 4.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch keeps the point coordinates in arrays `x` and `y` and passes successive
    groups of four coordinates to `curve()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 65: A Driving Simulation with Waypoints'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sketch 60 allowed a user to drive around a track in 3D, and Sketch 64 illustrated
    how to create curves, like a track that a simulated car could drive on. Computer
    driving games often have automated vehicles that compete with the player, giving
    the impression of being a real opponent. This sketch will implement a system for
    computer-controlled cars that is similar to the methods used in those computer
    games.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to realize that games and simulations do not necessarily do things
    the way people do. A human driver would orient the car based on the next turn
    they could see and would steer continually to remain on the track. We could build
    a computer program to do this too, but it would be pretty complicated. Another
    option is to use predetermined knowledge about the track to steer the vehicle.
    In this case, the programmer has to provide more information to the program at
    the outset, but the resulting simplicity in the code is worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: To be specific, the programmer breaks up the track into linear pieces. The linear
    pieces should be as long as possible and join to each other at vertices called
    waypoints, places where the direction of the line, and hence the car, changes.
    (We can dissect any curve this way.) Each waypoint has a number or a label assigned
    by the programmer. When the car is at waypoint 1, the program will change its
    direction of motion to move toward waypoint 2\. When it arrives at waypoint 2,
    it will steer to waypoint 3\. Because the segments are lines, we don’t need to
    steer between waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch implements waypoints as a collection of arrays, each array containing
    one dimension of the waypoints. The location of waypoint `i` is in the array locations
    `wpx[i]` and `wpy[i]` 1. In a more accurate simulation, a waypoint would have
    much more information associated with it: changes in speed and acceleration, rate
    of change of the turn, and perhaps graphical information like brake lights turning
    on. In the current sketch, the only other thing needed is the angle between the
    current and the next waypoint so that we can rotate the car to face the new direction.
    We could calculate this, but it would take more code, and the positions of the
    waypoints and the angles between them can be determined in advance. We declare
    arrays `wpx`, `wpy`, and `wpa` 2 and initialize them with the position and angle
    data, which implicitly defines the size of the arrays. (It is not possible to
    both specify the size of an array using a number and initialize it using data.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the vehicle’s assigned `speed` (changed using W and S), we compute its
    position change during each frame as `dx = speed * ( wpx(i+1) - wpx(i) )/d(i,i+1)`where
    `d(i,i+1)` is the distance between waypoints `i` and `i+1` 4. We say that the
    vehicle has arrived at waypoint `i` when it is within `speed` pixels of it, at
    which point it changes direction and aims for the next waypoint, `i+1` 3. The
    `wayPoint` variable indicates the last waypoint encountered, meaning that the
    vehicle is aiming for `wayPoint+1`. The waypoint count wraps around at the end,
    so we increment modulo-*N* where *N* is the number of waypoints: the waypoint
    following *N* is 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the spacebar allows the user to see where the waypoints and paths are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 66: Many Small Objects—A Snowstorm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Processing program redraws the screen many times each second. Visible objects
    must be redrawn in each frame, and to do so the program must save the graphical
    parameters (size, location, shape, and color) of all of them. Drawing each object
    takes time, so if there are many, is it still possible to redraw them all quickly
    enough? In many cases it is, if the objects themselves are not complex. This sketch
    will draw snow falling, with each snowflake being an object that moves realistically
    between frames.
  prefs: []
  type: TYPE_NORMAL
- en: Snowflakes are, in fact, very complex shapes, but from a distance they are just
    white blobs. We’ll draw them as small rectangles whose width and height vary by
    a small random value each frame to simulate the effect of the snowflake fluttering
    as it falls 1. We set the dimensions with the formula `width = size + random(3)-1.5`.
  prefs: []
  type: TYPE_NORMAL
- en: '`size` is a constant set to `3`, and the value of `random(3)` is a number between
    0 and 3, so `random(3)-1.5` will have a value between −1.5 and +1.5, creating
    a change in the size between 1.5 and 4.5\. Each snowflake also has a slightly
    different falling speed 5. This gives the illusion of depth because flakes that
    fall faster appear nearer to the viewer than ones that fall slower. The speed
    is selected at random, but it yields the desired effect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program creates snowflakes at the top of the screen and gives them a downward
    (+y) speed, which will make them appear to fall. To track the position, size,
    and speed in both the x- and y-directions, we use arrays: for example, the array
    `x` stores the x position, and `x[i]` is the x location of the `i`^(th) snowflake.
    The array size, given by the constant `SIZE`, is the maximum number of snowflakes.
    (The value here is 5,000, found by trial and error based on the observed number
    needed given the background and the maximum rate of snowfall.)'
  prefs: []
  type: TYPE_NORMAL
- en: Snow does not normally fall straight down; we observe it drifting and floating
    with air currents. The speed at which the snowflakes fall remains constant, but
    the x position of each flake changes a bit at random as it falls to try to give
    the illusion of real snow 2. If we set `dx` to a nonzero value, it simulates a
    wind, and snow will blow in the specified direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each frame, we generate up to 30 new snowflakes with random horizontal positions
    and y-coordinates of 0 4 (at the top of the window, to maintain the illusion).
    The number of snowflakes created during each frame is random but is a function
    of the y position of the mouse 3. The nearer the mouse is to the top of the screen,
    the less snow will appear to fall. This is the number of flakes created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This means that almost no flakes will fall for small values of `mouseY`, while
    the maximum of up to 30 new snowflakes during each frame occurs when `mouseY/height`
    is at its maximum of 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: The global variable `SIZE` has a value of 5,000, which is the number of snowflakes
    that can be on the screen at any time. Initially there are only a few, but the
    array will fill up quickly. When all 5,000 array elements are occupied, we start
    over again at 0, assuming that the snowflakes at the beginning of the array have
    fallen past the bottom of the screen and are not visible. This technique is referred
    to as a circular array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 67: Particle Graphics—Smoke'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some things are difficult to model using polygons: soft and amorphous shapes
    like water, fire, clouds, and smoke, for example. Such things can move in unpredictable
    ways and expand to fill arbitrary shapes. This sketch will draw smoke emitting
    from a smokestack and illustrate a key method in modern computer graphics: a particle
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A particle system combines a large number of small objects to form a complex
    shape. The objects are usually simple, like spheres or circles, and have a set
    of parameters that control their display. The basic parameters of a circle are
    position, velocity, color, and size. Initial parameters usually have a random
    element: speed plus or minus a random number, for example. An emitter is the location
    where the system creates new particles (circles), usually with a small, random
    displacement, so the particles aren’t exactly at the emitter.'
  prefs: []
  type: TYPE_NORMAL
- en: The particle system in this sketch produces a large number of overlapping circles,
    possibly somewhat transparent, moving with slightly different speeds (not unlike
    the previous sketch except for density). The previous sketch drew a large number
    of small objects that could still be seen as individual snowflakes. In this sketch,
    if enough of these particles exist, we can’t distinguish them individually, and
    they form an object in combination. As the number increases and the objects overlap,
    the result looks like fog or smoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch defines a large number of circles to be created (`SIZE`) and declares
    arrays to hold the position, speed, and size of each one: the value of `x[121]`
    is the x position of the 121st circle, for example. Initially there are none,
    and the variable `last` holds the index of the last one defined. We increment
    `last` each frame as we create new circles, and we reset it to zero when the number
    exceeds `SIZE`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function first runs through the arrays and draws each circle that
    exists (meaning `x[i] > 0`) 1. It changes the circle’s position by a small random
    amount, may change the size slightly, and gives it a color that varies around
    RGB = (205, 205, 150). It then creates a random number of new circles, giving
    them positions near the emitter, a vertical speed, and a small size 2.
  prefs: []
  type: TYPE_NORMAL
- en: The effect is striking. With up to 800 circles, the system yields a remarkably
    good impression of smoke moving upward. The sketch reads and displays a background
    image of a smokestack for a better visual effect.
  prefs: []
  type: TYPE_NORMAL
- en: The outline around the circles has been turned off with `noStroke()`, but it
    is educational to delete that statement and run the program so that the particles
    can be seen. The way the particles move and overlap is clearer, as in [Figure
    67-1](#figure67-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f067001](Images/f067001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 67-1: Particles showing the outline of the circles'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 68: Saving a State—A Spinning Propeller'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sketch will draw a spinning propeller. We can code this in many ways, some
    of them simpler than the method in this sketch, but the purpose here is to use
    a simple example to explain how and why to save (and restore) the geometric state
    of a sketch.
  prefs: []
  type: TYPE_NORMAL
- en: The geometric state is the resultant combination of all the translation, rotation,
    and scaling that accumulate during the display of an object up to a specific point
    in the drawing process. Rotating an object about its center means first translating
    the origin to the center of the object, doing the rotation, and then translating
    the origin back to the original location. If the state is not restored by undoing
    the translation, then all objects drawn from that time on will translate to the
    location of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current state, whatever it is, including all rotation, translation, and
    scaling, is saved using a call to the function `pushMatrix()` and is restored
    by a call to `popMatrix()`. These calls must always occur in pairs, like brackets;
    a call to `pushMatrix()` always has a corresponding call to `popMatrix()`. For
    example, you could save and restore state while rotating a triangle about its
    center at (100, 100), shown in [Figure 68-1](#figure68-1), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the origin and rotation angle are back to their original values,
    and the next object can be drawn from a clean state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch draws a propeller with four sections, each being one blade, which
    is an image. We draw this blade four times: once in the original orientation,
    and then three times each rotated about the propeller center point by 90 degrees
    1. Each section drawn uses a save and restore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The four-section propeller is drawn inside a `drawProp(x,y)` function that saves
    the state on entering the function, then translates to (`x`, `y`), scales the
    image, rotates it, updates the angle so the next call to `drawProp()` draws the
    propeller at a different angle 2, and draws the four sections. We use multiple
    calls to the `drawProp()` function to draw a rotating propeller at multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: '![f068001](Images/f068001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 68-1: The transformations needed to rotate an object about its center'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 69: L-Systems—Drawing Plants'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing realistic-looking plants is difficult. Living things do not usually
    contain straight lines, which is what computers draw best. In addition, there
    is a random nature to life forms that humans recognize, so we are critical of
    renderings. In 1968 a botanist named Aristid Lindenmayer developed a scheme for
    describing the growth of fungi and algae, and then later expanded it to deal with
    more advanced plant life. This was in turn adapted by computer graphics practitioners
    into a scheme for drawing plants. We call this scheme an L-system.
  prefs: []
  type: TYPE_NORMAL
- en: 'An L-system is technically a grammar, which is a set of rules for making strings.
    If a grammar has two rules, X -> Xf and X -> z, then it is showing how to take
    a symbol, X, and transform it into a sequence of characters. For each X, we choose
    which replacement rule to follow, and we continue replacing capital Xs (referred
    to as non-terminal symbols) until there are no more left to replace. Here’s an
    example expansion for this grammar: X -> Xf -> Xff -> Xfff -> zfff.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an L-system, a grammar that can define a plant, the final string represents
    a recipe for drawing something. It uses the following symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: f Draw a straight line segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[ Save the current state (`pushMatrix()`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '] Go back to the previous state (`popMatrix()`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: + Rotate by a fixed positive angle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- Rotate by a fixed negative angle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The grammar uses two rules to produce a string of these symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: X -> ff
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: X -> f–[[X]+X]+f[+fX]–X
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unless the plant consists of only two straight lines (ff), the first step would
    be X –> f–[[X]+X]+f[+fX]–X. Then each X would be replaced by the right side of
    a production, so the second step might be f–[[X]+X]+f[+fX]–X –> f–[[ f–[[X]+X]+f[+fX]–X]+ff]+f[+ff]–ff,
    followed perhaps by f–[[ f–[[ff]+ff]+f[+fff]–ff]+ff]+f[+ff]–ff, which can now
    be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: The `makeString()` function 1 calls itself to expand the non-terminal X symbols
    into strings and append these to the string being constructed. It will only call
    itself to a depth specified by the first parameter, `levels`, and will then return,
    thus guaranteeing that the program will eventually end. The string generated by
    the grammar is passed to the `drawPlant()` function 2, which executes each character
    as a graphical operation, thus drawing the plant. In the function `void` `drawPlant(float
    length, float angle, String s, int drawLevel)`, the first parameter, `length`,
    is the length of the line to draw (for the symbol f); the `angle` is the rotation
    angle for the + and - characters; `s` is the string generated by `makeString()`;
    and `drawLevel` indicates a depth level for drawing lines. Essentially, `makeString()`
    creates a string that is a program for how to draw the plant, and `drawPlant()`
    executes that program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 70: Warping an Image'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1991 the general public saw morphing for the first time, an effect that uses
    a computer to smoothly convert one image into another. The computer produces a
    small sequence of images so that, when played back as a video sequence, an object
    appears to continuously change shape to become the other. The film *Terminator
    2* used it and, probably most strikingly, the Michael Jackson music video for
    the song “Black or White” used it in a sequence where faces morphed into one another.
    This sketch performs a warp or bending of an image, but does not do a complete
    morph.
  prefs: []
  type: TYPE_NORMAL
- en: The principle underlying the morphing method is something called a polynomial
    warp. Imagine we place an image over a regular grid and then bend the grid using
    a mathematical function and take the image with it. The result is an image that
    changes in a particular way—a warp. Morphing between two images requires that
    we establish a correspondence between the image, usually by a human. A function
    bends (maps) one image into another (a warp) while the pixel color values change
    systematically from the source to the destination values.
  prefs: []
  type: TYPE_NORMAL
- en: If the image is a face and the warp is based on a sine curve, we get an effect
    that looks like a funhouse mirror, as shown in [Figure 70-1](#figure70-1). The
    geometry of the original face bends (maps) into that of the new one according
    to the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![f070001](Images/f070001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 70-1: Warping a face'
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch implements an image warp. We read an image and display the pixels
    according to a sine function transformation of coordinates. The original image
    is `source`, and this is the mapping between original and new pixel coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This mapping is arbitrary, chosen for an amusing effect. The loop that does
    the mapping 2 has to map pixel values from the destination back to the source,
    not the other way around. Each pixel in the source does correspond to a pixel
    in the destination, but there may be unmapped pixels in the result if we do the
    mapping the other way. So for each pixel `(x,y)` in the destination image, we
    transform it to `(newX, newY)` values using the desired function and then find
    the corresponding pixel in the source image. We then set the destination `(x,y)`
    to the source `(newX, newY)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the sketch, the values of `ds` and `size` are parameters to the transformation
    function, and they change slightly each frame 1, creating a cyclical change in
    the image that a person will perceive as an animation of the bending or warping
    motion.
  prefs: []
  type: TYPE_NORMAL
