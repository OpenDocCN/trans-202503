- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HEURISTIC-GUIDED
    SEARCHES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">启发式引导搜索</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter introduces *heuristic-guided search* algorithms, sometimes called
    *best-first searches*. These algorithms incorporate heuristic information about
    nodes’ estimated distance from the goal to prioritize the order in which to explore
    them. By focusing on the most promising paths toward the goal, they can achieve
    significant computational savings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*启发式引导搜索*算法，有时也称为*最佳优先搜索*。这些算法结合了节点与目标之间估算的距离信息，以确定探索节点的优先顺序。通过关注最有前景的路径，它们能够实现显著的计算节省。
- en: As we saw in the last chapter, finding the shortest (or lowest-cost) path from
    a specified start node to a specified goal node mirrors the daily task of navigating
    through the world. When planning a route to work or the store, we might measure
    cost by the time taken, the distance traveled, or the aggravation incurred due
    to the number of bad intersections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，从指定的起始节点到指定目标节点找到最短（或最低成本）路径的过程，类似于我们日常导航的任务。无论是规划前往工作地点还是商店的路线，我们可能会通过所需时间、行驶距离或由于交叉路口拥堵所带来的烦恼来衡量成本。
- en: After explaining what constitutes a heuristic, this chapter introduces two canonical
    heuristic search algorithms. *Greedy best-first search* prioritizes nodes solely
    by their estimated cost to the goal, while *A* search* (pronounced “A-star”) combines
    the cost to reach an intermediary node with the estimated cost from that node
    to the goal. This combination makes A* search a much more powerful tool for efficiently
    finding good paths.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释启发式方法的构成之后，本章介绍了两种典型的启发式搜索算法。*贪心最佳优先搜索*仅根据估算的到达目标的成本来优先考虑节点，而*A*搜索*（读作“A星”）则将到达中介节点的成本与从该节点到目标的估算成本相结合。这种组合使得A*搜索成为一种更强大的工具，能够高效地找到良好的路径。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing Appropriate Heuristics</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">选择合适的启发式方法</samp>
- en: The algorithms in this chapter rely on estimated costs to guide their searches.
    To add such heuristic information to an algorithm, we must pick a method of estimating
    costs from what we know about each node. While the difficulty of defining a good
    heuristic varies widely across problems, the approaches for many real-world scenarios
    are simple and intuitive. After introducing Euclidean distance as a common heuristic
    used in path planning, we discuss the constraints and challenges involved in choosing
    heuristics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的算法依赖于估算成本来指导搜索。为了将这种启发式信息加入到算法中，我们必须根据我们对每个节点的了解，选择一种估算成本的方法。尽管定义一个好的启发式方法在不同问题中的难度差异较大，但许多实际场景中的方法既简单又直观。在介绍欧几里得距离作为路径规划中常用的启发式方法后，我们将讨论选择启发式方法时涉及的约束和挑战。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Euclidean Distance</samp>
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">欧几里得距离</samp>
- en: '*Euclidean distance* is a common, powerful, and intuitive heuristic used in
    many real-world path-planning problems that estimates the cost to a node at a
    given location by the straight-line distance to get there. For example, suppose
    we are navigating a cross-country road trip from Boston to Seattle. If the starting
    city is located at (*x*[1], *y*[1]) and the destination is at (*x*[2], *y*[2]),
    then the Euclidean distance between the two is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*欧几里得距离*是一个常见的、强大且直观的启发式方法，广泛应用于许多现实世界的路径规划问题中。它通过直线距离来估算到达某个节点的成本。例如，假设我们正在进行一次横跨美国的公路旅行，从波士顿到西雅图。如果出发城市位于（*x*[1]，*y*[1]）而目的地位于（*x*[2]，*y*[2]），则两者之间的欧几里得距离如下所示：'
- en: <mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>=</mo> <msqrt><mrow><mfenced><mrow><msup><mrow><mfenced><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>−</mo> <msub><mi>x</mi> <mn>2</mn></msub></mrow></mfenced></mrow>
    <mn>2</mn></msup> <mo>+</mo> <msup><mrow><mfenced><mrow><msub><mi>y</mi> <mn>1</mn></msub>
    <mo>−</mo> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mfenced></mrow> <mn>2</mn></msup></mrow></mfenced></mrow></msqrt></mrow>
    ![dist, is equal to; the square root of open paren; open paren, x sub 1
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>=</mo> <msqrt><mrow><mfenced><mrow><msup><mrow><mfenced><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>−</mo> <msub><mi>x</mi> <mn>2</mn></msub></mrow></mfenced></mrow>
    <mn>2</mn></msup> <mo>+</mo> <msup><mrow><mfenced><mrow><msub><mi>y</mi> <mn>1</mn></msub>
    <mo>−</mo> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mfenced></mrow> <mn>2</mn></msup></mrow></mfenced></mrow></msqrt></mrow>
    ![dist, 等于；开括号；开括号，x 子 1
- en: minus x sub 2, close paren squared; plus, open paren, y sub 1 minus y sub
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 减去x下标2，右括号平方；加上，左括号，y下标1减去y下标
- en: 2, close paren squared; close paren end root](../images/pg112.jpg)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 2，右括号平方；右括号结束根](../images/pg112.jpg)
- en: 'We can code this equation as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个方程式编码如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unless you are a bird flying directly to your destination, Euclidean distance
    provides, at best, a lower bound of the true cost. Roads don’t exist between every
    pair of cities on the map. Even highways that stretch directly from one point
    to another are unlikely to follow a straight line, since they must curve around
    geographic features like mountains and lakes, lengthening your journey.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你像鸟一样直接飞往目的地，否则欧几里得距离充其量只能提供真实成本的下界。地图上的城市之间并非每对都有道路连接。即使是直接从一个点到另一个点的高速公路，也不太可能沿直线行驶，因为它们必须绕过地理特征，如山脉和湖泊，从而延长你的旅程。
- en: Despite its optimistic nature, Euclidean distance can provide vital heuristic
    information. For example, these estimates can help us choose appropriate waypoints
    as we plan a road trip. On a trip from Boston to Seattle, Cleveland would obviously
    make a better rest stop than Miami, because Miami is farther from both Seattle
    and Cleveland than our starting point.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管欧几里得距离具有乐观的特性，但它仍然能提供重要的启发式信息。例如，这些估算可以帮助我们在规划公路旅行时选择合适的途经点。在从波士顿到西雅图的旅途中，克利夫兰显然比迈阿密更适合作为休息站，因为迈阿密离西雅图和克利夫兰的距离都比我们的起点更远。
- en: '[Figure 8-1(a)](#fig8-1) shows an example graph on a two-dimensional plane.
    [Figure 8-1(b)](#fig8-1) shows the corresponding edge weights, which largely correspond
    to the straight-line distance between nodes. However, the cost between two nodes
    can also be *greater* than the Euclidean distance. The edge between nodes 2 and
    4 has a weight of 3.5, which could indicate additional cost, such as traversing
    a steep hill or using a dirt road. The cost of traversing between nodes (the edge
    weight) must simply be greater than or equal to the estimated distance.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-1(a)](#fig8-1)展示了一个二维平面上的示例图。[图8-1(b)](#fig8-1)展示了对应的边权重，这些权重大致对应于节点之间的直线距离。然而，两节点之间的成本也可能*大于*欧几里得距离。节点2和节点4之间的边的权重是3.5，这可能表示额外的成本，例如需要穿越陡峭的山丘或使用土路。节点之间的穿越成本（即边的权重）必须大于或等于估算距离。'
- en: '![In (A), a seven-node graph is shown on a 5 × 5 grid. Node 0 is at x=0, y=0
    and node 1 is at x=0, y=2\. In (B), each edge is labeled with the cost between
    the two nodes. The edge (0, 1) has a weight 2.0\. In (C), each node is labeled
    with the estimated distance to the goal.](../images/f08001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![在（A）中，展示了一个七节点图，位于5×5网格上。节点0位于x=0，y=0，节点1位于x=0，y=2。在（B）中，每条边都标有两个节点之间的成本。边（0，1）的权重是2.0。在（C）中，每个节点标有到目标的估算距离。](../images/f08001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: The weights and
    Euclidean distances between nodes on a 2D plane</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-1：二维平面上节点之间的权重和欧几里得距离</samp>
- en: Given this arrangement, we can provide lower-bound estimates of the potential
    cost from each node to the goal by taking the Euclidean distance from that node
    to the goal, as shown in [Figure 8-1(c)](#fig8-1), for a goal node of 6\. The
    estimated cost from node 0 to node 6 is 5.0, reflecting their Euclidean distance.
    As noted previously, these estimates do not always capture the full cost. For
    example, the estimated distance from node 0 to node 6 is too optimistic, as the
    node lacks a direct path to node 6.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种安排，我们可以通过计算从每个节点到目标的欧几里得距离，来提供从每个节点到目标的潜在成本的下界估算，如[图8-1(c)](#fig8-1)所示，对于目标节点6而言。从节点0到节点6的估算成本为5.0，反映了它们的欧几里得距离。如前所述，这些估算并不总是能够捕捉到全部成本。例如，从节点0到节点6的估算距离过于乐观，因为该节点没有直接到达节点6的路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Admissible Heuristics</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可接受的启发式方法</samp>
- en: We define a heuristic to be *admissible* if the estimated cost from the start
    node to the goal is always less than or equal to the true cost, or, in other words,
    if the heuristic does not overestimate the true cost. Euclidean distance, for
    example, is a common, effective, and admissible heuristic for real-world path
    planning, since the straight-line distance to our goal provides an optimistic
    estimate of the cost to get there. The admissibility requirement is essential
    for the correct operation of some searches, such as A* search, and will be one
    of our major constraints when choosing a heuristic for a given purpose.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义启发式方法为*可接受*，如果从起始节点到目标节点的估算成本始终小于或等于真实成本，或者换句话说，如果启发式方法不会高估真实成本。例如，欧几里得距离就是一个常见的、有效的且可接受的启发式方法，适用于现实世界的路径规划，因为到目标的直线距离提供了一个乐观的估算，表示到达目标的成本。可接受性要求对于某些搜索（如A*搜索）的正确运行至关重要，并且在选择用于特定目的的启发式方法时将是我们主要的约束之一。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Heuristic Design
    Challenges</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启发式设计挑战</samp>
- en: While it’s relatively easy to define a heuristic for estimating distances, let’s
    consider a more difficult case. Imagine you want to solicit an introduction to
    a new contact through your professional network. Each person (node) can reach
    out only to their present or past coworkers to pass along the request. To facilitate
    your introduction, you must find a sequence of weighted edges that indirectly
    connect you to the person you ultimately want to meet, where each edge weight
    represents the cost of passing along the request. The cost of passing the request
    to a friend with whom you converse daily would be low, while the cost of connecting
    with an annoying former coworker with whom you never want to speak again would
    be very high.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然定义估算距离的启发式方法相对简单，但让我们考虑一个更复杂的情况。假设你希望通过你的职业网络请求介绍认识一个新联系人。每个人（节点）只能通过联系他们现在或曾经的同事来传递这个请求。为了促进你的介绍，你必须找到一条加权边的序列，这些边间接地将你与最终想要见到的人连接起来，每条边的权重代表传递请求的成本。与一个每天都和你交谈的朋友联系，成本会很低，而与一个让你讨厌的前同事联系，且你再也不想和他交谈的成本则会非常高。
- en: Unfortunately, it’s difficult to capture all these factors with a single admissible
    heuristic. You might be able to glean some estimate of distance to the goal from
    each person’s job history. The estimated cost of communication through a person
    in a different industry from the goal node should generally be higher; for example,
    professional interactions between a professional baseball player and a computer
    scientist are rarer than those between two baseball players. Similarly, the estimated
    cost would be lower if the two individuals worked at the same company. However,
    piecing together positive and negative indicators like this makes it difficult
    to form a good quantitative estimate, as the indicators are too noisy. The fact
    that two people once worked together does not help you if they have never met
    or are nemeses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用单一的可接受启发式方法很难捕捉所有这些因素。你或许能从每个人的工作历史中获得一些对目标的距离估算。与目标节点来自不同产业的人的沟通成本通常会更高；例如，职业棒球运动员和计算机科学家之间的职业互动比两个棒球运动员之间的职业互动要少得多。同样，如果这两个人在同一家公司工作，估算的成本会更低。然而，将这些正面和负面指标拼凑在一起很难形成一个好的定量估算，因为这些指标过于嘈杂。事实上，两个曾经一起工作过的人，如果他们从未见过面或者是死敌，那么这个信息对你并没有帮助。
- en: Worse, it is much more difficult to ensure your heuristics for such problems
    are admissible. If you place a high cost on different industries, you will occasionally
    overestimate the cost of passing your message between them—perhaps you know a
    programmer who still talks regularly to the movie star who was their childhood
    best friend. Similarly, this metric would not capture the family members who work
    for different companies but communicate often.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，确保这些问题的启发式方法是可接受的要困难得多。如果你对不同行业之间的成本设置了很高的权重，你偶尔会高估在它们之间传递信息的成本——也许你认识一位程序员，他仍然与曾是童年最好朋友的电影明星保持定期联系。同样，这个度量也无法捕捉到那些在不同公司工作但经常沟通的家庭成员。
- en: 'Choosing a good heuristic involves maximizing information while maintaining
    admissibility and minimizing computation cost. It is trivial to design an admissible
    heuristic by assigning each node a cost of negative infinity, but this strategy
    is obviously useless in guiding a search. Similarly, we can design a perfectly
    informative and admissible heuristic by using the algorithms in the previous chapter:
    we just solve the all-pairs shortest-path problem and compute the heuristic from
    the true lowest-cost path between each node and the goal. Yet this does not help
    either, as the computational cost of the search is too high. The point of a heuristic
    is to reduce the computational cost of the search itself. As we consider new problems
    and heuristics, it is always important to examine the trade-offs between information,
    computational cost, and admissibility.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个好的启发式方法需要在保持可接受性和最小化计算成本的同时最大化信息量。通过为每个节点分配负无穷大的代价来设计一个可接受的启发式方法是微不足道的，但显然这种策略对于引导搜索没有任何帮助。同样，我们可以通过使用上一章中的算法设计一个完美的信息丰富且可接受的启发式方法：我们只需解决所有节点对之间的最短路径问题，并根据每个节点与目标之间的真实最低成本路径来计算启发式方法。然而，这也没有任何帮助，因为搜索的计算成本过高。启发式方法的关键在于减少搜索本身的计算成本。在考虑新问题和启发式方法时，始终需要权衡信息量、计算成本和可接受性之间的关系。
- en: 'The following sections introduce two canonical heuristic searches, starting
    with the simplest approach: greedy best-first search.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节介绍了两种经典的启发式搜索算法，从最简单的方法开始：贪心最佳优先搜索。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Greedy Best-First Search</samp>
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">贪心最佳优先搜索</samp>
- en: A *greedy best-first search* always chooses the option that looks best at a
    given point in the search, exploring the next unvisited node with the lowest estimated
    cost based on the best heuristic value. The algorithm maintains a minimum priority
    queue of nodes to test. As it progresses toward the goal, at each step it chooses
    the lowest-cost node from the priority queue and explores that node next. Each
    time the algorithm sees new neighbors, it adds them to the queue with a priority
    equal to their heuristic value. The algorithm proceeds node by node until it finds
    a path to the goal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*贪心最佳优先搜索*总是在搜索中的某一点选择看起来最好的选项，基于最优启发式值探索估算成本最低的下一个未访问节点。该算法维持一个最小优先队列，用于测试节点。当它向目标推进时，每一步都从优先队列中选择最低成本的节点，并接着探索该节点。每当算法看到新的邻居节点时，它会将其添加到队列中，并赋予与其启发式值相等的优先级。该算法逐节点推进，直到找到通往目标的路径。'
- en: We can view greedy best-first search as a modification of breadth-first search.
    Whereas the latter search prioritizes nodes by the order in which they were seen,
    using a queue to visit the earliest-seen node, best-first search orders the nodes
    with a heuristic.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将贪心最佳优先搜索看作是广度优先搜索的一个变种。广度优先搜索优先考虑按照访问顺序排列的节点，使用队列访问最早看到的节点，而最佳优先搜索则通过启发式方法对节点进行排序。
- en: Greedy best-first search takes the approach we might expect of an eager but
    clever squirrel navigating a maze, as shown in [Figure 8-2](#fig8-2). The squirrel
    (S) can smell the delicious pile of acorns that is his goal destination (G). Using
    its nose, the squirrel can deduce the straight-line path he could take directly
    to the nuts, if there were no walls ([Figure 8-2(a)](#fig8-2)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心最佳优先搜索采用了我们可能会期望的方式，就像一只聪明但急切的松鼠在迷宫中穿行，正如[图8-2](#fig8-2)所示。松鼠（S）能闻到他目标目的地（G）那堆美味的橡果。通过嗅觉，松鼠可以推测出他如果没有墙壁的阻挡，可以直接走向橡果的直线路径（[图8-2(a)](#fig8-2)）。
- en: '![(A) shows a maze on a 5 × 5 grid with the cell in the middle of the top row
    labeled S and the cell in the bottom right labeled G. A gray arrow points directly
    from S to G. (B) shows the same maze with the cell to the left of S labeled with
    a minus, and the cells below it and to its right labeled with pluses.](../images/f08002.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个5×5网格的迷宫，顶部中间的单元格标记为S，右下角的单元格标记为G。一个灰色箭头直接从S指向G。 (B) 显示了同一个迷宫，其中S左侧的单元格标记为减号，S下方和右侧的单元格标记为加号。](../images/f08002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: A maze with a heuristic
    estimate of the goal’s direction</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-2：带有启发式目标方向估算的迷宫</samp>
- en: At any given location (node), the squirrel can also determine adjacent locations
    to which it can move and estimate which one will take it closer to the destination.
    The squirrel uses a smell-based heuristic—nodes with a stronger smell of acorns
    are closer to the goal. [Figure 8-2(b)](#fig8-2) shows that two of the neighboring
    squares will move the squirrel closer to the acorns (+), while one will move it
    farther away (–). The squirrel always chooses the path with the strongest smell,
    following the scent toward the food, sometimes backtracking to points where the
    smell was stronger than the current location. Along the way, it mentally notes
    alternative paths and adds them to the list of options to try.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定的位置（节点），松鼠还可以确定它可以移动到的相邻位置，并估计哪一个能将它带得离目标更近。松鼠使用基于气味的启发式方法——气味更强的橡果节点更接近目标。[图
    8-2(b)](#fig8-2)显示，两个相邻的方格将使松鼠更接近橡果（+），而一个则使它远离橡果（–）。松鼠始终选择气味最强的路径，沿着气味朝食物前进，有时会回溯到气味比当前地点更强的点。在此过程中，它会在脑海中记下其他路径，并将它们加入到待尝试的选项列表中。
- en: Although greedy best-first search might quickly find a path to the goal if it
    is working with a good heuristic, the final path is not guaranteed to be optimal.
    We might take a path that looks good due to an optimistic estimate at an early
    node and skip a better path with a more realistic estimate. The squirrel might
    take a longer path that temporarily curves away from the food simply because the
    smell was stronger in that direction. We will see an example of this scenario
    later in this section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然贪婪的最佳优先搜索如果使用了好的启发式方法，可能会快速找到通向目标的路径，但最终路径并不保证是最优的。我们可能会走一条看起来不错的路径，因为在早期节点时的乐观估计，而跳过了一条更好的路径，尽管它的估计更为现实。松鼠可能会走一条较长的路径，暂时偏离食物的方向，仅仅因为那个方向的气味更强。我们将在本节后面看到这个场景的示例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'To implement the greedy search algorithm, we need to provide an additional
    piece of information beyond what we included in earlier searches: the nodes’ heuristic
    values. There are multiple approaches to providing this information. For clarity
    of illustration, we’ll start by passing a precomputed list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>
    that maps the nodes’ indices to their heuristic values, and we’ll introduce an
    alternative method later in the chapter.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现贪婪搜索算法，我们需要提供比之前搜索中包含的更多的信息：节点的启发式值。有多种方法可以提供这些信息。为了清晰地说明，我们将从传递一个预先计算好的列表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>开始，该列表将节点的索引与它们的启发式值对应起来，稍后在本章中我们将介绍一种替代方法。
- en: 'The code for greedy best-first search is similar to that of breadth-first search.
    Instead of using a queue to store the nodes in the order they were seen, we use
    a custom *min-heap-based priority queue* (described in [Appendix B](appendix_B.xhtml))
    to retrieve nodes in order of decreasing estimated cost:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪的最佳优先搜索的代码类似于广度优先搜索的代码。我们不是使用队列按照节点被访问的顺序来存储节点，而是使用一个自定义的*基于最小堆的优先级队列*（在[附录
    B](appendix_B.xhtml)中描述）来按估计成本递减的顺序获取节点：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code starts by setting up the internal data structures, including a list
    indicating whether we have visited each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>),
    a list mapping each node to the one that preceded it on the search path (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), and a minimum priority queue
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>). It then inserts the
    starting node into the priority queue, with its heuristic cost as the priority
    ❶. In the squirrel maze analogy, this marks the point right before the squirrel’s
    search begins. Standing ready outside the maze, it smells the acorns and has one
    available option on its mental priority queue: the starting node.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先设置内部数据结构，包括一个列表，用于指示我们是否已经访问过每个节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>），一个列表，将每个节点映射到它在搜索路径中前面的节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>），以及一个最小优先级队列（<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>）。然后，它将起始节点插入到优先级队列中，并以它的启发式成本作为优先级
    ❶。在松鼠迷宫的类比中，这标志着松鼠搜索开始之前的那个点。它站在迷宫外，闻到橡果的气味，并且在它的心理优先级队列中有一个可用的选项：起始节点。
- en: The exploration of greedy best-first search takes place in a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that continues exploring until the code has either exhausted the priority
    queue or visited the goal node ❷. At each iteration, the code retrieves the next
    node on the priority queue—the one with the best heuristic value—and visits that
    node. You can picture this as the squirrel running to the location of the next
    best option.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心最佳优先搜索的探索过程是在一个<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环中进行的，直到代码耗尽优先队列或访问到目标节点❷为止。在每次迭代中，代码会检索优先队列中的下一个节点——具有最佳启发式值的节点——并访问该节点。你可以将其想象成松鼠奔向下一个最佳选择的位置。
- en: The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to iterate over each of the current node’s neighbors. If a neighbor has not been
    visited and is not in the priority queue, then it has not been seen before ❸.
    The code therefore adds it to the priority queue (with the estimated distance
    as the priority) and marks the current node as the step before it in the path.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历当前节点的每个邻居。如果某个邻居没有被访问过且不在优先队列中，那么它之前没有被看到❸。因此，代码会将其加入优先队列（以估算的距离作为优先级），并将当前节点标记为该邻居的前一步。
- en: When the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop completes,
    the greedy search will have either found a path to the goal node or discovered
    that no such path exists. In the former case, unlike other algorithms we have
    seen previously, there may still be unexplored nodes on the priority queue. In
    the latter case, the priority queue will be empty; there are no more nodes to
    explore. The goal node’s entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, reflecting the
    lack of any path back to the starting node. The code concludes by returning the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环完成时，贪心搜索要么找到了通往目标节点的路径，要么发现没有这样的路径。在前一种情况下，与我们之前看到的其他算法不同，优先队列中可能仍然有未探索的节点。在后一种情况下，优先队列将为空；没有更多的节点可供探索。目标节点在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>中的条目将为<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，表示没有任何路径返回到起始节点。代码最终通过返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>列表来结束。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: '[Figure 8-3](#fig8-3) shows an example greedy best-first search on the graph
    from [Figure 8-1](#fig8-1). In each subfigure, the current node being explored
    is enclosed in a dashed circle, while nodes that have been visited are shaded.
    The edge weights are shown alongside each edge.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-3](#fig8-3)展示了一个在[图8-1](#fig8-1)中的图上进行的贪心最佳优先搜索示例。在每个子图中，当前正在探索的节点被虚线圆圈包围，而已访问的节点则被阴影标记。每条边的权重显示在每条边旁边。'
- en: '![Each subfigure shows the seven-node graph from Figure 8-1 along with the
    sorted priority queue and the last array. (B) shows node 0 shaded and circled.
    The last array reads [–1, 0, 0, 0, –1, –1, –1] and the priority queue has nodes
    2, 1, and 3 with priorities 2.24, 3.60, and 4.0, respectively.](../images/f08003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了图8-1中的七节点图，并附带排序后的优先队列和最后数组。(B)显示了节点0被标记和圈出。最后的数组为[–1, 0, 0, 0, –1,
    –1, –1]，优先队列中包含节点2、1和3，它们的优先级分别为2.24、3.60和4.0。](../images/f08003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The steps of a
    greedy best-first search</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-3：贪心最佳优先搜索的步骤</samp>
- en: 'To avoid cluttering the illustrations, the heuristic values for each node are
    not shown directly in [Figure 8-3](#fig8-3). However, these heuristic values are
    the same Euclidean distances as shown in [Figure 8-1(c)](#fig8-1). We provide
    them to the algorithm as a list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免图示过于拥挤，[图8-3](#fig8-3)中没有直接显示每个节点的启发式值。然而，这些启发式值与[图8-1(c)](#fig8-1)中显示的欧几里得距离相同。我们将它们作为列表<samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>提供给算法：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each subfigure also shows the current priority queue (in sorted order for illustration)
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list. Although
    the code maintains the priority queue in heap ordering, we show the priority queue
    in sorted order to make the relative orderings clearer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子图还展示了当前的优先队列（为清晰起见以排序顺序显示）和<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>列表。虽然代码保持优先队列的堆排序，但我们以排序顺序展示优先队列，以便更清楚地看到相对顺序。
- en: 'The search begins by putting the start node into the priority queue with its
    corresponding cost estimate 5.0, as shown in [Figure 8-3(a)](#fig8-3). During
    the first iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, it dequeues node 0 from the priority queue, visits it, and adds each previously
    unseen neighbor to the priority queue, as shown in [Figure 8-3(b)](#fig8-3). The
    priorities for the nodes are equal to their heuristic costs (that is, the Euclidean
    distances to the goal node) as given in [Figure 8-1(c)](#fig8-1): node 1 = 3.6,
    node 2 = 2.24, and node 3 = 4.0\. The search sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    values to 0 for each of these neighbors to indicate that the path toward them
    comes from node 0.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从将起始节点放入优先队列并赋予其对应的成本估算值 5.0 开始，如[图 8-3(a)](#fig8-3)所示。在< s amp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环的第一次迭代中，它从优先队列中移除节点 0，访问该节点，并将每个之前未见过的邻居添加到优先队列，如[图 8-3(b)](#fig8-3)所示。节点的优先级等于其启发式成本（即到目标节点的欧几里得距离），如[图
    8-1(c)](#fig8-1)所示：节点 1 = 3.6，节点 2 = 2.24，节点 3 = 4.0。搜索为这些邻居设置了< s amp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    值为 0，以指示前往它们的路径来自节点 0。
- en: At each step in the search, the algorithm chooses the node that looks most promising
    as it progresses toward the goal. Checking the priority queue, it moves on to
    node 2\. As shown in [Figure 8-3(c)](#fig8-3), it then adds node 2’s unvisited
    neighbors to the priority queue. With priority 2.24, node 4 now sits at the top
    of the queue. The search progresses through node 4 in [Figure 8-3(d)](#fig8-3)
    to the goal node in [Figure 8-3(e)](#fig8-3).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索的每一步，算法都会选择看起来最有前途的节点，朝着目标前进。检查优先队列后，它继续处理节点 2。如[图 8-3(c)](#fig8-3)所示，它随后将节点
    2 的未访问邻居添加到优先队列中。节点 4 现在以优先级 2.24 排在队列的最前面。搜索通过节点 4 进展，最终到达目标节点，如[图 8-3(d)](#fig8-3)和[图
    8-3(e)](#fig8-3)所示。
- en: As you can see from this example, greedy best-first search does not produce
    an optimal path to the goal. The search is lured to node 2 with the promise of
    its proximity to the goal node, but is forced to detour through node 4 and over
    a costly 3.5 weighted edge. Greedy best-first search cannot tell that it would
    have been better to progress through node 1, because it doesn’t consider the cost
    of the paths to get to a node. It looks only at the estimated cost from a given
    node to the goal and uses that for prioritization. By the time the search has
    finished visiting node 2, it has already seen that node 4 has a better heuristic
    value than node 1.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，贪婪最佳优先搜索并未产生通向目标的最优路径。搜索被节点 2 的目标邻近性吸引，但最终被迫绕过节点 4，经过一个代价为 3.5 的高权重边。贪婪最佳优先搜索无法判断通过节点
    1 会是更好的选择，因为它没有考虑到通向节点的路径成本。它仅仅看待从某个节点到目标的估算成本，并将其作为优先级的依据。等到搜索访问完节点 2 时，它已经看到节点
    4 的启发式值比节点 1 更优。
- en: 'We can picture this suboptimality in the context of a frustrating bicycle trip.
    Suppose that after a morning of cycling with no destination in mind and without
    paying attention to the path, you and your friend are exhausted and want to find
    your way home. You stop at a fork in the road and consider the options. You know
    the left path ends at an intersection adjacent to your house but traverses a small
    mountain to get there. The right path is flat but terminates at an intersection
    a few blocks away from your house. Both paths get you closer to home, but with
    radically different costs (edge weights). Unfortunately, a greedy algorithm doesn’t
    take that into consideration. Before you can open your mouth, your overeager friend
    lets out a cheer and pedals up the left path. When you try to protest, they just
    call out, “Who cares about a little hill? This path gets us closer.”  ### <samp
    class="SANS_Futura_Std_Bold_B_11">A* Search</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过一个令人沮丧的骑行旅行来形象化这种次优性。假设在一个上午的骑行中，你们没有目的地，也没有注意到路径，最终你和你的朋友都感到筋疲力尽，想要找到回家的路。你们停在一个岔路口，开始考虑各自的选择。你知道左侧的路尽头是一个与你家相邻的交叉口，但为了到达那里，必须翻越一座小山。右侧的路是平坦的，但终点是离你家几条街的交叉口。两条路都能让你们更接近家，但代价（边的权重）却有天壤之别。不幸的是，贪婪算法并未考虑这一点。在你开口之前，你那过于急切的朋友欢呼一声，便骑上了左侧的路。当你试图抗议时，他们只是喊道：“一点小山坡有什么关系？这条路让我们更接近家。”  ###
    <samp class="SANS_Futura_Std_Bold_B_11">A* 搜索</samp>'
- en: A* search combines the heuristic estimates of greedy best-first search with
    a more comprehensive accounting for the observed edge costs, providing an efficient
    mechanism for finding the shortest path between two nodes. Whereas greedy best-first
    search completely ignores the edge cost, A* balances the promise of the heuristic
    estimates with the cold, hard facts about the best paths we have seen to each
    node. This combination results in an accurate and computationally efficient algorithm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: A* 搜索将贪心最佳优先搜索的启发式估算与对已观察到的边缘成本的更全面的考虑相结合，提供了一种高效的机制，用于找到两个节点之间的最短路径。而贪心最佳优先搜索完全忽略边缘成本，A*
    则平衡了启发式估算的潜力与我们对每个节点的最佳路径所了解的冷硬事实。这种结合产生了一个准确且计算高效的算法。
- en: 'The key intuition behind the A* algorithm is that we want to rank potential
    nodes in our path by their estimated <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>
    cost. It is not sufficient to focus on the cost from the current node to the goal;
    we also must ask how expensive it was to get to that node in the first place.
    To answer this question, A* tracks an additional piece of information: the cost
    of the best path found so far to each node. As shown in [Figure 8-4](#fig8-4),
    the priority used for unvisited nodes is then just the sum of the cost of the
    best path to the node so far plus the estimated cost of traveling from that node
    to the goal.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: A* 算法背后的关键直觉是，我们希望按估算的<samp class="SANS_TheSansMonoCd_W5Regular_11">总</samp>成本对潜在的路径节点进行排序。仅仅关注从当前节点到目标的成本是不够的；我们还必须问，首先到达该节点的成本有多高。为了回答这个问题，A*
    跟踪一个额外的信息：到每个节点的最佳路径所需的成本。如[图 8-4](#fig8-4)所示，用于未访问节点的优先级是到该节点的最佳路径成本加上从该节点到目标的估算成本之和。
- en: '![Three nodes, S, C, and G. The path between S and C is labeled “Best cost
    S to C” and the path between C and G is labeled “Estimate C to G.”](../images/f08004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![三个节点，S、C 和 G。S 到 C 之间的路径标注为“Best cost S to C”，C 到 G 之间的路径标注为“Estimate C to
    G。”](../images/f08004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: The combination
    of true cost to a node and estimated cost to the goal</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-4：节点的真实成本与目标的估算成本的结合</samp>
- en: 'In contrast to the eager squirrel’s demonstration of greedy best-first search,
    we can visualize A* search as a more meticulous explorer with an advanced degree
    in cartography searching for a path to a proposed archeological dig site. In addition
    to the standard compass, canteen, and obligatory exploring hat, our protagonist
    carries a clipboard to track information about the area. They represent each node
    as a row with three columns of information: the best cost to the node (titled
    Best Cost), the best path to the node (Best Path), and the estimated total cost
    to the goal through that node (Heuristic). Throughout their journey, the explorer
    continually updates these three columns of information.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与急躁的松鼠展示的贪心最佳优先搜索相比，我们可以将 A* 搜索可视化为一个更为细致的探险者，他拥有高级制图学学位，正在寻找通往提议的考古挖掘现场的路径。除了标准的指南针、水壶和必备的探险帽，我们的主角还携带着一个文件夹来追踪有关该地区的信息。他们将每个节点表示为一行，包含三列信息：到该节点的最佳成本（标题为
    Best Cost）、到该节点的最佳路径（Best Path）以及通过该节点到达目标的估算总成本（Heuristic）。在整个旅程中，探险者不断更新这三列信息。
- en: The explorer travels from village to village (node to node). GPS coordinates
    provide an estimate of the shortest possible distance. Signposts, trail markers,
    and in-person interviews reveal the actual distance to neighboring nodes. Each
    time the explorer discovers a new node, they compute its estimated cost to the
    goal and write that down in the Heuristic column.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 探险者从一个村庄到另一个村庄（从一个节点到另一个节点）旅行。GPS 坐标提供了最短可能距离的估算。路标、路径标记和面对面的访谈揭示了到邻近节点的实际距离。每当探险者发现一个新节点时，他们会计算到目标的估算成本，并将其记录在启发式（Heuristic）列中。
- en: As their journey continues, the explorer always moves to the next location (node)
    with the lowest estimated total cost. Each time they consider a neighboring location,
    whether new or previously seen, they ask themselves whether they’ve found a better
    path to that node than they had previously discovered. If so, they document this
    discovery in the Best Cost and Best Path columns. Perhaps earlier in their journey
    they discovered a 10-mile trail through a dense, spider-infested jungle to reach
    the archeology site. Their notes detail this path and its tremendous cost. However,
    they later discover a new, three-mile-long paved highway to the same site via
    a small village to the east. They eagerly erase their old values and update both
    the Best Cost and the Best Path columns to reflect this new find.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着旅程的继续，探险者总是朝着估算总成本最低的下一个位置（节点）移动。每次他们考虑一个邻近位置，无论是新位置还是以前见过的，他们都会问自己是否发现了比之前更好的路径到达该节点。如果是，他们会在最佳成本和最佳路径栏目中记录这一发现。也许在旅程的早期，他们发现了一条穿越密林、蜘蛛横行的10英里小道通向考古遗址。他们的笔记详细记录了这条路径和它的巨大成本。然而，他们后来发现了一条新的、三英里长的铺设公路，通过东边的一个小村庄通往同一地点。他们急切地擦掉旧的记录，并更新最佳成本和最佳路径栏目，以反映这一新发现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: The code for A* search in [Listing 8-1](#list8-1) orders the potential nodes
    by the estimated total cost through that node and onto the goal. Again, it uses
    a precomputed list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> of heuristic
    values for each node.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](#list8-1)中的A*搜索代码根据通过该节点并通向目标的估算总成本对潜在节点进行排序。它再次使用了一个预先计算的列表 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>，该列表包含每个节点的启发式值。'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: The code for A*
    search</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-1: A* 搜索的代码</samp>'
- en: The code starts by setting up the internal data structures, including a list
    indicating whether it has visited each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>),
    a list mapping each node to the one that preceded it on the search path (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), a list storing the cost
    of the best path found from the starting node to each subsequent node (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>),
    and a minimum priority queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>).
    It inserts the starting node into the priority queue, with its estimated cost
    as the priority, and sets the cost of the starting node to 0 to reflect the fact
    that the search is already at that node ❶.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先设置内部数据结构，包括一个列表，表示是否访问过每个节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>），一个列表，将每个节点映射到其在搜索路径上前面的节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>），一个列表，存储从起始节点到每个后续节点的最佳路径成本（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>），以及一个最小优先队列（<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>）。它将起始节点插入到优先队列中，以其估算成本作为优先级，并将起始节点的成本设置为0，以反映搜索已到达该节点
    ❶。
- en: The search is now ready to begin. A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop continues exploring nodes until the code has either exhausted the priority
    queue or visited the goal node ❷. At each iteration, the code retrieves the next
    node on the priority queue—the node with the lowest estimated total cost to the
    goal—and visits it next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索现在准备开始了。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环将继续探索节点，直到代码耗尽优先队列或访问到目标节点
    ❷。在每次迭代中，代码从优先队列中取出下一个节点——到达目标的估算总成本最低的节点——并访问它。
- en: The algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate over each of the current node’s neighbors. It checks whether the
    current node provides a better path to the neighbor, computing the full cost by
    combining the best cost to the current node with the edge weight to the neighbor
    ❸. If the code finds a better path to a node, it updates both the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> lists. It then updates
    the neighboring node’s estimated total cost using the new cost to <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>
    plus the estimated cost from <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>
    to the goal ❹. If the neighbor is in the priority queue already, the code updates
    its priority with the <samp class="SANS_TheSansMonoCd_W5Regular_11">update_priority()</samp>
    function to take the new estimated total cost into account. Otherwise, it adds
    the node to the priority queue.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历当前节点的每个邻居。它检查当前节点是否提供了到邻居的更优路径，通过将到当前节点的最佳路径与到邻居的边权重相加来计算完整的成本
    ❸。如果代码找到到某个节点的更优路径，它会更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 列表。然后，它使用新的到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp> 的成本以及从 <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>
    到目标的估计成本，更新邻居节点的估计总成本 ❹。如果邻居已经在优先队列中，代码会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">update_priority()</samp>
    函数更新它的优先级，以考虑新的估计总成本。否则，它会将节点添加到优先队列中。
- en: As in greedy best-first search, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop in A* search completes when it has either found a path to the goal node or
    concluded that no such path exists—that is, if the search exhausts the priority
    queue before visiting the goal node. The code finishes by returning the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与贪心最佳优先搜索一样，当 A* 搜索完成时，要么找到了到目标节点的路径，要么得出结论没有这样的路径——也就是说，如果搜索在访问目标节点之前已经耗尽了优先队列。代码通过返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 列表来完成。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: '[Figure 8-5](#fig8-5) shows an example A* search. As in our example for greedy
    best-first search, we show the edge weights and again use the heuristics from
    [Figure 8-1(c)](#fig8-1):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-5](#fig8-5) 显示了一个 A* 搜索示例。与我们在贪心最佳优先搜索示例中一样，我们显示了边权重，并再次使用来自 [图 8-1(c)](#fig8-1)
    的启发式方法：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each subfigure also shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> array, and priority
    queue. The current node being explored is marked with a dashed circle and the
    visited nodes are shaded. Again, the priority queue is shown in sorted order for
    clarity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子图还显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 数组、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> 数组和优先队列。当前正在探索的节点用虚线圆圈标出，已访问的节点被阴影标记。为了清晰起见，优先队列按排序顺序显示。
- en: '[Figure 8-5(a)](#fig8-5) shows the initial state of the search before it visits
    the first node. The priority queue initially contains only the start node. Since
    the distance from the start node to itself is 0.0, the estimated total cost of
    the starting node is just the estimated distance to the goal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    array reflects the known costs to get to each node: 0.0 for the starting node
    and infinite for everything else, because the search has not observed a path to
    those nodes yet.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-5(a)](#fig8-5) 显示了搜索的初始状态，在访问第一个节点之前。优先队列最初只包含起始节点。由于从起始节点到其自身的距离为 0.0，因此起始节点的估计总成本只是到目标的估计距离。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> 数组反映了到达每个节点的已知成本：起始节点为 0.0，其它节点为无限大，因为搜索尚未观察到通往这些节点的路径。'
- en: '[Figure 8-5(a)](#fig8-5) represents our hypothetical explorer’s state before
    the start of an expedition. They have been hired to find the shortest path from
    a city (node 0) to a proposed archeological dig site (node 6). Before they land
    at the starting city, they have only a rough (and optimistic) estimate of the
    distance to the dig site given the geographical coordinates of its location. The
    explorer checks their lists, dons their helmet, and says, “I know the dig site
    is at least five miles from the city. It’s time to get started.”'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-5(a)](#fig8-5)代表了我们假设的探险者在开始探险前的状态。他们被雇佣来寻找从一个城市（节点0）到一个提议的考古挖掘地点（节点6）的最短路径。在到达起始城市之前，他们仅根据考古挖掘地点的地理坐标，对距离目标地的距离有一个粗略（且乐观的）估计。探险者检查他们的列表，戴上头盔，说：“我知道挖掘地点距离城市至少五英里，是时候开始了。”'
- en: '![Each subfigure shows the seven-node graph from Figure 8-1 along with the
    sorted priority queue, the last array, and the cost array.](../images/f08005.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了图8-1中的七节点图，以及排序后的优先队列、最后的数组和成本数组。](../images/f08005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: The steps of the
    A* algorithm on an example graph</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-5：A*算法在一个示例图上的步骤</samp>
- en: 'In [Figure 8-5(b)](#fig8-5), the search dequeues the top node from the priority
    queue and explores it. This is equivalent to our intrepid explorer arriving at
    the starting city and looking around. The search finds three neighbor nodes and
    computes their expected total cost as the sum of the distance to the current node,
    the edge weight to the neighbor, and the estimated cost from the neighbor to the
    goal, resulting in the following total estimated costs:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8-5(b)](#fig8-5)中，搜索从优先队列中出队最上面的节点并探索它。这相当于我们勇敢的探险者到达起始城市并四处观察。搜索发现三个邻近的节点，并计算它们的预期总成本，作为到当前节点的距离、到邻居的边权和从邻居到目标的估计成本的总和，得到以下总估算成本：
- en: 'Node 1: 0.0 + 2.0 + 3.6 = 5.6'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 节点1：0.0 + 2.0 + 3.6 = 5.6
- en: 'Node 2: 0.0 + 2.83 + 2.24 = 5.07'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 节点2：0.0 + 2.83 + 2.24 = 5.07
- en: 'Node 3: 0.0 + 3.0 + 4.0 = 7.0'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 节点3：0.0 + 3.0 + 4.0 = 7.0
- en: This corresponds to the explorer updating their lists after finding three roads
    out of the initial city. From a helpful signpost, they know the distance to the
    villages and their locations. Each road presents a potential path with a different
    estimated cost.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于探险者在找到三条通往起始城市的道路后更新他们的列表。从一个有用的路标上，他们知道村庄的距离和位置。每条道路提供了一个潜在的路径，并且每条路径的预估成本不同。
- en: Since the estimated total cost of node 2 looks the best, the search explores
    it next, as shown in [Figure 8-5(c)](#fig8-5). From there, it considers two neighbors,
    nodes 3 and 4\. Node 3 already has a lower cost from the starting node (3.0 versus
    2.83 + 2.24 = 5.07), so the search does not update its path or priority. The search
    has not seen node 4 before, so it provides an initial cost value of 2.83 + 3.5
    = 6.33 and a total cost estimate of 2.83 + 3.5 + 2.24 = 8.57\. This cost reflects
    the impact of both the path to node 2 and the extreme cost of traversing from
    node 2 to node 4.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节点2的估计总成本最优，搜索接下来会探索它，如[图8-5(c)](#fig8-5)所示。从这里，搜索会考虑两个邻居节点3和4。节点3从起始节点的成本已经较低（3.0对比2.83
    + 2.24 = 5.07），所以搜索不会更新它的路径或优先级。搜索从未见过节点4，因此提供了初始成本值2.83 + 3.5 = 6.33，以及总成本估计2.83
    + 3.5 + 2.24 = 8.57。这个成本反映了从节点2到节点4路径的极高成本。
- en: Through the eyes of the explorer, these decisions look similar. They see a signpost
    indicating two new villages. Village 3 is an additional 2.24 miles away. Compared
    to the direct path from city 0 to village 3, the detour through village 2 to village
    3 is much longer. They immediately realize there is no need to add an unnecessary
    stop and therefore refrain from updating the row for village 3\. In contrast,
    while the path to village 4 from village 2 is exceptionally difficult, it offers
    the prospect of getting closer to their goal, so they update the row for village
    4.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从探险者的视角来看，这些决策看起来很相似。他们看到一个路标，指示着两个新村庄。村庄3距离约2.24英里。与从城市0到村庄3的直线路径相比，绕过村庄2到村庄3的绕行路线要长得多。他们立刻意识到没有必要增加一个不必要的停靠点，因此决定不更新村庄3的行。相比之下，虽然从村庄2到村庄4的路径异常困难，但它有可能让他们更接近目标，因此他们更新了村庄4的行。
- en: The search continues by taking the unvisited node with the best estimated total
    cost. Unlike greedy search, it does not jump to the node estimated to be closest
    to the goal, in this case node 4\. Though this node has the best estimated cost
    to the goal (2.24), the cost of getting there using the current path is high (6.3
    through node 2). Instead, the search explores node 1, as shown in [Figure 8-5(d)](#fig8-5),
    and finds a better path to node 4, updating the estimated total cost to 2.0 +
    1.41 + 2.24 = 5.65\. It also updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array to indicate that the path to node 4 goes through node 1 instead of node
    2.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续进行，通过选择优先值最低的未访问节点来进行。与贪心搜索不同，A* 搜索不会直接跳到估计离目标最近的节点，这里是节点 4。虽然这个节点的估计成本（2.24）是最接近目标的，但使用当前路径到达它的成本较高（通过节点
    2 为 6.3）。相反，搜索探索了节点 1，如[图 8-5(d)](#fig8-5)所示，并找到了通往节点 4 的更好路径，更新了估计的总成本为 2.0 +
    1.41 + 2.24 = 5.65。同时，更新了 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    数组，表明通往节点 4 的路径是通过节点 1 而不是节点 2。
- en: This step mirrors the explorer thinking about the total cost of the route. The
    archologists who hired the explorer want a low-cost route to reach the site repeatedly.
    Knowing this, the explorer tries village 1 before crossing the mountain from village
    2 to village 4.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步反映了探险者思考路线总成本的过程。雇佣探险者的考古学家希望找到一条低成本的路线，反复到达现场。知道这一点后，探险者首先尝试从村庄 2 到村庄 4
    穿越山脉之前先探索村庄 1。
- en: 'The search continues to node 4 in [Figure 8-5(e)](#fig8-5), then node 6 in
    [Figure 8-5(f)](#fig8-5). At each stop, it considers the unvisited neighbors and
    checks whether it has found a better path. It stops after reaching node 6 because
    it knows it has found the best path to the goal, even without having visited nodes
    3 and 5.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Why
    A* Finds the Optimal Path</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索继续在[图 8-5(e)](#fig8-5)中前进到节点 4，然后在[图 8-5(f)](#fig8-5)中到达节点 6。在每个停顿点，搜索会考虑未访问的邻居，并检查是否发现了更好的路径。它在到达节点
    6 后停止，因为它知道自己已经找到了通向目标的最佳路径，即使没有访问节点 3 和 5。#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为何
    A* 能找到最优路径</samp>
- en: The skeptical reader might wonder how we can be sure A* search has found the
    best path, since it explores only a portion of the graph without visiting every
    node. However, as long as its heuristic is admissible, A* will always find the
    optimal path. To see why, let’s examine the state after A* search has reached
    the goal node through some path and consider an alternate path to the goal node
    through an unvisited node *v*. Because of our admissible heuristic and priority
    queue ordering, any path through node *v* must be longer than the one we have
    already found.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 怀疑的读者可能会问，我们如何确保 A* 搜索找到了最佳路径，因为它只探索了图的一部分，而没有访问每个节点。然而，只要其启发式是可接受的，A* 就一定能找到最优路径。为了理解原因，让我们分析一下
    A* 搜索通过某条路径到达目标节点后的状态，并考虑通过一个未访问的节点 *v* 到达目标节点的替代路径。由于我们使用的是可接受的启发式和优先队列排序，任何通过节点
    *v* 的路径必定比我们已经找到的路径更长。
- en: Since the search did not visit node *v* before the goal node, node *v*’s priority
    value (estimated total cost) must have been greater than the priority value of
    the goal node. At the point that the search visited the goal node, the goal node’s
    priority value equals the actual cost of the path found. The estimated cost to
    the goal is always 0 for the goal itself, so the goal’s priority value equals
    the cost to the node preceding it plus the corresponding edge weight. We are no
    longer relying on heuristics. We have an actual path cost.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于搜索在到达目标节点之前没有访问节点 *v*，因此节点 *v* 的优先值（估计总成本）一定大于目标节点的优先值。当搜索访问到目标节点时，目标节点的优先值等于已找到路径的实际成本。目标的估计成本总是为
    0，因为它本身就是目标节点，因此目标的优先值等于前一个节点的成本加上相应的边权重。我们不再依赖启发式方法，而是得到了实际的路径成本。
- en: In contrast, the priority value of the unvisited node *v* is a lower bound of
    the true distance due to use of an admissible heuristic. It can never be less
    than the true distance. Our heuristic is optimistic. Any path to the goal through
    node *v* must cost at least as much as node *v*’s priority value, which was greater
    than that of the goal node. Thus, the cost of a path to the goal through node
    *v* must be higher than the one already found.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，未访问节点 *v* 的优先值是使用可接受启发式方法后的真实距离的下界。它永远不可能小于真实距离。我们的启发式方法是乐观的。任何通过节点 *v*
    到达目标的路径，其成本至少与节点 *v* 的优先值相等，而这个优先值大于目标节点的优先值。因此，任何通过节点 *v* 到达目标的路径，其成本必定比已经找到的路径要高。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Applying A* to Puzzles</samp>
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">应用 A* 于难题</samp>
- en: As long as we can generate a useful and admissible heuristic, we can apply heuristic-based
    searches to efficiently find solutions for the puzzle graphs from [Chapter 6](chapter6.xhtml),
    such as the prisoners-and-guards puzzle. As a reminder, [Figure 8-6](#fig8-6)
    shows the state graph for that puzzle (originally introduced in [Figure 6-8](chapter6.xhtml#fig6-8)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们能生成一个有用且可接受的启发式，我们就可以应用基于启发式的搜索，来高效地为[第6章](chapter6.xhtml)中的难题图（例如囚徒与看守难题）找到解决方案。作为提醒，[图8-6](#fig8-6)展示了该难题的状态图（最初在[图6-8](chapter6.xhtml#fig6-8)中介绍）。
- en: '![A 16-node graph. Each node is labeled with a number and a three-element list
    describing the puzzle state.](../images/f08006.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![一个16节点的图，每个节点标有一个数字和一个描述难题状态的三元素列表。](../images/f08006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: The state graph
    for the prisoners-and-guards river-crossing puzzle</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-6：囚徒与看守过河难题的状态图</samp>
- en: 'We can use two basic facts about the physical properties of the boat to derive
    an admissible metric indicating the distance to the goal state:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用关于船只物理特性的两个基本事实来推导一个可接受的度量，表示到达目标状态的距离：
- en: The boat can carry at most two people. If there are *k* people on the left shore,
    we need to least *ceil*(*k* / 2) trips to get them all onto the right shore.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这艘船最多可以载两个人。如果左岸有*k*人，我们至少需要 *ceil*(*k* / 2) 次旅行才能将他们全部带到右岸。
- en: If the boat is on the right shore, it must return to the left shore before picking
    up more people.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果船在右岸，它必须先返回左岸才能接载更多的人。
- en: 'Using those conditions, we can define a function to generate the heuristic
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PGState</samp> stored in
    each node:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些条件，我们可以定义一个函数，从存储在每个节点中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PGState</samp>
    生成启发式值：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code loops over the graph’s nodes with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, checking the puzzle state of each node to determine the number of people
    on the left shore ❶. It then computes the minimum number of trips the boat needs
    to make from left to right by considering how many people still need to be moved
    over and noting that at most two people can come over each time ❷. It also computes
    the minimum number of trips the boat needs to make from right to left by noting
    that, while there are more passengers to transport, the boat needs to return to
    the left shore to pick them up ❸. The heuristic is the sum of these two sets of
    trips.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历图的每个节点，检查每个节点的难题状态以确定左岸的人数❶。然后，它通过考虑还需要移动的人数，并注意每次最多可以带两个人，计算船从左岸到右岸所需的最少次数❷。它还通过注意到虽然右岸有更多的乘客需要运输，但船必须返回左岸接他们，计算船从右岸到左岸所需的最少次数❸。启发式值是这两组旅行次数的总和。
- en: '[Table 8-1](#tab8-1) compares the values of this heuristic function for each
    state with the true distance to the goal node, which we calculate by counting
    the steps from each state to the goal in [Figure 8-6](#fig8-6). As you can see,
    the heuristic is admissible and never overestimates the true distance.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8-1](#tab8-1)将该启发式函数在每个状态下的值与通过计算从每个状态到目标的步骤得到的真实距离进行比较，如[图8-6](#fig8-6)所示。正如你所看到的，启发式是可接受的，并且从不高估真实距离。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Values
    from the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">pg_generate_heuristic()</samp>
    <samp class="SANS_Futura_Std_Book_11">Function vs. the True Distance to the Goal
    Node</samp>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表8-1：</samp> <samp class="SANS_Futura_Std_Book_11">来自</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pg_generate_heuristic()</samp> <samp
    class="SANS_Futura_Std_Book_11">函数的值与目标节点的真实距离</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">State</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">R</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">L</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">R</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">L</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">状态</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">R</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">L</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">R</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">L</samp> |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Heuristic distance</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">True distance</samp> | <samp class="SANS_Futura_Std_Book_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_Futura_Std_Book_11">9</samp>
    | <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: 'Given this heuristic function, we can run A* search on the river- crossing
    puzzle:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The prisoners-and-guards problem provides a demonstrative example of applying
    A* search to puzzles because we can enumerate the states and compare the heuristic
    values to the true best path. However, the structure of the graph, with a single
    long sequence of states without branches, means that A* search does not significantly
    outperform breadth-first search on this puzzle. In contrast, A* search could provide
    significant advantages on puzzles with much larger state spaces, since the power
    of A* search is its ability to focus on exploring only promising paths toward
    the goal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Searching Unknown Graphs</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the algorithms introduced in this chapter so far have treated both the
    graph and heuristic values as known items passed to the search, these approaches
    work equally well on problems for which the algorithm needs to dynamically construct
    an unknown graph. Consider the puzzle-building examples from [Chapter 6](chapter6.xhtml).
    There, we used breadth-first search to quite literally explore the state space,
    building up a graph as we encountered new nodes and edges. We can do the same
    thing with heuristically guided searches.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Instead of passing a list of heuristic values to each node, we could pass a
    function that dynamically evaluates the heuristic based on the information in
    the node. For example, if a node has auxiliary data *x* and *y*, indicating its
    spatial position, we could define the heuristic function to be the Euclidean distance
    from that node to the known goal position. In the case of a real-world explorer,
    this might correlate to their using a GPS to estimate the distance to the objective
    as they trek through the jungle.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不直接传递一个启发式值的列表给每个节点，而是传递一个函数，这个函数根据节点中的信息动态评估启发式。例如，如果一个节点有辅助数据 *x* 和 *y*，表示其空间位置，我们可以定义启发式函数为该节点到已知目标位置的欧几里得距离。对于一个现实世界的探险者来说，这可能类似于他们使用GPS来估算穿越丛林时距离目标的距离。
- en: 'We can visualize this dynamic construction and evaluation using the “clouded
    out” mechanism from video games. For example, [Figure 8-7](#fig8-7) shows a grid
    as a 5×5 maze. Explored areas like the long dead end at the bottom of the graph
    are shown as boxes, while unexplored areas are grayed out. Anything could be in
    the gray zone: a direct path to the goal, numerous dead ends, or a giant monster.
    We won’t know until we explore it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用视频游戏中的“遮罩”机制来可视化这个动态构建和评估的过程。例如，[图8-7](#fig8-7)展示了一个5×5迷宫的网格。像图底部的长死胡同这样的已探索区域显示为方块，而未探索区域则显示为灰色。灰色区域中可能有任何东西：通向目标的直接路径、无数的死胡同，或是一个巨大的怪物。我们在探索之前无法得知。
- en: '![The figure shows a grid as a 5 × 5 maze. Eleven of the cells are shown and
    the rest are grayed out.](../images/f08007.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![该图展示了一个5×5的迷宫网格。网格中展示了十一格，剩余的部分为灰色。](../images/f08007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-7: A maze with the
    unseen areas grayed out</samp>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-7：一个迷宫，未见区域被灰色显示</samp>
- en: In this section, we modify the code from [Listing 8-1](#list8-1) to conduct
    dynamic exploration by constructing the graph as new nodes are discovered. The
    auxiliary data structures such as <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    and distance must also be dynamically extended to account for new states.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们修改了[清单8-1](#list8-1)中的代码，通过在发现新节点时动态构建图来进行探索。辅助数据结构如<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>和distance也必须动态扩展，以便考虑到新状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'For our example code, we generalize the algorithm by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class. This class provides basic information about the puzzle, including the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例代码，我们通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>类来对算法进行泛化。这个类提供了关于谜题的基本信息，包括以下内容：
- en: The starting state’s index
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始状态的索引
- en: A given state’s neighbors
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定状态的邻居
- en: The cost of a transition between any two neighboring states
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意两个邻近状态之间的转换成本
- en: The heuristic value at a state
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个状态的启发式值
- en: Whether the current state is the goal
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态是否为目标
- en: Given this interface, we do not need to know anything about the state space
    ahead of time. Just like a real-life explorer consulting GPS and road signs, we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> interface throughout
    the algorithm to examine the local state of the world.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个接口，我们无需事先了解任何状态空间的信息。就像现实中的探险者咨询GPS和路标一样，我们在整个算法中使用<samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>接口来检查世界的局部状态。
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class
    does not need to enumerate the state space. It also does not need to construct
    and store the full graph. We can use functions like the ones in [Chapter 6](chapter6.xhtml)
    to dynamically determine a state’s neighbors given information about the state.
    This dynamic evaluation allows us to explore massive state spaces without a huge
    memory overhead.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>类不需要枚举状态空间。它也不需要构建和存储完整的图。我们可以使用像[第6章](chapter6.xhtml)中的函数，动态地根据状态信息确定一个状态的邻居。动态评估使我们能够在没有巨大内存开销的情况下探索庞大的状态空间。
- en: 'We can define a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class for the distance-based example search in this chapter as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为本章的基于距离的示例搜索定义一个简单的<samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>类，代码如下：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class stores
    the underlying graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>),
    the starting index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start_ind</samp>),
    and the goal index (<samp class="SANS_TheSansMonoCd_W5Regular_11">goal_ind</samp>).
    In this example, they are all provided by the user. The class then uses basic
    getter functions to provide the information needed. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp>
    returns the index of the starting state, while <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    lists the neighboring states. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp>
    function uses the actual edge cost between two nodes, or infinity if there is
    no such edge.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> 类存储底层图（<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）、起始索引（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">start_ind</samp>）和目标索引（<samp class="SANS_TheSansMonoCd_W5Regular_11">goal_ind</samp>）。在这个例子中，它们都是由用户提供的。然后，类通过基本的获取函数提供所需的信息。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp> 返回起始状态的索引，而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> 列出邻近的状态。<samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp>
    函数使用两个节点之间的实际边权重，如果没有这样的边，则返回无穷大。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function
    assumes that the node’s coordinates are stored in its label as an (*x*, *y*) tuple
    or list ❶ and uses the Euclidean distance to the goal as the heuristic ❷ (which
    requires the code to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    math</samp>). When creating the graph, we will also need to set the labels of
    the nodes to contain these coordinates.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> 函数假设节点的坐标存储在其标签中，以
    (*x*, *y*) 元组或列表的形式 ❶，并使用到目标的欧几里得距离作为启发式 ❷（这要求代码包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    math</samp>）。在创建图时，我们还需要将节点的标签设置为包含这些坐标。
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class,
    we create a modified version of A* search that dynamically allocates and fills
    the data structures. For simplicity’s sake, we use dictionaries to map each state’s
    index (or string) directly to the corresponding information, as shown in [Listing
    8-2](#list8-2).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> 类，我们创建了一个修改版的
    A* 搜索，该版本动态地分配和填充数据结构。为了简化，我们使用字典将每个状态的索引（或字符串）直接映射到相应的信息，如 [清单 8-2](#list8-2)
    所示。
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: An A* search for
    an unknown graph</samp>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 8-2：一个针对未知图的 A* 搜索</samp>
- en: The code in [Listing 8-2](#list8-2) defines a modified version of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">astar_search()</samp> function defined
    in [Listing 8-1](#list8-1), <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_dynamic()</samp>.
    This function creates empty helper data structures and inserts the starting state
    into each one ❶. The use of dictionaries means we do not need to know anything
    about the number of total states or their underlying indices. At this point, the
    data structure has information only about that single state because the code has
    not explored any others. It gets the index of the starting state from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp> function and
    its estimated cost (priority) via the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp>
    function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-2](#list8-2) 中的代码定义了一个修改版的 <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_search()</samp>
    函数（见 [清单 8-1](#list8-1)），即 <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_dynamic()</samp>。这个函数创建空的辅助数据结构并将起始状态插入到每个数据结构中
    ❶。字典的使用意味着我们不需要了解总状态的数量或它们的底层索引。在这一点上，数据结构仅包含那个单一状态的信息，因为代码尚未探索其他任何状态。它通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp> 函数获取起始状态的索引，并通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> 函数获取其估计成本（优先级）。'
- en: The [Listing 8-2](#list8-2) algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to explore states on the priority queue until it has either run out of states
    to explore or found the goal. During each iteration, the algorithm dequeues the
    most promising state (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>),
    marks it visited, and checks whether it is the goal by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp>
    function. In the real world, this might consist of entering a new city and looking
    around for familiar landmarks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-2](#list8-2)算法使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环来探索优先队列中的状态，直到没有更多状态可以探索或找到了目标。在每次迭代中，算法会出队最有前景的状态（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index</samp>），将其标记为已访问，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp>函数检查它是否为目标。在现实世界中，这可能类似于进入一个新城市并寻找熟悉的地标。'
- en: For each state it explores, the code checks all its neighbors using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function to return
    the state’s local neighborhood ❷. The code then computes the cost from the current
    node to that neighbor (<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>),
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp> function
    to return the edge weight. Similarly, it dynamically computes the heuristic value
    of that neighbor (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>) using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个探索的状态，代码使用<samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>函数检查所有邻居，以返回该状态的局部邻域❷。然后，代码计算从当前节点到该邻居的代价（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>），使用<samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp>函数返回边的权重。类似地，它通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp>函数动态计算该邻居的启发式值（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>）。
- en: Once it has the distance to the neighbor and that neighbor’s heuristic value,
    the code checks whether it has encountered the neighboring state before. It checks
    whether the state has been seen by testing whether it has an entry with any value
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp> dictionary
    ❸. If the neighboring state is not in the dictionary, it has never been seen and
    is added to each data structure. The neighboring state’s cost is the sum of the
    cost to get to the current state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>)
    plus the cost of the next state transition (<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>).
    The neighboring state’s priority is this best cost to that state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>)
    plus the heuristic estimate at that state (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到邻居的距离和该邻居的启发式值，代码会检查是否之前遇到过该邻居状态。它通过测试是否在<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>字典中有任何值的条目来检查该状态是否出现过❸。如果邻居状态不在字典中，说明它之前从未出现过，将其添加到每个数据结构中。邻居状态的代价是到达当前状态的代价（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>）加上下一状态转换的代价（<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>）。邻居状态的优先级是到达该状态的最佳代价（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>）加上该状态的启发式估算值（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>）。
- en: If the neighbor has been seen before ❹, the code checks whether the new path
    is better by comparing the neighbor’s cost (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>)
    with the cost through the new path (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>).
    If the code finds a better path, it updates the path to the state (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    the cost to reach the state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>),
    and the state’s priority. Again, the code updates the priority in the queue directly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邻居状态之前已经出现过❹，代码会通过比较邻居的代价（<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>）与新路径的代价（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>）来检查新路径是否更优。如果代码发现了更好的路径，它会更新到达该状态的路径（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>）、到达该状态的代价（<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>）以及该状态的优先级。再次强调，代码会直接更新队列中的优先级。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: Let’s apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_dynamic()</samp>
    function to the graph from [Figure 8-1](#fig8-1). Of course, the algorithm does
    not know the graph ahead of time. It does not even know how many nodes the graph
    has. All the code sees is what the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class provides.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend our graph from the greedy and A* examples shown in [Figures 8-3](#fig8-3)
    and [8-5](#fig8-5) by adding the node’s spatial position in its label, as in the
    following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Admittedly, while this manual assignment approach works for the purpose of setting
    up this demonstrative example, it leads to a long problem and tedious setup for
    a large number of points. We discuss programmatic approaches to reading in graph
    data in [Appendix A](appendix_A.xhtml).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-8](#fig8-8) shows the search. In [Figure 8-8(a)](#fig8-8), the algorithm
    knows the starting state with index 0 and the existence of a goal state. However,
    it knows nothing about the rest of the graph, including the edges out of node
    0\. The goal node doesn’t even have a number yet because the search has not seen
    it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: When the search visits node 0 in [Figure 8-8(b)](#fig8-8), it discovers three
    edges to three neighbors. Each of these edges has a weight provided by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp>
    function and a heuristic value provided by the class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp>
    function. While this is not much information, it is enough for us to build up
    a picture of the neighborhood around the starting state. The search augments its
    auxiliary data structures (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>) to account for this
    by adding new entries for the corresponding nodes. It does not explicitly create
    a graph or store the edges.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: This search follows the same sequence as the A* search example in [Figure 8-5](#fig8-5).
    The main difference in [Figure 8-8](#fig8-8) lies in what the search knows about
    the graph at each step. It is only guaranteed to have seen all the node’s edges
    once it visits that node. For example, while the algorithm knows about both nodes
    1 and 4 for several iterations, it does not learn about the edge between them
    until [Figure 8-8(d)](#fig8-8), when it has visited node 1.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows a partial graph, along with the sorted priority queue,
    the last array, and the cost array. (B) shows five nodes, where node 0 is shaded
    and circled, attached by edges to nodes 1, 2, and 3, and node G is not attached
    to any edges.](../images/f08008.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-8: The steps of an
    A* search algorithm on an unknown graph</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous A* search example, the code continues until it visits the
    goal node. At this point the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp> function
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, and we know
    that we have found the shortest path. However, as shown by [Figure 8-8(f)](#fig8-8),
    this does not mean the search has explored the entire graph. Not only did it skip
    visiting nodes 3 and 5, but it also never learned about the edge between them.
    There could be an entire world branching out beyond those nodes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 A* 搜索示例一样，代码继续执行，直到访问到目标节点。此时，<samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    类的 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp> 函数返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，我们知道已经找到了最短路径。然而，如
    [图 8-8(f)](#fig8-8) 所示，这并不意味着搜索已经遍历了整个图。它不仅跳过了访问节点 3 和 5，而且也没有了解它们之间的边缘。那些节点之外可能还有一个分支的整个世界。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: Greedy best-first search and A* search provide mechanisms for incorporating
    heuristic estimates into our search algorithms, helping us find the best paths
    between two nodes. Greedy best-first search is simple and needs to track very
    little information but may produce nonoptimal paths. The combination of an admissible
    (optimistic) heuristic and good bookkeeping on the cost so far allows A* search
    to efficiently choose which nodes to explore while guaranteeing it finds the lowest-cost
    path.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心最佳优先搜索和 A* 搜索提供了将启发式估计纳入搜索算法的机制，帮助我们找到两个节点之间的最佳路径。贪心最佳优先搜索简单，所需跟踪的信息很少，但可能产生非最优路径。通过结合一个可接受的（乐观的）启发式方法和对目前成本的良好记录，A*
    搜索能够高效地选择要探索的节点，同时保证找到最低成本路径。
- en: The main advantage of these algorithms, particularly A*, is that the use of
    heuristic information focuses the search. Just as GPS coordinates can help us
    determine which of two possible roads will bring us to our destination more quickly,
    heuristics allow us to prioritize which nodes to explore next. As a result, A*
    search is a practical algorithm that has become a staple of artificial intelligence
    and video game path planning.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的主要优点，特别是 A* 算法， lies in the use of heuristic information to focus the search.
    就像 GPS 坐标可以帮助我们确定两条可能的道路中哪一条更快到达目的地一样，启发式方法允许我们优先考虑接下来探索的节点。因此，A* 搜索是一种实用的算法，已成为人工智能和视频游戏路径规划的核心算法之一。
- en: In the next part of the book, we step away from search algorithms and examine
    tasks related to the connectivity of graphs. We review how to sort nodes in a
    directed graph, consider how to test the connectivity of graphs, and examine random
    behavior on graphs. Many of these algorithms use searches as a core component.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将不再讨论搜索算法，而是研究与图的连通性相关的任务。我们回顾如何在有向图中对节点进行排序，考虑如何测试图的连通性，并研究图上的随机行为。许多这些算法将搜索作为核心组件。
