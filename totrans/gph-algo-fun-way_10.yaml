- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HEURISTIC-GUIDED
    SEARCHES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces *heuristic-guided search* algorithms, sometimes called
    *best-first searches*. These algorithms incorporate heuristic information about
    nodes’ estimated distance from the goal to prioritize the order in which to explore
    them. By focusing on the most promising paths toward the goal, they can achieve
    significant computational savings.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the last chapter, finding the shortest (or lowest-cost) path from
    a specified start node to a specified goal node mirrors the daily task of navigating
    through the world. When planning a route to work or the store, we might measure
    cost by the time taken, the distance traveled, or the aggravation incurred due
    to the number of bad intersections.
  prefs: []
  type: TYPE_NORMAL
- en: After explaining what constitutes a heuristic, this chapter introduces two canonical
    heuristic search algorithms. *Greedy best-first search* prioritizes nodes solely
    by their estimated cost to the goal, while *A* search* (pronounced “A-star”) combines
    the cost to reach an intermediary node with the estimated cost from that node
    to the goal. This combination makes A* search a much more powerful tool for efficiently
    finding good paths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing Appropriate Heuristics</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithms in this chapter rely on estimated costs to guide their searches.
    To add such heuristic information to an algorithm, we must pick a method of estimating
    costs from what we know about each node. While the difficulty of defining a good
    heuristic varies widely across problems, the approaches for many real-world scenarios
    are simple and intuitive. After introducing Euclidean distance as a common heuristic
    used in path planning, we discuss the constraints and challenges involved in choosing
    heuristics.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Euclidean Distance</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Euclidean distance* is a common, powerful, and intuitive heuristic used in
    many real-world path-planning problems that estimates the cost to a node at a
    given location by the straight-line distance to get there. For example, suppose
    we are navigating a cross-country road trip from Boston to Seattle. If the starting
    city is located at (*x*[1], *y*[1]) and the destination is at (*x*[2], *y*[2]),
    then the Euclidean distance between the two is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>=</mo> <msqrt><mrow><mfenced><mrow><msup><mrow><mfenced><mrow><msub><mi>x</mi>
    <mn>1</mn></msub> <mo>−</mo> <msub><mi>x</mi> <mn>2</mn></msub></mrow></mfenced></mrow>
    <mn>2</mn></msup> <mo>+</mo> <msup><mrow><mfenced><mrow><msub><mi>y</mi> <mn>1</mn></msub>
    <mo>−</mo> <msub><mi>y</mi> <mn>2</mn></msub></mrow></mfenced></mrow> <mn>2</mn></msup></mrow></mfenced></mrow></msqrt></mrow>
    ![dist, is equal to; the square root of open paren; open paren, x sub 1
  prefs: []
  type: TYPE_NORMAL
- en: minus x sub 2, close paren squared; plus, open paren, y sub 1 minus y sub
  prefs: []
  type: TYPE_NORMAL
- en: 2, close paren squared; close paren end root](../images/pg112.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can code this equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unless you are a bird flying directly to your destination, Euclidean distance
    provides, at best, a lower bound of the true cost. Roads don’t exist between every
    pair of cities on the map. Even highways that stretch directly from one point
    to another are unlikely to follow a straight line, since they must curve around
    geographic features like mountains and lakes, lengthening your journey.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its optimistic nature, Euclidean distance can provide vital heuristic
    information. For example, these estimates can help us choose appropriate waypoints
    as we plan a road trip. On a trip from Boston to Seattle, Cleveland would obviously
    make a better rest stop than Miami, because Miami is farther from both Seattle
    and Cleveland than our starting point.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-1(a)](#fig8-1) shows an example graph on a two-dimensional plane.
    [Figure 8-1(b)](#fig8-1) shows the corresponding edge weights, which largely correspond
    to the straight-line distance between nodes. However, the cost between two nodes
    can also be *greater* than the Euclidean distance. The edge between nodes 2 and
    4 has a weight of 3.5, which could indicate additional cost, such as traversing
    a steep hill or using a dirt road. The cost of traversing between nodes (the edge
    weight) must simply be greater than or equal to the estimated distance.'
  prefs: []
  type: TYPE_NORMAL
- en: '![In (A), a seven-node graph is shown on a 5 × 5 grid. Node 0 is at x=0, y=0
    and node 1 is at x=0, y=2\. In (B), each edge is labeled with the cost between
    the two nodes. The edge (0, 1) has a weight 2.0\. In (C), each node is labeled
    with the estimated distance to the goal.](../images/f08001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: The weights and
    Euclidean distances between nodes on a 2D plane</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Given this arrangement, we can provide lower-bound estimates of the potential
    cost from each node to the goal by taking the Euclidean distance from that node
    to the goal, as shown in [Figure 8-1(c)](#fig8-1), for a goal node of 6\. The
    estimated cost from node 0 to node 6 is 5.0, reflecting their Euclidean distance.
    As noted previously, these estimates do not always capture the full cost. For
    example, the estimated distance from node 0 to node 6 is too optimistic, as the
    node lacks a direct path to node 6.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Admissible Heuristics</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define a heuristic to be *admissible* if the estimated cost from the start
    node to the goal is always less than or equal to the true cost, or, in other words,
    if the heuristic does not overestimate the true cost. Euclidean distance, for
    example, is a common, effective, and admissible heuristic for real-world path
    planning, since the straight-line distance to our goal provides an optimistic
    estimate of the cost to get there. The admissibility requirement is essential
    for the correct operation of some searches, such as A* search, and will be one
    of our major constraints when choosing a heuristic for a given purpose.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Heuristic Design
    Challenges</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While it’s relatively easy to define a heuristic for estimating distances, let’s
    consider a more difficult case. Imagine you want to solicit an introduction to
    a new contact through your professional network. Each person (node) can reach
    out only to their present or past coworkers to pass along the request. To facilitate
    your introduction, you must find a sequence of weighted edges that indirectly
    connect you to the person you ultimately want to meet, where each edge weight
    represents the cost of passing along the request. The cost of passing the request
    to a friend with whom you converse daily would be low, while the cost of connecting
    with an annoying former coworker with whom you never want to speak again would
    be very high.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it’s difficult to capture all these factors with a single admissible
    heuristic. You might be able to glean some estimate of distance to the goal from
    each person’s job history. The estimated cost of communication through a person
    in a different industry from the goal node should generally be higher; for example,
    professional interactions between a professional baseball player and a computer
    scientist are rarer than those between two baseball players. Similarly, the estimated
    cost would be lower if the two individuals worked at the same company. However,
    piecing together positive and negative indicators like this makes it difficult
    to form a good quantitative estimate, as the indicators are too noisy. The fact
    that two people once worked together does not help you if they have never met
    or are nemeses.
  prefs: []
  type: TYPE_NORMAL
- en: Worse, it is much more difficult to ensure your heuristics for such problems
    are admissible. If you place a high cost on different industries, you will occasionally
    overestimate the cost of passing your message between them—perhaps you know a
    programmer who still talks regularly to the movie star who was their childhood
    best friend. Similarly, this metric would not capture the family members who work
    for different companies but communicate often.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing a good heuristic involves maximizing information while maintaining
    admissibility and minimizing computation cost. It is trivial to design an admissible
    heuristic by assigning each node a cost of negative infinity, but this strategy
    is obviously useless in guiding a search. Similarly, we can design a perfectly
    informative and admissible heuristic by using the algorithms in the previous chapter:
    we just solve the all-pairs shortest-path problem and compute the heuristic from
    the true lowest-cost path between each node and the goal. Yet this does not help
    either, as the computational cost of the search is too high. The point of a heuristic
    is to reduce the computational cost of the search itself. As we consider new problems
    and heuristics, it is always important to examine the trade-offs between information,
    computational cost, and admissibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sections introduce two canonical heuristic searches, starting
    with the simplest approach: greedy best-first search.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Greedy Best-First Search</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *greedy best-first search* always chooses the option that looks best at a
    given point in the search, exploring the next unvisited node with the lowest estimated
    cost based on the best heuristic value. The algorithm maintains a minimum priority
    queue of nodes to test. As it progresses toward the goal, at each step it chooses
    the lowest-cost node from the priority queue and explores that node next. Each
    time the algorithm sees new neighbors, it adds them to the queue with a priority
    equal to their heuristic value. The algorithm proceeds node by node until it finds
    a path to the goal.
  prefs: []
  type: TYPE_NORMAL
- en: We can view greedy best-first search as a modification of breadth-first search.
    Whereas the latter search prioritizes nodes by the order in which they were seen,
    using a queue to visit the earliest-seen node, best-first search orders the nodes
    with a heuristic.
  prefs: []
  type: TYPE_NORMAL
- en: Greedy best-first search takes the approach we might expect of an eager but
    clever squirrel navigating a maze, as shown in [Figure 8-2](#fig8-2). The squirrel
    (S) can smell the delicious pile of acorns that is his goal destination (G). Using
    its nose, the squirrel can deduce the straight-line path he could take directly
    to the nuts, if there were no walls ([Figure 8-2(a)](#fig8-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a maze on a 5 × 5 grid with the cell in the middle of the top row
    labeled S and the cell in the bottom right labeled G. A gray arrow points directly
    from S to G. (B) shows the same maze with the cell to the left of S labeled with
    a minus, and the cells below it and to its right labeled with pluses.](../images/f08002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: A maze with a heuristic
    estimate of the goal’s direction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At any given location (node), the squirrel can also determine adjacent locations
    to which it can move and estimate which one will take it closer to the destination.
    The squirrel uses a smell-based heuristic—nodes with a stronger smell of acorns
    are closer to the goal. [Figure 8-2(b)](#fig8-2) shows that two of the neighboring
    squares will move the squirrel closer to the acorns (+), while one will move it
    farther away (–). The squirrel always chooses the path with the strongest smell,
    following the scent toward the food, sometimes backtracking to points where the
    smell was stronger than the current location. Along the way, it mentally notes
    alternative paths and adds them to the list of options to try.
  prefs: []
  type: TYPE_NORMAL
- en: Although greedy best-first search might quickly find a path to the goal if it
    is working with a good heuristic, the final path is not guaranteed to be optimal.
    We might take a path that looks good due to an optimistic estimate at an early
    node and skip a better path with a more realistic estimate. The squirrel might
    take a longer path that temporarily curves away from the food simply because the
    smell was stronger in that direction. We will see an example of this scenario
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To implement the greedy search algorithm, we need to provide an additional
    piece of information beyond what we included in earlier searches: the nodes’ heuristic
    values. There are multiple approaches to providing this information. For clarity
    of illustration, we’ll start by passing a precomputed list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>
    that maps the nodes’ indices to their heuristic values, and we’ll introduce an
    alternative method later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for greedy best-first search is similar to that of breadth-first search.
    Instead of using a queue to store the nodes in the order they were seen, we use
    a custom *min-heap-based priority queue* (described in [Appendix B](appendix_B.xhtml))
    to retrieve nodes in order of decreasing estimated cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code starts by setting up the internal data structures, including a list
    indicating whether we have visited each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>),
    a list mapping each node to the one that preceded it on the search path (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), and a minimum priority queue
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>). It then inserts the
    starting node into the priority queue, with its heuristic cost as the priority
    ❶. In the squirrel maze analogy, this marks the point right before the squirrel’s
    search begins. Standing ready outside the maze, it smells the acorns and has one
    available option on its mental priority queue: the starting node.'
  prefs: []
  type: TYPE_NORMAL
- en: The exploration of greedy best-first search takes place in a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that continues exploring until the code has either exhausted the priority
    queue or visited the goal node ❷. At each iteration, the code retrieves the next
    node on the priority queue—the one with the best heuristic value—and visits that
    node. You can picture this as the squirrel running to the location of the next
    best option.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to iterate over each of the current node’s neighbors. If a neighbor has not been
    visited and is not in the priority queue, then it has not been seen before ❸.
    The code therefore adds it to the priority queue (with the estimated distance
    as the priority) and marks the current node as the step before it in the path.
  prefs: []
  type: TYPE_NORMAL
- en: When the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop completes,
    the greedy search will have either found a path to the goal node or discovered
    that no such path exists. In the former case, unlike other algorithms we have
    seen previously, there may still be unexplored nodes on the priority queue. In
    the latter case, the priority queue will be empty; there are no more nodes to
    explore. The goal node’s entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, reflecting the
    lack of any path back to the starting node. The code concludes by returning the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 8-3](#fig8-3) shows an example greedy best-first search on the graph
    from [Figure 8-1](#fig8-1). In each subfigure, the current node being explored
    is enclosed in a dashed circle, while nodes that have been visited are shaded.
    The edge weights are shown alongside each edge.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the seven-node graph from Figure 8-1 along with the
    sorted priority queue and the last array. (B) shows node 0 shaded and circled.
    The last array reads [–1, 0, 0, 0, –1, –1, –1] and the priority queue has nodes
    2, 1, and 3 with priorities 2.24, 3.60, and 4.0, respectively.](../images/f08003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The steps of a
    greedy best-first search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid cluttering the illustrations, the heuristic values for each node are
    not shown directly in [Figure 8-3](#fig8-3). However, these heuristic values are
    the same Euclidean distances as shown in [Figure 8-1(c)](#fig8-1). We provide
    them to the algorithm as a list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each subfigure also shows the current priority queue (in sorted order for illustration)
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list. Although
    the code maintains the priority queue in heap ordering, we show the priority queue
    in sorted order to make the relative orderings clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search begins by putting the start node into the priority queue with its
    corresponding cost estimate 5.0, as shown in [Figure 8-3(a)](#fig8-3). During
    the first iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop, it dequeues node 0 from the priority queue, visits it, and adds each previously
    unseen neighbor to the priority queue, as shown in [Figure 8-3(b)](#fig8-3). The
    priorities for the nodes are equal to their heuristic costs (that is, the Euclidean
    distances to the goal node) as given in [Figure 8-1(c)](#fig8-1): node 1 = 3.6,
    node 2 = 2.24, and node 3 = 4.0\. The search sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    values to 0 for each of these neighbors to indicate that the path toward them
    comes from node 0.'
  prefs: []
  type: TYPE_NORMAL
- en: At each step in the search, the algorithm chooses the node that looks most promising
    as it progresses toward the goal. Checking the priority queue, it moves on to
    node 2\. As shown in [Figure 8-3(c)](#fig8-3), it then adds node 2’s unvisited
    neighbors to the priority queue. With priority 2.24, node 4 now sits at the top
    of the queue. The search progresses through node 4 in [Figure 8-3(d)](#fig8-3)
    to the goal node in [Figure 8-3(e)](#fig8-3).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this example, greedy best-first search does not produce
    an optimal path to the goal. The search is lured to node 2 with the promise of
    its proximity to the goal node, but is forced to detour through node 4 and over
    a costly 3.5 weighted edge. Greedy best-first search cannot tell that it would
    have been better to progress through node 1, because it doesn’t consider the cost
    of the paths to get to a node. It looks only at the estimated cost from a given
    node to the goal and uses that for prioritization. By the time the search has
    finished visiting node 2, it has already seen that node 4 has a better heuristic
    value than node 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can picture this suboptimality in the context of a frustrating bicycle trip.
    Suppose that after a morning of cycling with no destination in mind and without
    paying attention to the path, you and your friend are exhausted and want to find
    your way home. You stop at a fork in the road and consider the options. You know
    the left path ends at an intersection adjacent to your house but traverses a small
    mountain to get there. The right path is flat but terminates at an intersection
    a few blocks away from your house. Both paths get you closer to home, but with
    radically different costs (edge weights). Unfortunately, a greedy algorithm doesn’t
    take that into consideration. Before you can open your mouth, your overeager friend
    lets out a cheer and pedals up the left path. When you try to protest, they just
    call out, “Who cares about a little hill? This path gets us closer.”  ### <samp
    class="SANS_Futura_Std_Bold_B_11">A* Search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A* search combines the heuristic estimates of greedy best-first search with
    a more comprehensive accounting for the observed edge costs, providing an efficient
    mechanism for finding the shortest path between two nodes. Whereas greedy best-first
    search completely ignores the edge cost, A* balances the promise of the heuristic
    estimates with the cold, hard facts about the best paths we have seen to each
    node. This combination results in an accurate and computationally efficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key intuition behind the A* algorithm is that we want to rank potential
    nodes in our path by their estimated <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>
    cost. It is not sufficient to focus on the cost from the current node to the goal;
    we also must ask how expensive it was to get to that node in the first place.
    To answer this question, A* tracks an additional piece of information: the cost
    of the best path found so far to each node. As shown in [Figure 8-4](#fig8-4),
    the priority used for unvisited nodes is then just the sum of the cost of the
    best path to the node so far plus the estimated cost of traveling from that node
    to the goal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three nodes, S, C, and G. The path between S and C is labeled “Best cost
    S to C” and the path between C and G is labeled “Estimate C to G.”](../images/f08004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: The combination
    of true cost to a node and estimated cost to the goal</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to the eager squirrel’s demonstration of greedy best-first search,
    we can visualize A* search as a more meticulous explorer with an advanced degree
    in cartography searching for a path to a proposed archeological dig site. In addition
    to the standard compass, canteen, and obligatory exploring hat, our protagonist
    carries a clipboard to track information about the area. They represent each node
    as a row with three columns of information: the best cost to the node (titled
    Best Cost), the best path to the node (Best Path), and the estimated total cost
    to the goal through that node (Heuristic). Throughout their journey, the explorer
    continually updates these three columns of information.'
  prefs: []
  type: TYPE_NORMAL
- en: The explorer travels from village to village (node to node). GPS coordinates
    provide an estimate of the shortest possible distance. Signposts, trail markers,
    and in-person interviews reveal the actual distance to neighboring nodes. Each
    time the explorer discovers a new node, they compute its estimated cost to the
    goal and write that down in the Heuristic column.
  prefs: []
  type: TYPE_NORMAL
- en: As their journey continues, the explorer always moves to the next location (node)
    with the lowest estimated total cost. Each time they consider a neighboring location,
    whether new or previously seen, they ask themselves whether they’ve found a better
    path to that node than they had previously discovered. If so, they document this
    discovery in the Best Cost and Best Path columns. Perhaps earlier in their journey
    they discovered a 10-mile trail through a dense, spider-infested jungle to reach
    the archeology site. Their notes detail this path and its tremendous cost. However,
    they later discover a new, three-mile-long paved highway to the same site via
    a small village to the east. They eagerly erase their old values and update both
    the Best Cost and the Best Path columns to reflect this new find.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for A* search in [Listing 8-1](#list8-1) orders the potential nodes
    by the estimated total cost through that node and onto the goal. Again, it uses
    a precomputed list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> of heuristic
    values for each node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: The code for A*
    search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by setting up the internal data structures, including a list
    indicating whether it has visited each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>),
    a list mapping each node to the one that preceded it on the search path (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), a list storing the cost
    of the best path found from the starting node to each subsequent node (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>),
    and a minimum priority queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>).
    It inserts the starting node into the priority queue, with its estimated cost
    as the priority, and sets the cost of the starting node to 0 to reflect the fact
    that the search is already at that node ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The search is now ready to begin. A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop continues exploring nodes until the code has either exhausted the priority
    queue or visited the goal node ❷. At each iteration, the code retrieves the next
    node on the priority queue—the node with the lowest estimated total cost to the
    goal—and visits it next.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate over each of the current node’s neighbors. It checks whether the
    current node provides a better path to the neighbor, computing the full cost by
    combining the best cost to the current node with the edge weight to the neighbor
    ❸. If the code finds a better path to a node, it updates both the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> lists. It then updates
    the neighboring node’s estimated total cost using the new cost to <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>
    plus the estimated cost from <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>
    to the goal ❹. If the neighbor is in the priority queue already, the code updates
    its priority with the <samp class="SANS_TheSansMonoCd_W5Regular_11">update_priority()</samp>
    function to take the new estimated total cost into account. Otherwise, it adds
    the node to the priority queue.
  prefs: []
  type: TYPE_NORMAL
- en: As in greedy best-first search, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop in A* search completes when it has either found a path to the goal node or
    concluded that no such path exists—that is, if the search exhausts the priority
    queue before visiting the goal node. The code finishes by returning the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 8-5](#fig8-5) shows an example A* search. As in our example for greedy
    best-first search, we show the edge weights and again use the heuristics from
    [Figure 8-1(c)](#fig8-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each subfigure also shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> array, and priority
    queue. The current node being explored is marked with a dashed circle and the
    visited nodes are shaded. Again, the priority queue is shown in sorted order for
    clarity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-5(a)](#fig8-5) shows the initial state of the search before it visits
    the first node. The priority queue initially contains only the start node. Since
    the distance from the start node to itself is 0.0, the estimated total cost of
    the starting node is just the estimated distance to the goal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>
    array reflects the known costs to get to each node: 0.0 for the starting node
    and infinite for everything else, because the search has not observed a path to
    those nodes yet.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-5(a)](#fig8-5) represents our hypothetical explorer’s state before
    the start of an expedition. They have been hired to find the shortest path from
    a city (node 0) to a proposed archeological dig site (node 6). Before they land
    at the starting city, they have only a rough (and optimistic) estimate of the
    distance to the dig site given the geographical coordinates of its location. The
    explorer checks their lists, dons their helmet, and says, “I know the dig site
    is at least five miles from the city. It’s time to get started.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the seven-node graph from Figure 8-1 along with the
    sorted priority queue, the last array, and the cost array.](../images/f08005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: The steps of the
    A* algorithm on an example graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 8-5(b)](#fig8-5), the search dequeues the top node from the priority
    queue and explores it. This is equivalent to our intrepid explorer arriving at
    the starting city and looking around. The search finds three neighbor nodes and
    computes their expected total cost as the sum of the distance to the current node,
    the edge weight to the neighbor, and the estimated cost from the neighbor to the
    goal, resulting in the following total estimated costs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Node 1: 0.0 + 2.0 + 3.6 = 5.6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Node 2: 0.0 + 2.83 + 2.24 = 5.07'
  prefs: []
  type: TYPE_NORMAL
- en: 'Node 3: 0.0 + 3.0 + 4.0 = 7.0'
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to the explorer updating their lists after finding three roads
    out of the initial city. From a helpful signpost, they know the distance to the
    villages and their locations. Each road presents a potential path with a different
    estimated cost.
  prefs: []
  type: TYPE_NORMAL
- en: Since the estimated total cost of node 2 looks the best, the search explores
    it next, as shown in [Figure 8-5(c)](#fig8-5). From there, it considers two neighbors,
    nodes 3 and 4\. Node 3 already has a lower cost from the starting node (3.0 versus
    2.83 + 2.24 = 5.07), so the search does not update its path or priority. The search
    has not seen node 4 before, so it provides an initial cost value of 2.83 + 3.5
    = 6.33 and a total cost estimate of 2.83 + 3.5 + 2.24 = 8.57\. This cost reflects
    the impact of both the path to node 2 and the extreme cost of traversing from
    node 2 to node 4.
  prefs: []
  type: TYPE_NORMAL
- en: Through the eyes of the explorer, these decisions look similar. They see a signpost
    indicating two new villages. Village 3 is an additional 2.24 miles away. Compared
    to the direct path from city 0 to village 3, the detour through village 2 to village
    3 is much longer. They immediately realize there is no need to add an unnecessary
    stop and therefore refrain from updating the row for village 3\. In contrast,
    while the path to village 4 from village 2 is exceptionally difficult, it offers
    the prospect of getting closer to their goal, so they update the row for village
    4.
  prefs: []
  type: TYPE_NORMAL
- en: The search continues by taking the unvisited node with the best estimated total
    cost. Unlike greedy search, it does not jump to the node estimated to be closest
    to the goal, in this case node 4\. Though this node has the best estimated cost
    to the goal (2.24), the cost of getting there using the current path is high (6.3
    through node 2). Instead, the search explores node 1, as shown in [Figure 8-5(d)](#fig8-5),
    and finds a better path to node 4, updating the estimated total cost to 2.0 +
    1.41 + 2.24 = 5.65\. It also updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array to indicate that the path to node 4 goes through node 1 instead of node
    2.
  prefs: []
  type: TYPE_NORMAL
- en: This step mirrors the explorer thinking about the total cost of the route. The
    archologists who hired the explorer want a low-cost route to reach the site repeatedly.
    Knowing this, the explorer tries village 1 before crossing the mountain from village
    2 to village 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search continues to node 4 in [Figure 8-5(e)](#fig8-5), then node 6 in
    [Figure 8-5(f)](#fig8-5). At each stop, it considers the unvisited neighbors and
    checks whether it has found a better path. It stops after reaching node 6 because
    it knows it has found the best path to the goal, even without having visited nodes
    3 and 5.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Why
    A* Finds the Optimal Path</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The skeptical reader might wonder how we can be sure A* search has found the
    best path, since it explores only a portion of the graph without visiting every
    node. However, as long as its heuristic is admissible, A* will always find the
    optimal path. To see why, let’s examine the state after A* search has reached
    the goal node through some path and consider an alternate path to the goal node
    through an unvisited node *v*. Because of our admissible heuristic and priority
    queue ordering, any path through node *v* must be longer than the one we have
    already found.
  prefs: []
  type: TYPE_NORMAL
- en: Since the search did not visit node *v* before the goal node, node *v*’s priority
    value (estimated total cost) must have been greater than the priority value of
    the goal node. At the point that the search visited the goal node, the goal node’s
    priority value equals the actual cost of the path found. The estimated cost to
    the goal is always 0 for the goal itself, so the goal’s priority value equals
    the cost to the node preceding it plus the corresponding edge weight. We are no
    longer relying on heuristics. We have an actual path cost.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the priority value of the unvisited node *v* is a lower bound of
    the true distance due to use of an admissible heuristic. It can never be less
    than the true distance. Our heuristic is optimistic. Any path to the goal through
    node *v* must cost at least as much as node *v*’s priority value, which was greater
    than that of the goal node. Thus, the cost of a path to the goal through node
    *v* must be higher than the one already found.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Applying A* to Puzzles</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As long as we can generate a useful and admissible heuristic, we can apply heuristic-based
    searches to efficiently find solutions for the puzzle graphs from [Chapter 6](chapter6.xhtml),
    such as the prisoners-and-guards puzzle. As a reminder, [Figure 8-6](#fig8-6)
    shows the state graph for that puzzle (originally introduced in [Figure 6-8](chapter6.xhtml#fig6-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A 16-node graph. Each node is labeled with a number and a three-element list
    describing the puzzle state.](../images/f08006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: The state graph
    for the prisoners-and-guards river-crossing puzzle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use two basic facts about the physical properties of the boat to derive
    an admissible metric indicating the distance to the goal state:'
  prefs: []
  type: TYPE_NORMAL
- en: The boat can carry at most two people. If there are *k* people on the left shore,
    we need to least *ceil*(*k* / 2) trips to get them all onto the right shore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the boat is on the right shore, it must return to the left shore before picking
    up more people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using those conditions, we can define a function to generate the heuristic
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PGState</samp> stored in
    each node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code loops over the graph’s nodes with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, checking the puzzle state of each node to determine the number of people
    on the left shore ❶. It then computes the minimum number of trips the boat needs
    to make from left to right by considering how many people still need to be moved
    over and noting that at most two people can come over each time ❷. It also computes
    the minimum number of trips the boat needs to make from right to left by noting
    that, while there are more passengers to transport, the boat needs to return to
    the left shore to pick them up ❸. The heuristic is the sum of these two sets of
    trips.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#tab8-1) compares the values of this heuristic function for each
    state with the true distance to the goal node, which we calculate by counting
    the steps from each state to the goal in [Figure 8-6](#fig8-6). As you can see,
    the heuristic is admissible and never overestimates the true distance.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Values
    from the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">pg_generate_heuristic()</samp>
    <samp class="SANS_Futura_Std_Book_11">Function vs. the True Distance to the Goal
    Node</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">State</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">R</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">3</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">2</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">3</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">R</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">1</samp><samp class="SANS_Futura_Std_Heavy_B_11">L</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">2</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">L</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">R</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">0</samp><samp class="SANS_Futura_Std_Heavy_B_11">1</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">L</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Heuristic distance</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">True distance</samp> | <samp class="SANS_Futura_Std_Book_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_Futura_Std_Book_11">9</samp>
    | <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Given this heuristic function, we can run A* search on the river- crossing
    puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The prisoners-and-guards problem provides a demonstrative example of applying
    A* search to puzzles because we can enumerate the states and compare the heuristic
    values to the true best path. However, the structure of the graph, with a single
    long sequence of states without branches, means that A* search does not significantly
    outperform breadth-first search on this puzzle. In contrast, A* search could provide
    significant advantages on puzzles with much larger state spaces, since the power
    of A* search is its ability to focus on exploring only promising paths toward
    the goal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Searching Unknown Graphs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the algorithms introduced in this chapter so far have treated both the
    graph and heuristic values as known items passed to the search, these approaches
    work equally well on problems for which the algorithm needs to dynamically construct
    an unknown graph. Consider the puzzle-building examples from [Chapter 6](chapter6.xhtml).
    There, we used breadth-first search to quite literally explore the state space,
    building up a graph as we encountered new nodes and edges. We can do the same
    thing with heuristically guided searches.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of passing a list of heuristic values to each node, we could pass a
    function that dynamically evaluates the heuristic based on the information in
    the node. For example, if a node has auxiliary data *x* and *y*, indicating its
    spatial position, we could define the heuristic function to be the Euclidean distance
    from that node to the known goal position. In the case of a real-world explorer,
    this might correlate to their using a GPS to estimate the distance to the objective
    as they trek through the jungle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize this dynamic construction and evaluation using the “clouded
    out” mechanism from video games. For example, [Figure 8-7](#fig8-7) shows a grid
    as a 5×5 maze. Explored areas like the long dead end at the bottom of the graph
    are shown as boxes, while unexplored areas are grayed out. Anything could be in
    the gray zone: a direct path to the goal, numerous dead ends, or a giant monster.
    We won’t know until we explore it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The figure shows a grid as a 5 × 5 maze. Eleven of the cells are shown and
    the rest are grayed out.](../images/f08007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-7: A maze with the
    unseen areas grayed out</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we modify the code from [Listing 8-1](#list8-1) to conduct
    dynamic exploration by constructing the graph as new nodes are discovered. The
    auxiliary data structures such as <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    and distance must also be dynamically extended to account for new states.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For our example code, we generalize the algorithm by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class. This class provides basic information about the puzzle, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The starting state’s index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A given state’s neighbors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of a transition between any two neighboring states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heuristic value at a state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the current state is the goal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given this interface, we do not need to know anything about the state space
    ahead of time. Just like a real-life explorer consulting GPS and road signs, we
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> interface throughout
    the algorithm to examine the local state of the world.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class
    does not need to enumerate the state space. It also does not need to construct
    and store the full graph. We can use functions like the ones in [Chapter 6](chapter6.xhtml)
    to dynamically determine a state’s neighbors given information about the state.
    This dynamic evaluation allows us to explore massive state spaces without a huge
    memory overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class for the distance-based example search in this chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class stores
    the underlying graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>),
    the starting index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start_ind</samp>),
    and the goal index (<samp class="SANS_TheSansMonoCd_W5Regular_11">goal_ind</samp>).
    In this example, they are all provided by the user. The class then uses basic
    getter functions to provide the information needed. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp>
    returns the index of the starting state, while <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    lists the neighboring states. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp>
    function uses the actual edge cost between two nodes, or infinity if there is
    no such edge.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function
    assumes that the node’s coordinates are stored in its label as an (*x*, *y*) tuple
    or list ❶ and uses the Euclidean distance to the goal as the heuristic ❷ (which
    requires the code to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    math</samp>). When creating the graph, we will also need to set the labels of
    the nodes to contain these coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class,
    we create a modified version of A* search that dynamically allocates and fills
    the data structures. For simplicity’s sake, we use dictionaries to map each state’s
    index (or string) directly to the corresponding information, as shown in [Listing
    8-2](#list8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: An A* search for
    an unknown graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 8-2](#list8-2) defines a modified version of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">astar_search()</samp> function defined
    in [Listing 8-1](#list8-1), <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_dynamic()</samp>.
    This function creates empty helper data structures and inserts the starting state
    into each one ❶. The use of dictionaries means we do not need to know anything
    about the number of total states or their underlying indices. At this point, the
    data structure has information only about that single state because the code has
    not explored any others. It gets the index of the starting state from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp> function and
    its estimated cost (priority) via the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The [Listing 8-2](#list8-2) algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop to explore states on the priority queue until it has either run out of states
    to explore or found the goal. During each iteration, the algorithm dequeues the
    most promising state (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>),
    marks it visited, and checks whether it is the goal by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp>
    function. In the real world, this might consist of entering a new city and looking
    around for familiar landmarks.
  prefs: []
  type: TYPE_NORMAL
- en: For each state it explores, the code checks all its neighbors using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function to return
    the state’s local neighborhood ❷. The code then computes the cost from the current
    node to that neighbor (<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>),
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp> function
    to return the edge weight. Similarly, it dynamically computes the heuristic value
    of that neighbor (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>) using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function.
  prefs: []
  type: TYPE_NORMAL
- en: Once it has the distance to the neighbor and that neighbor’s heuristic value,
    the code checks whether it has encountered the neighboring state before. It checks
    whether the state has been seen by testing whether it has an entry with any value
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp> dictionary
    ❸. If the neighboring state is not in the dictionary, it has never been seen and
    is added to each data structure. The neighboring state’s cost is the sum of the
    cost to get to the current state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>)
    plus the cost of the next state transition (<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>).
    The neighboring state’s priority is this best cost to that state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>)
    plus the heuristic estimate at that state (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: If the neighbor has been seen before ❹, the code checks whether the new path
    is better by comparing the neighbor’s cost (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>)
    with the cost through the new path (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>).
    If the code finds a better path, it updates the path to the state (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    the cost to reach the state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>),
    and the state’s priority. Again, the code updates the priority in the queue directly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_dynamic()</samp>
    function to the graph from [Figure 8-1](#fig8-1). Of course, the algorithm does
    not know the graph ahead of time. It does not even know how many nodes the graph
    has. All the code sees is what the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend our graph from the greedy and A* examples shown in [Figures 8-3](#fig8-3)
    and [8-5](#fig8-5) by adding the node’s spatial position in its label, as in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, while this manual assignment approach works for the purpose of setting
    up this demonstrative example, it leads to a long problem and tedious setup for
    a large number of points. We discuss programmatic approaches to reading in graph
    data in [Appendix A](appendix_A.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-8](#fig8-8) shows the search. In [Figure 8-8(a)](#fig8-8), the algorithm
    knows the starting state with index 0 and the existence of a goal state. However,
    it knows nothing about the rest of the graph, including the edges out of node
    0\. The goal node doesn’t even have a number yet because the search has not seen
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: When the search visits node 0 in [Figure 8-8(b)](#fig8-8), it discovers three
    edges to three neighbors. Each of these edges has a weight provided by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp>
    function and a heuristic value provided by the class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp>
    function. While this is not much information, it is enough for us to build up
    a picture of the neighborhood around the starting state. The search augments its
    auxiliary data structures (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>) to account for this
    by adding new entries for the corresponding nodes. It does not explicitly create
    a graph or store the edges.
  prefs: []
  type: TYPE_NORMAL
- en: This search follows the same sequence as the A* search example in [Figure 8-5](#fig8-5).
    The main difference in [Figure 8-8](#fig8-8) lies in what the search knows about
    the graph at each step. It is only guaranteed to have seen all the node’s edges
    once it visits that node. For example, while the algorithm knows about both nodes
    1 and 4 for several iterations, it does not learn about the edge between them
    until [Figure 8-8(d)](#fig8-8), when it has visited node 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows a partial graph, along with the sorted priority queue,
    the last array, and the cost array. (B) shows five nodes, where node 0 is shaded
    and circled, attached by edges to nodes 1, 2, and 3, and node G is not attached
    to any edges.](../images/f08008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-8: The steps of an
    A* search algorithm on an unknown graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous A* search example, the code continues until it visits the
    goal node. At this point the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp> function
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, and we know
    that we have found the shortest path. However, as shown by [Figure 8-8(f)](#fig8-8),
    this does not mean the search has explored the entire graph. Not only did it skip
    visiting nodes 3 and 5, but it also never learned about the edge between them.
    There could be an entire world branching out beyond those nodes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Greedy best-first search and A* search provide mechanisms for incorporating
    heuristic estimates into our search algorithms, helping us find the best paths
    between two nodes. Greedy best-first search is simple and needs to track very
    little information but may produce nonoptimal paths. The combination of an admissible
    (optimistic) heuristic and good bookkeeping on the cost so far allows A* search
    to efficiently choose which nodes to explore while guaranteeing it finds the lowest-cost
    path.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of these algorithms, particularly A*, is that the use of
    heuristic information focuses the search. Just as GPS coordinates can help us
    determine which of two possible roads will bring us to our destination more quickly,
    heuristics allow us to prioritize which nodes to explore next. As a result, A*
    search is a practical algorithm that has become a staple of artificial intelligence
    and video game path planning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the book, we step away from search algorithms and examine
    tasks related to the connectivity of graphs. We review how to sort nodes in a
    directed graph, consider how to test the connectivity of graphs, and examine random
    behavior on graphs. Many of these algorithms use searches as a core component.
  prefs: []
  type: TYPE_NORMAL
