- en: '**E  More Fault Injections**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**E  更多故障注入**'
- en: '**E.1 Java Card Invalid Bytecode**'
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.1 Java Card无效字节码**'
- en: Java Card is a reduced version of Java intended to run on micro-controllers
    and smart cards. It’s one of those crazy contraptions that could only have been
    invented in the Nineties, allowing Java development of firmware applets. Here,
    we’ll discuss a type confusion problem described in Mostowski and Poll (2008)
    and elsewhere, as well as a way to glitch past protections in that scheme from
    Barbu, Thiebeauld, and Guerin (2010).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java Card是一个简化版的Java，旨在运行于微控制器和智能卡上。它是那种只能在九十年代发明的疯狂设备，允许Java开发固件小程序。在这里，我们将讨论Mostowski和Poll（2008）以及其他地方描述的类型混淆问题，以及Barbu、Thiebeauld和Guerin（2010）在此方案中绕过保护的一种方法。
- en: Many trade-offs are required to make this work. Within a Java Card applet, you’ll
    find far more use of primitive types than in regular Java software. The available
    libraries are limited, and you absolutely must do your cryptography by calling
    hardware acceleration libraries rather than implementing your own purely in software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个操作需要做很多权衡。在Java Card小程序中，你会发现使用原始数据类型的情况比普通Java软件更多。可用的库有限，你必须通过调用硬件加速库来进行加密，而不是完全通过软件实现自己的加密功能。
- en: Java Card 3 was released in 2008 with mandatory on-chip byte-code validation
    (OCBV). Prior cards simply trust the developer’s workstation to produce and sign
    only valid bytecode. This means that anyone with signing authority can simply
    write illegal byte-code that casts one class to another, then uses the data fields
    of the misinterpreted class to dump all ROM.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java Card 3于2008年发布，增加了强制的片上字节码验证（OCBV）。之前的卡片仅仅信任开发者的工作站生成并签名有效的字节码。这意味着任何具有签名权限的人都可以编写非法字节码，将一个类转换成另一个类，然后利用错误解释的类的数据字段转储整个ROM。
- en: While you probably won’t have signing keys for a card whose keys you’d like
    to extract, it’s often possible to buy a “white card” from eBay that accepts development
    keys. On these cards, such an exploit can be used to dump the JVM ROM, a very
    useful artifact for attacking locked cards.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能没有签名密钥来提取你想要的卡片密钥，但通常可以从eBay购买一张“白卡”，它接受开发者密钥。在这些卡片上，可以利用这种漏洞来转储JVM ROM，这是攻击锁定卡片时非常有用的工具。
- en: '![Image](../images/f0320-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0320-01.jpg)'
- en: 'Figure E.1: Catching a Miscast Instruction'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.1：捕获误转指令
- en: We already mentioned that Java Card 3 closes this loophole, so let’s discuss
    a trick to perform the type confusion at runtime without offending the bytecode
    verifier. It was first described in Barbu, Thiebeauld, and Guerin (2010).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过Java Card 3修补了这个漏洞，所以接下来我们来讨论一个技巧，可以在运行时执行类型混淆，而不会触发字节码验证器的警告。这个方法最早在Barbu、Thiebeauld和Guerin（2010）中描述过。
- en: The idea is to use Java’s `try`/`catch` construct, in which the error from an
    illegal cast is caught without crashing the machine. Very many glitches can be
    applied, with the applet helping to cover up those that failed until a lucky one
    succeeds.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是使用Java的`try`/`catch`结构，其中非法转换的错误会被捕获，但不会使机器崩溃。可以应用许多漏洞，应用程序将帮助掩盖那些失败的漏洞，直到某个幸运的漏洞成功。
- en: Barbu presents the concrete example from [Figure E.1](app05.xhtml#chEfig1),
    in which the `SecurityException` is quietly caught and ignored, but if the cast
    does not trigger an exception, then the cast object is ready for reuse. This will
    spin forever without fault injection, because the exception will always occur,
    but a lucky fault will skip the exception and allow the cast. Once successfully
    cast, the mistyped object can be reused for hours without triggering another exception.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Barbu提供了[图E.1](app05.xhtml#chEfig1)中的具体示例，其中`SecurityException`被悄悄捕获并忽略，但如果转换没有触发异常，则该对象可以重新使用。这个过程会无限循环，除非出现故障注入，因为异常总是会发生，但幸运的故障会跳过异常并允许转换。一旦成功转换，错误类型的对象可以在不触发另一个异常的情况下使用几个小时。
- en: '**E.2 L11, M2351, LPC55 CrowRBAR**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.2 L11, M2351, LPC55 CrowRBAR**'
- en: Roth (2019) describes a glitching attack against both NuMicro’s M2351 chip and
    NXP’s LPC55S69\. This was quickly followed by Results (2020b), which describes
    some very practical effects of those glitches. Roth’s paper concerns voltage glitching
    attacks against the attribution units, which define the trust levels of regions
    of memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Roth（2019）描述了针对NuMicro的M2351芯片和NXP的LPC55S69的故障攻击。这很快被Results（2020b）跟进，后者描述了这些故障的实际影响。Roth的论文涉及针对归属单元的电压故障攻击，归属单元定义了内存区域的信任级别。
- en: He begins by describing ARM’s standardized security attribution unit (SAU).
    This is the peripheral that describes regions of memory as Secure, Non-Secure,
    or Non-Secure Callable. Some chips also support an implementation-defined attribution
    unit (IDAU), which might be custom rather than inherited from ARM’s standard designs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 他首先描述了 ARM 的标准化安全归属单元（SAU）。这是一个外设，用于将内存区域描述为安全、非安全或可调用非安全。某些芯片还支持一个实现定义的归属单元（IDAU），它可能是定制的，而不是继承自
    ARM 的标准设计。
- en: His first target is Microchip’s SAM L11, one of the first chip microcontrollers
    to ship with TrustZone-M. This chip does not contain an SAU, only an IDAU that
    is configured by the boot ROM from a row in flash memory.^([1](footnotes.xhtml#app5fn1))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 他的第一个目标是 Microchip 的 SAM L11，这是首批搭载 TrustZone-M 的微控制器之一。此芯片不包含 SAU，只有一个由启动 ROM
    配置的 IDAU，该配置来自闪存中的一行数据。^([1](footnotes.xhtml#app5fn1))
- en: The goal of the fault is to read secure-world data while running from the non-secure
    world. Glitching did not trigger the brown out detector (BOD) peripheral, which
    was a concern as that peripheral is supposed to reset the chip when the voltage
    drops too low.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 故障攻击的目标是读取安全世界中的数据，同时在非安全世界中运行。故障攻击没有触发欠压检测器（BOD）外设，这让他感到担忧，因为该外设应该在电压过低时重置芯片。
- en: As he did not yet have a dump of the boot ROM, he had to hypothesize a good
    target rather than disassembling to learn the right timing. He used a ChipWhisperer
    to reveal that the secure mode is first set at 2.18 ms after reset; this shows
    as a gross difference in the power consumption. A custom firmware image could
    then be written to immediately reveal the success or failure of a glitch around
    that time, narrowing the parameters before attacking black-box targets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为他还没有获得启动 ROM 的转储，他不得不假设一个合适的目标，而不是通过反汇编来学习正确的时机。他使用了 ChipWhisperer 来揭示安全模式在复位后
    2.18 毫秒时首次被设置；这一点表现为功耗的明显差异。然后可以写入一个自定义固件镜像，立即显示在那个时间点附近发生故障的成功与否，从而缩小攻击黑盒目标前的参数范围。
- en: '![Image](../images/f0322-01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0322-01.jpg)'
- en: 'Figure E.2: Nuvoton M2351'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.2：Nuvoton M2351
- en: The SAM L11 is available as a bare chip, but also provisioned with a key and
    Trustonic’s Kinibi-M, a commercial Trusted Execution Environment library. This
    variant is called the SAM L11 KPH, and the user is only allowed to write and debug
    the non-secure world. Roth purchased some from Digikey and glitched the chip until
    OpenOCD reported a successful read, after which he could read out Knibi for reverse
    engineering or even replace it for supply chain attacks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SAM L11 既可以作为裸片购买，也可以配备密钥和 Trustonic 的 Kinibi-M 商业可信执行环境库。这一变种被称为 SAM L11 KPH，用户只能写入和调试非安全世界的内容。Roth
    从 Digikey 购买了一些，并对芯片进行故障攻击，直到 OpenOCD 报告成功读取，之后他可以读取 Knibi 进行逆向工程，甚至替换它以进行供应链攻击。
- en: Roth’s second target was the Nuvoton M2351\. Unlike the SAM L11, this chip contains
    both an SAU and a fixed IDAU. Its marketing explicitly advertises defenses against
    voltage glitching.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Roth 的第二个目标是 Nuvoton M2351。与 SAM L11 不同，这款芯片包含了 SAU 和固定的 IDAU。其市场营销明确宣传防止电压故障攻击的防护。
- en: He first expected glitching this chip to be simple, as the more-secure opinion
    of the SAU or IDAU will override the other. Unfortunately for his attack, this
    chip uses a special instruction, `blxns` or `bxns`, to branch (and link) to the
    non-secure world from the secure world.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 他最初认为对这款芯片进行故障攻击会很简单，因为 SAU 或 IDAU 中更安全的设置将会覆盖另一个。不幸的是，针对他的攻击，这款芯片使用了一条特殊指令，`blxns`
    或 `bxns`，用于从安全世界跳转（并链接）到非安全世界。
- en: The last bit of the destination address is also checked by these instructions.
    Secure code pointers are odd, which in older chips would imply the Thumb instruction
    set. When the secure world wishes to call the non-secure world, it must first
    clear a bit of the pointer to be compatible with these instructions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目标地址的最后一位也会被这些指令检查。安全代码指针是奇数，在旧的芯片中，这意味着使用 Thumb 指令集。当安全世界希望调用非安全世界时，必须首先清除指针的一位，以使其与这些指令兼容。
- en: Therefore, a minimum attack might be to first glitch the instruction that sets
    `SAU->CTRL=1` and then glitch the bit clear that precedes `blxns` so the normal-world
    code runs in a secure-world context. This works, but it is very difficult to make
    stable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最小的攻击方式可能是首先故障攻击设置 `SAU->CTRL=1` 的指令，然后故障攻击在 `blxns` 之前清除位，以便使正常世界的代码在安全世界的上下文中运行。这是可行的，但要做到稳定非常困难。
- en: Roth’s better attack against this chip is called CrowRBAR. The idea here is
    that the IDAU maps each region twice, first as secure and again at a different
    location as non-secure. Bit 28 distinguishes the mirror, being set for the secure
    mapping and clear for the non-secure mapping. The SAU’s `RBAR` register then describes
    the start of the non-secure region, and if it were left as zero, the entire region
    would be non-secure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Roth针对该芯片的更好攻击叫做CrowRBAR。其思路是IDAU将每个区域映射两次，第一次映射为安全区域，第二次在不同的位置映射为非安全区域。位28区分镜像，安全映射时该位为1，非安全映射时该位为0。SAU的`RBAR`寄存器描述非安全区域的起始位置，如果该值为零，整个区域都将是非安全的。
- en: Glitching the write of the `RBAR` register takes about thirty seconds, exposing
    the entirety of the region to the non-secure world! Roth is unable to read the
    SAU registers back in this state to know exactly what the effect of the glitch
    was, but he is able to read the entirety of flash memory from code in the non-secure
    world.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 故障攻击`RBAR`寄存器的写入大约需要三十秒，暴露整个区域到非安全世界！Roth无法在这种状态下读取SAU寄存器，无法准确知道故障的具体影响，但他能够读取整个闪存中的代码，暴露给非安全世界。
- en: Roth also considered NXP’s LPC55S69, whose layout is quite similar to the M2351\.
    A complication of this target over the M2351 is the `MISC_CTRL_REG` register’s
    `ENABLE_SECURE_CHECKING` field, which checks that the attribution unit’s security
    state matches that of the memory protection checker (MPC). This can also be glitched,
    but only with multiple faults.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Roth还考虑了NXP的LPC55S69，其布局与M2351非常相似。与M2351相比，这个目标的复杂性在于`MISC_CTRL_REG`寄存器的`ENABLE_SECURE_CHECKING`字段，该字段检查归属单元的安全状态是否与内存保护检查器（MPC）的状态匹配。这也可以通过故障攻击来绕过，但需要多个故障。
- en: While Roth’s interest was largely in privilege escalation to the secure world
    in these chips, Results (2020b) describes three attacks against cryptography functions
    in the M2351’s ROM library (MKROM). These attacks depend upon the fact that non-secure
    code can expose timing on a GPIO pin just before a call into the ROM, so the glitcher
    has very predictable timing and very little drift.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Roth主要关注的是提升这些芯片中到安全世界的特权升级，Results（2020b）描述了针对M2351的ROM库（MKROM）中密码学函数的三种攻击。这些攻击依赖于这样一个事实，即非安全代码可以在调用ROM之前暴露一个GPIO引脚的时序，因此故障攻击者能非常准确地预测时序，且漂移非常小。
- en: The first glitches the AES key to zero by skipping `XAES_SetKey()`, advancing
    the timing by 2.5 µs. The second glitches the output from `XAES_SetDMATransfer()`
    down to zeroes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个攻击通过跳过`XAES_SetKey()`将AES密钥设置为零，将时序提前2.5微秒。第二个攻击通过将`XAES_SetDMATransfer()`的输出值设为零来制造故障。
- en: You will often hear that AES128 or some other algorithm is vulnerable to cryptanalysis
    when rounds have been skipped, and when I was younger, I wondered where the hell
    that might be useful. The third attack from Limited Results glitches to skip the
    last AES round. Feeding two faulted ciphertexts into Philippe Teuwen’s PhoenixAES
    tool for differential fault analysis reveals *K*[10], from which the entire key
    schedule can be extracted, including the original AES key as *K*[00].
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会听到说AES128或其他算法在跳过某些轮次时容易受到密码分析攻击，而在我年轻的时候，我曾经好奇这种情况到底有什么用。Limited Results的第三个攻击方法通过故障跳过最后一轮AES。将两个故障的密文输入到Philippe
    Teuwen的PhoenixAES工具中进行差分故障分析，可以揭示出*K*[10]，从中可以提取出整个密钥调度，包括原始的AES密钥*K*[00]。
- en: '**E.3 68HC705 and 6805**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.3 68HC705 和 6805**'
- en: Motorola’s 68HC705 is an early 6800 microcontroller with built-in EEPROM, protected
    from readout by an option bit that can be bypassed with glitching. The 6805 is
    related, but features a mask ROM that can be photographed and a test mode that
    can dump the same electrically.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 摩托罗拉的68HC705是一款早期的6800微控制器，内置EEPROM，通过一个选项位保护防止读取，但可以通过故障攻击绕过该保护。6805与之相关，但它具有一个可以拍照的掩模ROM，以及一个可以电气方式转储的测试模式。
- en: Pemberton (2022) is a custom glitcher built from an Arduino Mega2560 and an
    Altera MAX7000S CPLD, the latter being chosen for its 5V I/O pins that are convenient
    for working with the old microcontroller. His CPLD provides 32 MHz (31.25 ns)
    resolution when glitching the supply voltage and 2 MHz clock of the target.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Pemberton（2022）是一款基于Arduino Mega2560和Altera MAX7000S CPLD的定制故障攻击工具，后者因其方便与老旧微控制器配合使用的5V
    I/O引脚而被选择。他的CPLD在故障攻击目标供电电压和2 MHz时钟时提供32 MHz（31.25 ns）分辨率。
- en: Power glitches are applied through either one or four 2N7000 FETs, and supply
    current on the 5V rail was limited by a resistor between 10 Ω and 220 Ω.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 电源故障通过一个或四个2N7000 FETs施加，并且5V轨的供电电流通过一个10Ω至220Ω的电阻限制。
- en: Pemberton used Motorola (1995) as a handy source of the boot ROM’s source code,
    but he admits that he resorted to brute-forcing the timing rather than choosing
    a target instruction. He describes a nifty trick of expiring the watchdog timer
    before pulling the chip out of reset. This way, the watchdog interrupt does not
    interfere with the regularity of the cycle counting.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 彭伯顿使用了摩托罗拉（1995）作为启动ROM源代码的便捷来源，但他承认他并没有选择目标指令，而是通过强行尝试时序来完成。他描述了一种巧妙的技巧，在将芯片从复位状态中拉出之前，使看门狗定时器过期。这样，看门狗中断就不会干扰周期计数的规律性。
- en: 'For both the 68HC705 with EEPROM and the older MC6805 chip with a mask ROM,
    there is an undocumented test mode to dump the memory. Riddle (2016) is mostly
    about photographically extracting the ROM, but it also contains this description
    of an electrical extraction:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于68HC705带EEPROM的版本和带掩膜ROM的旧款MC6805芯片，都有一个未公开的测试模式来转储内存。瑞德尔（2016）主要是通过摄影提取ROM，但也包含了这个电气提取的描述：
- en: I was able to electronically dump the ROM using the non-user-mode (NUM) pin.
    I used a 1 MHz clock on the EXTAL pin with XTAL grounded, tied !RST, !INT and
    TIMER high, and connected NUM to +5\. I tied the Port A pins to +5 and ground
    using eight 1K resistors to set it to `0x9D`, the opcode for `nop`, and I tied
    Port C.3 high. The ROM contents were output on Port B; I captured the bytes using
    a logic analyzer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过非用户模式（NUM）引脚成功地电子方式转储了ROM。我在EXTAL引脚上使用了1 MHz的时钟，XTAL接地，!RST、!INT和TIMER引脚接高电平，NUM接+5V。我将Port
    A引脚通过八个1K电阻接到+5V和地，将其设置为`0x9D`，即`nop`的操作码，并将Port C.3接高电平。ROM的内容通过Port B输出，我使用逻辑分析仪捕获了这些字节。
- en: '![Image](../images/f0326-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0326-01.jpg)'
- en: 'Figure E.3: 68HC705C8A'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.3：68HC705C8A
- en: Riddle’s page describes electrical dumps of the EEPROM-based MC68705P5 when
    not secured, which is the same procedure as above except that Port C.0 is pulled
    to seven volts through a 1K resistor. The MC68705P3 and ST Micro’s EF6805U3 are
    the same, except that they do not have support for securing against electrical
    dumping. He notes that dumping often begins at the target of the reset vector,
    rather than at address zero.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 瑞德尔的页面描述了当MC68705P5没有被加密时，基于EEPROM的电气转储，这个过程与上面相同，只是Port C.0通过1K电阻拉到七伏。MC68705P3和ST微电子的EF6805U3是相同的，只是它们不支持防止电气转储的加密。他提到，转储通常从复位向量的目标地址开始，而不是从地址零开始。
- en: Please do not confuse his method with the self-test mode, which is a way to
    dump a checksum of memory and not its contents. It sits at `0x784` in the ROM
    of the MC6805P2, where it is activated by putting nine volts on the TIMER pin,
    shifting the interrupt vector table up by eight bytes. LEDs connected with Port
    C will flash on a checksum failure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要将他的方法与自检模式混淆，自检模式用于转储内存的校验和，而不是其内容。它位于MC6805P2 ROM的`0x784`处，通过将九伏电压加到TIMER引脚来激活，从而将中断向量表向上偏移八个字节。连接到Port
    C的LED在校验和失败时会闪烁。
- en: '![Image](../images/f0328-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0328-01.jpg)'
- en: 'Figure E.4: Game Boy Color CPU'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.4：Game Boy Color CPU
- en: '![Image](../images/f0328-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0328-02.jpg)'
- en: 'Figure E.5: Game Boy Color Shellcode from Sideris (2009a)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.5：来自Sideris（2009a）的Game Boy Color Shellcode
- en: '**E.4 Super Game Boy and GB Color**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.4 超级Game Boy与GB Color**'
- en: While the ROM of the Game Boy (DMG) can be read photographically, as we saw
    in [Chapter 23](ch23.xhtml#ch23), the Super Game Boy and Game Boy Color have ROMs
    in which bits are not visible from the surface. Perhaps Dash etching would expose
    them, but voltage glitching makes that unnecessary.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Game Boy（DMG）的ROM可以通过摄影读取，就像我们在[第23章](ch23.xhtml#ch23)中看到的那样，超级Game Boy和Game
    Boy Color的ROM则有一些位无法从表面直接看到。或许通过Dash蚀刻可以暴露这些位，但电压故障使得这一切变得不再必要。
- en: Described in Sideris (2009a) and Sideris (2009b), the trick is to glitch the
    final instruction of the ROM, which disables ROM access until the next reboot.
    By skipping this instruction, a flash memory cartridge programmed with code to
    dump the ROM can freely read the code out of memory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sideris（2009a）和Sideris（2009b）中描述的技巧是对ROM的最后一条指令进行电压故障，从而禁用ROM访问，直到下次重启。通过跳过这条指令，已编程的闪存卡带可以自由地从内存中读取代码，转储ROM内容。
- en: Sideris glitches this by having an FPGA replace the CPU’s clock and the cartridge.
    It counts clock cycles at a normal rate until executing the lockout instruction
    at `0x00FE`, then halts the clock and removes power for a few seconds to drain
    the chip of some state. The hope is that the internal ROM will not be disabled,
    and that the CPU will come back to life at a later address, somewhere in cartridge
    memory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Sideris通过让FPGA替代CPU的时钟和卡带来制造故障。它以正常速率计数时钟周期，直到执行`0x00FE`处的锁定指令，然后停止时钟并切断电源几秒钟，以清除芯片的一些状态。希望内部ROM不会被禁用，并且CPU将在稍后的地址处恢复运行，地址位于卡带内存中某个位置。
- en: On a successful glitch, the cartridge ROM then executes a long nop sled, falling
    into the shellcode in [Figure E.5](app05.xhtml#chEfig5). That shellcode reads
    through all memory, writing to `0xA100|x` for every byte `x` that’s read out of
    memory. Those writes are silently ignored, but the access log produced by his
    FPGA then contains every byte of the console’s memory in order.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障成功后，卡带ROM会执行一长串nop指令，进入[图E.5](app05.xhtml#chEfig5)中的shellcode。该shellcode会读取所有内存，并在每次读取到内存中的字节`x`时，将其写入`0xA100|x`。这些写入会被静默忽略，但由FPGA生成的访问日志会按顺序记录控制台内存中的每个字节。
- en: The Super Game Boy maps its ROM from `0x0000` to `0x00FF`, just like a Game
    Boy. The Game Boy Color has a 3kB ROM that is mapped into both that region and
    into the range from `0x0200` to `0x08ff`, which overlaps the cartridge ROM but
    leaves a gap for the cartridge ROM header from `0x0100` to `0x01FF`. It is from
    within this gap, or after `0x0900`, that shellcode must run.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Super Game Boy将其ROM从`0x0000`映射到`0x00FF`，与Game Boy一样。Game Boy Color有一个3kB的ROM，该ROM被映射到这个区域，并且还映射到`0x0200`到`0x08FF`的范围，这与卡带ROM重叠，但为卡带ROM头部留出了一个从`0x0100`到`0x01FF`的空隙。shellcode必须从这个空隙中运行，或者在`0x0900`之后运行。
- en: '**E.5 STM32F2 Chip.Fail and Kraken**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.5 STM32F2 Chip.Fail与Kraken**'
- en: Roth, Datko, and Nedospasov (2019) describes a glitch of the STM32F2 boot ROM,
    used to downgrade from RDP Level 2 (full protection) to Level 1, where flash memory
    is protected but SRAM is not protected. By extending this with a second glitch,
    Uncredited (2020) demonstrates dumping firmware from a fully locked chip.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Roth、Datko和Nedospasov（2019）描述了STM32F2引导ROM的故障，利用该故障可以从RDP Level 2（完全保护）降级到Level
    1，在Level 1下闪存被保护但SRAM没有被保护。通过扩展此故障并进行第二次故障，Uncredited（2020）展示了从一个完全锁定的芯片中提取固件。
- en: Among other details, Roth notes that it is better to time against the reset
    pin rising high, rather than the application of power. A shunt resistor for power
    analysis shows the reading of the option bytes that contain the protection mode
    as the first visible power spike.^([2](footnotes.xhtml#app5fn2))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他细节中，Roth指出，最好是与复位引脚的上升沿计时，而不是电源的接通。用于电源分析的旁路电阻显示，包含保护模式的选项字节作为第一个可见的电源尖峰。^([2](footnotes.xhtml#app5fn2))
- en: Using an FPGA and MAX4619 analog switch, they successfully glitched the STM32F2
    into RDP Level 1 with a delay of 17,900 cycles and a pulse of 50 cycles at 100MHz.
    RDP Level 1 does not expose flash memory, but early versions of the Trezor cryptocurrency
    wallet moved key material into SRAM, allowing its extraction with careful timing.
    Grand (2022) describes using this attack against an old cryptocurrency wallet
    to record the otherwise lost contents, as updates are not deployed to devices
    forgotten in safes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FPGA和MAX4619模拟开关，他们成功地将STM32F2故障降级至RDP Level 1，延迟为17,900个周期，并在100MHz时产生50个周期的脉冲。RDP
    Level 1不暴露闪存，但早期版本的Trezor加密货币钱包将密钥材料转移到SRAM中，从而可以通过精确计时提取出来。Grand（2022）描述了如何利用这一攻击方法对旧版加密货币钱包进行攻击，以记录本来丢失的内容，因为这些设备在保险箱中被遗忘，更新没有部署到这些设备上。
- en: Like the RDP downgrade in [Chapter D.3](app04.xhtml#app04_3), this glitch can
    also be used to later extract memory with STM32 exploits that require RDP Level
    1, such as the one in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 像[第D.3章](app04.xhtml#app04_3)中的RDP降级一样，这种故障也可以用于后续提取需要RDP Level 1的STM32漏洞内存，例如[第2章](ch02.xhtml#ch02)中的漏洞。
- en: Uncredited (2020) begins by reproducing the RDP downgrade glitch from Roth,
    Datko, and Nedospasov (2019). Like Roth, he was unable to find a fault that dropped
    the chip all the way to Level 0, and he was interested in dumping secrets that
    were held only in flash memory and never copied to SRAM. To do this, he began
    with some observations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Uncredited（2020）首先重现了Roth、Datko和Nedospasov（2019）的RDP降级故障。像Roth一样，他未能找到使芯片完全降级到Level
    0的故障，他的兴趣在于提取仅存储在闪存中并未复制到SRAM中的秘密。为了实现这一目标，他开始了一些观察。
- en: 'First, he notes that glitching roughly 170 µs after reset will enable JTAG
    and SWD on an STM32F205\. Glitching 180 µs after reset will re-enable the bootloader
    ROM. Both JTAG/SWD and the ROM behave as if they were in RDP Level 1, but there
    is a crucial difference: JTAG and SWD will disable access to flash memory in hardware
    when access attempts are made, but the bootloader prohibits access by a software
    check that is performed within the command handler.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，他指出，在复位后大约 170 µs 进行故障攻击将启用 STM32F205 的 JTAG 和 SWD。复位后 180 µs 进行故障攻击将重新启用引导程序
    ROM。JTAG/SWD 和 ROM 的行为就像处于 RDP Level 1 中一样，但有一个关键区别：当访问尝试发生时，JTAG 和 SWD 会在硬件中禁用对闪存的访问，而引导程序则通过命令处理程序内执行的软件检查来禁止访问。
- en: This means that you can dump flash memory from a locked chip by first glitching
    at startup to drop into RDP Level 1, beginning a bootloader session, and then
    performing a second glitch during the Read Memory command handler.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，您可以通过在启动时首先进行故障攻击，将芯片降至 RDP Level 1，开始引导程序会话，然后在执行读取内存命令处理程序时进行第二次故障攻击，从而转储被锁定芯片的闪存。
- en: '**E.6 STM8 Bootloader and SWIM**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.6 STM8 引导程序和 SWIM**'
- en: The STM8 series of 8-bit microcontrollers are used in automotive immobilizers
    and other useful targets. The chip’s lock is in the form of a code readout protection
    (CRP) bit, which is checked by the bootloader.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: STM8 系列 8 位微控制器广泛应用于汽车防盗系统和其他有用的目标中。芯片的锁保护形式为代码读取保护（CRP）位，由引导程序进行检查。
- en: There is also a brown out reset (BOR) feature that resets the chip when the
    voltage drops beneath a threshold. BOR isn’t exactly a glitching defense, but
    it might require that any glitches be narrow and well calibrated to avoid unnecessary
    resets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个掉电重置（BOR）功能，当电压低于阈值时，它会重置芯片。BOR 并不完全是一个故障防御机制，但它可能要求任何故障攻击都必须非常短且精确，以避免不必要的重置。
- en: Described in Section 4 of Herrewegen et al. (2020) is a double-glitching attack
    on the STM8L152 and STM8AF6266\. The first glitch faults a read of `0x8000`, tricking
    the bootloader into thinking that the chip is empty, so that the bootloader starts
    instead of the application. The second glitch faults a read from `0x4800`, tricking
    the chip into thinking that CRP is not enabled.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Herrewegen 等（2020）在第 4 节中描述了一种针对 STM8L152 和 STM8AF6266 的双重故障攻击。第一次故障攻击使对 `0x8000`
    的读取出错，使引导程序误以为芯片是空的，从而启动引导程序而不是应用程序。第二次故障攻击使对 `0x4800` 的读取出错，使芯片误以为 CRP 没有启用。
- en: '![Image](../images/f0332-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0332-01.jpg)'
- en: 'Figure E.6: STM8L152'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.6：STM8L152
- en: Glitching both of these targets is difficult because there’s no feedback mechanism
    letting you know that one of them was timed right, until both have successfully
    been glitched. There’s no way in the locked chip to distinguish a near miss from
    a total failure. To remedy this, they patched the bootloader to run from flash
    memory, allowing experimentation with partial feedback before moving to the tricky
    double-glitch of the locked chip.^([3](footnotes.xhtml#app5fn3))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对这两个目标进行故障攻击很困难，因为没有反馈机制让你知道是否有一次故障攻击的时机正确，直到两次都成功故障攻击。在被锁定的芯片中，无法区分一次差点成功的故障与一次完全失败的故障。为了解决这个问题，他们修补了引导程序，使其从闪存运行，从而允许在转向复杂的双重故障攻击之前进行部分反馈实验。
- en: A far easier glitching target than the bootloader is the SWIM debugging interface,
    which is the STM8’s equivalent of JTAG. The STM8S103 was successfully faulted
    into an unprotected SWIM session with a single glitch after reset in Fritsch (2020).
    This result was reproduced more recently in Rainier (2022) with nothing more than
    a pair of high-speed LMC555 timers! Both reported success when glitching the VCAP
    pin to ground with very short pulses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 比引导程序更容易故障攻击的目标是 SWIM 调试接口，这是 STM8 的 JTAG 等效接口。在 Fritsch（2020）中，STM8S103 在复位后通过一次故障攻击成功进入了未受保护的
    SWIM 会话。Rainier（2022）最近也成功复制了这一结果，仅使用了一对高速 LMC555 定时器！两者都报告了通过用非常短的脉冲将 VCAP 引脚接地进行故障攻击时的成功。
- en: '**E.7 STM32F1/F3 Shaping the Glitch**'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.7 STM32F1/F3 故障形状调整**'
- en: Two glitching attacks against the STM32 are reported in Bozzato, Focardi, and
    Palmarini (2019), in which the authors used a signal generator to control the
    shape of each voltage glitch.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Bozzato、Focardi 和 Palmarini（2019）报告了针对 STM32 的两次故障攻击，在这些攻击中，作者使用信号发生器来控制每个电压故障的形状。
- en: Against the STM32F1 series, they report glitching the Read Memory command to
    bypass the bootloader’s readout protection check. When successful, this glitched
    check returns `ACK` and a chunk of memory. Unsuccessful attempts quickly return
    a `NAK` and no memory, but have no penalty against future attacks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 针对STM32F1系列，他们报告了通过故障注入“读取内存”命令，绕过引导加载程序的读取保护检查。成功时，这个故障的检查会返回`ACK`和一块内存。如果不成功，则会迅速返回`NAK`并且没有内存，但对未来的攻击没有任何惩罚。
- en: For the STM32F3, they perform a glitch at reset to downgrade from RDP Level
    2, in which no bootloader or JTAG connections are allowed, down to RDP Level 1,
    in which limited bootloader and JTAG access are available and the chip is vulnerable
    to other attacks. They note some complications to the glitch timing, as the boot
    process takes some time in which the target’s clock drifts away from the glitcher’s
    clock.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于STM32F3，他们在复位时执行一个故障操作，将RDP Level 2降级到RDP Level 1，在Level 2下不允许使用引导加载程序或JTAG连接，而在Level
    1下则可以有限地使用引导加载程序和JTAG访问，芯片也因此容易受到其他攻击。他们注意到故障时序的复杂性，因为启动过程需要一些时间，而目标的时钟会偏离故障发生器的时钟。
- en: But why do they glitch into Level 1 instead of all the way to Level 0? Well,
    Level 2 is defined as `0xCC33` and Level 0 is `0xAA55` in the protection configuration
    word, so damaging these to *any other value* produces Level 1\. For this reason,
    glitching all the way to Level 0 is much more difficult than simply dropping into
    Level 1.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么他们选择将故障注入降级到Level 1，而不是直接降到Level 0呢？原因在于，Level 2在保护配置字中定义为`0xCC33`，而Level
    0则是`0xAA55`，因此将这些值损坏为*任何其他值*都会导致降级到Level 1。基于这个原因，将故障注入降到Level 0比简单降到Level 1要困难得多。
- en: Other STM32 fault injection attacks follow a similar pattern. Uncredited (2020)
    in [Chapter E.5](app05.xhtml#app05_5), for example, performs its reads by glitching
    the protection level check at runtime rather than at boot time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他STM32的故障注入攻击遵循类似的模式。例如，Uncredited（2020）在[Chapter E.5](app05.xhtml#app05_5)中执行的读取操作，通过在运行时故障注入保护级别检查，而不是在启动时进行。
- en: '**E.8 MSP430F5172 Glitch Per Word**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.8 MSP430F5172 每字故障注入**'
- en: The serial boot-strap loader (BSL) of the MSP430F5 family requires a password
    in the form of the firmware’s interrupt vector table (IVT) before the Read command
    can operate. The general idea is that if you know the contents of the interrupt
    table, then you already have a copy of firmware, so there’s nothing for the chip
    to defend.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: MSP430F5系列的串行引导加载程序（BSL）需要一个固件的中断向量表（IVT）形式的密码，才能使读取命令生效。一般而言，如果你知道中断表的内容，那你就已经拥有了固件的副本，因此芯片无需进行防御。
- en: It’s frustrating to glitch, because the bit that stores the password comparison
    success is checked for *every byte* that is read by the TX Data Block command,
    but a successful attack is documented in Bozzato, Focardi, and Palmarini (2019)
    that dumps individual bytes. This attack is surprisingly fast once calibrated,
    nearly two kilobytes per minute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入很让人沮丧，因为存储密码比对成功的位会对每个通过TX数据块命令读取的字节进行检查，但Bozzato、Focardi和Palmarini（2019）记录了一个成功的攻击案例，该攻击可以转储单个字节。这个攻击一旦校准完成，速度非常快，几乎是每分钟两千字节。
- en: The authors also implemented this attack on a ferroelectric RAM (FRAM) device,
    the MSP430FR5725\. FRAM is a potential replacement for flash memory, but because
    bit errors are frequent at the lowest levels, it includes an ECC mechanism to
    correct expected bit errors, making an unreliable memory appear rock solid. They
    note that this error correction makes the attack much slower, roughly one kilobyte
    every six minutes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作者们还将此攻击实施到了铁电RAM（FRAM）设备MSP430FR5725上。FRAM是闪存的潜在替代品，但由于在最低级别时位错误频繁出现，因此它包括一个ECC机制来修正预期的位错误，从而使不可靠的内存看起来非常可靠。他们指出，这种错误修正使得攻击变得更加缓慢，大约每六分钟才能读取一千字节。
- en: '**E.9 CC2640 CC2652 eFuses**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.9 CC2640 CC2652 电子熔丝**'
- en: Wouters, Gielichs, and Preneel (2022) describes a fault injection attack against
    the CC2640R2F and CC2652R1F, 2.4GHz radio microcontrollers in the SimpleLink series
    by Texas Instruments. Their commercial target was the Tesla Model 3 key fob, which
    uses the CC2640.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Wouters、Gielichs和Preneel（2022）描述了对德州仪器SimpleLink系列中CC2640R2F和CC2652R1F 2.4GHz无线微控制器的故障注入攻击。他们的商业目标是特斯拉Model
    3的钥匙扣，后者使用了CC2640。
- en: By reverse engineering a dump of the bootloader ROM, they identified two good
    targets for glitching in the form of settings that are fetched from the Customer
    Configuration (CCFG) and Factory Configuration (FCFG) pages of eFuses. To ease
    experimentation, they built an emulator for the ROM away from hardware.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反向工程启动加载程序ROM的转储，他们识别出了两个有效的故障目标，分别是从客户配置（CCFG）和工厂配置（FCFG）eFuse页面提取的设置。为了便于实验，他们构建了一个不依赖硬件的ROM仿真器。
- en: They first characterized the glitch width that triggered faults but not crashes
    by glitching a tight loop in an artificial target program, allowing them to temporarily
    set aside the issue of the glitch offset. The CC2640R2F (Cortex M3) was best faulted
    for a duration of 100 ns, while the CC2652R1F (Cortex M4) was best faulted for
    a longer duration, 610 ns. They attribute this to differences in micro-architecture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 他们首先通过在一个人工目标程序中故障一个紧凑的循环，表征了触发故障但不崩溃的故障宽度，从而让他们可以暂时搁置故障偏移的问题。CC2640R2F（Cortex
    M3）在100纳秒时最易发生故障，而CC2652R1F（Cortex M4）则在较长的610纳秒时最易发生故障。他们将这种差异归因于微架构的不同。
- en: '**Customer Configuration (CCFG)**'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**客户配置（CCFG）**'
- en: A first glitching target was the Customer Configuration (CCFG) eFuse parsing,
    in which the ROM reads `CCFG:CCFG_TAP_DAP_x` registers to learn which JTAG features
    will be enabled. Side channel analysis of power consumption differences between
    a chip with valid firmware and a chip with invalid firmware gave an estimated
    “last moment” of the ROM parsing CCFG bits. Potential glitch target times were
    explored backward from that offset.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个故障目标是客户配置（CCFG）eFuse解析，其中ROM读取`CCFG:CCFG_TAP_DAP_x`寄存器以了解哪些JTAG功能将被启用。通过对具有有效固件和无效固件的芯片之间功耗差异的侧信道分析，估算了ROM解析CCFG位的“最后时刻”。潜在的故障目标时间是从该偏移量反向探索的。
- en: '![Image](../images/f0336-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0336-01.jpg)'
- en: 'Figure E.7: Texas Instruments CC2640'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图E.7：德州仪器 CC2640
- en: 'Here they hit a snag: each glitch attempt might enable JTAG, but JTAG is slow,
    and they were only able to attempt one glitch every 2.5 seconds! To speed things
    up, they wrote a quick little program that outputs the state of the `JTAGCFG`
    register to a UART. This allowed glitch timings against a test chip to be quickly
    attempted without waiting on a JTAG connection, at a rate of ten attempts per
    second. After characterization, the derived glitch offset from the test chip could
    then be used on the real target chip.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里他们遇到了一些困难：每次故障尝试可能会启用JTAG，但JTAG速度较慢，他们只能每2.5秒尝试一次故障！为了加速，他们编写了一个小程序，将`JTAGCFG`寄存器的状态输出到UART。这使得可以在没有等待JTAG连接的情况下，以每秒十次的速度对测试芯片进行故障时序尝试。经过表征后，从测试芯片得出的故障偏移可以用于真实目标芯片。
- en: Measured in 200 MHz ChipWhisperer cycles after reset, the successful offsets
    for glitching the CCFG to enable JTAG were between 188,300 and 188,4000 cycles
    for the CC2640R2F, for a success rate of 5%. The CC2652R1F was glitched between
    161,700 and 162,000 cycles after reset, with a success rate of 1%.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在200 MHz ChipWhisperer周期中，经过复位后的故障偏移，成功的CCFG故障以启用JTAG的偏移量在CC2640R2F之间为188,300到188,4000周期，成功率为5%。CC2652R1F在复位后的161,700到162,000周期之间发生故障，成功率为1%。
- en: '**Factory Test Mode (FCFG)**'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**工厂测试模式（FCFG）**'
- en: By this point, successful glitches were known for both chips, but they were
    slow. A better target presented itself in an undocumented factory test mode, one
    that is earlier in the boot process and triggered by the Factory Configuration
    (FCFG) fuses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，两个芯片的成功故障已经确认，但它们比较慢。一个更好的目标出现了，它是一个未记录的工厂测试模式，在启动过程的早期触发，由工厂配置（FCFG）eFuse引发。
- en: If you recall that the principle limitation of glitching CCFG was detecting
    the open JTAG connection, then you might hope for some other signal that the glitch
    was successful. The very best such signal would be a GPIO pin, and that’s exactly
    what was found by reverse engineering early checks in the ROM.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得故障CCFG的原理限制是检测到开放的JTAG连接，那么你可能会希望找到其他信号来确认故障是否成功。最理想的信号就是GPIO引脚，这正是通过反向工程ROM中的早期检查发现的。
- en: Checking the GPIO pin state allows one hundred attempts per second, ten times
    better than the UART indication. Because the code for the indication exists in
    ROM, it works on both practice attempts and against a real target of unknown firmware!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 检查GPIO引脚状态允许每秒进行一百次尝试，比UART指示的速度快十倍。因为指示的代码存在于ROM中，它不仅适用于实践尝试，还能在面对未知固件的真实目标时正常工作！
- en: Successful glitching sets GPIO pin 23 high. The CC2640R2F glitches into this
    state between 161,100 and 161,200 cycles after reset, with a glitch width of 115ns
    resulting in a 10% success rate. This takes less than a second! The CC2652R1F
    glitched into this state between 129,700 and 129,900 clock cycles, but saw no
    improvement from the earlier glitch width of 610ns. This had a success rate of
    0.1%, allowing them to enable all debugging features in no more than a few seconds.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**E.10 LC87 Unlooping over USB**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of my favorite sources for this book is Scott (2016). She describes a glitching
    attack against the USB `GET_DESCRIPTOR` request of the Sanyo/ONsemi LC871W32 microcontroller
    in a Wacom CTE-450 tablet. Her article is a joy to read, ending with a successful
    read of a 125 kHz RFID tag using the scanning wires of the tablet and a software-only
    memory corruption exploit. For the purposes of this book, I’ll focus on her initial
    extraction of the device’s mask ROM by glitching its USB handlers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The LC87 is an 8-bit microcontroller, sold in very high volumes and without
    any support for hobbyist or low-volume use. In the case of these pen tablets,
    Wacom first used a flash memory variant of the chip and later switched to a masked
    ROM variant.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: When she first approached the tablet, the debugging port of the LC87 denied
    any connections and having no serial bootloader, USB was her best bet for a memory
    corruption attack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Back then, there was little in public writing about USB glitching attacks, so
    she designed the FaceWhisperer, an extension for Colin O’Flynn’s Chipwhisperer.^([4](footnotes.xhtml#app5fn4))
    Like my Facedancer boards, hers uses a Maxim MAX3241E USB controller, but she
    also provides a 12MHz clock output and a glitch trigger input with an adjustable
    voltage threshold.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: While timing the glitch can be harder in USB than against a UART bootloader,
    there do exist universal commands implemented by all USB devices. Rather than
    target something unique to the Wacom’s protocol, she targeted the generic `GET_DESCRIPTOR`
    handler, which is implemented in all USB devices. It returns a structure defining
    the interfaces and endpoints the device provides. While this structure can be
    dynamically generated, many devices simply store a static copy in code memory
    and return it when requested.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In the tablet’s case, the USB configuration descriptor was 34 bytes long and
    returned in a single packet. A successful transaction looks something like this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0339-01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: When the timing is just right, a glitch can corrupt the length of the transfer,
    causing more bytes to be returned. This example shows 268 bytes, 234 of which
    come after the 34 bytes of the real descriptor. After a few more glitches with
    similar timing, she managed to luck out with a 65,534-byte transaction, including
    all 32kB of mask ROM!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0340-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: After dumping the ROM, she reverse engineered it to find an undocumented backdoor,
    a human interface device (HID) request that writes exactly 16 bytes into SRAM
    at an arbitrary address. While RAM is not executable on this platform, that was
    enough for her to load and execute a ROP chain for arbitrary behavior.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: With a little analog magic and a lot of experience, she was able to pulse the
    tablet’s sense wires in the right way, to both power and read an EM4100 RFID tag.
    A strange goal, but a damned impressive one, considering that there were zero
    hardware modifications in her final target.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**E.11 78K0 Glitching Checksums**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first glitching exploit of the Renesas 78K0 was described in Bozzato, Focardi,
    and Palmarini (2019). Their exploit glitches the Checksum and Verify commands
    to operate on four bytes instead of the minimum 256 bytes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A later attack in Herrewegen et al. (2020) uses knowledge from a reverse engineered
    ROM to provide more accurate timing, leaking individual bytes. Because the sanity
    check must be bypassed for every byte read, a successful dump takes ten hours
    or so after the equipment has been calibrated.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The best-known attack is well described in Wouters et al. (2020), which is mostly
    about the Texas Instruments DST80 immobilizer system for modern cars. Rather than
    try to dump firmware from the immobilizer chip, they glitched a Renesas 78K0/KC2
    chip from a Toyota ECU.^([5](footnotes.xhtml#app5fn5)) And rather than try to
    glitch the Checksum or Read commands, Wouters glitches the Set Security command.
    This command includes a safety check to ensure that the new security state is
    no less secure than the old one, and bypassing this check allows a single successful
    glitch to unlock the chip.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Glitch parameters can be found on [page 105](ch10.xhtml#page_105) of their paper,
    in which a 16 MHz target’s Security Set command was glitched from 2.7V to 0V with
    a 100 ns width at an offset of 596.78 µs or 818.05 µs after the first bit of the
    Security Set message. They believe the timing difference comes from the choice
    of protections, as one of their targets had more protections enabled than the
    other.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**E.12 RX65 Bootloader Glitching**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Renesas RX65 chips allow readout protections to be set for memory ranges and
    by installing an ID code. The range restrictions are used to prevent reading the
    bootloader ROM, while the ID code is the password that protects against readout
    of flash memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Julien (2021) describes a voltage glitching attack against the Renesas RX65N,
    accomplished by first reverse engineering the undocumented FINE protocol that
    wraps commands of the documented serial communication interface (SCI) protocol.
    He then removed the target’s decoupling capacitors and glitched through a transistor
    on the VCL pin, which exposes the internal core voltage. His glitch pulse was
    applied by a Nucleo-F429L board running at 180MHz, and the source pulse was under
    100 ns.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: While his initial glitching was performed without having a dump of the bootloader
    ROM, that glitch allowed him to dump reserved areas of memory. Most returned all
    zeroes, but eventually the bootloader ROM was found in the range from `0xfe7f-9000`
    to `0xfe7fffff`. This is a little weird in that it sits beneath a round number,
    rather than beginning on a round number.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**E.13 GPLB52X Tamagotchi**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Tamagotchi toys use the GPLB52X, an LCD controller from General Plus with
    a 6502 microcontroller and an application in custom mask ROM. Here we’ll discuss
    three ways to get remote code execution inside them for firmware dumping, and
    one of these techniques seems portable to other 6502 machines with attacker-controlled
    SRAM buffers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Silvanovich (2013a) describes a reliable software exploit of an unhandled case
    in a `switch` statement of the Tamatown Tama-Go toys, with shellcode loaded as
    artwork into the LCD framebuffer. This exploit is particularly clever because
    she had to write it blind, without already having a dump of the mask ROM to reverse
    engineer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the die photo on [page 343](app05.xhtml#chEfig8), she searched
    through wire-bonding documentation from General Plus until the bonding pads in
    the documentation matched those in the chip from the toy. That told her the chip’s
    model number and allowed her to write shellcode, but she still needed a way to
    execute her shellcode.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0343-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Figure E.8: General Plus GPLB52X'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0344-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Figure E.9: Simplified GPLB52X Memory Map'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: And executing shellcode is tricky, as the attacker controls only external EEPROM
    memory. This external memory is not executable in place, so it’s necessary to
    wait for the device to read the external EEPROM and then copy some of its data
    to internal SRAM, which is executable. Helpfully, the toy keeps sprites in the
    external EEPROM that are displayed on the toy’s LCD screen from a memory-mapped
    frame buffer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: So she placed shellcode with a long nop sled into the LCD buffer as plugin graphics
    from an external EEPROM, then fuzzed all available configuration bytes in the
    EEPROM until the shell-code ran and dumped the internal ROM. Having the ROM, she
    reverse engineered it to find a parser vulnerability in a `switch()` statement
    and wrote a clean exploit that reliably triggered the same code execution with
    minimal side effects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: A later toy, Tamagotchi Friends, was released without support for memory chip
    accessories or infrared communications, but with support for a small EEPROM of
    persistent data and an NFC peripheral. Silvanovich (2014) describes a successful
    glitching attack, in which she was able to redirect execution into her 54-byte
    shellcode that was copied as data from EEPROM into the LCD frame buffer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Rather than trying to skip a specific instruction as many other glitching attacks
    do in this book, she instead glitched the target hard enough that the program
    counter was corrupted. The 6502 CPU has no illegal instructions and much of unused
    memory reads as `0x00`, which is a `brk` instruction when a debugger is attached
    but otherwise a `nop`, forming a nop sled that leads more or less to her shellcode,
    shown in [Figure E.10](app05.xhtml#chEfig10).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a brownout glitch can be found in YKT (2023), where the 6502
    core of a Mitsubishi M37409M2 is tricked into running shellcode from an SRAM buffer.
    Like Natalie’s attack, this one also uses shellcode with a long nop sled and relies
    on randomizing the program counter with a long power fault rather than attempting
    to glitch an individual instruction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0346-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure E.10: GPLB52X (6502) Shellcode for Tamagotchi Friends'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'YKT describes the attack like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Dumped the SC-55mkII’s secondary MCU (Mitsubishi M37409M2) firmware using voltage
    glitching. Injecting trojan to its ram and using glitch to corrupt PC counter
    to execute it did the trick.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Disabling power of the chip will cause PC register corrupt to randomish value.
    Since this is a really simple 8-bit MCU with very small memory footprint—only
    8kB—there’s very high chances to point PC to ram address and execute it after
    lots of retries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Silvanovich (2013b) describes a test program, resident in ROM at `0xC000` in
    the GPLB52X series. Natalie dumped it along with the Tamagotchi, where it sits
    just before the application begins at `0xCC00`. See [Figure E.9](app05.xhtml#chEfig9)
    for the memory map and [Table E.1](app05.xhtml#chEtab1) for a list of test programs.
    Test mode is started with the test pin of the die, then the program number sampled
    over Port A. She has particular interest in programs `03` and `14`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Program `03` is a ROM checksum routine. By default, when Port B is not set,
    the checksum covers the entire ROM. Setting Port B allows a range to be clocked
    in, but this is sadly not exploitable for dumping individual bytes. The range
    must be at least 255, and a bug in the ROM leaves Port B in input mode after the
    transaction, so you can’t read the checksum when a limited range is selected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '|  `00`  | Sleep mode? |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `01` | RAM Test |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `02` | Stress Test |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `03` | ROM Checksum |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `04` | LCD Test |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `05` | Unknown |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `06` | Port Stress Test |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `07` | Timer Interrupt Test |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `08` | Another LCD Test |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `09` | Unknown |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `0A` | Unknown |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `0B` | Something like `09` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `0C` | Something like `00` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `0D` | Something like `04` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `0E` | Unknown |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `0F` | SPI Test |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `10` | Unknown |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `11` | LCD Test |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `12` | Something like `16` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `13` | ROM Checksum |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `14` | **Code Execution!** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `15` | Interrupt Test? |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `16` | Jumps to RAM at `0x0200` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `17` | Sets `0x300b` and `0x300c` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: 'Table E.1: GPLB52X Test Codes from Silvanovich (2013b)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Program `14` is more useful. It accepts bits of a program over port B.7, one
    bit at a time, with bits 2 and 4 of the same port signaling when the next bit
    is ready. The program is loaded from `0x0200` to `0x05ff`, then executed in place
    after the last bit is loaded. [Figure E.11](app05.xhtml#chEfig11) has a listing
    of this program handler.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0349-01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure E.11: GeneralPlus Test Program `14`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**E.14 MC9S12 Reset Glitch**'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HCS12 chips such as Freescale’s MC9S12 chip are popular as automotive ECUs.
    They are regularly cracked by the automotive chip-tuning industry to adjust the
    air fuel ratios of fuel injected engines.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Stephen Chavez and Specter presented some hints at their crack in Chavez and
    Specter (2017), and from private correspondence I’ve confirmed that they dumped
    the chip by pulling the reset line high with a very short pulse to confuse the
    HCS12 reset state machine.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The VVDI Prog is a commercial chip programmer, whose special feature is built-in
    support for memory extraction attacks against a number of automotive microcontrollers,
    for performance tuning or key copying. As of version 4.9.5, it advertises attacks
    against some members of the MC68HC(9)08, MC68HC(9)12, and MC9S12 families.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**E.15 Nvidia Tegra X2**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the Tegra X1 had a very well-publicized deployment in the Nintendo Switch,
    the X2 was found in more expensive devices, such as autonomous driving units and
    infotainment systems in modern cars. A voltage fault injection for the X2 is described
    in Bittner et al. (2021).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The X2 boots in three stages: (1) the iROM runs from masked ROM to decrypt
    and verify the signature of (2) Nvidia’s MB1 bootloader from an eMMC, which then
    runs (3) the OEM’s MB2 bootloader from eMMC. MB1 is encrypted and its signing
    key is tightly protected by Nvidia, but MB2 can be freely modified using development
    kits.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Bittner’s first challenge was to write an MB2 image that would dump the iROM
    for reverse engineering. This was aided by leaked BootROM source code from the
    X1, which periodically appears online before disappearing in a flurry of DMCA
    notices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0351-01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Figure E.12: Fuse Check in the X2’s UART Bootloader'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering the iROM revealed that the chip supports a “Failure Analysis
    Mode,” in which a prompt is sent to a UART and then code is received over that
    UART for execution. This mode is chosen by a fuse check early in the boot process,
    so the fuse check is a good glitch target. The reset pin can be used as a trigger
    signal for glitch timing, and the appearance of a UART prompt indicates a successful
    glitch.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: For the fault injection itself, Bittner used an IRF8736 MOSFET to glitch a voltage
    rail of the X2, controlling the MOSFET by an FPGA’s GPIO pin through a MAX4619
    level shifter. The target of the glitch is roughly the code in [Figure E.12](app05.xhtml#chEfig12),
    with lines 3 or 11 being good candidates for the faulted instruction.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Having code execution through the UART bootloader, they then loaded shellcode
    that used the X2’s internal keys to decrypt the MB1 bootloader.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过UART引导加载程序执行代码后，他们加载了利用X2内部密钥解密MB1引导加载程序的shellcode。
- en: '**E.16 Zynq 7000 ROM Dump Glitch**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.16 Zynq 7000 ROM 转储故障**'
- en: The Zynq series from Xilinx combine an ARM CPU with a Xilinx 7-Series FPGA.
    They’re commonly found in lab equipment, Bitcoin mining rigs, and anywhere else
    that a Linux machine and an FPGA are needed in a single package. The chip boots
    from a signed image in external memory, such as a SPI flash chip or an SD card.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Xilinx的Zynq系列将ARM CPU与Xilinx 7系列FPGA结合在一起。它们通常出现在实验室设备、比特币挖矿设备以及任何需要在单一包装中集成Linux机器和FPGA的地方。该芯片从外部存储器中的签名镜像启动，例如SPI闪存芯片或SD卡。
- en: The Zynq boot ROM supports signed and encrypted firmware images, making it a
    prime target for software exploits, but access to the ROM is disabled before control
    is handed over to the application. This makes reading the ROM difficult, even
    from an unlocked development kit.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Zynq引导ROM支持签名和加密的固件镜像，这使其成为软件漏洞攻击的主要目标，但在控制权交给应用程序之前，ROM的访问是被禁用的。这使得即使从解锁的开发工具包中，也很难读取ROM。
- en: Schretlen (2021b) describes a fault injection technique for dumping the boot
    ROM. It requires strapping the PLL_DISABLE pin, and also replacing some of the
    decoupling caps with SOT23 FETs. Timing was too unpredictable when triggering
    on the target’s reset signal, and the SD card’s own timing was too noisy to use
    as a start trigger.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Schretlen (2021b)描述了一种故障注入技术，用于转储引导ROM。它要求将PLL_DISABLE引脚固定，并且需要用SOT23 FET替换一些去耦电容。当通过触发目标的复位信号时，时序过于不可预测，而SD卡自身的时序也太嘈杂，无法用作启动触发器。
- en: The solution was to trigger after the last byte returned from the SD card to
    the Zynq. The author notes that the SPI flash boot method might be more deterministic,
    but the required pins were not broken out on the available development board.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在从SD卡返回Zynq的最后一个字节之后触发。作者指出，SPI闪存引导方法可能更具确定性，但所需的引脚在现有的开发板上并没有被引出。
- en: Glitching is a fine way to extract a ROM when there are no other options, as
    was the case for the first extraction of this ROM. After getting the ROM and reverse
    engineering it, a common goal is to find a software bug that allows for extraction
    without glitching. See [Chapter A.10](app01.xhtml#app01_10) for just such an exploit
    against this chip.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有其他选项时，使用故障注入提取ROM是一种不错的方法，这也是首次提取该ROM时使用的方法。在获取ROM并进行逆向工程后，一个常见的目标是找到一种软件漏洞，允许在不使用故障注入的情况下提取ROM。有关这种漏洞的更多信息，请参见[章节A.10](app01.xhtml#app01_10)。
- en: '**E.17 STM32 Body Biasing Injection**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.17 STM32体偏压注入**'
- en: Body biasing injection (BBI) attacks were first introduced to literature in
    Maurine et al. (2012), as a way to induce a fault by regionally raising the voltage
    on the underside of the microchip die. This requires exposing the backside of
    the die, then stepping a probe around to explore the best injection spots for
    any particular attack.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 体偏压注入（BBI）攻击最早在Maurine等人（2012）中提出，作为一种通过局部提升微芯片背面电压来诱发故障的方法。这需要暴露芯片的背面，然后使用探针沿着背面探索任何特定攻击的最佳注入点。
- en: While it requires more equipment and preparation than voltage glitching, it
    has the advantage of inducing a *localized* fault. These faults are confined to
    a region of the chip, leaving the rest of the chip to run properly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它比电压故障注入需要更多的设备和准备，但它有诱发*局部*故障的优势。这些故障仅限于芯片的某一区域，其他部分则能够正常工作。
- en: O’Flynn (2020b) describes a practical attack against the STM32-F415 in wafer-level
    chip-scale packaging (WLCSP), which naturally exposes the backside of the die.
    Recall from [Chapter 18](ch18.xhtml#ch18) that WLCSP works by putting BGA solder
    balls directly onto a die, which is soldered to a circuit board without any plastic
    encapsulation. This dramatically reduces the preparation time, as there’s no need
    to chemically or mechanically remove the device packaging.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: O'Flynn (2020b)描述了针对STM32-F415的实际攻击，该芯片采用晶圆级芯片尺寸封装（WLCSP），自然暴露了芯片背面。回顾[第18章](ch18.xhtml#ch18)，WLCSP通过将BGA焊球直接放置在芯片上，并将其焊接到电路板上，而无需任何塑料封装。这大大缩短了准备时间，因为不需要化学或机械地去除设备封装。
- en: He used a custom probe called the ChipJabber BBI that sits at the end of a ChipWhisperer.
    Whenever the CW glitch fires, a low-voltage pulse from two capacitors fires through
    a transformer to send a high-voltage pulse into a probe on the backside of the
    die. Power is provided by a bench supply with current limiting capability. See
    [Figure E.13](app05.xhtml#chEfig13).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: O’Flynn used a three-axis motorized stage and a spring-loaded probe to scan
    256 unique points on the WLCSP package’s surface. On these packages, the surface
    layer faces downward into the circuit board, while the backside is exposed away
    from the board for the probe. Some of them have a thin opaque layer over the backside,
    but such paint can be scraped away with a knife.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0354-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Figure E.13: ChipJabber BBI Schematic'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0354-02.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Figure E.14: STM32F103 Bias Points from Balda (2021)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The transformer was custom-wound around a commercial ferrite rod, with six turns
    of 26 AWG magnetic wire for the primary winding and sixty turns of 30 AWS wire
    for the secondary winding. Fewer turns result in lower inductance, which is necessary
    for a fast reaction time. More turns would slow the slew rate and lengthen the
    pulse duration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In terms of faults, he was more interested in providing a convenient target
    for research into body biasing techniques than breaking the readout protection
    of any particular device. His examples include a nested loop for characterization,
    a classic fault attack on RSA-CRT and the beginnings of characterizing faults
    in the hardware AES accelerator.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: As O’Flynn’s excellent paper set up the STM32 as a target but stopped just short
    of a memory extraction exploit, there was a good opportunity for a second paper.
    Balda (2021) provided this, reproducing the work against an STM32F103 microcontroller
    with an aim to extract locked firmware.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: His STM32F103 is a wire-bonded BGA in which the front side of the die faces
    away from the board and the backside faces down into the board. This is far less
    convenient than the WLCSP package, but luckily the center pins of the BGA package
    weren’t needed for the bootloader. Balda slowly ground through the PCB, the solder
    bumps, and the bottom of the BGA package to reveal the die. A copper pad that
    was against the die was pulled away with a scalpel after pieces had been freed
    by grinding.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: This chip has a single RDP level, as we saw in [Chapter 11](ch11.xhtml#ch11),
    and Balda chose to attack it through the bootloader rather than through JTAG.
    Each time the read request is sent to the boot-loader as `0x11 0xEE`, the BBI
    fault injection has a chance to skip the device’s RDP check and allow the read
    to continue.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Balda notes that successful glitches for the RDP bypass were inserted 8.95 µs
    after the last rising edge of the bootloader read command. The fault must be performed
    for every memory read, but a 60% success rate keeps things moving quickly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Plotting the successful locations of those faults produces [Figure E.14](app05.xhtml#chEfig14),
    showing that at these voltages the useful faults all come in or around the flash
    memory. None of the faults targeted the CPU, and Balda hypothesizes that this
    is because the ROM boot-loader reads from the flash memory’s `FLASH_OBR` register,
    which holds a single bit for the RDP status.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这些故障的成功位置生成了[图 E.14](app05.xhtml#chEfig14)，显示在这些电压下，有效的故障几乎都发生在闪存附近。没有任何故障针对
    CPU，Balda 假设这是因为 ROM 启动加载器从闪存的 `FLASH_OBR` 寄存器读取，该寄存器保存了 RDP 状态的单个位。
- en: Glitches 3.5 µs after the last rising edge of the command had a different and
    undesired effect, mass erasing all flash memory and destroying the information
    that might be retrieved. Effects like these are why it’s so important to carefully
    calibrate glitches, rather than adopting a “spray and pray” strategy and leaving
    the equipment to run unattended in a cupboard.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令最后一个上升沿之后 3.5 µs 的故障产生了不同且不希望出现的效果，导致所有闪存被大规模擦除，并摧毁了可能被恢复的信息。像这样的效果说明了为什么必须小心校准故障，而不是采用“漫天撒网”的策略，并将设备无人看管地放在柜子里运行。
- en: '**E.18 PCF7941 Erasure**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.18 PCF7941 擦除**'
- en: NXP has a series of wireless security transponders implemented as RISC microcontrollers.
    One of these, the PCF7941, has been successfully glitched to program replacement
    car keys.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: NXP 有一系列实现为 RISC 微控制器的无线安全应答器。其中之一 PCF7941 已成功被干扰，用于编程替换车钥匙。
- en: In a San Francisco dive bar, I heard that this required cooling the chip with
    alcohol and dry ice for several days before an FPGA was able to glitch the 2Link
    debugging protocol into an unlock. It sounded like the attack used a single glitch
    to unlock all the chip at one time, but I’m not entirely sure from the description.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧金山的一家地下酒吧里，我听说这需要用酒精和干冰将芯片冷却几天，直到 FPGA 能够利用 2Link 调试协议进行解锁。听起来这个攻击使用了单次故障来一次性解锁整个芯片，但我不完全确定描述中的细节。
- en: Some commercial tools, like VVDI Prog mentioned in [Chapter E.14](app05.xhtml#app05_14),
    support the PCF7941\. They use a wired connection to glitch the chip, erasing
    it for a new pairing. The glitch is only to allow erasure of a locked chip. These
    tools don’t seem to extract the firmware, as their customers are more interested
    in matching keys to new vehicles.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一些商业工具，如在[章节 E.14](app05.xhtml#app05_14)中提到的 VVDI Prog，支持 PCF7941\。它们通过有线连接干扰芯片，擦除它以便重新配对。这个故障仅用于允许擦除被锁定的芯片。这些工具似乎不会提取固件，因为它们的客户更关注为新车匹配钥匙。
- en: '![Image](../images/f0357-01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0357-01.jpg)'
- en: 'Figure E.15: NXP PCF7941'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 E.15：NXP PCF7941
- en: '**E.19 EFM32WG without a Brownout**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**E.19 没有欠压的 EFM32WG**'
- en: The EFM32WG is a nice little ARM Cortex-M chip from Silicon Labs. Its longevity
    is guaranteed until 2026, marketed toward smart meters and industrial automation.
    While the CPU itself would be vulnerable to glitching, the chip features effective
    brownout detection (BOD) circuits that reset the chip during bootloader glitching
    attempts, frustrating the attack.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: EFM32WG 是一款来自 Silicon Labs 的小型 ARM Cortex-M 芯片，主要用于智能电表和工业自动化领域。其使用寿命保证至2026年。尽管
    CPU 本身可能容易受到故障干扰，但该芯片配备了有效的欠压检测（BOD）电路，可以在启动加载器出现故障时重置芯片，从而有效防止攻击。
- en: Results (2021a) describes using electromagnetic fault injection (EMFI) to glitch
    the CPU region of the chip, allowing protected firmware to be read without causing
    a brownout. This was performed because regular voltage glitching reliably triggered
    one of four brownout detectors (BODs) before introducing any faults, requiring
    the localized fault injection that EMFI can provide.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果（2021a）描述了使用电磁故障注入（EMFI）干扰芯片的 CPU 区域，允许读取受保护的固件而不引发欠压。这是因为常规的电压故障会在引入任何故障之前可靠地触发四个欠压检测器（BOD）之一，因此需要使用
    EMFI 提供的局部故障注入。
- en: The EMFI system is a custom one called Der Injektor. The design has not yet
    been published as I write this, but it might be by the time you read this.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: EMFI 系统是一种名为 Der Injektor 的定制系统。尽管我在撰写时该设计尚未公开，但可能在你阅读时已经发布。
- en: These results were successfully reproduced by Transistor (2023) against a Bosch
    smart home system. While Limited Results built a custom EMFI tool, Vegan Transistor
    preferred to modify a Langer BS 06DB-s pulse generator that was intended for electrical
    fast transient (EFT) pulse testing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Transistor（2023）成功地在博世智能家居系统上复现了这些结果。虽然 Limited Results 构建了定制的 EMFI 工具，但 Vegan
    Transistor 更喜欢修改一款 Langer BS 06DB-s 脉冲发生器，该脉冲发生器原本用于电快速瞬变（EFT）脉冲测试。
- en: To identify the proper time for fault injection, power was traced in both a
    locked and an unlocked state. This was performed by a magnetic field probe near
    a decoupling capacitor, amplified to account for the low power consumption of
    the chip. The glitch target window begins 150 µs after reset, lasting for 47 µs.
    Immediately afterward, the first instruction begins execution.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Faults that were too strong triggered a reset, and by backing up just a bit
    until the resets ceased, the right power level was identified. Eventually JTAG
    unlocked and a standard Segger J-Flash read out 128kB of firmware.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**E.20 MPC55 by EMFI**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: O’Flynn (2020a) describes an electromagnetic attack against the boot assist
    module (BAM) of the NXP MPC5676R and MPC5566 chips, PowerPC devices that are popular
    in automotive ECUs.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Electrically, the only thing special about an automotive grade chip is that
    it will run at a higher temperature. From a security perspective, though, there’s
    an entire industry called *chip tuning* that hacks these chips in order to improve
    engine performance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that O’Flynn didn’t bother reverse engineering the BAM ROM,
    as it wasn’t necessary to implement his attack. Power rail glitching would likely
    also work, but EMFI allows the attack to be performed without relocating the chip
    from its board in the ECU of a 2019 Chevy Silverado. There’s no need to remove
    decoupling capacitors or solder in a transistor for glitching.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Similar chips are sold by as the SPC57xx and SPC58xx from ST Micro. These perform
    their permission check *after* buffering the code in SRAM. That dramatically slows
    the fault timing search, because the full transfer must be repeated for every
    single fault injection attempt. O’Flynn has not yet reported success in breaking
    them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
