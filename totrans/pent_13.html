<html><head></head><body><section class="chapter" epub:type="chapter" id="password_attacks" title="Chapter&#xA0;9.&#xA0;Password Attacks"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Password Attacks</h2></div></div></div><p><a class="indexterm" id="iddle1881"/><a class="indexterm" id="iddle1898"/>Passwords are often the path of least resistance on pentesting engagements. A client with a strong security program can fix missing Windows patches and out-of-date software, but the users themselves can’t be patched. We’ll look at attacking users when we discuss</p><p>social engineering in <a class="xref" href="ch11.xhtml" title="Chapter 11. Social Engineering">Chapter 11</a>, but if we can correctly guess or calculate a user’s password, we may be able to avoid involving the user in the attack at all. In this chapter we’ll look at how to use tools to automate running services on our targets and sending usernames and passwords. Additionally, we’ll study cracking the password hashes we gained access to in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>.</p><div class="sect1" title="Password Management"><div class="titlepage"><div><div><h2 class="title" id="password_management" style="clear: both">Password Management</h2></div></div></div><p>Companies are waking up to the inherent risks of password-based authentication; brute-force attacks and educated guesses are both serious risks to weak passwords. Many organizations use biometric (fingerprint or retinal <a class="indexterm" id="iddle1135"/><a class="indexterm" id="iddle1221"/><a class="indexterm" id="iddle1270"/><a class="indexterm" id="iddle1883"/><a class="indexterm" id="iddle1905"/><a class="indexterm" id="iddle2257"/><a class="indexterm" id="iddle2320"/>scan-based) or two-factor authentication to mitigate these risks. Even web services such as Gmail and Dropbox offer two-factor authentication in which the user provides a password as well as a second value, such as the digits on an electronic token. If two-factor authentication is not available, using strong passwords is imperative for account security because all that stands between the attacker and sensitive data may come down to a simple string. Strong passwords are long, use characters from multiple complexity classes, and are not based on a dictionary word.</p><p>The passwords we use in this book are deliberately terrible, but unfortunately, many users don’t behave much better when it comes to passwords. Organizations can force users to create strong passwords, but as passwords become more complex, they become harder to remember. Users are likely to leave a password that they can’t remember in a file on their computer, in their smartphone, or even on a Post-it note, because it’s just easier to keep of track them that way. Of course, passwords that can be discovered lying around in plaintext undermine the security of using a strong password.</p><p>Another cardinal sin of good password management is using the same password on many sites. In a worst-case scenario, the CEO’s weak password for a compromised web forum might just be the very same one for his or her corporate access to financial documents. Password reuse is something to bear in mind while performing password attacks; you may find the same passwords work on multiple systems and sites.</p><p>Password management presents a difficult problem for IT staff and will likely continue to be a fruitful avenue for attackers unless or until password-based authentication is phased out entirely in favor of another model.</p></div><div class="sect1" title="Online Password Attacks"><div class="titlepage"><div><div><h2 class="title" id="online_password_attacks" style="clear: both">Online Password Attacks</h2></div></div></div><p>Just as we used automated scans to find vulnerabilities, we can use scripts to automatically attempt to log in to services and find valid credentials. We’ll use tools designed for automating online password attacks or guessing passwords until the server responds with a successful login. These tools use a technique called <span class="emphasis"><em>brute forcing</em></span>. Tools that use brute forcing try every possible username and password combination, and given enough time, they <span class="emphasis"><em>will</em></span> find valid credentials.</p><p>The trouble with brute forcing is that as stronger passwords are used, the time it takes to brute-force them moves from hours to years and even beyond your natural lifetime. We can probably find working credentials more easily by feeding educated guesses about the correct passwords into an automated login tool. Dictionary words are easy to remember, so despite the security warnings, many users incorporate them into passwords. Slightly more security-conscious users might put some numbers at the end of their password or maybe even an exclamation point.</p><div class="sect2" title="Wordlists"><div class="titlepage"><div><div><h3 class="title" id="wordlists">Wordlists</h3></div></div></div><p><a class="indexterm" id="iddle1897"/><a class="indexterm" id="iddle2342"/><a class="indexterm" id="iddle2520"/>Before you can use a tool to guess passwords, you need a list of credentials to try. If you don’t know the name of the user account you want to crack, or you just want to crack as many accounts as possible, you can provide a username list for the password-guessing tool to iterate through.</p><div class="sect3" title="User Lists"><div class="titlepage"><div><div><h4 class="title" id="user_lists">User Lists</h4></div></div></div><p>When creating a user list, first try to determine the client’s username scheme. For instance, if we’re trying to break into employee email accounts, figure out the pattern the email addresses follow. Are they <span class="emphasis"><em>firstname.lastname</em></span>, just a first name, or something else?</p><p>You can look for good username candidates on lists of common first or last names. Of course, the guesses will be even more likely to succeed if you can find the names of your target’s actual employees. If a company uses a first initial followed by a last name for the username scheme, and they have an employee named John Smith, <span class="emphasis"><em>jsmith</em></span> is likely a valid username. <a class="xref" href="ch09.xhtml#sample_user_list" title="Example 9-1. Sample user list">Example 9-1</a> shows a very short sample user list. You’d probably want a larger list of users in an actual engagement.</p><div class="example"><a id="sample_user_list"/><div class="example-title">Example 9-1. Sample user list</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat userlist.txt</strong></span>&#13;
georgia&#13;
john&#13;
mom&#13;
james</pre></div></div><p>Once you’ve created your list, save the sample usernames in a text file in Kali Linux, as shown in <a class="xref" href="ch09.xhtml#sample_user_list" title="Example 9-1. Sample user list">Example 9-1</a>. You’ll use this list to perform online password attacks in <a class="xref" href="ch09.xhtml#guessing_usernames_and_passwords_with_hy" title="Guessing Usernames and Passwords with Hydra">Guessing Usernames and Passwords with Hydra</a>.</p></div><div class="sect3" title="Password Lists"><div class="titlepage"><div><div><h4 class="title" id="password_lists">Password Lists</h4></div></div></div><p>In addition to a list of possible users, we’ll also need a password list, as shown in <a class="xref" href="ch09.xhtml#sample_password_list" title="Example 9-2. Sample password list">Example 9-2</a>.</p><div class="example"><a id="sample_password_list"/><div class="example-title">Example 9-2. Sample password list</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cat passwordfile.txt</strong></span>&#13;
password&#13;
Password&#13;
password1&#13;
Password1&#13;
Password123&#13;
password123</pre></div></div><p><a class="indexterm" id="iddle1175"/><a class="indexterm" id="iddle1582"/><a class="indexterm" id="iddle2082"/><a class="indexterm" id="iddle2450"/>Like our username list, this password list is just a very short example (and one that, hopefully, wouldn’t find the correct passwords for too many accounts in the real world). On a real engagement, you should use a much longer wordlist.</p><p>There are many good password lists available on the Internet. Good places to look for wordlists include <span class="emphasis"><em><a class="ulink" href="http://packetstormsecurity.com/Crackers/wordlists/" target="_top">http://packetstormsecurity.com/Crackers/wordlists/</a></em></span> and <span class="emphasis"><em><a class="ulink" href="http://www.openwall.com/wordlists/" target="_top">http://www.openwall.com/wordlists/</a></em></span>. A few password lists are also built into Kali Linux. For example, the <span class="emphasis"><em>/usr/share/wordlists</em></span> directory contains a file called <span class="emphasis"><em>rockyou.txt.gz</em></span>. This is a compressed wordlist. If you unzip the file with the gunzip Linux utility, you’ll have about 140 MB of possible passwords, which should give you a pretty good start. Also, some of the password-cracking tools in Kali come with sample wordlists. For example, the John the Ripper tool (which we’ll use in <a class="xref" href="ch09.xhtml#offline_password_attacks" title="Offline Password Attacks">Offline Password Attacks</a>) includes a wordlist at <span class="emphasis"><em>/usr/share/john/password.lst</em></span>.</p><p>For better results, customize your wordlists for a particular target by including additional words. You can make educated guesses based on information you gather about employees online. Information about spouses, children, pets, and hobbies may put you on the right track. For example, if your target’s CEO is a huge Taylor Swift fan on social media, consider adding keywords related to her albums, her music, or her boyfriends. If your target’s password is <span class="emphasis"><em>TaylorSwift13!</em></span>, you should be able to confirm it using password guessing long before you have to run a whole precompiled wordlist or a brute-force attempt. Another thing to keep in mind is the language(s) used by your target. Many of your pentesting targets may be global.</p><p>In addition to making educated guesses based on information you gather while performing reconnaissance, a tool like the ceWL custom wordlist generator will search a company website for words to add to your wordlist. <a class="xref" href="ch09.xhtml#using_cewl_to_build_custom_wordlists" title="Example 9-3. Using ceWL to build custom wordlists">Example 9-3</a> shows how you might use ceWL to create a wordlist based on the contents of <span class="emphasis"><em><a class="ulink" href="http://www.bulbsecurity.com" target="_top">www.bulbsecurity.com</a></em></span>.</p><div class="example"><a id="using_cewl_to_build_custom_wordlists"/><div class="example-title">Example 9-3. Using ceWL to build custom wordlists</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>cewl --help</strong></span>&#13;
cewl 5.0 Robin Wood (robin@digininja.org) (www.digininja.org)&#13;
&#13;
Usage: cewl [OPTION] ... URL&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
--depth x, -d x: depth to spider to, default 2 ❶&#13;
--min_word_length, -m: minimum word length, default 3 ❷&#13;
--offsite, -o: let the spider visit other sites&#13;
--write, -w file: write the output to the file ❸&#13;
--ua, -u user-agent: useragent to send&#13;
--<span class="emphasis"><em>snip</em></span>--&#13;
URL: The site to spider.&#13;
root@kali:~# <span class="strong"><strong>cewl -w bulbwords.txt -d 1 -m 5 www.bulbsecurity.com</strong></span> ❹</pre></div></div><p><a class="indexterm" id="iddle1233"/><a class="indexterm" id="iddle1601"/>The command <code class="literal">ceWL --help</code> lists ceWL’s usage instructions. Use the <code class="literal">-d</code> (depth) option ❶ to specify how many links ceWL should follow on the target website. If you think that your target has a minimum password-size requirement, you might specify a minimum word length to match with the <code class="literal">-m</code> option ❷. Once you’ve made your choices, output ceWL’s results to a file with the <code class="literal">-w</code> option ❸. For example, to search <span class="emphasis"><em><a class="ulink" href="http://www.bulbsecurity.com" target="_top">www.bulbsecurity.com</a></em></span> to depth <code class="literal">1</code> with minimum word length of <code class="literal">5</code> characters and output the words found to the file <span class="emphasis"><em>bulbwords.txt</em></span>, you would use the command shown at ❹. The resulting file would include all words found on the site that meet your specifications.</p><p>Another method for creating wordlists is producing a list of every possible combination of a given set of characters, or a list of every combination of characters for a specified number of characters. The tool Crunch in Kali will generate these character sets for you. Of course, the more possibilities, the more disk space is required for storage. A very simple example of using Crunch is shown in <a class="xref" href="ch09.xhtml#brute-forcing_a_keyspace_with_crunch" title="Example 9-4. Brute-forcing a keyspace with Crunch">Example 9-4</a>.</p><div class="example"><a id="brute-forcing_a_keyspace_with_crunch"/><div class="example-title">Example 9-4. Brute-forcing a keyspace with Crunch</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>crunch 7 7 AB</strong></span>&#13;
Crunch will now generate the following amount of data: 1024 bytes&#13;
0 MB&#13;
0 GB&#13;
0 TB&#13;
0 PB&#13;
Crunch will now generate the following number of lines: 128&#13;
AAAAAAA&#13;
AAAAAAB&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>This example generates a list of all the possible seven-character combinations of just the characters <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span>. A more useful, but much, much larger example would be entering <code class="literal">crunch 7 8</code>, which would generate a list of all the possible combinations of characters for a string between seven and eight characters in length, using the default Crunch character set of lowercase letters. This technique is known as <span class="emphasis"><em>keyspace brute-forcing</em></span>. While it is not feasible to try every possible combination of characters for a password in the span of your natural life, it is possible to try specific subsets; for instance, if you knew the client’s password policy requires passwords to be at least seven characters long, trying all seven- and eight-character passwords would probably result in cracking success—even among the rare users who did not base their passwords on a dictionary word.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note01"/>Note</h3><p>Developing a solid wordlist or set of wordlists is a constantly evolving process. For the exercises in this chapter, you can use the short sample wordlist we created in <a class="xref" href="ch09.xhtml#sample_password_list" title="Example 9-2. Sample password list">Example 9-2</a>, but as you gain experience in the field, you’ll develop more complex lists that work well on client engagements.</p></div><p>Now let’s see how to use our wordlist to guess passwords for services running on our targets.</p></div></div><div class="sect2" title="Guessing Usernames and Passwords with Hydra"><div class="titlepage"><div><div><h3 class="title" id="guessing_usernames_and_passwords_with_hy">Guessing Usernames and Passwords with Hydra</h3></div></div></div><p><a class="indexterm" id="iddle1488"/><a class="indexterm" id="iddle1896"/><a class="indexterm" id="iddle2348"/>If you have a set of credentials that you’d like to try against a running service that requires a login, you can input them manually one by one or use a tool to automate the process. Hydra is an online password-guessing tool that can be used to test usernames and passwords for running services. (Following the tradition of naming security tools after the victims of Heracles’s labors, Hydra is named for the mythical Greek serpent with many heads.) <a class="xref" href="ch09.xhtml#using_hydra_to_guess_pop3_usernames_and" title="Example 9-5. Using Hydra to guess POP3 usernames and passwords">Example 9-5</a> shows an example of using Hydra for online password guessing.</p><div class="example"><a id="using_hydra_to_guess_pop3_usernames_and"/><div class="example-title">Example 9-5. Using Hydra to guess POP3 usernames and passwords</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>hydra -L userlist.txt -P passwordfile.txt 192.168.20.10 pop3</strong></span>&#13;
Hydra v7.6 (c)2013 by van Hauser/THC &amp; David Maciejak - for legal purposes only&#13;
&#13;
Hydra (http://www.thc.org/thc-hydra) starting at 2015-01-12 15:29:26&#13;
[DATA] 16 tasks, 1 server, 24 login tries (l:4/p:6), ~1 try per task&#13;
[DATA] attacking service pop3 on port 110&#13;
[110][pop3] host: 192.168.20.10   login: georgia   password: password❶&#13;
[STATUS] attack finished for 192.168.20.10 (waiting for children to finish)&#13;
1 of 1 target successfuly completed, 1 valid password found&#13;
Hydra (http://www.thc.org/thc-hydra) finished at 2015-01-12 15:29:48</pre></div></div><p><a class="xref" href="ch09.xhtml#using_hydra_to_guess_pop3_usernames_and" title="Example 9-5. Using Hydra to guess POP3 usernames and passwords">Example 9-5</a> shows how to use Hydra to guess usernames and passwords by running through our username and password files to search for valid POP3 credentials on our Windows XP target. This command uses the <code class="literal">-L</code> flag to specify the username file, the <span class="bolditalic"><code class="literal">-</code></span><code class="literal">P</code> for the password list file, and specifies the protocol <code class="literal">pop3</code>. Hydra finds that user <span class="emphasis"><em>georgia</em></span>’s password is <code class="literal">password</code> at ❶. (Shame on <span class="emphasis"><em>georgia</em></span> for using such an insecure password!)</p><p>Sometimes you’ll know that a specific username exists on a server, and you just need a valid password to go with it. For example, we used the <code class="literal">SMTP VRFY</code> verb to find valid usernames on the SLMail server on the Windows XP target in <a class="xref" href="ch06.xhtml" title="Chapter 6. Finding Vulnerabilities">Chapter 6</a>. As you can see in <a class="xref" href="ch09.xhtml#using_a_specific_username_with_hydra" title="Example 9-6. Using a specific username with Hydra">Example 9-6</a>, we can use the <span class="emphasis"><em><code class="literal">-</code></em></span><code class="literal">l</code> flag instead of <span class="emphasis"><em><code class="literal">-</code></em></span><code class="literal">L</code> to specify one particular username. Knowing that, let’s look for a valid password for user <span class="emphasis"><em>georgia</em></span> on the <code class="literal">pop3</code> server.</p><div class="example"><a id="using_a_specific_username_with_hydra"/><div class="example-title">Example 9-6. Using a specific username with Hydra</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>hydra -l georgia -P passwordfile.txt 192.168.20.10 pop3</strong></span>&#13;
Hydra v7.6 (c)2013 by van Hauser/THC &amp; David Maciejak - for legal purposes only&#13;
[DATA] 16 tasks, 1 server, 24 login tries (l:4/p:6), ~1 try per task&#13;
[DATA] attacking service pop3 on port 110&#13;
[110][pop3] host: 192.168.20.10   login: georgia   password: password❶&#13;
[STATUS] attack finished for 192.168.20.10 (waiting for children to finish)&#13;
1 of 1 target successfuly completed, 1 valid password found&#13;
Hydra (http://www.thc.org/thc-hydra) finished at 2015-01-07 20:22:23</pre></div></div><p>Hydra found <span class="emphasis"><em>georgia</em></span>’s password to be <span class="emphasis"><em>password</em></span> ❶.</p><p>Now, in <a class="xref" href="ch09.xhtml#using_netcat_to_log_in_with_guessed_cred" title="Example 9-7. Using Netcat to log in with guessed credentials">Example 9-7</a>, we’ll use our credentials to read <span class="emphasis"><em>georgia</em></span>’s email.</p><div class="example"><a id="using_netcat_to_log_in_with_guessed_cred"/><div class="example-title">Example 9-7. Using Netcat to log in with guessed credentials</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>nc 192.168.20.10 pop3</strong></span>&#13;
+OK POP3 server xpvictim.com ready &lt;00037.23305859@xpvictim.com&gt;&#13;
<span class="strong"><strong>USER georgia</strong></span>&#13;
+OK georgia welcome here&#13;
<span class="strong"><strong>PASS password</strong></span>&#13;
+OK mailbox for georgia has 0 messages (0 octets)</pre></div></div><p><a class="indexterm" id="iddle1461"/><a class="indexterm" id="iddle1468"/><a class="indexterm" id="iddle1882"/><a class="indexterm" id="iddle1884"/><a class="indexterm" id="iddle1890"/><a class="indexterm" id="iddle1945"/>Specify the <code class="literal">pop3</code> protocol, and provide the username and password when prompted. (Unfortunately, there are no love letters in this particular inbox.) Hydra can perform online password guessing against a range of services. (See its manual page for a complete list.) For example, here we use the credentials we found with Hydra to log in with Netcat.</p><p>Keep in mind that most services can be configured to lock out accounts after a certain number of failed login attempts. There are few better ways to get noticed by a client’s IT staff than suddenly locking out several user accounts. Logins in rapid succession can also tip off firewalls and intrusion-prevention systems, which will get your IP address blocked at the perimeter. Slowing down and randomizing scans can help with this, but there is, of course, a tradeoff: Slower scans will take longer to produce results.</p><p>One way to avoid having your login attempts noticed is to try to guess a password before trying to log in, as you’ll learn in the next section.</p></div></div><div class="sect1" title="Offline Password Attacks"><div class="titlepage"><div><div><h2 class="title" id="offline_password_attacks" style="clear: both">Offline Password Attacks</h2></div></div></div><p>Another way to crack passwords (without being discovered) is to get a copy of the password hashes and attempt to reverse them back to plaintext passwords. This is easier said than done because hashes are designed to be the product of a one-way hash function: Given an input, you can calculate the output using the hash function, but given the output, there is no way to reliably determine the input. Thus, if a hash is compromised, there should be no way to calculate the plaintext password. We can, however, guess a password, hash it with the one-way hash function, and compare the results to the known hash. If the two hashes are the same, we’ve found the correct password.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note02"/>Note</h3><p>As you’ll learn in <a class="xref" href="ch09.xhtml#lm_vsdot_ntlm_hashing_algorithms" title="LM vs. NTLM Hashing Algorithms">LM vs. NTLM Hashing Algorithms</a>, not all password hashing systems have stood the test of time. Some have been cracked and are no longer considered secure. In these cases, regardless of the strength of the password chosen, an attacker with access to the hashes will be able to recover the plaintext password in a reasonable amount of time.</p></div><p>Of course, it’s even better if you can get access to passwords in plaintext and save yourself the trouble of trying to reverse the cryptography, but often the passwords you encounter will be hashed in some way. In this section we’ll focus on finding and reversing password hashes. If you stumble upon a program configuration file, database, or other file that stores passwords in plaintext, all the better.</p><p>But before we can try to crack password hashes, we have to find them. We all hope that the services that store our passwords do a good job of <a class="indexterm" id="iddle1458"/><a class="indexterm" id="iddle1467"/><a class="indexterm" id="iddle1889"/><a class="indexterm" id="iddle2098"/><a class="indexterm" id="iddle2467"/>protecting them, but that’s never a given. It only takes one exploitable flaw or a user who falls victim to a social-engineering attack (discussed in <a class="xref" href="ch11.xhtml" title="Chapter 11. Social Engineering">Chapter 11</a>) to bring down the whole house of cards. You’ll find plenty of password hashes lying around sites like Pastebin, remnants from past security breaches.</p><p>In <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>, we gained access to some password hashes on the Linux and Windows XP targets. Having gained a Meterpreter session with system privileges on the Windows XP system via the <span class="emphasis"><em>windows/smb/ms08_067_netapi</em></span> Metasploit module, we can use the <code class="literal">hashdump</code> Meterpreter command to print the hashed Windows passwords, as shown in <a class="xref" href="ch09.xhtml#dumping_password_hashes_in_meterpreter" title="Example 9-8. Dumping password hashes in Meterpreter">Example 9-8</a>.</p><div class="example"><a id="dumping_password_hashes_in_meterpreter"/><div class="example-title">Example 9-8. Dumping password hashes in Meterpreter</div><div class="example-contents"><pre class="programlisting">meterpreter &gt; <span class="strong"><strong>hashdump</strong></span>&#13;
Administrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::&#13;
georgia:1003:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::&#13;
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::&#13;
HelpAssistant:1000:df40c521ef762bb7b9767e30ff112a3c:938ce7d211ea733373bcfc3e6fbb3641:::&#13;
secret:1004:e52cac67419a9a22664345140a852f61:58a478135a93ac3bf058a5ea0e8fdb71:::&#13;
SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:bc48640a0fcb55c6ba1c9955080a52a8:::</pre></div></div><p>Save the output of the hashdump to a file called <span class="emphasis"><em>xphashes.txt</em></span>, which we will use in <a class="xref" href="ch09.xhtml#john_the_ripper" title="John the Ripper">John the Ripper</a>.</p><p>In <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a> we also downloaded backups of the SAM and SYSTEM hives using the local file inclusion issue in Zervit 0.4 on the Windows XP system. We used this same issue to download the configuration file for the FileZilla FTP server, which contained passwords hashed with the MD5 algorithm. On the Linux target, the Vsftpd smiley-face backdoor gave us root privileges, and thus we can access to the file <span class="emphasis"><em>/etc/shadow</em></span>, which stores Linux password hashes. We saved the password for user <span class="emphasis"><em>georgia</em></span> to the file <span class="emphasis"><em>linuxpasswords.txt</em></span>.</p><div class="sect2" title="Recovering Password Hashes from a Windows SAM File"><div class="titlepage"><div><div><h3 class="title" id="recovering_password_hashes_from_a_window">Recovering Password Hashes from a Windows SAM File</h3></div></div></div><p>The SAM file stores hashed Windows passwords. Though we were able to use Meterpreter to dump the password hashes from the Windows XP system (as shown previously), sometimes you’ll be able to get only the SAM file.</p><p>We weren’t able to get access to the primary SAM file through the Zervit 0.4 vulnerability, but we were able to download a backup copy from the <span class="emphasis"><em>C:\Windows\repair</em></span> directory using a local file-inclusion vulnerability. But when we try to read the SAM file (as shown in <a class="xref" href="ch09.xhtml#viewing_the_sam_file" title="Example 9-9. Viewing the SAM file">Example 9-9</a>), we don’t see any password hashes.</p><div class="example"><a id="viewing_the_sam_file"/><div class="example-title">Example 9-9. Viewing the SAM file</div><div class="example-contents"><pre class="programlisting">root@bt:~# <span class="strong"><strong>cat sam</strong></span>&#13;
regf     P P5gfhbinDDDDnk,DuDDDDD DDDD DDDDDDDDDxDDDDSAMXDDDskx x D DpDμ\μ?&#13;
?   μ μ&#13;
                                  DDDDnk LDDDD DBDDDD Dx DDDDDSAMDDDDskxx7d&#13;
DHXμ4μ?          DDDDvk D CPDDD D  μDxDμD0Dμ    DμDD 4μ1   ?         DDDDD&#13;
DDDDlf   SAMDDDDnk DuDDDDD   H#DDDD Px DDDDDomainsDDDDvkDDDDD8lf DDomaDDDDnk&#13;
\DDJDDD DDDDDD0x DDDD( AccountDDDDvk DD&#13;
--snip--</pre></div></div><p><a class="indexterm" id="iddle1113"/><a class="indexterm" id="iddle1120"/><a class="indexterm" id="iddle1459"/><a class="indexterm" id="iddle2099"/><a class="indexterm" id="iddle2274"/>The SAM file is obfuscated because the Windows Syskey utility encrypts the password hashes inside the SAM file with 128-bit Rivest Cipher 4 (RC4) to provide additional security. Even if an attacker or pentester can gain access to the SAM file, there’s a bit more work to do before we can recover the password hashes. Specifically, we need a key to reverse the encrypted hashes.</p><p>The encryption key for the Syskey utility is called the <span class="emphasis"><em>bootkey</em></span>, and it’s stored in the Windows SYSTEM file. You’ll find a copy of the SYSTEM file in the <span class="emphasis"><em>C:\Windows\repair</em></span> directory where we found the backup SAM file. We can use a tool in Kali called Bkhive to extract the Syskey utility’s bootkey from the SYSTEM file so we can decrypt the hashes, as shown in <a class="xref" href="ch09.xhtml#using_bkhive_to_extract_the_bootkey" title="Example 9-10. Using Bkhive to extract the bootkey">Example 9-10</a>.</p><div class="example"><a id="using_bkhive_to_extract_the_bootkey"/><div class="example-title">Example 9-10. Using Bkhive to extract the bootkey</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>bkhive system xpkey.txt</strong></span>&#13;
bkhive 1.1.1 by Objectif Securite&#13;
http://www.objectif-securite.ch&#13;
original author: ncuomo@studenti.unina.it&#13;
&#13;
Root Key : $$$PROTO.HIV&#13;
Default ControlSet: 001&#13;
Bootkey: 015777ab072930b22020b999557f42d5</pre></div></div><p>Here we use Bkhive to extract the bootkey by passing in the SYSTEM file <span class="emphasis"><em>system</em></span> (the file we downloaded from the repair directory using the Zervit 0.4 directory traversal) as the first argument and extracting the file to <span class="emphasis"><em>xpkey.txt</em></span>. Once we have the bootkey, we can use Samdump2 to retrieve the password hashes from the SAM file, as shown in <a class="xref" href="ch09.xhtml#using_samdump2_to_recover_windows_hashes" title="Example 9-11. Using Samdump2 to recover Windows hashes">Example 9-11</a>. Pass Samdump2 the location of the SAM file and the bootkey from Bkhive as arguments, and it will use the bootkey to decrypt the hashes.</p><div class="example"><a id="using_samdump2_to_recover_windows_hashes"/><div class="example-title">Example 9-11. Using Samdump2 to recover Windows hashes</div><div class="example-contents"><pre class="programlisting">root@kali:~# <span class="strong"><strong>samdump2 sam xpkey.txt</strong></span>&#13;
samdump2 1.1.1 by Objectif Securite&#13;
http://www.objectif-securite.ch&#13;
original author: ncuomo@studenti.unina.it&#13;
&#13;
Root Key : SAM&#13;
Administrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::&#13;
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::&#13;
HelpAssistant:1000:df40c521ef762bb7b9767e30ff112a3c:938ce7d211ea733373bcfc3e6fbb3641:::&#13;
SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:bc48640a0fcb55c6ba1c9955080a52a8:::</pre></div></div><p>Now compare these hashes to those found with the <code class="literal">hashdump</code> command in an active Meterpreter session from <a class="xref" href="ch09.xhtml#dumping_password_hashes_in_meterpreter" title="Example 9-8. Dumping password hashes in Meterpreter">Example 9-8</a>. (A Meterpreter session with sufficient privileges can dump password hashes on the fly without requiring us to download the SAM and SYSTEM files.) Notice that our hash list in <a class="xref" href="ch09.xhtml#using_samdump2_to_recover_windows_hashes" title="Example 9-11. Using Samdump2 to recover Windows hashes">Example 9-11</a> lacks entries for the users <span class="emphasis"><em>georgia</em></span> or <span class="emphasis"><em>secret</em></span>. What happened?</p><p>When using the Zervit directory traversal, we weren’t able to access the main SAM file at <span class="emphasis"><em>C:\Windows\System32\config</em></span> and instead downloaded a backup from <span class="emphasis"><em>C:\Windows\repair\sam</em></span>. These users must have been created <a class="indexterm" id="iddle1463"/><a class="indexterm" id="iddle1886"/><a class="indexterm" id="iddle2476"/>after the SAM file backup was created. We do have a password hash for the <span class="emphasis"><em>Administrator</em></span> user, though. Though not complete or fully up-to-date, we may still be able to use cracked hashes from this backup SAM to log in to the systems.</p><p>Now let’s look at another way to access password hashes.</p></div><div class="sect2" title="Dumping Password Hashes with Physical Access"><div class="titlepage"><div><div><h3 class="title" id="dumping_password_hashes_with_physical_ac">Dumping Password Hashes with Physical Access</h3></div></div></div><p>On some engagements, you’ll actually have physical access to user machines, with so-called physical attacks in scope. While having physical access may not appear very useful at first, you may be able to access the password hashes by restarting a system using a Linux Live CD to bypass security controls. (We’ll use a Kali ISO image, though other Linux Live CDs such as Helix or Ubuntu will work. We used a prebuilt Kali virtual machine in <a class="xref" href="ch01.xhtml" title="Chapter 1. Setting Up Your Virtual Lab">Chapter 1</a>. To get a standalone ISO of Kali, go to <span class="emphasis"><em><a class="ulink" href="http://www.kali.org" target="_top">http://www.kali.org</a></em></span>.) When you boot a machine with a Live CD, you can mount the internal hard disk and gain access to all files, including the SAM and SYSTEM files. (When Windows boots, there are certain security controls in place to stop users from accessing the SAM file and dumping password hashes, but these aren’t active when the filesystem is loaded in Linux.)</p><p>Our Windows 7 virtual machine, with its solid external security posture, has been a bit neglected in these last few chapters. Let’s dump its hashes using a physical attack. First, we’ll point our virtual machine’s optical drive to a Kali ISO file, as shown in <a class="xref" href="ch09.xhtml#setting_our_windows_7_virtual_machine_to" title="Figure 9-1. Setting our Windows 7 virtual machine to boot from the Kali ISO file">Figure 9-1</a> (for VMware Fusion). In VMware Player, highlight your Windows 7 virtual machine, right-click it and choose <span class="strong"><strong>Settings</strong></span>, then choose <span class="strong"><strong>CD/DVD (SATA)</strong></span> and point to the ISO in the Use ISO Image field on the right side of the page.</p><div class="figure"><a id="setting_our_windows_7_virtual_machine_to"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00102"/><img alt="Setting our Windows 7 virtual machine to boot from the Kali ISO file" src="httpatomoreillycomsourcenostarchimages2030394.png.jpg"/></div></div><div class="figure-title">Figure 9-1. Setting our Windows 7 virtual machine to boot from the Kali ISO file</div></div><p>By default, VMware will boot up the virtual machine so quickly that it will be difficult to change the BIOS settings to boot from the CD/DVD drive instead of the hard disk. To fix this, we’ll add a line to the VMware configuration file (<span class="emphasis"><em>.vmx</em></span>) to delay the boot process at the BIOS screen for a few seconds.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><a class="indexterm" id="iddle1118"/><a class="indexterm" id="iddle1731"/><a class="indexterm" id="iddle2381"/><a class="indexterm" id="iddle2400"/>On your host machine, browse to where you saved your virtual machines. Then, in the folder for the Windows 7 target, find the <span class="emphasis"><em>.vmx</em></span> configuration file, and open it in a text editor. The configuration file should look similar to <a class="xref" href="ch09.xhtml#vmware_configuration_file_left_parenthes" title="Example 9-12. VMware configuration file (.vmx)">Example 9-12</a>.</p><div class="example"><a id="vmware_configuration_file_left_parenthes"/><div class="example-title">Example 9-12. VMware configuration file (.vmx)</div><div class="example-contents"><pre class="programlisting">.encoding = "UTF-8"&#13;
config.version = "8"&#13;
virtualHW.version = "9"&#13;
vcpu.hotadd = "TRUE"&#13;
scsi0.present = "TRUE"&#13;
scsi0.virtualDev = "lsilogic"&#13;
--<span class="emphasis"><em>snip</em></span>--</pre></div></div></li><li class="listitem"><p>Add the line <span class="strong"><strong><code class="literal">bios.bootdelay = 3000</code></strong></span> anywhere in the file. This tells the virtual machine to delay booting for 3000 ms, or three seconds, enough time for us to change the boot options.</p></li><li class="listitem"><p>Save the <span class="emphasis"><em>.vmx</em></span> file, and restart the Windows 7 target. Once you can access the BIOS, choose to boot from the CD drive. The virtual machine should start the Kali ISO. Even though we’re booted into Kali, we can mount the Windows hard disk and access files, bypassing the security features of the Windows operating system.</p></li></ol></div><p><a class="xref" href="ch09.xhtml#dumping_windows_hashes_with_a_linux_live" title="Example 9-13. Dumping Windows hashes with a Linux Live CD">Example 9-13</a> shows how to mount the file system and dump the password hashes.</p><div class="example"><a id="dumping_windows_hashes_with_a_linux_live"/><div class="example-title">Example 9-13. Dumping Windows hashes with a Linux Live CD</div><div class="example-contents"><pre class="programlisting">root@kali:# ❶<span class="strong"><strong>mkdir -p /mnt/sda1</strong></span>&#13;
root@kali:# ❷<span class="strong"><strong>mount /dev/sda1 /mnt/sda1</strong></span>&#13;
root@kali:# ❸<span class="strong"><strong>cd /mnt/sda1/Windows/System32/config/</strong></span>&#13;
root@kali:/mnt/sda1/Windows/System32/config  <span class="strong"><strong>bkhive SYSTEM out</strong></span>&#13;
root@kali:/mnt/sda1/Windows/System32/config  <span class="strong"><strong>samdump2 SAM out</strong></span>&#13;
samdump2 1.1.1 by Objectif Securite&#13;
http://www.objectif-securite.ch&#13;
original author: ncuomo@studenti.unina.it&#13;
&#13;
Root Key : CMI-CreateHive{899121E8-11D8-41B6-ACEB-301713D5ED8C}&#13;
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::&#13;
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::&#13;
Georgia Weidman:1000:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b75B6c:::</pre></div></div><p>We create a directory where we can mount our Windows filesystem with the <code class="literal">mkdir</code> command at ❶. Next, we use <code class="literal">mount</code> ❷ to mount the Windows filesystem (<span class="emphasis"><em>/dev/sda1</em></span>) in the newly created directory (<span class="emphasis"><em>/mnt/sda1</em></span>), which means that the target’s C drive is effectively at <span class="emphasis"><em>/mnt/sda1</em></span>. The SAM and SYSTEM files in Windows are in the <span class="emphasis"><em>C:\Windows\System32\config</em></span> directory, so we change directories to <span class="emphasis"><em>/mnt/sda1/Windows/System32/config</em></span> to access these files using <a class="indexterm" id="iddle1136"/><a class="indexterm" id="iddle1465"/><a class="indexterm" id="iddle1604"/><a class="indexterm" id="iddle1632"/><a class="indexterm" id="iddle1851"/><a class="indexterm" id="iddle1888"/><code class="literal">cd</code> ❸, at which point we can use Samdump2 and Bkhive against the SAM and SYSTEM files without first saving these files and moving them to our Kali system.</p><p>Once again we’ve managed to get access to password hashes. We now have hashes for our Windows XP target, our Windows 7 target, our Linux target, and the FileZilla FTP server on the Windows XP target.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note03"/>Note</h3><p>In <a class="xref" href="ch13.xhtml" title="Chapter 13. Post Exploitation">Chapter 13</a>, we’ll explore some tricks for using password hashes to authenticate without the need for access to the plaintext passwords, but usually, in order to use these hashes, we’ll need to reverse the cryptographic hash algorithms and get the plaintext passwords. The difficulty of this depends on the password-hashing algorithm used as well as the strength of the password used.</p></div></div><div class="sect2" title="LM vs. NTLM Hashing Algorithms"><div class="titlepage"><div><div><h3 class="title" id="lm_vsdot_ntlm_hashing_algorithms">LM vs. NTLM Hashing Algorithms</h3></div></div></div><p><a class="xref" href="ch09.xhtml#dumping_windows_hashes_with_a_li-id00026" title="Example 9-14. Dumping Windows hashes with a Linux Live CD">Example 9-14</a> compares the two password hash entries. The first one belongs to the <span class="emphasis"><em>Administrator</em></span> account on Windows XP, which we found with <code class="literal">hashdump</code> in Meterpreter, and the second is Georgia Weidman’s account from Windows 7, which we found with physical access in the previous section.</p><div class="example"><a id="dumping_windows_hashes_with_a_li-id00026"/><div class="example-title">Example 9-14. Dumping Windows hashes with a Linux Live CD</div><div class="example-contents"><pre class="programlisting">Administrator❶:500❷:e52cac67419a9a224a3b108f3fa6cb6d❸:8846f7eaee8fb117ad06bdd830b7586c❹&#13;
Georgia Weidman❶:1000❷:aad3b435b51404eeaad3b435b51404ee❸:8846f7eaee8fb117ad06bdd830b7586c❹</pre></div></div><p>The first field in the hashes is the username ❶; the second is the user ID ❷; the third is the password hash in LAN Manager (LM) format ❸; and the fourth is the NT LAN Manager (NTLM) hash ❹. LM Hash was the primary way to hash passwords on Microsoft Windows up to Windows NT, but it’s a cryptographically unsound method that makes it possible to discover the correct plaintext password for an LM hash, regardless of a password’s length and complexity. Microsoft introduced NTLM hashing to replace LM hash, but on Windows XP, passwords are stored in both LM and NTLM formats by default. (Windows 7 opts exclusively for the more secure NTLM hash.)</p><p>In the hashes in <a class="xref" href="ch09.xhtml#dumping_windows_hashes_with_a_li-id00026" title="Example 9-14. Dumping Windows hashes with a Linux Live CD">Example 9-14</a>, because both passwords are the string <span class="emphasis"><em>password</em></span>, the NTLM hash entries for each account are identical, but the LM hash fields are different. The first entry has the value <code class="literal">e52cac67419a9a224a3b108f3fa6cb6d</code>, whereas the Windows 7 entry has <code class="literal">aad3b435b51404eeaad3b435b51404ee</code>, which is LM hash-speak for empty. The inclusion of the LM hash entry will make cracking the hashes much simpler. In fact, any LM-hashed password can be brute-forced in minutes to hours. In contrast, our ability to crack the NTLM hashes will depend on both our ability to guess and the length and complexity of the password. If the hashing function is cryptographically sound, it could take years, decades, or more than your lifetime to try every possible password.</p></div><div class="sect2" title="The Trouble with LM Password Hashes"><div class="titlepage"><div><div><h3 class="title" id="trouble_with_lm_password_hashes">The Trouble with LM Password Hashes</h3></div></div></div><p><a class="indexterm" id="iddle1605"/><a class="indexterm" id="iddle1633"/>When you see LM hashes on a pentest, you can be sure that the plaintext password is recoverable from the password hash. However, one-way hash functions can’t be reversed. Complex math is used to develop algorithms that make it impossible to discover the original plaintext password value that was hashed, given the password hash. But we <span class="emphasis"><em>can</em></span> run a plaintext password guess through the cryptographic hashing function and compare the results to the hash we’re trying to crack; if they’re the same, we’ve found the correct password.</p><p>The following issues contribute to the insecurity of LM hashes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Passwords are truncated at 14 characters.</p></li><li class="listitem"><p>Passwords are converted to all uppercase.</p></li><li class="listitem"><p>Passwords of fewer than 14 characters are null-padded to 14 characters.</p></li><li class="listitem"><p>The 14-character password is broken into two seven-character passwords that are hashed separately.</p></li></ul></div><p>Why are these characteristics so significant? Say we start with a complex, strong password like this:</p><a id="pro_id00129"/><pre class="programlisting">T3LF23!+?sRty$J</pre><p>This password has 15 characters from four classes, including lowercase letters, uppercase letters, numbers, and symbols, and it’s not based on a dictionary word. However, in the LM hash algorithm, the password is truncated to 14 characters like this:</p><a id="pro_id00130"/><pre class="programlisting">T3LF23!+?sRty$</pre><p>Then the lowercase letters are changed to uppercase:</p><a id="pro_id00131"/><pre class="programlisting">T3LF23!+?SRTY$</pre><p>Next, the password is split into two seven-character parts. The two parts are then used as keys to encrypt the static string <code class="literal">KGS!@#$%</code> using the Data Encryption Standard (DES) encryption algorithm:</p><a id="pro_id00132"/><pre class="programlisting">T3LF23!     +?SRTY$</pre><p>The resulting eight-character ciphertexts from the encryption are then concatenated to make the LM hash.</p><p>To crack an LM hash, we just need to find seven characters, all uppercase, with perhaps some numbers and symbols. Modern computing hardware can try every possible one- to seven-character combination, encrypt the string <code class="literal">KGS!@#$%</code>, and compare the resulting hash to a given value in a matter of minutes to hours.</p></div><div class="sect2" title="John the Ripper"><div class="titlepage"><div><div><h3 class="title" id="john_the_ripper">John the Ripper</h3></div></div></div><p><a class="indexterm" id="iddle1138"/><a class="indexterm" id="iddle1580"/><a class="indexterm" id="iddle1852"/><a class="indexterm" id="iddle1892"/><a class="indexterm" id="iddle2343"/><a class="indexterm" id="iddle2544"/>One of the more popular tools for cracking passwords is John the Ripper. The default mode for John the Ripper is brute forcing. Because the set of possible plaintext passwords in LM hash is so limited, brute forcing is a viable method for cracking any LM hash in a reasonable amount of time, even with our Kali virtual machine, which has limited CPU power and memory.</p><p>For example, if we save the Windows XP hashes we gathered earlier in this chapter to a file called <span class="emphasis"><em>xphashes.txt</em></span>, then feed them to John the Ripper like this, we find that John the Ripper can run through the entire set of possible passwords and come up with the correct answer, as shown in <a class="xref" href="ch09.xhtml#cracking_lm_hashes_with_john_the_ripper" title="Example 9-15. Cracking LM hashes with John the Ripper">Example 9-15</a>.</p><div class="example"><a id="cracking_lm_hashes_with_john_the_ripper"/><div class="example-title">Example 9-15. Cracking LM hashes with John the Ripper</div><div class="example-contents"><pre class="programlisting">root@kali: <span class="strong"><strong>john xphashes.txt</strong></span>&#13;
Warning: detected hash type "lm", but the string is also recognized as "nt"&#13;
Use the "--format=nt" option to force loading these as that type instead&#13;
Loaded 10 password hashes with no different salts (LM DES [128/128 BS SSE2])&#13;
                 (SUPPORT_388945a0)&#13;
PASSWOR          (secret:1)&#13;
                 (Guest)&#13;
PASSWOR          (georgia:1)&#13;
PASSWOR          (Administrator:1)&#13;
D                (georgia:2)&#13;
D                (Administrator:2)&#13;
D123             (secret:2)</pre></div></div><p>John the Ripper cracks the seven-character password hashes. In <a class="xref" href="ch09.xhtml#cracking_lm_hashes_with_john_the_ripper" title="Example 9-15. Cracking LM hashes with John the Ripper">Example 9-15</a>, we see that <span class="emphasis"><em>PASSWOR</em></span> is the first half of the user <span class="emphasis"><em>secret</em></span>’s password. Likewise, it’s the first half of the password for <span class="emphasis"><em>georgia</em></span> and <span class="emphasis"><em>Administrator</em></span>. The second half of <span class="emphasis"><em>secret</em></span>’s password is <span class="emphasis"><em>D123</em></span>, and <span class="emphasis"><em>georgia</em></span> and <span class="emphasis"><em>Administrator</em></span>’s are <span class="emphasis"><em>D</em></span>. Thus, the complete plaintext of the LM-hashed passwords are <span class="emphasis"><em>PASSWORD</em></span> for <span class="emphasis"><em>georgia</em></span> and <span class="emphasis"><em>Administrator</em></span> and <span class="emphasis"><em>PASSWORD123</em></span> for <span class="emphasis"><em>secret</em></span>. The LM hash doesn’t tell us the correct case for a password, and if you try logging in to the Windows XP machine as <span class="emphasis"><em>Administrator</em></span> or <span class="emphasis"><em>georgia</em></span> with the password <span class="emphasis"><em>PASSWORD</em></span> or the account <span class="emphasis"><em>secret</em></span> with <span class="emphasis"><em>PASSWORD123</em></span>, you will get a login error because LM hash does not take into account the correct case of the letters in the password.</p><p>To find out the correct case of the password, we need to look at the fourth field of the NTLM hash. John the Ripper noted in the example in <a class="xref" href="ch09.xhtml#cracking_lm_hashes_with_john_the_ripper" title="Example 9-15. Cracking LM hashes with John the Ripper">Example 9-15</a> that NTLM hashes were also present, and you can use the flag <code class="literal">--format=nt</code> to force John the Ripper to use those hashes (we don’t have LM hashes for Windows 7, so we will have to crack Windows 7 passwords with a wordlist since brute forcing the NTLM hashes would likely take too long).</p><p>Cracking Windows NTLM hashes is nowhere near as easy as cracking LM ones. Although a five-character NTLM password that uses only lowercase letters and no other complexity could be brute-forced as quickly as an LM hash, a 30-character NTLM password with lots of complexity could <a class="indexterm" id="iddle1464"/><a class="indexterm" id="iddle1887"/><a class="indexterm" id="iddle2481"/><a class="indexterm" id="iddle2487"/>take many years to crack. Trying every possible character combination of any length, hashing it, and comparing it to a value could go on forever until we happened to stumble upon the correct value (only to find out that the user has since changed his or her password).</p><p>Instead of attempting to brute-force passwords, we can use wordlists containing known passwords, common passwords, dictionary words, combinations of dictionary words padded with numbers and symbols at the end, and so on. (We’ll see an example of using a wordlist with John the Ripper in <a class="xref" href="ch09.xhtml#cracking_linux_passwords" title="Cracking Linux Passwords">Cracking Linux Passwords</a>).</p><div class="sidebar"><a id="real-world_example"/><div class="sidebar-title">A Real-World Example</div><p>Legacy password hashing once made all the difference on one of my pentests. The domain controller was Windows Server 2008, with a strong security posture. The workstations throughout the enterprise were reasonably secure, too, having recently been upgraded to fully patched Windows 7 systems. There was, however, one promising light in the dark: a Windows 2000 box that was missing several security patches. I was able to quickly gain system privileges on the machine using Metasploit.</p><p>The trouble was that, while on paper, the penetration test was now a success, compromising the machine had gained me next to nothing. The system contained no sensitive files, and it was the only machine on this particular network, isolated from the new, updated Windows domain. It had all the trappings of a domain controller, except it had no clients. All of the other machines in the environment were members of the new Windows 2008 domain controller’s domain. Though technically I was now a domain administrator, I was no further along on the pentest than I was before I found the Windows 2000 machine.</p><p>Since this was the domain controller, the domain user password hashes were included locally. Windows 2000, like Windows XP, stored the LM hashes of passwords. The client’s old domain administrator password was strong; it had about 14 characters; included uppercase letters, lowercase letters, numbers, and symbols; and was not based on a dictionary word. Fortunately, because it was LM hashed, I was able to get the password back in a matter of minutes.</p><p>What do you think the domain administrator’s password was on the new domain? You guessed it. It was the same as the domain administrator’s password on the old domain. The Windows 2000 box had not been used in over six months, but it was still running, and it used an insecure hashing algorithm. Also, the client wasn’t changing their passwords regularly. These two things combined to bring down what was otherwise a strong security posture. I was able to access every system in the environment just by logging in with the domain administrator password I found on the compromised Windows 2000 system.</p></div></div><div class="sect2" title="Cracking Linux Passwords"><div class="titlepage"><div><div><h3 class="title" id="cracking_linux_passwords">Cracking Linux Passwords</h3></div></div></div><p><a class="indexterm" id="iddle1137"/><a class="indexterm" id="iddle1200"/><a class="indexterm" id="iddle1343"/><a class="indexterm" id="iddle1583"/><a class="indexterm" id="iddle1620"/><a class="indexterm" id="iddle1672"/><a class="indexterm" id="iddle1893"/>We can also use John the Ripper against the Linux password hashes we dumped after exploiting the Vsftpd server backdoor in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>, as shown in <a class="xref" href="ch09.xhtml#cracking_linux_hashes_with_john_the_ripp" title="Example 9-16. Cracking Linux hashes with John the Ripper">Example 9-16</a>.</p><div class="example"><a id="cracking_linux_hashes_with_john_the_ripp"/><div class="example-title">Example 9-16. Cracking Linux hashes with John the Ripper</div><div class="example-contents"><pre class="programlisting">root@kali# <span class="strong"><strong>cat linuxpasswords.txt</strong></span>&#13;
georgia:$1$CNp3mty6$lRWcT0/PVYpDKwyaWWkSg/:15640:0:99999:7:::&#13;
root@kali# <span class="strong"><strong>johnlinuxpasswords.txt --wordlist=passwordfile.txt</strong></span>&#13;
Loaded 1 password hash (FreeBSD MD5 [128/128 SSE2 intrinsics 4x])&#13;
password         (georgia)&#13;
guesses: 1  time: 0:00:00:00 DONE (Sun Jan 11 05:05:31 2015)  c/s: 100&#13;
trying: password - Password123</pre></div></div><p>User <span class="emphasis"><em>georgia</em></span> has an MD5 hash (we can tell from the <code class="literal">$1$</code> at the beginning of the password hash). MD5 can’t be brute-forced in a reasonable amount of time. Instead, we use a wordlist with the <code class="literal">--wordlist</code> option in John the Ripper. John the Ripper’s success at cracking the password depends on the inclusion of the correct password in our wordlist.</p><div class="sidebar"><a id="mangling_wordlists_with_john_the_ripper"/><div class="sidebar-title">Mangling Wordlists with John the Ripper</div><p>When required by a password policy to include a number and/or a symbol in a password, many users will just tack them on to the end of a dictionary word. Using John the Ripper’s rules functionality, we can catch this and other common mutations that may slip by a simple wordlist. Open the John the Ripper configuration file at <span class="emphasis"><em>/etc/john/john.conf</em></span> in an editor and search for <span class="emphasis"><em>List.Rules:Wordlist</em></span>. Beneath this heading, you can add mangling rules for the wordlist. For example, the rule <code class="literal">$[0-9]$[0-9]$[0-9]</code> will add three numbers to the end of each word in the wordlist. You can enable rules in John the Ripper by using the flag <code class="literal">--rules</code> at the command line. More information on writing your own rules can be found at <span class="emphasis"><em><a class="ulink" href="http://www.openwall.com/john/doc/RULES.shtml" target="_top">http://www.openwall.com/john/doc/RULES.shtml</a></em></span>.</p></div></div><div class="sect2" title="Cracking Configuration File Passwords"><div class="titlepage"><div><div><h3 class="title" id="cracking_configuration_file_passwords">Cracking Configuration File Passwords</h3></div></div></div><p>Finally, let’s try to crack the MD5 hashed passwords we found in the FileZilla FTP server configuration file we downloaded with the Zervit 0.4 file inclusion vulnerability. As you’ll see, sometimes we don’t even need to crack a password hash. For example, try entering the hash for the user <span class="emphasis"><em>georgia</em></span>, <span class="emphasis"><em>5f4dcc3b5aa765d61d8327deb882cf99</em></span>, into a search engine. The first few hits confirm that <span class="emphasis"><em>georgia</em></span>’s password is <span class="emphasis"><em>password</em></span>. Additionally, searching tells us that the account <span class="emphasis"><em>newuser</em></span> is created when a FileZilla FTP server is installed with the password <span class="emphasis"><em>wampp</em></span>.</p><p><a class="indexterm" id="iddle1421"/><a class="indexterm" id="iddle1466"/><a class="indexterm" id="iddle1895"/><a class="indexterm" id="iddle1900"/><a class="indexterm" id="iddle1947"/><a class="indexterm" id="iddle2035"/><a class="indexterm" id="iddle2043"/><a class="indexterm" id="iddle2426"/><a class="indexterm" id="iddle2482"/>Now try logging in to the Windows XP target’s FTP server with these credentials. Sure enough, login is successful. The administrator of this system forgot to change the default password for the built-in FTP account. If we were not able to recover the plaintext passwords this easily, we could again use John the Ripper with a wordlist, as discussed previously.</p></div><div class="sect2" title="Rainbow Tables"><div class="titlepage"><div><div><h3 class="title" id="rainbow_tables">Rainbow Tables</h3></div></div></div><p>Rather than taking a wordlist, hashing each entry with the relevant algorithm, and comparing the resulting hash to the value to be cracked, we can speed up this process considerably by having our wordlist prehashed. This, of course, will take storage space—more with longer hash lists, and approaching infinity as we try to store every possible password hash value for brute forcing.</p><p>A set of precomputed hashes is known as a <span class="emphasis"><em>rainbow table</em></span>. Rainbow tables typically hold every possible hash entry for a given algorithm up to a certain length with a limited character set. For example, you may have a rainbow table for MD5 hashes that contains all entries that are all lowercase letters and numbers with lengths between one and nine. This table is about 80 GB—not so bad with today’s price of storage, but keep in mind this is only a very limited amount of the possible keyspace for MD5.</p><p>Given its limited keyspace (discussed previously), an LM hash appears to be an ideal candidate for using rainbow tables. A full set of LM hash rainbow tables is about 32 GB.</p><p>You can download pregenerated sets of hashes from <span class="emphasis"><em><a class="ulink" href="http://project-rainbowcrack.com/table.htm" target="_top">http://project-rainbowcrack.com/table.htm</a></em></span>. The tool Rcrack in Kali can be used to sift through the rainbow tables for the correct plaintext.</p></div><div class="sect2" title="Online Password-Cracking Services"><div class="titlepage"><div><div><h3 class="title" id="online_password-cracking_services">Online Password-Cracking Services</h3></div></div></div><p>The current hip thing to do in IT is to move things to the cloud, and password cracking is no different. By leveraging multiple high-spec machines, you can get faster, more comprehensive results than you could with just a virtual machine on your laptop. You can, of course, set up up your own high-powered machines in the cloud, create your own wordlists, and so on, but there are also online services that will take care of this for you for a fee. For example, <span class="emphasis"><em><a class="ulink" href="https://www.cloudcracker.com/" target="_top">https://www.cloudcracker.com/</a></em></span> can crack NTLM Windows hashes, SHA-512 for Linux, WPA2 handshakes for wireless, and more. You simply upload your password hash file, and the cracker does the rest.</p></div></div><div class="sect1" title="Dumping Plaintext Passwords from Memory with Windows Credential Editor"><div class="titlepage"><div><div><h2 class="title" id="dumping_plaintext_passwords_from_memory" style="clear: both">Dumping Plaintext Passwords from Memory with Windows Credential Editor</h2></div></div></div><p>Why bother cracking password hashes if we can get access to plaintext passwords? If we have access to a Windows system, in some cases we can pull plaintext passwords directly from memory. One tool with this functionality is the Windows Credential Editor (WCE). We can upload this tool to an exploited target system, and it will pull plaintext passwords from the Local <a class="indexterm" id="iddle1639"/><a class="indexterm" id="iddle1647"/>Security Authority Subsystem Service (LSASS) process in charge of enforcing the system’s security policy. You can download the latest version of WCE from <span class="emphasis"><em><a class="ulink" href="http://www.ampliasecurity.com/research/wcefaq.html" target="_top">http://www.ampliasecurity.com/research/wcefaq.html</a></em></span>. An example of running WCE is shown in <a class="xref" href="ch09.xhtml#running_wce" title="Example 9-17. Running WCE">Example 9-17</a>.</p><div class="example"><a id="running_wce"/><div class="example-title">Example 9-17. Running WCE</div><div class="example-contents"><pre class="programlisting">C:\&gt;<span class="strong"><strong>wce.exe -w</strong></span>&#13;
wce.exe -w&#13;
WCE v1.42beta (Windows Credentials Editor) - (c) 2010-2013 Amplia Security - by Hernan Ochoa&#13;
(hernan@ampliasecurity.com)&#13;
Use -h for help.&#13;
&#13;
georgia\BOOKXP:password</pre></div></div><p>Here WCE found the plaintext of the user <span class="emphasis"><em>georgia</em></span>’s password. The downside to this attack is that it requires a logged-in user for the password to be stored in memory. Even if you were able to get a plaintext password or two with this method, it is still worth dumping and attempting to crack any password hashes you can access.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" id="summary-id00027" style="clear: both">Summary</h2></div></div></div><p>Reversing password hashes is an exciting field, and as the speed of hardware increases, it becomes possible to crack stronger hashes faster. Using multiple CPUs and even the graphics processing units (GPUs) on video cards, password crackers can try many hashes very quickly. Our virtual machines don’t have much processing power, but even your average modern laptop is much faster than the machines that were used for password cracking just a few short years ago. The cutting edge of password cracking these days is taking to the cloud and harnessing multiple top-spec cloud servers for cracking. You’ll even find some cloud-based password-cracking services.</p><p>As you’ve seen in this chapter, using information gathered from successful exploits in <a class="xref" href="ch08.xhtml" title="Chapter 8. Exploitation">Chapter 8</a>, we’ve managed to reverse password hashes to recover plaintext passwords for some services and the systems themselves. Having managed to get a foothold on the systems, let’s look at some advanced attack methods that can help us if we can’t find anything vulnerable when listening on the network. We still have the Windows 7 machine to exploit, after all.</p></div></section></body></html>