- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: 'Think of the Children: Countermeasures, Certifications, and Goodbytes'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 关注儿童：对策、认证和Goodbytes
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: We’ve written much about various attacks, but the ultimate goal of a defensive
    hacker is to improve security. With that in mind, we dedicate this chapter to
    countermeasures that mitigate fault attacks and side-channel analysis, various
    certifications that exist, and how you can get better. This is also the concluding
    chapter to our book, which we see as the bridge to the next step in our journey,
    which is to fix the problems you will expose.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经写了很多关于各种攻击的内容，但防御型黑客的最终目标是提高安全性。考虑到这一点，我们将本章专门献给减轻故障攻击和侧信道分析的对策，现有的各种认证，以及如何提升自己。这也是本书的结尾章节，我们认为这为我们的下一个阶段搭建了桥梁，那就是修复你将暴露的问题。
- en: Countermeasures are as old as the field of side-channel power analysis itself,
    and an area of active research. We’ll cover several of the classic countermeasures
    that are good first steps, along with their limitations. When you first hear about
    side-channel analysis, some obvious countermeasures come to mind, but it’s always
    important to evaluate them. For example, just adding noise to the system might
    sound like a good countermeasure, but in practice this makes the attack only slightly
    harder. The countermeasures in this chapter are publicly known (no NDAs were violated
    in the making of this book) and are typically ones that have some usage in the
    industry and represent a “reasonable effort.” Countermeasure development in highly
    secure products requires significant investment and collaboration between hardware
    design and software design teams. However, even with some software-only changes,
    we can make SCA and FI attacks much more difficult to execute.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对策与侧信道功率分析领域一样古老，且是一个活跃的研究领域。我们将介绍几种经典的对策，它们是良好的入门步骤，同时也会说明其局限性。当你第一次听到侧信道分析时，一些显而易见的对策会出现在脑海中，但始终重要的是要对其进行评估。例如，给系统添加噪声可能听起来是个不错的对策，但实际上这只会稍微增加攻击的难度。本章中的对策是公开已知的（本书制作过程中没有违反任何保密协议），通常是一些在行业中有一定应用并代表“合理努力”的对策。在高安全性产品中，对策的开发需要大量投资，并且需要硬件设计和软件设计团队之间的协作。然而，即使只进行一些软件上的更改，我们也可以让
    SCA 和 FI 攻击变得更难执行。
- en: It’s critically important that you evaluate the effectiveness of your countermeasures.
    For both power analysis and fault injection countermeasures, this must be a continuous
    evaluation. If you are writing C code, for example, your C compiler can simply
    optimize countermeasures away. A very common story in embedded security is that
    a “secure” product with a highly effective countermeasure was evaluated only at
    certain stages of the design. The compiler, synthesis tool, or implementation
    destroyed the effectiveness of the countermeasure. If you don’t test early and
    often, you’ll end up shipping products that you think are protected but simply
    aren’t.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 评估你的对策的有效性至关重要。对于功率分析和故障注入对策，这必须是一个持续的评估过程。例如，如果你编写的是 C 代码，C 编译器可能会简单地优化掉对策。在嵌入式安全领域，一个非常常见的故事是，某个“安全”的产品在设计的某些阶段仅进行了对策的评估。编译器、综合工具或实现破坏了对策的有效性。如果你不及早且频繁地进行测试，最终你会发布那些你认为是受保护的产品，但实际上根本就不安全。
- en: The tools we have taught you in this book are a great starting point for this
    evaluation. You can even start to set up a fully automated analysis, for example,
    so your product is being continuously evaluated with the actual toolchain in use.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们教授的工具是进行这种评估的绝佳起点。例如，你甚至可以开始设置一个完全自动化的分析系统，使你的产品在实际使用的工具链下得到持续评估。
- en: Countermeasures
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对策
- en: Ideal countermeasures don’t exist, but adding several together can make an attacker’s
    job hard enough for them to give up. In this section, we’ll provide several countermeasure
    constructions that you can apply in software or hardware. We’ll also discuss countermeasure
    verification, which is effectively the application of the techniques you learned
    in different chapters to see how much harder the attack becomes. The examples
    that follow are simplified to demonstrate each principle; therefore, we “ignore”
    some recommendations from the other principles. Many of these countermeasures
    are covered in the whitepaper “Secure Application Programming in the Presence
    of Side Channel Attacks” by Marc Witteman et al.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的对策并不存在，但将多个对策结合起来可以让攻击者的工作变得足够困难，从而让他们放弃。在本节中，我们将提供几种可以应用于软件或硬件的对策构建方法。我们还将讨论对策验证，这实际上是将你在不同章节中学到的技术应用到实际中，看看攻击变得多么困难。接下来的示例经过简化，以演示每个原理；因此，我们“忽略”了一些其他原理的建议。许多这些对策已在Marc
    Witteman等人的白皮书《在旁路攻击存在下的安全应用编程》中进行了详细介绍。
- en: Implementing Countermeasures
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现对策
- en: Implementing countermeasures in a commercial product is very difficult and therefore
    hard to get “right” the first time; in this context, “right” means the right balance
    of cost, power, performance, security, debuggability, development complexity,
    and whatever else you care about. Most successful manufacturers reach a good balance
    of these considerations after several product iterations. Once you start exploring
    conflicts between security and other aspects, at least you know you’re doing something
    right. You’ve hopefully already implemented the low-hanging fruit countermeasures
    and are now reaching the point where real tradeoffs need to be made. This means
    you are actively doing cost/benefit analyses, and you realize there is no absolute
    security; this is life and this is good.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业产品中实现对策是非常困难的，因此很难第一次就做到“正确”；在这个语境中，“正确”意味着成本、功率、性能、安全性、可调试性、开发复杂性以及你关心的其他因素之间的正确平衡。大多数成功的制造商会在几次产品迭代后达成这些考虑因素的良好平衡。一旦你开始探索安全性与其他方面之间的冲突，至少你知道自己在做正确的事情。你希望已经实现了容易解决的基础对策，并且现在正进入需要做出真正权衡的阶段。这意味着你正在积极进行成本/收益分析，并意识到没有绝对的安全性；这就是生活，这很好。
- en: You do want to avoid some common pitfalls. What we typically see is that the
    law of leaky abstractions (“all nontrivial abstractions, to some degree, are leaky,”
    by Joel Spolsky) applies to security vulnerabilities; side channels and faults
    are clearly cases of it, but it also applies to countermeasures. Electrical engineers
    will come up with a new circuit, computer scientists with improved code, and crypto
    people with a new cipher. The problem is that they commonly use the same abstraction
    when designing a countermeasure as when designing the object that contains the
    vulnerability, and that leads to ineffective countermeasures. You’ll see a basic
    example of how a secure countermeasure from one implementation (software) can
    fail on another implementation (hardware) in the “Noncorrelating/Constant Power
    Consumption Everywhere” section later in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你确实需要避免一些常见的陷阱。我们通常看到的是，泄漏抽象法则（“所有非平凡的抽象，在某种程度上，都是泄漏的，” 乔尔·斯波尔斯基所说）适用于安全漏洞；旁路攻击和故障显然是它的体现，但它同样适用于对策。电气工程师会提出新的电路，计算机科学家会改进代码，加密专家会提出新的加密算法。问题在于，他们通常在设计对策时使用与设计包含漏洞的对象相同的抽象方式，这导致了对策的无效性。在本章稍后的“无相关/恒定功率消耗”一节中，你将看到一个简单的例子，展示如何一个安全的对策在一种实现（软件）中有效，但在另一种实现（硬件）中失败。
- en: Breaking through the abstractions requires a fundamental understanding of every
    level of your stack, good-enough simulators, and/or plain-old testing of your
    final product. In other words, this is hard and iterative work; you won’t get
    it right the first time, but if you do it right, you’ll get gradually better.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打破抽象层次需要对你堆栈中的每一层有基本的理解、足够好的模拟器和/或对最终产品的彻底测试。换句话说，这是一个困难且反复迭代的过程；你不会第一次就做对，但如果做对了，你会逐渐变得更好。
- en: One of the key insights about countermeasures is that they operate by breaking
    an attack’s assumptions. Every attack makes some assumptions that are required
    to be true in order for the attack to succeed. For instance, in differential power
    analysis (DPA), the assumption is that your operations are aligned in time, so
    a countermeasure introducing misalignment breaks this assumption and reduces DPA’s
    effectiveness. Having an attack tree ready with known attacks and choosing countermeasures
    that break those attacks’ assumptions is a good strategy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对策的一个关键见解是，它们通过破坏攻击的假设来起作用。每个攻击都会做出一些假设，这些假设在攻击成功时必须为真。例如，在差分功率分析（DPA）中，假设你的操作是时间对齐的，因此引入错位的对策破坏了这个假设，从而减少了DPA的有效性。准备好攻击树并选择破坏这些攻击假设的对策是一种好的策略。
- en: 'This reasoning also works in the opposite direction: countermeasures rely on
    assumptions on the attacks, and it’s up to attackers to break them. The previous
    example of introducing misalignment as a countermeasure to DPA operates under
    the assumption that an attacker isn’t able to recognize features in a trace and
    perform alignment. This is where cat-and-mouse games start.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这一推理也适用于相反的方向：对策依赖于对攻击的假设，而攻击者的任务是破坏这些假设。之前提到的通过引入错位来对抗差分功率分析（DPA）的对策，是基于假设攻击者无法识别跟踪中的特征并执行对齐的前提下进行的。这就是猫鼠游戏开始的地方。
- en: With these cat-and-mouse games, countermeasures are broken and upgraded, and
    attacks are thwarted and improved. In software, the main game plan is patching.
    With hardware, that strategy is not possible. In some cases, you can patch hardware
    vulnerabilities using software countermeasures, which means you can keep a product
    secure for a bit longer. In other cases, you’ll rely on the security of a product
    as it was shipped. Ideally, products are shipped with a hardware security margin
    that makes them resistant against attackers *X* years in the future (although
    determining *X* is impossible due to the nonlinear nature of attacks), kind of
    like medicine products need to have some expiry date for their safe usage. In
    reality, this is impossible, and the common strategy is one of “best effort” combined
    with allowing patching through firmware updates and configuration changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些猫鼠游戏中，对策被破坏和升级，攻击被阻止和改进。在软件中，主要的游戏计划是打补丁。在硬件中，这种策略是不可行的。在某些情况下，你可以通过软件对策来修补硬件漏洞，这意味着你可以让产品保持安全一段时间。在其他情况下，你将依赖产品出厂时的安全性。理想情况下，产品在出厂时应该具备硬件安全余量，使其能抵抗未来*X*年后的攻击（尽管由于攻击的非线性特性，确定*X*是不可行的），就像药品需要有使用安全期一样。实际上，这是不可能的，常见的策略是“尽力而为”，并通过固件更新和配置更改允许打补丁。
- en: None of the countermeasures presented here are perfect, but they don’t need
    to be. With some extra effort or more clever attack, an attacker will be able
    to bypass them. The point is not to create an unbreakable system, but one where
    the cost of a successful attack is lower than the cost of the countermeasures
    or where the cost of attacking is higher than the attacker’s budget.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的所有对策都不完美，但它们不需要完美。通过一些额外的努力或更聪明的攻击，攻击者能够绕过这些对策。重点不是创造一个无法攻破的系统，而是设计一个成功攻击的成本低于对策成本，或者攻击的成本高于攻击者的预算的系统。
- en: Noncorrelating/Constant Time Everywhere
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非相关/常量时间 everywhere
- en: If an operation’s duration depends on some secret, either simple power analysis
    (SPA) or timing analysis may be able to recover that secret. The classical example
    of correlating time is using `strcmp()` or `memcmp()` to verify a password or
    PIN. (Storing the plaintext password or PIN instead of a hashed form is not secure
    in the first place, but let’s take it as an example.) Both of these C functions
    have an early termination condition, as they return after the first differing
    byte, giving an attacker who can measure timing the information of which character
    of an entered PIN differs from a stored PIN. For examples, see Chapter 8 on timing
    attacks and the `memcmp()` example in this chapter’s companion notebook (available
    at [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个操作的持续时间取决于某个秘密，那么简单的功率分析（SPA）或定时分析可能能够恢复这个秘密。关联时间的经典示例是使用`strcmp()`或`memcmp()`来验证密码或PIN码。（将明文密码或PIN码存储而不是存储其哈希值本身就是不安全的，但我们暂且将其作为一个示例。）这两个C函数都有一个提前终止的条件，因为它们在第一个不同的字节后就会返回，这使得攻击者在可以测量时间的情况下，能够得知输入的PIN码中哪个字符与存储的PIN码不同。有关示例，请参见第8章关于定时攻击的内容，以及本章附带笔记本中的`memcmp()`示例（可在[https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)查看）。
- en: The trick is to implement a countermeasure that *decorrelates* the timing between
    the operation and the secret, which means making the operating *time constant*
    (and possibly adding *timing randomization* on top), as shown in [Listing 14-7](#listing14-7).
    One solution is to implement a time constant memory comparison, like in `memcmp_consttime()`
    in this chapter’s notebook. We have the core of that function shown in [Listing
    14-1](#listing14-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是实现一个对策，使得操作与秘密之间的时间不再相关，这意味着要使操作的*时间保持常量*（并可能在此基础上添加*定时随机化*），如[列表14-7](#listing14-7)所示。一种解决方案是实现一个常量时间内存比较，比如本章笔记本中的`memcmp_consttime()`。我们在[列表14-1](#listing14-1)中展示了该函数的核心。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 14-1: A constant time `memcmp``()` function'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-1：一个常量时间的`memcmp()`函数
- en: Instead of terminating on the first differing byte, for each set of bytes in
    the two buffers, we calculate the XOR, which is zero if the bytes are the same
    and nonzero otherwise. We then accumulate all XORs by OR-ing them into `diff`,
    which means that once a single bit differs, this bit will remain set in `diff`.
    This code has no branches that depend on the contents of either buffer. Even better
    from a leakage perspective is to compare hashes of values instead, but doing so
    will be slower. Note that this example doesn’t include overflow checks for simplicity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在第一个不同的字节上终止，而是对于两个缓冲区中的每一组字节，计算它们的异或值，如果字节相同则结果为零，否则为非零。然后我们通过将所有异或值按位或（OR）到`diff`中来累加它们，这意味着一旦某个位不同，该位将在`diff`中保持不变。从泄漏角度来看，更好的做法是比较值的哈希，而不是直接比较字节，但这样做会更慢。请注意，为了简化，此示例没有包括溢出检查。
- en: Timing attacks on hash-based message authentication code (HMAC) comparisons
    are common in cryptographic implementations. If you have a data blob that’s signed
    using HMAC, the target system computes the HMAC over the blob and compares it
    to the signature. If that comparison leaks timing information, it allows brute-forcing
    the HMAC value, just like the preceding password example, without the HMAC key
    ever being known. This attack was used to bypass Xbox 360 code verification, called
    the *Xbox 360 timing attack* (unlike the FI attack in Chapter 13). To fix this,
    the *constant time comparison* can be used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希的消息认证码（HMAC）比较中的定时攻击在加密实现中很常见。如果你有一个使用HMAC签名的数据块，目标系统会计算该数据块的HMAC并与签名进行比较。如果该比较泄露了定时信息，就像前面的密码示例一样，它允许暴力破解HMAC值，而不需要知道HMAC密钥。这个攻击被用来绕过Xbox
    360的代码验证，称为*Xbox 360定时攻击*（与第13章中的FI攻击不同）。要修复此问题，可以使用*常量时间比较*。
- en: Another important aspect is the timing of branches that are conditional on a
    sensitive value. A simple example would be the code shown in [Listing 14-2](#listing14-2).
    If the secret value passed is `0xCA`, the execution of `leakSecret()` takes much
    longer than if the value is different.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是基于敏感值的条件分支的定时。一个简单的示例是[列表14-2](#listing14-2)中显示的代码。如果传递的秘密值是`0xCA`，那么执行`leakSecret()`的时间比传递其他值时要长得多。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 14-2: We can identify whether or not `secret` is `0xCA` by measuring
    the execution time of this code.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-2：我们可以通过测量这段代码的执行时间来判断`secret`是否为`0xCA`。
- en: Now, just by measuring the duration of the process, or by looking at SPA signals,
    an attacker can derive whether the secret value equals `0xca`. An attacker can
    also use knowledge of the timing of the `if()` statement in order to try to fault
    it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，攻击者只需通过测量过程的持续时间，或者查看SPA信号，就可以推测秘密值是否等于`0xca`。攻击者还可以利用`if()`语句的时序知识来尝试使其故障。
- en: One solution is to make the relevant code *branchless*, like in `dontLeakSecret()`
    in [Listing 14-3](#listing14-3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使相关代码*无分支*，如[示例 14-3](#listing14-3)中的`dontLeakSecret()`。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 14-3: We avoid the obvious power analysis by always executing both
    operations.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-3：我们通过始终执行两个操作来避免明显的功率分析。
- en: 'The idea is to execute both sides of the branch and store the results separately.
    Then we calculate a `mask`, which is either all zeros or all ones in binary, depending
    on the outcome of the `if()` condition. We can use this mask to combine the results
    logically: if the mask is all zeros, we take the result from one side of the branch;
    if it’s all ones, we take the result from the other. We’ve also tried to use operations
    to do the mask generation and assignment without a conditional code flow, but
    as we mention later, the risk here is that a clever compiler may yet detect what
    we are doing and replace our code with conditional code. The example from [Listing
    14-3](#listing14-3) (along with all the examples) may be easier to understand
    when running the code yourself, so be sure to see the companion notebook for this
    chapter to better understand the program flow. There are some obvious limitations
    here: `takesLong()` and `muchShorter()` should not have any side effects, and
    the performance of this code will be poorer.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其思路是执行分支的两个部分并分别存储结果。然后我们计算一个`mask`，该掩码在二进制中要么全为零，要么全为一，具体取决于`if()`条件的结果。我们可以使用这个掩码通过逻辑运算合并结果：如果掩码全为零，我们取分支一侧的结果；如果全为一，我们取另一侧的结果。我们也尝试过使用操作来生成和赋值掩码，而不采用条件代码流程，但正如我们稍后提到的，这里有风险，聪明的编译器可能会检测到我们正在做的事情，并将我们的代码替换为条件代码。从[示例
    14-3](#listing14-3)（以及所有示例）中可以看到，自己运行代码可能更容易理解，因此请务必查看本章的伴随笔记本，以便更好地理解程序流程。这里有一些明显的限制：`takesLong()`和`muchShorter()`不应有任何副作用，并且该代码的性能会较差。
- en: Finally, *timing randomization* is the insertion of nonconstant time operations
    that don’t depend on a secret. The simplest is just a loop that iterates some
    random number of times, which should be tuned such that it introduces sufficient
    uncertainty in timing for the processed secret. If a secret would normally leak
    during a particular clock cycle, you want to spread that out over at least dozens
    or hundreds of clock cycles. Realignment is nontrivial for an attacker if timing
    randomization is combined with sufficient noise addition (see the “Noncorrelating/Constant
    Power Consumption Everywhere” section, next).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*时序随机化*是指插入与秘密无关的非恒定时间操作。最简单的方式是使用一个循环，随机迭代若干次，其迭代次数需要调节到足以为处理的秘密引入足够的不确定性。如果一个秘密通常会在某个特定的时钟周期泄漏，你希望将其分散到至少几十个或几百个时钟周期中。如果时序随机化结合足够的噪声添加（参见下一节“非相关/恒定功耗”部分），对于攻击者来说，重新对齐是非平凡的。
- en: Timing randomization also helps against fault injection, as an attacker now
    either has to be lucky that the timing of the fault coincides with the randomized
    timing or needs to spend extra time on a setup that synchronizes with the target
    operation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 时序随机化也有助于防止故障注入，因为攻击者现在要么必须幸运地让故障时序与随机化时序巧合，要么需要花费额外的时间来同步目标操作。
- en: Device clocks that are driven by a PLL and not directly by an external crystal
    are usually not perfectly stable. Therefore, some timing randomization already
    comes “naturally”. Similarly, interrupts can add instability to the timing. These
    effects may add sufficient randomization for some use cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由PLL驱动而非直接由外部晶体驱动的设备时钟通常不是完全稳定的。因此，一些时序随机化已经“自然”地出现。类似地，中断可以为时序增加不稳定性。这些效应可能为某些使用场景添加足够的随机化。
- en: If not, it is recommended to add timing randomization explicitly before sensitive
    operations. Timing randomization may be easily seen in side-channel traces, so
    it points a big arrow to the sensitive operations. Noise addition may be able
    to help here, as it makes attack techniques such as alignment and Fourier transforms
    that discard timing information more difficult. If you can afford the performance
    hit, you should sprinkle timing randomization throughout your hardware design
    or software code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有实现此类方法，建议在敏感操作之前明确添加时序随机化。时序随机化可能会在旁道信道追踪中轻易看到，因此它会指向敏感操作。噪声的添加可能有助于此，因为它使得对抗技术如对齐和傅里叶变换等丢失时序信息的攻击变得更加困难。如果你可以承受性能损失，你应该在硬件设计或软件代码中遍布添加时序随机化。
- en: Noncorrelating/Constant Power Consumption Everywhere
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无相关/恒定功耗
- en: You can observe leakage in the power consumption signal’s amplitude. The less
    correlation there is between sensitive data/operations and power consumption,
    the better, but that’s nontrivial to achieve. The most basic way to do it is to
    add *noise* to the power consumption by running any piece of hardware or software
    in parallel. This strategy doesn’t fully decorrelate the signal, but it increases
    the noise and therefore increases the attack cost. In hardware, generating this
    noise can mean running a random number generator, a special noise generator, or
    a video decoder on dummy data. In software, you could run a parallel thread on
    another CPU core that performs decoy or dummy operations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到功耗信号幅度中的泄漏。敏感数据/操作与功耗之间的相关性越小越好，但要实现这一点并不简单。最基本的方法是通过并行运行任何硬件或软件向功耗中加入*噪声*。这种策略并不能完全去相关信号，但它增加了噪声，因此也增加了攻击成本。在硬件中，生成这种噪声可以通过运行一个随机数生成器、一个特殊的噪声生成器或一个视频解码器来处理虚拟数据。在软件中，你可以在另一个CPU核心上运行一个并行线程，执行诱饵或虚拟操作。
- en: 'In hardware, it’s possible to design a circuit that’s *balanced*—that is, for
    every clock, the same number of bitflips occurs irrespective of the data being
    processed. This balancing is called *dual-rail logic*, and the idea behind it
    is that each gate and line has an inverted version as well, such that a zero-to-one
    transition co-occurs with a one-to-zero transition. Adding this balancing is very
    expensive in terms of chip area and requires extremely careful and low-level balancing
    to make sure each transition happens at the same time. Imbalances still lead to
    leakage, though much less than without this technique. Additionally, electromagnetic
    signals must also be taken into account: two inverted signals may amplify or cancel
    each other out, depending on the spatial arrangement of the signals.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中，设计一个*平衡*电路是可能的——即，对于每个时钟周期，不管处理的数据是什么，都会发生相同数量的位翻转。这种平衡叫做*双轨逻辑*，其背后的理念是每个门和线路都有一个反转版本，使得零到一的转换与一到零的转换同时发生。加入这种平衡在芯片面积上非常昂贵，并且需要极其小心和低级别的平衡，以确保每个转换同时发生。然而，不平衡仍然会导致泄漏，尽管比没有这种技术时要少得多。此外，电磁信号也必须考虑进去：两个反向信号可能会相互放大或相互抵消，具体取决于信号的空间布局。
- en: For crypto, we can go beyond adding random noise and play some nice tricks using
    *masking*. Ideally, for every encryption or decryption, a random mask value is
    generated and is mixed in with the data at the start of the cipher. We then modify
    the cipher implementation such that the intermediate values stay masked, and at
    the end of the cipher, we “unmask” the result. Theoretically, nowhere during the
    cipher’s execution should any intermediate value be present without a mask. This
    means DPA should fail, as DPA critically depends on being able to predict an (unmasked)
    intermediate value. Masking thereby should not have *first-order* *leakage*, which
    is leakage that can be exploited by only looking at a single point in time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加密，我们可以通过添加随机噪声来进一步使用一些巧妙的*掩码*技巧。理想情况下，在每次加密或解密时，生成一个随机掩码值，并将其与数据混合在一起，作为密码的开始。然后我们修改密码实现，使得中间值始终保持掩码状态，在密码结束时，我们“解掩”结果。从理论上讲，在密码执行过程中，任何中间值都不应无掩码地存在。这意味着差分功耗分析（DPA）应该会失败，因为DPA严重依赖于能够预测一个（未掩码的）中间值。因此，掩码应该没有*一阶*
    *泄漏*，一阶泄漏是指通过仅查看某一时间点的内容来利用的泄漏。
- en: 'One example of masking is rotating S-box masking of AES (see “RSM: A Small
    and Fast Countermeasure for AES, Secure Against 1st and 2nd-Order Zero-Offset
    SCAs,” by Maxime Nassar, Youssef Souissi, Sylvain Guilley, and Jean-Luc Danger).
    In *Rotating* *S-boxes Masking (RSM)*, we modify each of the 16 S-boxes such that
    they take in a mask value *M*[*i*], and they produce an output value masked with
    *M*[(][*i+1*][)] [*mod*] [16], where *M*[*i*] is a randomly chosen 8-bit value
    for 0 ≤ *i* < 16\. Masking is simply done using XOR. The S-box tables are recalculated
    only once before executing the cipher. For the cipher invocation, we XOR the initial
    mask onto the key, which in turn XOR masks the data during `AddRoundKey`. The
    XOR masks are preserved by the modified S-box in `SubBytes` and `ShiftRows` operations.
    The `MixColumns` operation is executed as is, but afterward is “fixed” by XORing
    in a state that effectively remasks the state vector. The result is a masked AES
    state vector after the first round and masked intermediate values all throughout
    the computation. These steps are repeated for all rounds, and then the data is
    unmasked by a final XOR.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码的一个例子是 AES 的旋转 S-box 掩码（见 Maxime Nassar、Youssef Souissi、Sylvain Guilley 和
    Jean-Luc Danger 撰写的“RSM：一种小巧且快速的 AES 防护措施，能够防范 1 阶和 2 阶零偏旁路攻击”）。在*旋转 S-box 掩码（RSM）*中，我们修改每个
    16 个 S-box，使它们接受一个掩码值 *M*[*i*]，并生成一个用 *M*[(][*i+1*][)] [*mod*] [16] 掩码的输出值，其中
    *M*[*i*] 是一个随机选择的 8 位值，0 ≤ *i* < 16。掩码仅通过 XOR 完成。S-box 表只在执行密码算法之前计算一次。在密码调用时，我们将初始掩码与密钥进行
    XOR 操作，进而在 `AddRoundKey` 中 XOR 掩码数据。XOR 掩码会在 `SubBytes` 和 `ShiftRows` 操作中由修改后的
    S-box 保持。`MixColumns` 操作按原样执行，但之后通过 XOR 操作“修正”，使得状态向量有效地重新掩码。最终，经过第一轮后得到一个掩码的
    AES 状态向量，并且在整个计算过程中都保持掩码的中间值。这些步骤会为所有轮次重复执行，最后通过一次 XOR 操作将数据解除掩码。
- en: 'The problem with masking is usually that the “perfect” model doesn’t always
    apply in reality. As in the case of RSM, masks are reused, and therefore “perfect”
    has been traded for a performance gain. The paper “Lowering the Bar: Deep Learning
    for Side-Channel Analysis,” by Guilherme Perin, Baris Ege, and Jasper van Woudenberg,
    shows that first-order leakage is still present for one implementation of RSM.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码的一个问题通常是“完美”的模型在现实中并不总是适用。就像 RSM 的情况一样，掩码会被重复使用，因此“完美”被换取了性能的提升。Guilherme
    Perin、Baris Ege 和 Jasper van Woudenberg 撰写的论文“降低门槛：用于旁路分析的深度学习”表明，对于某些 RSM 实现，依然存在一阶泄漏。
- en: 'Even if masking is “perfect,” so-called *second-order attacks* on masking exist,
    which work on the principle that we look at two intermediate values, *X* and *Y*.
    For example, *X* could be a byte of state after `AddRoundKey`, and *Y* a byte
    after `SubBytes`. If they are both masked with the same mask *M* during execution—that
    is, *X* ⊕ *M* and *Y* ⊕ *M*—we can do the following. We measure a side-channel
    signal of *X* ⊕ *M* and *Y* ⊕ *M*. Assume for a moment we know the points in time
    *x* and *y* where the signal of *X* ⊕ *M* and *Y* ⊕ *M* are leaking, which means
    we can obtain their corresponding sample values *t*[*x*] and *t*[*y*]. We can
    combine these two measurements points (for example, by calculating their absolute
    difference as |*t*[*x*] − *t*[*y*]|). We also know (*X* ⊕ *M*) ⊕ (*Y* ⊕ *M*) =
    *X* ⊕ *Y*. As it turns out, there is actually a correlation between |*t*[*x*]
    − *t*[*y*]| and *X* ⊕ *Y*, and on that correlation, we can perform DPA. This is
    called a second-orderattack because we combine two points on the trace, but the
    idea extends up to any *higher-order attacks*: first-order masking applies one
    mask to a value (that is, *X* ⊕ *M*) and can be attacked with second-order DPA.
    Second-order masking applies two masks to a value (that is, *X* ⊕ *M*[*1*] ⊕ *M*[*2*])
    and can be attacked with third-order DPA, and so on. In general, *n*th-order masking
    can be attacked with (*n* + 1)th-order DPA.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使掩码是“完美的”，也存在所谓的*二阶攻击*，其原理是我们观察两个中间值，*X* 和 *Y*。例如，*X* 可能是 `AddRoundKey` 后的一个字节，*Y*
    可能是 `SubBytes` 后的一个字节。如果它们在执行过程中都使用相同的掩码 *M*，也就是 *X* ⊕ *M* 和 *Y* ⊕ *M*，我们可以执行以下操作。我们测量
    *X* ⊕ *M* 和 *Y* ⊕ *M* 的旁路信号。假设我们知道信号 *X* ⊕ *M* 和 *Y* ⊕ *M* 泄漏的时间点 *x* 和 *y*，这意味着我们可以获取它们对应的采样值
    *t*[*x*] 和 *t*[*y*]。我们可以结合这两个测量点（例如，通过计算它们的绝对差值 |*t*[*x*] − *t*[*y*]|）。我们还知道 (*X*
    ⊕ *M*) ⊕ (*Y* ⊕ *M*) = *X* ⊕ *Y*。事实证明，|*t*[*x*] − *t*[*y*]| 和 *X* ⊕ *Y* 之间实际上存在相关性，基于这种相关性，我们可以执行
    DPA。这就是所谓的二阶攻击，因为我们将跟踪中的两个点结合起来，但这个思路可以扩展到任何*更高阶攻击*：一阶掩码对一个值应用一个掩码（也就是 *X* ⊕ *M*），并且可以通过二阶
    DPA 攻击。二阶掩码对一个值应用两个掩码（也就是 *X* ⊕ *M*[*1*] ⊕ *M*[*2*]），并且可以通过三阶 DPA 攻击，以此类推。一般来说，*n*阶掩码可以通过
    (*n* + 1)阶 DPA 攻击。
- en: The problem with a second-order attack is finding the points in time *x* and
    *y* where the signals of *X* ⊕ *M* and *Y* ⊕ *M* are leaking. In normal DPA, we
    just correlate all samples at a single point in time in a trace to find leakage.
    If we don’t know time *x* and *y*, we have to “brute-force” them by combining
    all possible samples in a trace and perform DPA on all these combinations. This
    is a problem of quadratic complexity in the number of samples in a trace. Also,
    the correlation isn’t perfect, so proper masking forces an attacker to perform
    more measurements and more computation. In other words, masking, though expensive
    and error-prone to implement, also puts a significant burden on an attacker.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶攻击的问题在于找到 *x* 和 *y* 这两个时间点，其中 *X* ⊕ *M* 和 *Y* ⊕ *M* 的信号存在泄漏。在正常的 DPA 中，我们只是对踪迹中某一时间点的所有样本进行相关分析来找到泄漏。如果我们不知道时间
    *x* 和 *y*，就必须通过暴力方法将踪迹中的所有可能样本组合起来，进行 DPA 分析。这是一个二次复杂度问题，复杂度与踪迹中的样本数有关。同时，相关性并不完美，因此适当的遮掩技术迫使攻击者进行更多的测量和计算。换句话说，尽管遮掩技术实现起来昂贵且容易出错，但它也给攻击者带来了很大的负担。
- en: '*Blinding* is similar to masking, except that the origins of those techniques
    are in (non-side-channel) cryptography. Various blinding techniques for RSA and
    ECC exist, and they rely on math. One example is RSA message blinding. For ciphertext
    *C*, message *M*, modulus *N*, public exponent *e* and private exponent *d*, and
    a random blind *1* < *r* < *N*, we first calculate the blinded message *R* = *M*
    × *r*^(*e*) mod *N*. Next, we perform the RSA signing on the blinded message,
    *R*^(*d*) = (*M* × *r*^(*e*))^(*d*) = *M*^(*d*) × *r*^(*ed*) = *C* × *r*, and
    we unblind by calculating (*C* × *r*) × *r*^(*–1*) = *C*. This results in the
    same value as textbook RSA without blinding, which would directly calculate *M*^(*d*)
    = *C*. However, because *R* in *R*^(*d*) is unpredictable for an attacker, timing
    attacks that require the message *M* to be raised to *d* fail. This is called
    *message blinding*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*遮掩（Blinding）* 类似于遮掩技术，只不过这些技术的起源是在（非侧信道）密码学中。RSA 和 ECC 有各种各样的遮掩技术，它们依赖于数学原理。一个例子是
    RSA 消息遮掩。对于密文 *C*、消息 *M*、模数 *N*、公钥指数 *e* 和私钥指数 *d* 以及随机遮掩 *1* < *r* < *N*，我们首先计算被遮掩的消息
    *R* = *M* × *r*^(*e*) mod *N*。接下来，我们对被遮掩的消息进行 RSA 签名，*R*^(*d*) = (*M* × *r*^(*e*))^(*d*)
    = *M*^(*d*) × *r*^(*ed*) = *C* × *r*，然后通过计算 (*C* × *r*) × *r*^(*–1*) = *C* 来去除遮掩。这样得到的值与不进行遮掩的经典
    RSA 相同，后者直接计算 *M*^(*d*) = *C*。然而，由于 *R* 在 *R*^(*d*) 中对攻击者是不可预测的，因此需要消息 *M* 提升到
    *d* 的时序攻击会失败。这就是所谓的 *消息遮掩（message blinding）*。'
- en: 'Since RSA uses one or a few bits of exponent *d* at a time, the exponent is
    also prone to timing or other side-channel attacks. To mitigate the side-channel
    leakage of the exponent value, exponent blinding is needed, which ensures that
    the exponent used in every RSA calculation is different by creating a random number
    1 ≤ *r* < 2^(64) and creating a new exponent *d′* = *d* + ϕ(*N*) × *r*, where
    ϕ(*N*) = (*p* – 1) × (*q* – 1) is the group order. The new exponent is “automatically”
    unblinded by the modular reduction (that is, *M*^(*d*)=*M*^(*d′*) mod *N*) but
    is unpredictable from the point of view of a side-channel attacker. The blinded
    exponent *d′* can be random for each invocation of the cipher, so an attacker
    isn’t able to learn more and more about *d* or a single *d′* by taking more traces.
    This raises the bar for an attacker. Instead of being able to acquire more information
    by acquiring more traces, an attacker is forced to break a single trace. However,
    if the implementation is very leaky, SPA attacks may be effective: completely
    extracting *d*′ from a single trace is equivalent to finding the unblinded private
    key *d*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RSA 每次只使用一个或几个指数位 *d*，因此指数也容易受到时序攻击或其他侧信道攻击的影响。为了减轻指数值的侧信道泄漏，需要进行指数遮掩（exponent
    blinding），这确保了每次 RSA 计算中使用的指数都是不同的，通过生成一个随机数 1 ≤ *r* < 2^(64)，并生成一个新的指数 *d′* =
    *d* + ϕ(*N*) × *r*，其中 ϕ(*N*) = (*p* – 1) × (*q* – 1) 是群的阶。新的指数通过模约简“自动”去除遮掩（即，*M*^(*d*)
    = *M*^(*d′*) mod *N*），但从侧信道攻击者的角度来看是不可预测的。被遮掩的指数 *d′* 可以是每次加密调用时的随机值，因此攻击者无法通过获取更多的踪迹来逐渐了解
    *d* 或单一的 *d′*。这增加了攻击者的难度。攻击者无法通过获取更多的踪迹获得更多的信息，而是必须破解单一的踪迹。然而，如果实现非常泄漏，SPA 攻击可能会有效：从单个踪迹完全提取
    *d′* 相当于找到了未遮掩的私钥 *d*。
- en: 'Many more blinding and masking techniques exist, as well as *time-constant*
    or *randomized exponentiation algorithms* for RSA and *scalar multiplication algorithms*
    for ECC: *modulus blinding*, *Montgomery ladders*, *randomized additions chains*,
    *randomized projective coordinates*, and *higher-order masking*. It’s an active
    field of study, and we recommend researching the latest in attacks and countermeasures.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的模糊和掩码技术，以及*时间常数*或*随机化指数运算算法*（用于RSA）和*标量乘法算法*（用于ECC）：*模数掩蔽*、*蒙哥马利阶梯*、*随机加法链*、*随机投影坐标*和*高阶掩蔽*。这是一个活跃的研究领域，我们建议研究最新的攻击和防御措施。
- en: 'When working with these countermeasures, be aware of their underlying assumptions.
    The example of masking earlier in this section implied an assumed Hamming weight
    leakage. But what if we implemented this in hardware, and a register leaked the
    Hamming distance between consecutive values? It’s possible then that the masking
    would be annihilated. The unmasking happens when a register consecutively contains
    the two masked values, *X* ⊕ *M* and then *Y* ⊕ *M*, which would leak HD(*X* ⊕
    *M*, *Y* ⊕ *M*). The issue can be seen if we rewrite this as follows: HD(*X* ⊕
    *M*, *Y* ⊕ *M*) = HW(*X* ⊕ *M* ⊕ *Y* ⊕ *M*) = HW(*X* ⊕ *Y*) = HD(*X*, *Y*). Effectively,
    the hardware has unmasked the value for you and just leaks the same Hamming distance.
    Therefore, at the algorithm level, this countermeasure seems like a good one,
    but the implementation can bite you back.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些对策时，要注意其潜在的假设。前面部分提到的掩蔽示例假设了哈明重量泄露。但如果我们在硬件中实现这个方法，而一个寄存器泄露了连续值之间的哈明距离呢？那么掩蔽可能就会被消除。当寄存器连续包含两个掩蔽值，*X*
    ⊕ *M* 和 *Y* ⊕ *M* 时，就会泄露HD(*X* ⊕ *M*, *Y* ⊕ *M*)。如果我们将其重新写成如下形式，就能看出这个问题：HD(*X*
    ⊕ *M*, *Y* ⊕ *M*) = HW(*X* ⊕ *M* ⊕ *Y* ⊕ *M*) = HW(*X* ⊕ *Y*) = HD(*X*, *Y*)。实际上，硬件已经为你解除了掩蔽，并泄露了相同的哈明距离。因此，从算法层面来看，这个对策似乎是有效的，但在实现时可能会带来反效果。
- en: Randomize Access to Confidential Array Values
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机化访问机密数组值
- en: This countermeasure is an easy one. If you’re looping over some secret that’s
    stored in an array, do it in a *random order*, or at least pick a *random starting
    point* and then loop over the array in order. This method disallows an attacker
    with side-channel possibilities from learning about a specific entry in the array.
    Examples where this is useful include verifying HMACs (or plaintext passwords)
    or zeroing/wiping keys from memory, as you don’t want to leak some of this information
    accidentally at a predictable point in time. See the companion notebook for an
    example in the `memcmp_randorder()` function that starts at an arbitrary point
    in the two arrays and does not branch, depending on buffer data. Alternatively,
    you can refer to [Listing 14-4](#listing14-4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对策很简单。如果你正在遍历存储在数组中的某个机密信息，可以采用*随机顺序*，或者至少选择一个*随机起始点*，然后按顺序遍历数组。此方法可以防止具有侧信道攻击可能性的攻击者从数组中学习特定条目。此方法有用的例子包括验证HMAC（或明文密码）或从内存中清除/擦除密钥，因为你不希望在一个可预测的时间点不小心泄露这些信息。有关例子，可以查看伴随笔记本中的`memcmp_randorder()`函数，该函数从两个数组中的任意位置开始，不根据缓冲区数据进行分支。或者，你可以参考[Listing
    14-4](#listing14-4)。
- en: Perform Decoy Operations or Infective Computing
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行诱饵操作或感染计算
- en: '*Decoy operations* are designed to mimic an actual sensitive operation (from
    a side-channel perspective), but they have no actual effect on the output of the
    operation. They fool an attacker into analyzing the wrong part of a side-channel
    trace and can double as a way to decorrelate timing. One example is the *square-and-multiply-always
    countermeasure* for modular exponentiation in RSA. In textbook RSA, for every
    bit of the exponent, you perform a square operation if the exponent bit is 0,
    and you perform a multiplication-and-square operation if the bit is 1\. This difference
    in operation for a 0-versus-1 bit has very obvious (SPA) side-channel leakage.
    To even it out, you can perform a decoy multiplication and discard the result
    if the bit is 0\. Now, the number of squares and multiplications are balanced.
    Another example is adding extra rounds to AES that discard their results.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*诱饵操作*旨在模拟实际的敏感操作（从旁路角度来看），但它们对操作的输出没有实际影响。它们会欺骗攻击者分析旁路跟踪中的错误部分，并且可以用作解耦时间的手段。一个例子是RSA中模幂运算的*平方乘法始终对策*。在教科书RSA中，对于每个位的指数，如果指数位为0，就执行平方操作，如果指数位为1，就执行乘法加平方操作。对于0和1位的操作差异，会造成非常明显的（SPA）旁路泄漏。为了平衡这一差异，你可以执行诱饵乘法，并在指数位为0时丢弃结果。这样，平方和乘法的次数就能保持平衡。另一个例子是在AES中增加额外的轮次并丢弃它们的结果。'
- en: To stick with our running memory compare example in the notebook, we add some
    random decoy rounds in `memcmp_decoys()`. It works by randomly executing a decoy
    XOR and making sure the result doesn’t get accumulated. This is also used in [Listing
    14-4](#listing14-4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续使用笔记本中的内存比较示例，我们在`memcmp_decoys()`中添加了一些随机诱饵轮次。它的工作原理是随机执行诱饵XOR操作，并确保结果不被累积。这也用于[Listing
    14-4](#listing14-4)。
- en: '*Infective computing* goes one step further: it uses the decoy operations as
    a way to “infect” the output. If any error occurs in the decoy operation, it corrupts
    the output. This is particularly handy in crypto operations; see “Infective Computation
    and Dummy Rounds: Fault Protection for Block Ciphers Without Check Before-Output”
    by Benedikt Gierlichs, Jörn-Marc Schmidt, and Michael Tunstall.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*感染性计算*更进一步：它使用诱饵操作作为“感染”输出的一种方式。如果诱饵操作发生错误，它会破坏输出。这在加密操作中尤为有用；可以参考Benedikt
    Gierlichs、Jörn-Marc Schmidt和Michael Tunstall的《Infective Computation and Dummy
    Rounds: Fault Protection for Block Ciphers Without Check Before-Output》。'
- en: Another good use of decoy operations is detecting faults (detect and respond
    to faults). If the decoy operation has a known output, you can verify that output
    is correct; if not, a fault must have occurred.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 诱饵操作的另一个良好应用是检测故障（检测并响应故障）。如果诱饵操作有已知的输出，你可以验证该输出是否正确；如果不正确，则说明一定发生了故障。
- en: Side-Channel-Resistant Crypto Libraries, Primitives, and Protocols
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旁路抵抗加密库、原语和协议
- en: Saying “use vetted *crypto libraries*” is along the lines of the Crypto 101
    rule “don’t roll your own crypto.” The caveat here is that most open source crypto
    libraries do not provide any power analysis side-channel resistance or fault-resistance
    guarantees. Common libraries (such as OpenSSL and NaCl) and primitives (such as
    Ed25519) do protect against timing side-channel attacks, mainly because timing
    attacks can be exploited remotely. If you’re building on top of a microcontroller
    or secure element, the crypto cores and/or library that comes with the chip may
    claim to have some resistance. Check the datasheet for the word *countermeasure*,
    *side channel*, or *fault*, or check any certifications. Even better, test the
    chip!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 说“使用经过验证的*加密库*”与加密101规则“不要自己实现加密”类似。这里的警告是，大多数开源加密库并不提供任何功率分析旁路抵抗或故障抵抗的保障。常见的库（如OpenSSL和NaCl）和原语（如Ed25519）确实能防范时间旁路攻击，主要是因为时间攻击可以被远程利用。如果你在微控制器或安全元素上构建，芯片自带的加密核心和/或库可能声称具有某些抵抗能力。查看数据手册中的*对策*、*旁路*或*故障*等词，或检查任何认证。更好的做法是，测试芯片！
- en: If you’re stuck with a crypto library or primitive that is not power side-channel
    resistant, you may be able to use a *leakage-resistant protocol*. These protocols
    basically ensure that keys are used only once or a few times, thus making DPA
    significantly harder. For instance, you can hash a key in order to create a new
    key for a next message. This type of operation is used, for example, in the AES
    mode implemented by NXP with the LPC55S69, which is called *Indexed Code Block*
    mode.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被迫使用一个不具备抗电源侧信道攻击能力的加密库或原语，你或许可以使用*抗泄漏协议*。这些协议基本上确保密钥只被使用一次或少数几次，从而使得差分功率分析（DPA）变得更加困难。例如，你可以对密钥进行哈希处理，以便为下一条消息创建一个新的密钥。这类操作例如在NXP实现的AES模式中使用，该模式在LPC55S69中被称为*索引代码块*模式。
- en: 'Finally, you can *wrap* the library to perform some safety checks against faults.
    For instance, after signing with ECC or RSA, you can verify the signature to check
    whether it passes. If not, some fault must have happened. Similarly, you can decrypt
    after encrypting to check that you obtained the plaintext again. Performing these
    checks pushes an attacker into double faults: one to target the algorithm and
    another to bypass the fault check.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以*封装*库以执行一些针对故障的安全检查。例如，在使用ECC或RSA签名后，你可以验证签名，检查它是否通过。如果没有，肯定发生了某些故障。同样，你可以在加密后解密，检查是否重新获得了明文。执行这些检查会迫使攻击者进入双重故障：一个针对算法，另一个绕过故障检查。
- en: Don’t Handle Keys When You Can Avoid It
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尽量避免处理密钥，除非必要
- en: Pretend that you are Superman and that keys are kryptonite; handle them with
    care and only when absolutely needed. Don’t copy (or integrity-check) them, and
    do pass them by *reference* in your application rather than by value. When using
    a crypto engine, avoid loading the key to the engine more than necessary to avoid
    *key-loading attacks*. This practice obviously reduces the possibilities for side-channel
    leakage, but also for fault attacks on the key. Differential fault analysis is
    a class of fancy crypto fault attacks, but there are more fault attacks on crypto.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是超人，密钥就是氪石；请小心处理它们，只在绝对必要时使用。不要复制（或进行完整性检查）它们，且在应用中应通过*引用*传递密钥，而不是通过值传递。当使用加密引擎时，避免不必要地加载密钥到引擎中，以避免*密钥加载攻击*。这种做法显然减少了侧信道泄漏的可能性，也减少了对密钥的故障攻击。差分故障分析是一种复杂的加密故障攻击，但加密还面临更多的故障攻击。
- en: 'Say an attacker can just zero out (part of) a key (for instance, during a key
    copy operation). Doing so can break challenge-response protocols. Challenge-response
    is basically used by one party to establish whether the other party has knowledge
    of a key: Alice sends Bob a nonce *c* (the challenge), and Bob encrypts *c* with
    shared key *k* and sends the response *r*. Alice performs the same encryption
    and verifies that Bob sent the correct *r*. Now Alice knows that Bob has knowledge
    of key *k*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个攻击者只需将密钥的一部分（例如，在密钥复制操作中）归零。这样做可以破坏挑战响应协议。挑战响应协议基本上由一方用来确认另一方是否知道某个密钥：爱丽丝向鲍勃发送一个随机数*c*（挑战），鲍勃用共享密钥*k*加密*c*并发送响应*r*。爱丽丝进行相同的加密，并验证鲍勃是否发送了正确的*r*。现在爱丽丝知道鲍勃知道密钥*k*。
- en: That’s all fine and dandy, except the Fault Fairy now has physical access to
    Alice’s crypto device. The key Alice uses for verification is now corrupted by
    a fault such that it is all zeros. Because the Fault Fairy knows this, she can
    spoof Bob by encrypting *r* with a zero key. Alternatively, if the Fault Fairy
    has access to Bob’s crypto device and can partially zero a key (for example, all
    except one byte), she can use one pair of *c* and *r* to brute-force the one nonzero
    key byte. Iterating over the other key bytes can expose the entire key. If the
    device is reloading the key frequently, the Fault Fairy has many attempts to zero
    out different parts of the key.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都好，问题是现在故障精灵可以物理访问到爱丽丝的加密设备。爱丽丝用于验证的密钥现在因为故障被破坏，变成了全零。因为故障精灵知道这一点，她可以通过用零密钥加密*r*来伪装鲍勃。或者，如果故障精灵能够访问鲍勃的加密设备，并能部分将密钥归零（例如，除了一个字节外的所有字节），她可以使用一对*c*和*r*暴力破解那个非零的密钥字节。通过迭代其他密钥字节，可以暴露整个密钥。如果设备频繁重新加载密钥，故障精灵将有多次机会将密钥的不同部分归零。
- en: Use Nontrivial Constants
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用非平凡的常量
- en: 'A Boolean in software is stored in 32 or 64 bits on a modern CPU. You can make
    use of all those other bits to build in fault mitigation and detection. In Chapter
    7, you saw in the demonstration of the Trezor One glitch that a simple comparison
    could be skipped. Likewise, imagine you are using the following code to verify
    a signature operation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代CPU上，软件中的布尔值被存储为32位或64位。你可以利用这些额外的位来构建故障缓解和检测机制。在第7章，你通过Trezor One故障的演示看到，简单的比较操作可能被跳过。同样，假设你使用以下代码来验证签名操作：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only return value of `verify_signature()` that *won’t* result in the code
    in question being flashed in is `0`. Every other possible return value will evaluate
    to “true” by the code! This is an example of using trivial constants that result
    in a particularly easily fault-injectable code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify_signature()`的唯一返回值是`0`，它*不会*导致相关代码被闪存写入。其他所有可能的返回值都会被代码评估为“真”！这是使用平凡常数的一个例子，导致代码非常容易被故障注入。'
- en: A typical fault model is that an attacker can zero out or “`0xffffffff` out”
    a word. In this model, it’s unlikely the attacker can set a specific 32-bit value.
    So, instead of using zero and one for a Boolean, we can use *nontrivial constants*
    with a large Hamming distance (for instance `0xA5C3B4D2` and `0x5A3C4B2D`). These
    require a large number of bitflips (through a fault) to get from one to the other.
    Simultaneously, we could define `0x0` and `0xffffffff` to be invalid values to
    catch faults.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的故障模型是，攻击者可以将一个字设置为零，或者“`0xffffffff`”，在这个模型中，攻击者不太可能设置一个特定的32位值。因此，我们可以用*非平凡常数*来代替布尔值的零和一，这些常数有较大的哈明距离（例如`0xA5C3B4D2`和`0x5A3C4B2D`）。要从一个常数转换到另一个常数，通常需要大量的比特翻转（通过故障）。同时，我们可以将`0x0`和`0xffffffff`定义为无效值，以捕捉故障。
- en: This idea can be extended to states in an enum, and similarly can be done in
    hardware state machines. Note that the application of this construct for states
    in an enum is typically trivial, but for Booleans, it can be infeasible to implement
    consistently, specifically when standard functions are used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路可以扩展到枚举中的状态，类似地也可以在硬件状态机中实现。请注意，将这个构造应用于枚举中的状态通常很简单，但对于布尔值来说，当使用标准函数时，可能很难始终如一地实现。
- en: In the example `memcmp_nontrivial()` in the notebook, we extend our memory compare
    function with nontrivial values for important state. This version is also shown
    in [Listing 14-4](#listing14-4), which includes decoys, starting at a random index
    and constant time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中的示例`memcmp_nontrivial()`中，我们使用非平凡值扩展了我们的内存比较函数，以处理重要的状态。这个版本也展示在[Listing
    14-4](#listing14-4)中，包括了诱饵函数，从随机索引开始，并具有常数时间特性。
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 14-4: A complicated `memcmp` function with decoy functions and nontrivial
    constants'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-4: 一个复杂的`memcmp`函数，包含诱饵函数和非平凡常数'
- en: 'The trick is to encode the values for `diff` and `tmpdiff` such that they are
    never just all 1 or all 0\. For that, we use two special values: `CONST_1==` `0xC0A0B000`
    and `CONST_2==0x03050400`. They’ve been designed to have the lower byte set to
    0\. This lower byte will be used to store the XOR of 2 bytes in memory, and we
    accumulate this in the `diff` variable. In addition, we’ll use the upper 24 bits
    of `diff` as a nontrivial constant. As you can see in the code, we also accumulate
    the values of `CONST_1` and `CONST_2` into `diff`. The way this is done is such
    that under normal circumstances, the top 24 bits of `diff` will have a fixed,
    known value—namely, the same as the top 24 bits of `CONST_1` | `CONST_2`. If there
    is a data fault that flips a bit in the top 24 bits of `tmpdiff`, it can be detected;
    you’ll see what to do later in the “Detect and Respond to Faults” section.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍在于将`diff`和`tmpdiff`的值编码成，它们永远不会是全1或全0。为此，我们使用两个特殊的值：`CONST_1==` `0xC0A0B000`和`CONST_2==0x03050400`。它们被设计成较低的字节被设置为0。这个较低的字节将用于存储内存中两个字节的异或结果，我们将这个值累积到`diff`变量中。此外，我们还将`diff`的高24位作为一个非平凡常数。正如代码所示，我们还将`CONST_1`和`CONST_2`的值累积到`diff`中。这样做的方式是，在正常情况下，`diff`的高24位将有一个固定且已知的值——即与`CONST_1`和`CONST_2`的高24位相同。如果数据故障导致`tmpdiff`的高24位发生比特翻转，就可以检测到；你将在“检测并响应故障”部分看到如何处理这种情况。
- en: The examples of the different memory compare functions show how hard it is to
    write something that mitigates faults. When you’re using optimizing (JIT) compilers,
    it’s even harder to write the code such that the countermeasures don’t get compiled
    out. The obvious answer is to do this in assembly (with the downside of having
    to code in assembly) or to make a compiler that injects these kinds of countermeasures.
    There have been some academic publications on the topic, but the problem seems
    to be acceptance—either for performance reasons or for concerns around potentially
    introducing issues into otherwise well-tested compiler behavior.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不同内存比较函数的示例展示了编写能够减轻故障的代码有多么困难。当你使用优化（JIT）编译器时，更难写出代码，确保这些对策不会被编译掉。显而易见的解决方案是使用汇编语言（虽然这有在汇编中编写代码的缺点），或者开发一个能够注入此类对策的编译器。关于这个主题已经有一些学术出版物，但问题似乎在于接受度——无论是出于性能原因，还是担心可能引入会影响已充分测试的编译器行为的问题。
- en: In hardware, *error correcting codes (ECCs)* can be considered “nontrivial constants”
    used to mitigate faults. They typically have limited error correction and detection
    capabilities, and for an attacker who can flip many bits (for example, an entire
    word), this may reduce fault effectiveness less than an order of magnitude. Care
    should also be taken that, for example, an all-zero word (including ECC bits)
    is not a correct encoding.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中，*错误更正码（ECC）*可以视为用来减轻故障的“非平凡常量”。它们通常具有有限的错误更正和检测能力，对于能够翻转多个位的攻击者（例如，整个字），这可能使得故障的有效性减少不到一个数量级。还需要注意的是，举例来说，一个全零的字（包括
    ECC 位）并不是一个正确的编码。
- en: Status Variable Reuse
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态变量重用
- en: Using nontrivial constants is great, but consider the code flow of `check_fw()`
    in the companion notebook, also shown in [Listing 14-5](#listing14-5). It sets
    `rv = validate_address(a)`, which returns a nontrivial constant. If the constant
    is `SECURE_OK`, it does `rv = validate_signature(a)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非平凡常量是一个不错的选择，但请考虑在配套笔记本中 `check_fw()` 函数的代码流，该函数在 [Listing 14-5](#listing14-5)
    中也有展示。它设置了 `rv = validate_address(a)`，返回一个非平凡常量。如果常量是 `SECURE_OK`，它将执行 `rv = validate_signature(a)`。
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 14-5: Using nontrivial constants isn’t an immediate fix for everything.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-5：使用非平凡常量并不是所有问题的立竿见影的解决办法。
- en: An attacker can do something easily here; they could use FI to skip the call
    at 2 to `validate_signature()`. The variable `rv` already has the `SECURE_OK`
    value present from the previous call to `validate_address()` at 1. Instead, we
    should be clearing the value after usage. In languages that support macros, we
    can do this relatively easily with a macro that wraps some of these calls. Alternatively,
    we can use a different variable (for example, by introducing an `rv2` for the
    second call) or verify control flow (see the next section). Note that all these
    methods are prone to compiler optimization (see the section “Fighting Compilers”
    later in the chapter).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者在这里可以轻松地做一些事情；他们可以使用故障注入（FI）跳过第 2 步对 `validate_signature()` 的调用。变量 `rv` 已经在之前对
    `validate_address()` 的调用（第 1 步）中设置了 `SECURE_OK` 值。因此，我们应该在使用后清除该值。在支持宏的语言中，我们可以通过一个宏轻松地包装这些调用。或者，我们可以使用一个不同的变量（例如，通过为第二次调用引入
    `rv2`）或验证控制流（见下节）。请注意，所有这些方法都容易受到编译器优化的影响（请参阅本章后面的“与编译器作斗争”部分）。
- en: Verify Control Flow
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证控制流
- en: Fault injection can alter control flow, so any critical control flow should
    be *verified* to decrease the probability of a successful fault. A simple example
    is a “default fail” statement in a `switch` statement in C; the case statements
    should enumerate all valid cases, and the default case should therefore never
    be reached. If the default case is reached, we know a fault has occurred. Similarly,
    you can do this for `if` statements where the final `else` is a failure mode.
    You can see an example of this in `default_fail()` in the notebook.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入可以改变控制流，因此任何关键的控制流应当进行*验证*，以降低故障成功的概率。一个简单的例子是在 C 语言中的 `switch` 语句中的“默认失败”语句；`case`
    语句应该列出所有有效的情况，因此默认情况应该永远不会被触及。如果默认情况被触及，我们就知道发生了故障。类似地，你可以对 `if` 语句做同样的处理，其中最终的
    `else` 是一种失败模式。在笔记本中的 `default_fail()` 函数中，你可以看到一个例子。
- en: When implementing any *conditional branch* (including one using the fancy “nontrivial
    constants”), also be aware of how the compiler’s implementation of your conditional
    may drastically affect the ability of an attacker to bypass a given code check.
    The high-level `if` statement will likely be implemented as a “branch if equal”
    or “branch of not equal” type of instruction. Like in Chapter 4, we’re going to
    go back to assembly code to see how this is implemented. The assembly code resulting
    from a typical `if`…`else` statement is given in [Listing 14-6](#listing14-6).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现任何 *条件分支*（包括使用那些“非平凡常数”的分支）时，也要意识到编译器如何实现你的条件分支，可能会极大地影响攻击者绕过某个代码检查的能力。高级的
    `if` 语句可能会被实现为“相等分支”或“不相等分支”类型的指令。像第 4 章中一样，我们将回到汇编代码中，看看它是如何实现的。典型的 `if`…`else`
    语句生成的汇编代码见 [列表 14-6](#listing14-6)。
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 14-6: Arm assembly code showing an `if` statement as implemented by
    the compiler'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-6：展示 `if` 语句的 ARM 汇编代码，编译器实现方式
- en: This `if` statement was designed to check whether or not an image (pointed to
    with `IMG_PTR`) should be booted. The function `signature_ok()` is called at 1,
    which has some special return value in `r0` to indicate if the signature should
    allow the image to boot. This comparison ultimately boils down to a branch if
    equal (`beq`) at 2, where if the branch to `.L2` is taken, the `panic()` function
    is called at 4. The problem is if an attacker skips the `beq` at 2, it will fall
    through to the `boot_image()` function at 3. Switching the order of the comparison
    such that skipping the `beq` at 2 would fall through to the `panic()` function
    would be good practice in this example. You may need to work with your compiler
    to get this effect (check `__builtin_expect` in gcc and clang compilers), and
    it’s a good reminder why investigating the actual assembly output is important.
    See the section “Simulation and Emulation” later in the chapter for links to tools
    to help you automated these tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `if` 语句的设计是用来检查是否应该启动一个图像（通过 `IMG_PTR` 指针指向）。在 1 处调用了 `signature_ok()` 函数，该函数会在
    `r0` 寄存器中返回一个特殊的值，指示签名是否允许该图像启动。这个比较最终会通过 2 处的相等分支（`beq`）进行判断，如果分支跳转到 `.L2`，则会在
    4 处调用 `panic()` 函数。问题在于，如果攻击者跳过了 2 处的 `beq`，它将直接跳转到 3 处的 `boot_image()` 函数。将比较的顺序调整为跳过
    2 处的 `beq` 会直接跳转到 `panic()` 函数，在这个例子中是一个更好的做法。你可能需要和你的编译器配合，以实现这个效果（可以查看 gcc 和
    clang 编译器中的 `__builtin_expect`），这也提醒我们为什么调查实际的汇编输出是非常重要的。有关帮助你自动化这些测试的工具，请参见本章后面的“仿真与模拟”部分。
- en: Double- or multi-checking sensitive decisions is also a means to verify control
    flow. Specifically, you implement multiple `if` statements that are logically
    equivalent but contain different operations. In the `double_check()` example in
    the notebook, the memory compare is executed twice and checked twice with slightly
    different logic. If the results of the second comparison disagree with the first,
    we’ve detected a fault.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对敏感决策进行双重或多重检查也是验证控制流的一种手段。具体而言，你实现多个逻辑上等价但包含不同操作的 `if` 语句。在笔记本中的 `double_check()`
    示例中，内存比较操作执行了两次，并用略微不同的逻辑进行检查。如果第二次比较的结果与第一次不一致，我们就发现了故障。
- en: The `double_check()` example is already hardened against single faults, but
    multiple faults timed at exactly the number of cycles between the `memcmp()` invocations
    can skip both checks. Therefore, it’s best to add some *random wait state* in
    between and ideally perform some *non-sensitive operations*, as shown in the `double_check_wait()`
    example in the notebook and also shown in [Listing 14-7](#listing14-7). The non-sensitive
    operations help because, first, a long glitch may corrupt consecutive conditional
    branches, and, second, the side-channel signal of the random wait gives away information
    to the attacker about when sensitive operations are happening. Compared to the
    previous examples, faults that were 100 percent successful before are now less
    likely.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`double_check()` 示例已经针对单一故障进行了加固，但在 `memcmp()` 调用之间恰好间隔一定周期的多个故障可以跳过两次检查。因此，最好在它们之间加入一些
    *随机等待状态*，理想情况下还要执行一些 *非敏感操作*，如笔记本中的 `double_check_wait()` 示例所示，且在 [列表 14-7](#listing14-7)
    中也有展示。非敏感操作的帮助在于：首先，长时间的故障可能会破坏连续的条件分支；其次，随机等待的侧信道信号会向攻击者透露敏感操作发生的时机。与之前的例子相比，曾经
    100% 成功的故障现在变得不太可能。'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 14-7: Double-checking `memcmp` operations with random delays'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-7：通过随机延迟双重检查 `memcmp` 操作
- en: Another simple control flow check is to see whether a sensitive loop operation
    terminates with the correct loop count. The `check_loop_end()` example in the
    companion notebook illustrates this; after the loop ends, the iterator value is
    checked against a “known-good” value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的控制流检查是查看敏感的循环操作是否以正确的循环计数结束。附带的笔记本中的`check_loop_end()`示例演示了这一点；循环结束后，迭代器的值会与一个“已知良好”的值进行检查。
- en: A more convoluted but broader countermeasure is that of *control flow integrity*.
    There are many ways of implementing this, but we give one example with a *cyclic
    redundancy check (CRC)*. CRCs are very fast. The idea is to represent a sequence
    of operations as a sequence of bytes, over which we calculate the CRC. At the
    end, we check whether the CRC matches what we expect, which should always be the
    case, unless a fault changed the sequence of operations. You’ll have to add some
    code to aid in your control flow integrity work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更复杂但更广泛的对策是*控制流完整性*。有很多种实现方式，但我们提供了一个使用*循环冗余检查（CRC）*的示例。CRC非常快速。其理念是将一系列操作表示为字节序列，并对其计算CRC。最后，我们检查CRC是否与预期值匹配，这应该始终成立，除非某个故障改变了操作顺序。你将需要添加一些代码来帮助进行控制流完整性工作。
- en: The companion notebook shows this in `crc_check()`, where several function calls
    update a running CRC. First, we enable a `DEBUG` mode, which causes the final
    CRC to be printed. Next, this CRC is embedded in the code as a check, and debug
    mode is turned off. Now, control flow checking is active. If a function call is
    skipped, the final CRC value will differ. You can verify that it works by setting
    the `FAULT` variable to 0 and 1.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 附带的笔记本中展示了`crc_check()`，其中多个函数调用更新了一个运行中的CRC。首先，我们启用了`DEBUG`模式，这会导致最终的CRC被打印出来。接着，这个CRC被嵌入到代码中作为检查项，并关闭调试模式。现在，控制流检查处于激活状态。如果一个函数调用被跳过，最终的CRC值将不同。你可以通过将`FAULT`变量设置为0和1来验证它是否有效。
- en: You can perform this type of simple control flow checking wherever there are
    no conditional branches. If you have a few conditional branches, you can still
    hard-code a few valid CRC values for each of the paths through the program. Alternatively,
    you also can have local control flow that operates only within one function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在没有条件分支的地方执行这种简单的控制流检查。如果程序中有一些条件分支，你仍然可以为每条路径硬编码一些有效的CRC值。或者，你还可以在仅限于一个函数内部的局部控制流中进行操作。
- en: CRCs are, of course, not cryptographically secure. Cryptographic security isn’t
    very important here, because all we need is a verification code that is hard to
    forge. In this case, forging would mean fault injections to set the CRC to a specific
    value, which we assume is outside of the capabilities of an attacker.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CRC当然并不是加密安全的。加密安全在这里并不重要，因为我们需要的仅仅是一个难以伪造的校验码。在这种情况下，伪造意味着通过故障注入将CRC设置为一个特定值，而我们假设攻击者的能力不足以做到这一点。
- en: Detect and Respond to Faults
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检测并响应故障
- en: By using nontrivial constants, double-checks, or decoy operations, we can start
    building *fault detection*. If we encounter an invalid state, we know it’s caused
    by a fault. This means in `if` statements, we check `condition==TRUE`, then `condition==FALSE`,
    and if we reach the final `else`, we know a fault has occurred. Similarly for
    “switch” statements, the “default” case should always be a fault option. See `memcmp_fault_detect()`
    in the notebook for an example of using nontrivial constants to detect faults;
    it simply checks whether the bits in the nontrivial bits in `diff` and `tmpdiff`
    are correctly set and returns `None` otherwise. Another example is 1 in [Listing
    14-7](#listing14-7), where the first check succeeded but the second one failed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用复杂的常量、双重检查或诱饵操作，我们可以开始构建*故障检测*。如果遇到无效状态，我们就知道是故障引起的。这意味着在`if`语句中，我们检查`condition==TRUE`，然后是`condition==FALSE`，如果最终进入`else`，我们就知道发生了故障。对于“switch”语句来说，“default”情况应该始终是故障选项。请参见笔记本中的`memcmp_fault_detect()`，它通过简单地检查`diff`和`tmpdiff`中非平凡位的比特是否正确设置，如果没有正确设置，则返回`None`。另一个例子是[Listing
    14-7](#listing14-7)中的1，在这个例子中，第一个检查成功，但第二个检查失败。
- en: Similar to decoy operations, we can use any parallel process in software or
    hardware to build generic *fault canaries*. Under normal circumstances, they should
    have some fixed, verifiable output, but under attack, their output changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于诱饵操作，我们可以使用任何并行的软硬件进程来构建通用的*故障金丝雀*。在正常情况下，它们应该有一些固定的、可验证的输出，但在遭受攻击时，它们的输出会发生变化。
- en: In hardware, we can build similar constructs. Additionally, hardware can include
    specific *fault sensors* that detect anomalies in the supply voltage or external
    clock, or even on-die *optical sensors*. These can be effective against specific
    fault types, but a different type of attack can bypass them. For instance, an
    optical sensor will detect a laser pulse, but will not detect a voltage perturbation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件中，我们可以构建类似的结构。此外，硬件还可以包括特定的*故障传感器*，用于检测供应电压或外部时钟的异常，甚至是芯片上的*光学传感器*。这些可以有效应对特定类型的故障，但另一种类型的攻击可能绕过它们。例如，光学传感器会检测激光脉冲，但不会检测电压扰动。
- en: A *fault response* is what to do when a fault is detected. The goal here is
    to reduce the chances of a successful attack to the point where an attacker will
    give up. On the one end of the spectrum, you can implement a program exit, OS
    reboot, or chip reset. These actions will delay an attacker but in principle still
    allow them infinite tries. Somewhere in the middle of the spectrum is signaling
    a backend system to flag this device as suspicious and perhaps disable the account.
    On the other end of the spectrum, you can implement permanent measures like wiping
    keys, accounts, or even burning fuses that disallow the chip from booting up.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*故障响应*是指在检测到故障时应采取的措施。这里的目标是将成功攻击的机会降低到攻击者放弃的程度。在这个光谱的一端，你可以实现程序退出、操作系统重启或芯片重置。这些措施会延迟攻击者，但原则上仍然允许他们进行无限次尝试。光谱的中间部分是向后端系统发出信号，标记该设备为可疑设备，并可能禁用该账户。在光谱的另一端，你可以实施永久性措施，如清除密钥、禁用账户，甚至烧毁熔丝，阻止芯片启动。'
- en: How to respond to faults can be difficult to decide, as it depends strongly
    on how tolerant you are to false positives, whether the system is safety critical,
    and how bad the impact of a compromise really is. In a credit card application,
    it’s perfectly acceptable to wipe keys and disable all functionality when under
    attack. At the same time, it’s not acceptable if this happens at a large scale
    due to false positives. Some balance needs to be struck on how many false positives
    (and faults!) can be had within a certain time frame or lifetime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如何响应故障可能很难决定，因为这在很大程度上取决于你对假阳性的容忍度、系统是否是安全关键型以及妥协带来的影响有多严重。在信用卡应用中，当遭受攻击时，清除密钥和禁用所有功能是完全可以接受的。与此同时，如果由于假阳性导致这种情况发生在大规模范围内，则是不可接受的。需要在一定的时间框架或生命周期内找到一个平衡点，确定可以容忍多少假阳性（和故障！）。
- en: To balance false positives and actual faults, a *fault counter* can be used.
    Initial counter increments are considered false positives, until the counter increments
    to a certain *counter threshold*. At the threshold, we conclude we are under (fault)
    attack. This counter must be nonvolatile, as you don’t want a power-down to reset
    the counter. An attacker would easily abuse this by just resetting between each
    fault attempt.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平衡假阳性和实际故障，可以使用*故障计数器*。初始的计数器增量被视为假阳性，直到计数器增加到一定的*计数阈值*。当达到该阈值时，我们认为系统正在遭受（故障）攻击。这个计数器必须是非易失性的，因为你不希望断电后计数器被重置。攻击者可以通过在每次故障尝试之间重置计数器轻松利用这一点。
- en: Even a nonvolatile counter must be implemented with care. We’ve done attacks
    where we detect the detection mechanism through a side-channel measurement and
    then power off the target before the counter can be updated in nonvolatile storage.
    That attack can be thwarted by incrementing the counter *before* a sensitive operation,
    storing it, performing the sensitive operation, and, only if no faults are detected,
    decrementing the counter again. A power-off will now simply mean the counter was
    increased.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是非易失性计数器也必须小心实现。我们曾经进行过攻击，通过侧信道测量检测到检测机制，然后在计数器更新到非易失性存储之前关闭目标设备。通过在*敏感操作*之前增加计数器，存储计数器值，执行敏感操作，且只有在未检测到故障的情况下再减少计数器，可以抵御这种攻击。现在，关机只意味着计数器已被增加。
- en: The counter threshold depends on your application’s exposure and tolerance for
    false positives; in automotive and aerospace/space applications, faults caused
    by nature are much more common because of the exposure to radiation and strong
    electromagnetic fields. The tolerance depends on the application. In the credit
    card case, wiping keys and effectively disabling functionality is acceptable.
    However, that wouldn’t be acceptable behavior for devices that have a safety function,
    such as medical or automotive devices. It may even not be acceptable from a field
    failure rate perspective for other applications. In that case, a response could
    be to inform a backend covertly that the device may be under attack. At this point,
    what to do is a product design decision, but it often involves trading off security
    for safety, cost, performance, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对策的阈值取决于应用的暴露度和对假阳性的容忍度；在汽车和航空航天/太空应用中，由于暴露于辐射和强电磁场中，由自然引起的故障更加常见。容忍度取决于应用。在信用卡的情况下，清除密钥和有效地禁用功能是可以接受的。然而，这在具有安全功能的设备（例如医疗或汽车设备）中则不可接受。从其他应用的现场故障率角度来看，这甚至可能是不可接受的。在这种情况下，一种应对方法可能是偷偷通知后端设备，表明该设备可能正受到攻击。此时，采取什么措施是一个产品设计决策，但它通常涉及在安全性、可靠性、成本、性能等方面进行权衡。
- en: Verifying Countermeasures
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证对策
- en: The countermeasures in this section will potentially make attacks harder. That’s
    an intentionally weak statement. Unfortunately, we’re not in a clean cryptographic
    world where elegant proofs exist that can reduce to existing and well-studied
    hard mathematical problems. We don’t even have the same kind of heuristic security
    as in cryptography, as countermeasure effectiveness varies from chip type to chip
    type, and sometimes from individual chip to chip. At best, literature analyzes
    countermeasures in a noiseless setting and validates them on (often) simple microcontrollers
    or FPGAs that behave relatively “cleanly.” That’s why—until we get better theoretical
    means to predict countermeasure effectiveness—testing effectiveness on real systems
    is critical.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的对策可能会使攻击更加困难。这是一个故意的弱声明。不幸的是，我们并不处于一个干净的加密世界，在这个世界里，存在能够简化为现有并且经过充分研究的数学难题的优雅证明。我们甚至没有像加密学中那样的启发式安全性，因为对策的有效性因芯片类型而异，有时甚至因单个芯片而异。最好的情况是，文献在无噪声的环境下分析对策，并在（通常）表现相对“干净”的简单微控制器或FPGA上验证它们。这就是为什么——直到我们有更好的理论方法来预测对策的有效性——在实际系统上测试有效性是至关重要的。
- en: Strength and Bypassability
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强度和可绕过性
- en: 'Two main angles need to be analyzed when verifying a countermeasure: strength
    and bypassability. In real-world analogies, *strength* is about how hard it is
    to pry open a door lock, and *bypassability* is about whether you can avoid the
    lock by entering through the window.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 验证对策时需要分析两个主要角度：强度和可绕过性。在现实世界的类比中，*强度*是指撬开门锁有多困难，*可绕过性*是指是否可以通过窗户进入，从而避开锁。
- en: Strength can be measured by turning the countermeasure on and off and then verifying
    the difference in attack resistance. For fault injection, you can represent this
    difference as the decrease in fault probability. For side-channel analysis, you
    can express this difference as the increase in the number of traces until key
    exposure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 强度可以通过开关对策并验证攻击抵抗差异来衡量。对于故障注入，您可以将这种差异表示为故障概率的降低。对于侧信道分析，您可以将这种差异表示为密钥暴露前所需的跟踪次数的增加。
- en: 'See the notebook for an example of testing the strength of the nontrivial constants
    countermeasure of the `memcmp_fault_detect()` function. This function uses the
    top 24 nontrivial constant bits (see also [Listing 14-4](#listing14-4)) as a fault
    detection mechanism. We simulate single-byte faults in the `diff` and `tmpdiff`
    values. We can observe that in roughly 81.2 percent of the cases, the fault is
    successfully detected, and in about 18.8 percent of the cases, there is no fault,
    or it has no observable effect. However, our countermeasure is not perfect: in
    about 0.0065 percent of the cases, the fault manages to flip the bits of `diff`
    or `tmpdiff` such that `memcmp_fault_detect()` concludes that the inputs are equal.
    Though that sounds like a low success rate, if this were a password check, we’d
    expect a successful login after 15,385 fault injections (1/0.000065). If you can
    do one fault per second, you’d be in within five hours.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查看笔记本中的示例，测试`memcmp_fault_detect()`函数中非平凡常数对策的强度。此函数使用顶部24位非平凡常数位（参见[Listing
    14-4](#listing14-4)）作为故障检测机制。我们模拟`diff`和`tmpdiff`值中的单字节故障。我们可以观察到，大约81.2%的情况下，故障被成功检测到，而约18.8%的情况下，则没有故障，或者没有可观察到的效果。然而，我们的对策并不完美：大约0.0065%的情况下，故障会成功翻转`diff`或`tmpdiff`的位，使得`memcmp_fault_detect()`得出输入值相等的结论。虽然这听起来成功率很低，但如果这是一个密码检查，我们期望在15,385次故障注入后成功登录（1/0.000065）。如果每秒能注入一次故障，那么你将在五小时内成功。
- en: 'The second (and more tricky) angle is bypassability: what is the effort in
    going around the countermeasure? To determine that, consider building an attack
    tree (see Chapter 1), which allows you to enumerate other attacks. You may mitigate
    voltage glitches, but an attacker can still do electromagnetic fault injection.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（也是更棘手的）角度是绕过性：绕过对策的难度有多大？为了确定这一点，可以考虑构建一个攻击树（参见第1章），它可以帮助你列举其他的攻击方式。你可能会缓解电压故障，但攻击者仍然可以进行电磁故障注入。
- en: Fighting Compilers
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对抗编译器
- en: Once you verify your countermeasures a few times, you’ll find they sometimes
    are completely ineffective, which can be due to bad coverage (for example, you
    plugged one leak where there were many). What also can happen is that your toolchain
    optimizes out your countermeasures because they don’t have any side effects. For
    instance, double-checking a value is the logical equivalent of checking a value
    once, so an optimizing compiler cleverly removes your double-check. Similar situations
    can happen during synthesizing hardware, where duplicated logic may be optimized
    out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你验证了几次你的对策，你会发现它们有时完全无效，这可能是由于覆盖不完全（例如，你只堵住了一个漏洞，而实际上有很多漏洞）。还有一种情况是，你的工具链可能会优化掉你的对策，因为它们没有副作用。例如，双重检查一个值与检查一次该值在逻辑上是等价的，因此优化编译器会巧妙地去除你的双重检查。在硬件综合过程中，也会发生类似的情况，其中重复的逻辑可能会被优化掉。
- en: If you use the `volatile` keyword on variables in C or C++, this can help avoid
    optimizing away countermeasures. With `volatile`, the compiler may not assume
    that two reads of the same variable yield the same value. Therefore, if you check
    a variable twice in a double-check, it will not be compiled out. Note that this
    generates more memory accesses, so if a chip is particularly sensitive to memory
    access glitches, it’s a double-edged sword. You can also use `__attribute__((optnone))`
    to turn off optimizations for particular functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在C或C++中的变量上使用`volatile`关键字，可以帮助避免对策被优化掉。使用`volatile`时，编译器不会假设对同一个变量的两次读取会得到相同的值。因此，如果你对一个变量进行双重检查，它将不会被编译器去除。请注意，这会产生更多的内存访问，因此，如果芯片对内存访问故障特别敏感，这就是一把双刃剑。你还可以使用`__attribute__((optnone))`来关闭特定函数的优化。
- en: The code in [Listing 14-6](#listing14-6) is another example where compiler optimizations
    will result in changes in your fault countermeasure. The compiler may choose to
    reorder the assembly code generated, which will lead to a fall-through condition
    if an attacker skips the single branch instruction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-6](#listing14-6)中的代码是另一个例子，编译器优化将导致你的故障对策发生变化。编译器可能会选择重新排序生成的汇编代码，如果攻击者跳过了单一的分支指令，就会导致发生“掉落”条件。'
- en: There is some research on making compilers output code that is more resistant
    to faults, which is an obvious solution direction; see Hillebold Christoph’s thesis
    “Compiler-Assisted Integrity Against Fault Injection Attacks.” Blanket application
    of such techniques are not be desirable for performance reasons.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有一些研究致力于使编译器输出更能抵抗故障的代码，这显然是一个解决方向；参见Hillebold Christoph的论文《编译器辅助的完整性防御抗故障注入攻击》。由于性能原因，这类技术的全面应用并不理想。
- en: Simulation and Emulation
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仿真与模拟
- en: Use of simulators is also important during verification. With hardware design,
    the cycle from initial design to first silicon may take years. Ideally, we want
    to be able to “measure” leakage well before silicon, when there is still time
    to fix things. See “Design Time Engineering of Side Channel Resistant Cipher Implementations”
    by Alessandro Barenghi et al.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证过程中使用仿真器也非常重要。对于硬件设计来说，从初步设计到首次硅片的周期可能需要数年。理想情况下，我们希望在硅片出现之前就能“测量”泄漏，这时还有时间进行修正。请参见Alessandro
    Barenghi等人的论文《侧信道抗性密码实现的设计时工程》。
- en: 'Similar research is ongoing on fault injection: by simulating various instruction
    corruptions, we can test whether single fault injection points exist. For more
    information, see “Secure Boot Under Attack: Simulation to Enhance Fault Injection
    and Defenses” by Martijn Bogaard and Niek Timmers. Riscure has an open source
    CPU emulator that implements instruction skipping and corruption at [https://github.com/Riscure/FiSim/](https://github.com/Riscure/FiSim/)
    that you can try to test your software countermeasures in. We recommend you try
    out this emulator—you can quickly learn which countermeasures work well and which
    won’t. More importantly, you’ll learn which countermeasure combinations are required
    to get down to a low fault count. Getting it down to zero faults is not easy!'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的故障注入研究正在进行中：通过模拟各种指令损坏，我们可以测试是否存在单点故障注入。更多信息，请参见Martijn Bogaard和Niek Timmers的《攻击下的安全启动：通过仿真增强故障注入与防御》。Riscure有一个开源的CPU仿真器，实施指令跳过和损坏，地址为[https://github.com/Riscure/FiSim/](https://github.com/Riscure/FiSim/)，你可以尝试测试你的软件反制措施。我们建议你试用这个仿真器——你可以迅速了解哪些反制措施有效，哪些无效。更重要的是，你会发现哪些反制措施组合能将故障率降到较低水平。将故障率降到零并不容易！
- en: Verification and Enlightenment
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证与启蒙
- en: Countermeasure strength is something you can measure yourself; for countermeasure
    bypassability, it’s best to engage someone who wasn’t involved in the design.
    Countermeasures can be regarded as a security system, and as Schneier’s law states,
    “Any person can invent a security system so clever that he or she can’t imagine
    a way of breaking it.”
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反制措施的强度，你可以自己测量；对于反制措施的绕过性，最好找一个没有参与设计的人来进行评估。反制措施可以被视为一种安全系统，正如施奈尔定律所说：“任何人都能发明出一种足够巧妙的安全系统，以至于他或她无法想象任何破解的方法。”
- en: On this topic, allow us a small excursion into what we’ll call the *four stages
    of security enlightenment*. It is our completely unscientific observation and
    subjective experience of how people generally respond to the notion of hardware
    attacks and how to solve them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个话题上，允许我们稍微偏离一下，探讨一下我们所称的*安全启蒙的四个阶段*。这是我们完全不科学的观察和主观经验，讲述人们通常如何回应硬件攻击的概念以及如何解决这些问题。
- en: 'The *first stage* is basic denial of the possibility or practicality of side-channel
    or fault attacks. The issue here is that basic software engineering assumptions—assumptions
    you’ve experienced and heard about all the time—can be broken: the hardware actually
    isn’t executing instructions that it’s fed, and it’s telling the world all about
    the data it’s processing. It’s like finding out the world isn’t flat.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一阶段*是基本否认侧信道或故障攻击的可能性或实用性。问题在于，基本的软件工程假设——这些假设你一直在体验和听到——是可以被打破的：硬件实际上并没有执行它接收到的指令，并且它正将其处理的数据公之于众。这就像发现世界不是平的。'
- en: Once the first stage is passed, the *second stage* is that countermeasures are
    easy or unbreakable. It’s the natural response to not yet grasp the full depth
    of the security issues, the cost of the countermeasures, or that attackers are
    adaptive creatures. It usually takes some countermeasures being broken (or some
    “yeah, but if you do that then…” conversations with a security expert) before
    moving on to the next stage, which is *security nihilism*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过了第一阶段，*第二阶段*就是反制措施容易或是无法被打破的。这是因为尚未完全理解安全问题的深度，反制措施的成本，或者攻击者是具有适应性的生物。通常需要一些反制措施被突破（或与安全专家进行一些“是的，但如果你这么做……”的对话）才能进入下一个阶段，也就是*安全虚无主义*。
- en: Security nihilism is the idea that everything is broken, so there’s nothing
    we can do anyway to prevent attacks. It’s true that everything can be broken,
    given a motivated and well-resourced attacker—and that is the crux. There are
    a limited number of attackers, and they have varying motivation and resources.
    As it stands, it’s still much easier to clone a magstripe credit card than to
    perform a side-channel attack on a credit card. As James Mickens said, “If your
    threat model includes the Mossad, you’re still gonna be Mossad’ed upon.” But,
    if you’re not a target for the Mossad, you probably will not be Mossad’ed upon.
    They also need to prioritize.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安全虚无主义是指一切都是脆弱的，所以我们无论如何都无法防止攻击。确实，任何东西都可以被破坏，只要有动机和充足资源的攻击者——这就是关键所在。攻击者数量有限，且他们的动机和资源各不相同。就目前而言，复制一张磁条信用卡要比对一张信用卡进行旁道攻击容易得多。正如James
    Mickens所说：“如果你的威胁模型中包括摩萨德，你最终还是会被摩萨德击败。”不过，如果你不是摩萨德的目标，你大概率不会被摩萨德盯上。他们也需要做出优先级排序。
- en: 'The fourth and final stage is *enlightenment*: understanding that security
    is about risk; risk will never be zero, but risk isn’t about the worst case happening
    all the time. In other words, it’s about making an attack as uninteresting for
    an attacker as feasible. Ideally, countermeasures raise the bar to the point where
    the cost of an attack isn’t worth the payoff. Or often more realistically, countermeasures
    make another product more interesting to attack than yours. Enlightenment is about
    realizing the limitations of countermeasures, and making risk-based tradeoffs
    as to which countermeasures to include. It’s also about being able to sleep again
    at night.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个也是最后一个阶段是*启蒙*：理解安全性与风险相关；风险永远不可能为零，但风险并不意味着最坏的情况总是发生。换句话说，安全性是关于让攻击者尽可能对攻击失去兴趣。理想情况下，防御措施应该提高门槛，直到攻击的成本超过了回报。或者更现实的说，防御措施使得另一个产品比你的更有攻击吸引力。启蒙是意识到防御措施的局限性，并在包含哪些防御措施时做出基于风险的权衡。这也是关于能够再次安心入睡。
- en: Industry Certifications
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行业认证
- en: Certification for side-channel analysis and fault injection resistance has been
    available through various organizations, which we’ll list in this section. We
    know from Chapter 1 that security isn’t binary, so what do industry certifications
    mean if an unbreakable product doesn’t exist?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 针对旁道分析和故障注入抗性，已经通过多个组织提供认证，我们将在本节中列出。我们从第一章知道，安全性不是二元的，那么如果没有不可打破的产品，行业认证意味着什么呢？
- en: The goal of these certifications is for vendors to demonstrate to third parties
    that they have some level of *assurance* of some level of *attack resistance*.
    It also means that only for a limited time; a certificate that’s a few years old
    obviously does not include attacks most recently discovered.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些认证的目标是让供应商向第三方展示他们在某种程度上具有*保障*和*抗攻击能力*。这也意味着认证只在有限的时间内有效；一张几年前的证书显然不包括最近发现的攻击。
- en: Let’s briefly consider attack resistance first. A product passes *Common Criteria
    PP-0084 (CC)/EMVCo* certification if it demonstrably has all the security functionality
    required, and the certifying lab cannot show an attack path exists that has fewer
    than 31 points in the *JIL score* (see “Scoring Hardware Attack Paths” in Chapter
    1). An attack path is only an attack path if it ends with the compromise of a
    well-defined asset, such as a key. That means both positive and negative testing
    is used, establishing “does it do what it should do” as well as “does it not do
    what it shouldn’t do.” The latter is very important when the adversary is intelligent
    and adaptive.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先简要考虑一下抗攻击能力。如果一个产品通过了*通用准则PP-0084 (CC)/EMVCo*认证，说明它具备所有必要的安全功能，并且认证实验室无法证明存在一个攻击路径，其*JIL评分*（参见第一章的“硬件攻击路径评分”）少于31个点。攻击路径只有在最终导致一个定义明确的资产（如密钥）遭到破坏时，才算作攻击路径。这意味着使用了正向测试和负向测试，既要确认“它做了它应该做的事”，也要确认“它没有做它不应该做的事”。后一项在面对聪明且具有适应能力的对手时尤为重要。
- en: Effectively, the JIL scoring limits the time, equipment, knowledge, personnel,
    and number of (open) samples that can be used for the attack. Whatever attacks
    a lab knows about or can develop are relevant for CC/EMVCo, as long as the scoring
    is within 31 points. See the latest version of the JIL document titled “Application
    of Attack Potential to Smartcards and Similar Devices” (which is available publicly
    online) for a good reference on how this scoring is done. A certificate tells
    you that the lab was unable to identify any attack that scored less than 31 points.
    Labs won’t even test whether attacks of 31 points and higher work. Going back
    to our earlier point about unbreakable products, the point system means you may
    still be able to find attacks at the high ratings. A great example is “Deconstructing
    a ‘Secure’ Processor,” by Christopher Tarnovsky, presented at Black Hat 2010,
    where he impressively goes beyond the effort a lab would put into a certification.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider levels of assurance, which is the aspect of “how *sure*
    are we it resists the relevant attacks.” On the one hand, you can read the product
    datasheet and see “side channel countermeasures,” and you can conclude that’s
    true based on the sheet, for a *low* level of assurance. Or, you can spend a year
    testing everything and mathematically proving lower bounds on the amount of leakage
    on your special protocol, and then you have a *high* level of assurance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: For CC, the level of assurance is defined as the *evaluation assurance level
    (EAL)* ; for smart cards, you’ll often see EAL5, EAL5+, EAL6, or EAL6+. We won’t
    go in details here, but just make sure you outsmart your friends by knowing EAL
    doesn’t mean “how secure it is.” Instead, it means “how sure am I of the security?”
    (And if you want to be supersmart, know that + means a few extra assurance requirements.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of *labs*, the labs must prove they are capable of state-of-the-art
    attacks, which is verified by the standards bodies. Additionally, for CC, labs
    must participate and share new attacks in the *Joint Hardware Attack Subgroup
    (JHAS)*. The JHAS maintains the JIL document referred to earlier and updates it
    with new attacks and scores. This way, the standard does not have to prescribe
    what attacks must be performed, which is good, because hardware security is a
    constantly moving field. Because the attacks are in the JIL, it’s mainly up to
    labs to pick the relevant attacks for a product. This comes at the “cost” of variability
    in the labs’ approach. The issue with the latter is that vendors can pick labs
    with a track record of finding fewer issues, so labs essentially have competitive
    pressure to find less. It’s up to the standards body to make sure labs still meet
    the bar.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach to CC was adopted by *GlobalPlatform* for its *Trusted Execution
    Environment (TEE)* certification. The number of points needed is 21, lower than
    that of smart cards, which means that most hardware attacks are considered relevant
    only if they are trivially scalable, such as through software means. For example,
    if we use a fault injection or side-channel attack to dump a master key that allows
    us to hack any similar device, it is considered a relevant attack. If we have
    to do a side-channel attack for every device we want to break, and it takes a
    month for each device to get the key out, it is considered out of certification
    scope, simply because the attack rating will be more than 21.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Arm has a certification program called *Platform Security Architecture (PSA)*.
    The PSA has several levels of certification. Level 3 includes physical attacks
    such as side-channel and fault injection resistance. PSA in general is designed
    to target IoT and embedded platforms. As such, it may be more suited to general-purpose
    platforms, but if you are building products with general-purpose microcontrollers,
    the PSA level is the most likely one you will see such devices certified to. At
    lower levels, PSA also helps fix some of the basic problems we still see today,
    such as a debug interface that’s left open.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is that of *ISO 19790*, which is aligned with the US/Canadian
    standard *FIPS 140-3* that focuses on cryptographic algorithms and modules. The
    *Cryptographic Module Verification Program (CMVP)* validates whether modules satisfy
    the FIPS 140-3 requirements. The approach here is heavily biased toward *verification*—that
    is, making sure the product conforms to the security functional requirements.
    In our earlier words, it’s biased toward testing strength rather than bypassability.
    The standard prescribes the types of tests that are to be performed on products,
    which aides reproducibility among labs. The issue is that attacks evolve quickly,
    and “standard sets of tests defined by a government body” do not. FIPS 140-2 (the
    predecessor of FIPS 140-3) was published in 2001 and didn’t include a way to validate
    side-channel attacks. In other words, a product can be FIPS 140-2 certified, meaning
    that the AES engine performs proper AES encryptions, the keys are accessible only
    by authorized parties, and so on, but also that the keys could leak in 100 side-channel
    traces, because SCA is not in the testing scope for FIPS 140-2\. It took 18 years
    for its successor FIPS 140-3 to become effective, which does include side-channel
    testing in the form of the *test vector leakage assessment (TVLA)*. With TVLA
    the testing is precisely specified, but too much cleverness in filtering, and
    so on, on the side of the attacker is excluded. This means “passing” the testing
    doesn’t mean there is no side-channel leakage, only that the most straightforward
    of leakage was not detected.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Yet another approach to side-channel leakage certification is explored in *ISO
    17825*, which again takes some of the TVLA testing we described in Chapter 11
    and standardizes it. The eventual goal may be to achieve a “datasheet figure”
    for leakage. Like ISO 19790, the ISO 17825 testing isn’t designed to perform the
    same work as Common Criteria. With Common Criteria, the question is more broadly
    looking at attack resistance, while ISO 17825 attempts to provide a method of
    comparing specific side-channel leakage with automated methods. This means that
    ISO 17825 isn’t supposed to provide a general security metric across a range of
    attacks, but it’s useful when you are trying to understand the impact of enabling
    certain side-channel countermeasures. In other words, it measures countermeasure
    strength, not bypassability.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: ISO/SAE 21434 is an automotive cybersecurity standard that is mandated in the
    EU per July 2022 for new vehicle types. It specifies *security engineering* requirements,
    and requires hardware attacks to be considered. This brings all of the attacks
    we learned about in this book into scope for the automotive space! When certifications
    hit marketing departments, you’ll find that “it’s secure!” is conflated with “it’s
    certified up to a certain assurance level against this limited set of threats.”
    This is understandable because the latter is a mouthful. However, it means it’s
    up to you to understand what the certification on a product actually means and
    how that fits your threat model. For example, if you’re trying to validate that
    a given system is generally resistant to various advanced attacks, someone offering
    ISO 17825 testing won’t have anywhere near the scope you require. But if you go
    only by the standard title (“Testing methods for the mitigation of noninvasive
    attack classes against cryptographic modules”) and a bit of marketing material
    the test provider gives you, you may easily be seduced into believing the value.
    Of course, there is a significant cost and effort difference as well between different
    certifications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Certification has helped (at least) the smart card industry reach high levels
    of side-channel attack and fault injection resistance. No one will have an easy
    time breaking a modern, certified card. At the same time, it’s imperative to look
    at what’s behind a certification, as there are always limits to what the certification
    means.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Getting Better
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number of different training courses are available on learning side-channel
    analysis and fault injection. When selecting a course, we recommend investigating
    the syllabus up front. This book covers the basics and theory, and if you sufficiently
    grasp them, it’d be better to select a course that focuses on the practical matters.
    The entire area of hardware hacking has people coming from all sorts of backgrounds.
    Some will be coming at it having done ten years of low-level chip design but never
    having dealt with finite field arithmetic. Others may have a PhD in theoretical
    mathematics but have never touched an oscilloscope before. So when you approach
    a topic, be sure to figure out the most valuable background for you. Whether you
    want more information on cryptography, signal processing, or the math behind DPA,
    find a course that focuses on those topics. Similarly, some training courses are
    more offense than defense focused, so find the one that matches your needs best.
    (Full disclosure: both authors’ companies run training courses.)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: You can also visit talks at conferences and learn from and discuss with people
    already in the field. You’ll find them at academic conferences, such as CHES,
    FDTC, COSADE, but also more (hardware) hacker-oriented conferences like Black
    Hat, Hardwear.io, DEF CON, CCC, and REcon. Definitely consider this an invite
    to say “Hi!” when you run into us at one of these events.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Attending a training course and attending events are also a great ways to learn
    new things outside of your background experience while sharing your unique background
    with others. You might have spent years working on the design of analog ICs, and
    we bet you will have some insight about how voltage spikes might be propagating
    inside a die that someone who has only worked with FPGAs won’t have.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we described a number of countermeasure strategies. Each countermeasure
    can be a building blocks of a “secure enough” system, and none of them will be
    individually sufficient. There’s also a number of caveats in building countermeasures,
    so make sure to verify they work as intended at each stage during development.
    We touched upon the professional side of verification through various certification
    strategies.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we talked a bit about how to keep improving in this field. The best
    teacher is still practice. Start with simple microcontrollers. For example, try
    something clocked under 100 MHz that you fully control, so no OS throws interrupts
    and multitasking at you. Next, start building countermeasures and see how they
    hold up to your attacks, or better yet, get a friend to build their own countermeasure,
    and try to break each other’s. You’ll find that testing strength is easier than
    bypassability. Once you’re pretty comfortable attacking and defending, start complicating
    things: faster clocks, more complex CPUs, less control over the target application,
    less knowledge of the target application, and so on. Realize you are still learning;
    a new target may make you feel like a beginner again. Keep going at it; ultimately
    patience leads to luck, and luck leads to skill. Good luck on your journey!'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们聊了一下如何在这个领域中持续进步。最好的老师仍然是实践。首先从简单的微控制器开始。例如，尝试使用时钟频率低于100 MHz的设备，并且完全由你控制，这样就没有操作系统向你抛出中断和多任务处理。接下来，开始构建反制措施，并观察它们如何抵御你的攻击，或者更好的是，找个朋友为自己构建反制措施，然后互相试图攻破对方的防线。你会发现，测试防御强度比绕过性要容易得多。一旦你在攻击和防守方面都比较得心应手，就开始增加难度：更高的时钟频率，更复杂的CPU，目标应用的控制力下降，对目标应用的了解减少，等等。意识到你仍在学习中；一个新的目标可能让你重新感到像个初学者。继续努力，最终耐心会带来运气，运气会带来技巧。祝你在这条路上好运！
