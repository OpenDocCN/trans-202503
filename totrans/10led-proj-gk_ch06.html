<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>Project 6: Automated Infrared Remote Control by Kaas Baichtal</title>
    <link href="../styles/9781593278472.css" rel="stylesheet" type="text/css"/>
    <link href="../68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_110"/><span class="big">6</span><br/>Automated Infrared Remote Control by Kaas Baichtal</h2>
<p class="ch-sub"><span epub:type="pagebreak" id="page_111"/>In this project, you’ll use infrared LEDs and a Raspberry Pi to automatically operate a remote controlled device.</p>
<div class="image"><img src="../images/f0111-01.jpg" alt="image"/></div>
<h3 class="h3" id="lev85"><span epub:type="pagebreak" id="page_112"/><strong>HOW IT WORKS: INFRARED LIGHT</strong></h3>
<p class="noindent">In the early 1800s, astronomer William Herschel discovered that sunlight split into colors by a prism is noticeably warmer the closer it is to the red end of the spectrum. However, the area of the spectrum beyond red is even warmer. It turns out there is another, warmer color of light—called <em>infrared (IR)</em>—which humans can feel but not see.</p>
<p class="indent">Infrared means “below red,” so named because it has a lower <em>frequency</em> (waves per second) than visible red light. The electromagnetic spectrum chart in <a href="ch06.xhtml#ch06fig1">Figure 6-1</a> shows the relationships between all radiant energies, including light, radio waves, microwaves, gamma rays, and X-rays.</p>
<div class="image"><a id="ch06fig1"/><img src="../images/f0112-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 6-1:</strong> The electromagnetic spectrum</p>
<h4 class="h4" id="lev86"><strong>Infrared LEDs</strong></h4>
<p class="noindent">Infrared LEDs have been around since the early 1960s. In fact, they were invented a year or two before LEDs that emit visible light. <a href="ch06.xhtml#ch06fig2">Figure 6-2</a> shows an example of an infrared LED.</p>
<div class="image"><a id="ch06fig2"/><img src="../images/f0112-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 6-2:</strong> An infrared LED. The larger section visible inside corresponds to the negative lead.</p>
<p class="indent">Like all diodes, an LED is a semiconductor. Current passes through a diode more easily in the forward direction than it would in reverse. It also emits a small quantity of electromagnetic radiation as it moves forward through the diode. Where this emission lies on the electromagnetic spectrum depends upon what materials were <span epub:type="pagebreak" id="page_113"/>used to manufacture the diode. Regular diodes made of silicon and germanium do not tend to emit light, while other semiconductor materials can emit various colors of visible light, as well as ultraviolet and infrared. Infrared LEDs are usually made with gallium arsenide (GaAs) or aluminum gallium arsenide (AlGaAs).</p>
<p class="indent">When an LED is reverse-biased (hooked up backward), no light will be produced.</p>
<h4 class="h4" id="lev87"><strong>Line-of-Sight Communications</strong></h4>
<p class="noindent">Infrared LEDs have dozens of important applications, including data communications. Circuits that send data using IR LEDs are called <em>transmitters</em>. Circuits that receive the infrared light and convert it back to data are called <em>receivers</em>.</p>
<p class="indent">Because infrared components transmit and receive light, they need to be able to “see” each other to successfully communicate (see <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>). This is commonly referred to as <em>line-of-sight communications</em>. Nothing opaque can be in the way, and the narrower the light beam the transmitting LED emits, the more precisely the transmitter needs to be aimed at its receiver. There are ways to steer or reflect light in non-line-of-sight directions when necessary, however—for example, through the use of mirrors, fiber optics, and light pipes.</p>
<div class="image"><a id="ch06fig3"/><img src="../images/f0113-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 6-3:</strong> This IR remote has a hole for its transmitter’s LED to beam out, while the air conditioner it controls has a small red window to allow IR light to shine in upon its receiver.</p>
<p class="indent">While it may seem like a disadvantage, the line-of-sight nature of infrared communications actually has its pluses: the IR transmissions are unlikely to interfere with other IR communications happening in completely different rooms or buildings. Anybody who has ever had their ceiling fans turned on and off by a neighbor’s radio remote will be able to appreciate that!</p>
<p class="indent">For this project we will use simple line-of-sight communications, orienting the IR transmitter attached to our Raspberry Pi so that it can be seen by the air conditioner without problems.</p>
<h4 class="h4" id="lev88"><span epub:type="pagebreak" id="page_114"/><strong>Data Transmission</strong></h4>
<p class="noindent">In the simplest possible sense, an IR transmitter communicates data by turning its LED on and off. For example, it would be possible to communicate using Morse code with an LED. However, several complicated languages and systems, called <em>protocols</em>, have been developed specifically for data communication over IR. Over the decades, more and more information has needed to be conveyed through the messaging sent by remotes. This has sparked many inventive ways of increasing the signal-to-noise ratio, error correction, and data carrying capacity. Here’s an overview of some of the things that might be included in a protocol specification:</p>
<ul>
<li class="noindent">The frequency of infrared light used</li>
<li class="noindent">The carrier frequency or frequencies used</li>
<li class="noindent">Number of devices supported</li>
<li class="noindent">Number of commands per device</li>
<li class="noindent">Number of bits used in encoding</li>
<li class="noindent">The encoding procedure</li>
<li class="noindent">The key-to-code mapping</li>
<li class="noindent">The data rate, which may be variable</li>
<li class="noindent">Modulation schemes of the transmitted pulses and/or the spaces between them</li>
</ul>
<p class="indent">Before the advent of programmable microcontrollers, transmitters and receivers needed additional circuitry to accomplish everything a protocol required. A general lack of compatibility led to the development of “universal remotes,” which either have the payloads of many other remotes preprogrammed into them, or simply record the signals of other remotes and parrot them back upon command. This latter is the procedure we’ll be using in this project to begin “teaching” the Raspberry Pi how to control the A/C, using a USB IR Toy (see <a href="ch06.xhtml#ch06fig4">Figure 6-4</a>). The USB IR Toy has a transmitter and receiver on the same circuit board, so we can use it to record the signals from the air conditioner’s remote as well as mimic them.</p>
<div class="image"><span epub:type="pagebreak" id="page_115"/><a id="ch06fig4"/><img src="../images/f0115-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 6-4:</strong> The USB IR Toy</p>
<h3 class="h3" id="lev89"><strong>GET THE PARTS</strong></h3>
<p class="noindent">The instructions in this project will use the equipment listed here. New to electronics projects? Stick with this parts list and I’ll make it easy!</p>
<p class="indent">If you have more experience and are able to modify the steps, feel free to substitute your own transmitter, receiver, computer, OS, and A/C or other item to be controlled.</p>
<ul>
<li class="noindent">USB IR transmitter and receiver (I used a Dangerous Prototypes USB IR Toy 2, which is available either prebuilt or in kit form. The prebuilt ones are available at Seeed Studios with SKU #102990037; <em><a href="https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html">https://www.seeedstudio.com/USB-Infrared-Toy-v2-p-831.html</a></em>.)</li>
<li class="noindent">USB cable with A and mini-B connectors (for example, Adafruit P/N 260)</li>
<li class="noindent">Raspberry Pi (Any model will work, but it will need to have Raspbian installed via NOOBS—see “<a href="intro.xhtml#lev12">Getting Started with the Raspberry Pi</a>” on <a href="intro.xhtml#page_13">page 13</a> for instructions on setting that up.)</li>
<li class="noindent">An air conditioner that has an IR remote (I used a Haier HWR08XC7.)</li>
</ul>
<p class="indent">The rest of this section deals with modifications, so if you’re using the parts listed, feel free to skip to “<a href="ch06.xhtml#lev90">Build It</a>” on <a href="ch06.xhtml#page_117">page 117</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_116"/>Any computer that has a USB port for the IR Toy 2 and is capable of running LIRC (Linux Infrared Remote Control) will work for this project. I chose a Raspberry Pi because I could get one bundled with a case, power supply, and NOOBS SD card cheaply on Amazon. Raspbian is the distribution being used for other projects in this book, so that’s what I’ll be providing instructions for, but everything we do here should be modifiable to work on your machine.</p>
<p class="indent">Whatever you use, you’ll need the LIRC package (<em><a href="http://www.lirc.org">http://www.lirc.org</a></em>/) for this project. LIRC is handy for this kind of task because 1) it can be installed on many flavors of Unix-like and Windows OSes; 2) it allows multiple programs to listen to one receiver; 3) it comes with helpful tools for memorizing remote controls and sending commands manually; and 4) its website has plenty of hardware compatibility info, so you can easily adapt this project to work with other hardware.</p>
<p class="indent">For example, there are lots of preconfigured <em>.conf</em> files for different handheld remotes, located at <em><a href="http://lirc-remotes.sourceforge.net/remotes-table.html">http://lirc-remotes.sourceforge.net/remotes-table.html</a></em>. In theory, you can control any device that works with one of those listed IR remotes without doing any coding or even having to scrabble in your couch cushions to find the remote. But few of those preconfigured remotes are intended for air conditioners, so for this project we’ll just create our own <em>.conf</em> file and not stress about finding a matching one.</p>
<p class="indent">In fact, since we’ll be creating our own <em>.conf</em> file anyway, you could use any IR-controllable device and the procedure will be exactly the same, as long as you still have its physical remote to imitate the codes from. Xbox? Roomba? DVD player? No problem!</p>
<p class="indent">If you intend to buy an A/C unit for the project, just go for one that, besides having the IR capability, meets your cooling needs and is a common everyday brand where you live.</p>
<p class="indent">For my IR transmitter and receiver, I chose the USB IR Toy 2 by Dangerous Prototypes for three reasons: it’s fully compatible with LIRC; it’s relatively inexpensive at $20 for a preassembled version (or almost nothing if you want to assemble it yourself); and finally, since it has both a transmitter and a receiver, I only have to deal with one device. Although actually controlling the air conditioner requires just a transmitter, we need the receiver as well since we’re creating our own initial configuration files.</p>
<h3 class="h3" id="lev90"><span epub:type="pagebreak" id="page_117"/><strong>BUILD IT</strong></h3>
<p class="noindent">Let’s make the project! The following steps assume you already have an assembled IR transmitter and receiver, A/C unit and remote, and <span class="literal">sudo</span> root privileges on your Pi. (Raspbian provides the “pi” user for this purpose.)</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>At the time of this writing, there were also user-contributed versions v23 and v24, which could be found in the forums on the website.</em></p>
</div>
<ol>
<li class="noindent"><p class="list"><strong>Upgrade your USB IR Toy 2’s firmware.</strong> Follow the directions on the Dangerous Prototypes website’s USB IR Toy 2 page (<em><a href="http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update">http://dangerousprototypes.com/docs/USB_IR_Toy_firmware_update</a></em>) to upgrade its firmware to the latest version, which was officially v22 at the time of this writing. Performing a firmware upgrade could save you a lot of trouble depending on which revision your unit shipped with, as some earlier versions did not support transmitting!</p>
<p class="indent">You can upgrade your firmware via the USB port using almost any computer. After downloading and unzipping the firmware upgrade package from the Dangerous Prototypes website, follow the instructions provided on the site. The procedure and results will vary depending on your setup, so I won’t go into a lot of detail except to say that on my Windows 7 desktop I had to manually install the driver included in the <em>inf-driver</em> subdirectory, a detail not mentioned in the instructions.</p>
<p class="indent">Once the computer recognizes the USB IR Toy 2, run the <em>update-USBIRToy.v22.bat</em> file in the firmware subdirectory and, when it asks, give it the port number assigned to your device (see Note for details).</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you did not receive a COM port, and can’t find it listed as a COM port in your Device Manager or equivalent, just press <small>ENTER</small> when you get to this question. You only need the port number if you were automatically assigned one.</em></p>
</div>
<p class="indent">I found it helpful to pause momentarily every time I plugged in or changed anything, as Windows re-recognized the USB IR Toy 2 more than once during this process, and the interruption caused the firmware updater to not find the device. Once the device was successfully recognized, the firmware upgrade process was quick and easy.</p></li>
<li class="noindent"><p class="list"><strong>Upgrade the Raspberry Pi’s OS and firmware.</strong> I recommend making sure your operating system is 100% patched/upgraded and the Raspberry Pi has also had its firmware fully updated to the latest version before you begin.</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_118"/><strong>Check LIRC’s dependencies.</strong> Now make sure your system has everything LIRC requires. The list can be found at <em><a href="http://www.lirc.org/html/install.html#dependencies">http://www.lirc.org/html/install.html#dependencies</a></em>. I checked by entering the following lines on the Linux command line:</p>
<p class="programs">$ <span class="codestrong">which make</span><br/>$ <span class="codestrong">which gcc</span><br/>$ <span class="codestrong">which g++</span><br/>$ <span class="codestrong">which ld</span><br/>$ <span class="codestrong">which modinfo</span><br/>$ <span class="codestrong">which pkg-config</span><br/>$ <span class="codestrong">which xsltproc</span></p>
<p class="indent">Each command should produce the full path of the item in question. If there is no response, the item is missing from the system. Two more checks you should perform are:</p>
<p class="programs">$ <span class="codestrong">dpkg -l python3-yaml</span><br/>$ <span class="codestrong">dpkg -l raspberrypi-kernel-headers</span></p>
<p class="indent">If you have these, you should see some information about the package in question; if you don’t, you should see a complaint saying the packages were not found. My fresh NOOBS install of Raspbian lacked both of these latter packages as well as xsltproc from the preceding list, so I installed the necessary items as follows:</p>
<p class="programs">$ <span class="codestrong">sudo apt-get install xsltproc python3-yaml \</span><br/><span class="codestrong">raspberrypi-kernel-headers</span></p></li>
<li class="noindent"><p class="list"><strong>Install LIRC.</strong> Next, download the LIRC source, which can be obtained on SourceForge at <em><a href="https://sourceforge.net/projects/lirc/files/LIRC/">https://sourceforge.net/projects/lirc/files/LIRC/</a></em>. Choose the directory with the most recent version of the code, save the <em>.tar.gz</em> file for that version, and then go to the save location. To extract and install LIRC, enter the following on the Linux command line, inserting your correct version number:</p>
<p class="programs">$ <span class="codestrong">tar xjf lirc-<span class="codestrongitalic">version</span>.tar.bz2</span><br/><br/>$ <span class="codestrong">cd lirc-<span class="codestrongitalic">version</span></span><br/>$ <span class="codestrong">./configure</span><br/>$ <span class="codestrong">make</span><br/>$ <span class="codestrong">sudo make install</span><br/>$ <span class="codestrong">sudo ldconfig</span></p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_119"/><strong>Connect the USB IR Toy 2.</strong> Now, power down your Pi, then plug in the USB IR Toy 2. Make sure to power the Pi down every time you plug and unplug your Toy, or you risk blowing stuff up! After rebooting your machine, look in the <span class="literal">dmesg</span> logfile to see if the Pi found your device:</p>
<p class="programs">$ <span class="codestrong">dmesg | grep –e usb</span></p>
<p class="indent">You should see output like this:</p>
<p class="programs">[    2.982746] usb 1-1.2: new full-speed USB device number 4 using dwc_otg<br/>[    3.090984] usb 1-1.2: New USB device found, idVendor=04d8, idProduct=fd08<br/>[    3.092965] usb 1-1.2: New USB device strings: Mfr=1, Product=2, SerialNumber=3<br/>[    3.096209] usb 1-1.2: Product: CDC Test<br/>[    3.097827] usb 1-1.2: Manufacturer: Dangerous Prototypes<br/>[    3.099458] usb 1-1.2: SerialNumber: 00000001<br/>[    4.358474] usbcore: registered new interface driver cdc_acm</p>
<p class="indent">This output shows that the Pi found my USB IR Toy 2 and was able to automatically find and load the correct kernel-level driver for it, <span class="literal">cdc_acm</span>. If your machine doesn’t load a kernel-level driver after finding the Toy, you can modify your system to load it each time the machine is booted. If you’re using Raspbian, you can do this by editing the file <em>/etc/modules</em> and adding the following line:</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you’re using a completely different IR transmitter/receiver for your project, you’ll quite likely have a different kernel-level driver. That too can be loaded in</em>/etc/modules.</p>
</div>
<p class="programs">cdc_acm</p>
<p class="indent">Once that’s working, you can use <span class="literal">dmesg</span> as follows to find the device name that’s been assigned to the USB IR Toy 2 (which you’ll need in the next step):</p>
<p class="programs">$ <span class="codestrong">dmesg | grep -e cdc_acm</span></p>
<p class="indent">My output gave me the following:</p>
<p class="programs">[    4.332559] cdc_acm 1-1.2:1.0: ttyACM0: USB ACM device<br/>[    4.358474] usbcore: registered new interface driver cdc_acm<br/>[    4.360314] cdc_acm: USB Abstract Control Model driver<br/>for USB modems and ISDN adapters</p>
<p class="indent"><span epub:type="pagebreak" id="page_120"/>In this case, my USB IR Toy 2 has been assigned to device <em>/dev/ttyACM0</em>. Write down your device assignment.</p></li>
<li class="noindent"><p class="list"><strong>Configure <em>lirc_options.conf</em>.</strong> LIRC has put some default configuration files in <em>/usr/local/etc/lirc</em>. For this step you need to edit <em>/usr/local/etc/lirc/lirc_options.conf</em> as superuser and change the <span class="literal">driver</span> parameter (not the kernel-level driver in this case, but the LIRC plug-in) to <span class="literal">irtoy</span> and the <span class="literal">device</span> parameter to the full path of the one you saw in your <span class="literal">dmesg</span>. Open your <em>/usr/local/etc/lirc/lirc_options.conf</em> file and change those parameters to match the following:</p>
<p class="programs">driver = irtoy<br/>device = /dev/ttyACM0</p>
<p class="indent">If you are using something besides a USB IR Toy 2, you can find a list of all other available plug-ins using the following command:</p>
<p class="programs">$ <span class="codestrong">lirc-lsplugins</span></p>
<p class="indent">While you’re in there, you may also need to change the default locations for <span class="literal">pidfile</span> and <span class="literal">output</span> so they match where they were actually installed on your system. In my case, the NOOBS-installed Raspbian, I had to prepend <em>/usr/local</em> to each one. You’ll know you failed if LIRC complains it can’t write the PID file when you try to run it!</p>
<p class="programs">output = /usr/local/var/run/lirc/lircd<br/>pidfile = /usr/local/var/run/lirc/lircd.pid</p></li>
<li class="noindent"><p class="list"><strong>Paranoia check.</strong> To make sure you’re on track, check that you used the right device and driver with the following command:</p>
<p class="programs">$ <span class="codestrong">sudo mode2 -H irtoy -d /dev/ttyACM0</span></p>
<p class="indent">Point any IR remote at the USB IR Toy 2 and push some buttons. You should see results flow across the screen, indicating that serial data is available on the Pi as a result of your button pushing. Mine started out like this:</p>
<p class="programs">Using driver irtoy on device /dev/ttyACM0<br/>Trying device: /dev/ttyACM0<br/>Using device: /dev/ttyACM0<br/><span epub:type="pagebreak" id="page_121"/>Running as regular user pi<br/>space 1000000<br/>pulse 3861<br/>space 1000000<br/>space 1000000<br/>pulse 21<br/>space 76799<br/>pulse 127<br/>space 12501<br/>pulse 63<br/>space 1112467<br/>pulse 42<br/>space 1000000<br/>space 1000000<br/>pulse 5119<br/>space 4543<br/>pulse 554<br/>space 575<br/>pulse 533<br/>space 575<br/>pulse 554<br/>--<span class="codeitalic">snip</span>--</p>
<p class="indent">When you’re done, press <small>CTRL</small>-C to exit that program.</p></li>
<li class="noindent"><p class="list"><strong>Pick names for your buttons.</strong> The information on each remote control your LIRC knows about will be stored in the <em>.conf</em> files located in <em>/usr/local/etc/lirc/lircd.conf.d</em>. The next step is to create a file there for the air conditioner. We’ll do this using a program called <em>irrecord</em>.</p>
<p class="indent">Each button on your remote will need a name in the configuration file. Write your choices down so they’ll be handy when you go to record your button presses. LIRC has some standardized button names that you can either use or disable; for simplicity we’ll use these standard names in this project. You can get the list by entering:</p>
<p class="programs">$ <span class="codestrong">irrecord -l</span></p>
<p class="indent">For my buttons I chose and wrote down the following:</p>
<p class="programs">on/off: KEY_POWER<br/>mode: KEY_MODE<br/>speed: KEY_FASTFORWARD<br/>timer: KEY_TIME<br/>temp/time up arrow: KEY_UP<br/>temp/time down arrow: KEY_DOWN</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_122"/><strong>Extra credit: get the model number of your remote.</strong> While not strictly necessary for this project, it’s a nice touch (and LIRC convention) to have your config file named after the remote you are using. I was able to find the model number of mine, a Haier AC-5620-30, by scrutinizing the spare parts section on Haier’s website and finding a match.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If at any time during the recording process the USB IR Toy 2 stops functioning, I would recommend power-cycling your Pi and unplugging/replugging the USB IR Toy 2’s cable while the power is off. I don’t know where the fault lies, but recording can be a bit dodgy!</em></p>
</div></li>
<li class="noindent"><p class="list"><strong>Record the codes sent by the remote.</strong> Now you’ll create a crude initial configuration file for your air conditioner’s remote by naming the buttons and pushing them such that the raw (not decoded yet) code is recorded and associated with its correct button name. Recording the raw signal will allow LIRC to reproduce it as an output later when you program your computer to control the A/C.</p>
<p class="indent">First move to a scratch directory where you have write privileges:</p>
<p class="programs">$ <span class="codestrong">cd /home/pi/</span></p>
<p class="indent">With your remote in hand and the USB IR Toy 2 arranged so the LEDs point toward you, enter:</p>
<p class="programs">$ <span class="codestrong">sudo irrecord -H irtoy -d /dev/ttyACM0 -f</span></p>
<p class="indent">Make sure to use your correct driver and device names. The program will step you through some processes to gather technical information on the signals your particular remote sends. First you’ll be asked to enter the name of your remote. Then it will ask you to push many random buttons, which will allow it to see how buttons generally work in this new and unfamiliar remote’s unknown protocol. Once it is confident it can tell one button push from another, it will ask you to enter your chosen button names one by one, and demonstrate the button push for each entry.</p>
<p class="indent">Follow all the instructions through to the end. When it finishes, the contents will be saved to a file that starts with the remote model name you provided, and ends in <em>.lircd.conf</em>.</p>
<p class="indent">If you later find that some button(s) did not record properly, you can re-record just those ones by specifying the config file to be updated using <span class="literal">-u</span>. For example:</p>
<p class="programs">$ <span class="codestrong">irrecord -H irtoy -d /dev/ttyACM0 -f -u \</span><br/><span class="codestrong">Haier_AC-5620-30.lircd.conf</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_123"/>This technique can also be used to adapt someone else’s config file for your own remote, if they are compatible enough.</p></li>
<li class="noindent"><p class="list"><strong>Edit your <em>.lirc.conf</em> file.</strong> Using your favorite text editor, open your newly created config file, and you should see that it has three sections:</p>
<ul class="bullet5">
<li class="noindent">First comes a comments area, surrounded by hash marks (#), with annotated blanks for you to fill in your remote and other relevant details. The LIRC community likes this information to be in this uniform format and fully fleshed out in the event that you decide to share the file with others. If you intend to keep the file to yourself, however, filling in the comments is optional.</li>
<li class="noindent"><p class="list">Next, directly under <span class="literal">begin remote</span>, there should be a section with your remote’s name and some basic serial communications characteristics of its signal. This information was gathered by irrecord during the process you went through in step 10, and will be different for different kinds of remotes. Mine looked like this:</p>
<p class="programs">begin remote<br/>  name  Remote_Haier_AC-5620-30.conf<br/>  flags RAW_CODES|CONST_LENGTH<br/>  eps            30<br/>  aeps          100<br/>  gap          108529</p></li>
<li class="noindent"><p class="list">Third, there will be a list of the button names you chose, each accompanied by a block of code that irrecord has associated with that button. You may notice that some of them look suspiciously short, or otherwise dramatically different from their fellows. These may well turn out to be misrecorded ones. You’ll find out for sure in the next step. Here’s my first button from that section:</p>
<p class="programs">begin raw_codes<br/><br/>    name KEY_POWER<br/>       8981    4565     533     575     533     597<br/>        511     575     533    1706     511    1727<br/>        533     575     511     597     533    1706<br/>        511    1706     554    1685     533    1706<br/>        533    1706     533     575     511    1727<br/>        533    1706     533     575     533    1706<br/>        533     575     511     597     511    1727<br/><span epub:type="pagebreak" id="page_124"/>        533    1706     533     575     533     575<br/>        533     597     511     575     533    1706<br/>        533    1706     533     597     511     575<br/>        533    1706     533    1727     511    1706<br/>        533</p></li>
</ul></li>
<li class="noindent"><p class="list"><strong>Test your <em>.lirc.conf</em> file.</strong> Move a copy of your <em>.lirc.conf</em> file to the configuration directory as follows:</p>
<p class="programs">$ <span class="codestrong">sudo cp Haier_AC-5620-30.lircd.conf \</span><br/><span class="codestrong">/usr/local/etc/lirc/lircd.conf.d/</span></p>
<p class="indent">If you’re not using the default config file, <em>devinput.lircd.conf</em>, for anything, you may wish to change its name to something like <em>devinput.lircd.conf.unused</em> so LIRC doesn’t try to use it.</p>
<p class="indent">Next, let’s test the config file. Start LIRC by entering:</p>
<p class="programs">$ <span class="codestrong">sudo lircd</span></p>
<p class="indent">With LIRC running, test your new config file by entering:</p>
<p class="programs">$ <span class="codestrong">sudo irw</span></p>
<p class="indent">Now push the buttons on your remote while pointing at the USB IR Toy 2. Test each button and check that the name you chose for it pops up on the screen when you push it. Make a note if any button press comes up with the wrong name, or if any buttons cause the system to get confused (you’ll know because it won’t say anything and there will be a long pause before any more pushes work). Those are probably misrecorded.</p>
<p class="indent">When you are finished testing, press <small>CTRL</small>-C to get out of <span class="literal">irw</span>, then kill the LIRC process using:</p>
<p class="programs">$ <span class="codestrong">sudo killall lircd</span></p>
<p class="indent">Take your list of erroneous buttons and use the <span class="literal">–u</span> technique described at the end of step 10 to re-record them. If irrecord won’t connect to the USB IR Toy 2, you may have to power-cycle the Pi and USB IR Toy 2.</p>
<p class="indent">When you are done re-recording, run <span class="codestrong">sudo lircd</span> again. Then run <span class="codestrong">sudo irw</span> again and test the buttons. Repeat this step until your config file is 100% accurate! This is the file LIRC will look at <span epub:type="pagebreak" id="page_125"/>when you ask it to generate codes to control your air conditioner with the USB IR Toy 2, so it pays to get this part right.</p></li>
<li class="noindent"><p class="list"><strong>Test control of the A/C.</strong> Next you must verify that the recorded commands are accurate enough to control the air conditioner itself when reproduced by LIRC. You can do this using the <span class="literal">irsend</span> command. First, start LIRC:</p>
<p class="programs">$ <span class="codestrong">sudo lircd</span></p>
<p class="indent">Now enter:</p>
<p class="programs">$ <span class="codestrong">irsend list "" ""</span></p>
<p class="indent">You should see a list of any remote names in your config file(s)—in my case, just the one:</p>
<p class="programs">Haier_AC-5620-30</p>
<p class="indent">You can list the commands available for a given remote by inserting its name exactly as shown in the list:</p>
<p class="programs">$ <span class="codestrong">irsend list Haier_AC-5620-30 ""</span></p>
<p class="indent">For me, this produces the following:</p>
<p class="programs">0000000000000001 KEY_POWER<br/>0000000000000002 KEY_FASTFORWARD<br/>0000000000000003 KEY_UP<br/>0000000000000004 KEY_DOWN<br/>0000000000000005 KEY_TIME<br/>0000000000000006 KEY_MODE</p>
<p class="indent">The similarity with my list of chosen button names from step 8 is no coincidence! It is reading the names from the config file we created. It should now be possible to take one of those button names and combine it with the remote name to send a command like this:</p>
<p class="programs">$ <span class="codestrong">irsend SEND_ONCE Haier_AC-5620-30 KEY_POWER</span></p>
<p class="indent">Boom! My air conditioner comes on. If you’re going to be using this to control something long-term, you’ll want to test all your buttons vigorously to make sure your LIRC and USB IR Toy 2 work together stably.</p></li>
</ol>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_126"/><strong>PATCHING AN UNSTABLE LIRC</strong></p>
<p class="spara">The first time I reached this step with LIRC 0.9.4d, I found it very unstable. Both LIRC and the USB IR Toy 2 would die with an error message every several commands. If I replugged the USB IR Toy 2 and reran LIRC it would work again—for several commands. If you encounter this problem like I did, there is a patch available at <em><a href="https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/">https://sourceforge.net/u/bengtmartensson/lirc/ci/experimental-irtoy/</a></em> that should fix it. Although diff patches are designed to be applied automatically, you’ll likely have to apply this one manually due to differences in versions.</p>
<p class="spara1">To apply the patch, first back up your <em>lirc_options.conf</em> file as follows:</p>
<p class="programs">$ <span class="codestrong">sudo mv /usr/local/etc/lirc/lirc_options.conf \</span><br/><span class="codestrong">/usr/local/etc/lirc/lirc_options.conf.backup</span></p>
<p class="spara1">Then go back to the directory where you compiled LIRC, <em>~/lirc-0.9.4d/</em> in my case. From there, edit <em>./plugins/irtoy.c</em> and make the additions and subtractions specified in the green and red lines of the diff. Then clean up the directory and recompile like this:</p>
<p class="programs">$ <span class="codestrong">./configure</span><br/>$ <span class="codestrong">make clean</span><br/>$ <span class="codestrong">make</span><br/>$ <span class="codestrong">sudo make install</span></p>
<p class="spara1">When done recompiling, reinstate your own <em>lirc_options.conf</em> file:</p>
<p class="programs">$ <span class="codestrong">sudo mv /usr/local/etc/lirc/lirc_options.conf.backup \</span><br/><span class="codestrong">/usr/local/etc/lirc/lirc_options.conf</span></p>
<p class="spara1">If you changed the name of <em>devinput.lircd.conf</em> before, you’ll have to delete the new copy the compilation added:</p>
<p class="programs">$ <span class="codestrong">sudo rm /usr/local/etc/lirc/lircd.conf.d/\</span><br/><span class="codestrong">devinput.lircd.conf</span></p>
<p class="spara1">Now repeat step 13 and see if the system now performs reliably. The patch cleared up the problem completely for me!</p>
</div>
<ol start="14">
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_127"/><strong>Analyze your <em>.conf</em> file.</strong> When you are 100% satisfied with the performance of your <em>.conf</em> file, you can tell LIRC to analyze the remote’s protocol much more thoroughly by using the following commands:</p>
<p class="programs">$ <span class="codestrong">cd ~</span><br/>$ <span class="codestrong">sudo cp /usr/local/etc/lirc/lircd.conf.d/\</span><br/><span class="codestrong">Haier_AC-5620-30.lircd.conf .</span><br/>$ <span class="codestrong">irrecord –a ~/Haier_AC-5620-30.lircd.conf</span></p>
<p class="indent">Technically you could have tried this immediately after recording the first time, but personally I found it worked much better if any errors or missing buttons were taken care of first. Once analyzed, my entire file had shrunk considerably and now looked like this:</p>
<p class="programs">begin remote<br/>  name  Haier_AC-5620-30<br/>  bits           32<br/>  flags SPACE_ENC|CONST_LENGTH<br/>  eps            30<br/>  aeps          100<br/><br/>  header       8984  4554<br/>  one           525  1712<br/>  zero          525   584<br/>  ptrail        529<br/>  gap          108529<br/>  toggle_bit_mask 0x0<br/>  frequency    38000<br/><br/>      begin codes<br/>          KEY_POWER                0x19F69867<br/>          KEY_MODE                 0x19F610EF<br/>          KEY_FASTFORWARD          0x19F620DF<br/>          KEY_TIME                 0x19F658A7<br/>          KEY_UP                   0x19F6A05F<br/>          KEY_DOWN                 0x19F6906F<br/>      end codes<br/><br/>end remote</p>
<p class="indent">Not only is this much more compact and easier to read than the raw version shown (partially) in step 11, but much more is now known about the protocol used by the A/C. In addition to <span epub:type="pagebreak" id="page_128"/>the header, frequency, and so on, the actual commands have been decoded, and are expressed in hex instead of as blinks of various lengths to be imitated. This means that LIRC actually knows what it is doing now, instead of parroting stuff it doesn’t understand. That can only be a good thing when it comes to accurately controlling the A/C!</p>
<p class="indent">Cut and paste the analysis to replace the raw content in your original <em>.lircd.conf</em> file and kill and then restart LIRC to give it a try. It should work brilliantly.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If nothing changed or happened when you tried to analyze your file, LIRC wasn’t able to figure out your protocol. Just keep using your raw</em> .conf <em>file in that case.</em></p>
</div></li>
<li class="noindent"><p class="list"><strong>Run LIRC automatically.</strong> Once you have LIRC configured properly, you can run it one last time and leave it running. You might also want to set it up to start automatically when you start your Pi, if you plan to set up tasks for your air conditioner controller that need to keep working if the machine gets rebooted. To do that on a Raspbian system, edit your <em>/etc/rc.local</em> file as superuser and add the line:</p>
<p class="programs">lircd</p></li>
<li class="noindent"><p class="list"><strong>Program the Pi to run your A/C.</strong> Now that you have your USB IR Toy 2 talking to LIRC and have proven you can control your air conditioner with it, you have lots of interesting options for automating the actual running of the A/C. Go to <em><a href="http://www.lirc.org/software.html">http://www.lirc.org/software.html</a></em> for a list of LIRC-related and compatible software and applications that let you manipulate your A/C in different ways or integrate it with your multimedia setup. I like using the command line, so my example script will be written in bash. But don’t let that stop you from experimenting with everything out there!</p>
<p class="indent">Let’s say that the room your A/C is in heats up in the daytime while you’re at work or school. The air conditioner can be left on to keep the room cool all day, but it would be much more economical to have it turn on right before you come home. So let’s say you want it to come on at 4:30 <small>PM</small>. Linux has a daemon called <span class="literal">cron</span> that can run programs on schedules. You could write a <span class="literal">cron</span> job to accomplish your goal by entering:</p>
<p class="programs">$ <span class="codestrong">sudo crontab –e</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_129"/>Then add a line like this to your crontab:</p>
<p class="programs">30 16 * * * /path/to/your/script/air_conditioner.sh</p>
<p class="indent">This specifies that a script named <em>air_conditioner.sh</em> on the path specified will be run at 30 minutes after the 16th hour each day. (If you want to do more with <span class="literal">cron</span>, try reading <span class="literal">man crontab</span>!)</p>
<p class="indent">Next, create the actual script in your text editor and save it as <em>air_conditioner.sh</em>. An example of a bash script to turn on the air conditioner might be as simple as:</p>
<p class="programs">#!/bin/sh<br/>#<br/># Sample program to control A/C<br/>#<br/>irsend SEND_ONCE Haier_AC-5620-30 KEY_POWER</p>
<p class="indent">This assumes that the A/C is always off when you leave in the morning. Since it is an <em>open-loop</em> control system (meaning the computer has no way of knowing whether the A/C was on or off to begin with), the beginning state has to be known for it to work right. Therefore, some things you want to do may require cleverness on your part to ensure the starting state is always known.</p></li>
</ol>
<h3 class="h3" id="lev91"><strong>TAKE IT FURTHER</strong></h3>
<p class="noindent">One option for modifying this project is to make it a <em>closed-loop</em> system where the Pi can actually check on the state of the A/C. You could set up a temperature sensor in the room, or an inductive current sensor on the air conditioner’s power cord, then have the Pi read the signals from those to determine what the A/C is doing. You could even have the Pi visually check for the state of the LEDs on the front of the A/C, if you are feeling ambitious and have a camera.</p>
<p class="indent">Even if you keep it an open-loop system, there are ways to make use of external information to add power to your automation. Here’s an experiment you can try right now: say you want the A/C to come on at 4:30 only if it’s over 90 degrees outside. You could power it off in the mornings, and have your Pi check the NOAA (National Oceanic <span epub:type="pagebreak" id="page_130"/>and Atmospheric Administration) website for current conditions in your area, like this:</p>
<p class="programs">wget -q -O current_conditions.txt "http://forecast.weather<br/>.gov/MapClick.php?CityName=Los_Angeles&amp;state=CA&amp;site=LAX&amp;lat<br/>=34.06076&amp;lon=-118.23510"</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Like all websites, NOAA’s may change its URL or content, which may break your script. If that happens, modify the URL and/or sed pattern matching in your script to get the information you want.</em></p>
</div>
<p class="indent">Unless you live in L.A., you’ll want to change the URL to the one for your own city once you have this working. The following commands will strip off the saved website, leaving only the current temperature from the current day:</p>
<p class="programs">grep -e myforecast-current-lrg current_conditions.txt | sed 's/.*myforecast-current-lrg\"&gt;\(.*\)\&amp;deg;F&lt;\/p&gt;.*/\1/g'</p>
<p class="indent">It’s useful to add logging functionality, so you can see if the Pi tried to send a power on command or not. You can do so with the <span class="literal">logger</span> command, like this:</p>
<p class="programs">logger 'Your message here'</p>
<p class="indent">Putting it all together, I present this sample program for you to edit and play with:</p>
<p class="programs">#!/bin/sh<br/>#<br/># Sample program to control A/C<br/>#<br/>CONTROL_TEMP=90<br/>wget -4 -q -O current_conditions.txt "http://forecast<br/>.weather.gov/MapClick.php?CityName=Los_Angeles&amp;state=CA&amp;site<br/>=LAX&amp;lat=34.06076&amp;lon=-118.23510"<br/>CURRENT_TEMP=`grep -e myforecast-current-lrg<br/>current_conditions.txt | sed 's/.*myforecast-current-lrg\"&gt;\(.*\)\&amp;deg;F&lt;\/p&gt;.*/\1/g'`<br/>if [ $CURRENT_TEMP -ge $CONTROL_TEMP ];<br/>then<br/>        irsend SEND_ONCE Haier_AC-5620-30 KEY_POWER<br/>        logger 'Temperature of '$CURRENT_TEMP' is at or above '$CONTROL_TEMP'. Air conditioner power command sent.'<br/><br/>else<br/>        logger 'Temperature of '$CURRENT_TEMP' is below '$CONTROL_TEMP'. Air conditioner power signal not sent.'<br/>fi</p>
<h3 class="h3" id="lev92"><span epub:type="pagebreak" id="page_131"/><strong>SUMMARY</strong></h3>
<p class="noindent">In this chapter you learned about infrared light and infrared LEDs, and a few—hopefully!—tantalizing bits about communications protocols. You created a system to control an air conditioner remotely from a computer using infrared light. I hope that you’ll explore further in books and online because there is a lot to learn about serial communications, circuit design, and LED technology. To learn the nitty-gritty of designing electronics circuits from discrete components, including LEDs, I recommend <em>The Art of Electronics</em> by Horowitz and Hill.</p>
</div>
  </body>
</html>
