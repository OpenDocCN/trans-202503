- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking People in Physical Space with Digital Information
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s continue our discussion of computational geometry with a somewhat controversial
    topic: tracking people in physical space using digital information. It’s no secret
    that law enforcement agencies across the globe rely heavily on cell phone tracking
    to locate and apprehend suspects. You might think this requires them to get a
    warrant and then subpoena the GPS records from a wireless provider, but this isn’t
    always the case, nor is it strictly necessary. Using publicly available information
    and basic geometry, you can (somewhat) accurately place a phone in a given area,
    even if it doesn’t have GPS. As long as it’s connected to a cellular or wireless
    network, you have a good shot at locating it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The triangulation process relies on knowing a few things: first, the location—that
    is, physical latitude and longitude—and configuration for a large number of wireless
    network hubs, like cell phone towers; second, the approximate broadcast range
    of these devices; and finally, the signal strength at the cell phone for a set
    of networks the device can communicate with. This may seem like a tall order,
    but the first two have already been handled for us by the nice folks at Unwired
    Labs with their service OpenCellID. The third topic we’ll discuss in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a basic understanding of the data, we’ll cover some of the ethical
    implications surrounding this project. After that, we’ll look at the OpenCellID
    API in more detail and discuss how to find the location of individual towers and
    use the API’s Geolocation solver to get an address and an accuracy estimate.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering Cellular Network Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several options for getting network information from a phone, ranging
    from sophisticated hardware attacks to very simple ones that use built-in utilities.
    Hardware attacks are beyond the scope of this book, but check out the books *Android
    Security Internals*^([1](b01.xhtml#c08-endnote-001)) and *The Android Hacker’s
    Handbook*^([2](b01.xhtml#c08-endnote-002)) for an introduction to this topic for
    Android phones, as well as *iOS Hacker’s Handbook*^([3](b01.xhtml#c08-endnote-003))
    for Apple devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The network interface data we need seems so simple and innocuous that it’s
    often made available to almost every application running on a cell phone, tablet,
    laptop, or other wireless-enabled devices. If you’re like me, you’re probably
    very picky about which applications can access your location data directly, but
    just about every app has a built-in reason to require network access: updates.
    Unfortunately, this means these applications can see which networks are visible
    and how strong their signal is. Thanks to the OpenCellID API, this information
    is almost as good as having a GPS signal, so if you had an exploit for any one
    of these apps, you could potentially use that to retrieve the information.'
  prefs: []
  type: TYPE_NORMAL
- en: As an experiment, you can try to manually scan the cellular networks in your
    area. Most phones have an option to manually select the cell network you want
    to connect with. To find it, search your phone’s make and model along with “manual
    cell network selection.” There’s also a plethora of apps available to perform
    this task, although I prefer to use the phone’s built-in capabilities before downloading
    any. Suffice to say, from this point forward I’ll assume you have access to the
    device’s network data through some legal means. I’ve also provided the sample
    data I used when developing the examples so that you can follow along without
    access to any device.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be working with the OpenCellID API throughout this project, so let’s take
    a moment to discuss what it is and why we’ll be using it. The OpenCellID API is
    an online service that stores information about cellular network base stations,
    such as location and network type. *Base stations* are what people usually mean
    when they refer to a cell network’s towers. Technically, the part of the tower
    we’re used to seeing just holds the physical antennas; the real brains of the
    operation are housed near the base of the antennas. These boxes contains the hardware
    and application logic necessary to route traffic from devices onto the cell provider’s
    network infrastructure and its final destination. For the rest of the chapter,
    I’ll use the terms *base station* and *tower* interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a free account and getting an API access token, you’ll have access
    to the data through an online REST API. Having publicly accessible data about
    cell networks is useful in a number of security applications, aside from tracking
    physical locations. If you’re traveling within any metropolitan area, your phone
    is being bounced from tower to tower. This usually happens seamlessly in the background
    and can occur for a couple of different reasons. Cell networks are constantly
    balancing traffic by asking devices to connect to other towers. When a base station
    detects that it’s becoming bogged down with traffic, it may tell new devices to
    find a different tower to handle their traffic. Your phone is also programmed
    to try to connect to the base station with the strongest signal first and then
    try others in descending order as necessary. Having your device bouncing across
    all these towers creates the potential for an adversary to introduce a rogue base
    station (one they control the application logic for) with a strong enough signal
    to trick nearby devices into connecting to it. As your phone is bouncing around,
    having access to a publicly curated list of known cell towers can help to ensure
    your device connects only to legitimate cell networks. The online portal for OpenCellID
    ([https://opencellid.org](https://opencellid.org)) can also be used to explore
    the data available in a geographic region.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-1](#figure8-1) shows the OpenCellID map for the Pike Place Market
    area of Seattle, retrieved from its online portal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Network data for the Pike Place Market area'
  prefs: []
  type: TYPE_NORMAL
- en: 'This image was captured from the OpenCellID main site. The gray circles are
    clusters of radios that OpenCellID has information for. The number in the center
    of the circle shows how may radios are in that cluster. You can also see a few
    pins with letter labels. These are single network instances where the letter denotes
    the type of radio that’s being used to communicate. The key in the lower right
    of the map shows the four major network types available: GSM, CDMA, UMTS, and
    LTE. The Jupyter notebook that accompanies this section has more details on each
    type of network.'
  prefs: []
  type: TYPE_NORMAL
- en: These four network types make up the core radio towers we’ll use to locate equipment
    based on their proximity to a set of fixed radio locations. There is another network
    type that isn’t shown on the map, Wi-Fi routers, which you can also use to get
    more precise results in some cases. The problem is, when compared to cellular
    network towers, Wi-Fi routers are ephemeral. They may be turned off, or worse
    (for our purpose), relocated without the OpenCellID database being updated, which
    would throw our analysis into a tailspin. We’ll stick to cellular towers in the
    example data, but you should definitely explore the Wi-Fi option on your own.
    There are online services such as WiGLE ([https://www.wigle.net](https://www.wigle.net))
    that are similar to OpenCellID but for Wi-Fi networks.
  prefs: []
  type: TYPE_NORMAL
- en: Each tower is uniquely identified by a country code and network ID. The data
    contains estimates on the effective range for the type of network, such as 1 kilometer
    for most CDMA antennas; it also contains the approximate latitude and longitude
    of the antenna, other bits to track when it was last verified, and more. By taking
    several visible network towers and seeing where they overlap service, we should
    be able to determine the small portion of earth where the device could be located.
    To do so, we’ll create polygons representing the service areas for each base station
    based on the network type. We’ll then overlay the polygons in relation to one
    another and find the area that all the networks have in common using the Shapely
    library’s `intersection` and `difference` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the nuts and bolts of the data, there are some privacy concerns
    we should consider. The decisions we make as security researchers can negatively
    impact the privacy and security of large portions of society in unintended ways.
    In the next section, we’ll cover some considerations to keep in mind before you
    undertake any project related to device tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Ethics of Tracking Devices and People
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some ways, criminals have it easy. A criminal doesn’t have to consider the
    ethical or moral implications of their actions. Whether they’re exposing their
    target to additional risk is usually not high on their list of concerns. White
    hats, on the other hand, have ethical, and oftentimes legal, barriers to consider
    when obtaining or using location information. In the past, I’ve received records
    similar to the data for this project from company-owned devices via remote administration
    tools after an employee’s laptop or cell phone went missing. However, even this
    seemingly benevolent use is an ethical gray area. Here in the US there isn’t a
    clear line on an employee’s right to privacy.^([4](b01.xhtml#c08-endnote-004))
    It’s easy to say, “If a company owns a system they have the right to track and
    monitor it,” but what about people who carry their work systems with them during
    off-hours (something I regularly do myself)? Several companies even require their
    managers to keep work phones on them during their downtime—even on vacation. There’s
    nothing technical to block these companies from tracking their employees during
    their private time, and the laws are murky and vague, so it becomes purely a question
    of ethics. When dealing with corporate entities, being forced to trust their ethical
    behavior scares a lot of people!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how this technology works, and how to apply it ethically to improve
    security without hurting privacy, falls to us as researchers and analysts. After
    reading this chapter, take some time to look up the relevant laws for your area
    and, perhaps even more importantly, think about what you believe are appropriate
    and inappropriate uses for this technology.^([5](b01.xhtml#c08-endnote-005))
  prefs: []
  type: TYPE_NORMAL
- en: For our project, I collected the data on myself using an Android tablet. As
    the data subject, I was aware of the data collection and gave myself, as the author,
    permission to use the data in the limited scope of writing this material. The
    key point here is that the data subject (me) was informed and gave consent. Getting
    informed consent to perform your analysis can prevent a lot of ethical risk before
    you even begin. If you apply this type of tracking technology outside the scope
    of informed consent (such as law enforcement or military applications), you must
    decide for yourself what ethical doctrine applies.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the ethics of device tracking in general, and more
    specifically concerning the various potential applications of our project, we
    can get into the meat of the problem. In the next section we’ll take a deeper
    dive into the OpenCellID API, covering the basics of calling the API, the structure
    of the data returned, and how we can process this information into relevant shape
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenCellID API Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Technically speaking, OpenCellID is a RESTful API that uses client secret keys
    to identify users. To access the OpenCellID data, you’ll need to sign up for one
    of these API keys. It’s free and easy: you simply provide an email and a use case
    (like “Research”), and you’ll get back an alphanumeric key. Your account comes
    with a limit of 5,000 requests a day, but this should be more than enough for
    most applications. If you’re smart about caching responses, you should be able
    to spread those out even more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common workflows supported by the API. *Geolocation* is the process
    of turning latitude and longitude information into a location on earth, like “123
    Main Street, Seattle, WA.” Geolocation comes up a lot both inside and outside
    of security, so it’s a good idea to become familiar with the process. *Geocoding*
    works in the opposite direction: you take an address and return the latitude and
    longitude of that point. We’ll mostly be working with the Geolocation portion
    of the API, but it’s worth noting OpenCellID also has API calls to help with map
    displays and calls for monitoring your usage. As you develop your own application,
    you’ll want to take advantage of those additional features.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-1](#listing8-1) shows the structure of a simple request to the API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: The structure of the API payload'
  prefs: []
  type: TYPE_NORMAL
- en: Every request needs to contain the alphanumeric `token` that you received when
    you signed up ❶. The `radio` field ❷ identifies the primary network type of the
    device we’re looking into. Setting this field doesn’t restrict the types of radios
    that you can pass in the `cells` field ❹, however, which represents the base stations
    that are visible to the device. We’ll revisit the `cells` field more in a moment,
    but first, let’s discuss how networks are identified and grouped.
  prefs: []
  type: TYPE_NORMAL
- en: Each country is assigned a three-digit *mobile country code (MCC)*. Most countries
    actually have several MCCs assigned to break up the geography into smaller chunks
    that make it easier to manage the traffic for any one region. To uniquely identify
    a mobile subscriber’s network, the MCC is combined with a *mobile network code
    (MNC)* into the *home network identity (HNI)*, which concatenates both pieces
    of information into one string.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 8-1](#listing8-1), the device has an MCC of 310 ❸ (which is the
    first of seven MCCs assigned to North America, numbered 310–316) and an MNC of
    120, so the HNI is 310120\. Using the HNI, OpenCellID can determine what service
    provider and network segment a device belongs to when it sends a query to the
    API. You can pull this information off the device you’re testing or pass some
    default network MCC and MNC, which is what we do in the code for this project.
    If you look up the HNI from [Listing 8-1](#listing8-1), you’ll see it belongs
    to the Sprint Spectrum network ([https://imsiadmin.com/assignments/hni](https://imsiadmin.com/assignments/hni))
    in North America.
  prefs: []
  type: TYPE_NORMAL
- en: Now, returning to the `cells` field, we see a list of nested JSON objects. We
    can send between one and seven radio identifiers to OpenCellID to help pinpoint
    location more accurately. You can even contact Unwired’s development team to increase
    that number if you need to (but that’s unlikely).
  prefs: []
  type: TYPE_NORMAL
- en: The next section of the data contains the radios we’d like to retrieve information
    about. The radio objects we send can be any mix of supported radio types. We identify
    each radio using two numbers based on its physical locations. Cell networks are
    divided into several geographic areas, each of which can support between 1 and
    65,534 base stations. Each geographic area is assigned a unique *location area
    code (LAC)*. Similar to the area code prefix on a telephone number, a LAC describes
    roughly where the base station is located. The second number is the *cell ID (CID)*,
    which identifies each individual base station within a LAC ❺. You can think of
    the LAC and the CID like a zip code and a street address, respectively. They work
    together to create a unique identifier for every base station on a network. Finally,
    the `address` field ❻ tells the API to return the human-readable address along
    with the other result fields. If you don’t need the address, you can save some
    bytes by excluding this field.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-2](#listing8-2) defines a Python function called `lookup_tower`
    to send the single radio payload from [Listing 8-1](#listing8-1) to the API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: A function to call the API and decode the response'
  prefs: []
  type: TYPE_NORMAL
- en: Before running anything, let’s begin by verifying that the URL presented here
    (`https://us1.unwiredlabs.com/v2/process.php`) is still the most up to date and
    appropriate for our use case. Unwired hosts several API endpoints around the world,
    so there may be another that is closer to you or one with less traffic (which
    helps reduce latency). You can do this by going to the Unwired Labs API list at
    [https://unwiredlabs.com/api](https://unwiredlabs.com/api) and selecting Endpoints
    from the options on the left. You can then copy the URL for the API endpoint that
    is geographically closest to you.
  prefs: []
  type: TYPE_NORMAL
- en: We must convert the JSON payload into a string object before passing it to the
    request library. To do so, we call the `json.dumps` (short for *dump string*)
    function on our JSON payload. We pass the function to the request library through
    the `data` parameter. The `response` object we get back will be a JSON object
    transmitted as text unless there’s an error, in which case we’ll get a nasty blob
    of HTML and the function will choke when trying to decode the `response.text`
    property. To avoid this, we’d expand our production code to wrap the call to `requests.request`
    in a `try...catch` block or other safety net.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-3](#listing8-3) shows the format of the response.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: A single-tower JSON query response'
  prefs: []
  type: TYPE_NORMAL
- en: The status string will be `"ok"` in cases where the request succeeded and `"error"`
    if the API detected a problem. The `balance` field holds the number of requests
    remaining for the day. We can take the `lat` (latitude), `lon` (longitude), and
    `accuracy` fields to plot the tower on a map. Finally, if we pass the `address=1`
    parameter, the `address` field holds this information as a string. [Figure 8-2](#figure8-2)
    shows the result of [Listing 8-3](#listing8-3) plotted on a map.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Displaying a tower range'
  prefs: []
  type: TYPE_NORMAL
- en: The map area shows the city of Seattle, where the tower is located. The dark
    gray circle in the middle of the image shows the approximate area covered by the
    tower, and the pin in the center of the gray circle represents the exact latitude
    and longitude of the tower. Each of the white lines crisscrossing the image represents
    a city street. You can see the maximum coverage area of one tower is pretty large—several
    city blocks at least. If we had only this one tower to try to locate the device,
    we’d have a lot of ground to cover! In the next section we’ll see how to narrow
    the area further by geolocating several towers and finding their overlapping service
    region using the GeoPandas and Shapely libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Proof of Concept: Locating a Device from Nearby Cell Towers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve seen how we can interact with the OpenCellID API to get back information
    on towers in our data. Now it’s time to put this knowledge together into an application
    that will locate a device based on the cell towers within its range. We’ll extend
    the `lookup_tower` function from [Listing 8-2](#listing8-2) to locate each tower
    in the list recovered from the test device. The data we’ll be using to test our
    application can be found in the file *cellular_networks.json* in the chapter’s
    supplemental materials.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-3](#figure8-3) shows the four towers from the sample data laid out
    over a map.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: Tower signal overlap'
  prefs: []
  type: TYPE_NORMAL
- en: Your eye can easily locate the area where all the signals overlap, but it isn’t
    quite as easy for a computer to determine. Therefore, our goal is to programmatically
    identify that portion of the map where all four towers overlap using Shapely to
    produce a bounded search area. We’ll then compare our results with the location
    guess returned from OpenCellID API to see which is more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering Tower Locations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first step, shown in [Listing 8-4](#listing8-4), is to gather the location
    information from each of the four towers using the `lookup_tower` function from
    [Listing 8-2](#listing8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: Gathering tower geolocation information'
  prefs: []
  type: TYPE_NORMAL
- en: After loading in the data, we create a `for` loop to loop over each cell ❶.
    We need to send in each tower by itself to get back its geolocation information;
    otherwise, we’ll get back a location guess using the towers you sent to the API
    as the reference information. We’ll replace the cells in the payload from [Listing
    8-1](#listing8-1) with the tower info loaded in from the *networks.json* file
    ❷. In a production application, this would be the portion of information you recover
    from the device you want to track. Next, we call the `lookup_tower` function ❸
    and store the result into a list called `tower_locs` ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a list containing JSON objects, which in turn contain geolocation
    information in the form of latitude and longitude coordinates for each tower.
    This is very close to a standard object format called GeoJSON, which many programs
    of different languages know how to interpret. To make our data more flexible and
    standardized, let’s finish converting the data to GeoJSON format. We can do this
    simply enough using the pandas data science library and its sister, GeoPandas,
    which adds support for geometric coordinates and operations. [Listing 8-5](#listing8-5)
    shows how to convert the JSON data the rest of the way to the GeoJSON format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: Creating a `GeoDataFrame` from tower locations'
  prefs: []
  type: TYPE_NORMAL
- en: First, we cast the list of JSON objects to a traditional pandas `DataFrame`,
    which gives us a chance to clean up any unnecessary fields in the next line. We’re
    dropping the `status` and `balance` fields since they don’t add any information
    to the analysis. Next, we use the GeoPandas `GeoDataFrame` class to cast `tower_df`
    into the more appropriate geolocation data, which contains a special field, aptly
    named `geometry`, to hold the geometric representation of each row in the `DataFrame`.
    In this case, we use the `lat` and `lon` columns from `tower_df` to define `Point`
    objects, which then get stored in the `geometry` column. The GeoPandas function
    `points_from_xy` takes in an x- and y-coordinate and returns a `Point` object
    that GeoPandas can use to associate a shape object with the data. You can see
    the structure of the `geo_df` data in the output of the 2nd cell in the *OpenCell_API_Examples.ipynb*
    notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Translating a Geographic Point to a Polygon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll be converting these `Point` objects to polygons representing circles,
    but Shapely isn’t aware of specific coordinate systems or units, so first we need
    to convert the latitude and longitude into native (*x*, *y*) coordinates and back
    again. This requires a rather tricky bit of code that can store intermediate results
    and keep track of units. It relies on the pyproj (short for Python Projection)
    and functools libraries to do so. The functools library is for *higher-order functions*,
    functions that act on or return other functions. Examples include functions that
    modify the call structure or translate inefficient call flows into more modern
    and efficient ones*.* Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `complex` function takes in five required parameters and prints them all
    out using a format string. But what if we know that in our use case we’ll always
    call `complex` with the same first four parameters and `x` is the only parameter
    we’ll ever need to change? In these situations we can use partial function copies
    to simplify the calling conventions. *Partial functions* allow us to fix a certain
    number of arguments for a function and generate a new function that we can call
    without including those fixed arguments. Here, `functools.partial` allows us to
    create a new simplified version of the `complex` function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `simple` function now contains a copy of the `complex` function, with the
    first four parameters statically defined to be the values `1`, `1`, `2`, and `3`,
    respectively. Now calling `simple` with any value will result in that value being
    passed to the `complex` function in the `x` parameter. Calling the `simple` function
    with the value `5` is now equivalent to calling the `complex` function with the
    values `1`, `1`, `2`, `3`, and `5`, as we can see from the code’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the `functools.partial` function to programmatically create two new
    functions to handle the coordinate translations. To do so, we’ll be using the
    pyproj library, which is designed to translate between different coordinate systems
    internally. The `Proj` class can convert from geographic (lat, lon) to native
    map projection (*x*, *y*) coordinates and vice versa, which is perfect for our
    needs. [Listing 8-6](#listing8-6) shows the function I found and modified from
    a related GIS Stack Exchange post.^([6](b01.xhtml#c08-endnote-006))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: Translating a geographic point to a geographic polygon'
  prefs: []
  type: TYPE_NORMAL
- en: We define the `az_proj` (short for *azimuth projection*) string to contain all
    the variables that will be passed in to the projection code ❶. The most important
    are `+proj`, which tells the library to convert the coordinates using a method
    known as *azimuthal equidistance (AEQD)*; `+R`, which holds the radius (in meters)
    of earth; and `+units`, which tells the code that this number is in meters, but
    more generally tells the library what units to convert to. The only two variables
    we need to be able to change on each call are `lat_0` and `lon_0`, which define
    the (0, 0) point in the coordinate field. Currently our data is in *world geodesic
    system (WGS)* coordinates. WGS 84 is the standard US Department of Defense definition
    of a global reference system for geospatial information and is the reference system
    for GPS (the Global Positioning System). It is compatible with the International
    Terrestrial Reference System (ITRS) if that’s more your cup of tea.^([7](b01.xhtml#c08-endnote-007))
  prefs: []
  type: TYPE_NORMAL
- en: In the `wgs84_to_aeqd` and `aeqd_to_wgs84` functions, we create a partial copy
    of the `pyproj.transform` function ❷. The `functools.partial` function freezes
    the first two parameters of the `pyproj.transform` function. Notice in the `aeqd_to_wgs84`
    function the two calls to the `Proj` class are reversed. That’s because the first
    two parameters to the `pyproj.transform` function define the current and desired
    representation, respectively. Reversing these two inputs reverses the translation
    direction, in this case from native coordinates back into geographic coordinates
    ❸. Since we’re creating simplified versions of the `transform` function, we freeze
    these two parameters in the appropriate order for our translation direction. The
    remaining parameters to the `pyproj.transform` function define the *x* and *y*
    values to translate. We’ll leave these unfrozen and pass them in when we call
    the functions in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the two conversion functions defined, we create a `Point` object
    from the latitude and longitude ❹. Shapely expects these in the reverse order
    than you might expect. If you try to pass the coordinates directly via the `geometry`
    column, you’ll run into the error `"latitude or longitude exceeded limits."` The
    `shapely.transform` function (not to be confused with the `pyproj.transform` function)
    applies a user-defined function to all the coordinates of a Shapely object and
    returns a new geometric object of the same type from the transformed coordinates.
    We’ll use the `shapely.transform` function to transform the point into native
    coordinates using the previously defined `wgs84_to_aeqd` function ❺. Shapely points
    have a `buffer` function that adds a defined amount of space around the point.
    Essentially, given a point and a desired amount of buffer space around that point,
    Shapely generates a new set of points representing the location of the boundary
    of the buffer space. We can use this to generate a circle representing the approximate
    coverage area of each tower. Since we defined the units in the AEQD transformation
    function as meters, we can pass the radius for the buffer area in meters as well.
    This is handy because the `accuracy` field returned by the OpenCellID API is also
    in meters. The value in the accuracy field describes how much error is in the
    latitude and longitude. Calling `buffer` with the radius set to the accuracy of
    the radio creates a polygon that represents the estimated location of the tower.
  prefs: []
  type: TYPE_NORMAL
- en: The signal coverage area is a little more difficult to calculate accurately.
    If we wanted to be very specific, we could calculate wave propagation, but then
    we’d need to know the type of tower, its power ratings, its height, and any major
    obstructions. It turns out that the accuracy field also makes a handy signal strength
    estimate. The accuracy of the tower placement tends to be about 30 to 50 percent
    of the optimal signal coverage for the given type of tower. Assuming your target
    is in a metropolitan area, 30 to 50 percent is also a fair guess for signal dampening,
    especially without knowing any more about the towers or landscape itself. So I
    like to use the accuracy field as a quick-and-dirty guess at coverage area as
    well ❻. By passing the accuracy as the radius to the `buffer` function, we’re
    defining a circle whose bounds will represent the probable coverage area of the
    tower. In reality the tower may not be in the center of the circle, but it will
    fall somewhere within it. This means the actual coverage area may be a bit bigger
    or smaller depending on the landscape and architectural construction of the area
    around the tower, but this will make a good starting point for our proof of concept.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a circular polygon defined around each tower’s *x* and
    *y* location that represents an approximation of its covered service area, but
    the points representing the hull of the polygon are currently in native map coordinates.
    To transform them into geodesic coordinates, we call `shapely.transform` again,
    this time with the `aeqd_to_wgs84` function ❼, and return the results.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we call the `apply` function to get the result of the `get_shapely_circle`
    function for each row in `geo_df` (setting `axis=1` operates on rows instead of
    columns) and use the results to overwrite the original `geometry` column in the
    data with the new polygons ❽.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Search Area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section we tackled the first big hurdle to our project. We
    can now convert the latitude and longitude of a tower, along with the accuracy
    estimation, into a geometric object representing the potential service area for
    that tower. We’ve also converted the points around the hull of the geometry back
    into latitude and longitude coordinates we can use with maps. Our next step is
    to find the geographic area where all of these polygons overlap, or more formally,
    *A*∩(*B*, *C*, . . . , *N*) where *A*, *B*, *C*, and so forth represent the polygons
    created during the previous steps. To accomplish this, we’ll borrow some code
    from Stack Overflow^([8](b01.xhtml#c08-endnote-008)) that performs repeated Boolean
    operations to find the intersection between *A* and each other polygon. Let’s
    start by defining a function to handle the simplest case: returning the difference
    and intersection of two polygons, *A* and *B*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-7](#listing8-7) shows the partitioning code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: Partitioning polygons into difference and intersection elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check for the simplest case: when polygon *A* doesn’t intersect polygon
    *B* anywhere. In this case, we simply return both polygons along with an empty
    `GeometryCollection` object. If there’s some overlap between the two polygons,
    we want to return three things. First, we want to return the two differences—that
    is, the part of *A* that doesn’t overlap *B* and vice versa. The two differences
    are stored in `only_a` and `only_b`. Then, we also want to return the intersection
    of the two, which can be found using Shapely’s `intersection` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 8-7](#listing8-7) will be used within the main function
    that solves the intersection code, which uses a slightly modified version of a
    *sweep line algorithm*, a very famous way to efficiently process an arbitrarily
    large set of shapes with some Boolean operations (such as unions and intersections).
    Rather than stopping at each point, we sweep over whole polygons and compare them
    to all previously known polygons. Each pair of polygons and its subgeometries
    will be iteratively collected and compared to see which parts of *A* overlap with
    the other polygons. These overlaps will be treated as subsets of geometry and
    checked in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-8](#listing8-8) shows the main function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-8: Sweep line algorithm for cascading intersection of polygons^([9](b01.xhtml#c08-endnote-009))'
  prefs: []
  type: TYPE_NORMAL
- en: First we create the `result` field with the first polygon in the list to check
    for intersection ❶. We loop over the rest of the polygon list and use the `partition`
    function from [Listing 8-7](#listing8-7) to generate all of the intersections
    and differences for the polygons (*B*, . . . , *N*) ❷. For each of these, we check
    the geometry to ensure no empty geometry objects get passed through ❸. Once we
    create all these subgeometries, we can take the cascading union to create the
    remainder section of polygon *A*. This represents the shape of *A* that doesn’t
    intersect any other polygon ❹. If it is non-empty, we add it to the current list
    of results ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we once again loop over the resulting intersections ❻ to see which of
    them also intersects with the primary polygon *A* ❼. We repeat this process until
    no more intersections are left to check. Sometimes the intersection operation
    creates tiny polygons, which are really just artifacts that we can toss. To do
    so, we have a second function that compares each intersection polygon’s area to
    the area of the first polygon; if it’s less than 1*e* – 16 × `A.area`, the polygon
    is removed. The remaining polygons are assigned back to the `only_poly1` variable
    ❽ (we’ll cover the `eliminate_small_areas` function momentarily). Lastly, we check
    if the remaining polygon list is empty. If not, we append it to the list of results
    being held in the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can now call the `cascaded_intersections` function with the list of tower
    service areas represented by the shape data stored in the `geometry` column of
    the `geo_df` data. We create a list containing the shape data we generated in
    [Listing 8-6](#listing8-6) representing the tower service areas and assign it
    to the `polys` variable ❾. We pass the zeroth polygon in the `polys` list as the
    first argument to the `cascaded_intersections` function. This will be the primary
    polygon (polygon *A*) the rest of the algorithm is considering intersections for.
    We pass the remainder of the list as the second argument (polygons *B*–*N*) to
    tell the `cascaded_intersections` function these are the polygons that may intersect
    polygon *A*. The `cascaded_intersections` function returns a list of different
    geometries of interest, which we assign to the `results` variable ❿.
  prefs: []
  type: TYPE_NORMAL
- en: 'The zeroth element of `results` will be the remainder of polygon *A* that doesn’t
    intersect with any other polygon. The first element will be the intersection of
    polygon *A* with all the other polygons. The remaining elements will depend on
    the layout of the polygons but will follow the pattern (*A*⋂*B* ∉ *CD*, *A*⋂*BC*
    ∉ *D*. . .). We need only the first element, the intersection of all the polygons,
    but the other results are there for you to explore on your own as well. One way
    we might use this output is to print out the minimum and maximum values for the
    latitude and longitude of the intersection result. This gives us a boundary in
    the shape of a box that completely encloses the geometry of the intersection polygon.
    We can find this search area pretty simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First we create two variables, `x` and `y`, to hold their respective list of
    coordinate values. Remember that we’ve already converted the coordinates to latitude
    and longitude, so all we need to do now is print out the minimum and maximum values
    from each list to find the latitude and longitude bounds of our search area. The
    output of the code for our test towers is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The coordinates in the output represent the lower-left and upper-right corners
    and can be used to form a box around the polygon resulting from the cascaded intersection
    function. We could give this information to a ground team who could go to the
    area and perform a search.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 8-8](#listing8-8) relies on the `eliminate_small_areas`
    function, which, by comparison, is very simple to grok. [Listing 8-9](#listing8-9)
    shows the code to eliminate any potential artifact polygons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-9: Removing small area polygons'
  prefs: []
  type: TYPE_NORMAL
- en: First we use `isinstance` to check whether the polygon passed in is an instance
    of a single polygon ❶. If it is, we check if the polygon’s area is smaller than
    the `small_area` parameter. If so, we return an empty `GeometryCollection`; otherwise,
    we return the polygon instance. If the object passed in the `poly` parameter isn’t
    an instance of a single polygon, we assert it must then be an instance of a `MultiPolygon`
    (essentially a list of polygons). If the assertion fails (say you pass in a dictionary
    by mistake), the code will raise an exception ❷. In the case where the object
    is a `MultiPolygon`, we use list comprehension to check each individual polygon’s
    area against the `small_area` parameter ❸. If the length of the resulting list
    is 0 ❹, no polygons remain after the artifacts are removed, so we return `EMPTY`.
    If exactly one polygon object remains in the list ❺, we return it as a single
    polygon instance; there’s no need to carry the additional weight of a `MultiPolygon`
    object forward. Otherwise, if more than one polygon remains in the list, we return
    them all as a `MultiPolygon` object ❻.
  prefs: []
  type: TYPE_NORMAL
- en: After we call the `cascading_intersections` function, we can plot the first
    item in the result to see the search area identified. [Figure 8-4](#figure8-4)
    shows the polygon representing the intersection of all the towers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c08/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Intersection of all four towers as a polygon'
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the shape of the polygon in [Figure 8-4](#figure8-4) to the overlapping
    areas from [Figure 8-3](#figure8-3), you’ll see that they look very similar, meaning
    we’ve achieved our goal of programmatically identifying the area of interest.
    We could pass these coordinates in raw form to any GPS device to create a more
    accurate bounded search area.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the Search Area for Investigators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could also overlay the result on a map to see the search area we should pass
    on to investigators, as shown in [Figure 8-5](#figure8-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c08/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: Resulting search area'
  prefs: []
  type: TYPE_NORMAL
- en: The polygon lays directly over the area known as Seattle Center, home of the
    Space Needle. Indeed, when I captured the sample data I was standing near the
    foot of the Space Needle, close to the center of the search area. Now let’s compare
    our result to the one presented by the OpenCellID API, shown in [Figure 8-6](#figure8-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502567c08/f08006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: Comparing location estimates'
  prefs: []
  type: TYPE_NORMAL
- en: The light gray outer circle shows the search area provided by the OpenCellID
    API based on three of the four sample towers (it was actually more accurate after
    one of the towers was removed). The dark gray area near the middle is our search
    area produced using basic computational geometry. As you can see, we have reduced
    the overall search area considerably. Also worth mentioning is that the OpenCellID
    result is centered on the very edge of our search area, which means my actual
    location was farther from the center of the search area.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the Search Area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using cell tower data will never be as accurate or reliable as GPS, but there
    are still some techniques we can apply to improve the result. By improving the
    signal coverage, you’ll get more accurate search areas. They may actually be smaller
    in area, but your confidence will be higher, leading to better resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: To further reduce the search area, you can take advantage of Wi-Fi networks
    in the area, if any are available. I wouldn’t rely on them to find the initial
    search area, but they’re a good option for shrinking a search area once you’ve
    defined one. I’m a fan of the WiGLE database for Wi-Fi searches, but the OpenCellID
    API also supports Wi-Fi antennas, as I mentioned previously. By combining the
    two APIs (and any additional APIs you may find), you’ll improve your chances of
    finding networks with location information available. You can use the limited
    range of these networks to drastically reduce the search area, sometimes to a
    single building. The FCC has investigated using this type of Wi-Fi geolocation
    as one option to help emergency service dispatchers find callers who don’t know
    their location.
  prefs: []
  type: TYPE_NORMAL
- en: You may also choose to use cell towers in your data that have the weakest signal,
    if you can capture the necessary information from the device you want to locate.
    Ideally, you’ll find several towers with weak signals. These usually turn out
    to be the towers that are farthest apart and thus create the smallest overlapping
    region. This is purely heuristic, though, since a weak signal could also indicate
    a closer tower with more obstructions. If you can capture multiple antennas (say
    12 different towers), you can try an iterative approach by testing different groups
    of three to four antennas at a time. You can compare the resulting search areas
    and determine a sort of search area heat map, where the most likely places are
    the ones that show up in the highest number of polygon intersections (or the overlap
    of the overlaps, if you prefer).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The power of geolocation in a security context can’t be overstated. In a world
    of cell phones, evolving smart cities, and the proliferation of the Internet of
    Things (IoT), people are constantly saturated by network transmissions. As you’ve
    seen, an intrepid researcher, corporate overlord, or motivated hacker can take
    this information and turn it into a physical location. Combine that with the common
    business practice of helpfully naming Wi-Fi access points after the company, and
    it becomes a scarily accurate tracking tool. There are a lot of ethical and legal
    concerns you should consider before you deploy this type of tracking system beyond
    a research environment.
  prefs: []
  type: TYPE_NORMAL
- en: There are several data sets that encourage users to contribute up-to-date information
    on the towers in their area through a process called *war driving*. Despite its
    antisocial name (rooted in hacker history), war driving is simply traveling around
    an area recording what networks are visible. Some folks have even attached recording
    devices to their outdoor animals so that, as the animal wanders, it also contributes
    to the owner’s network map.^([10](b01.xhtml#c08-endnote-010))
  prefs: []
  type: TYPE_NORMAL
- en: It’s not all gloom and doom, though. In the next project we’ll look at applying
    the same principles of converting physical locations into geometric data to help
    a city plan for new emergency services. We’ll revisit the topic of tessellation
    and discuss one of my favorite geometric algorithms, the Voronoi diagram.
  prefs: []
  type: TYPE_NORMAL
