- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Tracking People in Physical Space with Digital Information
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字信息跟踪人们在物理空间中的位置
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Let’s continue our discussion of computational geometry with a somewhat controversial
    topic: tracking people in physical space using digital information. It’s no secret
    that law enforcement agencies across the globe rely heavily on cell phone tracking
    to locate and apprehend suspects. You might think this requires them to get a
    warrant and then subpoena the GPS records from a wireless provider, but this isn’t
    always the case, nor is it strictly necessary. Using publicly available information
    and basic geometry, you can (somewhat) accurately place a phone in a given area,
    even if it doesn’t have GPS. As long as it’s connected to a cellular or wireless
    network, you have a good shot at locating it.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论计算几何学的话题，谈到一个有点争议的话题：使用数字信息跟踪人们在物理空间中的位置。全球的执法机构依赖手机追踪来定位和逮捕嫌疑人，这一点已不再是秘密。你可能认为这需要他们获得搜查令，然后从无线提供商那里传唤GPS记录，但事实并非总是如此，也不一定严格需要。利用公开可用的信息和基本的几何学，你可以（在某种程度上）准确地定位一部没有GPS的手机所在的区域。只要它连接到蜂窝或无线网络，你就有很好的机会定位它。
- en: 'The triangulation process relies on knowing a few things: first, the location—that
    is, physical latitude and longitude—and configuration for a large number of wireless
    network hubs, like cell phone towers; second, the approximate broadcast range
    of these devices; and finally, the signal strength at the cell phone for a set
    of networks the device can communicate with. This may seem like a tall order,
    but the first two have already been handled for us by the nice folks at Unwired
    Labs with their service OpenCellID. The third topic we’ll discuss in the next
    section.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 三角定位过程依赖于知道几个信息：首先，位置——即物理的纬度和经度——以及大量无线网络枢纽的配置，如手机基站；其次，这些设备的大致广播范围；最后，手机在一组网络中可以通信的信号强度。这看起来可能是一个难题，但前两个问题已经由Unwired
    Labs的团队通过他们的OpenCellID服务为我们解决了。第三个问题将在下一节中讨论。
- en: Once you have a basic understanding of the data, we’ll cover some of the ethical
    implications surrounding this project. After that, we’ll look at the OpenCellID
    API in more detail and discuss how to find the location of individual towers and
    use the API’s Geolocation solver to get an address and an accuracy estimate.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对数据有了基本的了解，我们将探讨一些围绕这个项目的伦理影响。之后，我们将更详细地介绍OpenCellID API，并讨论如何找到单个基站的位置，使用API的地理位置求解器获取地址和准确度估计。
- en: Gathering Cellular Network Data
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集蜂窝网络数据
- en: There are several options for getting network information from a phone, ranging
    from sophisticated hardware attacks to very simple ones that use built-in utilities.
    Hardware attacks are beyond the scope of this book, but check out the books *Android
    Security Internals*^([1](b01.xhtml#c08-endnote-001)) and *The Android Hacker’s
    Handbook*^([2](b01.xhtml#c08-endnote-002)) for an introduction to this topic for
    Android phones, as well as *iOS Hacker’s Handbook*^([3](b01.xhtml#c08-endnote-003))
    for Apple devices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从手机获取网络信息，从复杂的硬件攻击到使用内置工具的非常简单的方法。硬件攻击超出了本书的范围，但你可以查看《*Android安全内部*》^([1](b01.xhtml#c08-endnote-001))
    和《*Android黑客手册*》^([2](b01.xhtml#c08-endnote-002))，了解关于Android手机的这方面内容，也可以参考《*iOS黑客手册*》^([3](b01.xhtml#c08-endnote-003))，了解Apple设备的相关信息。
- en: 'The network interface data we need seems so simple and innocuous that it’s
    often made available to almost every application running on a cell phone, tablet,
    laptop, or other wireless-enabled devices. If you’re like me, you’re probably
    very picky about which applications can access your location data directly, but
    just about every app has a built-in reason to require network access: updates.
    Unfortunately, this means these applications can see which networks are visible
    and how strong their signal is. Thanks to the OpenCellID API, this information
    is almost as good as having a GPS signal, so if you had an exploit for any one
    of these apps, you could potentially use that to retrieve the information.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的网络接口数据看起来非常简单且无害，以至于几乎每个在手机、平板电脑、笔记本电脑或其他支持无线功能的设备上运行的应用程序都能获取到。如果你像我一样，可能会对哪些应用程序可以直接访问你的位置信息非常挑剔，但几乎每个应用程序都有内置的理由要求网络访问：更新。不幸的是，这意味着这些应用程序可以看到哪些网络是可见的，以及它们的信号强度。多亏了OpenCellID
    API，这些信息几乎和拥有GPS信号一样有效，因此，如果你能利用这些应用程序的某个漏洞，可能会用它来获取这些信息。
- en: As an experiment, you can try to manually scan the cellular networks in your
    area. Most phones have an option to manually select the cell network you want
    to connect with. To find it, search your phone’s make and model along with “manual
    cell network selection.” There’s also a plethora of apps available to perform
    this task, although I prefer to use the phone’s built-in capabilities before downloading
    any. Suffice to say, from this point forward I’ll assume you have access to the
    device’s network data through some legal means. I’ve also provided the sample
    data I used when developing the examples so that you can follow along without
    access to any device.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，你可以尝试手动扫描你所在区域的蜂窝网络。大多数手机都有一个手动选择蜂窝网络的选项。要找到它，可以搜索手机的型号和“手动选择蜂窝网络”。市面上还有很多应用可以执行此任务，尽管我更倾向于在下载任何应用之前，先使用手机自带的功能。可以说，从这一点开始，我假设你通过某种合法方式能够访问设备的网络数据。我还提供了在开发示例时使用的样本数据，供你跟随学习，即使你无法访问任何设备也可以进行操作。
- en: We’ll be working with the OpenCellID API throughout this project, so let’s take
    a moment to discuss what it is and why we’ll be using it. The OpenCellID API is
    an online service that stores information about cellular network base stations,
    such as location and network type. *Base stations* are what people usually mean
    when they refer to a cell network’s towers. Technically, the part of the tower
    we’re used to seeing just holds the physical antennas; the real brains of the
    operation are housed near the base of the antennas. These boxes contains the hardware
    and application logic necessary to route traffic from devices onto the cell provider’s
    network infrastructure and its final destination. For the rest of the chapter,
    I’ll use the terms *base station* and *tower* interchangeably.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用 OpenCellID API，所以我们先花一点时间来讨论它是什么，以及为什么我们要使用它。OpenCellID API 是一项在线服务，存储有关蜂窝网络基站的信息，如位置和网络类型。*基站*通常是人们所说的蜂窝网络的塔。技术上来说，我们通常看到的塔部分仅仅承载了物理天线；实际操作的大脑部分位于天线底部附近。这些箱子包含了必要的硬件和应用逻辑，用来将设备的流量引导到蜂窝网络提供商的网络基础设施并最终到达目的地。在本章的其余部分，我将交替使用*基站*和*塔*这两个术语。
- en: After creating a free account and getting an API access token, you’ll have access
    to the data through an online REST API. Having publicly accessible data about
    cell networks is useful in a number of security applications, aside from tracking
    physical locations. If you’re traveling within any metropolitan area, your phone
    is being bounced from tower to tower. This usually happens seamlessly in the background
    and can occur for a couple of different reasons. Cell networks are constantly
    balancing traffic by asking devices to connect to other towers. When a base station
    detects that it’s becoming bogged down with traffic, it may tell new devices to
    find a different tower to handle their traffic. Your phone is also programmed
    to try to connect to the base station with the strongest signal first and then
    try others in descending order as necessary. Having your device bouncing across
    all these towers creates the potential for an adversary to introduce a rogue base
    station (one they control the application logic for) with a strong enough signal
    to trick nearby devices into connecting to it. As your phone is bouncing around,
    having access to a publicly curated list of known cell towers can help to ensure
    your device connects only to legitimate cell networks. The online portal for OpenCellID
    ([https://opencellid.org](https://opencellid.org)) can also be used to explore
    the data available in a geographic region.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个免费账户并获得 API 访问令牌后，你将通过在线 REST API 获取数据。除了跟踪物理位置之外，关于蜂窝网络的公开可访问数据在许多安全应用中也很有用。如果你在任何大城市地区旅行，手机会在塔与塔之间切换。通常这一过程会在后台无缝进行，且发生的原因有几个。蜂窝网络通过让设备连接到其他塔来不断平衡流量。当一个基站检测到其流量过载时，它可能会指示新的设备连接到其他塔来处理流量。你的手机还会被编程为优先连接信号最强的基站，然后根据需要依次连接其他信号较弱的基站。你的设备在这些塔之间的切换可能会为攻击者提供机会，诱使他们通过一个足够强的信号，在附近的设备之间插入一个恶意的基站（他们控制应用逻辑的基站）。当你的手机在不同塔之间切换时，公开的已知基站列表能够帮助确保你的设备只连接到合法的蜂窝网络。OpenCellID
    的在线门户([https://opencellid.org](https://opencellid.org)) 也可以用来探索某一地理区域内可用的数据。
- en: '[Figure 8-1](#figure8-1) shows the OpenCellID map for the Pike Place Market
    area of Seattle, retrieved from its online portal.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](#figure8-1) 显示了来自 OpenCellID 的西雅图派克市场区域的地图，数据来自其在线门户。'
- en: '![](image_fi/502567c08/f08001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c08/f08001.png)'
- en: 'Figure 8-1: Network data for the Pike Place Market area'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：派克市场区域的网络数据
- en: 'This image was captured from the OpenCellID main site. The gray circles are
    clusters of radios that OpenCellID has information for. The number in the center
    of the circle shows how may radios are in that cluster. You can also see a few
    pins with letter labels. These are single network instances where the letter denotes
    the type of radio that’s being used to communicate. The key in the lower right
    of the map shows the four major network types available: GSM, CDMA, UMTS, and
    LTE. The Jupyter notebook that accompanies this section has more details on each
    type of network.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片是从 OpenCellID 主网站获取的。灰色圆圈表示 OpenCellID 拥有信息的无线电簇。圆圈中央的数字显示了该簇中有多少个无线电设备。你还可以看到一些带字母标签的图钉。这些是单一的网络实例，字母表示用于通信的无线电类型。地图右下角的关键字展示了四种主要的网络类型：GSM、CDMA、UMTS
    和 LTE。与本节内容相关的 Jupyter notebook 里有更多关于每种网络类型的详细信息。
- en: These four network types make up the core radio towers we’ll use to locate equipment
    based on their proximity to a set of fixed radio locations. There is another network
    type that isn’t shown on the map, Wi-Fi routers, which you can also use to get
    more precise results in some cases. The problem is, when compared to cellular
    network towers, Wi-Fi routers are ephemeral. They may be turned off, or worse
    (for our purpose), relocated without the OpenCellID database being updated, which
    would throw our analysis into a tailspin. We’ll stick to cellular towers in the
    example data, but you should definitely explore the Wi-Fi option on your own.
    There are online services such as WiGLE ([https://www.wigle.net](https://www.wigle.net))
    that are similar to OpenCellID but for Wi-Fi networks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种网络类型构成了我们将用来根据固定无线电位置集来定位设备的核心基站。还有一种网络类型在地图上没有显示，那就是 Wi-Fi 路由器，在某些情况下，你也可以使用
    Wi-Fi 路由器获得更精确的定位结果。问题是，与蜂窝网络塔相比，Wi-Fi 路由器是短暂的。它们可能会关闭，或者更糟的是（对我们来说），在 OpenCellID
    数据库没有更新的情况下被重新定位，这会让我们的分析陷入困境。在示例数据中，我们将坚持使用蜂窝基站，但你一定可以自己探索 Wi-Fi 选项。有些在线服务，如
    WiGLE ([https://www.wigle.net](https://www.wigle.net))，它们类似于 OpenCellID，但专注于 Wi-Fi
    网络。
- en: Each tower is uniquely identified by a country code and network ID. The data
    contains estimates on the effective range for the type of network, such as 1 kilometer
    for most CDMA antennas; it also contains the approximate latitude and longitude
    of the antenna, other bits to track when it was last verified, and more. By taking
    several visible network towers and seeing where they overlap service, we should
    be able to determine the small portion of earth where the device could be located.
    To do so, we’ll create polygons representing the service areas for each base station
    based on the network type. We’ll then overlay the polygons in relation to one
    another and find the area that all the networks have in common using the Shapely
    library’s `intersection` and `difference` functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个基站都有一个唯一的国家代码和网络 ID。数据中包含有关网络类型的有效范围估算值，例如大多数 CDMA 天线的有效范围是 1 公里；还包括天线的大致经纬度、其他验证信息，以及更多内容。通过获取几个可见的网络基站并查看它们的服务覆盖区域，我们应该能够确定设备可能位于的地球小部分区域。为此，我们将根据网络类型创建表示每个基站服务区域的多边形。然后，我们将把这些多边形彼此叠加，并使用
    Shapely 库的 `intersection` 和 `difference` 函数找出所有网络共享的区域。
- en: Before we dive into the nuts and bolts of the data, there are some privacy concerns
    we should consider. The decisions we make as security researchers can negatively
    impact the privacy and security of large portions of society in unintended ways.
    In the next section, we’ll cover some considerations to keep in mind before you
    undertake any project related to device tracking.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入数据的细节之前，我们应该考虑一些隐私问题。作为安全研究人员，我们做出的决策可能会以意想不到的方式对社会的大部分隐私和安全产生负面影响。在下一节中，我们将讨论在进行任何与设备跟踪相关的项目之前需要考虑的一些事项。
- en: Ethics of Tracking Devices and People
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪设备和人员的伦理
- en: In some ways, criminals have it easy. A criminal doesn’t have to consider the
    ethical or moral implications of their actions. Whether they’re exposing their
    target to additional risk is usually not high on their list of concerns. White
    hats, on the other hand, have ethical, and oftentimes legal, barriers to consider
    when obtaining or using location information. In the past, I’ve received records
    similar to the data for this project from company-owned devices via remote administration
    tools after an employee’s laptop or cell phone went missing. However, even this
    seemingly benevolent use is an ethical gray area. Here in the US there isn’t a
    clear line on an employee’s right to privacy.^([4](b01.xhtml#c08-endnote-004))
    It’s easy to say, “If a company owns a system they have the right to track and
    monitor it,” but what about people who carry their work systems with them during
    off-hours (something I regularly do myself)? Several companies even require their
    managers to keep work phones on them during their downtime—even on vacation. There’s
    nothing technical to block these companies from tracking their employees during
    their private time, and the laws are murky and vague, so it becomes purely a question
    of ethics. When dealing with corporate entities, being forced to trust their ethical
    behavior scares a lot of people!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，罪犯反而轻松。罪犯不必考虑他们行为的伦理或道德影响。他们是否让目标面临更高的风险，通常不会是他们关注的重点。另一方面，白帽子黑客在获取或使用位置信息时，必须考虑伦理以及通常涉及的法律障碍。在过去，我通过远程管理工具从公司拥有的设备上获得了类似于本项目数据的记录，这些设备是在员工的笔记本电脑或手机丢失后才得到的。然而，即使这种看似出于善意的使用，也是一个伦理灰色地带。在美国，关于员工隐私权的界限并不明确。^([4](b01.xhtml#c08-endnote-004))
    很容易说，“如果公司拥有一个系统，他们有权追踪和监控它，”但如果人们在非工作时间携带工作系统（比如我自己经常做的事情）呢？有些公司甚至要求管理人员在空闲时间——甚至是度假时——也要随身携带工作手机。这些公司没有技术手段来阻止追踪员工的私人时间，而且法律模糊不清，因此这纯粹变成了一个伦理问题。当涉及到企业实体时，许多人害怕被迫相信它们的伦理行为！
- en: Understanding how this technology works, and how to apply it ethically to improve
    security without hurting privacy, falls to us as researchers and analysts. After
    reading this chapter, take some time to look up the relevant laws for your area
    and, perhaps even more importantly, think about what you believe are appropriate
    and inappropriate uses for this technology.^([5](b01.xhtml#c08-endnote-005))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种技术的工作原理，以及如何将其道德地应用于提高安全性而不损害隐私，是我们作为研究人员和分析师的责任。在阅读完这一章后，花些时间查阅你所在地区的相关法律，也许更重要的是，思考一下你认为这种技术的适当和不适当的使用方式。^([5](b01.xhtml#c08-endnote-005))
- en: For our project, I collected the data on myself using an Android tablet. As
    the data subject, I was aware of the data collection and gave myself, as the author,
    permission to use the data in the limited scope of writing this material. The
    key point here is that the data subject (me) was informed and gave consent. Getting
    informed consent to perform your analysis can prevent a lot of ethical risk before
    you even begin. If you apply this type of tracking technology outside the scope
    of informed consent (such as law enforcement or military applications), you must
    decide for yourself what ethical doctrine applies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我使用一台 Android 平板电脑收集了关于我自己的数据。作为数据主体，我知道数据的收集并且允许自己，作为作者，在写作此材料的有限范围内使用这些数据。这里的关键点是，数据主体（我）已经被告知并且给出了同意。获取知情同意进行分析可以在开始之前避免很多伦理风险。如果你在知情同意的范围之外应用这种追踪技术（例如在执法或军事应用中），你必须自己决定适用哪种伦理原则。
- en: Now that we’ve discussed the ethics of device tracking in general, and more
    specifically concerning the various potential applications of our project, we
    can get into the meat of the problem. In the next section we’ll take a deeper
    dive into the OpenCellID API, covering the basics of calling the API, the structure
    of the data returned, and how we can process this information into relevant shape
    objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了设备追踪的伦理问题，尤其是与我们项目的各种潜在应用相关的问题，我们可以进入问题的核心部分。在下一部分，我们将深入探讨 OpenCellID
    API，介绍如何调用 API、返回数据的结构，以及如何将这些信息处理成相关的形状对象。
- en: The OpenCellID API Structure
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenCellID API 结构
- en: 'Technically speaking, OpenCellID is a RESTful API that uses client secret keys
    to identify users. To access the OpenCellID data, you’ll need to sign up for one
    of these API keys. It’s free and easy: you simply provide an email and a use case
    (like “Research”), and you’ll get back an alphanumeric key. Your account comes
    with a limit of 5,000 requests a day, but this should be more than enough for
    most applications. If you’re smart about caching responses, you should be able
    to spread those out even more.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，OpenCellID是一个RESTful API，使用客户端密钥来识别用户。要访问OpenCellID数据，你需要注册其中一个API密钥。它是免费的且易于操作：你只需要提供一个电子邮件和使用案例（如“研究”），然后你将获得一个字母数字密钥。你的账户每天有5000次请求的限制，但对于大多数应用来说，这已经足够。如果你聪明地缓存响应，你应该能将这些请求分散得更开。
- en: 'There are two common workflows supported by the API. *Geolocation* is the process
    of turning latitude and longitude information into a location on earth, like “123
    Main Street, Seattle, WA.” Geolocation comes up a lot both inside and outside
    of security, so it’s a good idea to become familiar with the process. *Geocoding*
    works in the opposite direction: you take an address and return the latitude and
    longitude of that point. We’ll mostly be working with the Geolocation portion
    of the API, but it’s worth noting OpenCellID also has API calls to help with map
    displays and calls for monitoring your usage. As you develop your own application,
    you’ll want to take advantage of those additional features.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: API支持两种常见的工作流。*地理定位*是将纬度和经度信息转化为地球上的位置，例如“123 Main Street, Seattle, WA”。地理定位在安全领域内外都经常出现，因此熟悉这个过程是个好主意。*地理编码*则是反向操作：你获取一个地址并返回该位置的纬度和经度。我们主要会使用API中的地理定位部分，但值得注意的是，OpenCellID还提供API调用，帮助显示地图以及监控你的使用情况。在你开发自己的应用时，你将希望利用这些额外的功能。
- en: '[Listing 8-1](#listing8-1) shows the structure of a simple request to the API.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](#listing8-1)展示了一个简单的API请求结构。'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: The structure of the API payload'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1：API有效负载的结构
- en: Every request needs to contain the alphanumeric `token` that you received when
    you signed up ❶. The `radio` field ❷ identifies the primary network type of the
    device we’re looking into. Setting this field doesn’t restrict the types of radios
    that you can pass in the `cells` field ❹, however, which represents the base stations
    that are visible to the device. We’ll revisit the `cells` field more in a moment,
    but first, let’s discuss how networks are identified and grouped.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都需要包含你在注册时获得的字母数字`token` ❶。`radio`字段 ❷标识我们正在查看的设备的主要网络类型。设置此字段并不会限制你在`cells`字段
    ❹中传递的无线电类型，`cells`字段代表设备可以看到的基站。我们稍后会再次讨论`cells`字段，但首先，让我们讨论一下如何标识和分组网络。
- en: Each country is assigned a three-digit *mobile country code (MCC)*. Most countries
    actually have several MCCs assigned to break up the geography into smaller chunks
    that make it easier to manage the traffic for any one region. To uniquely identify
    a mobile subscriber’s network, the MCC is combined with a *mobile network code
    (MNC)* into the *home network identity (HNI)*, which concatenates both pieces
    of information into one string.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个国家都会分配一个三位数的*移动国家代码（MCC）*。实际上，大多数国家都会分配几个MCC，以便将地理区域划分为更小的区域，从而更容易管理任何一个地区的流量。为了唯一标识一个移动用户的网络，MCC与*移动网络代码（MNC）*组合成*家庭网络标识（HNI）*，将这两部分信息拼接成一个字符串。
- en: In [Listing 8-1](#listing8-1), the device has an MCC of 310 ❸ (which is the
    first of seven MCCs assigned to North America, numbered 310–316) and an MNC of
    120, so the HNI is 310120\. Using the HNI, OpenCellID can determine what service
    provider and network segment a device belongs to when it sends a query to the
    API. You can pull this information off the device you’re testing or pass some
    default network MCC and MNC, which is what we do in the code for this project.
    If you look up the HNI from [Listing 8-1](#listing8-1), you’ll see it belongs
    to the Sprint Spectrum network ([https://imsiadmin.com/assignments/hni](https://imsiadmin.com/assignments/hni))
    in North America.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 8-1](#listing8-1)中，设备的MCC为310 ❸（这是分配给北美的七个MCC中的第一个，编号为310-316），MNC为120，因此HNI为310120。通过HNI，OpenCellID可以确定设备属于哪个服务提供商和网络段，当它向API发送查询时，你可以从你正在测试的设备上提取此信息，或者传递一些默认的网络MCC和MNC，这也是我们在这个项目的代码中所做的。如果你查找[清单
    8-1](#listing8-1)中的HNI，你会看到它属于北美的Sprint Spectrum网络([https://imsiadmin.com/assignments/hni](https://imsiadmin.com/assignments/hni))。
- en: Now, returning to the `cells` field, we see a list of nested JSON objects. We
    can send between one and seven radio identifiers to OpenCellID to help pinpoint
    location more accurately. You can even contact Unwired’s development team to increase
    that number if you need to (but that’s unlikely).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`cells`字段，我们看到一个嵌套JSON对象的列表。我们可以向OpenCellID发送1到7个无线电标识符，以帮助更准确地定位。如果需要，你甚至可以联系Unwired的开发团队来增加这个数量（但这不太可能）。
- en: The next section of the data contains the radios we’d like to retrieve information
    about. The radio objects we send can be any mix of supported radio types. We identify
    each radio using two numbers based on its physical locations. Cell networks are
    divided into several geographic areas, each of which can support between 1 and
    65,534 base stations. Each geographic area is assigned a unique *location area
    code (LAC)*. Similar to the area code prefix on a telephone number, a LAC describes
    roughly where the base station is located. The second number is the *cell ID (CID)*,
    which identifies each individual base station within a LAC ❺. You can think of
    the LAC and the CID like a zip code and a street address, respectively. They work
    together to create a unique identifier for every base station on a network. Finally,
    the `address` field ❻ tells the API to return the human-readable address along
    with the other result fields. If you don’t need the address, you can save some
    bytes by excluding this field.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的下一个部分包含了我们希望检索信息的无线电。我们发送的无线电对象可以是任何支持的无线电类型的混合。我们通过两个数字来标识每个无线电，这两个数字基于其物理位置。蜂窝网络被划分为多个地理区域，每个区域可以支持1到65,534个基站。每个地理区域分配一个唯一的*位置区域码
    (LAC)*。类似于电话号码的区号，LAC大致描述了基站所在的位置。第二个数字是*小区ID (CID)*，它标识LAC内的每个独立基站❺。你可以把LAC和CID分别想象成邮政编码和街道地址。它们共同作用，为网络中的每个基站创建一个唯一的标识符。最后，`address`字段❻告诉API返回可读的地址以及其他结果字段。如果你不需要地址，可以通过排除该字段来节省一些字节。
- en: '[Listing 8-2](#listing8-2) defines a Python function called `lookup_tower`
    to send the single radio payload from [Listing 8-1](#listing8-1) to the API.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8-2](#listing8-2)定义了一个名为`lookup_tower`的Python函数，用于将[列表8-1](#listing8-1)中的单个无线电负载发送到API。'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: A function to call the API and decode the response'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8-2：调用API并解码响应的函数
- en: Before running anything, let’s begin by verifying that the URL presented here
    (`https://us1.unwiredlabs.com/v2/process.php`) is still the most up to date and
    appropriate for our use case. Unwired hosts several API endpoints around the world,
    so there may be another that is closer to you or one with less traffic (which
    helps reduce latency). You can do this by going to the Unwired Labs API list at
    [https://unwiredlabs.com/api](https://unwiredlabs.com/api) and selecting Endpoints
    from the options on the left. You can then copy the URL for the API endpoint that
    is geographically closest to you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何内容之前，让我们首先验证此处提供的URL（`https://us1.unwiredlabs.com/v2/process.php`）是否仍然是最新的，并且适合我们的使用场景。Unwired在全球范围内托管多个API端点，因此可能有一个更靠近你或者流量更少（有助于减少延迟）的端点。你可以通过访问Unwired
    Labs API列表[https://unwiredlabs.com/api](https://unwiredlabs.com/api)，然后从左侧选项中选择“Endpoints”来执行此操作。然后，你可以复制地理上最靠近你的API端点的URL。
- en: We must convert the JSON payload into a string object before passing it to the
    request library. To do so, we call the `json.dumps` (short for *dump string*)
    function on our JSON payload. We pass the function to the request library through
    the `data` parameter. The `response` object we get back will be a JSON object
    transmitted as text unless there’s an error, in which case we’ll get a nasty blob
    of HTML and the function will choke when trying to decode the `response.text`
    property. To avoid this, we’d expand our production code to wrap the call to `requests.request`
    in a `try...catch` block or other safety net.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在将JSON负载传递给请求库之前，将其转换为字符串对象。为此，我们在JSON负载上调用`json.dumps`（简写为*dump string*）函数。我们通过`data`参数将该函数传递给请求库。返回的`response`对象将是一个JSON对象，以文本形式传输，除非发生错误，在这种情况下，我们将得到一段糟糕的HTML块，且在尝试解码`response.text`属性时，函数会失败。为了避免这种情况，我们应该扩展生产代码，在调用`requests.request`时使用`try...catch`块或其他安全网。
- en: '[Listing 8-3](#listing8-3) shows the format of the response.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8-3](#listing8-3)展示了响应的格式。'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: A single-tower JSON query response'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8-3：单基站JSON查询响应
- en: The status string will be `"ok"` in cases where the request succeeded and `"error"`
    if the API detected a problem. The `balance` field holds the number of requests
    remaining for the day. We can take the `lat` (latitude), `lon` (longitude), and
    `accuracy` fields to plot the tower on a map. Finally, if we pass the `address=1`
    parameter, the `address` field holds this information as a string. [Figure 8-2](#figure8-2)
    shows the result of [Listing 8-3](#listing8-3) plotted on a map.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 状态字符串将在请求成功时为`"ok"`，如果API检测到问题，则为`"error"`。`balance`字段保存当天剩余的请求次数。我们可以使用`lat`（纬度）、`lon`（经度）和`accuracy`字段将塔定位到地图上。最后，如果传递`address=1`参数，`address`字段将作为字符串保存该信息。[图
    8-2](#figure8-2)展示了[清单 8-3](#listing8-3)中绘制在地图上的结果。
- en: '![](image_fi/502567c08/f08002.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c08/f08002.png)'
- en: 'Figure 8-2: Displaying a tower range'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：显示塔范围
- en: The map area shows the city of Seattle, where the tower is located. The dark
    gray circle in the middle of the image shows the approximate area covered by the
    tower, and the pin in the center of the gray circle represents the exact latitude
    and longitude of the tower. Each of the white lines crisscrossing the image represents
    a city street. You can see the maximum coverage area of one tower is pretty large—several
    city blocks at least. If we had only this one tower to try to locate the device,
    we’d have a lot of ground to cover! In the next section we’ll see how to narrow
    the area further by geolocating several towers and finding their overlapping service
    region using the GeoPandas and Shapely libraries.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 地图区域显示的是塔所在的城市——西雅图。图像中央的深灰色圆圈显示了塔的覆盖区域，灰色圆圈中央的图钉代表塔的精确经纬度。每一条白色的交叉线代表城市街道。你可以看到，一个塔的最大覆盖区域相当大——至少有几个街区。如果我们只有这一座塔来定位设备，那我们就得覆盖大量的区域！在下一节中，我们将看到如何通过地理定位多个塔并使用GeoPandas和Shapely库找到它们重叠的服务区域来进一步缩小区域。
- en: 'The Proof of Concept: Locating a Device from Nearby Cell Towers'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念验证：从附近的基站定位设备
- en: We’ve seen how we can interact with the OpenCellID API to get back information
    on towers in our data. Now it’s time to put this knowledge together into an application
    that will locate a device based on the cell towers within its range. We’ll extend
    the `lookup_tower` function from [Listing 8-2](#listing8-2) to locate each tower
    in the list recovered from the test device. The data we’ll be using to test our
    application can be found in the file *cellular_networks.json* in the chapter’s
    supplemental materials.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何与OpenCellID API交互，以获取我们数据中塔的信息。现在是时候将这些知识结合起来，制作一个应用程序，通过塔的位置来定位设备。我们将扩展[清单
    8-2](#listing8-2)中的`lookup_tower`函数，以定位从测试设备中恢复的塔列表。我们用来测试应用程序的数据可以在本章的补充材料中的*cellular_networks.json*文件中找到。
- en: '[Figure 8-3](#figure8-3) shows the four towers from the sample data laid out
    over a map.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](#figure8-3)展示了从示例数据中获取的四个塔在地图上的布局。'
- en: '![](image_fi/502567c08/f08003.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c08/f08003.png)'
- en: 'Figure 8-3: Tower signal overlap'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：塔信号重叠
- en: Your eye can easily locate the area where all the signals overlap, but it isn’t
    quite as easy for a computer to determine. Therefore, our goal is to programmatically
    identify that portion of the map where all four towers overlap using Shapely to
    produce a bounded search area. We’ll then compare our results with the location
    guess returned from OpenCellID API to see which is more accurate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你的眼睛可以轻松地找到所有信号重叠的区域，但对于计算机来说，确定这一点并不那么容易。因此，我们的目标是通过编程识别地图上所有四个塔重叠的区域，并使用Shapely生成一个有限的搜索区域。然后，我们将把我们的结果与OpenCellID
    API返回的定位猜测进行比较，看看哪个更准确。
- en: Gathering Tower Locations
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集塔位置
- en: Our first step, shown in [Listing 8-4](#listing8-4), is to gather the location
    information from each of the four towers using the `lookup_tower` function from
    [Listing 8-2](#listing8-2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步，如[清单 8-4](#listing8-4)所示，是使用[清单 8-2](#listing8-2)中的`lookup_tower`函数收集每个塔的位置数据。
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: Gathering tower geolocation information'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-4：收集塔的地理位置信息
- en: After loading in the data, we create a `for` loop to loop over each cell ❶.
    We need to send in each tower by itself to get back its geolocation information;
    otherwise, we’ll get back a location guess using the towers you sent to the API
    as the reference information. We’ll replace the cells in the payload from [Listing
    8-1](#listing8-1) with the tower info loaded in from the *networks.json* file
    ❷. In a production application, this would be the portion of information you recover
    from the device you want to track. Next, we call the `lookup_tower` function ❸
    and store the result into a list called `tower_locs` ❹.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载数据后，我们创建一个`for`循环来遍历每个单元格❶。我们需要单独传递每个基站，以便获取其地理位置信息；否则，我们将根据你传递给API的基站作为参考信息来返回一个位置猜测。我们将从[清单
    8-1](#listing8-1)中加载的单元格内容替换为从*networks.json*文件中加载的基站信息❷。在生产应用中，这将是你从设备中恢复的、你想要追踪的信息。接下来，我们调用`lookup_tower`函数❸并将结果存储到一个名为`tower_locs`的列表中❹。
- en: Now we have a list containing JSON objects, which in turn contain geolocation
    information in the form of latitude and longitude coordinates for each tower.
    This is very close to a standard object format called GeoJSON, which many programs
    of different languages know how to interpret. To make our data more flexible and
    standardized, let’s finish converting the data to GeoJSON format. We can do this
    simply enough using the pandas data science library and its sister, GeoPandas,
    which adds support for geometric coordinates and operations. [Listing 8-5](#listing8-5)
    shows how to convert the JSON data the rest of the way to the GeoJSON format.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含JSON对象的列表，每个对象包含每个基站的地理位置信息，形式为经纬度坐标。这与一种标准对象格式GeoJSON非常相似，许多不同语言的程序都能理解这种格式。为了使我们的数据更加灵活和标准化，我们完成将数据转换为GeoJSON格式。我们可以通过使用pandas数据科学库和它的姐妹库GeoPandas来简单地完成这一点，GeoPandas增加了对几何坐标和操作的支持。[清单
    8-5](#listing8-5)展示了如何将JSON数据转换为GeoJSON格式。
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-5: Creating a `GeoDataFrame` from tower locations'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-5：从基站位置创建`GeoDataFrame`
- en: First, we cast the list of JSON objects to a traditional pandas `DataFrame`,
    which gives us a chance to clean up any unnecessary fields in the next line. We’re
    dropping the `status` and `balance` fields since they don’t add any information
    to the analysis. Next, we use the GeoPandas `GeoDataFrame` class to cast `tower_df`
    into the more appropriate geolocation data, which contains a special field, aptly
    named `geometry`, to hold the geometric representation of each row in the `DataFrame`.
    In this case, we use the `lat` and `lon` columns from `tower_df` to define `Point`
    objects, which then get stored in the `geometry` column. The GeoPandas function
    `points_from_xy` takes in an x- and y-coordinate and returns a `Point` object
    that GeoPandas can use to associate a shape object with the data. You can see
    the structure of the `geo_df` data in the output of the 2nd cell in the *OpenCell_API_Examples.ipynb*
    notebook.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将JSON对象列表转换为传统的pandas`DataFrame`，这样我们可以在下一行清理掉任何不必要的字段。我们将删除`status`和`balance`字段，因为它们对分析没有任何帮助。接下来，我们使用GeoPandas的`GeoDataFrame`类将`tower_df`转换为更适合的地理定位数据，其中包含一个特别的字段，恰如其名，叫做`geometry`，用于保存`DataFrame`中每一行的几何表示。在这种情况下，我们使用`tower_df`中的`lat`和`lon`列来定义`Point`对象，这些对象将存储在`geometry`列中。GeoPandas的`points_from_xy`函数接受x和y坐标并返回一个`Point`对象，GeoPandas可以用它将形状对象与数据关联起来。你可以在*OpenCell_API_Examples.ipynb*笔记本的第二个单元格输出中查看`geo_df`数据的结构。
- en: Translating a Geographic Point to a Polygon
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将地理坐标点转换为多边形
- en: 'We’ll be converting these `Point` objects to polygons representing circles,
    but Shapely isn’t aware of specific coordinate systems or units, so first we need
    to convert the latitude and longitude into native (*x*, *y*) coordinates and back
    again. This requires a rather tricky bit of code that can store intermediate results
    and keep track of units. It relies on the pyproj (short for Python Projection)
    and functools libraries to do so. The functools library is for *higher-order functions*,
    functions that act on or return other functions. Examples include functions that
    modify the call structure or translate inefficient call flows into more modern
    and efficient ones*.* Consider the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些`Point`对象转换为表示圆形的多边形，但Shapely并不关心特定的坐标系统或单位，因此我们首先需要将纬度和经度转换为原生的(*x*,
    *y*)坐标，然后再转换回来。这需要一些复杂的代码来存储中间结果并跟踪单位。它依赖于pyproj（Python投影的缩写）和functools库来实现。functools库用于*高阶函数*，即作用于或返回其他函数的函数。例如，它包括修改调用结构或将低效的调用流程转化为更现代和高效的流程的函数。考虑以下示例：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `complex` function takes in five required parameters and prints them all
    out using a format string. But what if we know that in our use case we’ll always
    call `complex` with the same first four parameters and `x` is the only parameter
    we’ll ever need to change? In these situations we can use partial function copies
    to simplify the calling conventions. *Partial functions* allow us to fix a certain
    number of arguments for a function and generate a new function that we can call
    without including those fixed arguments. Here, `functools.partial` allows us to
    create a new simplified version of the `complex` function like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`complex`函数接收五个必需的参数，并使用格式化字符串打印所有参数。但如果我们知道，在我们的用例中，我们总是会使用相同的前四个参数调用`complex`，而`x`是唯一需要更改的参数呢？在这种情况下，我们可以使用部分函数副本来简化调用方式。*部分函数*允许我们为函数固定某些参数，并生成一个新的函数，我们可以在不包含这些固定参数的情况下调用它。在这里，`functools.partial`允许我们创建`complex`函数的一个简化版本，如下所示：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `simple` function now contains a copy of the `complex` function, with the
    first four parameters statically defined to be the values `1`, `1`, `2`, and `3`,
    respectively. Now calling `simple` with any value will result in that value being
    passed to the `complex` function in the `x` parameter. Calling the `simple` function
    with the value `5` is now equivalent to calling the `complex` function with the
    values `1`, `1`, `2`, `3`, and `5`, as we can see from the code’s output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple`函数现在包含了`complex`函数的副本，前四个参数已静态定义为`1`、`1`、`2`和`3`。现在，调用`simple`函数时传入任何值，都会将该值作为`x`参数传递给`complex`函数。调用`simple`函数并传入值`5`现在等同于调用`complex`函数，并传入`1`、`1`、`2`、`3`和`5`，正如我们从代码的输出中看到的那样：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ll use the `functools.partial` function to programmatically create two new
    functions to handle the coordinate translations. To do so, we’ll be using the
    pyproj library, which is designed to translate between different coordinate systems
    internally. The `Proj` class can convert from geographic (lat, lon) to native
    map projection (*x*, *y*) coordinates and vice versa, which is perfect for our
    needs. [Listing 8-6](#listing8-6) shows the function I found and modified from
    a related GIS Stack Exchange post.^([6](b01.xhtml#c08-endnote-006))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`functools.partial`函数来程序化地创建两个新的函数，处理坐标转换。为此，我们将使用pyproj库，它旨在内部转换不同的坐标系统。`Proj`类可以将地理坐标（纬度，经度）转换为本地地图投影（*x*，*y*）坐标，反之亦然，这正好符合我们的需求。[列表
    8-6](#listing8-6)展示了我从相关的GIS Stack Exchange帖子中找到并修改的函数。^([6](b01.xhtml#c08-endnote-006))
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-6: Translating a geographic point to a geographic polygon'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-6：将地理坐标点转换为地理多边形
- en: We define the `az_proj` (short for *azimuth projection*) string to contain all
    the variables that will be passed in to the projection code ❶. The most important
    are `+proj`, which tells the library to convert the coordinates using a method
    known as *azimuthal equidistance (AEQD)*; `+R`, which holds the radius (in meters)
    of earth; and `+units`, which tells the code that this number is in meters, but
    more generally tells the library what units to convert to. The only two variables
    we need to be able to change on each call are `lat_0` and `lon_0`, which define
    the (0, 0) point in the coordinate field. Currently our data is in *world geodesic
    system (WGS)* coordinates. WGS 84 is the standard US Department of Defense definition
    of a global reference system for geospatial information and is the reference system
    for GPS (the Global Positioning System). It is compatible with the International
    Terrestrial Reference System (ITRS) if that’s more your cup of tea.^([7](b01.xhtml#c08-endnote-007))
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`az_proj`（即*方位投影*）字符串，其中包含所有将传递给投影代码的变量 ❶。最重要的变量有`+proj`，它告诉库使用一种被称为*方位等距投影（AEQD）*的方法来转换坐标；`+R`，它保存地球的半径（单位为米）；以及`+units`，它告诉代码该数值单位为米，但更一般地，它告诉库应该转换到哪些单位。我们每次调用时唯一需要更改的两个变量是`lat_0`和`lon_0`，它们定义了坐标系中的(0,
    0)点。当前，我们的数据使用*世界大地测量系统（WGS）*坐标。WGS 84是美国国防部定义的全球地理信息参考系统标准，也是全球定位系统（GPS）的参考系统。如果你更习惯使用国际地面参考系统（ITRS），它也是兼容的。^([7](b01.xhtml#c08-endnote-007))
- en: In the `wgs84_to_aeqd` and `aeqd_to_wgs84` functions, we create a partial copy
    of the `pyproj.transform` function ❷. The `functools.partial` function freezes
    the first two parameters of the `pyproj.transform` function. Notice in the `aeqd_to_wgs84`
    function the two calls to the `Proj` class are reversed. That’s because the first
    two parameters to the `pyproj.transform` function define the current and desired
    representation, respectively. Reversing these two inputs reverses the translation
    direction, in this case from native coordinates back into geographic coordinates
    ❸. Since we’re creating simplified versions of the `transform` function, we freeze
    these two parameters in the appropriate order for our translation direction. The
    remaining parameters to the `pyproj.transform` function define the *x* and *y*
    values to translate. We’ll leave these unfrozen and pass them in when we call
    the functions in a moment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wgs84_to_aeqd`和`aeqd_to_wgs84`函数中，我们创建了`pyproj.transform`函数的一个部分拷贝❷。`functools.partial`函数将`pyproj.transform`函数的前两个参数冻结。在`aeqd_to_wgs84`函数中注意到，两个对`Proj`类的调用是反向的。这是因为`pyproj.transform`函数的前两个参数分别定义了当前和目标的坐标表示方式。反转这两个输入会反转转换方向，在这种情况下是从原生坐标转换回地理坐标❸。由于我们正在创建`transform`函数的简化版本，我们冻结这两个参数，以适应我们所需的转换方向。`pyproj.transform`函数的其余参数定义了需要转换的*
    x *和* y *值。我们将这些参数保持未冻结，并在稍后调用函数时传递。
- en: Now that we have the two conversion functions defined, we create a `Point` object
    from the latitude and longitude ❹. Shapely expects these in the reverse order
    than you might expect. If you try to pass the coordinates directly via the `geometry`
    column, you’ll run into the error `"latitude or longitude exceeded limits."` The
    `shapely.transform` function (not to be confused with the `pyproj.transform` function)
    applies a user-defined function to all the coordinates of a Shapely object and
    returns a new geometric object of the same type from the transformed coordinates.
    We’ll use the `shapely.transform` function to transform the point into native
    coordinates using the previously defined `wgs84_to_aeqd` function ❺. Shapely points
    have a `buffer` function that adds a defined amount of space around the point.
    Essentially, given a point and a desired amount of buffer space around that point,
    Shapely generates a new set of points representing the location of the boundary
    of the buffer space. We can use this to generate a circle representing the approximate
    coverage area of each tower. Since we defined the units in the AEQD transformation
    function as meters, we can pass the radius for the buffer area in meters as well.
    This is handy because the `accuracy` field returned by the OpenCellID API is also
    in meters. The value in the accuracy field describes how much error is in the
    latitude and longitude. Calling `buffer` with the radius set to the accuracy of
    the radio creates a polygon that represents the estimated location of the tower.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了两个转换函数，我们从经纬度创建一个`Point`对象❹。Shapely期望的顺序与你可能预期的相反。如果你尝试通过`geometry`列直接传递坐标，你将遇到错误`"latitude
    or longitude exceeded limits."`。`shapely.transform`函数（与`pyproj.transform`函数不同）将一个用户定义的函数应用于Shapely对象的所有坐标，并从变换后的坐标返回相同类型的新的几何对象。我们将使用`shapely.transform`函数，通过之前定义的`wgs84_to_aeqd`函数将点转换为原生坐标❺。Shapely点有一个`buffer`函数，用于在点周围添加一定量的空间。本质上，给定一个点和所需的缓冲区空间量，Shapely生成一组新的点，表示缓冲区边界的位置。我们可以使用它生成一个圆形，表示每个塔的近似覆盖区域。由于我们在AEQD转换函数中将单位定义为米，我们也可以传递缓冲区区域的半径（以米为单位）。这很方便，因为OpenCellID
    API返回的`accuracy`字段的单位也是米。准确度字段中的值描述了纬度和经度的误差。通过将半径设置为无线电的精度来调用`buffer`，可以创建一个多边形，表示塔的位置的估计。
- en: The signal coverage area is a little more difficult to calculate accurately.
    If we wanted to be very specific, we could calculate wave propagation, but then
    we’d need to know the type of tower, its power ratings, its height, and any major
    obstructions. It turns out that the accuracy field also makes a handy signal strength
    estimate. The accuracy of the tower placement tends to be about 30 to 50 percent
    of the optimal signal coverage for the given type of tower. Assuming your target
    is in a metropolitan area, 30 to 50 percent is also a fair guess for signal dampening,
    especially without knowing any more about the towers or landscape itself. So I
    like to use the accuracy field as a quick-and-dirty guess at coverage area as
    well ❻. By passing the accuracy as the radius to the `buffer` function, we’re
    defining a circle whose bounds will represent the probable coverage area of the
    tower. In reality the tower may not be in the center of the circle, but it will
    fall somewhere within it. This means the actual coverage area may be a bit bigger
    or smaller depending on the landscape and architectural construction of the area
    around the tower, but this will make a good starting point for our proof of concept.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 信号覆盖区域的准确计算有点复杂。如果我们想要非常精确地计算，我们可以计算波传播，但那时我们需要知道塔的类型、功率等级、塔的高度以及任何主要障碍物。事实上，精度字段也为信号强度提供了一个有用的估算。塔的位置精度通常是给定类型塔的最佳信号覆盖范围的30%到50%。假设目标位于大都市区域，30%到50%也是信号衰减的合理猜测，特别是在我们对塔或周围的景观没有更多了解的情况下。因此，我也喜欢将精度字段作为覆盖区域的快速估算❻。通过将精度作为半径传递给`buffer`函数，我们定义了一个圆，其边界将表示塔的可能覆盖区域。实际上，塔可能并不在圆心位置，但它会位于圆内的某个地方。这意味着实际的覆盖区域可能会根据塔周围区域的地形和建筑结构稍微大一些或小一些，但这将为我们的概念验证提供一个不错的起点。
- en: At this point, we have a circular polygon defined around each tower’s *x* and
    *y* location that represents an approximation of its covered service area, but
    the points representing the hull of the polygon are currently in native map coordinates.
    To transform them into geodesic coordinates, we call `shapely.transform` again,
    this time with the `aeqd_to_wgs84` function ❼, and return the results.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经为每个塔的*x*和*y*位置定义了一个圆形多边形，表示其覆盖的服务区域的近似值，但表示多边形外壳的点目前处于原生地图坐标系中。为了将其转换为大地坐标，我们再次调用`shapely.transform`，这次使用`aeqd_to_wgs84`函数❼，并返回结果。
- en: Lastly, we call the `apply` function to get the result of the `get_shapely_circle`
    function for each row in `geo_df` (setting `axis=1` operates on rows instead of
    columns) and use the results to overwrite the original `geometry` column in the
    data with the new polygons ❽.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`apply`函数来获取`geo_df`中每一行的`get_shapely_circle`函数结果（设置`axis=1`表示按行操作而非按列操作），并使用结果覆盖数据中的原始`geometry`列，生成新的多边形❽。
- en: Calculating the Search Area
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算搜索区域
- en: 'In the previous section we tackled the first big hurdle to our project. We
    can now convert the latitude and longitude of a tower, along with the accuracy
    estimation, into a geometric object representing the potential service area for
    that tower. We’ve also converted the points around the hull of the geometry back
    into latitude and longitude coordinates we can use with maps. Our next step is
    to find the geographic area where all of these polygons overlap, or more formally,
    *A*∩(*B*, *C*, . . . , *N*) where *A*, *B*, *C*, and so forth represent the polygons
    created during the previous steps. To accomplish this, we’ll borrow some code
    from Stack Overflow^([8](b01.xhtml#c08-endnote-008)) that performs repeated Boolean
    operations to find the intersection between *A* and each other polygon. Let’s
    start by defining a function to handle the simplest case: returning the difference
    and intersection of two polygons, *A* and *B*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解决了项目中的第一个大难题。现在，我们可以将塔的纬度和经度以及精度估算值转换为表示该塔潜在服务区域的几何对象。我们还将几何体外壳周围的点转换回可用于地图的纬度和经度坐标。我们的下一步是找到这些多边形重叠的地理区域，或者更正式地说，*A*∩(*B*,
    *C*, . . . , *N*)，其中*A*、*B*、*C*等代表之前步骤中创建的多边形。为此，我们将借用来自Stack Overflow的部分代码^([8](b01.xhtml#c08-endnote-008))，该代码执行重复的布尔运算以找到*A*与其他每个多边形的交集。让我们从定义一个函数开始，处理最简单的情况：返回两个多边形*A*和*B*的差异和交集。
- en: '[Listing 8-7](#listing8-7) shows the partitioning code.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-7](#listing8-7)展示了划分代码。'
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-7: Partitioning polygons into difference and intersection elements'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-7：将多边形划分为差异和交集元素
- en: 'First, we check for the simplest case: when polygon *A* doesn’t intersect polygon
    *B* anywhere. In this case, we simply return both polygons along with an empty
    `GeometryCollection` object. If there’s some overlap between the two polygons,
    we want to return three things. First, we want to return the two differences—that
    is, the part of *A* that doesn’t overlap *B* and vice versa. The two differences
    are stored in `only_a` and `only_b`. Then, we also want to return the intersection
    of the two, which can be found using Shapely’s `intersection` function.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查最简单的情况：当多边形*A*与多边形*B*没有任何交集时。在这种情况下，我们直接返回两个多边形，并附加一个空的`GeometryCollection`对象。如果两个多边形之间有重叠，我们需要返回三件事。首先，我们返回两个差集，即多边形*A*不与*B*重叠的部分，反之亦然。这两个差集分别存储在`only_a`和`only_b`中。然后，我们还需要返回这两个多边形的交集，可以使用Shapely的`intersection`函数找到交集。
- en: The code in [Listing 8-7](#listing8-7) will be used within the main function
    that solves the intersection code, which uses a slightly modified version of a
    *sweep line algorithm*, a very famous way to efficiently process an arbitrarily
    large set of shapes with some Boolean operations (such as unions and intersections).
    Rather than stopping at each point, we sweep over whole polygons and compare them
    to all previously known polygons. Each pair of polygons and its subgeometries
    will be iteratively collected and compared to see which parts of *A* overlap with
    the other polygons. These overlaps will be treated as subsets of geometry and
    checked in turn.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-7](#listing8-7)中的代码将用于解决交集问题的主要函数中，该函数使用了一种稍微修改过的*扫描线算法*，这是一种非常著名的方法，用来高效地处理任意大小的形状集合，并进行一些布尔操作（例如并集和交集）。我们不是在每个点上停下，而是扫过整个多边形，并将其与所有先前已知的多边形进行比较。每对多边形及其子几何体将被反复收集并进行比较，以查看*A*的哪些部分与其他多边形重叠。这些重叠将被视为几何体的子集，并依次进行检查。'
- en: '[Listing 8-8](#listing8-8) shows the main function.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 8-8](#listing8-8)显示了主要函数。'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-8: Sweep line algorithm for cascading intersection of polygons^([9](b01.xhtml#c08-endnote-009))'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-8: 用于多边形级联交集的扫描线算法^([9](b01.xhtml#c08-endnote-009))'
- en: First we create the `result` field with the first polygon in the list to check
    for intersection ❶. We loop over the rest of the polygon list and use the `partition`
    function from [Listing 8-7](#listing8-7) to generate all of the intersections
    and differences for the polygons (*B*, . . . , *N*) ❷. For each of these, we check
    the geometry to ensure no empty geometry objects get passed through ❸. Once we
    create all these subgeometries, we can take the cascading union to create the
    remainder section of polygon *A*. This represents the shape of *A* that doesn’t
    intersect any other polygon ❹. If it is non-empty, we add it to the current list
    of results ❺.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`result`字段，使用列表中的第一个多边形进行交集检查 ❶。然后，我们遍历其余的多边形列表，使用[Listing 8-7](#listing8-7)中的`partition`函数生成所有多边形(*B*,
    . . . , *N*)的交集和差集 ❷。对于这些交集，我们检查几何体，确保没有空的几何体对象被传递 ❸。一旦我们创建了所有这些子几何体，我们可以进行级联并集操作，生成多边形*A*的剩余部分。这代表了与其他多边形没有交集的*A*形状
    ❹。如果它非空，我们将其添加到当前的结果列表中 ❺。
- en: Next, we once again loop over the resulting intersections ❻ to see which of
    them also intersects with the primary polygon *A* ❼. We repeat this process until
    no more intersections are left to check. Sometimes the intersection operation
    creates tiny polygons, which are really just artifacts that we can toss. To do
    so, we have a second function that compares each intersection polygon’s area to
    the area of the first polygon; if it’s less than 1*e* – 16 × `A.area`, the polygon
    is removed. The remaining polygons are assigned back to the `only_poly1` variable
    ❽ (we’ll cover the `eliminate_small_areas` function momentarily). Lastly, we check
    if the remaining polygon list is empty. If not, we append it to the list of results
    being held in the `result` variable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次遍历生成的交集 ❻，查看其中哪些与主多边形*A*也有交集 ❼。我们重复此过程，直到不再有交集需要检查。有时，交集操作会产生一些微小的多边形，这些其实只是一些伪影，我们可以将其丢弃。为此，我们有一个第二个函数，它将每个交集多边形的面积与第一个多边形的面积进行比较；如果小于1*e*
    – 16 × `A.area`，该多边形将被移除。剩余的多边形将被重新赋值给`only_poly1`变量 ❽（我们稍后将讨论`eliminate_small_areas`函数）。最后，我们检查剩余的多边形列表是否为空。如果不为空，我们将其添加到存储在`result`变量中的结果列表中。
- en: We can now call the `cascaded_intersections` function with the list of tower
    service areas represented by the shape data stored in the `geometry` column of
    the `geo_df` data. We create a list containing the shape data we generated in
    [Listing 8-6](#listing8-6) representing the tower service areas and assign it
    to the `polys` variable ❾. We pass the zeroth polygon in the `polys` list as the
    first argument to the `cascaded_intersections` function. This will be the primary
    polygon (polygon *A*) the rest of the algorithm is considering intersections for.
    We pass the remainder of the list as the second argument (polygons *B*–*N*) to
    tell the `cascaded_intersections` function these are the polygons that may intersect
    polygon *A*. The `cascaded_intersections` function returns a list of different
    geometries of interest, which we assign to the `results` variable ❿.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用 `cascaded_intersections` 函数，传入由 `geo_df` 数据中 `geometry` 列存储的塔服务区形状数据列表。我们创建一个包含在[示例
    8-6](#listing8-6)中生成的塔服务区形状数据的列表，并将其赋值给 `polys` 变量❾。我们将 `polys` 列表中的第零个多边形作为第一个参数传递给
    `cascaded_intersections` 函数。这将是算法考虑交集的主要多边形（多边形 *A*）。我们将列表的其余部分作为第二个参数（多边形 *B*–*N*）传递给
    `cascaded_intersections` 函数，告诉它这些多边形可能与多边形 *A* 相交。`cascaded_intersections` 函数返回一个感兴趣的几何形状列表，我们将其赋值给
    `results` 变量❿。
- en: 'The zeroth element of `results` will be the remainder of polygon *A* that doesn’t
    intersect with any other polygon. The first element will be the intersection of
    polygon *A* with all the other polygons. The remaining elements will depend on
    the layout of the polygons but will follow the pattern (*A*⋂*B* ∉ *CD*, *A*⋂*BC*
    ∉ *D*. . .). We need only the first element, the intersection of all the polygons,
    but the other results are there for you to explore on your own as well. One way
    we might use this output is to print out the minimum and maximum values for the
    latitude and longitude of the intersection result. This gives us a boundary in
    the shape of a box that completely encloses the geometry of the intersection polygon.
    We can find this search area pretty simply:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`results` 的第零个元素将是多边形 *A* 的剩余部分，即没有与任何其他多边形相交的部分。第一个元素将是多边形 *A* 与所有其他多边形的交集。其余元素将取决于多边形的布局，但将遵循模式（*A*⋂*B*
    ∉ *CD*, *A*⋂*BC* ∉ *D*...）。我们只需要第一个元素，即所有多边形的交集，但其他结果也可以供你自行探索。我们可能使用这个输出的一种方式是打印出交集结果的纬度和经度的最小值和最大值。这为我们提供了一个完全封闭交集多边形几何形状的边界框。我们可以相当简单地找到这个搜索区域：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First we create two variables, `x` and `y`, to hold their respective list of
    coordinate values. Remember that we’ve already converted the coordinates to latitude
    and longitude, so all we need to do now is print out the minimum and maximum values
    from each list to find the latitude and longitude bounds of our search area. The
    output of the code for our test towers is shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两个变量 `x` 和 `y`，用来保存各自的坐标值列表。记住，我们已经将坐标转换为纬度和经度，因此现在需要做的就是打印出每个列表的最小值和最大值，以找到我们搜索区域的纬度和经度范围。测试塔的代码输出如下：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The coordinates in the output represent the lower-left and upper-right corners
    and can be used to form a box around the polygon resulting from the cascaded intersection
    function. We could give this information to a ground team who could go to the
    area and perform a search.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的坐标表示左下角和右上角的坐标，可以用来围绕由级联交集函数产生的多边形形成一个边界框。我们可以将这些信息提供给地面团队，供他们前往该区域进行搜索。
- en: The code in [Listing 8-8](#listing8-8) relies on the `eliminate_small_areas`
    function, which, by comparison, is very simple to grok. [Listing 8-9](#listing8-9)
    shows the code to eliminate any potential artifact polygons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-8](#listing8-8) 中的代码依赖于 `eliminate_small_areas` 函数，与之相比，这个函数非常简单易懂。[示例
    8-9](#listing8-9) 展示了去除任何潜在伪影多边形的代码。'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-9: Removing small area polygons'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-9：去除小面积多边形
- en: First we use `isinstance` to check whether the polygon passed in is an instance
    of a single polygon ❶. If it is, we check if the polygon’s area is smaller than
    the `small_area` parameter. If so, we return an empty `GeometryCollection`; otherwise,
    we return the polygon instance. If the object passed in the `poly` parameter isn’t
    an instance of a single polygon, we assert it must then be an instance of a `MultiPolygon`
    (essentially a list of polygons). If the assertion fails (say you pass in a dictionary
    by mistake), the code will raise an exception ❷. In the case where the object
    is a `MultiPolygon`, we use list comprehension to check each individual polygon’s
    area against the `small_area` parameter ❸. If the length of the resulting list
    is 0 ❹, no polygons remain after the artifacts are removed, so we return `EMPTY`.
    If exactly one polygon object remains in the list ❺, we return it as a single
    polygon instance; there’s no need to carry the additional weight of a `MultiPolygon`
    object forward. Otherwise, if more than one polygon remains in the list, we return
    them all as a `MultiPolygon` object ❻.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`isinstance`检查传入的多边形是否为单一多边形的实例❶。如果是，我们检查该多边形的面积是否小于`small_area`参数。如果是，我们返回一个空的`GeometryCollection`；否则，返回该多边形实例。如果传入的`poly`参数不是单一多边形的实例，我们断言它必须是`MultiPolygon`的实例（本质上是一个多边形列表）。如果断言失败（比如你不小心传入了一个字典），代码将引发异常❷。在`MultiPolygon`的情况下，我们使用列表推导式检查每个单独多边形的面积与`small_area`参数的关系❸。如果结果列表的长度为0❹，则在去除伪影后没有多边形，因此我们返回`EMPTY`。如果列表中仅剩一个多边形对象❺，我们将其作为单个多边形实例返回；不需要再传递一个额外的`MultiPolygon`对象。如果列表中剩下多个多边形，我们将它们全部返回为一个`MultiPolygon`对象❻。
- en: After we call the `cascading_intersections` function, we can plot the first
    item in the result to see the search area identified. [Figure 8-4](#figure8-4)
    shows the polygon representing the intersection of all the towers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`cascading_intersections`函数后，我们可以绘制结果中的第一个项目，查看标识出的搜索区域。[图 8-4](#figure8-4)展示了代表所有塔楼交集的多边形。
- en: '![](image_fi/502567c08/f08004.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c08/f08004.png)'
- en: 'Figure 8-4: Intersection of all four towers as a polygon'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4：所有四个塔楼的交集作为一个多边形
- en: If you compare the shape of the polygon in [Figure 8-4](#figure8-4) to the overlapping
    areas from [Figure 8-3](#figure8-3), you’ll see that they look very similar, meaning
    we’ve achieved our goal of programmatically identifying the area of interest.
    We could pass these coordinates in raw form to any GPS device to create a more
    accurate bounded search area.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将[图 8-4](#figure8-4)中的多边形形状与[图 8-3](#figure8-3)中的重叠区域进行比较，你会发现它们非常相似，这意味着我们已经实现了通过程序识别感兴趣区域的目标。我们可以将这些坐标以原始形式传递给任何GPS设备，以创建一个更精确的边界搜索区域。
- en: Mapping the Search Area for Investigators
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为调查员绘制搜索区域
- en: We could also overlay the result on a map to see the search area we should pass
    on to investigators, as shown in [Figure 8-5](#figure8-5).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将结果叠加到地图上，以查看我们应该传递给调查员的搜索区域，如[图 8-5](#figure8-5)所示。
- en: '![](image_fi/502567c08/f08005.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c08/f08005.png)'
- en: 'Figure 8-5: Resulting search area'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：结果搜索区域
- en: The polygon lays directly over the area known as Seattle Center, home of the
    Space Needle. Indeed, when I captured the sample data I was standing near the
    foot of the Space Needle, close to the center of the search area. Now let’s compare
    our result to the one presented by the OpenCellID API, shown in [Figure 8-6](#figure8-6).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该多边形直接覆盖了被称为西雅图中心的区域，这是太空针的所在地。事实上，当我采集样本数据时，我正站在太空针脚下，接近搜索区域的中心。现在，让我们将我们的结果与OpenCellID
    API提供的结果进行比较，如[图 8-6](#figure8-6)所示。
- en: '![](image_fi/502567c08/f08006.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c08/f08006.png)'
- en: 'Figure 8-6: Comparing location estimates'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：位置估算比较
- en: The light gray outer circle shows the search area provided by the OpenCellID
    API based on three of the four sample towers (it was actually more accurate after
    one of the towers was removed). The dark gray area near the middle is our search
    area produced using basic computational geometry. As you can see, we have reduced
    the overall search area considerably. Also worth mentioning is that the OpenCellID
    result is centered on the very edge of our search area, which means my actual
    location was farther from the center of the search area.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 浅灰色的外圈显示了由OpenCellID API提供的基于四个示例塔楼中三个塔楼的搜索区域（实际上，在移除一个塔楼后，它变得更为准确）。靠近中心的深灰色区域是我们使用基本计算几何方法生成的搜索区域。如你所见，我们已经显著减少了整体搜索区域。此外，值得一提的是，OpenCellID的结果中心位于我们搜索区域的边缘，这意味着我的实际位置远离搜索区域的中心。
- en: Reducing the Search Area
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩小搜索区域
- en: Using cell tower data will never be as accurate or reliable as GPS, but there
    are still some techniques we can apply to improve the result. By improving the
    signal coverage, you’ll get more accurate search areas. They may actually be smaller
    in area, but your confidence will be higher, leading to better resource usage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基站数据永远不会像GPS那样准确或可靠，但我们仍然可以应用一些技术来改善结果。通过改善信号覆盖，你将获得更准确的搜索区域。它们可能实际上更小，但你的信心会更高，从而实现更好的资源利用。
- en: To further reduce the search area, you can take advantage of Wi-Fi networks
    in the area, if any are available. I wouldn’t rely on them to find the initial
    search area, but they’re a good option for shrinking a search area once you’ve
    defined one. I’m a fan of the WiGLE database for Wi-Fi searches, but the OpenCellID
    API also supports Wi-Fi antennas, as I mentioned previously. By combining the
    two APIs (and any additional APIs you may find), you’ll improve your chances of
    finding networks with location information available. You can use the limited
    range of these networks to drastically reduce the search area, sometimes to a
    single building. The FCC has investigated using this type of Wi-Fi geolocation
    as one option to help emergency service dispatchers find callers who don’t know
    their location.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步缩小搜索区域，你可以利用该区域内的Wi-Fi网络（如果有的话）。我不会依赖Wi-Fi来找到初始搜索区域，但它们是缩小已定义搜索区域的一个好选择。我是WiGLE数据库的粉丝，用于Wi-Fi搜索，但正如我之前提到的，OpenCellID
    API也支持Wi-Fi天线。通过结合这两个API（以及你可能找到的任何其他API），你会提高找到有位置信息可用的网络的机会。你可以利用这些网络的有限范围来大幅缩小搜索区域，有时甚至可以缩小到单个建筑物。美国联邦通信委员会（FCC）曾研究过使用这种Wi-Fi地理定位作为一种帮助紧急服务调度员找到不知自己位置的来电者的选项。
- en: You may also choose to use cell towers in your data that have the weakest signal,
    if you can capture the necessary information from the device you want to locate.
    Ideally, you’ll find several towers with weak signals. These usually turn out
    to be the towers that are farthest apart and thus create the smallest overlapping
    region. This is purely heuristic, though, since a weak signal could also indicate
    a closer tower with more obstructions. If you can capture multiple antennas (say
    12 different towers), you can try an iterative approach by testing different groups
    of three to four antennas at a time. You can compare the resulting search areas
    and determine a sort of search area heat map, where the most likely places are
    the ones that show up in the highest number of polygon intersections (or the overlap
    of the overlaps, if you prefer).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够从想要定位的设备捕获到必要的信息，你也可以选择使用信号最弱的基站。理想情况下，你会找到几个信号较弱的基站。通常，这些基站是距离最远的，因此会创建最小的重叠区域。不过，这纯粹是启发式方法，因为弱信号也可能表示较近的基站，且存在更多的障碍物。如果你能捕获多个天线（例如12个不同的基站），可以尝试通过每次测试三到四个天线的组合来采取迭代方法。你可以比较结果搜索区域，并确定一种搜索区域热图，其中最可能的地方是那些出现在最多多边形交集中的位置（或者如果你更喜欢的话，就是重叠区域的重叠部分）。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The power of geolocation in a security context can’t be overstated. In a world
    of cell phones, evolving smart cities, and the proliferation of the Internet of
    Things (IoT), people are constantly saturated by network transmissions. As you’ve
    seen, an intrepid researcher, corporate overlord, or motivated hacker can take
    this information and turn it into a physical location. Combine that with the common
    business practice of helpfully naming Wi-Fi access points after the company, and
    it becomes a scarily accurate tracking tool. There are a lot of ethical and legal
    concerns you should consider before you deploy this type of tracking system beyond
    a research environment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全背景下，地理定位的力量是无法被过分强调的。在一个充满手机、不断发展的智慧城市和物联网（IoT）扩展的世界里，人们始终被网络传输所包围。如你所见，无畏的研究人员、企业霸主或积极的黑客可以利用这些信息将其转化为物理位置。结合Wi-Fi接入点通常以公司名称命名这一常见商业做法，这就成了一个令人恐惧的精确跟踪工具。在你将这种类型的跟踪系统应用到研究环境以外之前，有很多伦理和法律问题你需要考虑。
- en: There are several data sets that encourage users to contribute up-to-date information
    on the towers in their area through a process called *war driving*. Despite its
    antisocial name (rooted in hacker history), war driving is simply traveling around
    an area recording what networks are visible. Some folks have even attached recording
    devices to their outdoor animals so that, as the animal wanders, it also contributes
    to the owner’s network map.^([10](b01.xhtml#c08-endnote-010))
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个数据集鼓励用户通过一种叫做*战争驾驶*的方式，贡献他们所在地区塔楼的最新信息。尽管这个名字有些反社会（源自黑客历史），但战争驾驶其实只是环绕某个地区，记录可见的网络。一些人甚至将录音设备附加在户外动物身上，这样当动物四处游荡时，它也在为主人贡献网络地图。^([10](b01.xhtml#c08-endnote-010))
- en: It’s not all gloom and doom, though. In the next project we’ll look at applying
    the same principles of converting physical locations into geometric data to help
    a city plan for new emergency services. We’ll revisit the topic of tessellation
    and discuss one of my favorite geometric algorithms, the Voronoi diagram.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非一切都充满了阴霾和末日感。在下一个项目中，我们将探讨如何应用相同的原则，将物理位置转化为几何数据，帮助城市规划新的紧急服务。我们将重新审视拼贴话题，并讨论我最喜欢的几何算法之一，Voronoi图。
