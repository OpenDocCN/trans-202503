["```\n{-# OPTIONS -Wall #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nmodule Mechanics3D where\n\nimport SimpleVec\n    ( R, Vec, PosVec, (^+^), (^-^), (*^), (^*), (^/), (<.>), (><)\n    , vec, sumV, magnitude, zeroV, xComp, yComp, zComp, iHat, jHat, kHat)\nimport Mechanics1D\n    ( RealVectorSpace(..), Diff(..), NumericalMethod\n    , Time, TimeStep, rungeKutta4, solver )\nimport SpatialMath\n    ( V3(..), Euler(..) )\nimport Graphics.Gnuplot.Simple\n    ( Attribute(..), Aspect(..), plotFunc, plotPaths )\nimport qualified Graphics.Gloss as G\nimport qualified Vis as V\n```", "```\ndata ParticleState = ParticleState { mass     :: R\n                                   , charge   :: R\n                                   , time     :: R\n                                   , posVec   :: Vec\n                                   , velocity :: Vec }\n                     deriving Show\n```", "```\ndefaultParticleState :: ParticleState\ndefaultParticleState = ParticleState { mass     = 1\n                                     , charge   = 0\n                                     , time     = 0\n                                     , posVec   = zeroV\n                                    , velocity  = zeroV }\n```", "```\nrockState :: ParticleState\nrockState\n    = defaultParticleState { mass    = 2                         -- kg\n                           , velocity = 3 *^ iHat ^+^ 4 *^ kHat  -- m/s\n                           }\n```", "```\ntype OneBodyForce = ParticleState -> Vec\n```", "```\ndata DParticleState = DParticleState { dmdt :: R\n                                     , dqdt :: R\n                                     , dtdt :: R\n                                     , drdt :: Vec\n                                     , dvdt :: Vec }\n                      deriving Show\n```", "```\nnewtonSecondPS :: [OneBodyForce]\n               -> ParticleState -> DParticleState  -- a differential equation\nnewtonSecondPS fs st\n    = let fNet = sumV [f st | f <- fs]\n          m = mass st\n          v = velocity st\n          acc = fNet ^/ m\n      in DParticleState { dmdt = 0    -- dm/dt\n                        , dqdt = 0    -- dq/dt\n                        , dtdt = 1    -- dt/dt\n                        , drdt = v    -- dr/dt\n                        , dvdt = acc  -- dv/dt\n                        }\n```", "```\n-- z direction is toward the sky\n-- assumes SI units\nearthSurfaceGravity :: OneBodyForce\nearthSurfaceGravity st\n    = let g = 9.80665  -- m/s^2\n      in (-mass st * g) *^ kHat\n```", "```\n-- origin is at center of sun\n-- assumes SI units\nsunGravity :: OneBodyForce\nsunGravity (ParticleState m _q _t r _v)\n    = let bigG = 6.67408e-11  -- N m^2/kg^2\n          sunMass = 1.98848e30  -- kg\n      in (-bigG * sunMass * m) *^ r ^/ magnitude r ** 3\n```", "```\nairResistance :: R  -- drag coefficient\n              -> R  -- air density\n              -> R  -- cross-sectional area of object\n              -> OneBodyForce\nairResistance drag rho area (ParticleState _m _q _t _r v)\n    = (-0.5 * drag * rho * area * magnitude v) *^ v\n```", "```\nairResistance 0.8 1.225 0.003\n```", "```\nwindForce :: Vec  -- wind velocity\n          -> R    -- drag coefficient\n          -> R    -- air density\n          -> R    -- cross-sectional area of object\n          -> OneBodyForce\nwindForce vWind drag rho area (ParticleState _m _q _t _r v)\n    = let vRel = v ^-^ vWind\n      in (-0.5 * drag * rho * area * magnitude vRel) *^ vRel\n```", "```\nuniformLorentzForce :: Vec  -- E\n                    -> Vec  -- B\n                    -> OneBodyForce\nuniformLorentzForce vE vB (ParticleState _m q _t _r v)\n    = q *^ (vE ^+^ v >< vB)\n```", "```\neulerCromerPS :: TimeStep        -- dt for stepping\n              -> NumericalMethod ParticleState DParticleState\neulerCromerPS dt deriv st\n    = let t   = time     st\n          r   = posVec   st\n          v   = velocity st\n          dst = deriv st\n          acc = dvdt dst\n          v'  = v ^+^ acc ^* dt\n      in st { time     = t  +         dt\n            , posVec   = r ^+^ v'  ^* dt\n            , velocity = v ^+^ acc ^* dt\n            }\n```", "```\ninstance RealVectorSpace DParticleState where\n    dst1 +++ dst2\n        = DParticleState { dmdt = dmdt dst1  +  dmdt dst2\n                         , dqdt = dqdt dst1  +  dqdt dst2\n                         , dtdt = dtdt dst1  +  dtdt dst2\n                         , drdt = drdt dst1 ^+^ drdt dst2\n                         , dvdt = dvdt dst1 ^+^ dvdt dst2\n                         }\n    scale w dst\n        = DParticleState { dmdt = w *  dmdt dst\n                         , dqdt = w *  dqdt dst\n                         , dtdt = w *  dtdt dst\n                         , drdt = w *^ drdt dst\n                         , dvdt = w *^ dvdt dst\n                         }\n```", "```\ninstance Diff ParticleState DParticleState where\n    shift dt dps (ParticleState m q t r v)\n        = ParticleState (m  +  dmdt dps  * dt)\n                        (q  +  dqdt dps  * dt)\n                        (t  +  dtdt dps  * dt)\n                        (r ^+^ drdt dps ^* dt)\n                        (v ^+^ dvdt dps ^* dt)\n```", "```\nstatesPS :: NumericalMethod ParticleState DParticleState\n         -> [OneBodyForce]  -- list of force funcs\n         -> ParticleState -> [ParticleState]  --evolver\nstatesPS method = iterate . method . newtonSecondPS\n```", "```\nupdatePS :: NumericalMethod ParticleState DParticleState\n         -> [OneBodyForce]\n         -> ParticleState -> ParticleState\nupdatePS method = method . newtonSecondPS\n```", "```\npositionPS :: NumericalMethod ParticleState DParticleState\n           -> [OneBodyForce]  -- list of force funcs\n           -> ParticleState   -- initial state\n           -> Time -> PosVec  -- position function\npositionPS method fs st t\n   = let states = statesPS method fs st\n         dt = time (states !! 1) - time (states !! 0)\n         numSteps = abs $ round (t / dt)\n         st1 = solver method (newtonSecondPS fs) st !! numSteps\n     in posVec st1\n```", "```\nsimulateGloss :: R    -- time-scale factor\n              -> Int  -- animation rate\n              -> s    -- initial state\n              -> (s -> G.Picture)\n              -> (TimeStep -> s -> s)\n              -> IO ()\nsimulateGloss tsFactor rate initialState picFunc updateFunc\n    = G.simulate (G.InWindow \"\" (1000, 750) (10, 10)) G.black rate\n      initialState picFunc\n          (\\_ -> updateFunc . (* tsFactor) . realToFrac)\n\nsimulateVis :: HasTime s => R  -- time-scale factor\n            -> Int             -- animation rate\n            -> s               -- initial state\n            -> (s -> V.VisObject R)\n            -> (TimeStep -> s -> s)\n            -> IO ()\nsimulateVis tsFactor rate initialState picFunc updateFunc\n    = let visUpdateFunc ta st\n              = let dtp = tsFactor * realToFrac ta - timeOf st\n                in updateFunc dtp st\n      in V.simulate V.defaultOpts (1/fromIntegral rate)\n      initialState (orient . picFunc) visUpdateFunc\n```", "```\nv3FromVec :: Vec -> V3 R\nv3FromVec v = V3 x y z\n    where\n      x = xComp v\n      y = yComp v\n      z = zComp v\n```", "```\norient :: V.VisObject R -> V.VisObject R\norient pict = V.RotEulerDeg (Euler 270 180 0) $ pict\n```", "```\nclass HasTime s where\n    timeOf :: s -> Time\n```", "```\ninstance HasTime ParticleState where\n    timeOf = time\n```", "```\nconstantForce :: Vec -> OneBodyForce\nconstantForce f = undefined f\n```", "```\ntenNewtoniHatForce :: OneBodyForce\ntenNewtoniHatForce = constantForce (10 *^ iHat)\n```", "```\nmoonSurfaceGravity :: OneBodyForce\nmoonSurfaceGravity = undefined\n```", "```\nearthGravity :: OneBodyForce\nearthGravity = undefined\n```", "```\ntvyPair :: ParticleState -> (R,R)\ntvyPair st = undefined st\n```", "```\ntvyPairs :: [ParticleState] -> [(R,R)]\ntvyPairs sts = undefined sts\n```", "```\ntle1yr :: ParticleState -> Bool\ntle1yr st = undefined st\n```", "```\nstateFunc :: [ParticleState]\n          -> Time -> ParticleState\nstateFunc sts t\n    = let t0 = undefined sts\n          t1 = undefined sts\n          dt = undefined t0 t1\n          numSteps = undefined t dt\n      in undefined sts numSteps\n```", "```\nairResAtAltitude :: R  -- drag coefficient\n                 -> R  -- air density at sea level\n                 -> R  -- cross-sectional area of object\n                 -> OneBodyForce\nairResAtAltitude drag rho0 area (ParticleState _m _q _t r v)\n    = undefined drag rho0 area r v\n```", "```\nprojectileRangeComparison :: R -> R -> (R,R,R)\nprojectileRangeComparison v0 thetaDeg\n    = let vx0 = v0 * cos (thetaDeg / 180 * pi)\n          vz0 = v0 * sin (thetaDeg / 180 * pi)\n          drag = 1\n          ballRadius = 0.05    -- meters\n          area = pi * ballRadius**2\n          airDensity  =    1.225  -- kg/m^3 @ sea level\n          leadDensity = 11342     -- kg/m^3\n          m = leadDensity * 4 * pi * ballRadius**3 / 3\n          stateInitial = undefined m vx0 vz0\n          aboveSeaLevel :: ParticleState -> Bool\n          aboveSeaLevel st = zComp (posVec st) >= 0\n          range :: [ParticleState] -> R\n          range = xComp . posVec . last . takeWhile aboveSeaLevel\n          method = rungeKutta4 0.01\n          forcesNoAir\n              = [earthSurfaceGravity]\n          forcesConstAir\n              = [earthSurfaceGravity, airResistance    drag airDensity area]\n          forcesVarAir\n              = [earthSurfaceGravity, airResAtAltitude drag airDensity area]\n          rangeNoAir    = range $ statesPS method forcesNoAir    stateInitial\n          rangeConstAir = range $ statesPS method forcesConstAir stateInitial\n          rangeVarAir   = range $ statesPS method forcesVarAir   stateInitial\n      in undefined rangeNoAir rangeConstAir rangeVarAir\n```"]