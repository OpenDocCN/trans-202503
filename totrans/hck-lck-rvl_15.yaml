- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PARLER,
    THE JANUARY 6 INSURRECTION, AND THE JSON FILE FORMAT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: On the morning of January 6, 2021, two months after Donald Trump lost the 2020
    election to Joe Biden by about 6 million votes, thousands of Trump’s supporters
    prepared to storm the US Capitol in Washington, DC, hoping to subvert democracy.
    “We will never give up. We will never concede,” Trump told the crowd from the
    National Mall, just south of the White House. “We fight like hell, and if you
    don’t fight like hell, you’re not going to have a country anymore.”
  prefs: []
  type: TYPE_NORMAL
- en: Smartphones in hand, the pro-Trump, anti-democracy activists recorded the entire
    event. They posted their photos and videos online, many to the far-right social
    media site Parler. In this chapter, you’ll learn to work with the massive trove
    of video evidence collected from that day’s insurrection in a popular file format
    called JavaScript Object Notation (JSON). You’ll learn how JSON data is structured
    and write Python code to scour a million JSON files full of Parler video metadata
    to find specific videos. You’ll also learn about working with Global Positioning
    System (GPS) coordinates, including how to plot points on a map, since many of
    the videos include GPS coordinates in their metadata. All of these skills could
    serve you well in your future investigations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a brief history of how the Parler dataset became available
    to the public.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Origins of the Parler Dataset</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The protesters at the US Capitol insurrection filmed themselves marching with
    Don’t Tread on Me, Fuck Biden, and Trump flags; tearing down fences; fighting
    with riot cops; smoking weed; smashing windows and then storming the Capitol building
    through them; throwing chairs at police; and threatening the lives of members
    of Congress and Vice President Mike Pence. They uploaded these videos to Parler
    in real time as they filmed them.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the attack on the Capitol, pro-Trump rioters attacked police officers
    with baseball bats, flag poles, and pipes, injuring at least 138 of them. One
    officer, Brian Sicknick, was hospitalized and died the next day. In the weeks
    and months following the attack, four more officers who responded that day died
    by suicide. A Capitol Police officer shot and killed Ashli Babbitt, a rioter who
    attempted to breach the doors to the US Senate chamber where senators were sheltering.
    Three more Trump supporters died during the riot: one from being crushed to death
    in the crowd, one from a stroke, and one from a heart attack.'
  prefs: []
  type: TYPE_NORMAL
- en: Days after the attack, citing Parler’s unwillingness to moderate content that
    encourages and incites violence, Apple and Google banned the Parler app from their
    app stores. Amazon Web Services (AWS), the major cloud hosting service that Parler
    had relied on, kicked the company off its service. It took Parler a month and
    a half to bring its site back up. Before it went down, though, a quick-thinking
    archivist downloaded over a million videos from the site. In this section, I’ll
    describe how she downloaded the videos and how they were used in Trump’s second
    impeachment trial.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How the Parler Videos
    Were Archived</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On the Saturday after the January 6 attack, John Paczkowski and Ryan Mac published
    an email in BuzzFeed News from the Amazon AWS Trust & Safety Team to Parler. Amazon
    informed Parler that it “cannot provide services to a customer that is unable
    to effectively identify and remove content that encourages or incites violence
    against others,” and that “we plan to suspend Parler’s account effective Sunday,
    January 10th.” Less than 48 hours before Parler went dark, a hacker named @donk_enby,
    with the help of other archivists, raced to download a copy of all of the videos
    and images uploaded to the social network.
  prefs: []
  type: TYPE_NORMAL
- en: Parler, it turns out, lacked security measures that prevent automatic scraping
    of the site’s data. *Web scraping* is a method of automated data collection where
    you use code to load web pages, rather than manually loading them in a browser,
    and extract their data. This chapter won’t cover how to scrape the web like @donk_enby
    did, but if you’re curious, you can learn how in Appendix B.
  prefs: []
  type: TYPE_NORMAL
- en: Parler’s website didn’t have any *rate limiting*, a security feature that prevents
    users from accessing the site too frequently, so nothing stopped a single computer
    from making millions of web requests. The URLs of Parler posts appeared to have
    random IDs, but @donk_enby discovered that they also had hidden incremental IDs
    (1, 2, 3, and so on), so a script could easily loop through every ID, make a web
    request to download every post, and then find the URLs for every video and image
    to download. While Parler did strip metadata from videos uploaded by its users,
    they also left original copies of videos that contained this metadata at predictable
    URLs. @donk_enby downloaded versions of the videos that contained a wealth of
    hidden information, including, in many cases, the GPS coordinates of where the
    video was filmed.
  prefs: []
  type: TYPE_NORMAL
- en: When @donk_enby archived this data, she saved it to an AWS S3 bucket, an AWS
    service for hosting files that never runs out of disk space. (It’s ironic that,
    in response to AWS kicking Parler off its service, she saved copies of the videos
    to a different part of AWS.)
  prefs: []
  type: TYPE_NORMAL
- en: Because there’s no widely agreed-upon definition of hacking, whether or not
    Parler was “hacked” is a matter of perspective. Technically, @donk_enby scraped
    public content from a public website, which isn’t illegal and doesn’t require
    bypassing security—had Parler even had any that would have prevented this. The
    same thing is often true of illegal hacking, though; people break into systems
    that are barely protected or accidentally left open to the public.
  prefs: []
  type: TYPE_NORMAL
- en: By Sunday night, @donk_enby had managed to archive at least 32TB of videos.
    “I hope that it can be used to hold people accountable and to prevent more death,”
    she told *Vice*. She worked with DDoSecrets to make a copy of the data available
    to the public—the copy you’ll work with in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Dataset’s Impact
    on Trump’s Second Impeachment</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On January 13, a week after the deadly riot at the Capitol and a week before
    Joe Biden’s inauguration as the new president, the US House of Representatives
    impeached Trump for “incitement of insurrection,” making Trump the first president
    in US history to be impeached twice.
  prefs: []
  type: TYPE_NORMAL
- en: During the impeachment trial in the US Senate, which took place in February
    at the beginning of Biden’s administration, the impeachment managers showed many
    videos of violent Trump supporters that @donk_enby had archived from Parler as
    evidence to support their case. “I had an efficient way to download it all. I
    knew what was there, but it seemed that nobody else could see the value,” she
    told CNN at the time. “I hope it inspires more people with similar skills to mine
    to use those skills for good.”
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, 57 percent of the Senate, including seven members of the Republican
    Party, found Trump guilty, while 43 percent—all of whom were Republicans—found
    him not guilty. The US Constitution requires a two-thirds majority of the Senate
    to convict, so Trump was acquitted. However, over 1,000 people were charged in
    connection to the January 6 insurrection. Two members of the far-right Oath Keepers
    militia, including its leader, Stewart Rhodes, and four members of the Proud Boys
    hate group, including its former leader, Enrique Tarrio, were convicted of seditious
    conspiracy. Several other members of these groups were also convicted of lesser
    crimes. Rhodes was sentenced to 18 years in prison in May 2023, and Tarrio was
    sentenced to 22 years in prison in September 2023.
  prefs: []
  type: TYPE_NORMAL
- en: Further investigating this dataset is obviously in the public interest. Let’s
    get started in Exercise 11-1.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-1: Download and Extract
    Parler Video Metadata</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Parler data is so large that it’s not practical, for the purposes of this
    chapter, to download it all. Instead, you’ll start with just the video metadata
    DDoSecrets has made available separately. The metadata contains useful information
    about each video, like its file format, when it was filmed, what type of phone
    or camera was used to film it, and in some cases the GPS coordinates describing
    where it was filmed. In this exercise, you’ll learn how to use the metadata to
    select and download individual videos to view.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re using Windows, I recommend that you follow along with this chapter
    using your Ubuntu terminal instead of PowerShell and that you save this data in
    your WSL Linux filesystem (for example, in* ~/datasets*), instead of in your Windows-formatted
    USB disk (*/mnt/c *or* /mnt/d*). Because of disk performance issues with WSL,
    I found that working with this data in Linux rather than directly in Windows was
    significantly faster. If you’ve only used Python in Windows so far, install Python
    in Ubuntu with the command* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">sudo
    apt install python3 python3-pip</samp>*, then install the click Python module
    by running* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">python3 -m pip
    install click</samp>*. You’ll need the click module for the exercises in this
    chapter. Refer to [Appendix A](appendixA.xhtml) to learn more about solving performance
    issues in WSL if you run into any problems.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Download the Metadata</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the Parler dataset takes up so much disk space, DDoSecrets couldn’t publish
    it using BitTorrent like it does with most of its other public releases. To seed
    that torrent, you would need a single server with 32TB of data, and no one would
    be able to connect to the swarm to download it because no one has 32TB of disk
    space lying around. Instead, DDoSecrets hosts the Parler data on its public data
    web server*.* If you know the filename of a Parler video, you can download it
    from *https://<wbr>data<wbr>.ddosecrets<wbr>.com<wbr>/Parler<wbr>/Videos<wbr>/<filename>*.
  prefs: []
  type: TYPE_NORMAL
- en: You can also download a full list of filenames, *ddosecrets-parler-listing.txt.gz*,
    and metadata for all of the video files, *metadata.tar.gz*. Files ending in *.gz*
    are compressed using a format called GZIP, so you can tell from the filename that
    *ddosecrets-parler-listing.txt.gz* is a compressed text file. Files ending in
    *.tar*, called *tarballs*, also combine multiple files and folders together into
    a single file. Tar files aren’t compressed, though—they take up as much disk space
    as all of the files they contain—so it’s common to compress them with GZIP, resulting
    in *.tar.gz* files. The *metadata.tar.gz* file is a GZIP-compressed tarball.
  prefs: []
  type: TYPE_NORMAL
- en: Start by downloading *ddosecrets-parler-listing.txt.gz* and *metadata.tar.gz*
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> command. This
    command is similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>,
    but it downloads a file and saves it to disk by default instead of displaying
    it in your terminal. Check if you already have <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp>
    installed by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">which wget</samp>.
    If you don’t, install it on macOS with <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew
    install wget</samp>, or on Linux or Windows with WSL with <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo
    apt install wget</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal. Create a new folder for the Parler data you’ll download, and
    change to that folder. (If you’re using Windows with WSL, make sure you create
    it in your WSL Linux filesystem, such as at *~/datasets/Parler*.) For example,
    here’s how I did it on my Mac, creating the folder on my *datasets* USB disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> to download
    the list of filenames by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output should show that you’ve downloaded the 17MB *ddosecrets -parler-listing.txt.gz*
    file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> program shows
    you a progress bar of your download in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, download the video metadata by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to make sure you’ve successfully downloaded the files by running <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">ls -lh</samp>. You should get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The file containing the list of filenames should be 17MB, and the metadata file
    should be 203MB.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uncompress and Download
    Individual Parler Videos</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To uncompress GZIP files, you’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    command with the following syntax: <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.gz</samp>. Running
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> on a gzipped file
    deletes the original file and leaves you with the uncompressed version without
    the *.gz* file extension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Uncompress the *ddosecrets-parler-listing.txt.gz* file by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your original 17MB file, *ddosecrets-parler-listing.txt.gz*, should be replaced
    with a 43MB text file called *ddosecrets-parler-listing.txt*, which contains over
    one million lines, one for each video that @donk_enby archived.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure it worked, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls
    -lh</samp> again. Your output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of files in *ddosecrets-parler-listing.txt* with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you learned in [Chapter 4](chapter4.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    command displays the content of a file, and piping that command’s output into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp> counts the number of
    lines in that file. The output should be <samp class="SANS_TheSansMonoCd_W5Regular_11">1031509</samp>,
    meaning there are 1,031,509 lines in *ddosecrets-parler-listing.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you load the file in a text editor, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first and second columns of text show the date and time that @donk_enby
    first uploaded each file to the S3 bucket, just after scraping it. The third column
    is the size of the file, in bytes, and the final column is the filename. All of
    the video files in the Parler dataset have similar random-looking names. These
    are the original IDs that Parler used for each video, and they don’t have file
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know the filenames of each Parler video, you can download individual
    files from *https://<wbr>data<wbr>.ddosecrets<wbr>.com<wbr>/Parler<wbr>/Videos<wbr>/<filename>*.
    Let’s try downloading one of the first videos listed in *ddosecrets-parler-listing
    .txt*. First, use the following commands to create a *videos* folder and switch
    to that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following command to download the Parler file *0003lx5cSwSB*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can normally tell the format of a file based on its file extension, but
    since these Parler video filenames don’t have extensions, use the following <samp
    class="SANS_TheSansMonoCd_W5Regular_11">file</samp> command to determine the format
    of *0003lx5cSwSB*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, <samp class="SANS_TheSansMonoCd_W5Regular_11">0003lx5cSwSB: ISO
    Media, MP4 v2 [ISO 14496-14]</samp>, shows that the file is an MP4 video. To make
    it easier to open in video-playing software, you’ll need to add the *.mp4* extension
    to the filename. You can rename files using the command <samp class="SANS_TheSansMonoCd_W5Regular_11">mv</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source_path dest_path</samp>,
    which moves a file from a source path to a destination path. To rename *0003lx5cSwSB*
    to *0003lx5cSwSB.mp4*, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can now watch *0003lx5cSwSB.mp4* in software like VLC Media Player. [Figure
    11-1](#fig11-1) shows a screenshot from this video, which features Trump battling
    the “fake news” media and calls him the “Savior of the Universe.”
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot from a pro-Trump video in which an image-edited Trump rides
    a motorcycle. The caption says “Trump A-Ah.”](Images/Figure11-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A screenshot from
    a pro-Trump Parler video showing an altered image of Trump riding a motorcycle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In your terminal, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cd ..</samp>
    to change out of the *videos* folder you just created and back to the Parler dataset
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: There are over a million videos in this dataset, and most likely, only a small
    fraction contain anything newsworthy. If you randomly pick individual videos to
    download and watch, chances are you’ll be wasting a lot of time. To more efficiently
    find interesting videos, let’s take a closer look at the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extract Parler Metadata</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To view the Parler metadata, you’ll need to extract the *metadata.tar.gz* tarball.
    In your terminal, uncompress and extract *metadata.tar.gz* using the <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because it’s so common to gzip tar archives, the <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    command will automatically detect if it’s gzipped and uncompress it for you, so
    you don’t need to manually do the <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    step yourself. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">-xvf</samp>
    argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> tells <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    to extract the files from *metadata.tar*, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    (meaning verbose) tells <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    to display each filename it extracts in the terminal, and <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    means that the next argument is a filename for the tarball on which this command
    will run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The command might take 10 minutes or so to extract the over one million JSON
    files in *metadata.tar.gz* into a new folder called *metadata*, depending on the
    speed of your hard disk. (If you’re using Windows with WSL and this step is going
    very slowly, consult Appendix A for performance tips.)
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to run <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> on
    the *metadata* folder or view it in a file browser, but beware that there are
    so many files that those simple tasks will take a long time (it took over five
    minutes for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> command
    to finish running on my computer). [Figure 11-2](#fig11-2) shows the files in
    the *metadata* folder in Finder on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: The files in this folder are all named *meta-*<*ID*>*.json*, where *ID* is the
    original video ID from Parler. For example, you can find the metadata for the
    file *0003lx5cSwSB*, the video you downloaded in the previous section, at *metadata/meta-0003lx5cSwSB.json*.
    All of these metadata files are in the JSON file format, so let’s take a closer
    look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: '![A Finder window, showing some of the JSON files in the metadata folder.](Images/Figure11-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: Some of the extracted
    Parler metadata files</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The JSON File Format</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON is a format used to store information in text strings. One of its main
    benefits is that it’s human-readable. Some file formats are designed for computers
    rather than humans to understand. If you run <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    on a PDF file, for example, you’ll see random-looking output in your terminal.
    You need to open the PDF in a program like Adobe Reader to understand the information
    it contains. However, humans can easily read the JSON text format just by viewing
    it in a text editor or by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    command.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is one of the most widely used data formats, and the one most APIs communicate
    with. Whenever you visit a website that does anything interactive, chances are
    your web browser and the website’s server are passing JSON data back and forth.
    This is one reason why hacked data, as well as data scraped from APIs, is often
    full of JSON files. Most of the data from the America’s Frontline Doctors dataset,
    covered in detail in [Chapter 13](chapter13.xhtml), is in JSON format, as is much
    of the data hacked from Gab, the right-wing social network discussed in Appendix
    B.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll learn more about JSON syntax and how to load JSON data
    into Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding JSON
    Syntax</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JSON has JavaScript in its name because it was first derived from that programming
    language, but it’s a *language-independent* data format: you can work with JSON
    data in JavaScript, Python, or any other programming language. Using their own
    JSON libraries, programming languages can convert JSON text strings into structured
    data (such as Python’s dictionaries and lists) and also convert that structured
    data back into JSON text strings that can be loaded by code in any other programming
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea of the structure of a JSON file, run the following command in
    your terminal to display the metadata for the Parler video with the filename *0003lx5cSwSB*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output should look like [Listing 11-1](#list11-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Video metadata
    for the file</samp> <samp class="SANS_Futura_Std_Book_11">0003lx5cSwSB</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, <samp class="SANS_TheSansMonoCd_W5Regular_11">FileType</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">MP4</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">2020:10:15 09:35:29</samp>, meaning
    that this video was filmed on October 15, 2020, at 9:35 AM, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Duration</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0:01:59</samp>, or 1 minute and
    59 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON syntax is extremely similar to Python syntax but uses different terminology
    to describe types of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of key-value pairs. An object is essentially equivalent to a dictionary
    in Python and even uses the same syntax. In JSON, however, keys *must* be strings.
    Objects are defined between braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}),
    and keys and values are separated with colons—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">{"first_name":
    "Frederick", "last_name": "Douglass"}</samp>. The JSON output for [Listing 11-1](#list11-1)
    also includes a JSON object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Array**'
  prefs: []
  type: TYPE_NORMAL
- en: An ordered list of items. An array is essentially equivalent to a list in Python
    and uses the same syntax. Arrays are defined between brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp>and]),
    and items are separated by commas. The JSON output in [Listing 11-1](#list11-1)
    has a few arrays, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">["mp42","mp41","iso4"]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean**'
  prefs: []
  type: TYPE_NORMAL
- en: A value of either <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. These work the
    same as <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    in Python, but they’re lowercase in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '**Number**'
  prefs: []
  type: TYPE_NORMAL
- en: Any whole number or number with decimals in it, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">2600</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>. These are similar
    to numbers in Python, though while Python makes a distinction between integers
    (whole numbers) and floating points (numbers with decimals), JSON does not.
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of text characters—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"videos
    have metadata?"</samp>. This is exactly the same as a string in Python, except
    that JSON strings *must* be enclosed double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>),
    whereas Python also allows you to use single quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">null</samp>
  prefs: []
  type: TYPE_NORMAL
- en: A keyword representing an empty value. This is very similar to Python’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp> keyword.
  prefs: []
  type: TYPE_NORMAL
- en: All JSON data is made up of combinations of these types, so it’s important to
    understand their exact syntax. If you use any invalid syntax, such as surrounding
    a string with single quotes instead of double quotes or using the Boolean <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    the JSON data won’t load properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike in Python code, whitespace isn’t important in JSON data. For example,
    consider this JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To write the same JSON string in a more human-readable format, you can split
    it into multiple lines and add indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You might encounter JSON files in datasets that are formatted either way. I
    often open JSON files in VS Code and use the text editor’s built-in format feature
    to reformat the JSON for legibility. To format a document in VS Code, click **View**▸**Command
    Palette**▸**Format Document** and press ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing JSON with
    Python</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can turn JSON data into Python dictionaries and lists using Python’s built-in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> module. First, open
    a Python interpreter and import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The function in this module that I use the most is <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>.
    This takes a string with JSON data as an argument, parses the string into a Python
    object like a dictionary or a list, and returns that object. For example, define
    a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    and set its value to a JSON string with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The value you set <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    to looks similar to a dictionary, but since it’s surrounded by single quotes,
    it’s actually a string. In Python, the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp>
    function tells you the type of a variable. You can confirm that <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    is a string with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    is a class of type <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> ([Chapter
    14](chapter14.xhtml) will touch on classes), meaning it’s a string. Now define
    a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> and
    set its value to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> takes
    a string as input and, if the string contains valid JSON, converts it into structured
    data—in this case, storing the resulting object in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function on
    <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> now to see what type
    of variable it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that you’ve parsed this JSON data into a Python dictionary
    (a <samp class="SANS_TheSansMonoCd_W5Regular_11">dict</samp>), which you can now
    use like any other dictionary. For example, to put the value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">last_name</samp>
    key of this dictionary in an f-string and then display it, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To practice accessing structured data, in your terminal, change to your Parler
    dataset folder, and then open a Python interpreter. Run the following commands
    to load the metadata from a Parler video as structured data. I’ve chosen the file
    *metadata/meta-HS34fpbzqg2b.json*, but feel free to load whichever file you’d
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You now have the video metadata in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    The simplest way to start inspecting it is to display it to the screen with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This output looks a little like JSON, but it’s a Python object—in this case,
    a list with a nested dictionary. Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function you learned about in [Chapter 8](chapter8.xhtml) to count how many items
    are in this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since any given Parler video metadata file contains the metadata only for one
    video, there’s only one item in this list. In order to access that metadata, you
    need to select the first item in the list. To do that, use <samp class="SANS_TheSansMonoCd_W5Regular_11">obj[0]</samp>
    (remember, 0 is the first index for any list) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the output starts with a brace, meaning the item is a dictionary.
    Now use a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to view
    all of the keys in this dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Each key listed in this output represents a different piece of video metadata
    from the JSON file. You can also select values from this dictionary using their
    keys. For example, try printing the values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These values represent the GPS coordinates for the location where this video
    was filmed.
  prefs: []
  type: TYPE_NORMAL
- en: Since JSON makes it easy to convert structured data into strings and back, when
    creating BlueLeaks Explorer I used JSON files to store the structure of BlueLeaks
    sites, as described in the section “The Technology Behind BlueLeaks Explorer”
    in [Chapter 10](chapter10.xhtml). When you create a structure for a BlueLeaks
    site, BlueLeaks Explorer stores all of the configuration for that site in a dictionary,
    then saves that information to a JSON file. If you quit BlueLeaks Explorer and
    then run it again later, it loads that JSON file back into a dictionary. Since
    the Parler metadata comes in JSON format, you can also write Python code that
    loads these JSON files to easily access that metadata, as you’ll do later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    module, you can find the documentation and plenty of example code at [*https://<wbr>docs<wbr>.python<wbr>.org<wbr>/3<wbr>/library<wbr>/json<wbr>.html*](https://docs.python.org/3/library/json.html).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Exceptions
    with JSON</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function
    will throw an exception if you pass an invalid JSON string into it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp>
    exception means that the string you passed in doesn’t contain valid JSON data.
    In this case, it’s telling you the error in the JSON string is at line 1, column
    1, and character 0, meaning the error is located at the first character of the
    string. If you have a longer JSON string that’s mostly valid but just has a little
    syntax issue, this error message can help you determine which piece of your syntax
    is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validating JSON data is a common use for Python exception handling, which you
    learned about in “Exception Handling” in [Chapter 7](chapter7.xhtml). For example,
    let’s say you have a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>.
    The following code will catch exceptions in case this string contains invalid
    JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statements to catch
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp>
    exception if it gets thrown. If <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    is a valid JSON string, it will display <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    JSON is valid</samp>, followed by the information in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    If the JSON string is invalid, the script will display <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid
    JSON</samp> and then continue running without crashing.
  prefs: []
  type: TYPE_NORMAL
- en: To load a JSON file in Python functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>,
    you must first load the content of the file into a string like so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.json</samp>
    with whatever file you’re loading, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata/meta-HS34fpbzqg2b.json</samp>
    to load the metadata for the *HS34fpbzqg2b* video file. As you learned in “Reading
    and Writing Files” in [Chapter 8](chapter8.xhtml), this code opens the file as
    a file object <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and then
    stores its content into a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’d run that string through <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    to convert it from a string into structured data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When this code finishes running, if the JSON string was valid, <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    will contain the JSON data. Otherwise, it will display <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid
    JSON</samp> and then return early from the function. The remaining code in the
    function can access the data in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for using this module to write Python scripts that parse the Parler
    metadata files, next we’ll look at how to access values like GPS coordinates from
    JSON files with several command line programs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Tools for Exploring JSON Data</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we’ve been focusing primarily on working with JSON files using Python,
    sometimes writing a Python script is overkill if you just want to quickly search
    a large block of JSON text. In this section, you’ll learn to use our old friend
    <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>, as well as a more powerful
    tool called <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>, to search
    JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Counting Videos with
    GPS Coordinates Using grep</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you know from [Chapter 4](chapter4.xhtml), the command line programs <samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>
    are incredibly powerful tools to quickly assess datasets. In a single command,
    and without needing to write a Python script, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    to efficiently search inside JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say you want to figure out how many Parler video metadata
    files include GPS coordinates. Open a terminal, switch to your Parler dataset
    folder, and run the following command to grep for the string <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">-r</samp>
    (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--recursive</samp>),
    tells <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to look inside
    every file in the given folder. The next argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>,
    is the string to search for. The final argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>,
    is the name of the folder to search.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this command, your terminal should quickly fill with GPS coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you’re trying to find how many of these videos have GPS coordinates,
    not necessarily what those coordinates are. If coordinates are still loading in
    your terminal, press CTRL-C to cancel the command, then pipe the output of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">wc
    -l</samp> to count how many lines get displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Of the slightly more than one million videos, about 64,000 have GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Programs like <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> can only take you so far
    in your attempts to efficiently search large quantities of data. For example,
    if the JSON files you’re searching are formatted on a single line, rather than
    split into multiple lines like the Parler files, <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    will search the entire block of JSON data for your string rather than a line at
    a time. You can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    to extract specific fields of data from JSON, either. For that, the best tool
    for the job is a program called <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatting and Searching
    Data with the jq Command</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> program allows you
    to take JSON data as input and select key information from it. In this section,
    you’ll learn how to use it to extract specific information from the Parler files.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll need to install <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
    Mac users can do so by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew
    install jq</samp> command. Linux or Windows with WSL users, run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo
    apt install jq</samp> command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command
    to indent JSON data and show syntax highlighting in your terminal, making the
    data easier to read. For example, try running this command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the command, <samp class="SANS_TheSansMonoCd_W5Regular_11">cat
    metadata/meta-HS34fpbzqg2b.json</samp>, outputs the content of that JSON file,
    which contains the metadata for a single Parler video. The second part, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">| jq</samp>, pipes that output as input
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This version includes syntax highlighting (as in VS Code) and formats the JSON
    data so that the items in every array and object are listed on separate lines
    and indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to
    filter for details from inside the JSON data. For example, suppose you just want
    to know the GPS coordinates from this JSON file. In the preceding code, you can
    tell from the bracket character at the beginning that this JSON data is an array.
    The first value of the array is an object, since it starts with a brace character,
    and one of the keys of the object is <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>.
    To filter for <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>,
    pass <samp class="SANS_TheSansMonoCd_W5Regular_11">".[0].GPSPosition"</samp> as
    an argument into the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this command, <samp class="SANS_TheSansMonoCd_W5Regular_11">.[0]</samp> selects
    the first item of the list in the file named *metaHS34fpbzqg2b.json*, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.GPSPosition</samp> selects the value
    with the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>
    from the object. The output shows the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>
    field, <samp class="SANS_TheSansMonoCd_W5Regular_11">"38 deg 53' 26.52\" N, 77
    deg 0' 28.44\" W"</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in learning more about how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>,
    check out its website at [*https://<wbr>stedolan<wbr>.github<wbr>.io<wbr>/jq*](https://stedolan.github.io/jq).
    You’ll also revisit it in [Chapter 14](chapter14.xhtml), where I explain how I
    used it to understand the structure of leaked neo-Nazi chat logs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a foundational understanding of JSON, you’ll try your hand
    at writing Python code that works with it in Exercise 11-2.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-2: Write a Script to Filter
    for Videos with GPS from January 6, 2021</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you’ll write a Python script that filters the Parler videos
    down to just those filmed on January 6, 2021, whose metadata includes GPS coordinates.
    You’ll do this by looping through all the JSON files in the dataset, converting
    them into Python objects, and inspecting their metadata to show you just the ones
    you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a challenge, you can try programming your own script to meet the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Make this script accept an argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>,
    using Click. This will be the path to the *metadata* folder full of JSON files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    that keeps track of the number of Parler videos that include GPS coordinates in
    their metadata, and set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop through all of the JSON files in the *metadata* folder. For each loop,
    your program should run the content of each JSON file through the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    function to turn it into a Python object. As described in the “Parsing JSON with
    Python” section, each object is technically a list containing one element, a dictionary
    full of all of the video’s metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check to see if that video’s metadata dictionary includes the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>
    and if the date stored in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    is January 6, 2021\. If both of these are true, the script should display a message
    that this file includes GPS coordinates and is from January 6, 2021, and increment
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable by 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the program display a message after looping through all the metadata files
    that tells the user the total number of videos with GPS coordinates from January
    6, 2021 (which should be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    variable, now that you’re done counting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, follow along with the rest of this exercise and I’ll walk you
    through the programming process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept the Parler
    Metadata Path as an Argument</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start with the usual Python script template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make the following modifications to your script so that it accepts the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp> CLI
    argument. This way, when you run the script, you can pass in the path to the *metadata*
    folder as an argument, which the code will use to open all of the JSON files inside
    that folder. The modifications are shown in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code first imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, then uses it to make the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function accept the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>.
    It also adds a docstring to show what the script does when you run it with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> argument. Finally,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function will
    print the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test your code to make sure it works so far, replacing the argument with the
    path to your own *metadata* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, the code should display the same string, stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>,
    that you passed in as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Through Parler
    Metadata Files</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, add some code that will loop through all of the JSON files in the *metadata*
    folder and run <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    on their contents to convert them into structured data in Python. Modify your
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> modules at the top
    of the file so it can use the functions they contain later on. The program then
    loops through the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    function, which returns the list of files in the *metadata* folder, storing each
    filename in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the
    code defines a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">abs_filename</samp>
    to be the absolute path of the JSON file the code is working with each time it
    loops. It creates the absolute path by concatenating <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> function. Now that
    the code knows the full filename, it checks to make sure that this is actually
    a file, not a folder, and that it ends with *.json*.
  prefs: []
  type: TYPE_NORMAL
- en: If the code confirms the file is JSON, it loads all of the data from this file
    into the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    and then converts that string into structured data, saved in the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>, using <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statements, as
    described in the “Handling Exceptions with JSON” section. If there are no syntax
    errors in an individual JSON file, the code displays a message to the screen saying
    that the file loaded successfully. Otherwise, it displays an error and moves on
    to the next file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement. In a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements immediately
    end the current loop and move on to the next loop.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, at this point the code is looping through every file in the *metadata*
    folder, and for each JSON file it comes across, opening it and loading its content
    as a text string. It then converts this string into a Python object using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function, storing
    the object in the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>
    variable, and displays a message that it successfully loaded. If the file didn’t
    successfully load, the message says that the JSON was invalid, and the code continues
    on to the next JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program again, replacing the argument with the path to your own *metadata*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If your output shows many messages saying different JSON files loaded successfully,
    your code is working. Once you’ve determined that your output looks correct, you
    can press CTRL-C to cancel the script before it finishes running.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Videos
    with GPS Coordinates</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Your code currently loops through all of the Parler metadata files, loads each
    file, and converts it into a Python object so you can work with it. Next, you
    need to filter out the videos that include GPS coordinates and to count those
    videos. To do so, make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    and starts its value out as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    This will keep track of the number of videos with GPS coordinates. After each
    JSON file is loaded into the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>
    variable, an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    checks if the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>
    exists inside this metadata dictionary. Remember from the previous section that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> is a list with one
    item, making <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata[0]</samp>
    the actual dictionary your code is checking. If this video metadata does have
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> field,
    the control flow moves to the code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Otherwise, it moves on to the next loop.
  prefs: []
  type: TYPE_NORMAL
- en: When the Python script comes across metadata that includes GPS coordinates,
    it displays the name of the file with <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    and increments <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> by 1\.
    This way, by the time this <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop is finished, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> will
    contain the total number of videos that have GPS coordinates in their metadata.
    Finally, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    completes, the code displays that total count with a second call to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function. As you learned
    in [Chapter 8](chapter8.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>
    in the f-string will display larger numbers with comma separators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your program again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this script loads the JSON data from over a million files, it might
    take a few minutes to finish running. In the end, your script should find 63,983
    videos with GPS coordinates. There should also be 63,984 lines of output: one
    with the name of each metadata file that has GPS coordinates, and one at the end
    that lists the total.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Videos
    from January 6, 2021</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll whittle down that list of roughly 64,000 videos even further to find
    out which were filmed on January 6, 2021.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can tell the date on which a video was filmed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    field in its metadata, as shown earlier in [Listing 11-1](#list11-1). The value
    of this field looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    field to filter the results further, make the following modifications to your
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than just checking for videos with GPS coordinates, now the code also
    checks for those that have a <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    that starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">2021:01:06</samp>.
    Once the code determines that the metadata in the current loop has GPS coordinates
    and was created on January 6, 2021, it displays the filename with <samp class="SANS_TheSansMonoCd_W5Regular_11">print(f"GPS</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Jan
    6: {filename}")</samp>. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop is finished, it displays the total count.'
  prefs: []
  type: TYPE_NORMAL
- en: The expression in this code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is surrounded by parentheses, and the three conditions inside those
    parentheses are indented. This is purely cosmetic; the code would work exactly
    the same if it were all on one line, but this formatting makes it slightly easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the final script in the book’s GitHub repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-2.py).
    Run the completed script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The script might still take a few minutes to run, but this time, there should
    be fewer results. Only 1,958 Parler videos have GPS coordinates and were filmed
    on January 6, 2021; this is about 3 percent of the videos with GPS coordinates,
    and less than 0.2 percent of all of the videos.
  prefs: []
  type: TYPE_NORMAL
- en: Watching almost 2,000 videos, while perhaps unpleasant, is at least feasible.
    We can still do better, though. In all likelihood, some of those January 6 videos
    weren’t actually filmed at the insurrection itself, but just happened to be uploaded
    the same day from other locations. To prepare for filtering this list further
    in order to find videos filmed at the insurrection, you’ll need some background
    on working with GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with GPS Coordinates</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll learn how latitude and longitude coordinates work and
    how to look them up on online map services like Google Maps. You’ll also learn
    how to convert between different GPS formats and measure the rough distance between
    two locations. I’ll introduce a few new Python features, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> methods for
    modifying strings and the <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    function for converting a string into a decimal number.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searching by Latitude
    and Longitude</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can define any location on Earth using two coordinates: latitude and longitude.
    These coordinates are measured in degrees, with each degree split into 60 minutes
    and each minute split into 60 seconds. Latitude goes from 90 degrees North, which
    is the North Pole, to 0 degrees at the equator, to 90 degrees South, which is
    the South Pole. Longitude goes from 180 degrees West, which is in the middle of
    the Pacific Ocean, to 0 degrees, which cuts through England, to 180 degrees East,
    back to that same location in the middle of the Pacific.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you look up the metadata for the Parler video with filename
    *HS34fpbzqg2b* (which shows Trump supporters removing barricades around the Capitol
    building while police officers stand by and watch), you’d find the following GPS
    coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Latitude: 38 deg 53′ 26.52″ N'
  prefs: []
  type: TYPE_NORMAL
- en: 'Longitude: 77 deg 0′ 28.44″ W'
  prefs: []
  type: TYPE_NORMAL
- en: That means this video was filmed at the latitude of 38 degrees, 53 minutes,
    26.52 seconds North and the longitude of 77 degrees, 0 minutes, 28.44 seconds
    West.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use various online map services, like Google Maps, to search by GPS
    coordinates and see exactly where on Earth they point to. To search the coordinates
    contained in the Parler metadata, you’ll need to slightly modify them so that
    Google Maps will recognize them, loading [*https://<wbr>www<wbr>.google<wbr>.com<wbr>/maps*](https://www.google.com/maps)
    and entering these coordinates as the string 38°53′26.52″, −77°0′28.44\. Try searching
    for those coordinates in Google Maps now. [Figure 11-3](#fig11-3) shows the exact
    location this video was filmed: just outside the US Capitol building, where police
    had set up barricades.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Google Maps screenshot with a pin on a location just outside the US Capitol
    building.](Images/Figure11-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Pinpointing a
    location near the US Capitol building in Google Maps</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use Google Maps to discover the GPS coordinates of any given point.
    If you right-click anywhere on the map, a context menu should pop up showing you
    the GPS coordinates of that point. However, when you do this, the coordinates
    it shows you will look slightly different because they’ll be in decimal format.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn to convert from decimals to degrees, minutes,
    and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    GPS Coordinate Formats</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GPS coordinates in decimal format show the number of degrees on the left side
    of the decimal point, and converted minutes and seconds values on the right side.
    For example, consider the GPS coordinates from the *HS34fpbzqg2b* video:'
  prefs: []
  type: TYPE_NORMAL
- en: The latitude is 38 degrees, 53 minutes, 26.52 seconds North, which is 38.8907
    in decimal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The longitude is 77 degrees, 0 minutes, 28.44 seconds West, which is −77.0079
    in decimal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One degree is 60 minutes and one minute is 60 seconds, meaning there are 3,600
    seconds in a degree. The formula to convert from degrees, minutes, and seconds
    to decimal format is *degrees* + (*minutes* / 60) + (*seconds* / 3,600). Latitudes
    are negative in the Southern Hemisphere but positive in the Northern Hemisphere,
    while longitudes are negative in the Western Hemisphere but positive in the Eastern
    Hemisphere. The latitude for the *HS34fpbzqg2b* video is positive, while the longitude
    is negative.
  prefs: []
  type: TYPE_NORMAL
- en: Decimal numbers are simpler to work with in code. Since the GPS coordinates
    in the Parler metadata are formatted as degrees, minutes, and seconds, let’s use
    some Python code to convert them to decimal format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function in [Listing 11-2](#list11-2) takes a GPS coordinate from the Parler metadata
    as an argument and returns the decimal version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">gps_degrees_to_decimal()</samp>
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function introduces some new Python features. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp>
    string method splits a string into a list of parts based on whitespace. For example,
    this method would convert the string <samp class="SANS_TheSansMonoCd_W5Regular_11">''77
    deg 0\'' 28.44" W''</samp> into the list of strings <samp class="SANS_TheSansMonoCd_W5Regular_11">[''77'',
    ''deg'', "0'' ", ''28.44" '', ''W'']</samp>. The line <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">gps
    _coordinate.split()</samp> stores the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate.split()</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp> variable.
    If you passed that string into this function as <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp>,
    this would mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[1]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">deg</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[2]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp> (0 followed by a single
    quote).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[3]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp> (28.44 followed by
    a double quote).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[4]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you can do math with strings in Python, you must convert them into *floating-point
    numbers*—which are just numbers that can contain decimals—using the <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    function. [Listing 11-2](#list11-2) uses <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    to set the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp>
    to the floating-point version of <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp>.
    In this case, it converts the value of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp> to the
    floating-point number <samp class="SANS_TheSansMonoCd_W5Regular_11">77.0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code similarly uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp>
    string method to convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp>
    value to a floating-point number. This method searches the string for the first
    argument and replaces it with the second argument. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"GPS
    is fun".replace("fun", "hard")</samp> returns the string <samp class="SANS_TheSansMonoCd_W5Regular_11">GPS
    is hard</samp>. When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[2].replace("
    ' ", " ")</samp>, you’re replacing the single quote character (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>)
    with an empty string, in order to delete that character. This would convert the
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and then convert <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to the floating-point number
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The next line uses <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp>
    to delete the double quote character (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>),
    converting the string <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinates</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp>, then converting that into
    the floating-point number <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp>
    and saving it as <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the function is more straightforward. It defines the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp> as the decimal version
    of the GPS coordinates that are passed in an argument, using the formula to convert
    the coordinates to decimal format using the numbers in <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>.
    If the coordinates are in the Western or Southern Hemisphere, the code <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal
    *=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> makes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp> a negative number.
    Finally, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">gps
    _decimal</samp>, the decimal version of the GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Since the GPS coordinates in the Parler data come in strings of degrees, minutes,
    and seconds, you’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function in the next exercise to convert them to decimal format. First, though,
    you’ll need to know how to calculate distances between two GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating GPS Distance
    in Python</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To determine which Parler videos were filmed in Washington, DC, based on their
    GPS coordinates, you can begin by finding the coordinates for the center point
    of the city and then imagine a circle around that point. You can consider a video
    to have been filmed in the city if its metadata has both a longitude and latitude
    within that circle. This won’t tell you if the video was exactly filmed within
    the Washington, DC, city limits, but it’s close enough. In this section, I’ll
    review the simple math required to do this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The Earth isn’t flat, but for the purposes of this chapter, pretend that Washington,
    DC, is a flat plane. You can think of GPS coordinates as a 2D point on a Cartesian
    coordinate system, where longitude represents the *x* axis (East and West) and
    latitude represents the *y* axis (North and South). Since you can look up the
    coordinates of the center of Washington, DC, and you know the coordinates for
    where each video was filmed, you can use the distance formula to determine if
    it’s inside the circle.
  prefs: []
  type: TYPE_NORMAL
- en: The distance formula, as you might recall from geometry class, is used to calculate
    the distance between two points. It states that the distance between two points
    equals the square root of ((*x*[2] − *x*[1])² + (*y*[2] − *y*[1])²), where (*x*[1],
    *y*[1]) is one point and (*x*[2], *y*[2]) is another point. As an example, [Figure
    11-4](#fig11-4) shows the distance between the White House and the US Capitol,
    with the White House at point (*x*[1], *y*[1]) and the US Capitol at point (*x*[2],
    *y*[2]).
  prefs: []
  type: TYPE_NORMAL
- en: '![A map of Washington, DC, overlaid by a right triangle. The White House is
    at the top of the triangle’s y axis, the US Capitol is at the right of the triangle’s
    x axis, and the distance formula is shown on the hypotenuse between them.](Images/Figure11-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: Using the distance
    formula to calculate the distance between the White House and the US Capitol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To determine if a given Parler video was filmed in Washington, DC, you’ll compare
    the city center with the GPS coordinates of a Parler video. The center point of
    DC is constant, and when you loop through the JSON files of Parler metadata, you
    can find all the relevant GPS coordinates. If you plug these points into the distance
    formula, you can determine whether the distance is close enough to the center
    to be considered inside the city.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Since the Earth isn’t actually flat, using the distance formula will only
    be relatively accurate for short distances, like 20 kilometers. It’s possible
    to calculate much more accurate distances between GPS coordinates using spherical
    geometry, but that requires using trigonometry functions like sine, cosine, and
    arctangent. Using the distance formula is much simpler and accurate enough for
    our purposes.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-3](#list11-3) shows a Python <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function that implements the distance formula.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">distance()</samp>
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The distance formula requires you to calculate a square root, which you can
    do using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">math.sqrt()</samp>
    function. To access this function, first you import the <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    module at the top of the file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">x1</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y1</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y2</samp> arguments, then calculates
    the distance formula, returning the distance between the two points. (In Python,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">**</samp> is the power operator,
    so we write *x*² as <samp class="SANS_TheSansMonoCd_W5Regular_11">x**2</samp>.)
    If you call <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> and
    pass any two points into it as arguments, it will return the distance between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding the Center
    of Washington, DC</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll find the coordinates of the center of Washington, DC, so that you
    can use the distance formula to compare them against those from a Parler video.
    Load [*https://<wbr>www<wbr>.google<wbr>.com<wbr>/maps*](https://www.google.com/maps)
    in your browser and search for **Washington DC**. Right-click the US Capitol building,
    which is approximately at the center of the city. Google Maps should show you
    the GPS coordinates of that point (see [Figure 11-5](#fig11-5)); click them to
    copy them. Your GPS coordinates might be slightly different, depending on where
    exactly you clicked.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot from Google Maps, showing the menu that pops up after right-clicking
    a point near the center of Washington, DC. The first item on the menu is 33.89410,
    −77.00667, which are the GPS coordinates of that point.](Images/Figure11-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: Using Google Maps
    to find the GPS coordinates of the center of Washington, DC</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the radius of the imaginary circle around Washington, DC, is about 20 kilometers,
    you can consider any videos filmed within 0.25 degrees to be inside the city.
    I decided on 0.25 degrees by checking the GPS coordinates on the outskirts of
    DC and comparing them to the coordinates in the city center.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> Python functions
    and the GPS coordinates for the center of Washington, DC, you’re ready to finish
    filtering the Parler videos to find the insurrection videos in Exercise 11-3.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-3: Update the Script to
    Filter for Insurrection Videos</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, you’ll filter the results of the Exercise 11-2 script even
    further, searching just for videos filmed in Washington, DC. First, make a copy
    of *exercise-11-2.py* and rename it *exercise-11-3.py*. Now modify *exercise-11-3.py*
    to match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This code first defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function from [Listing 11-2](#list11-2) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function from [Listing 11-3](#list11-3), importing the required <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    module at the top of the file. It will later use <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to
    _decimal()</samp> to convert GPS coordinates from the Parler video metadata into
    decimal format and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    to calculate the distance between that GPS coordinate and the center of Washington,
    DC.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    function. This function takes a single argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>,
    which contains the Parler video metadata loaded from its JSON file. It returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if the GPS coordinates
    in that metadata are located inside Washington, DC, but otherwise returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    function first defines the *x* and *y* coordinates you found for the city center
    in the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_y</samp>. Next, it defines the
    *x* and *y* coordinates of the Parler video, storing those values in the variables
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
    Since the GPS coordinates in the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> metadata
    fields aren’t in decimal format, it first passes those strings into the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> function
    to convert them from degrees, minutes, and seconds into decimals and then saves
    the return values into <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function
    to determine the distance between these two points. The return value is this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function
    returns a number representing the distance between the center of Washington, DC,
    and the location where the video was filmed. If that number is less than or equal
    to 0.25 (roughly 20 kilometers), the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>;
    otherwise, it evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    Thus, the <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    function returns a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: With these functions defined at the top of the file, the remaining changes to
    the script are minimal. The code updates the docstring, since our script’s purpose
    has changed. It also updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement that checks whether or not an insurrection video was found. The version
    of this script from Exercise 11-2 just checked if the metadata included a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> field, but now it
    checks for the fields <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> as well.
    The videos with GPS coordinates contain all three of these fields. <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>
    is just a single field that contains both longitude and latitude. However, since
    you need separate values for longitude and latitude, it’s simpler to use the metadata
    fields that are already separated. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement confirms that the video was filmed in Washington, DC, by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc(metadata)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If all of these conditions are true—the metadata contains <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>; the metadata
    contains <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> with
    a value matching January 6, 2021; and the GPS coordinates in the metadata show
    that the video was filmed in Washington, DC—then the code displays a message saying
    it found an insurrection video and increments <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>.
    Finally, after the script has finished looping through all of the Parler metadata
    files, it displays the total number of insurrection videos found.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the final script in the book’s GitHub repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-3.py).
    Run your complete script now, making sure to pass in the correct path to your
    Parler *metadata* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The script should find 1,202 insurrection videos. This means that out of the
    1,958 videos uploaded to Parler on January 6 that included GPS coordinates, at
    least 61 percent were videos of the insurrection itself. (It’s possible that more
    videos uploaded to Parler were also from the insurrection that day but just didn’t
    include GPS coordinates in their metadata.) Manually watching 1,202 Parler videos
    is still unpleasant, but at least it’s not as bad as watching 1,958.
  prefs: []
  type: TYPE_NORMAL
- en: You now know which of the Parler videos were from the January 6 insurrection,
    but you can draw even more interesting conclusions from this dataset (and others
    that contain similar location data) when you visualize the data on a map.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Plotting GPS Coordinates on a Map with
    simplekml</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than just displaying a list of insurrection video filenames, you could
    plot the locations of those videos on a map, allowing you to easily choose which
    videos you’d like to watch first. You could also map all Parler videos that contain
    GPS coordinates around the world, in case there are other newsworthy videos in
    this dataset that don’t relate to the January 6 insurrection. In this section,
    you’ll learn to write Python code to create a file of Parler location data that
    you can then upload to an online map service to visualize it.
  prefs: []
  type: TYPE_NORMAL
- en: Google Earth ([*https://<wbr>earth<wbr>.google<wbr>.com*](https://earth.google.com))
    allows you to upload a file in Keyhole Markup Language (KML), a file format designed
    to describe geographical features such as points on a map. KML was created in
    2004 specifically for use with Google Earth, and it became a standard file format
    for describing geographic data in 2008.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-4](#list11-4) shows an example KML file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: A file written
    in KML,</samp> <samp class="SANS_Futura_Std_Book_11">example.kml</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the KML format is similar to HTML. Both formats are extensions
    of XML, or Extensible Markup Language, so they share the same rules. The first
    line, starting with <samp class="SANS_TheSansMonoCd_W5Regular_11"><?xml</samp>,
    is called the XML prolog, and it defines some metadata about this file. The entire
    contents of the KML file are wrapped in a <samp class="SANS_TheSansMonoCd_W5Regular_11"><kml></samp>
    tag. Inside this is a <samp class="SANS_TheSansMonoCd_W5Regular_11"><Document></samp>
    tag, and inside this are one or more <samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp>
    tags. Each <samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp> represents
    a point on a map: its name, description, and GPS coordinates in decimal format.
    This example file describes a single point for New York City.'
  prefs: []
  type: TYPE_NORMAL
- en: To plot GPS coordinates on Google Earth, you must generate a KML file that contains
    these coordinates and then upload it to the service. The simplest way to create
    KML files is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    Python module. You can use this module to create a new KML object, create a new
    point on it for each Parler video with GPS coordinates, and then save that KML
    object to a *.kml* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    module by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use the module in the Python interpreter to generate the *example .kml*
    file from [Listing 11-4](#list11-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: After importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    module, this code defines the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml</samp>
    variable as the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml.Kml()</samp>,
    which returns a KML object. It then uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml.newpoint()</samp>
    method to add GPS points to the KML file it’s creating. While this example just
    adds one point for New York City, with the description “The Big Apple,” you can
    add as many points as you want. Note that the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">coords</samp>
    argument must be a list of tuples, with each tuple containing longitude and latitude
    coordinates in decimal format. Finally, after adding points, the code saves the
    KML file by running <samp class="SANS_TheSansMonoCd_W5Regular_11">kml.save()</samp>
    and passes an output filename.
  prefs: []
  type: TYPE_NORMAL
- en: You can find further documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    Python module at [*https://<wbr>simplekml<wbr>.readthedocs<wbr>.io*](https://simplekml.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to create KML files full of location data that can be mapped
    in Google Earth. As your final exercise in this chapter, you’ll generate KML files
    based on GPS coordinates in the Parler dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-4: Create KML Files to
    Visualize Location Data</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve focused on finding Parler videos filmed in Washington, DC, during
    the January 6 insurrection. While this is undoubtedly the most newsworthy part
    of this dataset, there could be other things we’re missing. Parler is a global
    far-right social network. What other far-right videos did people post to it? Does
    it contain any interesting data from other countries, such as Russia? In this
    exercise, you’ll write a script that creates two KML files full of GPS coordinates
    from the Parler dataset to visualize in Google Earth:'
  prefs: []
  type: TYPE_NORMAL
- en: A *parler-videos-all.kml* file containing all videos with GPS coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *parler-videos-january6.kml* file containing videos with GPS coordinates filmed
    on January 6, 2021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This exercise will give you experience creating KML files and using Google Earth
    to visualize location data, a skill that will likely come in handy for any future
    dataset you come across that includes location data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll base your script for this exercise off the script you wrote in Exercise
    11-3\. For a challenge, you can try programming your own script to meet the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Make this script accept an argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>,
    using Click. This will be the path to the *metadata* folder full of JSON files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> module
    and create two KML objects (one for each KML file you’ll be creating). Loop through
    the Parler video metadata JSON files, and add different points to the appropriate
    KML objects depending on the metadata. Points for all videos should be added to
    *parler-videos-all.kml*, and points only for videos with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    of January 6, 2021, should be added to *parler-videos-january6.kml*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give every point you add to a KML object a name, a description, and GPS coordinates
    in decimal format. The name should be the Parler video ID (for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HS34fpbzqg2b</samp>), and the description
    should be a string containing the video’s download link (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">https://data.ddosecrets.com/Parler/Videos/HS34fpbzqg2b</samp>)
    as well as important metadata fields such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTypeExtension</samp>, or others
    you’re interested in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your script loop through all of the metadata JSON files and filter them
    for videos that contain GPS coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, follow along with the instructions in the rest of this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create a KML File
    for All Videos with GPS Coordinates</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll begin by writing a script to loop through all of the Parler metadata
    JSON files and add any GPS coordinates it finds to a single KML file, *parler
    -videos-all.kml*, including only the video URL in the description, not any metadata.
    Make a copy of the *exercise-11-3.py* script and name it *exercise-11-4.py*, then
    make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since you’re going to be mapping this data, you don’t need the code that detects
    if a video is in Washington, DC—you’ll be able to tell by zooming into Washington,
    DC. Therefore, this code deletes the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    functions from the previous script, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    import. The new code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    module at the top of the file so that you can use it later in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code defines the function <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename_to_parler_id()</samp>.
    This function is only a single, complex line of code that takes the filename of
    a Parler metadata JSON file as an argument, then returns the Parler ID associated
    with that file. For example, say the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">meta-31VC1ufihFpa.json</samp>.
    In this case, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename.split("-")</samp>
    will evaluate to the list <samp class="SANS_TheSansMonoCd_W5Regular_11">['meta',
    '31VC1ufihFpa.json']</samp>. Since Python starts counting at zero, the code selects
    the second item in that list (the string <samp class="SANS_TheSansMonoCd_W5Regular_11">31VC1ufihFpa.json</samp>)
    by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp> to that expression,
    making it <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename .split("-")[1]</samp>.
    Next, it splits *that* string on the period character with the expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">json_filename.split("-")[1].split(".")</samp>,
    which returns the list <samp class="SANS_TheSansMonoCd_W5Regular_11">['31VC1ufihFpa',
    'json']</samp>. It then selects the first item in that list (the string <samp
    class="SANS_TheSansMonoCd_W5Regular_11">31VC1ufihFpa</samp>) by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    to that expression, making it <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename
    .split("-")[1].split(".")[0]</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename_to_parler_id()</samp>
    function just returns the result of that expression, which is the Parler ID.
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function,
    the code defines a new KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp>
    to contain all the GPS points found in the Parler metadata. The rest of this code
    should be familiar to you from Exercises 11-2 and 11-3\. It loops through the
    Parler *metadata* folder looking for JSON files, loading the JSON data for each
    file it finds into the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>
    variable. This time, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement ensures that the metadata dictionary contains the keys <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> and that
    those values aren’t blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code finds a Parler video that contains non-empty GPS fields, it sets
    up variables with the data it needs to add the point to the KML files: <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>. It defines <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> as the return value of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename _to_parler_id()</samp>
    function, meaning the name of the point will be the video’s Parler ID. It defines
    <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp> as the video’s
    download URL. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function, it defines <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp> as the longitude
    and latitude, in decimal format, of the GPS coordinates found in the metadata.'
  prefs: []
  type: TYPE_NORMAL
- en: After defining these variables, the code runs <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all.newpoint()</samp>
    to add the GPS point to the KML object. It sets the point’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    its description to <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>,
    and its coordinates to a list of points; in this case, the list has only one point,
    a tuple containing <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>. Finally, when the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is complete, the code
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all.save()</samp>
    function to save all of these GPS points into the file *parler-videos-all.kml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the final script, changing the path in the argument to the path to your
    Parler *metadata* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Since the Parler dataset contains about 64,000 videos with GPS coordinates,
    the script should return about 64,000 lines of output, each including a video’s
    Parler ID, longitude, and latitude. When the script finishes running, it should
    also create a 20MB KML file called *parler-videos-all.kml* in the same folder
    as the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open *parler-videos-all.kml* in a text editor. The file’s contents should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This file should contains 64,000 <samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp>
    tags, each representing a different Parler video with GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve created a KML file that contains *all* of the Parler location
    data, you’ll modify your script further to create a KML file with just the videos
    from January 6, 2021.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create KML Files
    for Videos from January 6, 2021</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Your script so far has a KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp>,
    and the code adds all of the GPS points in the Parler metadata to it. Make the
    following changes to your code to create another KML object, <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>,
    and just add GPS points from videos filmed on January 6, 2021, to it. Since this
    script is getting long, I’ll quote just the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, the only part that is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, this script adds another KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>.
    The code will add points to this file only from January 6, 2021\. Next, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop will loop through each
    Parler metadata file, parse the JSON, and determine whether or not it has GPS
    coordinates. If so, the code will prepare variables so it can add the point to
    the KML objects. But this time, instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    variable containing just the video’s download URL, it will also include metadata.
  prefs: []
  type: TYPE_NORMAL
- en: When defining <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>,
    the code adds <samp class="SANS_TheSansMonoCd_W5Regular_11"><br></samp> at the
    end, which is the HTML tag for a line break. This way, when you visualize this
    KML file, the description will show the URL on the first line, and the metadata
    will start on the next line. The code then loops through a list of metadata keys
    to add to the description, including <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTypeExtension</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Duration</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Make</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Model</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Software</samp>.
    If there are any other pieces of metadata you’d like to include, feel free to
    add them to your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each loop, the code checks to see if the metadata for the current video
    includes that key, and if so, adds its value to <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>,
    inserting a line break after each piece of metadata. For example, if the code
    is looking at the JSON file *meta-g09yZZCplavI.json*, <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: (The actual value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    string will contain <samp class="SANS_TheSansMonoCd_W5Regular_11"><br></samp>
    for the line breaks, but this is how the description will look in Google Earth.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code uses another <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to see if that video was created on January 6, 2021, and if so, adds
    that point to <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>.
    It does this by checking that the file has a <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    metadata field and that the date in that field is from January 6, 2021, just as
    you did in Exercise 11-2\. Finally, when the script finishes looping through all
    of the Parler videos, after saving the points in <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp>
    to *parler-videos-all.kml*, it also saves the points in <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>
    to *parler-videos-january6.kml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the final script in the book’s GitHub repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-4<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-4.py).
    Run your complete script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When the script is finished running, it should have created two KML files:
    a 31MB file called *parler-videos-all.kml* (the file is bigger this time because
    the descriptions are longer) and a 929KB file called *parler-videos -january6.kml*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve put in the hard work of generating KML files full of GPS coordinates,
    you can move on to the fun part: visualizing this data using Google Earth. This
    will allow you to scroll around the globe picking which videos you’d like to watch.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Visualizing Location Data with Google
    Earth</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to visualize location data in the KML files
    that you just created using Google Earth, marking each Parler video with a pin
    on a map. Not only will this let you visualize exactly where all of the videos
    with GPS coordinates were filmed, but this will also make it considerably simpler
    to download these videos to watch.
  prefs: []
  type: TYPE_NORMAL
- en: When you created those KML files, you set the description for each Parler video
    to include its download URL. Once you load a KML file into Google Earth and turn
    it into pins on a map, you can click on a video’s pin to see its description and
    then click the link in the description to download the video. In a web browser,
    load Google Earth at [*https://<wbr>earth<wbr>.google<wbr>.com*](https://earth.google.com).
    (You don’t have to log in to a Google account, though doing so enables you to
    save your work and revisit it later.) In the menu bar on the left, choose **Projects**▸**Open**▸**Import
    KML File from Computer**. Browse for the *parler -videos-all.kml* file you created
    in the previous exercise and open it. When it’s done loading, click the pencil
    icon to edit the title of this project, name it *All Parler Videos*, and press
    ENTER. This should create a pin on the map for each Parler video in the entire
    dataset, labeled by its ID.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for *parler-videos-january6.kml*, and name this one **Parler
    Videos from January 6, 2021**. In the Projects panel on the left of the screen,
    you should see your two projects.
  prefs: []
  type: TYPE_NORMAL
- en: By clicking the eye icon, you can show and hide Google Earth projects to choose
    which KML files you want displayed. With the pins you want displayed, you can
    rotate the Earth and zoom in on whatever you’d like. You can double-click on the
    map, click the plus (+) button to zoom in, and click the minus (−) button to zoom
    out.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to investigate just the insurrection videos, show that project
    and hide the others. [Figure 11-6](#fig11-6) shows Google Earth zoomed in on the
    US Capitol building in Washington, DC, with just the videos from the January 6
    insurrection showing. The pins in the figure are all videos of the January 6 insurrection,
    and the pins located over the Capitol building itself are videos filmed by Trump
    supporters who were actively trespassing inside the US Capitol that day.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Google Earth focused on the US Capitol building, with only
    the insurrection videos showing.](Images/Figure11-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: Google Earth,
    focused on the US Capitol building, with pins at the GPS points in</samp> <samp
    class="SANS_Futura_Std_Book_11">parler-videos-january6.kml</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When you find a video you’re interested in, click its pin to view its description.
    You should see the URL to download the video, and you can watch it using software
    like VLC Media Player.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use Google Earth to search for a location so you can see the individual
    pins there. For example, you could hide the Parler Videos from January 6, 2021,
    project and instead show pins for the All Parler Videos project, then search for
    *Moscow*. [Figure 11-7](#fig11-7) shows Google Earth zoomed in on the city of
    Moscow, Russia. As the figure indicates, only a handful of videos whose metadata
    included GPS coordinates were filmed there and uploaded to Parler.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Google Earth, zoomed into Moscow, with five pins.](Images/Figure11-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: Parler videos
    filmed in Moscow</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the pin for the video labeled *ykAXApWbiZuM*. You should see the following
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this video was filmed on June 28, 2020 (during the Black Lives
    Matter uprising), with an iPhone 7 Plus running iOS 13.5.1\. Right-click the link
    to see the option to download the video. This way, your web browser won’t try
    opening it directly in a new tab, where it might not display properly.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested, you can open the video file using VLC Media Player to
    watch it. In the recording, a tattooed American white supremacist who runs a Confederate-themed
    barber shop in Moscow goes on a racist and homophobic rant, in part explaining
    why he moved to Russia. “I voted Trump in office in 2016,” he said. “But the fact
    is, nothing’s gonna change. The fact is, all these Trump supporters in America
    all the time can’t see the real problem. Your real problem is fucking Jews in
    America.” [Figure 11-8](#fig11-8) shows a screenshot from the video where he’s
    telling Parler users that he’s a real white supremacist and not a liberal troll,
    as people were accusing him of being.
  prefs: []
  type: TYPE_NORMAL
- en: '![A still from the Parler video of the American white supremacist in Moscow,
    in VLC Media Player.](Images/Figure11-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-8: A screenshot from
    a Parler video filmed by an American white supremacist in Moscow</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: He goes on to fantasize about mass shooting Black Lives Matter protesters. “I
    watch the news in America. I see all these fucking [N-word]s, antifa fucking scum.
    Ripping down the monuments. It angers me more than anything. What I don’t understand
    is where’s the fucking police to stop any of this?” he asks. “How come nobody’s
    shooting these motherfuckers? If I was in Los Angeles still, seeing all this rioting
    and looting going on, I’d be up on a motherfucking building with my AK-47 just
    spraying the fucking crowd.”
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious about the complete metadata from this video, you can check
    the original file at *meta-ykAXApWbiZuM.json*. If you wanted to see more videos
    posted by this Parler user, you could modify your script to filter videos that
    were filmed on the exact device by checking for the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Make</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Model</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Software</samp>
    fields. You might find some other users’ videos, but chances are you’ll also find
    more videos from this poster as well.
  prefs: []
  type: TYPE_NORMAL
- en: The media spent the bulk of its time focusing on Parler videos they knew were
    taken in Washington, DC, on the day of the insurrection. If you’re interested
    in further exploring this dataset, you might try to find videos from other far-right
    protests, or events with far-right counterprotesters. For example, you could create
    a KML file that includes the date ranges of the specific 2020 Black Lives Matters
    protests and explore those videos. You might find video evidence of other crimes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Viewing Metadata with ExifTool</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When @donk_enby downloaded the Parler videos and extracted metadata from them
    in JSON format, she used a command line program called <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>.
    This program is one of the investigation tools I use most frequently, and this
    section explains how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> followed
    by a filepath, it will attempt to find metadata stored in that file and show it
    to you. It works on a variety of file formats, including Microsoft Office documents,
    PDFs, images, and videos. You can use it to find hidden information in the metadata
    of those documents, such as the author of a Word document, which type of phone
    or camera was used to take a photo, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    on the Parler videos since @donk_enby did it for you, but most of the time, you
    won’t be so lucky. If you want to search for hidden information in BlueLeaks documents,
    for example, you’d need to run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    on them yourself. In this subsection, to learn how <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    works, you’ll use it to view the metadata on one of the Parler videos in JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mac users, install <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install exiftool</samp>
    command; users of Linux or Windows with WSL, install it with the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo
    apt install libimage-exiftool-perl</samp> command. In your terminal, change to
    the *videos* folder in your Parler dataset folder and use <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp>
    to download the Parler video with the ID *HS34fpbzqg2b*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> to
    look at the metadata of a file by running <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename</samp>. Run it
    on the *HS34fpbzqg2b* file that you just downloaded with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should show all the metadata for this video file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Along with other information, the metadata shows that this video’s file extension
    is *.mov*, it was recorded using an iPhone XR running iOS 14.2 on January 6, 2021,
    at 1:57 PM, and it was filmed at the GPS coordinates 38 deg 53′ 26.52″ N, 77 deg
    0′ 28.44″ W.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the file extension for this video is *.mov*, rename it by running <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">mv HS34fpbzqg2b HS34fpbzqg2b.mov</samp>.
    You can open *HS34fpbzqg2b.mov* in a program like VLC Media Player just to see
    what it contains: police officers stepping out of the way while Trump supporters
    remove barricades surrounding the Capitol building.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When @donk_enby used <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    to extract the metadata from the Parler videos, she used the <samp class="SANS_TheSansMonoCd_W5Regular_11">-json</samp>
    argument to extract it in JSON format. Here’s how you do that for *HS34fpbzqg2b*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-json</samp> argument makes
    the output much easier to work with than <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>’s
    default output.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned about the secrets hidden in the metadata of
    over a million videos uploaded to Parler, many of them by insurrectionists filming
    themselves during the January 6 riot in Washington, DC. You’ve learned the syntax
    of the JSON file format and how to work with JSON data in your own Python scripts.
    You’ve written a series of scripts that filtered the list of a million videos
    down to just the ones that were, according to their metadata, filmed on January
    6, 2021, in Washington, DC, during the attack on the US Capitol by supporters
    of Donald Trump. You now have the skills necessary to write code that analyzes
    JSON in your own investigations. Finally, you’ve seen how you can convert GPS
    coordinates from degrees to decimal and plot them on a map, an invaluable skill
    for future investigations that involve location data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll explore one more technology that’s common in hacked
    and leaked datasets: SQL databases. You’ll use the SQL skills you learn to dig
    into the hacked databases of Epik, a hosting and domain name company that provides
    service to much of the American fascist movement.'
  prefs: []
  type: TYPE_NORMAL
