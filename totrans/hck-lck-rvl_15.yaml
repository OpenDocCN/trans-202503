- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PARLER,
    THE JANUARY 6 INSURRECTION, AND THE JSON FILE FORMAT</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PARLER、1月6日的叛乱与JSON文件格式</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: On the morning of January 6, 2021, two months after Donald Trump lost the 2020
    election to Joe Biden by about 6 million votes, thousands of Trump’s supporters
    prepared to storm the US Capitol in Washington, DC, hoping to subvert democracy.
    “We will never give up. We will never concede,” Trump told the crowd from the
    National Mall, just south of the White House. “We fight like hell, and if you
    don’t fight like hell, you’re not going to have a country anymore.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年1月6日清晨，在唐纳德·特朗普以约600万票的差距输给乔·拜登后两个月，成千上万的特朗普支持者准备冲进位于华盛顿特区的美国国会大厦，企图颠覆民主。“我们永不放弃，我们永不让步，”特朗普在白宫南边的国家广场对人群说道。“我们拼尽全力，如果你不拼命，你就不再有这个国家了。”
- en: Smartphones in hand, the pro-Trump, anti-democracy activists recorded the entire
    event. They posted their photos and videos online, many to the far-right social
    media site Parler. In this chapter, you’ll learn to work with the massive trove
    of video evidence collected from that day’s insurrection in a popular file format
    called JavaScript Object Notation (JSON). You’ll learn how JSON data is structured
    and write Python code to scour a million JSON files full of Parler video metadata
    to find specific videos. You’ll also learn about working with Global Positioning
    System (GPS) coordinates, including how to plot points on a map, since many of
    the videos include GPS coordinates in their metadata. All of these skills could
    serve you well in your future investigations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 手持智能手机，亲特朗普的反民主活动分子记录下了整个事件。他们将照片和视频发布到网上，许多上传至极右翼社交媒体网站Parler。在本章中，你将学习如何使用从当天的叛乱中收集到的大量视频证据，这些证据采用了一种流行的文件格式——JavaScript对象表示法（JSON）。你将学习JSON数据的结构，并编写Python代码，通过解析一百万个包含Parler视频元数据的JSON文件来查找特定的视频。你还将学习如何处理全球定位系统（GPS）坐标，包括如何在地图上标出点，因为许多视频的元数据中包含了GPS坐标。所有这些技能都将在你未来的调查中大有帮助。
- en: Let’s start with a brief history of how the Parler dataset became available
    to the public.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Parler数据集公开的简短历史开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Origins of the Parler Dataset</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Parler数据集的起源</samp>
- en: The protesters at the US Capitol insurrection filmed themselves marching with
    Don’t Tread on Me, Fuck Biden, and Trump flags; tearing down fences; fighting
    with riot cops; smoking weed; smashing windows and then storming the Capitol building
    through them; throwing chairs at police; and threatening the lives of members
    of Congress and Vice President Mike Pence. They uploaded these videos to Parler
    in real time as they filmed them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国国会骚乱中的抗议者拍摄了他们手持“不踩我”、“去你妈的拜登”和特朗普旗帜游行的过程；拆除栅栏；与防暴警察对抗；吸食大麻；砸窗户然后通过窗户冲进国会大厦；向警察投掷椅子；并威胁国会议员和副总统迈克·彭斯的生命。他们在拍摄过程中将这些视频实时上传至Parler。
- en: 'During the attack on the Capitol, pro-Trump rioters attacked police officers
    with baseball bats, flag poles, and pipes, injuring at least 138 of them. One
    officer, Brian Sicknick, was hospitalized and died the next day. In the weeks
    and months following the attack, four more officers who responded that day died
    by suicide. A Capitol Police officer shot and killed Ashli Babbitt, a rioter who
    attempted to breach the doors to the US Senate chamber where senators were sheltering.
    Three more Trump supporters died during the riot: one from being crushed to death
    in the crowd, one from a stroke, and one from a heart attack.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在袭击国会期间，亲特朗普的暴徒用棒球棍、旗杆和管道袭击警察，至少造成138名警察受伤。一名警察布赖恩·西克尼克被送医，次日死亡。在袭击后的几周和几个月内，四名当天参与应对的警察自杀身亡。一名国会警察开枪打死了艾什莉·巴比特，一名试图闯入美国参议院议场的暴徒，参议员们在那儿避难。还有三名特朗普支持者在骚乱中死亡：一人被人群压死，一人死于中风，一人死于心脏病发作。
- en: Days after the attack, citing Parler’s unwillingness to moderate content that
    encourages and incites violence, Apple and Google banned the Parler app from their
    app stores. Amazon Web Services (AWS), the major cloud hosting service that Parler
    had relied on, kicked the company off its service. It took Parler a month and
    a half to bring its site back up. Before it went down, though, a quick-thinking
    archivist downloaded over a million videos from the site. In this section, I’ll
    describe how she downloaded the videos and how they were used in Trump’s second
    impeachment trial.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 袭击发生后的几天，因Parler拒绝对鼓励和煽动暴力的内容进行审核，Apple和Google将Parler应用从他们的应用商店中下架。亚马逊Web服务（AWS），Parler依赖的主要云托管服务，将该公司从其服务中踢出。Parler花了一个半月才将网站恢复上线。不过，在网站关闭之前，一位反应迅速的档案工作者下载了超过一百万个视频。在这一节中，我将描述她是如何下载这些视频的，以及它们是如何在特朗普第二次弹劾审判中被使用的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How the Parler Videos
    Were Archived</samp>
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parler视频是如何被归档的</samp>
- en: On the Saturday after the January 6 attack, John Paczkowski and Ryan Mac published
    an email in BuzzFeed News from the Amazon AWS Trust & Safety Team to Parler. Amazon
    informed Parler that it “cannot provide services to a customer that is unable
    to effectively identify and remove content that encourages or incites violence
    against others,” and that “we plan to suspend Parler’s account effective Sunday,
    January 10th.” Less than 48 hours before Parler went dark, a hacker named @donk_enby,
    with the help of other archivists, raced to download a copy of all of the videos
    and images uploaded to the social network.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在1月6日袭击后的那个星期六，John Paczkowski和Ryan Mac在BuzzFeed News发布了一封来自Amazon AWS信任与安全团队发送给Parler的电子邮件。亚马逊通知Parler，“不能为无法有效识别和删除鼓励或煽动对他人暴力的内容的客户提供服务”，并且“我们计划从1月10日（星期日）起暂停Parler的账户。”
    在Parler关闭前不到48小时，一位名为@donk_enby的黑客在其他档案工作者的帮助下，迅速下载了社交网络上所有上传的视频和图像的副本。
- en: Parler, it turns out, lacked security measures that prevent automatic scraping
    of the site’s data. *Web scraping* is a method of automated data collection where
    you use code to load web pages, rather than manually loading them in a browser,
    and extract their data. This chapter won’t cover how to scrape the web like @donk_enby
    did, but if you’re curious, you can learn how in Appendix B.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Parler缺乏防止自动抓取网站数据的安全措施。*网页抓取*是一种自动化数据收集方法，你可以使用代码加载网页，而不是在浏览器中手动加载它们，并提取其数据。本章不会介绍如何像@donk_enby那样抓取网页，但如果你感兴趣，可以在附录B中学习如何操作。
- en: Parler’s website didn’t have any *rate limiting*, a security feature that prevents
    users from accessing the site too frequently, so nothing stopped a single computer
    from making millions of web requests. The URLs of Parler posts appeared to have
    random IDs, but @donk_enby discovered that they also had hidden incremental IDs
    (1, 2, 3, and so on), so a script could easily loop through every ID, make a web
    request to download every post, and then find the URLs for every video and image
    to download. While Parler did strip metadata from videos uploaded by its users,
    they also left original copies of videos that contained this metadata at predictable
    URLs. @donk_enby downloaded versions of the videos that contained a wealth of
    hidden information, including, in many cases, the GPS coordinates of where the
    video was filmed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Parler的网站没有任何*速率限制*，这是一种防止用户频繁访问网站的安全功能，因此没有任何东西能阻止单台计算机发出数百万个网页请求。Parler帖子的网址似乎具有随机ID，但@donk_enby发现它们实际上也有隐藏的递增ID（1,
    2, 3，依此类推），因此脚本可以轻松地循环遍历每个ID，发出网页请求以下载每个帖子，然后找到每个视频和图像的网址进行下载。尽管Parler从用户上传的视频中剥离了元数据，但它们仍然保留了包含这些元数据的原始视频副本，并且这些视频在可预测的网址上可用。@donk_enby下载了包含大量隐藏信息的视频版本，其中许多视频的GPS坐标表明视频的拍摄地点。
- en: When @donk_enby archived this data, she saved it to an AWS S3 bucket, an AWS
    service for hosting files that never runs out of disk space. (It’s ironic that,
    in response to AWS kicking Parler off its service, she saved copies of the videos
    to a different part of AWS.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当@donk_enby将这些数据归档时，她将其保存到了AWS S3存储桶中，这是AWS用于托管文件的服务，具有无限的磁盘空间。（讽刺的是，作为回应AWS将Parler从其服务中踢出，她将这些视频的副本保存到了AWS的另一部分。）
- en: Because there’s no widely agreed-upon definition of hacking, whether or not
    Parler was “hacked” is a matter of perspective. Technically, @donk_enby scraped
    public content from a public website, which isn’t illegal and doesn’t require
    bypassing security—had Parler even had any that would have prevented this. The
    same thing is often true of illegal hacking, though; people break into systems
    that are barely protected or accidentally left open to the public.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对黑客行为的定义没有广泛共识，Parler 是否被“黑客攻击”是一个视角问题。从技术角度来看，@donk_enby 从一个公开网站抓取了公开内容，这本身并不违法，也不需要绕过任何安全措施——即使
    Parler 有这样的措施，也未必能阻止这种行为。非法黑客行为通常也是如此；人们进入的是那些几乎没有保护，或者偶然向公众开放的系统。
- en: By Sunday night, @donk_enby had managed to archive at least 32TB of videos.
    “I hope that it can be used to hold people accountable and to prevent more death,”
    she told *Vice*. She worked with DDoSecrets to make a copy of the data available
    to the public—the copy you’ll work with in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到周日晚，@donk_enby 已成功存档了至少 32TB 的视频。“我希望这些能用来追究责任，防止更多人死亡，”她在接受 *Vice* 采访时表示。她与
    DDoSecrets 合作，将该数据的副本提供给公众——你将在本章中使用的正是这个副本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Dataset’s Impact
    on Trump’s Second Impeachment</samp>
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数据集对特朗普第二次弹劾的影响</samp>
- en: On January 13, a week after the deadly riot at the Capitol and a week before
    Joe Biden’s inauguration as the new president, the US House of Representatives
    impeached Trump for “incitement of insurrection,” making Trump the first president
    in US history to be impeached twice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 1 月 13 日，在国会大厦致命骚乱一周后、乔·拜登成为新总统前一周，美国众议院以“煽动叛乱”指控弹劾特朗普，这使特朗普成为美国历史上第二次被弹劾的总统。
- en: During the impeachment trial in the US Senate, which took place in February
    at the beginning of Biden’s administration, the impeachment managers showed many
    videos of violent Trump supporters that @donk_enby had archived from Parler as
    evidence to support their case. “I had an efficient way to download it all. I
    knew what was there, but it seemed that nobody else could see the value,” she
    told CNN at the time. “I hope it inspires more people with similar skills to mine
    to use those skills for good.”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国参议院的弹劾审判中，发生在拜登政府初期的 2 月，弹劾经理展示了大量特朗普支持者暴力行为的视频，这些视频是@donk_enby 从 Parler
    网站上存档的，用作支持弹劾案的证据。“我有一种高效的方法来下载所有视频。我知道里面有什么，但似乎没有其他人能看到这些视频的价值，”她当时在接受 CNN 采访时说道。“我希望能激励更多拥有类似技能的人将这些技能用来做好事。”
- en: Ultimately, 57 percent of the Senate, including seven members of the Republican
    Party, found Trump guilty, while 43 percent—all of whom were Republicans—found
    him not guilty. The US Constitution requires a two-thirds majority of the Senate
    to convict, so Trump was acquitted. However, over 1,000 people were charged in
    connection to the January 6 insurrection. Two members of the far-right Oath Keepers
    militia, including its leader, Stewart Rhodes, and four members of the Proud Boys
    hate group, including its former leader, Enrique Tarrio, were convicted of seditious
    conspiracy. Several other members of these groups were also convicted of lesser
    crimes. Rhodes was sentenced to 18 years in prison in May 2023, and Tarrio was
    sentenced to 22 years in prison in September 2023.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，57% 的参议员，包括七名共和党成员，裁定特朗普有罪，而 43% 的参议员——全部为共和党人——认为他无罪。美国宪法要求参议院必须以三分之二多数定罪，因此特朗普被宣告无罪。然而，超过
    1,000 人因参与 1 月 6 日的叛乱而被起诉。两名极右翼誓言守卫组织（Oath Keepers）的成员，包括其领袖斯图尔特·罗兹，以及四名自豪男孩（Proud
    Boys）仇恨团体的成员，包括前领袖恩里克·塔里奥，被判定犯有煽动叛乱罪。该组织的其他几名成员也因较轻的罪行被判刑。罗兹于 2023 年 5 月被判处 18
    年监禁，塔里奥则在 2023 年 9 月被判处 22 年监禁。
- en: Further investigating this dataset is obviously in the public interest. Let’s
    get started in Exercise 11-1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步研究这个数据集显然符合公众利益。让我们在练习 11-1 中开始吧。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-1: Download and Extract
    Parler Video Metadata</samp>'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 11-1：下载并提取 Parler 视频元数据</samp>
- en: The Parler data is so large that it’s not practical, for the purposes of this
    chapter, to download it all. Instead, you’ll start with just the video metadata
    DDoSecrets has made available separately. The metadata contains useful information
    about each video, like its file format, when it was filmed, what type of phone
    or camera was used to film it, and in some cases the GPS coordinates describing
    where it was filmed. In this exercise, you’ll learn how to use the metadata to
    select and download individual videos to view.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Parler数据集非常庞大，为了本章的目的，下载全部数据并不实际。相反，您将首先仅下载DDoSecrets单独提供的视屏元数据。元数据包含关于每个视频的有用信息，比如文件格式、拍摄时间、使用的手机或相机类型，以及在某些情况下，描述拍摄地点的GPS坐标。在本练习中，您将学习如何使用这些元数据选择并下载单个视频进行观看。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you’re using Windows, I recommend that you follow along with this chapter
    using your Ubuntu terminal instead of PowerShell and that you save this data in
    your WSL Linux filesystem (for example, in* ~/datasets*), instead of in your Windows-formatted
    USB disk (*/mnt/c *or* /mnt/d*). Because of disk performance issues with WSL,
    I found that working with this data in Linux rather than directly in Windows was
    significantly faster. If you’ve only used Python in Windows so far, install Python
    in Ubuntu with the command* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">sudo
    apt install python3 python3-pip</samp>*, then install the click Python module
    by running* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">python3 -m pip
    install click</samp>*. You’ll need the click module for the exercises in this
    chapter. Refer to [Appendix A](appendixA.xhtml) to learn more about solving performance
    issues in WSL if you run into any problems.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您使用的是Windows，我建议您使用Ubuntu终端而不是PowerShell来跟随本章内容，并将数据保存在您的WSL Linux文件系统中（例如，在*
    ~/datasets*），而不是保存在Windows格式的USB磁盘（*/mnt/c* 或 */mnt/d*）中。由于WSL的磁盘性能问题，我发现直接在Linux中处理这些数据比在Windows中更快。如果您只在Windows中使用过Python，请使用命令*
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">sudo apt install python3
    python3-pip</samp>* 在Ubuntu中安装Python，然后运行* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">python3
    -m pip install click</samp>* 安装click Python模块。您将在本章的练习中需要使用click模块。如果遇到任何问题，请参考[附录A](appendixA.xhtml)了解更多关于解决WSL性能问题的内容。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Download the Metadata</samp>
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">下载元数据</samp>
- en: Since the Parler dataset takes up so much disk space, DDoSecrets couldn’t publish
    it using BitTorrent like it does with most of its other public releases. To seed
    that torrent, you would need a single server with 32TB of data, and no one would
    be able to connect to the swarm to download it because no one has 32TB of disk
    space lying around. Instead, DDoSecrets hosts the Parler data on its public data
    web server*.* If you know the filename of a Parler video, you can download it
    from *https://<wbr>data<wbr>.ddosecrets<wbr>.com<wbr>/Parler<wbr>/Videos<wbr>/<filename>*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Parler数据集占用了大量磁盘空间，DDoSecrets无法像发布大多数其他公开发布的内容那样使用BitTorrent发布它。要做种这个torrent，您需要一个拥有32TB数据的单个服务器，而没有人能够连接到种子网络下载数据，因为没有人会拥有32TB的磁盘空间。因此，DDoSecrets将Parler数据托管在其公共数据Web服务器上。如果您知道一个Parler视频的文件名，您可以从*https://<wbr>data<wbr>.ddosecrets<wbr>.com<wbr>/Parler<wbr>/Videos<wbr>/<filename>*下载它。
- en: You can also download a full list of filenames, *ddosecrets-parler-listing.txt.gz*,
    and metadata for all of the video files, *metadata.tar.gz*. Files ending in *.gz*
    are compressed using a format called GZIP, so you can tell from the filename that
    *ddosecrets-parler-listing.txt.gz* is a compressed text file. Files ending in
    *.tar*, called *tarballs*, also combine multiple files and folders together into
    a single file. Tar files aren’t compressed, though—they take up as much disk space
    as all of the files they contain—so it’s common to compress them with GZIP, resulting
    in *.tar.gz* files. The *metadata.tar.gz* file is a GZIP-compressed tarball.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以下载完整的文件名列表，*ddosecrets-parler-listing.txt.gz*，以及所有视频文件的元数据，*metadata.tar.gz*。以*.gz*结尾的文件是使用名为GZIP的格式进行压缩的，因此您可以从文件名看出*ddosecrets-parler-listing.txt.gz*是一个压缩的文本文件。以*.tar*结尾的文件，称为*tarball*，也将多个文件和文件夹合并成一个文件。但tar文件本身并没有压缩，它们占用的磁盘空间与其中包含的所有文件一样——因此通常会使用GZIP进行压缩，生成*.tar.gz*文件。*metadata.tar.gz*文件是一个经过GZIP压缩的tarball。
- en: Start by downloading *ddosecrets-parler-listing.txt.gz* and *metadata.tar.gz*
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> command. This
    command is similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>,
    but it downloads a file and saves it to disk by default instead of displaying
    it in your terminal. Check if you already have <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp>
    installed by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">which wget</samp>.
    If you don’t, install it on macOS with <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew
    install wget</samp>, or on Linux or Windows with WSL with <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo
    apt install wget</samp>.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从下载*ddosecrets-parler-listing.txt.gz*和*metadata.tar.gz*开始，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp>
    命令。这个命令类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>，但它默认将文件下载并保存到磁盘，而不是显示在终端中。通过运行
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">which wget</samp> 检查你是否已安装 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">wget</samp>。如果没有，请在macOS上运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew
    install wget</samp>，或者在Linux或WSL的Windows上运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo
    apt install wget</samp>。
- en: 'Open a terminal. Create a new folder for the Parler data you’ll download, and
    change to that folder. (If you’re using Windows with WSL, make sure you create
    it in your WSL Linux filesystem, such as at *~/datasets/Parler*.) For example,
    here’s how I did it on my Mac, creating the folder on my *datasets* USB disk:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端。为你将下载的Parler数据创建一个新文件夹，并切换到该文件夹。（如果你使用的是带WSL的Windows，请确保在WSL Linux文件系统中创建它，例如在*~/datasets/Parler*中。）例如，这是我在Mac上创建文件夹的方法，将其创建在我的*datasets*
    USB磁盘上：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now use <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> to download
    the list of filenames by running the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> 通过运行以下命令下载文件名列表：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output should show that you’ve downloaded the 17MB *ddosecrets -parler-listing.txt.gz*
    file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> program shows
    you a progress bar of your download in your terminal.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应显示你已下载17MB的*ddosecrets-parler-listing.txt.gz*文件。<samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp>程序会在你的终端显示下载进度条。
- en: 'Next, download the video metadata by running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令下载视频元数据：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check to make sure you’ve successfully downloaded the files by running <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">ls -lh</samp>. You should get the following
    output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls -lh</samp>，检查是否已成功下载文件。你应该看到以下输出：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The file containing the list of filenames should be 17MB, and the metadata file
    should be 203MB.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件名列表的文件应为17MB，元数据文件应为203MB。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uncompress and Download
    Individual Parler Videos</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解压并下载单个Parler视频</samp>
- en: 'To uncompress GZIP files, you’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    command with the following syntax: <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.gz</samp>. Running
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> on a gzipped file
    deletes the original file and leaves you with the uncompressed version without
    the *.gz* file extension.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压GZIP文件，你需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    命令，语法如下： <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.gz</samp>。对gzipped文件运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> 会删除原文件，并留下不带*.gz*扩展名的解压版本。
- en: 'Uncompress the *ddosecrets-parler-listing.txt.gz* file by running the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令解压*ddosecrets-parler-listing.txt.gz*文件：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your original 17MB file, *ddosecrets-parler-listing.txt.gz*, should be replaced
    with a 43MB text file called *ddosecrets-parler-listing.txt*, which contains over
    one million lines, one for each video that @donk_enby archived.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你的原始17MB文件*ddosecrets-parler-listing.txt.gz*应被替换为一个43MB的文本文件*ddosecrets-parler-listing.txt*，该文件包含超过一百万行，每一行代表@donk_enby归档的一个视频。
- en: 'To make sure it worked, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls
    -lh</samp> again. Your output should look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保其正常工作，请再次运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls -lh</samp>。你的输出应类似于以下内容：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Count the number of files in *ddosecrets-parler-listing.txt* with the following
    command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令计算*ddosecrets-parler-listing.txt*中的文件数量：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you learned in [Chapter 4](chapter4.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    command displays the content of a file, and piping that command’s output into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp> counts the number of
    lines in that file. The output should be <samp class="SANS_TheSansMonoCd_W5Regular_11">1031509</samp>,
    meaning there are 1,031,509 lines in *ddosecrets-parler-listing.txt*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第4章](chapter4.xhtml)中学到的，<samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>命令显示文件的内容，将该命令的输出通过管道传输到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp>可以计算文件中的行数。输出应为<samp class="SANS_TheSansMonoCd_W5Regular_11">1031509</samp>，这意味着*ddosecrets-parler-listing.txt*文件有1,031,509行。
- en: 'If you load the file in a text editor, it should look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在文本编辑器中打开该文件，它应该是这样的：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first and second columns of text show the date and time that @donk_enby
    first uploaded each file to the S3 bucket, just after scraping it. The third column
    is the size of the file, in bytes, and the final column is the filename. All of
    the video files in the Parler dataset have similar random-looking names. These
    are the original IDs that Parler used for each video, and they don’t have file
    extensions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列和第二列文本显示了@donk_enby第一次将每个文件上传到S3存储桶的日期和时间，上传操作发生在抓取之后。第三列是文件的大小，单位为字节，最后一列是文件名。Parler数据集中的所有视频文件都有类似的随机名称。这些是Parler为每个视频使用的原始ID，并且它们没有文件扩展名。
- en: 'Now that you know the filenames of each Parler video, you can download individual
    files from *https://<wbr>data<wbr>.ddosecrets<wbr>.com<wbr>/Parler<wbr>/Videos<wbr>/<filename>*.
    Let’s try downloading one of the first videos listed in *ddosecrets-parler-listing
    .txt*. First, use the following commands to create a *videos* folder and switch
    to that folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了每个Parler视频的文件名，你可以从*https://<wbr>data<wbr>.ddosecrets<wbr>.com<wbr>/Parler<wbr>/Videos<wbr>/<filename>*下载单个文件。让我们试着下载*ddosecrets-parler-listing.txt*中列出的第一个视频。首先，使用以下命令创建一个*videos*文件夹并切换到该文件夹：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, run the following command to download the Parler file *0003lx5cSwSB*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令来下载Parler文件*0003lx5cSwSB*：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can normally tell the format of a file based on its file extension, but
    since these Parler video filenames don’t have extensions, use the following <samp
    class="SANS_TheSansMonoCd_W5Regular_11">file</samp> command to determine the format
    of *0003lx5cSwSB*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以根据文件扩展名来判断文件格式，但由于这些Parler视频文件没有扩展名，可以使用以下<samp class="SANS_TheSansMonoCd_W5Regular_11">file</samp>命令来确定*0003lx5cSwSB*的格式：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output, <samp class="SANS_TheSansMonoCd_W5Regular_11">0003lx5cSwSB: ISO
    Media, MP4 v2 [ISO 14496-14]</samp>, shows that the file is an MP4 video. To make
    it easier to open in video-playing software, you’ll need to add the *.mp4* extension
    to the filename. You can rename files using the command <samp class="SANS_TheSansMonoCd_W5Regular_11">mv</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source_path dest_path</samp>,
    which moves a file from a source path to a destination path. To rename *0003lx5cSwSB*
    to *0003lx5cSwSB.mp4*, run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '输出内容<samp class="SANS_TheSansMonoCd_W5Regular_11">0003lx5cSwSB: ISO Media,
    MP4 v2 [ISO 14496-14]</samp>表明该文件是一个MP4视频。为了方便在视频播放软件中打开，你需要在文件名后添加*.mp4*扩展名。你可以使用命令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mv</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source_path
    dest_path</samp>来重命名文件，它会将文件从源路径移动到目标路径。要将*0003lx5cSwSB*重命名为*0003lx5cSwSB.mp4*，可以运行以下命令：'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now watch *0003lx5cSwSB.mp4* in software like VLC Media Player. [Figure
    11-1](#fig11-1) shows a screenshot from this video, which features Trump battling
    the “fake news” media and calls him the “Savior of the Universe.”
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在如VLC Media Player等软件中观看*0003lx5cSwSB.mp4*。图[Figure 11-1](#fig11-1)显示了该视频的一张截图，视频内容展示了特朗普与“假新闻”媒体作斗争，并称他为“宇宙的救世主”。
- en: '![A screenshot from a pro-Trump video in which an image-edited Trump rides
    a motorcycle. The caption says “Trump A-Ah.”](Images/Figure11-1.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![一张来自亲特朗普视频的截图，图中经过编辑的特朗普骑着摩托车。标题写着“特朗普 A-Ah。”](Images/Figure11-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A screenshot from
    a pro-Trump Parler video showing an altered image of Trump riding a motorcycle</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-1：一张亲特朗普Parler视频的截图，显示了一张编辑过的特朗普骑摩托车的图像</samp>
- en: In your terminal, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cd ..</samp>
    to change out of the *videos* folder you just created and back to the Parler dataset
    folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，运行<samp class="SANS_TheSansMonoCd_W7Bold_B_11">cd ..</samp>命令，退出刚才创建的*videos*文件夹，返回到Parler数据集文件夹。
- en: There are over a million videos in this dataset, and most likely, only a small
    fraction contain anything newsworthy. If you randomly pick individual videos to
    download and watch, chances are you’ll be wasting a lot of time. To more efficiently
    find interesting videos, let’s take a closer look at the metadata.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集包含超过一百万个视频，其中大多数可能都没有新闻价值。如果你随机选择单个视频进行下载和观看，很可能会浪费很多时间。为了更高效地找到有趣的视频，让我们仔细看看元数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extract Parler Metadata</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">提取 Parler 元数据</samp>
- en: 'To view the Parler metadata, you’ll need to extract the *metadata.tar.gz* tarball.
    In your terminal, uncompress and extract *metadata.tar.gz* using the <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Parler 的元数据，你需要解压 *metadata.tar.gz* tarball 文件。在你的终端中，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    命令解压并提取 *metadata.tar.gz* 文件：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because it’s so common to gzip tar archives, the <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    command will automatically detect if it’s gzipped and uncompress it for you, so
    you don’t need to manually do the <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    step yourself. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">-xvf</samp>
    argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> tells <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    to extract the files from *metadata.tar*, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    (meaning verbose) tells <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    to display each filename it extracts in the terminal, and <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    means that the next argument is a filename for the tarball on which this command
    will run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 gzip 压缩 tar 归档文件非常常见，<samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    命令会自动检测文件是否已被 gzip 压缩，并为你解压缩，所以你无需手动执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp>
    步骤。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">-xvf</samp> 参数中，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    告诉 <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp> 从 *metadata.tar* 中提取文件，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">v</samp>（表示详细模式）告诉 <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp>
    在终端显示每个提取的文件名，<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 表示下一个参数是
    tarball 文件名，该命令将在其上运行。
- en: 'Your output should look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该如下所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command might take 10 minutes or so to extract the over one million JSON
    files in *metadata.tar.gz* into a new folder called *metadata*, depending on the
    speed of your hard disk. (If you’re using Windows with WSL and this step is going
    very slowly, consult Appendix A for performance tips.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据硬盘的速度，这个命令可能需要大约 10 分钟时间，将 *metadata.tar.gz* 中超过一百万个 JSON 文件解压到一个名为 *metadata*
    的新文件夹中。（如果你在使用 WSL 的 Windows 系统，而且这个步骤非常缓慢，请查阅附录 A 获取性能优化建议。）
- en: Feel free to run <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> on
    the *metadata* folder or view it in a file browser, but beware that there are
    so many files that those simple tasks will take a long time (it took over five
    minutes for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> command
    to finish running on my computer). [Figure 11-2](#fig11-2) shows the files in
    the *metadata* folder in Finder on macOS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时在 *metadata* 文件夹中运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>
    命令，或者在文件浏览器中查看，但要注意，由于文件数量太多，这些简单操作可能会花费很长时间（在我的计算机上，运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>
    命令花费了五分钟以上的时间）。[图 11-2](#fig11-2) 显示了在 macOS 中的 Finder 中查看 *metadata* 文件夹的文件。
- en: The files in this folder are all named *meta-*<*ID*>*.json*, where *ID* is the
    original video ID from Parler. For example, you can find the metadata for the
    file *0003lx5cSwSB*, the video you downloaded in the previous section, at *metadata/meta-0003lx5cSwSB.json*.
    All of these metadata files are in the JSON file format, so let’s take a closer
    look at that now.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹中的文件名都以 *meta-*<*ID*>*.json* 命名，其中 *ID* 是 Parler 中的原始视频 ID。例如，你可以在 *metadata/meta-0003lx5cSwSB.json*
    中找到之前章节中下载的视频 *0003lx5cSwSB* 的元数据。所有这些元数据文件都是 JSON 文件格式，因此现在让我们仔细了解一下这个格式。
- en: '![A Finder window, showing some of the JSON files in the metadata folder.](Images/Figure11-2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Finder 窗口，显示 metadata 文件夹中的一些 JSON 文件。](Images/Figure11-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: Some of the extracted
    Parler metadata files</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-2：一些提取的 Parler 元数据文件</samp>
- en: <samp class="SANS_Futura_Std_Bold_B_11">The JSON File Format</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">JSON 文件格式</samp>
- en: JSON is a format used to store information in text strings. One of its main
    benefits is that it’s human-readable. Some file formats are designed for computers
    rather than humans to understand. If you run <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    on a PDF file, for example, you’ll see random-looking output in your terminal.
    You need to open the PDF in a program like Adobe Reader to understand the information
    it contains. However, humans can easily read the JSON text format just by viewing
    it in a text editor or by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种用于存储信息的文本字符串格式。它的主要优点之一是易于人类阅读。有些文件格式是为了计算机而设计的，而不是让人类理解。例如，如果你在 PDF
    文件上运行 `<samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>` 命令，你会在终端看到看似随机的输出。你需要使用像
    Adobe Reader 这样的程序打开 PDF 文件，才能理解其中的内容。然而，人类只需在文本编辑器中查看 JSON 文本格式，或使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>`
    命令，就能轻松阅读 JSON 数据。
- en: JSON is one of the most widely used data formats, and the one most APIs communicate
    with. Whenever you visit a website that does anything interactive, chances are
    your web browser and the website’s server are passing JSON data back and forth.
    This is one reason why hacked data, as well as data scraped from APIs, is often
    full of JSON files. Most of the data from the America’s Frontline Doctors dataset,
    covered in detail in [Chapter 13](chapter13.xhtml), is in JSON format, as is much
    of the data hacked from Gab, the right-wing social network discussed in Appendix
    B.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是最广泛使用的数据格式之一，也是大多数 API 通信时使用的格式。每当你访问一个具有互动功能的网站时，很可能你的浏览器和该网站的服务器正在互相传递
    JSON 数据。这也是为什么被黑的数据以及从 API 中抓取的数据通常包含大量 JSON 文件的原因之一。美国前线医生数据集的大部分数据都采用 JSON 格式，详细内容请参见
    [第 13 章](chapter13.xhtml)，此外，Appendix B 中讨论的右翼社交网络 Gab 被黑的数据也大多是 JSON 格式。
- en: In this section, you’ll learn more about JSON syntax and how to load JSON data
    into Python scripts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解更多关于 JSON 语法的信息，并学习如何将 JSON 数据加载到 Python 脚本中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding JSON
    Syntax</samp>
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解 JSON 语法</samp>
- en: 'JSON has JavaScript in its name because it was first derived from that programming
    language, but it’s a *language-independent* data format: you can work with JSON
    data in JavaScript, Python, or any other programming language. Using their own
    JSON libraries, programming languages can convert JSON text strings into structured
    data (such as Python’s dictionaries and lists) and also convert that structured
    data back into JSON text strings that can be loaded by code in any other programming
    language.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 中有 JavaScript 这个名字，因为它最初来源于该编程语言，但它是一个 *与语言无关* 的数据格式：你可以在 JavaScript、Python
    或任何其他编程语言中使用 JSON 数据。通过各自的 JSON 库，编程语言可以将 JSON 文本字符串转换为结构化数据（如 Python 的字典和列表），并且还可以将这些结构化数据转换回
    JSON 文本字符串，供任何其他编程语言的代码加载使用。
- en: 'To get an idea of the structure of a JSON file, run the following command in
    your terminal to display the metadata for the Parler video with the filename *0003lx5cSwSB*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 JSON 文件的结构，可以在终端中运行以下命令，显示文件名为 *0003lx5cSwSB* 的 Parler 视频的元数据：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output should look like [Listing 11-1](#list11-1).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示 [清单 11-1](#list11-1)。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Video metadata
    for the file</samp> <samp class="SANS_Futura_Std_Book_11">0003lx5cSwSB</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-1：文件的高清视频元数据</samp> <samp
    class="SANS_Futura_Std_Book_11">0003lx5cSwSB</samp>
- en: As you can see, <samp class="SANS_TheSansMonoCd_W5Regular_11">FileType</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">MP4</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">2020:10:15 09:35:29</samp>, meaning
    that this video was filmed on October 15, 2020, at 9:35 AM, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Duration</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0:01:59</samp>, or 1 minute and
    59 seconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，<samp class="SANS_TheSansMonoCd_W5Regular_11">FileType</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">MP4</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">2020:10:15
    09:35:29</samp>，这意味着该视频是在 2020 年 10 月 15 日上午 9:35 拍摄的，<samp class="SANS_TheSansMonoCd_W5Regular_11">Duration</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0:01:59</samp>，即 1 分 59 秒。
- en: 'JSON syntax is extremely similar to Python syntax but uses different terminology
    to describe types of information:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 语法与 Python 语法非常相似，但使用不同的术语来描述信息类型：
- en: '**Object**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**'
- en: 'A set of key-value pairs. An object is essentially equivalent to a dictionary
    in Python and even uses the same syntax. In JSON, however, keys *must* be strings.
    Objects are defined between braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}),
    and keys and values are separated with colons—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">{"first_name":
    "Frederick", "last_name": "Douglass"}</samp>. The JSON output for [Listing 11-1](#list11-1)
    also includes a JSON object.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '一组键值对。对象本质上等同于 Python 中的字典，甚至使用相同的语法。然而，在 JSON 中，键*必须*是字符串。对象的定义在花括号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp>和）之间，键和值之间用冒号分隔——例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">{"first_name":
    "Frederick", "last_name": "Douglass"}</samp>。[清单 11-1](#list11-1)中的 JSON 输出也包含一个
    JSON 对象。'
- en: '**Array**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**'
- en: An ordered list of items. An array is essentially equivalent to a list in Python
    and uses the same syntax. Arrays are defined between brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp>and]),
    and items are separated by commas. The JSON output in [Listing 11-1](#list11-1)
    has a few arrays, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">["mp42","mp41","iso4"]</samp>.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有序的项目列表。数组本质上等同于 Python 中的列表，并使用相同的语法。数组定义在方括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp>和）之间，项目之间用逗号分隔。[清单
    11-1](#list11-1)中的 JSON 输出包含了几个数组，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">["mp42","mp41","iso4"]</samp>。
- en: '**Boolean**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔值**'
- en: A value of either <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. These work the
    same as <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    in Python, but they’re lowercase in JSON.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值，可以是 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。这些与
    Python 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    的作用相同，但在 JSON 中它们是小写的。
- en: '**Number**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字**'
- en: Any whole number or number with decimals in it, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">2600</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>. These are similar
    to numbers in Python, though while Python makes a distinction between integers
    (whole numbers) and floating points (numbers with decimals), JSON does not.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 任何整数或带小数的数字，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">2600</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>。这些与 Python 中的数字类似，尽管 Python
    区分整数（整数）和浮点数（带小数的数字），而 JSON 则没有区分。
- en: '**String**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: A sequence of text characters—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"videos
    have metadata?"</samp>. This is exactly the same as a string in Python, except
    that JSON strings *must* be enclosed double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>),
    whereas Python also allows you to use single quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列文本字符——例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">"videos have metadata?"</samp>。这与
    Python 中的字符串完全相同，只不过 JSON 字符串*必须*用双引号（<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>）括起来，而
    Python 也允许使用单引号（<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>）。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">null</samp>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">null</samp>
- en: A keyword representing an empty value. This is very similar to Python’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp> keyword.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代表空值的关键字。这与 Python 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    关键字非常相似。
- en: All JSON data is made up of combinations of these types, so it’s important to
    understand their exact syntax. If you use any invalid syntax, such as surrounding
    a string with single quotes instead of double quotes or using the Boolean <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    the JSON data won’t load properly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 JSON 数据都是由这些类型的组合构成的，因此理解它们的准确语法非常重要。如果使用任何无效的语法，例如将字符串用单引号括起来而不是双引号，或者使用布尔值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，则
    JSON 数据无法正确加载。
- en: 'Unlike in Python code, whitespace isn’t important in JSON data. For example,
    consider this JSON string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 代码不同，JSON 数据中的空格并不重要。例如，考虑这个 JSON 字符串：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To write the same JSON string in a more human-readable format, you can split
    it into multiple lines and add indentation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将相同的 JSON 字符串写成更易读的格式，你可以将其拆分成多行并添加缩进：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You might encounter JSON files in datasets that are formatted either way. I
    often open JSON files in VS Code and use the text editor’s built-in format feature
    to reformat the JSON for legibility. To format a document in VS Code, click **View**▸**Command
    Palette**▸**Format Document** and press ENTER.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在数据集中遇到格式不同的 JSON 文件。我经常在 VS Code 中打开 JSON 文件，并使用文本编辑器的内置格式化功能来重新格式化 JSON
    以提高可读性。在 VS Code 中格式化文档，点击 **视图**▸**命令面板**▸**格式化文档**，然后按回车键。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing JSON with
    Python</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 Python 解析 JSON</samp>
- en: 'You can turn JSON data into Python dictionaries and lists using Python’s built-in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> module. First, open
    a Python interpreter and import the module:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Python 内置的 <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> 模块将
    JSON 数据转换为 Python 字典和列表。首先，打开 Python 解释器并导入该模块：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The function in this module that I use the most is <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>.
    This takes a string with JSON data as an argument, parses the string into a Python
    object like a dictionary or a list, and returns that object. For example, define
    a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    and set its value to a JSON string with the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个模块中最常使用的函数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>。它接受一个包含
    JSON 数据的字符串作为参数，将该字符串解析为 Python 对象，如字典或列表，并返回该对象。例如，定义一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    的字符串，并使用以下命令将其值设置为一个 JSON 字符串：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The value you set <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    to looks similar to a dictionary, but since it’s surrounded by single quotes,
    it’s actually a string. In Python, the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp>
    function tells you the type of a variable. You can confirm that <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    is a string with the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> 看起来像一个字典，但由于它被单引号包围，因此它实际上是一个字符串。在
    Python 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> 函数可以告诉你变量的类型。你可以通过以下命令确认
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> 是一个字符串：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This output shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    is a class of type <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> ([Chapter
    14](chapter14.xhtml) will touch on classes), meaning it’s a string. Now define
    a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> and
    set its value to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> 是一个类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> 的类（[第 14 章](chapter14.xhtml)
    将涉及类），这意味着它是一个字符串。现在定义一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    的变量，并将其值设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    函数的返回值：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> takes
    a string as input and, if the string contains valid JSON, converts it into structured
    data—in this case, storing the resulting object in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function on
    <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> now to see what type
    of variable it is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> 接受一个字符串作为输入，并且如果字符串包含有效的
    JSON，它将其转换为结构化数据——在这个例子中，将结果对象存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    中。现在对 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp>
    函数，看看它是什么类型的变量：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output shows that you’ve parsed this JSON data into a Python dictionary
    (a <samp class="SANS_TheSansMonoCd_W5Regular_11">dict</samp>), which you can now
    use like any other dictionary. For example, to put the value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">last_name</samp>
    key of this dictionary in an f-string and then display it, use the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示你已经将这个 JSON 数据解析成了一个 Python 字典（一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">dict</samp>），现在你可以像使用其他字典一样使用它。例如，要将该字典中
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last_name</samp> 键的值放入一个 f-string
    并显示它，可以使用以下命令：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To practice accessing structured data, in your terminal, change to your Parler
    dataset folder, and then open a Python interpreter. Run the following commands
    to load the metadata from a Parler video as structured data. I’ve chosen the file
    *metadata/meta-HS34fpbzqg2b.json*, but feel free to load whichever file you’d
    like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习访问结构化数据，请在终端中切换到你的 Parler 数据集文件夹，然后打开 Python 解释器。运行以下命令来将 Parler 视频的元数据作为结构化数据加载。我选择了文件
    *metadata/meta-HS34fpbzqg2b.json*，但你可以随意加载任何文件：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You now have the video metadata in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    The simplest way to start inspecting it is to display it to the screen with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经将视频元数据存储在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 中。开始检查它的最简单方法是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 函数将其显示到屏幕上：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This output looks a little like JSON, but it’s a Python object—in this case,
    a list with a nested dictionary. Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function you learned about in [Chapter 8](chapter8.xhtml) to count how many items
    are in this list:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出看起来有点像 JSON，但它是一个 Python 对象——在这种情况下，是一个包含嵌套字典的列表。使用你在 [第 8 章](chapter8.xhtml)
    中学习过的 <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> 函数来计算这个列表中的项数：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since any given Parler video metadata file contains the metadata only for one
    video, there’s only one item in this list. In order to access that metadata, you
    need to select the first item in the list. To do that, use <samp class="SANS_TheSansMonoCd_W5Regular_11">obj[0]</samp>
    (remember, 0 is the first index for any list) as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何给定的 Parler 视频元数据文件只包含一个视频的元数据，因此这个列表中只有一个项。为了访问该元数据，你需要选择列表中的第一个项。可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">obj[0]</samp>（记住，0 是任何列表的第一个索引）来访问，如下所示：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time, the output starts with a brace, meaning the item is a dictionary.
    Now use a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to view
    all of the keys in this dictionary:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出以大括号开始，意味着该项是一个字典。现在使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环来查看字典中的所有键：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Each key listed in this output represents a different piece of video metadata
    from the JSON file. You can also select values from this dictionary using their
    keys. For example, try printing the values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> keys:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中列出的每个键都代表了来自 JSON 文件的不同视频元数据。你还可以使用这些键从字典中选择相应的值。例如，尝试打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> 键的值：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These values represent the GPS coordinates for the location where this video
    was filmed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值代表了该视频拍摄地点的 GPS 坐标。
- en: Since JSON makes it easy to convert structured data into strings and back, when
    creating BlueLeaks Explorer I used JSON files to store the structure of BlueLeaks
    sites, as described in the section “The Technology Behind BlueLeaks Explorer”
    in [Chapter 10](chapter10.xhtml). When you create a structure for a BlueLeaks
    site, BlueLeaks Explorer stores all of the configuration for that site in a dictionary,
    then saves that information to a JSON file. If you quit BlueLeaks Explorer and
    then run it again later, it loads that JSON file back into a dictionary. Since
    the Parler metadata comes in JSON format, you can also write Python code that
    loads these JSON files to easily access that metadata, as you’ll do later in this
    chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSON 使得结构化数据可以轻松地转化为字符串并进行反向转换，因此在创建 BlueLeaks Explorer 时，我使用 JSON 文件来存储
    BlueLeaks 网站的结构，如 [第 10 章](chapter10.xhtml) 中的“BlueLeaks Explorer 背后的技术”部分所述。当你为
    BlueLeaks 网站创建结构时，BlueLeaks Explorer 会将该网站的所有配置信息存储在字典中，然后将其保存到 JSON 文件中。如果你退出
    BlueLeaks Explorer 然后稍后再次运行它，它会将该 JSON 文件加载回字典中。由于 Parler 元数据是以 JSON 格式提供的，你也可以编写
    Python 代码加载这些 JSON 文件，以轻松访问这些元数据，正如你将在本章后面做的那样。
- en: To learn more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>
    module, you can find the documentation and plenty of example code at [*https://<wbr>docs<wbr>.python<wbr>.org<wbr>/3<wbr>/library<wbr>/json<wbr>.html*](https://docs.python.org/3/library/json.html).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> 模块的信息，可以在
    [*https://<wbr>docs<wbr>.python<wbr>.org<wbr>/3<wbr>/library<wbr>/json<wbr>.html*](https://docs.python.org/3/library/json.html)
    找到文档和大量示例代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Exceptions
    with JSON</samp>
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 JSON 处理异常</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function
    will throw an exception if you pass an invalid JSON string into it, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> 函数传入无效的
    JSON 字符串，它会抛出异常，像这样：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp>
    exception means that the string you passed in doesn’t contain valid JSON data.
    In this case, it’s telling you the error in the JSON string is at line 1, column
    1, and character 0, meaning the error is located at the first character of the
    string. If you have a longer JSON string that’s mostly valid but just has a little
    syntax issue, this error message can help you determine which piece of your syntax
    is wrong.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp>
    异常意味着你传入的字符串不包含有效的 JSON 数据。在这种情况下，它会告诉你 JSON 字符串中的错误出现在第 1 行，第 1 列，字符 0，意味着错误位于字符串的第一个字符。如果你有一个较长的
    JSON 字符串，虽然大部分内容是有效的，但只有少量语法错误，这个错误信息可以帮助你找出哪个语法部分出了问题。
- en: 'Validating JSON data is a common use for Python exception handling, which you
    learned about in “Exception Handling” in [Chapter 7](chapter7.xhtml). For example,
    let’s say you have a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>.
    The following code will catch exceptions in case this string contains invalid
    JSON data:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 JSON 数据是 Python 异常处理的常见用途，你在 [第 7 章](chapter7.xhtml) 的“异常处理”中学到过。例如，假设你有一个名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> 的字符串。以下代码将在该字符串包含无效
    JSON 数据时捕获异常：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statements to catch
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp>
    exception if it gets thrown. If <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    is a valid JSON string, it will display <samp class="SANS_TheSansMonoCd_W5Regular_11">The
    JSON is valid</samp>, followed by the information in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
    If the JSON string is invalid, the script will display <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid
    JSON</samp> and then continue running without crashing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    语句来捕捉 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp>
    异常，如果抛出异常的话。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    是一个有效的 JSON 字符串，它将显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">The JSON is
    valid</samp>，并且显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> 中的信息。如果
    JSON 字符串无效，脚本将显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid JSON</samp>，然后继续运行，不会崩溃。
- en: To load a JSON file in Python functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>,
    you must first load the content of the file into a string like so
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 函数如 <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 中加载
    JSON 文件，首先必须将文件内容加载到一个字符串中，像这样：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.json</samp>
    with whatever file you’re loading, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata/meta-HS34fpbzqg2b.json</samp>
    to load the metadata for the *HS34fpbzqg2b* video file. As you learned in “Reading
    and Writing Files” in [Chapter 8](chapter8.xhtml), this code opens the file as
    a file object <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and then
    stores its content into a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.json</samp>
    替换为你正在加载的文件名，比如 <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata/meta-HS34fpbzqg2b.json</samp>，以加载
    *HS34fpbzqg2b* 视频文件的元数据。正如你在 [第 8 章](chapter8.xhtml) 的“文件读写”中学到的那样，这段代码将文件打开为一个文件对象
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，然后将其内容存储到一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    的字符串中。
- en: 'Next, you’d run that string through <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    to convert it from a string into structured data, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    将该字符串转换为结构化数据，像这样：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When this code finishes running, if the JSON string was valid, <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    will contain the JSON data. Otherwise, it will display <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid
    JSON</samp> and then return early from the function. The remaining code in the
    function can access the data in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码运行完毕后，如果JSON字符串有效，<samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>将包含JSON数据。否则，它将显示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Invalid JSON</samp>并提前从函数中返回。函数中的其余代码可以访问<samp
    class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>中的数据。
- en: To prepare for using this module to write Python scripts that parse the Parler
    metadata files, next we’ll look at how to access values like GPS coordinates from
    JSON files with several command line programs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备使用这个模块编写解析Parler元数据文件的Python脚本，接下来我们将学习如何通过几个命令行程序来访问像GPS坐标这样的值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Tools for Exploring JSON Data</samp>
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">探索JSON数据的工具</samp>
- en: While we’ve been focusing primarily on working with JSON files using Python,
    sometimes writing a Python script is overkill if you just want to quickly search
    a large block of JSON text. In this section, you’ll learn to use our old friend
    <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>, as well as a more powerful
    tool called <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>, to search
    JSON files.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们主要集中在使用Python处理JSON文件上，但有时如果你只想快速搜索一大块JSON文本，编写Python脚本可能显得有些过于复杂。在这一节中，你将学会使用我们的老朋友<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>，以及一个更强大的工具<samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>来搜索JSON文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Counting Videos with
    GPS Coordinates Using grep</samp>
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用grep统计带有GPS坐标的视频</samp>
- en: As you know from [Chapter 4](chapter4.xhtml), the command line programs <samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>
    are incredibly powerful tools to quickly assess datasets. In a single command,
    and without needing to write a Python script, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    to efficiently search inside JSON files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第4章](chapter4.xhtml)中了解到的，命令行程序<samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>是非常强大的工具，可以快速评估数据集。在一个命令中，无需编写Python脚本，你就可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>高效地搜索JSON文件。
- en: 'For example, let’s say you want to figure out how many Parler video metadata
    files include GPS coordinates. Open a terminal, switch to your Parler dataset
    folder, and run the following command to grep for the string <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想弄清楚有多少Parler视频元数据文件包含GPS坐标。打开终端，切换到你的Parler数据集文件夹，并运行以下命令来grep查找字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">-r</samp>
    (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--recursive</samp>),
    tells <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to look inside
    every file in the given folder. The next argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>,
    is the string to search for. The final argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>,
    is the name of the folder to search.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数<samp class="SANS_TheSansMonoCd_W5Regular_11">-r</samp>（是<samp class="SANS_TheSansMonoCd_W5Regular_11">--recursive</samp>的简写）告诉<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>查找给定文件夹中的每个文件。下一个参数<samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>是要搜索的字符串。最后一个参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>是要搜索的文件夹名称。
- en: 'When you run this command, your terminal should quickly fill with GPS coordinates:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你的终端应该会很快填充GPS坐标：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, you’re trying to find how many of these videos have GPS coordinates,
    not necessarily what those coordinates are. If coordinates are still loading in
    your terminal, press CTRL-C to cancel the command, then pipe the output of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">wc
    -l</samp> to count how many lines get displayed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你要找的是这些视频中有多少个包含GPS坐标，而不一定是坐标的具体值。如果坐标还在终端中加载中，按CTRL-C取消命令，然后将<samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>的输出管道到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp>以统计显示的行数：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Of the slightly more than one million videos, about 64,000 have GPS coordinates.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在略多于一百万个视频中，大约有64,000个包含GPS坐标。
- en: Programs like <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> can only take you so far
    in your attempts to efficiently search large quantities of data. For example,
    if the JSON files you’re searching are formatted on a single line, rather than
    split into multiple lines like the Parler files, <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    will search the entire block of JSON data for your string rather than a line at
    a time. You can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    to extract specific fields of data from JSON, either. For that, the best tool
    for the job is a program called <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 像 <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>
    这样的程序在你尝试高效搜索大量数据时只能起到一定作用。例如，如果你正在搜索的 JSON 文件是单行格式的，而不是像 Parler 文件那样分成多行，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> 将会搜索整个 JSON 数据块中的字符串，而不是逐行搜索。你也不能使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> 来提取 JSON 中的特定字段。为此，最合适的工具是一个名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 的程序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatting and Searching
    Data with the jq Command</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 jq 命令格式化和搜索数据</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> program allows you
    to take JSON data as input and select key information from it. In this section,
    you’ll learn how to use it to extract specific information from the Parler files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 程序允许你将 JSON 数据作为输入并从中选择关键信息。在本节中，你将学习如何使用它从
    Parler 文件中提取特定信息。
- en: First, you’ll need to install <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
    Mac users can do so by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew
    install jq</samp> command. Linux or Windows with WSL users, run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo
    apt install jq</samp> command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>。Mac 用户可以通过运行
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install jq</samp> 命令进行安装。Linux
    或 Windows（带 WSL）的用户，请运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo apt
    install jq</samp> 命令。
- en: 'You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command
    to indent JSON data and show syntax highlighting in your terminal, making the
    data easier to read. For example, try running this command in your terminal:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 命令在终端中缩进 JSON
    数据并显示语法高亮，这样数据就更容易阅读了。例如，尝试在终端中运行以下命令：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first part of the command, <samp class="SANS_TheSansMonoCd_W5Regular_11">cat
    metadata/meta-HS34fpbzqg2b.json</samp>, outputs the content of that JSON file,
    which contains the metadata for a single Parler video. The second part, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">| jq</samp>, pipes that output as input
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的第一部分 <samp class="SANS_TheSansMonoCd_W5Regular_11">cat metadata/meta-HS34fpbzqg2b.json</samp>
    输出该 JSON 文件的内容，文件中包含单个 Parler 视频的元数据。第二部分 <samp class="SANS_TheSansMonoCd_W5Regular_11">|
    jq</samp> 将该输出作为输入传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>。
- en: 'The output should look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This version includes syntax highlighting (as in VS Code) and formats the JSON
    data so that the items in every array and object are listed on separate lines
    and indented.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该版本包括语法高亮（如 VS Code 中的效果），并将 JSON 数据格式化，使每个数组和对象中的项目都列在单独的行上并进行缩进。
- en: 'You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to
    filter for details from inside the JSON data. For example, suppose you just want
    to know the GPS coordinates from this JSON file. In the preceding code, you can
    tell from the bracket character at the beginning that this JSON data is an array.
    The first value of the array is an object, since it starts with a brace character,
    and one of the keys of the object is <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>.
    To filter for <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>,
    pass <samp class="SANS_TheSansMonoCd_W5Regular_11">".[0].GPSPosition"</samp> as
    an argument into the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command,
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 来筛选 JSON 数据中的详细信息。例如，假设你只想知道这个
    JSON 文件中的 GPS 坐标。在前面的代码中，你可以从开头的括号字符看出，这个 JSON 数据是一个数组。数组的第一个值是一个对象，因为它以花括号字符开始，其中一个键是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>。要筛选 <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>，将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">".[0].GPSPosition"</samp> 作为参数传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> 命令，如下所示：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this command, <samp class="SANS_TheSansMonoCd_W5Regular_11">.[0]</samp> selects
    the first item of the list in the file named *metaHS34fpbzqg2b.json*, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.GPSPosition</samp> selects the value
    with the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>
    from the object. The output shows the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>
    field, <samp class="SANS_TheSansMonoCd_W5Regular_11">"38 deg 53' 26.52\" N, 77
    deg 0' 28.44\" W"</samp>.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，<samp class="SANS_TheSansMonoCd_W5Regular_11">.[0]</samp> 选择名为 *metaHS34fpbzqg2b.json*
    文件中列表的第一个项，<samp class="SANS_TheSansMonoCd_W5Regular_11">.GPSPosition</samp> 选择该对象中键为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp> 的值。输出显示了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp> 字段的值，<samp class="SANS_TheSansMonoCd_W5Regular_11">"38
    deg 53' 26.52\" N, 77 deg 0' 28.44\" W"</samp>。
- en: If you’re interested in learning more about how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>,
    check out its website at [*https://<wbr>stedolan<wbr>.github<wbr>.io<wbr>/jq*](https://stedolan.github.io/jq).
    You’ll also revisit it in [Chapter 14](chapter14.xhtml), where I explain how I
    used it to understand the structure of leaked neo-Nazi chat logs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解更多如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>，可以访问它的官网
    [*https://<wbr>stedolan<wbr>.github<wbr>.io<wbr>/jq*](https://stedolan.github.io/jq)。你还将在
    [第 14 章](chapter14.xhtml) 中回顾它，届时我将解释我如何使用它来理解泄露的 neo-Nazi 聊天记录结构。
- en: Now that you have a foundational understanding of JSON, you’ll try your hand
    at writing Python code that works with it in Exercise 11-2.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了基础的 JSON 理解，你将在练习 11-2 中尝试编写与 JSON 数据交互的 Python 代码。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-2: Write a Script to Filter
    for Videos with GPS from January 6, 2021</samp>'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 11-2：编写一个脚本，筛选出 2021 年 1 月 6 日拍摄的包含
    GPS 的视频</samp>
- en: In this exercise, you’ll write a Python script that filters the Parler videos
    down to just those filmed on January 6, 2021, whose metadata includes GPS coordinates.
    You’ll do this by looping through all the JSON files in the dataset, converting
    them into Python objects, and inspecting their metadata to show you just the ones
    you’re looking for.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个 Python 脚本，用于筛选出仅包含 2021 年 1 月 6 日拍摄的、元数据中包含 GPS 坐标的 Parler 视频。你将通过遍历数据集中的所有
    JSON 文件，将它们转换为 Python 对象，并检查它们的元数据，从而只显示你需要的那些视频。
- en: 'For a challenge, you can try programming your own script to meet the following
    requirements:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，你可以尝试编写自己的脚本，满足以下要求：
- en: Make this script accept an argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>,
    using Click. This will be the path to the *metadata* folder full of JSON files.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使这个脚本接受一个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>，使用
    Click。这将是包含 JSON 文件的*元数据*文件夹路径。
- en: Define a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    that keeps track of the number of Parler videos that include GPS coordinates in
    their metadata, and set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> 的新变量，用来跟踪包含
    GPS 坐标的 Parler 视频的数量，并将其初始值设为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: Loop through all of the JSON files in the *metadata* folder. For each loop,
    your program should run the content of each JSON file through the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    function to turn it into a Python object. As described in the “Parsing JSON with
    Python” section, each object is technically a list containing one element, a dictionary
    full of all of the video’s metadata.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历 *metadata* 文件夹中的所有 JSON 文件。对于每次循环，你的程序应该通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    函数将每个 JSON 文件的内容转换为 Python 对象。正如在“使用 Python 解析 JSON”部分所述，每个对象实际上是一个包含一个元素的列表，这个元素是一个字典，包含了所有视频的元数据。
- en: Check to see if that video’s metadata dictionary includes the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>
    and if the date stored in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    is January 6, 2021\. If both of these are true, the script should display a message
    that this file includes GPS coordinates and is from January 6, 2021, and increment
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable by 1.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查该视频的元数据字典是否包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>
    键，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> 键中存储的日期是否为
    2021 年 1 月 6 日。如果这两者都为真，脚本应该显示一条消息，告知该文件包含 GPS 坐标并且来自 2021 年 1 月 6 日，并将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">count</samp> 变量加 1。
- en: Have the program display a message after looping through all the metadata files
    that tells the user the total number of videos with GPS coordinates from January
    6, 2021 (which should be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    variable, now that you’re done counting).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让程序在遍历完所有元数据文件后显示一条消息，告诉用户从 2021 年 1 月 6 日起，包含 GPS 坐标的视频总数（该值应该存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    变量中，既然你已经完成了计数）。
- en: Alternatively, follow along with the rest of this exercise and I’ll walk you
    through the programming process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，按照本练习的其余部分进行，我会一步步指导你完成编程过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept the Parler
    Metadata Path as an Argument</samp>
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">接受 Parler 元数据路径作为参数</samp>
- en: 'Start with the usual Python script template:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从常见的 Python 脚本模板开始：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, make the following modifications to your script so that it accepts the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp> CLI
    argument. This way, when you run the script, you can pass in the path to the *metadata*
    folder as an argument, which the code will use to open all of the JSON files inside
    that folder. The modifications are shown in bold:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改你的脚本，使其接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    命令行参数。这样，当你运行脚本时，你可以将 *metadata* 文件夹的路径作为参数传入，代码会用它来打开该文件夹中的所有 JSON 文件。修改部分已加粗显示：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code first imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, then uses it to make the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function accept the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>.
    It also adds a docstring to show what the script does when you run it with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> argument. Finally,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function will
    print the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    to the screen.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> 模块，然后使用它使得
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> 函数接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    参数。它还添加了一个文档字符串，以展示当你用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp>
    参数运行脚本时，脚本的功能。最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    函数将打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    的值到屏幕上。
- en: 'Test your code to make sure it works so far, replacing the argument with the
    path to your own *metadata* folder:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的代码，确保到目前为止它工作正常，将参数替换为你自己 *metadata* 文件夹的路径：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Sure enough, the code should display the same string, stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>,
    that you passed in as an argument.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，代码应该显示与你作为参数传入的字符串相同的内容，该字符串存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Through Parler
    Metadata Files</samp>
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">遍历 Parler 元数据文件</samp>
- en: 'Next, add some code that will loop through all of the JSON files in the *metadata*
    folder and run <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    on their contents to convert them into structured data in Python. Modify your
    code as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一些代码，遍历*metadata*文件夹中的所有JSON文件，并对其内容运行<samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>，将它们转换为Python中的结构化数据。修改代码如下：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> modules at the top
    of the file so it can use the functions they contain later on. The program then
    loops through the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>
    function, which returns the list of files in the *metadata* folder, storing each
    filename in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在文件顶部导入了<samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp>模块，以便后续可以使用它们包含的函数。程序接着循环遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp>函数的返回值，该函数返回*metadata*文件夹中的文件列表，将每个文件名存储在变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>中。
- en: Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the
    code defines a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">abs_filename</samp>
    to be the absolute path of the JSON file the code is working with each time it
    loops. It creates the absolute path by concatenating <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> function. Now that
    the code knows the full filename, it checks to make sure that this is actually
    a file, not a folder, and that it ends with *.json*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环内，代码定义了一个新变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">abs_filename</samp>，该变量表示代码每次循环时正在处理的JSON文件的绝对路径。它通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp>函数，将<samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>连接，生成绝对路径。现在代码知道了完整的文件名，它会检查确保这确实是一个文件，而不是一个文件夹，并且文件名以*.json*结尾。
- en: If the code confirms the file is JSON, it loads all of the data from this file
    into the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>
    and then converts that string into structured data, saved in the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>, using <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statements, as
    described in the “Handling Exceptions with JSON” section. If there are no syntax
    errors in an individual JSON file, the code displays a message to the screen saying
    that the file loaded successfully. Otherwise, it displays an error and moves on
    to the next file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statement. In a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements immediately
    end the current loop and move on to the next loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码确认文件是JSON格式，它将把该文件的所有数据加载到变量<samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>中，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">try</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>语句，将该字符串转换为结构化数据，并保存在变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>中，如“处理JSON中的异常”一节所述。如果单个JSON文件中没有语法错误，代码会在屏幕上显示文件加载成功的消息。否则，它会显示错误并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>语句跳过当前文件，继续下一个文件。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环中，<samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>语句会立即结束当前循环并进入下一个循环。
- en: To summarize, at this point the code is looping through every file in the *metadata*
    folder, and for each JSON file it comes across, opening it and loading its content
    as a text string. It then converts this string into a Python object using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function, storing
    the object in the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>
    variable, and displays a message that it successfully loaded. If the file didn’t
    successfully load, the message says that the JSON was invalid, and the code continues
    on to the next JSON file.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，目前的代码正在遍历*metadata*文件夹中的每一个文件，对于每个遇到的JSON文件，它会打开并将其内容作为文本字符串加载。然后，它使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>函数将该字符串转换为Python对象，并将该对象存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>变量中，并显示一个加载成功的消息。如果文件没有成功加载，消息将显示JSON无效，代码会继续处理下一个JSON文件。
- en: 'Run the program again, replacing the argument with the path to your own *metadata*
    folder:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序，将参数替换为你自己的*metadata*文件夹路径：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If your output shows many messages saying different JSON files loaded successfully,
    your code is working. Once you’ve determined that your output looks correct, you
    can press CTRL-C to cancel the script before it finishes running.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出中显示了多个消息，表示不同的JSON文件加载成功，那么你的代码是正常工作的。确定输出正确后，你可以按CTRL-C取消脚本执行，避免其继续运行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Videos
    with GPS Coordinates</samp>
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">筛选包含GPS坐标的视频</samp>
- en: 'Your code currently loops through all of the Parler metadata files, loads each
    file, and converts it into a Python object so you can work with it. Next, you
    need to filter out the videos that include GPS coordinates and to count those
    videos. To do so, make the following modifications:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码目前正在遍历所有的Parler元数据文件，加载每个文件，并将其转换为Python对象，以便你可以对其进行操作。接下来，你需要筛选出包含GPS坐标的视频并统计这些视频的数量。为此，请进行以下修改：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code defines a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    and starts its value out as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    This will keep track of the number of videos with GPS coordinates. After each
    JSON file is loaded into the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>
    variable, an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    checks if the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>
    exists inside this metadata dictionary. Remember from the previous section that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> is a list with one
    item, making <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata[0]</samp>
    the actual dictionary your code is checking. If this video metadata does have
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> field,
    the control flow moves to the code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. Otherwise, it moves on to the next loop.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个新变量<samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>，并将其初始值设为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。这个变量将用于跟踪包含GPS坐标的视频数量。在每次JSON文件加载到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>变量后，<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句会检查该元数据字典中是否存在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>键。记住在前一节中提到过，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>是一个包含一个项目的列表，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">metadata[0]</samp>是实际被代码检查的字典。如果这个视频的元数据确实包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>字段，控制流会进入<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句之后的代码块。否则，它会继续进入下一个循环。
- en: When the Python script comes across metadata that includes GPS coordinates,
    it displays the name of the file with <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    and increments <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> by 1\.
    This way, by the time this <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop is finished, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> will
    contain the total number of videos that have GPS coordinates in their metadata.
    Finally, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    completes, the code displays that total count with a second call to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function. As you learned
    in [Chapter 8](chapter8.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>
    in the f-string will display larger numbers with comma separators.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python脚本遇到包含GPS坐标的元数据时，它会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    显示文件名，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> 增加1。这样，在这个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环结束时，<samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>
    将包含元数据中具有GPS坐标的视频的总数。最后，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环完成后，代码将通过第二次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    函数来显示该总数。如你在[第8章](chapter8.xhtml)中学到的，f-string中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>
    会使用逗号分隔符显示较大的数字。
- en: 'Run your program again:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行你的程序：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because this script loads the JSON data from over a million files, it might
    take a few minutes to finish running. In the end, your script should find 63,983
    videos with GPS coordinates. There should also be 63,984 lines of output: one
    with the name of each metadata file that has GPS coordinates, and one at the end
    that lists the total.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个脚本需要从超过一百万个文件中加载JSON数据，因此它可能需要几分钟才能完成。最终，脚本应该会找到63,983个包含GPS坐标的视频。输出应该有63,984行：每行一个带有GPS坐标的元数据文件的名称，最后一行显示总数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Videos
    from January 6, 2021</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">过滤2021年1月6日的视频</samp>
- en: Now you’ll whittle down that list of roughly 64,000 videos even further to find
    out which were filmed on January 6, 2021.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将进一步筛选出大约64,000个视频，找出其中哪些是拍摄于2021年1月6日的。
- en: 'You can tell the date on which a video was filmed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    field in its metadata, as shown earlier in [Listing 11-1](#list11-1). The value
    of this field looks something like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过视频元数据中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    字段来确定视频的拍摄日期，如前面在[列表11-1](#list11-1)中所示。该字段的值类似于以下内容：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    field to filter the results further, make the following modifications to your
    code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 若要进一步使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> 字段来过滤结果，请对你的代码进行以下修改：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Rather than just checking for videos with GPS coordinates, now the code also
    checks for those that have a <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    that starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">2021:01:06</samp>.
    Once the code determines that the metadata in the current loop has GPS coordinates
    and was created on January 6, 2021, it displays the filename with <samp class="SANS_TheSansMonoCd_W5Regular_11">print(f"GPS</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Jan
    6: {filename}")</samp>. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop is finished, it displays the total count.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，代码不仅检查是否有带GPS坐标的视频，还检查那些 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    字段以 <samp class="SANS_TheSansMonoCd_W5Regular_11">2021:01:06</samp> 开头的视频。一旦代码确定当前循环中的元数据包含GPS坐标并且拍摄时间是2021年1月6日，它会显示文件名，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print(f"GPS</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jan 6: {filename}")</samp>。当 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环结束时，它会显示总数。'
- en: The expression in this code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is surrounded by parentheses, and the three conditions inside those
    parentheses are indented. This is purely cosmetic; the code would work exactly
    the same if it were all on one line, but this formatting makes it slightly easier
    to read.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的表达式被括号括起来，括号内的三个条件都有缩进。这纯粹是外观上的调整；如果这些代码都写在一行上，程序依然可以正常工作，只不过这样的格式使得代码稍微容易阅读一些。
- en: 'You can find the final script in the book’s GitHub repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-2.py).
    Run the completed script like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到最终的脚本：[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-2.py)。像这样运行完成的脚本：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The script might still take a few minutes to run, but this time, there should
    be fewer results. Only 1,958 Parler videos have GPS coordinates and were filmed
    on January 6, 2021; this is about 3 percent of the videos with GPS coordinates,
    and less than 0.2 percent of all of the videos.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可能仍然需要几分钟才能运行，但这次结果应该会少一些。只有1,958个Parler视频包含GPS坐标，并且是在2021年1月6日拍摄的；这大约是所有含有GPS坐标的视频的3%，也是所有视频的不到0.2%。
- en: Watching almost 2,000 videos, while perhaps unpleasant, is at least feasible.
    We can still do better, though. In all likelihood, some of those January 6 videos
    weren’t actually filmed at the insurrection itself, but just happened to be uploaded
    the same day from other locations. To prepare for filtering this list further
    in order to find videos filmed at the insurrection, you’ll need some background
    on working with GPS coordinates.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然观看将近2,000个视频可能会让人不愉快，但至少是可行的。不过我们可以做得更好。很可能，其中一些1月6日的视频实际上并不是在暴动现场拍摄的，而是刚好在同一天从其他地方上传的。为了进一步过滤这个列表，以便找到在暴动现场拍摄的视频，你需要一些有关GPS坐标的背景知识。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with GPS Coordinates</samp>
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">处理GPS坐标</samp>
- en: In this section, you’ll learn how latitude and longitude coordinates work and
    how to look them up on online map services like Google Maps. You’ll also learn
    how to convert between different GPS formats and measure the rough distance between
    two locations. I’ll introduce a few new Python features, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> methods for
    modifying strings and the <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    function for converting a string into a decimal number.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习纬度和经度坐标是如何工作的，以及如何在像Google Maps这样的在线地图服务中查找它们。你还将学习如何在不同的GPS格式之间转换，并测量两个位置之间的大致距离。我将介绍一些新的Python功能，包括用于修改字符串的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp>
    方法，以及用于将字符串转换为十进制数字的 <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searching by Latitude
    and Longitude</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按纬度和经度搜索</samp>
- en: 'You can define any location on Earth using two coordinates: latitude and longitude.
    These coordinates are measured in degrees, with each degree split into 60 minutes
    and each minute split into 60 seconds. Latitude goes from 90 degrees North, which
    is the North Pole, to 0 degrees at the equator, to 90 degrees South, which is
    the South Pole. Longitude goes from 180 degrees West, which is in the middle of
    the Pacific Ocean, to 0 degrees, which cuts through England, to 180 degrees East,
    back to that same location in the middle of the Pacific.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两个坐标定义地球上的任何位置：纬度和经度。这些坐标以度为单位进行测量，每度被分为60分钟，每分钟被分为60秒。纬度从北极的90度向南到赤道的0度，再到南极的90度。经度从太平洋中部的西经180度到切过英国的0度，再到太平洋中部的东经180度，回到同一位置。
- en: 'For example, if you look up the metadata for the Parler video with filename
    *HS34fpbzqg2b* (which shows Trump supporters removing barricades around the Capitol
    building while police officers stand by and watch), you’d find the following GPS
    coordinates:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你查看Parler视频的元数据，文件名为 *HS34fpbzqg2b*（该视频显示特朗普支持者在国会大厦周围移除路障，而警察则站在一旁观看），你会发现以下GPS坐标：
- en: 'Latitude: 38 deg 53′ 26.52″ N'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度：38度53′26.52″ N
- en: 'Longitude: 77 deg 0′ 28.44″ W'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 经度：77度0′28.44″ W
- en: That means this video was filmed at the latitude of 38 degrees, 53 minutes,
    26.52 seconds North and the longitude of 77 degrees, 0 minutes, 28.44 seconds
    West.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该视频是在北纬38度53分26.52秒和西经77度0分28.44秒的地方拍摄的。
- en: 'You can use various online map services, like Google Maps, to search by GPS
    coordinates and see exactly where on Earth they point to. To search the coordinates
    contained in the Parler metadata, you’ll need to slightly modify them so that
    Google Maps will recognize them, loading [*https://<wbr>www<wbr>.google<wbr>.com<wbr>/maps*](https://www.google.com/maps)
    and entering these coordinates as the string 38°53′26.52″, −77°0′28.44\. Try searching
    for those coordinates in Google Maps now. [Figure 11-3](#fig11-3) shows the exact
    location this video was filmed: just outside the US Capitol building, where police
    had set up barricades.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种在线地图服务，如Google地图，通过GPS坐标查找并准确显示它们在地球上的位置。要搜索Parler元数据中的坐标，你需要稍微修改它们，以便Google地图识别，加载[*https://<wbr>www<wbr>.google<wbr>.com<wbr>/maps*](https://www.google.com/maps)并将这些坐标作为字符串38°53′26.52″，−77°0′28.44输入。现在尝试在Google地图中搜索这些坐标。[图11-3](#fig11-3)显示了该视频拍摄的确切位置：美国国会大厦外，警方在此设置了路障。
- en: '![A Google Maps screenshot with a pin on a location just outside the US Capitol
    building.](Images/Figure11-3.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![显示标记位置的Google地图截图，位置位于美国国会大厦外。](Images/Figure11-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Pinpointing a
    location near the US Capitol building in Google Maps</samp>'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图11-3：在Google地图中标记靠近美国国会大厦的地点</samp>
- en: You can also use Google Maps to discover the GPS coordinates of any given point.
    If you right-click anywhere on the map, a context menu should pop up showing you
    the GPS coordinates of that point. However, when you do this, the coordinates
    it shows you will look slightly different because they’ll be in decimal format.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Google地图来查找任何给定点的GPS坐标。如果你在地图上任意位置右键点击，一个上下文菜单将弹出，显示该点的GPS坐标。然而，当你这样做时，显示的坐标会有所不同，因为它们将以十进制格式显示。
- en: In the next section, you’ll learn to convert from decimals to degrees, minutes,
    and seconds.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，你将学习如何将十进制格式转换为度、分、秒格式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    GPS Coordinate Formats</samp>
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在GPS坐标格式之间转换</samp>
- en: 'GPS coordinates in decimal format show the number of degrees on the left side
    of the decimal point, and converted minutes and seconds values on the right side.
    For example, consider the GPS coordinates from the *HS34fpbzqg2b* video:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制格式的GPS坐标显示了小数点左侧的度数和小数点右侧的转换后分钟和秒数值。例如，考虑来自*HS34fpbzqg2b*视频的GPS坐标：
- en: The latitude is 38 degrees, 53 minutes, 26.52 seconds North, which is 38.8907
    in decimal.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纬度为38度53分26.52秒北纬，换算成十进制为38.8907。
- en: The longitude is 77 degrees, 0 minutes, 28.44 seconds West, which is −77.0079
    in decimal.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经度为77度0分28.44秒西经，换算成十进制为−77.0079。
- en: One degree is 60 minutes and one minute is 60 seconds, meaning there are 3,600
    seconds in a degree. The formula to convert from degrees, minutes, and seconds
    to decimal format is *degrees* + (*minutes* / 60) + (*seconds* / 3,600). Latitudes
    are negative in the Southern Hemisphere but positive in the Northern Hemisphere,
    while longitudes are negative in the Western Hemisphere but positive in the Eastern
    Hemisphere. The latitude for the *HS34fpbzqg2b* video is positive, while the longitude
    is negative.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一度等于60分，一分等于60秒，这意味着一度有3,600秒。将度、分、秒转换为十进制格式的公式是*度* + (*分* / 60) + (*秒* / 3,600)。南半球的纬度为负，北半球的纬度为正，西半球的经度为负，东半球的经度为正。*HS34fpbzqg2b*视频的纬度为正，而经度为负。
- en: Decimal numbers are simpler to work with in code. Since the GPS coordinates
    in the Parler metadata are formatted as degrees, minutes, and seconds, let’s use
    some Python code to convert them to decimal format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function in [Listing 11-2](#list11-2) takes a GPS coordinate from the Parler metadata
    as an argument and returns the decimal version.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数字在代码中更容易处理。由于Parler元数据中的GPS坐标是以度、分、秒格式表示的，我们可以使用一些Python代码将其转换为十进制格式。[列表11-2](#list11-2)中的<­samp
    class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>函数接受Parler元数据中的GPS坐标作为参数，并返回十进制版本。
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">gps_degrees_to_decimal()</samp>
    function</samp>'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表11-2：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">gps_degrees_to_decimal()</samp>函数</samp>
- en: 'This function introduces some new Python features. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp>
    string method splits a string into a list of parts based on whitespace. For example,
    this method would convert the string <samp class="SANS_TheSansMonoCd_W5Regular_11">''77
    deg 0\'' 28.44" W''</samp> into the list of strings <samp class="SANS_TheSansMonoCd_W5Regular_11">[''77'',
    ''deg'', "0'' ", ''28.44" '', ''W'']</samp>. The line <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">gps
    _coordinate.split()</samp> stores the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate.split()</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp> variable.
    If you passed that string into this function as <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp>,
    this would mean the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数介绍了一些新的 Python 特性。首先，<samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp>
    字符串方法根据空格将字符串拆分成一个部分列表。例如，这个方法会将字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">'77
    deg 0\' 28.44" W'</samp> 转换为字符串列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">['77',
    'deg', "0' ", '28.44" ', 'W']</samp>。行 <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate.split()</samp>
    将 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate.split()</samp>
    的返回值存储到 <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp> 变量中。如果你将该字符串作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp> 传入此函数，那么它的含义如下：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp>.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp> 是字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp>。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[1]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">deg</samp>.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[1]</samp> 是字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">deg</samp>。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[2]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp> (0 followed by a single
    quote).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[2]</samp> 是字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp>（0
    后跟单引号）。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[3]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp> (28.44 followed by
    a double quote).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[3]</samp> 是字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp>（28.44
    后跟双引号）。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[4]</samp> is the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[4]</samp> 是字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>。
- en: Before you can do math with strings in Python, you must convert them into *floating-point
    numbers*—which are just numbers that can contain decimals—using the <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    function. [Listing 11-2](#list11-2) uses <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    to set the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp>
    to the floating-point version of <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp>.
    In this case, it converts the value of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp> to the
    floating-point number <samp class="SANS_TheSansMonoCd_W5Regular_11">77.0</samp>.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中进行字符串的数学运算之前，你必须使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    函数将它们转换为*浮点数*——即可以包含小数的数字。[列表 11-2](#list11-2) 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp>
    将 <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp> 的值设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp>
    的浮点版本。在这种情况下，它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp>
    中的字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp> 转换为浮点数 <samp class="SANS_TheSansMonoCd_W5Regular_11">77.0</samp>。
- en: The next line of code similarly uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp>
    string method to convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp>
    value to a floating-point number. This method searches the string for the first
    argument and replaces it with the second argument. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"GPS
    is fun".replace("fun", "hard")</samp> returns the string <samp class="SANS_TheSansMonoCd_W5Regular_11">GPS
    is hard</samp>. When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[2].replace("
    ' ", " ")</samp>, you’re replacing the single quote character (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>)
    with an empty string, in order to delete that character. This would convert the
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and then convert <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to the floating-point number
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码类似地使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> 字符串方法将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp> 值转换为浮点数。该方法在字符串中查找第一个参数，并用第二个参数替换它。例如，
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"GPS is fun".replace("fun", "hard")</samp>
    返回字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">GPS is hard</samp>。当你运行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">parts[2].replace(" ' ", " ")</samp> 时，你正在用空字符串替换单引号字符
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>)，以便删除该字符。这将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp>
    中的字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，然后将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 转换为浮点数 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>。
- en: The next line uses <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp>
    to delete the double quote character (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>),
    converting the string <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinates</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp>, then converting that into
    the floating-point number <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp>
    and saving it as <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> 删除双引号字符
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>)，将字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp>
    从 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinates</samp> 转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp>，然后将其转换为浮点数 <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp>，并将其保存为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>。
- en: The rest of the function is more straightforward. It defines the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp> as the decimal version
    of the GPS coordinates that are passed in an argument, using the formula to convert
    the coordinates to decimal format using the numbers in <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>.
    If the coordinates are in the Western or Southern Hemisphere, the code <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal
    *=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> makes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp> a negative number.
    Finally, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">gps
    _decimal</samp>, the decimal version of the GPS coordinates.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分更加直接。它将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp>
    定义为传入的GPS坐标的十进制版本，使用公式将坐标转换为十进制格式，公式使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>
    中的数字。如果坐标位于西半球或南半球，代码 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal
    *=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> 会使 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp>
    变为负数。最后，函数返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp>，即GPS坐标的十进制版本。
- en: Since the GPS coordinates in the Parler data come in strings of degrees, minutes,
    and seconds, you’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function in the next exercise to convert them to decimal format. First, though,
    you’ll need to know how to calculate distances between two GPS coordinates.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Parler数据中的GPS坐标以度、分、秒的字符串形式出现，在接下来的练习中，你将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    函数将其转换为十进制格式。不过，首先你需要了解如何计算两个GPS坐标之间的距离。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating GPS Distance
    in Python</samp>
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用 Python 计算 GPS 距离</samp>
- en: To determine which Parler videos were filmed in Washington, DC, based on their
    GPS coordinates, you can begin by finding the coordinates for the center point
    of the city and then imagine a circle around that point. You can consider a video
    to have been filmed in the city if its metadata has both a longitude and latitude
    within that circle. This won’t tell you if the video was exactly filmed within
    the Washington, DC, city limits, but it’s close enough. In this section, I’ll
    review the simple math required to do this calculation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据视频的 GPS 坐标确定哪些 Parler 视频是在华盛顿特区拍摄的，可以通过找到城市中心点的坐标，并想象一个围绕该点的圆圈来开始。如果视频的元数据中的经纬度都在这个圆圈内，你可以认为该视频是在城市内拍摄的。这并不能告诉你视频是否完全在华盛顿特区的市界内拍摄，但已经足够接近了。在这一节中，我将回顾完成这个计算所需的简单数学。
- en: The Earth isn’t flat, but for the purposes of this chapter, pretend that Washington,
    DC, is a flat plane. You can think of GPS coordinates as a 2D point on a Cartesian
    coordinate system, where longitude represents the *x* axis (East and West) and
    latitude represents the *y* axis (North and South). Since you can look up the
    coordinates of the center of Washington, DC, and you know the coordinates for
    where each video was filmed, you can use the distance formula to determine if
    it’s inside the circle.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 地球并不是平的，但为了本章的目的，假设华盛顿特区是一个平面。你可以将 GPS 坐标视为笛卡尔坐标系中的 2D 点，其中经度表示 *x* 轴（东西方向），纬度表示
    *y* 轴（南北方向）。由于你可以查找华盛顿特区中心的坐标，并且知道每个视频拍摄位置的坐标，你可以使用距离公式来确定它是否在圆圈内。
- en: The distance formula, as you might recall from geometry class, is used to calculate
    the distance between two points. It states that the distance between two points
    equals the square root of ((*x*[2] − *x*[1])² + (*y*[2] − *y*[1])²), where (*x*[1],
    *y*[1]) is one point and (*x*[2], *y*[2]) is another point. As an example, [Figure
    11-4](#fig11-4) shows the distance between the White House and the US Capitol,
    with the White House at point (*x*[1], *y*[1]) and the US Capitol at point (*x*[2],
    *y*[2]).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 距离公式，正如你在几何课上可能记得的，用来计算两点之间的距离。它表示两点之间的距离等于（（*x*[2] − *x*[1])² + (*y*[2] − *y*[1])²）的平方根，其中（*x*[1],
    *y*[1]）是一个点，(*x*[2], *y*[2])是另一个点。举个例子，[图 11-4](#fig11-4) 显示了白宫和美国国会大厦之间的距离，其中白宫位于点（*x*[1],
    *y*[1]），美国国会大厦位于点（*x*[2], *y*[2]）。
- en: '![A map of Washington, DC, overlaid by a right triangle. The White House is
    at the top of the triangle’s y axis, the US Capitol is at the right of the triangle’s
    x axis, and the distance formula is shown on the hypotenuse between them.](Images/Figure11-4.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![华盛顿特区的地图，叠加一个直角三角形。白宫位于三角形的 y 轴顶端，美国国会大厦位于三角形的 x 轴右侧，两个地点之间的斜边显示了距离公式。](Images/Figure11-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: Using the distance
    formula to calculate the distance between the White House and the US Capitol</samp>'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-4：使用距离公式计算白宫和美国国会大厦之间的距离</samp>
- en: To determine if a given Parler video was filmed in Washington, DC, you’ll compare
    the city center with the GPS coordinates of a Parler video. The center point of
    DC is constant, and when you loop through the JSON files of Parler metadata, you
    can find all the relevant GPS coordinates. If you plug these points into the distance
    formula, you can determine whether the distance is close enough to the center
    to be considered inside the city.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定给定的 Parler 视频是否在华盛顿特区拍摄，你需要将城市中心与 Parler 视频的 GPS 坐标进行比较。华盛顿特区的中心点是固定的，当你遍历
    Parler 元数据的 JSON 文件时，你可以找到所有相关的 GPS 坐标。如果你将这些点代入距离公式，就可以判断距离是否足够接近中心，从而判断是否在城市内。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Since the Earth isn’t actually flat, using the distance formula will only
    be relatively accurate for short distances, like 20 kilometers. It’s possible
    to calculate much more accurate distances between GPS coordinates using spherical
    geometry, but that requires using trigonometry functions like sine, cosine, and
    arctangent. Using the distance formula is much simpler and accurate enough for
    our purposes.*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于地球实际上不是平的，使用距离公式仅在较短的距离（如 20 公里）内相对准确。使用球面几何可以计算出更精确的 GPS 坐标之间的距离，但那需要使用三角函数，如正弦、余弦和反正切。使用距离公式要简单得多，并且对于我们的目的来说已经足够准确。*'
- en: '[Listing 11-3](#list11-3) shows a Python <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function that implements the distance formula.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-3](#list11-3) 显示了一个 Python <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    函数，它实现了距离公式。'
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">distance()</samp>
    function</samp>'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">distance()</samp>
    函数</samp>
- en: The distance formula requires you to calculate a square root, which you can
    do using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">math.sqrt()</samp>
    function. To access this function, first you import the <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    module at the top of the file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">x1</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y1</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y2</samp> arguments, then calculates
    the distance formula, returning the distance between the two points. (In Python,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">**</samp> is the power operator,
    so we write *x*² as <samp class="SANS_TheSansMonoCd_W5Regular_11">x**2</samp>.)
    If you call <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> and
    pass any two points into it as arguments, it will return the distance between
    them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 距离公式要求你计算一个平方根，这可以通过 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">math.sqrt()</samp>
    函数来完成。为了使用这个函数，首先需要在文件顶部导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    模块。<samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 函数接受 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">x2</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y2</samp>
    参数，然后计算距离公式，返回两点之间的距离。（在 Python 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">**</samp>
    是幂运算符，所以我们写 *x*² 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">x**2</samp>。）如果你调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 并传入任意两点，它将返回这两点之间的距离。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding the Center
    of Washington, DC</samp>
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">寻找华盛顿特区的中心</samp>
- en: Now you’ll find the coordinates of the center of Washington, DC, so that you
    can use the distance formula to compare them against those from a Parler video.
    Load [*https://<wbr>www<wbr>.google<wbr>.com<wbr>/maps*](https://www.google.com/maps)
    in your browser and search for **Washington DC**. Right-click the US Capitol building,
    which is approximately at the center of the city. Google Maps should show you
    the GPS coordinates of that point (see [Figure 11-5](#fig11-5)); click them to
    copy them. Your GPS coordinates might be slightly different, depending on where
    exactly you clicked.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将找到华盛顿特区中心的坐标，以便你可以使用距离公式将其与 Parler 视频的坐标进行比较。在浏览器中加载 [*https://<wbr>www<wbr>.google<wbr>.com<wbr>/maps*](https://www.google.com/maps)
    并搜索 **Washington DC**。右键单击美国国会大厦，它大致位于城市的中心。Google 地图应该会显示该点的 GPS 坐标（见 [图 11-5](#fig11-5)）；点击这些坐标复制它们。根据你点击的位置，你的
    GPS 坐标可能会稍有不同。
- en: '![A screenshot from Google Maps, showing the menu that pops up after right-clicking
    a point near the center of Washington, DC. The first item on the menu is 33.89410,
    −77.00667, which are the GPS coordinates of that point.](Images/Figure11-5.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![来自 Google 地图的截图，显示了右键单击靠近华盛顿特区中心的一个点后弹出的菜单。菜单上的第一个项目是 33.89410, −77.00667，这是该点的
    GPS 坐标。](Images/Figure11-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: Using Google Maps
    to find the GPS coordinates of the center of Washington, DC</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-5：使用 Google 地图查找华盛顿特区中心的
    GPS 坐标</samp>
- en: If the radius of the imaginary circle around Washington, DC, is about 20 kilometers,
    you can consider any videos filmed within 0.25 degrees to be inside the city.
    I decided on 0.25 degrees by checking the GPS coordinates on the outskirts of
    DC and comparing them to the coordinates in the city center.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果华盛顿特区周围的假想圆圈半径约为 20 公里，你可以认为任何拍摄于 0.25 度范围内的视频都在城市内部。我通过检查华盛顿特区边缘的 GPS 坐标，并将其与市中心的坐标进行比较，决定了
    0.25 度的范围。
- en: Armed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> Python functions
    and the GPS coordinates for the center of Washington, DC, you’re ready to finish
    filtering the Parler videos to find the insurrection videos in Exercise 11-3.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> Python 函数以及华盛顿特区中心的
    GPS 坐标后，你已准备好完成筛选 Parler 视频，找出练习 11-3 中的叛乱视频。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-3: Update the Script to
    Filter for Insurrection Videos</samp>'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 11-3：更新脚本以筛选叛乱视频</samp>
- en: 'In this exercise, you’ll filter the results of the Exercise 11-2 script even
    further, searching just for videos filmed in Washington, DC. First, make a copy
    of *exercise-11-2.py* and rename it *exercise-11-3.py*. Now modify *exercise-11-3.py*
    to match the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将进一步筛选练习 11-2 脚本的结果，仅搜索在华盛顿特区拍摄的视频。首先，复制 *exercise-11-2.py* 并将其重命名为 *exercise-11-3.py*。现在修改
    *exercise-11-3.py* 以匹配以下代码：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This code first defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function from [Listing 11-2](#list11-2) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    function from [Listing 11-3](#list11-3), importing the required <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    module at the top of the file. It will later use <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to
    _decimal()</samp> to convert GPS coordinates from the Parler video metadata into
    decimal format and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    to calculate the distance between that GPS coordinate and the center of Washington,
    DC.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码首先定义了来自[清单 11-2](#list11-2)的 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    函数和来自[清单 11-3](#list11-3)的 <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    函数，并在文件顶部导入了所需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp> 模块。随后，它将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    将 Parler 视频元数据中的 GPS 坐标转换为十进制格式，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    计算该 GPS 坐标与华盛顿特区中心之间的距离。
- en: Next, the code defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    function. This function takes a single argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>,
    which contains the Parler video metadata loaded from its JSON file. It returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if the GPS coordinates
    in that metadata are located inside Washington, DC, but otherwise returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    函数。该函数接受一个参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>，其中包含从
    Parler 视频的 JSON 文件加载的元数据。如果该元数据中的 GPS 坐标位于华盛顿特区内，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，否则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    function first defines the *x* and *y* coordinates you found for the city center
    in the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_x</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_y</samp>. Next, it defines the
    *x* and *y* coordinates of the Parler video, storing those values in the variables
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
    Since the GPS coordinates in the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> metadata
    fields aren’t in decimal format, it first passes those strings into the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> function
    to convert them from degrees, minutes, and seconds into decimals and then saves
    the return values into <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    函数首先在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_y</samp>
    中定义了你为城市中心找到的 *x* 和 *y* 坐标。接下来，它定义了 Parler 视频的 *x* 和 *y* 坐标，将这些值存储在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 中。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> 元数据字段中的 GPS
    坐标不是十进制格式，它首先将这些字符串传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    函数，将它们从度、分、秒转换为十进制，然后将返回值保存在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 中。
- en: 'Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function
    to determine the distance between these two points. The return value is this expression:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 函数来确定这两点之间的距离。返回值是以下表达式：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function
    returns a number representing the distance between the center of Washington, DC,
    and the location where the video was filmed. If that number is less than or equal
    to 0.25 (roughly 20 kilometers), the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>;
    otherwise, it evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    Thus, the <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    function returns a Boolean.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 函数返回一个表示华盛顿特区中心与视频拍摄地点之间距离的数字。如果这个数字小于或等于
    0.25（大约 20 公里），表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>；否则，值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    函数返回一个布尔值。
- en: With these functions defined at the top of the file, the remaining changes to
    the script are minimal. The code updates the docstring, since our script’s purpose
    has changed. It also updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement that checks whether or not an insurrection video was found. The version
    of this script from Exercise 11-2 just checked if the metadata included a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> field, but now it
    checks for the fields <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> as well.
    The videos with GPS coordinates contain all three of these fields. <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>
    is just a single field that contains both longitude and latitude. However, since
    you need separate values for longitude and latitude, it’s simpler to use the metadata
    fields that are already separated. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement confirms that the video was filmed in Washington, DC, by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc(metadata)</samp>.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部定义了这些功能后，脚本的剩余更改很小。代码更新了文档字符串，因为我们脚本的目的已经发生了变化。它还更新了检查是否找到了叛乱视频的<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句。第11-2练习中的版本仅检查元数据是否包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>字段，但现在它还会检查<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>字段。包含GPS坐标的视频包含这三个字段。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>只是一个包含经度和纬度的单一字段。然而，由于你需要分开处理经度和纬度的值，使用已经分开的元数据字段更为简便。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc(metadata)</samp>来确认视频是否是在华盛顿DC拍摄的。
- en: If all of these conditions are true—the metadata contains <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>; the metadata
    contains <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> with
    a value matching January 6, 2021; and the GPS coordinates in the metadata show
    that the video was filmed in Washington, DC—then the code displays a message saying
    it found an insurrection video and increments <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>.
    Finally, after the script has finished looping through all of the Parler metadata
    files, it displays the total number of insurrection videos found.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些条件都为真——元数据包含<samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>；元数据包含与2021年1月6日匹配的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>字段；并且元数据中的GPS坐标显示视频是在华盛顿DC拍摄的——那么代码将显示一条消息，表明它找到了一个叛乱视频，并递增<samp
    class="SANS_TheSansMonoCd_W5Regular_11">count</samp>。最后，在脚本完成遍历所有Parler元数据文件后，它将显示找到的叛乱视频的总数。
- en: 'You can find the final script in the book’s GitHub repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-3.py).
    Run your complete script now, making sure to pass in the correct path to your
    Parler *metadata* folder:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到最终脚本：[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-3.py)。现在运行你的完整脚本，确保传入正确的Parler
    *metadata*文件夹路径：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The script should find 1,202 insurrection videos. This means that out of the
    1,958 videos uploaded to Parler on January 6 that included GPS coordinates, at
    least 61 percent were videos of the insurrection itself. (It’s possible that more
    videos uploaded to Parler were also from the insurrection that day but just didn’t
    include GPS coordinates in their metadata.) Manually watching 1,202 Parler videos
    is still unpleasant, but at least it’s not as bad as watching 1,958.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本应该找到1,202个叛乱视频。这意味着在1月6日上传到Parler的1,958个包含GPS坐标的视频中，至少61%的视频是关于叛乱本身的。（也有可能上传到Parler的更多视频来自当天的叛乱，只是它们的元数据中没有包含GPS坐标。）手动观看1,202个Parler视频仍然是令人不愉快的，但至少比观看1,958个要好一些。
- en: You now know which of the Parler videos were from the January 6 insurrection,
    but you can draw even more interesting conclusions from this dataset (and others
    that contain similar location data) when you visualize the data on a map.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道哪些Parler视频来自1月6日的叛乱，但当你在地图上可视化数据时（以及其他包含类似位置数据的数据集），你还可以得出更多有趣的结论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Plotting GPS Coordinates on a Map with
    simplekml</samp>
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用simplekml在地图上绘制GPS坐标</samp>
- en: Rather than just displaying a list of insurrection video filenames, you could
    plot the locations of those videos on a map, allowing you to easily choose which
    videos you’d like to watch first. You could also map all Parler videos that contain
    GPS coordinates around the world, in case there are other newsworthy videos in
    this dataset that don’t relate to the January 6 insurrection. In this section,
    you’ll learn to write Python code to create a file of Parler location data that
    you can then upload to an online map service to visualize it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与其仅仅显示叛乱视频文件名的列表，你可以将这些视频的位置绘制在地图上，便于你轻松选择首先观看哪些视频。你还可以绘制所有包含全球GPS坐标的Parler视频，万一这个数据集中还有其他与1月6日叛乱无关但具有新闻价值的视频。在这一部分，你将学习如何编写Python代码来创建一个Parler位置数据文件，然后将其上传到在线地图服务以进行可视化。
- en: Google Earth ([*https://<wbr>earth<wbr>.google<wbr>.com*](https://earth.google.com))
    allows you to upload a file in Keyhole Markup Language (KML), a file format designed
    to describe geographical features such as points on a map. KML was created in
    2004 specifically for use with Google Earth, and it became a standard file format
    for describing geographic data in 2008.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Google Earth ([*https://<wbr>earth<wbr>.google<wbr>.com*](https://earth.google.com))允许你上传一个KML文件，这是一种用于描述地理特征（例如地图上的点）的文件格式。KML在2004年为Google
    Earth专门创建，并在2008年成为描述地理数据的标准文件格式。
- en: '[Listing 11-4](#list11-4) shows an example KML file.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-4](#list11-4) 显示了一个KML文件的示例。'
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: A file written
    in KML,</samp> <samp class="SANS_Futura_Std_Book_11">example.kml</samp>'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-4：一个用KML编写的文件，</samp>
    <samp class="SANS_Futura_Std_Book_11">example.kml</samp>
- en: 'As you can see, the KML format is similar to HTML. Both formats are extensions
    of XML, or Extensible Markup Language, so they share the same rules. The first
    line, starting with <samp class="SANS_TheSansMonoCd_W5Regular_11"><?xml</samp>,
    is called the XML prolog, and it defines some metadata about this file. The entire
    contents of the KML file are wrapped in a <samp class="SANS_TheSansMonoCd_W5Regular_11"><kml></samp>
    tag. Inside this is a <samp class="SANS_TheSansMonoCd_W5Regular_11"><Document></samp>
    tag, and inside this are one or more <samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp>
    tags. Each <samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp> represents
    a point on a map: its name, description, and GPS coordinates in decimal format.
    This example file describes a single point for New York City.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，KML格式与HTML类似。两者都是XML（可扩展标记语言）的扩展，因此共享相同的规则。第一行以<samp class="SANS_TheSansMonoCd_W5Regular_11"><?xml</samp>开头，被称为XML前导，它定义了该文件的一些元数据。KML文件的整个内容都被包裹在<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><kml></samp>标签中。在其中是一个<samp class="SANS_TheSansMonoCd_W5Regular_11"><Document></samp>标签，里面包含一个或多个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp>标签。每个<samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp>表示地图上的一个点：其名称、描述和以十进制度格式表示的GPS坐标。此示例文件描述了纽约市的一个单一位置。
- en: To plot GPS coordinates on Google Earth, you must generate a KML file that contains
    these coordinates and then upload it to the service. The simplest way to create
    KML files is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    Python module. You can use this module to create a new KML object, create a new
    point on it for each Parler video with GPS coordinates, and then save that KML
    object to a *.kml* file.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Google Earth上绘制GPS坐标，你必须生成一个包含这些坐标的KML文件，然后将其上传到服务中。创建KML文件的最简单方法是使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> Python模块。你可以使用这个模块为每个具有GPS坐标的Parler视频创建一个新的KML对象，并将其保存到一个*.kml*文件中。
- en: 'Install the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    module by running the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装<samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>模块：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now use the module in the Python interpreter to generate the *example .kml*
    file from [Listing 11-4](#list11-4):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在Python解释器中使用该模块从[清单 11-4](#list11-4)生成*示例 .kml*文件：
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    module, this code defines the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml</samp>
    variable as the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml.Kml()</samp>,
    which returns a KML object. It then uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml.newpoint()</samp>
    method to add GPS points to the KML file it’s creating. While this example just
    adds one point for New York City, with the description “The Big Apple,” you can
    add as many points as you want. Note that the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">coords</samp>
    argument must be a list of tuples, with each tuple containing longitude and latitude
    coordinates in decimal format. Finally, after adding points, the code saves the
    KML file by running <samp class="SANS_TheSansMonoCd_W5Regular_11">kml.save()</samp>
    and passes an output filename.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入<samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>模块后，这段代码将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kml</samp>变量的值定义为<samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml.Kml()</samp>的输出，该方法返回一个KML对象。接着，它使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kml.newpoint()</samp>方法向正在创建的KML文件中添加GPS坐标点。虽然这个示例仅添加了一个纽约市的点，描述为“纽约大苹果”，但你可以根据需要添加任意多个点。请注意，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">coords</samp>参数的值必须是一个元组列表，每个元组包含以十进制格式表示的经度和纬度坐标。最后，添加点之后，代码通过运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kml.save()</samp>并传递一个输出文件名来保存KML文件。
- en: You can find further documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    Python module at [*https://<wbr>simplekml<wbr>.readthedocs<wbr>.io*](https://simplekml.readthedocs.io).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*https://<wbr>simplekml<wbr>.readthedocs<wbr>.io*](https://simplekml.readthedocs.io)上找到有关<samp
    class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> Python模块的更多文档。
- en: You now know how to create KML files full of location data that can be mapped
    in Google Earth. As your final exercise in this chapter, you’ll generate KML files
    based on GPS coordinates in the Parler dataset.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道如何创建充满位置信息的KML文件，可以在Google Earth中进行映射。作为本章的最后一个练习，你将基于Parler数据集中的GPS坐标生成KML文件。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-4: Create KML Files to
    Visualize Location Data</samp>'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 11-4：创建KML文件以可视化位置信息</samp>
- en: 'So far, we’ve focused on finding Parler videos filmed in Washington, DC, during
    the January 6 insurrection. While this is undoubtedly the most newsworthy part
    of this dataset, there could be other things we’re missing. Parler is a global
    far-right social network. What other far-right videos did people post to it? Does
    it contain any interesting data from other countries, such as Russia? In this
    exercise, you’ll write a script that creates two KML files full of GPS coordinates
    from the Parler dataset to visualize in Google Earth:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于查找在1月6日叛乱期间拍摄的、位于华盛顿特区的Parler视频。虽然这无疑是这个数据集中最具新闻价值的部分，但可能还有其他我们遗漏的内容。Parler是一个全球性的极右翼社交网络。人们发布了哪些其他极右翼视频？它是否包含来自其他国家的有趣数据，比如俄罗斯？在这个练习中，你将编写一个脚本，从Parler数据集中创建两个包含GPS坐标的KML文件，以便在Google
    Earth中可视化：
- en: A *parler-videos-all.kml* file containing all videos with GPS coordinates
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含所有视频和GPS坐标的*parler-videos-all.kml*文件
- en: A *parler-videos-january6.kml* file containing videos with GPS coordinates filmed
    on January 6, 2021
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含2021年1月6日拍摄、具有GPS坐标的Parler视频的*parler-videos-january6.kml*文件
- en: This exercise will give you experience creating KML files and using Google Earth
    to visualize location data, a skill that will likely come in handy for any future
    dataset you come across that includes location data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将使你获得创建KML文件和使用Google Earth可视化位置信息的经验，这项技能对于你未来接触到包含位置信息的数据集可能会非常有用。
- en: 'You’ll base your script for this exercise off the script you wrote in Exercise
    11-3\. For a challenge, you can try programming your own script to meet the following
    requirements:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你将基于在练习11-3中编写的脚本来编写本练习的脚本。为了挑战自己，你可以尝试编写自己的脚本，以满足以下要求：
- en: Make this script accept an argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>,
    using Click. This will be the path to the *metadata* folder full of JSON files.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Click让这个脚本接受一个参数<samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>，这个参数将是包含JSON文件的*metadata*文件夹的路径。
- en: Import the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> module
    and create two KML objects (one for each KML file you’ll be creating). Loop through
    the Parler video metadata JSON files, and add different points to the appropriate
    KML objects depending on the metadata. Points for all videos should be added to
    *parler-videos-all.kml*, and points only for videos with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    of January 6, 2021, should be added to *parler-videos-january6.kml*.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> 模块并创建两个 KML
    对象（每个 KML 文件对应一个对象）。遍历 Parler 视频元数据 JSON 文件，根据元数据将不同的点添加到相应的 KML 对象中。所有视频的点应添加到
    *parler-videos-all.kml* 中，只有 2021 年 1 月 6 日的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    的视频的点应添加到 *parler-videos-january6.kml* 中。
- en: Give every point you add to a KML object a name, a description, and GPS coordinates
    in decimal format. The name should be the Parler video ID (for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HS34fpbzqg2b</samp>), and the description
    should be a string containing the video’s download link (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">https://data.ddosecrets.com/Parler/Videos/HS34fpbzqg2b</samp>)
    as well as important metadata fields such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTypeExtension</samp>, or others
    you’re interested in.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给你添加到 KML 对象的每个点命名、描述，并提供十进制格式的 GPS 坐标。名称应为 Parler 视频 ID（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">HS34fpbzqg2b</samp>），描述应包含视频的下载链接（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">https://data.ddosecrets.com/Parler/Videos/HS34fpbzqg2b</samp>）以及你感兴趣的重要元数据字段，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">FileTypeExtension</samp>
    等。
- en: Make your script loop through all of the metadata JSON files and filter them
    for videos that contain GPS coordinates.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的脚本遍历所有元数据 JSON 文件，并筛选出包含 GPS 坐标的视频。
- en: Alternatively, follow along with the instructions in the rest of this exercise.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，按照本练习中剩余部分的说明进行操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create a KML File
    for All Videos with GPS Coordinates</samp>
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为所有包含 GPS 坐标的视频创建
    KML 文件</samp>
- en: 'You’ll begin by writing a script to loop through all of the Parler metadata
    JSON files and add any GPS coordinates it finds to a single KML file, *parler
    -videos-all.kml*, including only the video URL in the description, not any metadata.
    Make a copy of the *exercise-11-3.py* script and name it *exercise-11-4.py*, then
    make the following modifications:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先编写一个脚本，遍历所有 Parler 元数据 JSON 文件，并将找到的任何 GPS 坐标添加到一个单一的 KML 文件中，*parler -videos-all.kml*，仅在描述中包含视频
    URL，而不包含任何元数据。复制 *exercise-11-3.py* 脚本并将其命名为 *exercise-11-4.py*，然后进行以下修改：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since you’re going to be mapping this data, you don’t need the code that detects
    if a video is in Washington, DC—you’ll be able to tell by zooming into Washington,
    DC. Therefore, this code deletes the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    functions from the previous script, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    import. The new code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp>
    module at the top of the file so that you can use it later in the script.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将要映射这些数据，你不需要检测视频是否位于华盛顿特区的代码——你可以通过缩放到华盛顿特区来判断。因此，这段代码删除了先前脚本中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp>
    函数，以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp> 导入。新代码在文件顶部导入了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> 模块，以便你稍后在脚本中使用它。
- en: Next, the code defines the function <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename_to_parler_id()</samp>.
    This function is only a single, complex line of code that takes the filename of
    a Parler metadata JSON file as an argument, then returns the Parler ID associated
    with that file. For example, say the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">meta-31VC1ufihFpa.json</samp>.
    In this case, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename.split("-")</samp>
    will evaluate to the list <samp class="SANS_TheSansMonoCd_W5Regular_11">['meta',
    '31VC1ufihFpa.json']</samp>. Since Python starts counting at zero, the code selects
    the second item in that list (the string <samp class="SANS_TheSansMonoCd_W5Regular_11">31VC1ufihFpa.json</samp>)
    by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp> to that expression,
    making it <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename .split("-")[1]</samp>.
    Next, it splits *that* string on the period character with the expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">json_filename.split("-")[1].split(".")</samp>,
    which returns the list <samp class="SANS_TheSansMonoCd_W5Regular_11">['31VC1ufihFpa',
    'json']</samp>. It then selects the first item in that list (the string <samp
    class="SANS_TheSansMonoCd_W5Regular_11">31VC1ufihFpa</samp>) by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp>
    to that expression, making it <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename
    .split("-")[1].split(".")[0]</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename_to_parler_id()</samp>
    function just returns the result of that expression, which is the Parler ID.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function,
    the code defines a new KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp>
    to contain all the GPS points found in the Parler metadata. The rest of this code
    should be familiar to you from Exercises 11-2 and 11-3\. It loops through the
    Parler *metadata* folder looking for JSON files, loading the JSON data for each
    file it finds into the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>
    variable. This time, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement ensures that the metadata dictionary contains the keys <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> and that
    those values aren’t blank.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code finds a Parler video that contains non-empty GPS fields, it sets
    up variables with the data it needs to add the point to the KML files: <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>. It defines <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> as the return value of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename _to_parler_id()</samp>
    function, meaning the name of the point will be the video’s Parler ID. It defines
    <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp> as the video’s
    download URL. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    function, it defines <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp> as the longitude
    and latitude, in decimal format, of the GPS coordinates found in the metadata.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码找到一个包含非空 GPS 字段的 Parler 视频时，它会设置变量以便将数据添加到 KML 文件中：<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">description</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>。它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    定义为 <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename _to_parler_id()</samp>
    函数的返回值，意味着点的名称将是视频的 Parler ID。它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    定义为视频的下载 URL。通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp>
    函数，它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>
    定义为在元数据中找到的 GPS 坐标的经度和纬度（十进制格式）。
- en: After defining these variables, the code runs <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all.newpoint()</samp>
    to add the GPS point to the KML object. It sets the point’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    its description to <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>,
    and its coordinates to a list of points; in this case, the list has only one point,
    a tuple containing <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>. Finally, when the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is complete, the code
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all.save()</samp>
    function to save all of these GPS points into the file *parler-videos-all.kml*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义这些变量后，代码运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all.newpoint()</samp>
    将 GPS 点添加到 KML 对象。它将点的名称设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>，描述设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>，坐标设置为包含点的列表；在这种情况下，列表中只有一个点，即包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>
    的元组。最后，当 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环完成时，代码调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kml_all.save()</samp> 函数，将所有这些 GPS 点保存到文件
    *parler-videos-all.kml* 中。
- en: 'Run the final script, changing the path in the argument to the path to your
    Parler *metadata* folder:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最终脚本，将参数中的路径更改为你 Parler *metadata* 文件夹的路径：
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Since the Parler dataset contains about 64,000 videos with GPS coordinates,
    the script should return about 64,000 lines of output, each including a video’s
    Parler ID, longitude, and latitude. When the script finishes running, it should
    also create a 20MB KML file called *parler-videos-all.kml* in the same folder
    as the script.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Parler 数据集包含大约 64,000 个带有 GPS 坐标的视频，因此脚本应返回大约 64,000 行输出，每行包括一个视频的 Parler
    ID、经度和纬度。当脚本运行完成后，它还应在与脚本相同的文件夹中创建一个大小为 20MB 的 KML 文件，名为*parler-videos-all.kml*。
- en: 'Open *parler-videos-all.kml* in a text editor. The file’s contents should look
    like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开*parler-videos-all.kml*。文件内容应如下所示：
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This file should contains 64,000 <samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp>
    tags, each representing a different Parler video with GPS coordinates.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件应包含 64,000 个 <samp class="SANS_TheSansMonoCd_W5Regular_11"><Placemark></samp>
    标签，每个标签代表一个不同的 Parler 视频及其 GPS 坐标。
- en: Now that you’ve created a KML file that contains *all* of the Parler location
    data, you’ll modify your script further to create a KML file with just the videos
    from January 6, 2021.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个包含*所有* Parler 位置信息的 KML 文件，你将进一步修改脚本，只创建包含 2021 年 1 月 6 日视频的 KML 文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create KML Files
    for Videos from January 6, 2021</samp>
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为 2021 年 1 月 6 日的视频创建
    KML 文件</samp>
- en: 'Your script so far has a KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp>,
    and the code adds all of the GPS points in the Parler metadata to it. Make the
    following changes to your code to create another KML object, <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>,
    and just add GPS points from videos filmed on January 6, 2021, to it. Since this
    script is getting long, I’ll quote just the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, the only part that is modified:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: At the top of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, this script adds another KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>.
    The code will add points to this file only from January 6, 2021\. Next, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop will loop through each
    Parler metadata file, parse the JSON, and determine whether or not it has GPS
    coordinates. If so, the code will prepare variables so it can add the point to
    the KML objects. But this time, instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    variable containing just the video’s download URL, it will also include metadata.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: When defining <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>,
    the code adds <samp class="SANS_TheSansMonoCd_W5Regular_11"><br></samp> at the
    end, which is the HTML tag for a line break. This way, when you visualize this
    KML file, the description will show the URL on the first line, and the metadata
    will start on the next line. The code then loops through a list of metadata keys
    to add to the description, including <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTypeExtension</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Duration</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Make</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Model</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Software</samp>.
    If there are any other pieces of metadata you’d like to include, feel free to
    add them to your script.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'In each loop, the code checks to see if the metadata for the current video
    includes that key, and if so, adds its value to <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>,
    inserting a line break after each piece of metadata. For example, if the code
    is looking at the JSON file *meta-g09yZZCplavI.json*, <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    will appear as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: (The actual value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    string will contain <samp class="SANS_TheSansMonoCd_W5Regular_11"><br></samp>
    for the line breaks, but this is how the description will look in Google Earth.)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code uses another <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to see if that video was created on January 6, 2021, and if so, adds
    that point to <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>.
    It does this by checking that the file has a <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>
    metadata field and that the date in that field is from January 6, 2021, just as
    you did in Exercise 11-2\. Finally, when the script finishes looping through all
    of the Parler videos, after saving the points in <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp>
    to *parler-videos-all.kml*, it also saves the points in <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>
    to *parler-videos-january6.kml*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the final script in the book’s GitHub repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-11<wbr>/exercise<wbr>-11<wbr>-4<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-4.py).
    Run your complete script like so:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When the script is finished running, it should have created two KML files:
    a 31MB file called *parler-videos-all.kml* (the file is bigger this time because
    the descriptions are longer) and a 929KB file called *parler-videos -january6.kml*.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve put in the hard work of generating KML files full of GPS coordinates,
    you can move on to the fun part: visualizing this data using Google Earth. This
    will allow you to scroll around the globe picking which videos you’d like to watch.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Visualizing Location Data with Google
    Earth</samp>
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to visualize location data in the KML files
    that you just created using Google Earth, marking each Parler video with a pin
    on a map. Not only will this let you visualize exactly where all of the videos
    with GPS coordinates were filmed, but this will also make it considerably simpler
    to download these videos to watch.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: When you created those KML files, you set the description for each Parler video
    to include its download URL. Once you load a KML file into Google Earth and turn
    it into pins on a map, you can click on a video’s pin to see its description and
    then click the link in the description to download the video. In a web browser,
    load Google Earth at [*https://<wbr>earth<wbr>.google<wbr>.com*](https://earth.google.com).
    (You don’t have to log in to a Google account, though doing so enables you to
    save your work and revisit it later.) In the menu bar on the left, choose **Projects**▸**Open**▸**Import
    KML File from Computer**. Browse for the *parler -videos-all.kml* file you created
    in the previous exercise and open it. When it’s done loading, click the pencil
    icon to edit the title of this project, name it *All Parler Videos*, and press
    ENTER. This should create a pin on the map for each Parler video in the entire
    dataset, labeled by its ID.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建这些 KML 文件时，你为每个 Parler 视频设置了包含下载 URL 的描述。一旦你将 KML 文件加载到 Google Earth 并将其转换为地图上的标记，你可以点击视频的标记查看其描述，然后点击描述中的链接下载视频。在网页浏览器中，加载
    Google Earth 网站 [*https://<wbr>earth<wbr>.google<wbr>.com*](https://earth.google.com)。（你无需登录
    Google 账户，但登录后可以保存你的工作并稍后访问。）在左侧菜单栏中，选择 **项目**▸**打开**▸**从计算机导入 KML 文件**。浏览到你在上一个练习中创建的
    *parler-videos-all.kml* 文件并打开它。加载完成后，点击铅笔图标编辑此项目的标题，将其命名为 *所有 Parler 视频*，然后按 ENTER
    键。这将为整个数据集中的每个 Parler 视频在地图上创建一个标记，标记上会显示其 ID。
- en: Repeat this process for *parler-videos-january6.kml*, and name this one **Parler
    Videos from January 6, 2021**. In the Projects panel on the left of the screen,
    you should see your two projects.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *parler-videos-january6.kml* 重复此过程，并将其命名为 **2021 年 1 月 6 日的 Parler 视频**。在屏幕左侧的项目面板中，你应该能看到你的两个项目。
- en: By clicking the eye icon, you can show and hide Google Earth projects to choose
    which KML files you want displayed. With the pins you want displayed, you can
    rotate the Earth and zoom in on whatever you’d like. You can double-click on the
    map, click the plus (+) button to zoom in, and click the minus (−) button to zoom
    out.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击眼睛图标，你可以显示和隐藏 Google Earth 项目，选择你想要显示的 KML 文件。选择好要显示的标记后，你可以旋转地球，放大任何你想要查看的区域。你可以双击地图，点击加号（+）按钮放大，点击减号（−）按钮缩小。
- en: For example, to investigate just the insurrection videos, show that project
    and hide the others. [Figure 11-6](#fig11-6) shows Google Earth zoomed in on the
    US Capitol building in Washington, DC, with just the videos from the January 6
    insurrection showing. The pins in the figure are all videos of the January 6 insurrection,
    and the pins located over the Capitol building itself are videos filmed by Trump
    supporters who were actively trespassing inside the US Capitol that day.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要仅调查暴乱视频，可以显示该项目并隐藏其他项目。[图 11-6](#fig11-6) 显示了 Google Earth 放大后的华盛顿特区的美国国会大厦，只有来自
    1 月 6 日暴乱的视频显示在其中。图中的标记都是 1 月 6 日暴乱的视频，而位于国会大厦上的标记是特朗普支持者在当天非法闯入美国国会时拍摄的视频。
- en: '![A screenshot of Google Earth focused on the US Capitol building, with only
    the insurrection videos showing.](Images/Figure11-6.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![一张截图，显示 Google Earth 放大了美国国会大厦，只有暴乱视频在显示。](Images/Figure11-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: Google Earth,
    focused on the US Capitol building, with pins at the GPS points in</samp> <samp
    class="SANS_Futura_Std_Book_11">parler-videos-january6.kml</samp>'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-6：Google Earth，聚焦于美国国会大厦，标记显示在</samp>
    <samp class="SANS_Futura_Std_Book_11">parler-videos-january6.kml</samp>
- en: When you find a video you’re interested in, click its pin to view its description.
    You should see the URL to download the video, and you can watch it using software
    like VLC Media Player.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你找到感兴趣的视频时，点击它的标记查看描述。你应该能看到视频的下载 URL，你可以使用如 VLC 媒体播放器等软件观看该视频。
- en: You can also use Google Earth to search for a location so you can see the individual
    pins there. For example, you could hide the Parler Videos from January 6, 2021,
    project and instead show pins for the All Parler Videos project, then search for
    *Moscow*. [Figure 11-7](#fig11-7) shows Google Earth zoomed in on the city of
    Moscow, Russia. As the figure indicates, only a handful of videos whose metadata
    included GPS coordinates were filmed there and uploaded to Parler.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Google Earth 搜索一个位置，以便查看该位置的单独标记。例如，你可以隐藏 2021 年 1 月 6 日的 Parler 视频项目，而展示
    All Parler Videos 项目的标记，然后搜索 *莫斯科*。[图 11-7](#fig11-7) 显示了 Google Earth 放大后的俄罗斯莫斯科市。如图所示，只有少数几个包含
    GPS 坐标的元数据的视频是在那里拍摄并上传到 Parler 的。
- en: '![A screenshot of Google Earth, zoomed into Moscow, with five pins.](Images/Figure11-7.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: Parler videos
    filmed in Moscow</samp>'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the pin for the video labeled *ykAXApWbiZuM*. You should see the following
    description:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, this video was filmed on June 28, 2020 (during the Black Lives
    Matter uprising), with an iPhone 7 Plus running iOS 13.5.1\. Right-click the link
    to see the option to download the video. This way, your web browser won’t try
    opening it directly in a new tab, where it might not display properly.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested, you can open the video file using VLC Media Player to
    watch it. In the recording, a tattooed American white supremacist who runs a Confederate-themed
    barber shop in Moscow goes on a racist and homophobic rant, in part explaining
    why he moved to Russia. “I voted Trump in office in 2016,” he said. “But the fact
    is, nothing’s gonna change. The fact is, all these Trump supporters in America
    all the time can’t see the real problem. Your real problem is fucking Jews in
    America.” [Figure 11-8](#fig11-8) shows a screenshot from the video where he’s
    telling Parler users that he’s a real white supremacist and not a liberal troll,
    as people were accusing him of being.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![A still from the Parler video of the American white supremacist in Moscow,
    in VLC Media Player.](Images/Figure11-8.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-8: A screenshot from
    a Parler video filmed by an American white supremacist in Moscow</samp>'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: He goes on to fantasize about mass shooting Black Lives Matter protesters. “I
    watch the news in America. I see all these fucking [N-word]s, antifa fucking scum.
    Ripping down the monuments. It angers me more than anything. What I don’t understand
    is where’s the fucking police to stop any of this?” he asks. “How come nobody’s
    shooting these motherfuckers? If I was in Los Angeles still, seeing all this rioting
    and looting going on, I’d be up on a motherfucking building with my AK-47 just
    spraying the fucking crowd.”
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious about the complete metadata from this video, you can check
    the original file at *meta-ykAXApWbiZuM.json*. If you wanted to see more videos
    posted by this Parler user, you could modify your script to filter videos that
    were filmed on the exact device by checking for the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Make</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Model</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Software</samp>
    fields. You might find some other users’ videos, but chances are you’ll also find
    more videos from this poster as well.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The media spent the bulk of its time focusing on Parler videos they knew were
    taken in Washington, DC, on the day of the insurrection. If you’re interested
    in further exploring this dataset, you might try to find videos from other far-right
    protests, or events with far-right counterprotesters. For example, you could create
    a KML file that includes the date ranges of the specific 2020 Black Lives Matters
    protests and explore those videos. You might find video evidence of other crimes.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Viewing Metadata with ExifTool</samp>
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When @donk_enby downloaded the Parler videos and extracted metadata from them
    in JSON format, she used a command line program called <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>.
    This program is one of the investigation tools I use most frequently, and this
    section explains how to use it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: If you run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> followed
    by a filepath, it will attempt to find metadata stored in that file and show it
    to you. It works on a variety of file formats, including Microsoft Office documents,
    PDFs, images, and videos. You can use it to find hidden information in the metadata
    of those documents, such as the author of a Word document, which type of phone
    or camera was used to take a photo, and much more.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    on the Parler videos since @donk_enby did it for you, but most of the time, you
    won’t be so lucky. If you want to search for hidden information in BlueLeaks documents,
    for example, you’d need to run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    on them yourself. In this subsection, to learn how <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    works, you’ll use it to view the metadata on one of the Parler videos in JSON
    format.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Mac users, install <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install exiftool</samp>
    command; users of Linux or Windows with WSL, install it with the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo
    apt install libimage-exiftool-perl</samp> command. In your terminal, change to
    the *videos* folder in your Parler dataset folder and use <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp>
    to download the Parler video with the ID *HS34fpbzqg2b*:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> to
    look at the metadata of a file by running <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename</samp>. Run it
    on the *HS34fpbzqg2b* file that you just downloaded with the following command:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output should show all the metadata for this video file:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Along with other information, the metadata shows that this video’s file extension
    is *.mov*, it was recorded using an iPhone XR running iOS 14.2 on January 6, 2021,
    at 1:57 PM, and it was filmed at the GPS coordinates 38 deg 53′ 26.52″ N, 77 deg
    0′ 28.44″ W.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the file extension for this video is *.mov*, rename it by running <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">mv HS34fpbzqg2b HS34fpbzqg2b.mov</samp>.
    You can open *HS34fpbzqg2b.mov* in a program like VLC Media Player just to see
    what it contains: police officers stepping out of the way while Trump supporters
    remove barricades surrounding the Capitol building.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'When @donk_enby used <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>
    to extract the metadata from the Parler videos, she used the <samp class="SANS_TheSansMonoCd_W5Regular_11">-json</samp>
    argument to extract it in JSON format. Here’s how you do that for *HS34fpbzqg2b*:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-json</samp> argument makes
    the output much easier to work with than <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>’s
    default output.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned about the secrets hidden in the metadata of
    over a million videos uploaded to Parler, many of them by insurrectionists filming
    themselves during the January 6 riot in Washington, DC. You’ve learned the syntax
    of the JSON file format and how to work with JSON data in your own Python scripts.
    You’ve written a series of scripts that filtered the list of a million videos
    down to just the ones that were, according to their metadata, filmed on January
    6, 2021, in Washington, DC, during the attack on the US Capitol by supporters
    of Donald Trump. You now have the skills necessary to write code that analyzes
    JSON in your own investigations. Finally, you’ve seen how you can convert GPS
    coordinates from degrees to decimal and plot them on a map, an invaluable skill
    for future investigations that involve location data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll explore one more technology that’s common in hacked
    and leaked datasets: SQL databases. You’ll use the SQL skills you learn to dig
    into the hacked databases of Epik, a hosting and domain name company that provides
    service to much of the American fascist movement.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
