["```\n#include <unistd.h>\n\npid_t `getpid`(void);\n```", "```\n#include <unistd.h>\n\npid_t `getppid`(void);\n```", "```\n`proc/mem_segments.c`\n#include <stdio.h>\n#include <stdlib.h>\n\nchar globBuf[65536];            /* Uninitialized data segment */\nint primes[] = { 2, 3, 5, 7 };  /* Initialized data segment */\n\nstatic int\nsquare(int x)                   /* Allocated in frame for square() */\n{\n    int result;                 /* Allocated in frame for square() */\n\n    result = x * x;\n    return result;              /* Return value passed via register */\n}\n\nstatic void\ndoCalc(int val)                 /* Allocated in frame for doCalc() */\n{\n    printf(\"The square of %d is %d\\n\", val, square(val));\n\n    if (val < 1000) {\n        int t;                  /* Allocated in frame for doCalc() */\n\n        t = val * val * val;\n        printf(\"The cube of %d is %d\\n\", val, t);\n    }\n}\n\nint\nmain(int argc, char *argv[])    /* Allocated in frame for main() */\n{\n    static int key = 9973;      /* Initialized data segment */\n    static char mbuf[10240000]; /* Uninitialized data segment */\n    char *p;                    /* Allocated in frame for main() */\n\n    p = malloc(1024);           /* Points to memory in heap segment */\n\n    doCalc(key);\n\n    exit(EXIT_SUCCESS);\n}\n      `proc/mem_segments.c`\n```", "```\nextern char etext, edata, end;\n        /* For example, &etext gives the address of the end\n           of the program text / start of initialized data */\n```", "```\n`proc/necho.c`\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int j;\n\n    for (j = 0; j < argc; j++)\n        printf(\"argv[%d] = %s\\n\", j, argv[j]);\n\n    exit(EXIT_SUCCESS);\n}\n      `proc/necho.c`\n```", "```\nchar **p;\n\nfor (p = argv; *p != NULL; p++)\n    puts(*p);\n```", "```\n$ `SHELL=/bin/bash`\n               *Create a shell variable*\n\n$ `export SHELL`\n                  *Put variable into shell process's environment*\n```", "```\n$ `export SHELL=/bin/bash`\n```", "```\n% `setenv SHELL /bin/bash`\n```", "```\n$ ``*`NAME=value`*`` ``*`program`*``\n```", "```\n$ `printenv`\nLOGNAME=mtk\nSHELL=/bin/bash\nHOME=/home/mtk\nPATH=/usr/local/bin:/usr/bin:/bin:.\nTERM=xterm\n```", "```\n`proc/display_env.c`\n#include \"tlpi_hdr.h\"\n\nextern char **environ;\n\nint\nmain(int argc, char *argv[])\n{\n    char **ep;\n\n    for (ep = environ; *ep != NULL; ep++)\n        puts(*ep);\n\n    exit(EXIT_SUCCESS);\n}\n      `proc/display_env.c`\n```", "```\nint main(int argc, char *argv[], char *envp[])\n```", "```\n#include <stdlib.h>\n\nchar *`getenv`(const char **name*);\n```", "```\n#include <stdlib.h>\n\nint `putenv`(char **string*);\n```", "```\n#include <stdlib.h>\nint `setenv`(const char **name*, const char **value*, int *overwrite*);\n```", "```\n#include <stdlib.h>\n\nint `unsetenv`(const char **name*);\n```", "```\nenviron = NULL;\n```", "```\n#define _BSD_SOURCE           /* Or: #define _SVID_SOURCE */\n#include <stdlib.h>\n\nint `clearenv`(void)\n```", "```\n$ `./modify_env \"GREET=Guten Tag\" SHELL=/bin/bash BYE=Ciao`\n\nGREET=Guten Tag\nSHELL=/bin/bash\n$ `./modify_env SHELL=/bin/sh BYE=byebye`\n\nSHELL=/bin/sh\nGREET=Hello world\n```", "```\nfor (ep = environ; *ep != NULL; ep++)\n    puts(*ep);\n```", "```\n     `proc/modify_env.c`\n#define _GNU_SOURCE     /* To get various declarations from <stdlib.h> */\n#include <stdlib.h>\n#include \"tlpi_hdr.h\"\n\nextern char **environ;\n\nint\nmain(int argc, char *argv[])\n{\n    int j;\n    char **ep;\n\n    clearenv();         /* Erase entire environment */\n\n    for (j = 1; j < argc; j++)\n        if (putenv(argv[j]) != 0)\n            errExit(\"putenv: %s\", argv[j]);\n\n    if (setenv(\"GREET\", \"Hello world\", 0) == -1)\n        errExit(\"setenv\");\n\n    unsetenv(\"BYE\");\n\n    for (ep = environ; *ep != NULL; ep++)\n        puts(*ep);\n\n    exit(EXIT_SUCCESS);\n}\n     `proc/modify_env.c`\n```", "```\n#include <setjmp.h>\n\nint `setjmp`(jmp_buf *env*);\n```", "```\nvoid `longjmp`(jmp_buf *env*, int *val*);\n```", "```\n$ `./longjmp`\n\nCalling f1() after initial setjmp()\nWe jumped back from f1()\n```", "```\n$ `./longjmp x`\n\nCalling f1() after initial setjmp()\nWe jumped back from f2()\n```", "```\n`proc/longjmp.c`\n#include <setjmp.h>\n#include \"tlpi_hdr.h\"\n\nstatic jmp_buf env;\n\nstatic void\nf2(void)\n{\n    longjmp(env, 2);\n}\n\nstatic void\nf1(int argc)\n{\n    if (argc == 1)\n        longjmp(env, 1);\n    f2();\n}\n\nint\nmain(int argc, char *argv[])\n{\n    switch (setjmp(env)) {\n    case 0:     /* This is the return after the initial setjmp() */\n        printf(\"Calling f1() after initial setjmp()\\n\");\n        f1(argc);               /* Never returns... */\n        break;                  /* ... but this is good form */\n\n    case 1:\n        printf(\"We jumped back from f1()\\n\");\n        break;\n\n    case 2:\n        printf(\"We jumped back from f2()\\n\");\n        break;\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `proc/longjmp.c`\n```", "```\ns = setjmp(env);                    /* WRONG! */\n```", "```\n`proc/setjmp_vars.c`\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\nstatic jmp_buf env;\n\nstatic void\ndoJump(int nvar, int rvar, int vvar)\n{\n    printf(\"Inside doJump(): nvar=%d rvar=%d vvar=%d\\n\", nvar, rvar, vvar);\n    longjmp(env, 1);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int nvar;\n    register int rvar;          /* Allocated in register if possible */\n    volatile int vvar;          /* See text */\n\n    nvar = 111;\n    rvar = 222;\n    vvar = 333;\n\n    if (setjmp(env) == 0) {     /* Code executed after setjmp() */\n        nvar = 777;\n        rvar = 888;\n        vvar = 999;\n        doJump(nvar, rvar, vvar);\n\n    } else {                    /* Code executed after longjmp() */\n\n        printf(\"After longjmp(): nvar=%d rvar=%d vvar=%d\\n\", nvar, rvar, vvar);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n\n      `proc/setjmp_vars.c`\n```", "```\n$ `cc -o setjmp_vars setjmp_vars.c`\n\n$ `./setjmp_vars`\n\nInside doJump(): nvar=777 rvar=888 vvar=999\nAfter longjmp(): nvar=777 rvar=888 vvar=999\n```", "```\n$ `cc -O -o setjmp_vars setjmp_vars.c`\n\n$ `./setjmp_vars`\n\nInside doJump(): nvar=777 rvar=888 vvar=999\nAfter longjmp(): nvar=111 rvar=222 vvar=999\n```", "```\n$ `cc -Wall -Wextra -O -o setjmp_vars setjmp_vars.c`\n\nsetjmp_vars.c: In function `main':\nsetjmp_vars.c:17: warning: variable `nvar' might be clobbered by `longjmp' or `vfork'\nsetjmp_vars.c:18: warning: variable `rvar' might be clobbered by `longjmp' or `vfork'\n```"]