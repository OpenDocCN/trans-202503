- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**FIGURING OUT WHAT’S TRUE AND FALSE WITH BOOLEANS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**用布尔值搞清楚什么是真的，什么是假的**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: 'You ask yes-or-no questions all the time: Is it raining? Is my hair too long?
    Once you know whether the answer is yes or no, you can decide what to do next:
    bring an umbrella, or not; trim your hair, or not. In all these situations, what
    you do depends on whether the answer to the question is yes or no. Deciding what
    to do based on the answer to a question is also important in programming. In this
    chapter, you’ll learn how to ask questions in Python.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你时常会问是非问题：在下雨吗？我的头发太长了吗？一旦你知道答案是“是”还是“否”，你就能决定接下来做什么：带伞，还是不带；修剪头发，还是不修剪。在所有这些情况下，你的行动取决于问题的答案是否为“是”或“否”。根据问题的答案来决定该做什么，在编程中也很重要。在本章中，你将学习如何在
    Python 中提问。
- en: In programming, the questions you ask are usually about comparing values. Is
    one value equal to another? Is a value bigger or smaller than another? The yes-or-no
    question is called a *condition*, and the answer isn’t *yes* or *no* but `True`
    or `False`. Say you ask the question “Do I have more gold blocks than my friend?”
    or, in other words, “Is my gold stash greater than my friend’s gold stash?” To
    make that question into a condition that Python can understand, we have to phrase
    it as a statement (such as “My gold stash is greater than my friend’s”) that can
    be true or false.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，你提出的问题通常是关于比较值的。一个值是否等于另一个值？一个值是否大于或小于另一个值？这种是非问题称为*条件*，其答案不是*是*或*否*，而是`True`或`False`。假设你问了这样一个问题：“我比我的朋友有更多的金块吗？”或者换句话说，“我的金矿比我朋友的金矿大吗？”为了让这个问题成为
    Python 能理解的条件，我们必须将其表述为一个可以为真或假的声明（例如：“我的金矿比我朋友的金矿大”）。
- en: 'Testing whether a condition is true or false is so useful in Python that there’s
    a special data type just for storing the values `True` and `False`. So far you’ve
    seen a few other data types: integer, float, and string data types. The data type
    that stores `True` and `False` values is the *Boolean* data type. Booleans can
    only be `True` or `False`. When you use Python to ask questions, the result is
    either `True` or `False`. When a condition is true or false, programmers say that
    it *evaluates to* `True` or *evaluates to* `False`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，测试一个条件是否为真或假是非常有用的，因此有一个专门的数据类型用来存储`True`和`False`这两个值。到目前为止，你已经看到过其他几种数据类型：整数、浮点数和字符串数据类型。用于存储`True`和`False`值的数据类型就是*布尔*数据类型。布尔值只能是`True`或`False`。当你在
    Python 中提问时，结果要么是`True`，要么是`False`。当一个条件为真或假时，程序员会说它*评估为*`True`或*评估为*`False`。
- en: In this chapter you’ll use Booleans, comparison operators, and logical operators
    to test different conditions involving values. Then you’ll be ready for [Chapter
    6](ch06.html#ch06), where you’ll use the answers to questions to make decisions
    about what to do next in a program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用布尔值、比较运算符和逻辑运算符来测试涉及值的不同条件。然后你将准备好进入[第6章](ch06.html#ch06)，在那里你将使用问题的答案来决定接下来在程序中该做什么。
- en: '**BOOLEAN BASICS**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔基础**'
- en: 'A Boolean is a bit like a light switch: it is either `True` (on) or `False`
    (off). In Python, you can declare a Boolean variable like this to represent that
    the light is on:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值有点像电灯开关：它要么是`True`（开），要么是`False`（关）。在 Python 中，你可以像这样声明一个布尔变量来表示灯亮着：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here you assign the value `True` to the variable `light`. To turn the light
    off, you could assign the value `False` to light:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将`True`的值赋给变量`light`，若要关闭灯光，可以将`False`的值赋给`light`：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Always capitalize the first letter of `True` and `False`. If you don’t, Python
    won’t recognize the value as a Boolean and will throw an exception instead of
    evaluating your calculation!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 始终大写`True`和`False`的首字母。如果不这样做，Python 将无法识别该值为布尔值，并会抛出异常，而不是评估你的计算！
- en: In the next mission, you’ll use Booleans to stop the player from smashing blocks
    in the game world.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个任务中，你将使用布尔值来阻止玩家在游戏世界中砸方块。
- en: '**MISSION #17: STOP SMASHING BLOCKS!**'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #17：停止砸方块！**'
- en: In Minecraft, it’s easy to smash blocks, which is great when you want to mine
    for resources. But it’s annoying to spend ages building a really cool structure
    and then accidentally smash and destroy it! In this mission, you’ll make your
    Minecraft world indestructible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Minecraft 中，砸方块很容易，当你想挖掘资源时这很棒。但当你花了很长时间建造一个非常酷的结构，然后不小心砸坏它时，就很让人烦恼！在这个任务中，你将使你的
    Minecraft 世界不可摧毁。
- en: By using `setting("world_immutable", True)` you can make blocks *immutable*,
    which means they can’t be changed. The `setting()` line of code is a function
    like the `setTilePos()` and `setPos()` functions you’ve seen. [Listing 5-1](ch05.html#ch5ex1)
    shows how to make the world immutable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`setting("world_immutable", True)`，你可以使方块*不可变*，这意味着它们无法被改变。`setting()`这行代码是一个函数，就像你之前看到的`setTilePos()`和`setPos()`函数一样。[列表
    5-1](ch05.html#ch5ex1)展示了如何使世界不可变。
- en: '*immutableOn.py*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*immutableOn.py*'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-1: Code that stops blocks from being broken*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：防止方块被破坏的代码*'
- en: The `setting()` function has options that you can set to `True` to turn them
    on. One of the options is `"world_immutable"`. To turn a `setting()` option on,
    you write `True` after the name of the setting inside the parentheses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`setting()`函数有一些选项，你可以将它们设置为`True`来启用它们。一个选项是`"world_immutable"`。要启用一个`setting()`选项，你只需在括号内写上`True`。'
- en: 'Type [Listing 5-1](ch05.html#ch5ex1) into IDLE and save it as *immutableOn.py*
    in a new folder called *booleans*. When you run it, you shouldn’t be able to smash
    most blocks, as shown in [Figure 5-1](ch05.html#ch5fig1). But what happens when
    you *do* want to break blocks again? Copy your program into a new file and change
    it to allow the player to smash blocks. (Hint: Use a Boolean!) Save the new file
    as *immutableOff.py* in the *booleans* folder.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDLE 中输入[列表 5-1](ch05.html#ch5ex1)并将其保存为*immutableOn.py*，放入名为*booleans*的新文件夹中。当你运行它时，大多数方块不应该被破坏，如[图
    5-1](ch05.html#ch5fig1)所示。但如果你*确实*想重新破坏方块呢？将你的程序复制到一个新文件中，并更改它，以允许玩家破坏方块。（提示：使用布尔值！）将新文件保存为*immutableOff.py*，放入*booleans*文件夹中。
- en: '![image](graphics/f05-01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-01.jpg)'
- en: '*Figure 5-1: No matter how hard I try, the block won’t break!*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：无论我多么努力，方块都不会破碎！*'
- en: '**CONCATENATING BOOLEANS**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**连接布尔值**'
- en: 'Like integers and floats, Booleans must be converted to strings before they
    can be concatenated. For example, you concatenate Booleans and strings when you
    want to output Booleans using the `print()` function. To do this, use the `str()`
    function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 像整数和浮点数一样，布尔值必须在连接之前转换为字符串。例如，当你想使用`print()`函数输出布尔值时，你会将布尔值与字符串连接。要做到这一点，使用`str()`函数：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `agree` variable stores a Boolean. It is converted to a string on the second
    line with `str(agree)`, concatenated to the `"I agree: "` string, and printed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`agree`变量存储一个布尔值。在第二行中，它被转换为字符串`str(agree)`，与`"I agree: "`字符串连接，并被打印出来。'
- en: '**COMPARATORS**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**比较符**'
- en: You are very good at comparing values. You know that 5 is greater than 2, 8
    and 8 are the same number, and 6 and 12 are not the same number. A computer is
    also good at comparing values; you just need to tell it exactly which kind of
    comparison you want by typing in a symbol called a *comparator*. For example,
    do you want it to check if one value is bigger than the other, or do you want
    it to check if it’s smaller?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你非常擅长比较值。你知道5大于2，8和8是相同的数字，6和12不是相同的数字。计算机也很擅长比较值；你只需要告诉它你想进行哪种比较，通过输入一个叫做*比较符*的符号。例如，你希望它检查一个值是否大于另一个，还是检查它是否更小？
- en: 'Comparators (or *comparison operators*) in Python let you compare data. Python
    uses six comparators:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 比较符（或*比较运算符*）在 Python 中允许你比较数据。Python 使用六个比较符：
- en: • Equal to (`==`)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: • 等于（`==`）
- en: • Not equal to (`!=`)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: • 不等于（`!=`）
- en: • Less than (`<`)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: • 小于（`<`）
- en: • Less than or equal to (`<=`)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: • 小于或等于（`<=`）
- en: • Greater than (`>`)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: • 大于（`>`）
- en: • Greater than or equal to (`>=`)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: • 大于或等于（`>=`）
- en: Each comparator returns a Boolean value (`True` or `False`) that states whether
    the condition has been met. Let’s look at these comparators and explore how to
    use them!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个比较符返回一个布尔值（`True` 或 `False`），表示条件是否成立。让我们来看看这些比较符，并探索如何使用它们！
- en: '**EQUAL TO**'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**等于**'
- en: When you want to find out whether two values are the same, you can use the equal
    to comparator (`==`). When the values are the same, the comparison returns the
    Boolean value `True`. When the values are different, the comparison returns `False`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想找出两个值是否相同时，可以使用等于比较符（`==`）。当值相同，比较结果返回布尔值`True`。当值不同，比较结果返回`False`。
- en: 'For example, let’s assign the value of two variables and then use the equal
    to operator to compare them:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为两个变量赋值，然后使用等于运算符来比较它们：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result is `True` because the values of the `length` and `width` variables
    are the same.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`True`，因为`length`和`width`变量的值相同。
- en: 'But if they are different, the result is `False`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果它们不同，结果是`False`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can use the equal to comparator on all variable types: strings, integers,
    floats, and Booleans.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对所有变量类型使用等于比较器：字符串、整数、浮动数值和布尔值。
- en: Notice how I used `==` to compare `length` and `width` instead of `=`, which
    is used to set a variable. Python uses the `==` operator to tell the difference
    between a comparison (asking whether two values are equal) and setting a variable
    (making a variable equal some value). Try to remember this difference to avoid
    bugs in your code. Don’t worry; even I make the mistake of using `=` instead of
    `==` once in a while!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我是如何使用`==`来比较`length`和`width`的，而不是使用`=`，后者用于设置变量。Python使用`==`运算符来区分比较（询问两个值是否相等）和设置变量（使一个变量等于某个值）。记住这个区别可以避免代码中的bug。别担心，甚至我有时也会犯用`=`而不是`==`的错误！
- en: '**MISSION #18: AM I SWIMMING?**'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #18: 我在游泳吗？**'
- en: Now you’ll use comparators to make a program that states whether or not you’re
    standing in water. The results will be posted to Minecraft chat.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用比较器制作一个程序，显示你是否站在水中。结果将会显示在Minecraft聊天框里。
- en: 'To find out the block type at certain coordinates, you’ll use the `getBlock()`
    function. This function takes coordinates as three arguments and returns the block
    type as an integer. For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找特定坐标的方块类型，你将使用`getBlock()`函数。这个函数以三个坐标作为参数，返回一个整数表示方块类型。例如：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, I stored the result of `mc.getBlock(10, 18, 13)` in a variable called
    `blockType`. If the block type at coordinates (10, 18, 13) is melon (block value
    103), the `blockType` variable will hold a value of 103.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将`mc.getBlock(10, 18, 13)`的结果存储在名为`blockType`的变量中。如果坐标(10, 18, 13)处的方块是甜瓜（方块值103），那么`blockType`变量的值将是103。
- en: Let’s put the `getBlock()` function to work. [Listing 5-2](ch05.html#ch5ex2)
    checks whether the player is standing on dry land.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来使用`getBlock()`函数。[列表 5-2](ch05.html#ch5ex2)检查玩家是否站在干燥的土地上。
- en: '*swimming.py*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*swimming.py*'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-2: This code checks the block type where the player’s legs are.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：这段代码检查玩家双腿所在的方块类型。*'
- en: Here, I get the three coordinates of the player’s position and pass those coordinates
    as arguments to `getBlock()`. I store the result of `mc.getBlock(x, y, z)` in
    `blockType`. The expression `blockType == 0` checks whether the block is air;
    if it is air, you know you’re just standing somewhere in your Minecraft world,
    the expression is `True`, and `True` is posted to chat. If it’s not air, `False`
    is posted to chat, so you must be underwater or maybe drowning in sand!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我获取了玩家位置的三个坐标，并将这些坐标作为参数传递给`getBlock()`。我将`mc.getBlock(x, y, z)`的结果存储在`blockType`中。表达式`blockType
    == 0`检查方块是否为空气；如果是空气，你知道自己只是在Minecraft世界中的某个地方站着，表达式为`True`，`True`会显示在聊天框里。如果不是空气，`False`会显示在聊天框里，那你一定是在水下或者可能被沙子淹没！
- en: Copy [Listing 5-2](ch05.html#ch5ex2) and save it as *swimming.py* in the *[Chapter
    5](ch05.html#ch05)* directory. Then change the code so it checks whether the player
    is standing in water (block type 9) and run it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 复制[列表 5-2](ch05.html#ch5ex2)并将其保存为*swimming.py*文件在*[第5章](ch05.html#ch05)*目录下。然后修改代码，使其检查玩家是否站在水中（方块类型9），并运行它。
- en: Try standing in water and running the program. Make sure that when the player
    is in water, the chat displays `True`. When the player isn’t in water, the chat
    should display `False`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试站在水中并运行程序。确保当玩家在水中时，聊天框显示`True`。当玩家不在水中时，聊天框应该显示`False`。
- en: The output of the program should look like [Figure 5-2](ch05.html#ch5fig2).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出应该像[图5-2](ch05.html#ch5fig2)一样。
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At this point, you will not be able to run this program continuously. You
    must run the program every time you want to check the block below the player.
    This applies to all the other missions in this chapter as well.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*此时，你将无法持续运行这个程序。每次你想检查玩家下方的方块时，都必须重新运行程序。这同样适用于本章的其他任务。*'
- en: '![image](graphics/f05-02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f05-02.jpg)'
- en: '*Figure 5-2: Although I can see that I am standing in water, Python kindly
    confirms this.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2：尽管我可以看到自己站在水中，Python也很贴心地确认了这一点。*'
- en: '**BONUS OBJECTIVE: I’M FLYING!**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：我在飞行！**'
- en: With a couple of changes to the code, you can check whether the block *below*
    you is air. This would tell you that you’re flying or jumping. How would you do
    this?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行一些修改，你可以检查你脚下的方块是否为空气。这可以告诉你你是在飞行还是跳跃。你会怎么做呢？
- en: '**NOT EQUAL TO**'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**不等于**'
- en: The not equal to comparator is the opposite of the equal to comparator. Instead
    of checking whether two values are the same, it checks whether they are different.
    When the two values are different, the comparison evaluates to `True`. When they
    are the same, it evaluates to `False`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于比较器是等于比较器的相反操作。它不是检查两个值是否相同，而是检查它们是否不同。当两个值不同时，比较结果为`True`；当它们相同时，结果为`False`。
- en: 'Say you want to make sure that an object is a rectangle but not a square. Because
    a non-square rectangle has a different length and width, you could write a comparison
    to check that the length and width are not equal:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想确保一个物体是矩形但不是正方形。因为非正方形矩形的长度和宽度不同，你可以写一个比较来检查长度和宽度是否不相等：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `width != length` expression asks whether the values of `width` and `length`
    are different.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`width != length`表达式询问`width`和`length`的值是否不同。'
- en: The result of this comparison is `True` because the `width` variable and the
    `length` variable have different values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较的结果为`True`，因为`width`变量和`length`变量的值不同。
- en: 'But if these values are the same, the comparison returns `False`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这些值相同，比较结果将返回`False`：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The not equal to comparator also works with strings, integers, floats, and Booleans,
    just like the equal to comparator.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于比较器同样适用于字符串、整数、浮点数和布尔值，就像等于比较器一样。
- en: '**MISSION #19: AM I STANDING IN SOMETHING OTHER THAN AIR?**'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #19：我站的不是空气吗？**'
- en: 'Let’s say you want to check whether you’re standing in something other than
    air, such as water, lava, dirt, gravel, or any other type of block. In [Mission
    #18](ch05.html#ch05lev2sec03), you checked whether the block at your current position
    was air, and you worked out how to check whether you were standing in water. You
    could copy and paste the program many times, changing it slightly each time to
    check for lava, dirt, gravel, and so on, one by one. But that would be very boring.
    Instead, use the not equal to comparator to check whether you’re underground,
    trapped in sand, at the bottom of the ocean, or even drowning in lava!'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你想检查自己是否站在除了空气之外的某种物体上，比如水、岩浆、泥土、砾石或其他类型的方块。在[任务 #18](ch05.html#ch05lev2sec03)中，你检查了当前位置的方块是否是空气，并且你也已经学会了如何检查自己是否站在水中。你可以将程序复制粘贴多次，每次稍作修改，来检查是否是岩浆、泥土、砾石等。但是这样做会很枯燥。相反，你可以使用不等于比较器来检查自己是否在地下、是否被困在沙子中、是否处于海底，甚至是否正在岩浆中溺水！'
- en: 'Open the program from [Mission #18](ch05.html#ch05lev2sec03) (*swimming.py*)
    and save it as *notAir.py* in the *booleans* folder. Delete the last line of the
    program and replace it with [Listing 5-3](ch05.html#ch5ex3).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '打开[任务 #18](ch05.html#ch05lev2sec03)中的程序（*swimming.py*），并将其保存为*notAir.py*到*booleans*文件夹中。删除程序的最后一行，并用[列表
    5-3](ch05.html#ch5ex3)替换。'
- en: '*notAir.py*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*notAir.py*'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-3: Changes to the swimming program*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：游泳程序的更改*'
- en: The last line of this code will print whether you’re not standing in air. The
    result of the comparison is stored in the `notAir` variable ➊. When the comparison
    evaluates to `True`, the value of the `notAir` variable will be `True`, and when
    the comparison evaluates to `False`, the value of the `notAir` variable will be
    `False`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最后一行将打印出你是否没有站在空气中的信息。比较的结果存储在`notAir`变量中 ➊。当比较结果为`True`时，`notAir`变量的值为`True`；当比较结果为`False`时，`notAir`变量的值为`False`。
- en: But the comparison on the first line isn’t quite right ➊. It currently checks
    whether the `blockType` is equal to air using the equal to comparator (`==`).
    Instead it should check whether the `blockType` variable is not equal to air using
    the not equal to comparator (`!=`). Change the first line to use the not equal
    to comparator instead of the equal to comparator. This will check whether the
    block at the player’s current position is not equal to air.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是第一行的比较有点问题 ➊。它当前检查`blockType`是否等于空气，使用的是等于比较器（`==`）。实际上，应该使用不等于比较器（`!=`）来检查`blockType`变量是否不等于空气。将第一行改成使用不等于比较器，而不是等于比较器。这样可以检查玩家当前位置的方块是否不是空气。
- en: When you run the program, make sure it works when you’re standing in air and
    when you’re underwater, in lava, in gravel, in sand, or teleported into the ground.
    The message posted to the chat when the condition is `True` is shown in [Figure
    5-3](ch05.html#ch5fig3).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时，确保它在你站在空气中、在水下、在岩浆中、在砾石中、在沙子中，或者被传送到地下时都能正常工作。当条件为`True`时，显示在聊天中的消息如[图
    5-3](ch05.html#ch5fig3)所示。
- en: '![image](graphics/f05-03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-03.jpg)'
- en: '*Figure 5-3: Just taking a nice, relaxing swim in some water, which is not
    air.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-3：在水里悠闲地游泳，而水不是空气。*'
- en: '**GREATER THAN AND LESS THAN**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于和小于**'
- en: When you need to figure out whether one value is bigger than another, you use
    the greater than comparator. The greater than comparator will return `True` when
    the value on the left is greater than the value on the right. If the value on
    the left is less than or the same as the value on the right, the comparison will
    return `False`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要判断一个值是否大于另一个值时，使用大于比较器。大于比较器会在左边的值大于右边的值时返回`True`。如果左边的值小于或等于右边的值，则比较会返回`False`。
- en: 'Say we have a minecart that can’t lift more than 99 blocks of obsidian. As
    long our minecart’s lifting limit is greater than the number of obsidian blocks
    it’s trying to lift, the blocks can be lifted:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一辆矿车，最多只能提升99块黑曜石。只要矿车的提升限制大于它试图提升的黑曜石块数，它就能提升这些块：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Brilliant! Our minecart can carry any number of obsidian blocks that is less
    than 100, and 99 is less than 100, so `limit > obsidian` evaluates to `True`.
    But what if someone adds another block of obsidian to the pile?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的矿车可以运载任何少于100块黑曜石的数量，而99小于100，所以`limit > obsidian`评估为`True`。但如果有人往堆里加了一块黑曜石会怎样？
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Oh no, now the limit has been reached! The result is now `False`: 100 is not
    greater than 100; it’s the same. Our minecart can’t lift the obsidian.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，现在已经达到限制了！结果变成了`False`：100不大于100，它们相等。我们的矿车无法提升黑曜石。
- en: The less than comparator works the same way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 小于比较器的工作方式相同。
- en: 'A van driving under a bridge needs to know whether it’s small enough to fit
    under it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一辆车驶过桥下时，需要知道它是否足够小，能够通过桥下：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this case, the van will fit because it’s smaller than the bridge height:
    8 is less than 12\. Later in its journey, the same van might encounter another
    bridge that is too low to drive under:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，车子能通过桥下，因为它的高度小于桥的高度：8小于12。后来在旅程中，同样的车可能会遇到一个过低的桥，无法通过：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because 8 is not less than 7, the result is `False`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为8不是小于7，所以结果是`False`。
- en: '**GREATER THAN OR EQUAL TO AND LESS THAN OR EQUAL TO**'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**大于或等于和小于或等于**'
- en: Like the greater than comparator, the greater than or equal to comparator determines
    whether one value is greater than another. Unlike the greater than comparator,
    it will also evaluate to `True` if the values are the same.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与大于比较器类似，大于或等于比较器确定一个值是否大于另一个值。与大于比较器不同，如果两个值相等，它也会评估为`True`。
- en: 'Let’s say I’m giving stickers to all the people who came to see my amazing
    program presentation. I need to check whether I have enough stickers for everyone:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我正在给所有来看我精彩的程序展示的人发贴纸。我需要检查是否有足够的贴纸分发给每个人：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I have enough stickers: 30 is the same as 30, so `stickers >= people` evaluates
    to `True`. But say one of my friends thinks the stickers look cool and wants one.
    Now, 31 people want stickers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我有足够的贴纸：30等于30，所以`stickers >= people`评估为`True`。但是假设我的朋友觉得这些贴纸很酷，想要一张。现在，31个人想要贴纸：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I don’t have enough stickers: 30 is not greater than or equal to 31\. It looks
    like my friend can’t have a sticker.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有足够的贴纸：30不大于或等于31。看起来我的朋友不能得到贴纸。
- en: By now, you’re ready to tackle almost any comparison. While you’re at IDLE,
    try out the less than or equal to comparator (`<=`) to see how it works, too.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经准备好解决几乎任何比较问题了。当你在IDLE时，试试“小于或等于”比较器（`<=`），看看它是如何工作的。
- en: '**NOTE**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The greater than, greater than or equal to, less than, and less than or equal
    to comparators don’t work with strings, although they do work with integers, floats,
    and Booleans.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*大于、大于或等于、小于和小于或等于比较器不能用于字符串，尽管它们可以用于整数、浮点数和布尔值。*'
- en: '**MISSION #20: AM I ABOVE THE GROUND?**'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务#20：我在地面上吗？**'
- en: The y-coordinate of a player in Minecraft shows how high they are in the game.
    Blocks are also stored using coordinates, which allows you to get the block types
    at specific coordinates using `getBlock()` and to create blocks at specific coordinates
    using `setBlocks()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft中玩家的y坐标显示他们在游戏中的高度。方块也使用坐标存储，这使得你可以使用`getBlock()`获取特定坐标处的方块类型，并使用`setBlocks()`在特定坐标处创建方块。
- en: To get the highest block in Minecraft, you can use the `getHeight()` function.
    The function takes an x- and z-coordinate and returns the y-coordinate for the
    highest block at that position, as shown in [Listing 5-4](ch05.html#ch5ex4).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Minecraft中的最高方块，你可以使用`getHeight()`函数。该函数接受x和z坐标并返回该位置的最高方块的y坐标，如[清单 5-4](ch05.html#ch5ex4)所示。
- en: '*aboveGround.py*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*aboveGround.py*'
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-4: Code to find the y-coordinate of the highest block at the player’s
    current location*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4: 查找玩家当前位置上方块的y坐标的代码*'
- en: This program gets the current position of the player, gets the y-coordinate
    for the highest block at the player’s position, and then posts this value to Minecraft
    chat.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序获取玩家的当前位置信息，获取玩家当前位置上方块的y坐标，然后将这个值发布到Minecraft聊天中。
- en: By combining this program with a greater than or equal to comparator, you can
    check whether or not the player is above the ground. Let’s do that now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个程序与大于或等于比较器结合，你可以检查玩家是否在地面上。现在我们来做这个。
- en: 'Copy the program in [Listing 5-4](ch05.html#ch5ex4) and save it as *aboveGround.py*.
    Change the program to check whether the player’s y-coordinate is greater than
    the `highestBlockY` variable. Then, add code to post the result to chat in the
    format of `"The player is above the ground: True/False"`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 复制[清单 5-4](ch05.html#ch5ex4)中的程序，并将其保存为*aboveGround.py*。修改程序以检查玩家的y坐标是否大于`highestBlockY`变量。然后，添加代码以将结果以“玩家是否在地面上：True/False”的格式发布到聊天中。
- en: '**HINT**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*Remember that you can store the result of a comparison in a variable. For
    example, if I wanted to check whether* `y` *is greater than or equal to 10 and
    store the answer in a variable called* `highEnough`, *I would use the following
    statement:* `highEnough = y >= 10`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，你可以将比较的结果存储在变量中。例如，如果我想检查* `y` *是否大于或等于10，并将结果存储在一个名为* `highEnough` *的变量中，我会使用以下语句：*
    `highEnough = y >= 10`。'
- en: Run the program when you’ve made these changes. The output for the program’s
    `False` outcomes are shown in [Figure 5-4](ch05.html#ch5fig4).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，运行程序。程序的`False`输出结果显示在[图 5-4](ch05.html#ch5fig4)中。
- en: '![image](graphics/f05-04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-04.jpg)'
- en: '*Figure 5-4: Now I’m in a cave, so Python is very much correct that I’m not
    above ground.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4: 现在我在一个洞穴里，所以Python的判断是正确的，我并不在地面上。*'
- en: '**MISSION #21: AM I CLOSE TO HOME?**'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #21: 我离家很近吗？**'
- en: As you wander around the Minecraft world, you might get lost and forget where
    your home is. You could wander for hours only to discover you were close to home
    when you first lost your way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Minecraft的世界里四处游荡时，可能会迷路，忘记自己家在哪。你可能会走几个小时，最终发现最初迷路时离家很近。
- en: With a single line of code, you can check how far you are from any coordinates
    in the game. For example, you could use the coordinates of your house and your
    current position to calculate how far away you are. By adding a comparator, you
    can also check whether or not you are within a certain number of blocks from your
    house. We’ll say you’re close to home if you’re only 40 blocks away.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一行代码，你可以检查自己距离游戏中任意坐标的远近。例如，你可以使用你家的坐标和当前位置来计算自己距离家有多远。通过添加比较器，你还可以检查自己是否距离家在某个特定的范围内。如果你距离家只有40个方块，那么我们就认为你离家很近。
- en: Let’s write a Python program to check this for you! The code for this mission
    should check how far you are from your house, as shown in [Listing 5-5](ch05.html#ch5ex5).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个Python程序来为你检查！这个任务的代码应该检查你离家有多远，如[清单 5-5](ch05.html#ch5ex5)所示。
- en: '*farFromHome.py*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*farFromHome.py*'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-5: Code that outputs the distance to your house*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-5: 输出你家距离的代码*'
- en: This code assumes your house is at the coordinates `x = 10` and `z = 10`, which
    are set with the `homeX` and `homeZ` variables ➊. In this case, we don’t need
    to know about the y-coordinate. I use the `getTilePos()` function to get the player’s
    position and set the `x` and `z` values.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码假设你家的坐标为`x = 10`和`z = 10`，这些值通过`homeX`和`homeZ`变量设置➊。在这种情况下，我们不需要关心y坐标。我使用`getTilePos()`函数获取玩家的位置并设置`x`和`z`值。
- en: To calculate the `distance` variable, we use a formula called the *Pythagorean
    theorem*. It calculates the length of a side of a right triangle, and you can
    use it in Minecraft to work out the distance between two points. You may have
    seen this formula written in math class as *a*² + *b*² = *c*², where *a* and *b*
    are the two legs of a right triangle, and *c* is the hypotenuse of the triangle,
    as shown in [Figure 5-5](ch05.html#ch5fig5). At ➋, we’re solving for *c*, which
    is represented by the variable `distance`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算`distance`变量，我们使用一种叫做*勾股定理*的公式。它计算直角三角形一边的长度，你可以在Minecraft中使用它来计算两点之间的距离。你可能在数学课上见过这个公式，形式是*a*²
    + *b*² = *c*²，其中*a*和*b*是直角三角形的两条直角边，*c*是斜边，正如[图 5-5](ch05.html#ch5fig5)所示。在➋处，我们正在求解*c*，它由变量`distance`表示。
- en: Save [Listing 5-5](ch05.html#ch5ex5) as *farFromHome.py* in the *booleans* folder.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 5-5](ch05.html#ch5ex5)保存为*farFromHome.py*，并放在*booleans*文件夹中。
- en: 'To finish the program, use a less than or equal to comparator to check whether
    the value of the `distance` variable is less than or equal to 40 and post the
    result to chat in the format of `"Your house is nearby: True/False"` ➌. Use concatenation
    to combine the string with the result of the comparison. Update the contents of
    the `postToChat()` ➌ function to output the string.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '为了完成程序，使用小于或等于比较符检查`distance`变量的值是否小于或等于40，并将结果以`"Your house is nearby: True/False"`的格式发布到聊天中
    ➌。使用连接运算符将字符串与比较结果结合起来。更新`postToChat()` ➌函数的内容以输出该字符串。'
- en: '![image](graphics/f05-05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-05.jpg)'
- en: '*Figure 5-5: A right triangle*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：直角三角形*'
- en: Test the program. When you are within 40 blocks of your house, you should receive
    a `True` message; when you aren’t within 40 blocks, you should see a `False` message.
    [Figure 5-6](ch05.html#ch5fig6) shows the program in operation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 测试程序。当你离家不超过40格时，应该收到`True`消息；当你距离超过40格时，应该看到`False`消息。[图 5-6](ch05.html#ch5fig6)展示了程序的运行效果。
- en: '![image](graphics/f05-06.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-06.jpg)'
- en: '*Figure 5-6: I’m definitely within 40 blocks of my house. In fact, there’s
    the front door!*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：我肯定在离家40格以内。事实上，那就是前门！*'
- en: '**LOGICAL OPERATORS**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**逻辑运算符**'
- en: 'Combining two or more comparators is often necessary in programs. You might
    want to determine whether two conditions are `True`: for example, you might want
    a car that is red *and* costs less than $10,000.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，组合两个或更多比较符是常见的需求。你可能想要判断两个条件是否都为`True`：例如，你可能想要一辆红色的车*并且*价格低于10,000美元。
- en: 'To combine two or more comparators, you use *logical operators*. Like comparators,
    you can use logical operators anywhere that you would use a Boolean value. Logical
    operators are also called *Boolean operators*. You’ll learn about three kinds
    of logical operators: `and`, `or`, and `not`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要组合两个或更多的比较符，你可以使用*逻辑运算符*。与比较符一样，逻辑运算符可以在任何需要布尔值的地方使用。逻辑运算符也被称为*布尔运算符*。你将学习三种类型的逻辑运算符：`and`、`or`和`not`。
- en: '**AND**'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**AND**'
- en: Use the `and` operator when you want to check whether two comparisons are both
    `True`. For an expression with an `and` operator to be `True`, both comparisons
    must be `True`. If either comparison is `False`, the statement will return `False`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要检查两个比较结果是否都为`True`时，使用`and`运算符。对于一个包含`and`运算符的表达式，要想结果为`True`，两个比较必须都为`True`。如果其中一个比较为`False`，整个语句的结果将为`False`。
- en: 'Say I want to find out whether a person is older than 18 and owns a car. I
    might write the following program:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想要判断一个人是否年满18岁且拥有汽车。我可能会写出以下程序：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we’re combining two comparators at ➊ and ➋ with `and`. Because the age
    of the person is greater than 18 (`age > 18` evaluates to `True`) and they own
    a car (`ownsCar == True`), the entire expression `age > 18 and ownsCar == True`
    evaluates to `True`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在➊和➋处使用`and`组合了两个比较符。因为这个人的年龄大于18岁（`age > 18`的结果为`True`），并且他们拥有一辆车（`ownsCar
    == True`），所以整个表达式`age > 18 and ownsCar == True`的结果为`True`。
- en: 'If one of these comparisons was `False`, the statement would evaluate to `False`.
    Say the person doesn’t own a car but is older than 18:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个比较结果是`False`，语句的结果将为`False`。假设这个人没有车但年满18岁：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `age > 18` evaluates to `True` and `ownsCar == True` evaluates to `False`,
    making the entire expression `False`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`age > 18`的结果为`True`，而`ownsCar == True`的结果为`False`，因此整个表达式的结果为`False`。
- en: '[Table 5-1](ch05.html#ch5tab01) summarizes the results of all of the possible
    Boolean combinations and results when using the `and` operator.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-1](ch05.html#ch5tab01)总结了使用`and`运算符时所有可能的布尔组合及其结果。'
- en: '**Table 5-1:** The Different Combinations of `True` and `False` with the `and`
    Operator'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** 使用`and`运算符的`True`和`False`的不同组合'
- en: '| **Comparison A** | **Comparison B** | **A and B** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **比较 A** | **比较 B** | **A 和 B** |'
- en: '| --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| TRUE | TRUE | TRUE |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 真 | 真 |'
- en: '| TRUE | FALSE | FALSE |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 真 | 假 | 假 |'
- en: '| FALSE | TRUE | FALSE |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 真 | 假 |'
- en: '| FALSE | FALSE | FALSE |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 假 | 假 | 假 |'
- en: '**MISSION #22: AM I ENTIRELY UNDERWATER?**'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #22：我完全在水下吗？**'
- en: 'In [Mission #18](ch05.html#ch05lev2sec03) ([page 85](ch05.html#page_85)), you
    checked whether the player was swimming. The program returned `True` or `False`
    depending on whether the block at the player’s current position was equal to water.
    That told you whether the player’s legs were underwater, but it would give the
    same result whether or not the player’s head was underwater. How would you check
    whether both the player’s legs and head were underwater?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在[任务 #18](ch05.html#ch05lev2sec03)（[第85页](ch05.html#page_85)），你检查了玩家是否在游泳。程序根据玩家当前位置的方块是否为水返回`True`或`False`。这告诉你玩家的腿是否在水下，但无论玩家头是否在水下，结果都是一样的。那么，你如何检查玩家的腿和头是否都在水下呢？'
- en: With a few simple changes to include an `and` operator, the *swimming.py* program
    can check whether the player’s legs and head are underwater. Open *swimming.py*
    and save it as *underwater.py*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些简单的修改，添加`and`运算符，*swimming.py*程序就可以检查玩家的腿和头是否在水下。打开*swimming.py*并保存为*underwater.py*。
- en: 'Make the following changes so the program checks whether the player is entirely
    underwater:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 进行以下更改，使程序检查玩家是否完全在水下：
- en: Add a second variable that checks the block type at the player’s `y` position
    `+ 1`. This variable stores the block type at the player’s head. Call this variable
    `blockType2`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个变量，检查玩家在`y`坐标位置`+ 1`的方块类型。该变量存储玩家头部上方的方块类型。将此变量命名为`blockType2`。
- en: Check whether `blockType` is equal to water and whether `blockType2` is equal
    to water.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`blockType`是否等于水，以及`blockType2`是否等于水。
- en: 'Post the result of the comparison to chat with this message: `"The player is
    underwater: True/False"`.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将比较结果通过此消息发送到聊天：“玩家是否在水下：True/False”。
- en: '**HINT**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*To check whether* `blockType` *and* `blockType2` *are equal to water, you
    can use the* `and` *operator. First, you check whether* `blockType` *is equal
    to water with the expression* `blockType == 9`. *Second, you check whether* `blockType2`
    *is equal to water with the expression* `blockType2 == 9`. *To combine the two,
    you put an* `and` *operator in the middle, like this:* `blockType == 9 and blockType2
    == 9`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*要检查* `blockType` *和* `blockType2` *是否都等于水，你可以使用* `and` *运算符。首先，你可以使用表达式* `blockType
    == 9` *检查* `blockType` *是否等于水。然后，使用表达式* `blockType2 == 9` *检查* `blockType2` *是否等于水。为了将这两者结合，你可以在中间加上`and`运算符，像这样：*
    `blockType == 9 and blockType2 == 9`。'
- en: When you run the program, make sure you test that it works in all three cases
    (when the player is above the water, when only the player’s legs are in the water,
    and when they’re entirely under the water). [Figure 5-7](ch05.html#ch5fig7) shows
    an example of the program working.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时，请确保测试它在所有三种情况中的表现（当玩家在水面上方时，当只有玩家的腿在水下时，以及当玩家完全在水下时）。[图 5-7](ch05.html#ch5fig7)显示了程序工作的示例。
- en: '![image](graphics/f05-07.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-07.jpg)'
- en: '*Figure 5-7: The player is under the water, running along the seafloor.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：玩家在水下，沿着海底前进。*'
- en: '**BONUS OBJECTIVE: AM I IN A TUNNEL?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：我在隧道里吗？**'
- en: Check whether the player is or isn’t in a dirt tunnel or a cobblestone tunnel.
    To do this, you’ll need to check the blocks above and below the player.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检查玩家是否处于泥土隧道或鹅卵石隧道中。为此，你需要检查玩家上方和下方的方块。
- en: '**OR**'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**或**'
- en: The `or` operator works differently than `and`. When either or both comparisons
    are `True`, the `or` expression will return `True`. As long as one comparison
    is `True`, the expression will still be `True`. But if neither comparison is `True`,
    the expression will evaluate to `False`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`运算符的工作方式与`and`不同。当任一或两者比较结果为`True`时，`or`表达式将返回`True`。只要有一个比较为`True`，表达式就为`True`。但是，如果两个比较都不为`True`，表达式将评估为`False`。'
- en: 'Let’s say I want to adopt a cat that is either black or orange in color. I
    could use the following code to get user input, and then see if the value of the
    string is either `"black"` or `"orange"`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想领养一只黑色或橙色的猫。我可以使用以下代码获取用户输入，然后检查字符串的值是否为`"black"`或`"orange"`：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As long as the `catColor` is either `"black"` or `"orange"`, I’ll adopt it.
    But if it’s a different color, like `"gray"`, `myCatNow` would be `False` and
    I wouldn’t adopt the cat.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 `catColor` 是 `"black"` 或 `"orange"`，我就会收养它。但如果它是其他颜色，比如 `"gray"`，那么 `myCatNow`
    就会是 `False`，我就不会收养这只猫。
- en: '[Table 5-2](ch05.html#ch5tab02) contains all of the possible combinations and
    results of using the `or` operator with Booleans.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-2](ch05.html#ch5tab02) 包含了使用 `or` 运算符与布尔值结合时的所有可能组合及其结果。'
- en: '**Table 5-2:** The Different Combinations of `True` and `False` with the `or`
    Operator'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2：** 使用 `or` 运算符时 `True` 和 `False` 的不同组合'
- en: '| **Comparison A** | **Comparison B** | **A or B** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **比较 A** | **比较 B** | **A 或 B** |'
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| TRUE | TRUE | TRUE |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | TRUE | TRUE |'
- en: '| TRUE | FALSE | TRUE |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | FALSE | TRUE |'
- en: '| FALSE | TRUE | TRUE |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | TRUE | TRUE |'
- en: '| FALSE | FALSE | FALSE |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | FALSE | FALSE |'
- en: '**MISSION #23: AM I IN A TREE?**'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #23：我在树中吗？**'
- en: The programs you’ve created so far in this chapter have displayed `True` or
    `False` depending on whether the player is standing on or in a particular block
    type. But what if you wanted to check whether the player is in a tree? How would
    you do this? Because trees are made of wood and leaves, you’d have to check whether
    the player is standing on wood *or* leaves.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你创建的程序会根据玩家是否站在某个特定的方块类型上，显示 `True` 或 `False`。但如果你想检查玩家是否在树中呢？该怎么做呢？因为树是由木材和树叶组成的，所以你需要检查玩家是否站在木材*或*树叶上。
- en: Let’s write a program. Open *swimming.py* again and save it as a new program
    called *inTree.py*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个程序。再次打开 *swimming.py* 文件，并将其另存为名为 *inTree.py* 的新程序。
- en: Change the program so it checks the type of block that is one block below the
    player. You’ll want to use the `or` operator to check whether the block below
    the player is leaves (block type 18) or wood (block type 11), then post the result
    to chat.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 修改程序，使其检查玩家下方一个方块的类型。你需要使用 `or` 运算符来检查玩家下方的方块是树叶（方块类型 18）还是木材（方块类型 11），然后将结果发布到聊天中。
- en: Recall that you can check the block below the player using `y = y - 1`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以使用 `y = y - 1` 来检查玩家下方的方块。
- en: '**NOTE**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although trees and leaves both come in different colors, all trees share the
    same block ID, and all leaves share the same block ID. (The only exceptions are
    Acacia and Dark Oak wood and leaves, which are a different block type. For now,
    let’s just ignore Acacia and Dark Oak.) The color is set using a second value,
    which you’ll learn about in a later chapter.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管树和树叶有不同的颜色，但所有树木共享相同的方块 ID，所有树叶也共享相同的方块 ID。（唯一的例外是金合欢和深色橡木木材与树叶，它们属于不同的方块类型。暂时我们忽略金合欢和深色橡木。）颜色是通过一个第二个值设置的，稍后的章节你将学习如何使用它。*'
- en: When you run the program, you should see the same output as in [Figure 5-8](ch05.html#ch5fig8).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该会看到与 [图 5-8](ch05.html#ch5fig8) 中相同的输出。
- en: '![image](graphics/f05-08.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-08.jpg)'
- en: '*Figure 5-8: I’m in a tree.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：我在树中。*'
- en: '**NOT**'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**NOT**'
- en: The `not` operator is quite a bit different from the `and` and `or` operators.
    It’s used on a single Boolean value or comparison and simply changes its value
    to the opposite.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 运算符与 `and` 和 `or` 运算符有些不同。它用于单一的布尔值或比较，并简单地将其值反转。'
- en: 'In other words, `not` changes `True` to `False` and `False` to `True`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`not` 会将 `True` 改为 `False`，将 `False` 改为 `True`：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `not` operator is handy when you start combining it with other logical operators.
    Let’s assign the value of `timeForBed` if you’re `not hungry` and you are `sleepy`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始将 `not` 运算符与其他逻辑运算符结合使用时，它非常有用。让我们在你 `不饿` 且 `困` 时给 `timeForBed` 赋值。
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `not` operator only applies to the Boolean it is in front of. Here it reverses
    the value of the `hungry` variable and leaves the `sleepy` variable alone. Because
    we set `hungry` to `False` earlier, writing `not hungry` now changes the value
    to `True`. The value of `sleepy` is `True`. Both values are now `True`, so `timeForBed`
    is `True`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 运算符只对它前面的布尔值起作用。这里，它反转了 `hungry` 变量的值，同时保持 `sleepy` 变量不变。因为我们之前把 `hungry`
    设置为 `False`，所以写 `not hungry` 会将其值变为 `True`。`sleepy` 的值是 `True`。现在两个值都为 `True`，因此
    `timeForBed` 为 `True`。'
- en: '**MISSION #24: IS THIS BLOCK NOT A MELON?**'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #24：这个方块不是西瓜吗？**'
- en: You’re hungry and want to know whether you have food at home. Your favorite
    food is melon, which you always store in the same space in your house. But you
    can’t remember if you have any melon left, and you need to decide whether to get
    food on your way home.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你饿了，想知道家里是否有食物。你最喜欢的食物是西瓜，你总是把它存放在家里的同一个地方。但你不记得家里是否还有西瓜了，所以你需要决定回家的路上是否要买些食物。
- en: Thankfully, you’re learning Python! With a bit of brain power, you can write
    a Python program to check whether you have a melon at home.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你在学习Python！只需一点脑力，就能写出一个Python程序来检查你家里是否有瓜。
- en: In this mission, you’ll create a program that says whether or not you need to
    find food before you return to your Minecraft house. The program will check whether
    there is a melon at certain coordinates. The coordinates you’ll check are up to
    you—they could be in your house, on your farm, or anywhere you might decide to
    keep some melon. Placing a melon at these coordinates is also up to you.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，你将创建一个程序来判断在回到你的Minecraft房子之前，是否需要找食物。程序会检查某些坐标处是否有瓜。你检查的坐标由你决定——它们可以在你的房子里，农场上，或你决定放置瓜的任何地方。在这些坐标上放置瓜也由你决定。
- en: Copy [Listing 5-6](ch05.html#ch5ex6) and save it as *notAMelon.py*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 复制[清单 5-6](ch05.html#ch5ex6)并将其保存为*notAMelon.py*。
- en: '*notAMelon.py*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*notAMelon.py*'
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-6: The start of the code to check whether there is a melon at a
    specific location*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6：检查特定位置是否有瓜的代码开头*'
- en: The code is meant to check whether the block at a specific position is a melon
    block. I’ve included a variable called `melon` that stores the block ID of a melon
    (103) ➊, and I’ve called the `getBlock()` method and stored the result in a variable
    called `block` ➋. To complete this program, you need to finish the line at ➌ that
    checks whether the `melon` variable is not equal to the `block` variable. The
    result should be stored in the `noMelon` variable so that it can be output to
    the Minecraft chat on the last line ➍.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是用来检查特定位置的块是否是瓜块。我包含了一个名为`melon`的变量，用来存储瓜的块ID（103）➊，并调用了`getBlock()`方法，将结果存储在名为`block`的变量中➋。为了完成这个程序，你需要完成➌这一行，检查`melon`变量是否与`block`变量不相等。结果应该存储在`noMelon`变量中，以便在最后一行输出到Minecraft聊天窗口中
    ➍。
- en: 'You can write the check ➌ to see if the `melon` and `block` variables are not
    equal in two ways: you can use the not equal to comparator or the `not` logical
    operator. Although the program will work either way, try using the `not` logical
    operator for this program.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式编写检查➌，看看`melon`和`block`变量是否不相等：你可以使用不等于比较符号或`not`逻辑运算符。尽管程序两种方式都能运行，但尝试使用`not`逻辑运算符来编写这个程序。
- en: Run the program when you’ve made the changes. The result should look something
    like [Figure 5-9](ch05.html#ch5fig9).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成更改后，运行程序。结果应该类似于[图 5-9](ch05.html#ch5fig9)。
- en: '![image](graphics/f05-09.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-09.jpg)'
- en: '*Figure 5-9: There’s a melon on my farm, so I don’t need to find some other
    food.*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：我的农场上有一个瓜，所以我不需要再找其他食物。*'
- en: '**BONUS OBJECTIVE: A WELL-STOCKED LARDER**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励目标：储藏丰富的食品柜**'
- en: Change the block type that the program checks for. You could check if corn is
    growing on your farm or if someone’s stolen your front door.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更改程序检查的块类型。你可以检查你的农场上是否有玉米，或者有人是否偷走了你的前门。
- en: '**LOGICAL OPERATOR ORDER**'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**逻辑运算符顺序**'
- en: 'You can combine as many logical operators as you want in a single statement.
    For example, here’s a pretty fancy combination using `and`, `or`, and `not`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个语句中组合任意多个逻辑运算符。例如，这里有一个非常复杂的组合，使用了`and`、`or`和`not`：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code evaluates to `True`. Are you surprised? In this example, the `not
    False` part of the statement is evaluated first to `True`. This is equivalent
    to:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结果是`True`。你感到惊讶吗？在这个例子中，语句中的`not False`部分首先被计算为`True`。这相当于：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `and` is then evaluated, and `True and True` evaluates to `True`, which
    is equivalent to:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后评估`and`，`True and True`的结果是`True`，这相当于：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, the `or` is evaluated, so `True or False` becomes `True`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，评估`or`，所以`True or False`的结果是`True`。
- en: 'When Python evaluates logical operators, it uses a certain order. If you get
    the order wrong, you might get a result you weren’t expecting! Here’s what Python
    evaluates first, second, and third:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python评估逻辑运算符时，它有一定的顺序。如果你搞错了顺序，可能会得到你意料之外的结果！以下是Python的评估顺序：
- en: '`not`'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`not`'
- en: '`and`'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`or`'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`or`'
- en: Practice creating statements with logical operators in IDLE and see if you can
    guess the result of each.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 练习在IDLE中创建带有逻辑运算符的语句，看看你能否猜出每个语句的结果。
- en: '**IS MY NUMBER BETWEEN TWO OTHERS?**'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**我的数字是否介于两个数之间？**'
- en: 'Often, you’ll want to check whether a value is less than one value and greater
    than another. Let’s imagine you wanted to make sure that you had between 10 and
    20 wolves, because you love wolves and want more than 10, but 20 or more might
    cause problems as you’d run out of food. You could test for this condition by
    using an `and` operator:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会想检查一个值是否小于一个值且大于另一个值。假设你想确保你有10到20只狼，因为你喜欢狼并且希望有超过10只，但20只或更多可能会造成问题，因为你会吃光食物。你可以使用`and`运算符来测试这个条件：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But you could also do it another way. Instead of using the `and` operator,
    write the variable once in the middle of two comparisons:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以用另一种方法来做。你可以不使用`and`运算符，而是将变量写在两个比较运算符之间：
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you run either of these programs and enter a number between 10 and 20 but
    not equal to either, then `enoughWolves` will be `True`. You can do the same using
    the greater than or equal to operators (`>=`) and the less than or equal to operators
    (`<=`):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这些程序中的任何一个，并输入一个介于10和20之间但不等于这两个值的数字，则`enoughWolves`将为`True`。你也可以使用大于等于运算符（`>=`）和小于等于运算符（`<=`）来实现相同的效果：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, entering 10 or 20 would also give `enoughWolves` a value of `True`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入10或20也会使`enoughWolves`的值为`True`。
- en: '**MISSION #25: AM I IN THE HOUSE?**'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #25：我在房子里吗？**'
- en: With Python code, you can make cool actions happen when you walk onto a certain
    area on the map. You could make a secret door open when the player walks onto
    a specific block, or you could trap them in a box when they walk over a trap.
    In this mission, I’ll show you how to detect if someone is in your Minecraft house.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python代码，你可以在玩家走到地图上的某个区域时让一些酷炫的动作发生。你可以让一个秘密门在玩家走到某个特定方块时打开，或者当他们走过陷阱时将他们困在箱子里。在这个任务中，我将向你展示如何检测一个人是否在你的Minecraft房子里。
- en: 'In [Mission #8](ch03.html#ch03lev2sec07) ([page 55](ch03.html#page_55)), you
    created a program that automatically builds the walls, ceiling, and floor of a
    building. You saved the program as *building.py* in the *math* folder. Open this
    program.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '在[任务 #8](ch03.html#ch03lev2sec07)（[第55页](ch03.html#page_55)），你创建了一个自动构建建筑物的墙壁、天花板和地板的程序。你将该程序保存在*math*文件夹中的*building.py*中。现在打开这个程序。'
- en: Read the code in the *building.py* program and make a note of the values of
    the `width`, `height`, and `length` variables (by default the values were `10`,
    `5`, and `6`, respectively). Also, write down the coordinates that you are currently
    standing at. Run the building program to build a house.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读*building.py*程序中的代码，并记录`width`、`height`和`length`变量的值（默认情况下，这些值分别为`10`、`5`和`6`）。同时，写下你当前站立的坐标。运行建筑程序来建造一座房子。
- en: Now that you’ve created a building, we can write a program like [Listing 5-7](ch05.html#ch5ex7)
    that checks whether the player is standing inside it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经建好了一个建筑物，我们可以编写一个像[清单 5-7](ch05.html#ch5ex7)那样的程序，来检查玩家是否站在建筑物内部。
- en: '*insideHouse.py*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*insideHouse.py*'
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-7: The start of the program to check whether the player is inside
    their house*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-7：检查玩家是否在房子内的程序开头*'
- en: '[Listing 5-7](ch05.html#ch5ex7) is supposed to check that the player’s x-coordinate
    is within the building created by *building.py*, but the program isn’t finished!
    Your job is to make sure the program also checks the y- and z-coordinates against
    the coordinates of the house that you built with the *building.py* program.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-7](ch05.html#ch5ex7)应该检查玩家的x坐标是否在*building.py*创建的建筑物内，但程序尚未完成！你的任务是确保程序还检查y和z坐标，确保它们在你使用*building.py*程序建造的房子的坐标范围内。'
- en: Copy [Listing 5-7](ch05.html#ch5ex7) into a new file and save it as *insideHouse.py*.
    You’ll complete the program so it checks whether the player is inside the building.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 5-7](ch05.html#ch5ex7)复制到一个新文件中，并将其保存为*insideHouse.py*。你将完成该程序，使其检查玩家是否在建筑物内部。
- en: 'To complete the program, do the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序，执行以下操作：
- en: Add the coordinates of the building (these are the coordinates you were standing
    at when you ran the *building.py* program) ➊.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加建筑物的坐标（这些坐标是你运行*building.py*程序时站立的位置）➊。
- en: Correct the `width`, `height`, and `length` variables if they are different
    from the ones used in your *building.py* program ➋.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`width`、`height`和`length`变量与*building.py*程序中使用的值不同，请修正它们➋。
- en: Complete the comparison for the `inside` variable so it checks whether the player’s
    coordinates are inside the building. The first part, to check whether the x position
    is in the house, has been done for you ➌. You need to add the comparisons for
    the y and z positions. The expressions are similar to the one that I’ve included
    for the x position (`buildX < x < buildX + width`).
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成对`inside`变量的比较，以检查玩家的坐标是否在建筑物内。第一部分，用于检查x坐标是否在房子内，已经为你完成 ➌。你需要添加y和z坐标的比较。表达式与我为x坐标所写的类似（`buildX
    < x < buildX + width`）。
- en: Post the value of the `inside` variable to the chat.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`inside`变量的值发布到聊天中。
- en: When you’ve made the changes, save and run the program. You should see output
    similar to [Figure 5-10](ch05.html#ch5fig10).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成更改后，保存并运行程序。你应该看到类似[图 5-10](ch05.html#ch5fig10)的输出。
- en: '![image](graphics/f05-10.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f05-10.jpg)'
- en: '*Figure 5-10: I’m in my bedroom, which is indeed inside my house.*'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 5-10：我在我的卧室，确实是在我的房子里。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you used Booleans, comparators, and logical operators to answer
    questions in your programs. In [Chapter 6](ch06.html#ch06), you’ll write programs
    that make decisions based on the answers to these questions. You’ll check whether
    a condition is true or not, and you’ll tell the program to run some code if the
    condition is true or run different code if it’s false. In [Chapter 7](ch07.html#ch07),
    your programs will keep running a piece of code as long as a condition is true
    and stop if the condition becomes false. This is the real power of Booleans and
    comparators. They help you control which code gets run in your program and exactly
    when the code gets run.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用了布尔值、比较器和逻辑运算符来回答程序中的问题。在[第6章](ch06.html#ch06)，你将编写根据这些问题的答案做出决策的程序。你将检查一个条件是否为真，并告诉程序如果条件为真就运行某段代码，或者如果条件为假则运行另一段代码。在[第7章](ch07.html#ch07)，你的程序将在条件为真时持续运行某段代码，直到条件变为假时停止运行。这就是布尔值和比较器的真正威力。它们帮助你控制程序中哪段代码被执行，以及何时被执行。
