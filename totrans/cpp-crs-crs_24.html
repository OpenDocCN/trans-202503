<html><head></head><body>
<h2 class="h2" id="ch21"><span epub:type="pagebreak" id="page_690"/><span epub:type="pagebreak" id="page_691"/><strong><span class="big">21</span><br/>WRITING APPLICATIONS</strong></h2>&#13;
<p class="quote"><em>For a bunch of hairless apes, we’ve actually managed to invent some pretty incredible things.<br/>—Ernest Cline</em>, Ready Player One</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter contains a potpourri of important topics that will add to your practical understanding of C++ by teaching you the basics of building real-world applications. It begins with a discussion of program support built into C++ that allows you to interact with the application life cycle. Next, you’ll learn about Boost ProgramOptions, an excellent library for developing console applications. It contains facilities to accept input from users without your having to reinvent the wheel. Additionally, you’ll learn some special topics about the preprocessor and compiler that you’ll likely come across when building an application whose source exceeds a single file.</p>&#13;
<h3 class="h3" id="ch21lev1sec1"><span epub:type="pagebreak" id="page_692"/><strong>Program Support</strong></h3>&#13;
<p class="noindent">Sometimes your programs need to interact with your operating environment’s application life cycle. This section covers three major categories of such interactions:</p>&#13;
<ul>&#13;
<li class="noindent">Handling program termination and cleanup</li>&#13;
<li class="noindent">Communicating with the environment</li>&#13;
<li class="noindent">Managing operating system signals</li>&#13;
</ul>&#13;
<p class="indent">To help illustrate the various facilities in this section, you’ll use <a href="ch21.xhtml#ch21ex01">Listing 21-1</a> as a framework. It uses a spruced up analog to the <code>Tracer</code> class from <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> in <a href="ch04.xhtml#ch04">Chapter 4</a> to help track which objects get cleaned up in various program termination scenarios.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer { <span class="ent">➊</span>&#13;
  Tracer(std::string name_in)&#13;
    : name{ std::move(name_in) } {&#13;
    std::cout &lt;&lt; name &lt;&lt; " constructed.\n";&#13;
  }&#13;
  ~Tracer() {&#13;
    std::cout &lt;&lt; name &lt;&lt; " destructed.\n";&#13;
  }&#13;
private:&#13;
  const std::string name;&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" }; <span class="ent">➋</span>&#13;
&#13;
void run() { <span class="ent">➌</span>&#13;
  std::cout &lt;&lt; "Entering run()\n";&#13;
  // ...&#13;
  std::cout &lt;&lt; "Exiting run()\n";&#13;
}&#13;
&#13;
int main() {&#13;
  std::cout &lt;&lt; "Entering main()\n"; <span class="ent">➍</span>&#13;
  Tracer local_tracer{ "local Tracer" }; <span class="ent">➎</span>&#13;
  thread_local Tracer thread_local_tracer{ "thread_local Tracer" }; <span class="ent">➏</span>&#13;
  const auto* dynamic_tracer = new Tracer{ "dynamic Tracer" }; <span class="ent">➐</span>&#13;
  run(); <span class="ent">➑</span>&#13;
  delete dynamic_tracer; <span class="ent">➒</span>&#13;
  std::cout &lt;&lt; "Exiting main()\n"; <span class="ent">➓</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed. <span class="ent">➋</span></span>&#13;
<span class="color1">Entering main() <span class="ent">➍</span></span>&#13;
<span class="color1">local Tracer constructed. <span class="ent">➎</span></span>&#13;
<span class="color1">thread_local Tracer constructed. <span class="ent">➏</span></span>&#13;
<span class="color1">dynamic Tracer constructed. <span class="ent">➐</span></span>&#13;
<span epub:type="pagebreak" id="page_693"/><span class="color1">Entering run() <span class="ent">➑</span></span>&#13;
<span class="color1">Exiting run() <span class="ent">➑</span></span>&#13;
<span class="color1">dynamic Tracer destructed. <span class="ent">➒</span></span>&#13;
<span class="color1">Exiting main() <span class="ent">➓</span></span>&#13;
<span class="color1">local Tracer destructed. <span class="ent">➎</span></span>&#13;
<span class="color1">thread_local Tracer destructed. <span class="ent">➏</span></span>&#13;
<span class="color1">static Tracer destructed. <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch21ex01"/><em>Listing 21-1: A framework for investigating program termination and cleanup facilities</em></p>&#13;
<p class="indent">First, you declare a <code>Tracer</code> class that accepts an arbitrary <code>std::string</code> tag and reports to stdout when the <code>Tracer</code> object is constructed and destructed <span class="ent">➊</span>. Next, you declare a <code>Tracer</code> with static storage duration <span class="ent">➋</span>. The <code>run</code> function reports when the program has entered and exited it <span class="ent">➌</span>. In the middle is a single comment that you’ll replace with other code in the sections that follow. Within <code>main</code>, you make an announcement <span class="ent">➍</span>; initialize <code>Tracer</code> objects with local <span class="ent">➎</span>, thread-local <span class="ent">➏</span>, and dynamic <span class="ent">➐</span> storage duration; and invoke <code>run</code> <span class="ent">➑</span>. Then you delete the dynamic Tracer object <span class="ent">➒</span> and announce that you’re about to return from <code>main</code> <span class="ent">➓</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>If any of the <a href="ch21.xhtml#ch21ex01">Listing 21-1</a> output is surprising, please review “An Object’s Storage Duration” on <a href="ch04.xhtml#page_89">page 89</a> before proceeding!</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch21lev2sec1"><strong><em>Handling Program Termination and Cleanup</em></strong></h4>&#13;
<p class="noindent">The <code>&lt;cstdlib&gt;</code> header contains several functions for managing program termination and resource cleanup. There are two broad categories of program termination functions:</p>&#13;
<ul>&#13;
<li class="noindent">Those that cause program termination</li>&#13;
<li class="noindent">Those that register a callback when termination is about to happen</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch21lev3sec1"><strong>Termination Callback with std::atexit</strong></h5>&#13;
<p class="noindent">To register a function to be called when normal program termination occurs, you use the <code>std::atexit</code> function. You can register multiple functions, and they’ll be called in reverse order from their registration. The callback functions take no arguments and return <code>void</code>. If <code>std::atexit</code> registers a function successfully, it will return a non-zero value; otherwise, it returns zero.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex02">Listing 21-2</a> illustrates that you can register an <code>atexit</code> callback and it will be called at the expected moment.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" };&#13;
&#13;
<span epub:type="pagebreak" id="page_694"/>&#13;
void run() {&#13;
  std::cout &lt;&lt; "Registering a callback\n"; <span class="ent">➊</span>&#13;
  std::atexit([] { std::cout &lt;&lt; "***std::atexit callback executing***\n"; }); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "Callback registered\n"; <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed.</span>&#13;
<span class="color1">Entering main()</span>&#13;
<span class="color1">local Tracer constructed.</span>&#13;
<span class="color1">thread_local Tracer constructed.</span>&#13;
<span class="color1">dynamic Tracer constructed.</span>&#13;
<span class="color1">Registering a callback</span>&#13;
<span class="color1">Callback registered <span class="ent">➌</span></span>&#13;
<span class="color1">dynamic Tracer destructed.</span>&#13;
<span class="color1">Exiting main()</span>&#13;
<span class="color1">local Tracer destructed.</span>&#13;
<span class="color1">thread_local Tracer destructed.</span>&#13;
<span class="color1">***std::atexit callback executing*** <span class="ent">➋</span></span>&#13;
<span class="color1">static Tracer destructed.</span></pre>&#13;
<p class="listing"><a id="ch21ex02"/><em>Listing 21-2: Registering an <code>atexit</code> callback</em></p>&#13;
<p class="indent">Within <code>run</code>, you announce that you’re about to register a callback <span class="ent">➊</span>, you do it <span class="ent">➋</span>, and then you announce that you’re about to return from <code>run</code> <span class="ent">➌</span>. In the output, you can plainly see that the callback occurs after you’ve returned from <code>main</code> and all the non-static objects have destructed.</p>&#13;
<p class="indent">There are two important admonitions when programming a callback function:</p>&#13;
<ul>&#13;
<li class="noindent">You must not throw an uncaught exception from the callback function. Doing so will cause <code>std::terminate</code> to get invoked.</li>&#13;
<li class="noindent">You need to be very careful interacting with non-static objects in your program. The <code>atexit</code> callback functions execute after <code>main</code> returns, so all local, thread local, and dynamic objects will be destroyed at that point unless you take special care to keep them alive.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>You can register at least 32 functions with <span class="codeitalic">std::atexit</span>, although the exact limit is implementation defined.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch21lev3sec2"><strong>Exiting with std::exit</strong></h5>&#13;
<p class="noindent">Throughout the book, you’ve been terminating programs by returning from <code>main</code>. In some circumstances, such as in multithreaded programs, you might want to exit the program gracefully in some other way, although you <span epub:type="pagebreak" id="page_695"/>should avoid introducing the associated complications. You can use the <code>std::exit</code> function, which accepts a single <code>int</code> corresponding to the program’s exit code. It will perform the following cleanup steps:</p>&#13;
<ol>&#13;
<li class="noindent">Thread-local objects associated with the current thread and static objects get destroyed. Any <code>atexit</code> callback functions get called.</li>&#13;
<li class="noindent">All of stdin, stdout, and stderr get flushed.</li>&#13;
<li class="noindent">Any temporary files get removed.</li>&#13;
<li class="noindent">The program reports the given status code to the operating environment, which resumes control.</li>&#13;
</ol>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex03">Listing 21-3</a> illustrates the behavior of <code>std::exit</code> by registering an <code>atexit</code> callback and invoking <code>exit</code> from within <code>run</code>.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" };&#13;
&#13;
void run() {&#13;
  std::cout &lt;&lt; "Registering a callback\n"; <span class="ent">➊</span>&#13;
  std::atexit([] { std::cout &lt;&lt; "***std::atexit callback executing***\n"; }); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "Callback registered\n"; <span class="ent">➌</span>&#13;
  std::exit(0); <span class="ent">➍</span>&#13;
}&#13;
&#13;
int main() {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed.</span>&#13;
<span class="color1">Entering main()</span>&#13;
<span class="color1">local Tracer constructed.</span>&#13;
<span class="color1">thread_local Tracer constructed.</span>&#13;
<span class="color1">dynamic Tracer constructed.</span>&#13;
<span class="color1">Registering a callback <span class="ent">➊</span></span>&#13;
<span class="color1">Callback registered <span class="ent">➌</span></span>&#13;
<span class="color1">thread_local Tracer destructed.</span>&#13;
<span class="color1">***std::atexit callback executing*** <span class="ent">➍</span></span>&#13;
<span class="color1">static Tracer destructed.</span></pre>&#13;
<p class="listing"><a id="ch21ex03"/><em>Listing 21-3: Invoking <code>std::exit</code></em></p>&#13;
<p class="indent">Within <code>run</code>, you announce that you’re registering a callback <span class="ent">➊</span>, you register one with <code>atexit</code> <span class="ent">➋</span>, you announce that you’ve completed registering <span class="ent">➌</span>, <span epub:type="pagebreak" id="page_696"/>and you invoke <code>exit</code> with argument zero <span class="ent">➍</span>. Compare the program output from <a href="ch21.xhtml#ch21ex03">Listing 21-3</a> to the output from <a href="ch21.xhtml#ch21ex02">Listing 21-2</a>. Notice that the following lines don’t appear:</p>&#13;
<pre>dynamic Tracer destructed.&#13;
Exiting main()&#13;
local Tracer destructed.</pre>&#13;
<p class="indent">According to the rules for <code>std::exit</code>, local variables on the call stack don’t get cleaned up. And of course, because the program never returns to <code>main</code> from <code>run</code>, <code>delete</code> never gets called. Ouch.</p>&#13;
<p class="indent">This example highlights an important consideration: you shouldn’t use <code>std::exit</code> to handle normal program execution. It’s mentioned here for completeness, because you might see it in earlier C++ code.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <code>&lt;cstdlib&gt;</code> header also includes a <code>std::quick_exit</code>, which invokes callbacks that you register with <code>std::at_quick_exit</code>, which has a similar interface to <code>std::atexit</code>. The main difference is that <code>at_quick_exit</code> callbacks won’t execute unless you explicitly invoke <code>quick_exit</code>, whereas <code>atexit</code> callbacks will always execute when the program is about to exit.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch21lev3sec3"><strong>std::abort</strong></h5>&#13;
<p class="noindent">To end a program, you also have a nuclear option by using <code>std::abort</code>. This function accepts a single integer-valued status code and immediately returns it to the operating environment. No object destructors get called and no <code>std::atexit</code> callbacks get invoked. <a href="ch21.xhtml#ch21ex04">Listing 21-4</a> illustrates how to use <code>std::abort</code>.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" };&#13;
&#13;
void run() {&#13;
  std::cout &lt;&lt; "Registering a callback\n"; <span class="ent">➊</span>&#13;
  std::atexit([] { std::cout &lt;&lt; "***std::atexit callback executing***\n"; }); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "Callback registered\n"; <span class="ent">➌</span>&#13;
  std::abort(); <span class="ent">➍</span>&#13;
}&#13;
&#13;
int main() {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed.</span>&#13;
<span class="color1">Entering main()</span>&#13;
<span class="color1">local Tracer constructed.</span>&#13;
<span class="color1">thread_local Tracer constructed.</span>&#13;
<span class="color1">dynamic Tracer constructed.</span>&#13;
<span class="color1">Registering a callback</span>&#13;
<span class="color1">Callback registered</span></pre>&#13;
<p class="listing"><a id="ch21ex04"/><em>Listing 21-4: Calling <code>std::abort</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_697"/>Within <code>run</code>, you again announce that you’re registering a callback <span class="ent">➊</span>, you register one with <code>atexit</code> and you announce that you’ve completed registering <span class="ent">➌</span>. This time, you invoke <code>abort</code> instead <span class="ent">➍</span>. Notice that no output prints after you announce that you’ve completed callback registration <span class="ent">➊</span>. The program doesn’t clean up any objects, and your <code>atexit</code> callback doesn’t get called.</p>&#13;
<p class="indent">As you might imagine, there aren’t too many canonical uses for <code>std::abort</code>. The main one you’re likely to encounter is the default behavior of <code>std::terminate</code>, which gets called when two exceptions are in flight at once.</p>&#13;
<h4 class="h4" id="ch21lev2sec2"><strong><em>Communicating with the Environment</em></strong></h4>&#13;
<p class="noindent">Sometimes, you might want to spawn another process. For example, Google’s Chrome Browser launches many processes to service a single browser session. This builds in some security and robustness by piggybacking the operating system’s process model. Web apps and plug-ins, for example, run in separate processes, so if they crash, the entire browser doesn’t crash. Also, by running the browser’s rendering engine in a separate process, any security vulnerabilities become more difficult to exploit because Google locks down that process’s permissions in what is known as a sandboxed environment.</p>&#13;
<h5 class="h5" id="ch21lev3sec4"><strong>std::system</strong></h5>&#13;
<p class="noindent">You can launch a separate process with the <code>std::system</code> function in the <code>&lt;cstdlib&gt;</code> header, which accepts a C-style string corresponding to the command you want to execute and returns an <code>int</code> corresponding to the return code from the command. The actual behavior depends on the operating environment. For example, the function will call <em>cmd.exe</em> on a Windows machine and <em>/bin/sh</em> on a Linux machine. This function blocks while the command is still executing.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex05">Listing 21-5</a> illustrates how to use <code>std::system</code> to ping a remote host. (You’ll need to update the contents of <code>command</code> to a relevant command for your operating system if you’re not using a Unix-like operating system.)</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main() {&#13;
  std::string command{ "ping -c 4 google.com" }; <span class="ent">➊</span>&#13;
  const auto result = std::system(command.c_str()); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "The command \'" &lt;&lt; command&#13;
            &lt;&lt; "\' returned " &lt;&lt; result &lt;&lt; "\n";&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_698"/><span class="color1">PING google.com (172.217.15.78): 56 data bytes</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=0 ttl=56 time=4.447 ms</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=1 ttl=56 time=12.162 ms</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=2 ttl=56 time=8.376 ms</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=3 ttl=56 time=10.813 ms</span>&#13;
&#13;
<span class="color1">--- google.com ping statistics ---</span>&#13;
<span class="color1">4 packets transmitted, 4 packets received, 0.0% packet loss</span>&#13;
<span class="color1">round-trip min/avg/max/stddev = 4.447/8.950/12.162/2.932 ms</span>&#13;
<span class="color1">The command 'ping -c 4 google.com' returned 0 <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch21ex05"/><em>Listing 21-5: Using <code>std::system</code> to invoke the <code>ping</code> utility (Output is from macOS Mojave version 10.14.)</em></p>&#13;
<p class="indent">First, you initialize a <code>string</code> called <code>command</code> containing <code>ping -c 4 google.com</code> <span class="ent">➊</span>. You then invoke <code>std::system</code> by passing the contents of <code>command</code> <span class="ent">➋</span>. This causes the operating system to invoke the <code>ping</code> command with the argument <code>-c 4</code>, which specifies four pings, and the address <code>google.com</code>. Then you print a status message reporting the return value from <code>std::system</code> <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch21lev3sec5"><strong>std::getenv</strong></h5>&#13;
<p class="noindent">Operating environments usually have <em>environment variables</em>, which users and developers can set to help programs find important information that the programs need to run. The <code>&lt;cstdlib&gt;</code> header contains the <code>std::getenv</code> function, which accepts a C-style string corresponding to the name of the environment variable you want to look up, and it returns a C-style string with the contents of the corresponding variable. If no such variable is found, the function returns <code>nullptr</code> instead.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex06">Listing 21-6</a> illustrates how to use <code>std::getenv</code> to obtain the <em>path variable</em>, which contains a list of directories containing important executable files.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main() {&#13;
  std::string variable_name{ "PATH" }; <span class="ent">➊</span>&#13;
  std::string result{ std::getenv(variable_name.c_str()) }; <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "The variable " &lt;&lt; variable_name&#13;
            &lt;&lt; " equals " &lt;&lt; result &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">The variable PATH equals /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span></pre>&#13;
<p class="listing"><a id="ch21ex06"/><em>Listing 21-6: Using <code>std::getenv</code> to retrieve the path variable (Output is from macOS Mojave version 10.14.)</em></p>&#13;
<p class="indent">First, you initialize a <code>string</code> called <code>variable_name</code> containing <code>PATH</code> <span class="ent">➊</span>. Next, you store the result of invoking <code>std::getenv</code> with <code>PATH</code> into a string called <code>result</code> <span class="ent">➋</span>. Then you print the results to stdout <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch21lev2sec3"><span epub:type="pagebreak" id="page_699"/><strong><em>Managing Operating System Signals</em></strong></h4>&#13;
<p class="noindent">Operating system signals are asynchronous notifications sent to processes that notify the program that an event occurred. The <code>&lt;csignal&gt;</code> header contains six macro constants that represent different signals from the operating system to the program (these signals are operating system agnostic):</p>&#13;
<ul>&#13;
<li class="noindent"><code>SIGTERM</code> represents a termination request.</li>&#13;
<li class="noindent"><code>SIGSEGV</code> represents invalid memory access.</li>&#13;
<li class="noindent"><code>SIGINT</code> represents an external interrupt, such as a keyboard interrupt.</li>&#13;
<li class="noindent"><code>SIGILL</code> represents an invalid program image.</li>&#13;
<li class="noindent"><code>SIGABRT</code> represents an abnormal termination condition, such as <code>std::abort</code>.</li>&#13;
<li class="noindent"><code>SIGFPE</code> represents a floating-point error, such as division by zero.</li>&#13;
</ul>&#13;
<p class="indent">To register a handler for one of these signals, you use the <code>std::signal</code> function in the <code>&lt;csignal&gt;</code> header. It accepts a single <code>int</code> value corresponding to one of the listed signal macros as its first argument. Its second argument is a function pointer (not a function object!) to a function that accepts an <code>int</code> corresponding to the signal macro and returning <code>void</code>. This function must have C linkage (although most implementations also permit C++ linkage). You’ll learn about C linkage later in the chapter. For now, simply prepend <code>extern "C"</code> to your function definition. Notice that, due to the asynchronous nature of the interrupts, any accesses to a global, mutable state must be synchronized.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex07">Listing 21-7</a> contains a program that waits for a keyboard interrupt.</p>&#13;
<pre>#include &lt;csignal&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;thread&gt;&#13;
#include &lt;atomic&gt;&#13;
&#13;
std::atomic_bool interrupted{}; <span class="ent">➊</span>&#13;
&#13;
extern "C" void handler(int signal) {&#13;
  std::cout &lt;&lt; "Handler invoked with signal " &lt;&lt; signal &lt;&lt; ".\n"; <span class="ent">➋</span>&#13;
  interrupted = true; <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
  using namespace std::chrono_literals;&#13;
  std::signal(SIGINT, handler); <span class="ent">➍</span>&#13;
  while(!interrupted) { <span class="ent">➎</span>&#13;
    std::cout &lt;&lt; "Waiting..." &lt;&lt; std::endl; <span class="ent">➏</span>&#13;
    std::this_thread::sleep_for(1s);&#13;
  }&#13;
  std::cout &lt;&lt; "Interrupted!\n"; <span class="ent">➐</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Waiting...</span>&#13;
<span class="color1">Waiting...</span>&#13;
<span class="color1">Waiting...</span>&#13;
<span class="color1">Handler invoked with signal 2.</span>&#13;
<span class="color1">Interrupted! <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_700"/><a id="ch21ex07"/><em>Listing 21-7: Registering for keyboard interrupts with <code>std::signal</code></em></p>&#13;
<p class="indent">You first declare an <code>atomic_bool</code> called <code>interrupted</code> that stores whether the program has received a keyboard interrupt <span class="ent">➊</span> (it has static storage duration because you cannot use function objects with <code>std::signal</code> and therefore must use a non-member function to handle the callback). Next, you declare a callback handler that accepts an <code>int</code> called <code>signal</code>, prints its value to stdout <span class="ent">➋</span>, and sets <code>interrupted</code> to true <span class="ent">➌</span>.</p>&#13;
<p class="indent">Within <code>main</code>, you set the signal handler for the <code>SIGINT</code> interrupt code to <code>handler</code> <span class="ent">➍</span>. Within a loop, you wait for the program to get interrupted <span class="ent">➎</span> by printing a message <span class="ent">➏</span> and sleeping for a second <span class="ent">➐</span>. Once the program has been interrupted, you print a message and return from <code>main</code> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Typically, you can cause a keyboard interrupt on modern operating systems by pressing <small>CTRL</small>-C.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch21lev1sec2"><strong>Boost ProgramOptions</strong></h3>&#13;
<p class="noindent">Most console applications accept command line parameters. As you learned in “The Three <code>main</code> Overloads” on <a href="ch09.xhtml#page_272">page 272</a>, you can define <code>main</code> to accept the parameters <code>argc</code> and <code>argv</code>, which the operating environment will populate with the number of arguments and argument contents, respectively. You can always parse these manually and modify your program’s behavior accordingly, but there’s a better way: the Boost ProgramOptions library is an essential ingredient for writing console applications.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>All the Boost ProgramOptions classes presented in this section are available in the <code>&lt;boost/program_options.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<p class="indent">You might be tempted to write your own argument-parsing code, but ProgramOptions is a smarter choice for four reasons:</p>&#13;
<ol>&#13;
<li class="noindent"><strong>It’s far more convenient.</strong> Once you learn the succinct, declarative syntax of ProgramOptions, you can easily describe fairly complicated console interfaces in a few lines of code.</li>&#13;
<li class="noindent"><strong>It handles errors effortlessly.</strong> When the user misuses your program, ProgramOptions tells the user how they misused the program without any additional effort on your part.</li>&#13;
<li class="noindent"><strong>It automatically generates a help prompt.</strong> Based on your declarative markup, ProgramOptions creates nicely formatted, easy to employ documentation on your behalf.</li>&#13;
<li class="noindent"><strong>It grows beyond the command line.</strong> If you want to draw configuration from config files or environment variables, it’s easy to transition from command line arguments.</li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_701"/>ProgramOptions comprises three parts:</p>&#13;
<ol>&#13;
<li class="noindent"><strong>The options description</strong> allows you to specify the allowed options.</li>&#13;
<li class="noindent"><strong>The parsers component</strong> extracts option names and values from the command line, config files, and environment variables.</li>&#13;
<li class="noindent"><strong>The storage component</strong> provides you with the interface to access typed options.</li>&#13;
</ol>&#13;
<p class="indent">In the subsections that follow, you’ll learn about each of these parts.</p>&#13;
<h4 class="h4" id="ch21lev2sec4"><strong><em>The Options Description</em></strong></h4>&#13;
<p class="noindent">Three main classes comprise the options description component:</p>&#13;
<ul>&#13;
<li class="noindent"><code>boost::program_options::option_description</code> describes a single option.</li>&#13;
<li class="noindent"><code>boost::program_options::value_semantic</code> knows the desired type of a single option.</li>&#13;
<li class="noindent"><code>boost::program_options::options_description</code> is a container for multiple objects of type <code>option_description</code>.</li>&#13;
</ul>&#13;
<p class="indent">You construct an <code>options_description</code> to, unsurprisingly, specify a description for the program’s options. Optionally, you can include a single string argument in the constructor that describes your program. This will print in the description if you include it, but it will have no functional impact. Next, you use its <code>add_options</code> method, which returns a special kind of object of type <code>boost::program_options::options_description_easy_init</code>. This class has a special <code>operator()</code> that accepts at least two arguments.</p>&#13;
<p class="indent">The first argument is the name of the option you want to add. ProgramOptions is very smart, so you can provide a long name and a short name separated by a comma. For example, if you had an option called <code>threads</code>, ProgramOptions would bind the parameter <code>--threads</code> from the command line to this option. If instead you named the option <code>threads,t</code>, ProgramOptions would bind either <code>--threads</code> or <code>-t</code> to your option.</p>&#13;
<p class="indent">The second argument is the description of the option. You can employ a <code>value_semantic</code>, a C-style string description, or both. Because <code>options_description_easy_init</code> returns a reference to itself from <code>operator()</code>, you can chain these calls together to form a succinct representation of your program’s options. Typically, you don’t create <code>value_semantic</code> objects directly. Instead, you use the convenience template function <code>boost::program_options::value</code> to generate them. It accepts a single template parameter corresponding to the desired type of the option. The resulting pointer points to an object that has code to parse text input (from the command line, for example) into the desired type. To specify an option of <code>int</code> type, for example, you would invoke <code>value&lt;int&gt;()</code>.</p>&#13;
<p class="indent">The resulting pointed-to object will have several methods that allow you to specify additional information about the option. For example, you can employ the <code>default_value</code> method to set the option’s default value. To specify <span epub:type="pagebreak" id="page_702"/>that an option of <code>int</code> type should default to 42, you would use the following construction:</p>&#13;
<pre>value&lt;int&gt;()-&gt;default_value(42)</pre>&#13;
<p class="indent">Another common pattern is an option that can take multiple tokens. Such options are allowed to have spaces between elements, and they’ll be parsed into a single string. To allow this, simply use the <code>multitoken</code> method. For example, to specify that an option can take multiple <code>std::string</code> values, you would use the following construction:</p>&#13;
<pre>value&lt;std::string&gt;()-&gt;multitoken()</pre>&#13;
<p class="indent">If instead you want to allow multiple instances of the same option, you can specify a <code>std::vector</code> as a value, like this:</p>&#13;
<pre>value&lt;std::vector&lt;std::string&gt;&gt;()</pre>&#13;
<p class="indent">If you have a Boolean option, you’ll use the convenience function <code>boost::program_options::bool_switch</code>, which accepts a pointer to a <code>bool</code>. If a user includes the corresponding option, the function will set the pointed-to <code>bool</code> to true. For example, the following construction will set a <code>bool</code> called <code>flag</code> to <code>true</code> if the corresponding option is included:</p>&#13;
<pre>bool_switch(&amp;flag)</pre>&#13;
<p class="indent">The <code>options_description</code> class supports <code>operator&lt;&lt;</code>, so you can create a nicely formatted help dialog without any additional effort. <a href="ch21.xhtml#ch21ex08">Listing 21-8</a> illustrates how to use ProgramOptions to create a <code>program_options</code> object for a sample program called <em>mgrep</em>.</p>&#13;
<pre>#include &lt;boost/program_options.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main(int argc, char** argv) {&#13;
  using namespace boost::program_options;&#13;
  bool is_recursive{}, is_help{};&#13;
&#13;
  options_description description{ "mgrep [options] pattern path1 path2 ..."&#13;
}; <span class="ent">➊</span>&#13;
  description.add_options()&#13;
          ("help,h", bool_switch(&amp;is_help), "display a help dialog") <span class="ent">➋</span>&#13;
          ("threads,t", value&lt;int&gt;()-&gt;default_value(4),&#13;
                        "number of threads to use") <span class="ent">➌</span>&#13;
          ("recursive,r", bool_switch(&amp;is_recursive),&#13;
                          "search subdirectories recursively") <span class="ent">➍</span>&#13;
          ("pattern", value&lt;std::string&gt;(), "pattern to search for") <span class="ent">➎</span>&#13;
          ("paths", value&lt;std::vector&lt;std::string&gt;&gt;(), "path to search"); <span class="ent">➏</span>&#13;
  std::cout &lt;&lt; description; <span class="ent">➐</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_703"/>-----------------------------------------------------------------------&#13;
<span class="color1">mgrep [options] pattern path1 path2 ...:</span>&#13;
<span class="color1">  -h [ --help ]             display a help dialog</span>&#13;
<span class="color1">  -t [ --threads ] arg (=4) number of threads to use</span>&#13;
<span class="color1">  -r [ --recursive ]        search subdirectories recursively</span>&#13;
<span class="color1">  --pattern arg             pattern to search for</span>&#13;
<span class="color1">  --path arg                path to search</span></pre>&#13;
<p class="listing"><a id="ch21ex08"/><em>Listing 21-8: Using Boost ProgramOptions to generate a nicely formatted help dialog</em></p>&#13;
<p class="indent">First, you initialize an <code>options_description</code> object using a custom usage string <span class="ent">➊</span>. Next, you invoke <code>add_options</code> and begin adding options: a Boolean flag indicating whether to display a help dialog <span class="ent">➋</span>, an <code>int</code> indicating how many threads to use <span class="ent">➌</span>, another Boolean flag indicating whether to search subdirectories in a <code>recursive</code> manner <span class="ent">➍</span>, a <code>std::string</code> indicating which <code>pattern</code> to search for within files <span class="ent">➎</span>, and a list of <code>std::string</code> values corresponding to the <code>paths</code> to search <span class="ent">➏</span>. You then write the <code>description</code> to stdout <span class="ent">➐</span>.</p>&#13;
<p class="indent">Suppose that your yet to be implemented mgrep program will always require a <code>pattern</code> and a <code>paths</code> argument. You could convert these into <em>positional</em><em>arguments</em>, which as their name implies will assign arguments based on their position. To do this, you employ the <code>boost::program_options::positional_options_description</code> class, which doesn’t take any constructor arguments. You use the <code>add</code> method, which takes two arguments: a C-style string corresponding to the option you want to convert to positional and an <code>int</code> corresponding to the number of arguments you want to bind to it. You can invoke <code>add</code> multiple times to add multiple positional arguments. But the order matters. Positional arguments will bind from left to right, so your first <code>add</code> invocation applies to the left positional arguments. For the last positional option, you can use the number <code>-1</code> to tell ProgramOptions to bind all remaining elements to the corresponding option.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex09">Listing 21-9</a> provides a snippet that you could append into <code>main</code> in <a href="ch21.xhtml#ch21ex07">Listing 21-7</a> to add the positional arguments.</p>&#13;
<pre>  positional_options_description positional; <span class="ent">➊</span>&#13;
  positional.add("pattern", 1); <span class="ent">➋</span>&#13;
  positional.add("path", -1); <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch21ex09"/><em>Listing 21-9: Adding positional arguments to <a href="ch21.xhtml#ch21ex08">Listing 21-8</a></em></p>&#13;
<p class="indent">You initialize a <code>positional_options_description</code> without any constructor arguments <span class="ent">➊</span>. Next, you invoke <code>add</code> and pass the arguments <code>pattern</code> and <code>1</code>, which will bind the first positional option to the <em>pattern</em> option <span class="ent">➋</span>. You invoke <code>add</code> again, this time passing the arguments <code>path</code> and <code>-1</code> <span class="ent">➌</span>, which will bind the remaining positional options to the <em>path</em> option.</p>&#13;
<h4 class="h4" id="ch21lev2sec5"><strong><em>Parsing Options</em></strong></h4>&#13;
<p class="noindent">Now that you’ve declared how your program accepts options, you can parse user input. It’s possible to take configuration from environment variables, configuration files, and the command line. For brevity, this section only discusses the last.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_704"/><em>For information on how to obtain configuration from environment variables and configuration files, refer to the Boost ProgramOptions documentation, especially the tutorial.</em></p>&#13;
</div>&#13;
<p class="indent">To parse command line input, you use the <code>boost::program_options::command_line_parser</code> class, which accepts two constructor parameters arguments: an <code>int</code> corresponding to <em>argc</em>, the number of arguments on the command line, and a <code>char**</code> corresponding to <em>argv</em>, the value (or content) of the arguments on the command line. This class offers several important methods that you’ll use to declare how the parser should interpret user input.</p>&#13;
<p class="indent">First, you’ll invoke its <code>options</code> method, which takes a single argument corresponding to your <code>options_description</code>. Next, you’ll use the positional method, which takes a single argument corresponding to your <code>positional_options_description</code>. Finally, you’ll invoke <code>run</code> without any arguments. This causes the parser to parse the command line input and return a <code>parsed_options</code> object.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex10">Listing 21-10</a> provides a snippet that you could append into <code>main</code> after <a href="ch21.xhtml#ch21ex08">Listing 21-8</a> to incorporate a <code>command_line_parser</code>.</p>&#13;
<pre>command_line_parser parser{ argc, argv }; <span class="ent">➊</span>&#13;
parser.options(description); <span class="ent">➋</span>&#13;
parser.positional(positional); <span class="ent">➌</span>&#13;
auto parsed_result = parser.run(); <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch21ex10"/><em>Listing 21-10: Adding the <code>command_line_parser</code> to <a href="ch21.xhtml#ch21ex08">Listing 21-8</a></em></p>&#13;
<p class="indent">You initialize a <code>command_line_parser</code> called <code>parser</code> by passing in the arguments from <code>main</code> <span class="ent">➊</span>. Next, you pass the <code>options_description</code> object to the <code>options</code> method <span class="ent">➋</span> and the <code>positional_options_description</code> to the <code>positional</code> method <span class="ent">➌</span>. Then you invoke the <code>run</code> method to produce your <code>parsed_options</code> object <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>If the user passes input that doesn’t parse, for example, because they provide an option that isn’t part of your description, the parser will throw an exception that inherits from <code>std::exception</code>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch21lev2sec6"><strong><em>Storing and Accessing Options</em></strong></h4>&#13;
<p class="noindent">You store program options into a <code>boost::program_options::variables_map</code> class, which takes no arguments in its constructor. To place your parsed options into a <code>variables_map</code>, you use the <code>boost::program_options::store</code> method, which takes a <code>parsed_options</code> object as its first argument and a <code>variables_map</code> object as its second argument. Then you call the <code>boost::program_options::notify</code> method, which takes a single <code>variables_map</code> argument. At this point, your <code>variables_map</code> contains all the options your user has specified.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex11">Listing 21-11</a> provides a snippet that you could append into <code>main</code> after <a href="ch21.xhtml#ch21ex10">Listing 21-10</a> to parse results into a <code>variables_map</code>.</p>&#13;
<pre>variables_map vm; <span class="ent">➊</span>&#13;
store(parsed_result, vm); <span class="ent">➋</span>&#13;
notify(vm); <span class="ent">➌</span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_705"/><a id="ch21ex11"/><em>Listing 21-11: Storing results into a <code>variables_map</code></em></p>&#13;
<p class="indent">You first declare a <code>variables_map</code> <span class="ent">➊</span>. Next, you pass your <code>parsed_result</code> from <a href="ch21.xhtml#ch21ex10">Listing 21-10</a> and your newly declared <code>variables_map</code> to <code>store</code> <span class="ent">➋</span>. Then you call <code>notify</code> on your <code>variables_map</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The <code>variables_map</code> class is an associative container that is essentially similar to a <code>std::map&lt;std::string, boost::any&gt;</code>. To extract an element, you use <code>operator[]</code> by passing the option name as the key. The result is a <code>boost::any</code>, so you’ll need to convert it to the correct type using its <code>as</code> method. (You learned about <code>boost::any</code> in “<code>any</code>” on <a href="ch12.xhtml#page_378">page 378</a>.) It’s crucial to check for any options that might be empty by using the <code>empty</code> method. If you fail to do so and you cast the <code>any</code> anyway, you’ll get a runtime error.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex12">Listing 21-12</a> illustrates how you can retrieve values from a <code>variables_map</code>.</p>&#13;
<pre>if (is_help) std::cout &lt;&lt; "Is help.\n"; <span class="ent">➊</span>&#13;
if (is_recursive) std::cout &lt;&lt; "Is recursive.\n"; <span class="ent">➋</span>&#13;
std::cout &lt;&lt; "Threads: " &lt;&lt; vm["threads"].as&lt;int&gt;() &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
if (!vm["pattern"].empty()) { <span class="ent">➍</span>&#13;
  std::cout &lt;&lt; "Pattern: " &lt;&lt; vm["pattern"].as&lt;std::string&gt;() &lt;&lt; "\n"; <span class="ent">➎</span>&#13;
} else {&#13;
  std::cout &lt;&lt; "Empty pattern.\n";&#13;
}&#13;
if (!vm["path"].empty()) { <span class="ent">➏</span>&#13;
  std::cout &lt;&lt; "Paths:\n";&#13;
  for(const auto&amp; path : vm["path"].as&lt;std::vector&lt;std::string&gt;&gt;()) <span class="ent">➐</span>&#13;
    std::cout &lt;&lt; "\t" &lt;&lt; path &lt;&lt; "\n";&#13;
} else {&#13;
  std::cout &lt;&lt; "Empty path.\n";&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex12"/><em>Listing 21-12: Retrieving values from a <code>variables_map</code></em></p>&#13;
<p class="indent">Because you use the <code>bool_switch</code> value for the <code>help</code> and <code>recursive</code> options, you simply use those Boolean values directly to determine whether the user has requested either <span class="ent">➊</span><span class="ent">➋</span>. Because <code>threads</code> has a default value, you don’t need to make sure that it’s empty, so you can extract its value using as<code>&lt;int&gt;</code> directly <span class="ent">➌</span>. For those options without defaults, such as <code>pattern</code>, you first check for <code>empty</code> <span class="ent">➍</span>. If those options aren’t empty, you can extract their values using <code>as&lt;std::string&gt;</code> <span class="ent">➎</span>. You do the same for <code>path</code> <span class="ent">➏</span>, which allows you extract the user-provided collection with <code>as&lt;std::vector&lt;std::string&gt;&gt;</code> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch21lev2sec7"><strong><em>Putting It All Together</em></strong></h4>&#13;
<p class="noindent">Now you have all the requisite knowledge to assemble a ProgramOptions-based application. <a href="ch21.xhtml#ch21ex13">Listing 21-13</a> illustrates one way to stitch the previous listings together.</p>&#13;
<pre><span epub:type="pagebreak" id="page_706"/>#include &lt;boost/program_options.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main(int argc, char** argv) {&#13;
  using namespace boost::program_options;&#13;
  bool is_recursive{}, is_help{};&#13;
&#13;
  options_description description{ "mgrep [options] pattern path1 path2 ..." };&#13;
  description.add_options()&#13;
          ("help,h", bool_switch(&amp;is_help), "display a help dialog")&#13;
          ("threads,t", value&lt;int&gt;()-&gt;default_value(4),&#13;
                        "number of threads to use")&#13;
          ("recursive,r", bool_switch(&amp;is_recursive),&#13;
                         "search subdirectories recursively")&#13;
          ("pattern", value&lt;std::string&gt;(), "pattern to search for")&#13;
          ("path", value&lt;std::vector&lt;std::string&gt;&gt;(), "path to search");&#13;
&#13;
  positional_options_description positional;&#13;
  positional.add("pattern", 1);&#13;
  positional.add("path", -1);&#13;
&#13;
  command_line_parser parser{ argc, argv };&#13;
  parser.options(description);&#13;
  parser.positional(positional);&#13;
&#13;
  variables_map vm;&#13;
  try {&#13;
    auto parsed_result = parser.run(); <span class="ent">➊</span>&#13;
    store(parsed_result, vm);&#13;
    notify(vm);&#13;
  } catch (const std::exception&amp; e) {&#13;
    std::cerr &lt;&lt; e.what() &lt;&lt; "\n";&#13;
    return -1;&#13;
  }&#13;
&#13;
  if (is_help) { <span class="ent">➋</span>&#13;
    std::cout &lt;&lt; description;&#13;
    return 0;&#13;
  }&#13;
  if (vm["pattern"].empty()) { <span class="ent">➌</span>&#13;
    std::cerr &lt;&lt; "You must provide a pattern.\n";&#13;
    return -1;&#13;
  }&#13;
  if (vm["path"].empty()) { <span class="ent">➍</span>&#13;
    std::cerr &lt;&lt; "You must provide at least one path.\n";&#13;
    return -1;&#13;
  }&#13;
  const auto threads = vm["threads"].as&lt;int&gt;();&#13;
  const auto&amp; pattern = vm["pattern"].as&lt;std::string&gt;();&#13;
  const auto&amp; paths = vm["path"].as&lt;std::vector&lt;std::string&gt;&gt;();&#13;
  // Continue program here ... <span class="ent">➎</span>&#13;
  std::cout &lt;&lt; "Ok." &lt;&lt; std::endl;&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_707"/><a id="ch21ex13"/><em>Listing 21-13: A complete command line parameter-parsing application using the previous listings</em></p>&#13;
<p class="indent">The first departure from the previous listings is that you wrap the call to run on your parser using a <code>try</code>-<code>catch</code> block to mitigate erroneous input provided by the user <span class="ent">➊</span>. If they do provide erroneous input, you simply catch the exception, print the error to stderr, and <code>return</code>.</p>&#13;
<p class="indent">Once you declare your program options and store them, as in <a href="ch21.xhtml#ch21ex08">Listings 21-8</a> to <a href="ch21.xhtml#ch21ex12">21-12</a>, you first check whether the user has requested a help prompt <span class="ent">➋</span>. If so, you simply print the usage and exit, because there’s no need to perform any further checking. Next, you perform some error checking to make sure the user has provided a pattern <span class="ent">➌</span> and at least one path <span class="ent">➍</span>. If not, you print an error along with the program’s correct usage and exit; otherwise, you can continue writing your program <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex14">Listing 21-14</a> shows various outputs from your program, which is compiled into the binary mgrep.</p>&#13;
<pre>$ ./mgrep <span class="ent">➊</span>&#13;
You must provide a pattern.&#13;
$ ./mgrep needle <span class="ent">➋</span>&#13;
You must provide at least one path.&#13;
$ ./mgrep --supercharge needle haystack1.txt haystack2.txt <span class="ent">➌</span>&#13;
unrecognised option '--supercharge'&#13;
$ ./mgrep --help <span class="ent">➍</span>&#13;
mgrep [options] pattern path1 path2 ...:&#13;
  -h [ --help ]             display a help dialog&#13;
  -t [ --threads ] arg (=4) number of threads to use&#13;
  -r [ --recursive ]        search subdirectories recursively&#13;
  --pattern arg             pattern to search for&#13;
  --path arg                path to search&#13;
$ ./mgrep needle haystack1.txt haystack2.txt haystack3.txt <span class="ent">➎</span>&#13;
Ok.&#13;
$ ./mgrep --recursive needle haystack1.txt <span class="ent">➏</span>&#13;
Ok.&#13;
$ ./mgrep -rt 10 needle haystack1.txt haystack2.txt <span class="ent">➐</span>&#13;
Ok.</pre>&#13;
<p class="listing"><a id="ch21ex14"/><em>Listing 21-14: Various invocations and outputs from the program in <a href="ch21.xhtml#ch21ex13">Listing 21-13</a></em></p>&#13;
<p class="indent">The first three invocations return errors for different reasons: you haven’t provided a pattern <span class="ent">➊</span>, you haven’t provided a path <span class="ent">➋</span>, or you provided an unrecognized option <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the next invocation, you get the friendly help dialog because you provided the <code>--help</code> option <span class="ent">➍</span>. The final three invocations parse correctly because all contain a pattern and at least one path. The first contains no options <span class="ent">➎</span>, the second uses the longhand option syntax <span class="ent">➏</span>, and the third uses the shorthand option syntax <span class="ent">➐</span>.</p>&#13;
<h3 class="h3" id="ch21lev1sec3"><span epub:type="pagebreak" id="page_708"/><strong>Special Topics in Compilation</strong></h3>&#13;
<p class="noindent">This section explains several important preprocessor features that will help you understand the double-inclusion problem, which is described in the following subsection, and how to solve it. You’ll learn about different options for optimizing your code by using compiler flags. Additionally, you’ll learn how to allow your linker to interoperate with C using a special language keyword.</p>&#13;
<h4 class="h4" id="ch21lev2sec8"><strong><em>Revisiting the Preprocessor</em></strong></h4>&#13;
<p class="noindent">The preprocessor is a program that applies simple transformations to source code before compilation. You give instructions to the preprocessor using preprocessor directives. All preprocessor directives begin with a hash mark (<code>#</code>). Recall from “The Compiler Tool Chain,” on <a href="ch01.xhtml#page_5">page 5</a> that <code>#include</code> is a preprocessor directive that tells the preprocessor to copy and paste the contents of the corresponding header directly into the source code.</p>&#13;
<p class="indent">The preprocessor also supports other directives. The most common is the <em>macro</em>, which is a fragment of code that’s been given a name. Whenever you use that name within C++ code, the preprocessor replaces that name with the contents of the macro.</p>&#13;
<p class="indent">The two different kinds of macros are object-like and function-like. You declare an object-like macro using the following syntax:</p>&#13;
<pre>#define <span class="codeitalic1">&lt;NAME&gt; &lt;CODE&gt;</span></pre>&#13;
<p class="noindent">where <span class="codeitalic">NAME</span> is the name of the macro and <code>CODE</code> is the code to replace that name. For example, <a href="ch21.xhtml#ch21ex15">Listing 21-15</a> illustrates how to define a string literal to a macro.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#define MESSAGE "LOL" <span class="ent">➊</span>&#13;
&#13;
int main(){&#13;
  printf(MESSAGE); <span class="ent">➋</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">LOL</span></pre>&#13;
<p class="listing"><a id="ch21ex15"/><em>Listing 21-15: A C++ program with an object-like macro</em></p>&#13;
<p class="indent">You define the macro <code>MESSAGE</code> to correspond with the code <code>"LOL"</code> <span class="ent">➊</span>. Next, you use the <code>MESSAGE</code> macro as the format string to <code>printf</code> <span class="ent">➋</span>. After the preprocessor has completed work on <a href="ch21.xhtml#ch21ex15">Listing 21-15</a>, it appears as <a href="ch21.xhtml#ch21ex16">Listing 21-16</a> to the compiler.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main(){&#13;
  printf("LOL");&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex16"/><em>Listing 21-16: The result of preprocessing <a href="ch21.xhtml#ch21ex15">Listing 21-15</a></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_709"/>The preprocessor is nothing more than a copy-and-paste tool here. The macro disappears, and you’re left with a simple program that prints <code>LOL</code> to the console.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you want to inspect the work that the preprocessor does, compilers usually have a flag that will limit compilation to just the preprocessing step. This will cause the compiler to emit the preprocessed source file corresponding to each translation unit. On GCC, Clang, and MSVC, for example, you can use the <code>-E</code> flag.</em></p>&#13;
</div>&#13;
<p class="indent">A function-like macro is just like an object-like macro except it can take a list of parameters after its identifier:</p>&#13;
<pre>#define <span class="codeitalic1">&lt;NAME&gt;</span>(<span class="codeitalic1">&lt;PARAMETERS&gt;</span>) <span class="codeitalic1">&lt;CODE&gt;</span></pre>&#13;
<p class="indent">You can use these <span class="codeitalic">PARAMETERS</span> within the <span class="codeitalic">CODE</span>, allowing the user to customize the macro’s behavior. <a href="ch21.xhtml#ch21ex17">Listing 21-17</a> contains the function-like macro <code>SAY_LOL_WITH</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#define SAY_LOL_WITH(fn) fn("LOL") <span class="ent">➊</span>&#13;
&#13;
int main() {&#13;
  SAY_LOL_WITH(printf); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex17"/><em>Listing 21-17: A C++ program with a function-like macro</em></p>&#13;
<p class="indent">The <code>SAY_LOL_WITH</code> macro accepts a single parameter named <code>fn</code> <span class="ent">➊</span>. The preprocessor pastes the macro into the expression <code>fn("LOL")</code>. When it evaluates <code>SAY_LOL_WITH</code>, the preprocessor pastes <code>printf</code> into the expression <span class="ent">➋</span>, yielding a translation unit just like <a href="ch21.xhtml#ch21ex16">Listing 21-16</a>.</p>&#13;
<h5 class="h5" id="ch21lev3sec6"><strong>Conditional Compilation</strong></h5>&#13;
<p class="noindent">The preprocessor also offers <em>conditional compilation</em>, a facility that provides basic <code>if</code>-<code>else</code> logic. Several flavors of conditional compilation are available, but the one you’re likely to encounter is illustrated in <a href="ch21.xhtml#ch21ex18">Listing 21-18</a>.</p>&#13;
<pre>#ifndef MY_MACRO <span class="ent">➊</span>&#13;
// Segment 1 <span class="ent">➋</span>&#13;
#else&#13;
// Segment 2 <span class="ent">➌</span>&#13;
#endif</pre>&#13;
<p class="listing"><a id="ch21ex18"/><em>Listing 21-18: A C++ program with a conditional compilation</em></p>&#13;
<p class="indent">If <code>MY_MACRO</code> isn’t defined at the point where the preprocessor evaluates <code>#ifndef</code> <span class="ent">➊</span>, <a href="ch21.xhtml#ch21ex18">Listing 21-18</a> reduces to the code represented by <code>// Segment 1</code> <span class="ent">➋</span>. If <code>MY_MACRO</code> is <code>#defined</code>, <a href="ch21.xhtml#ch21ex18">Listing 21-18</a> evaluates to the code represented by <code>// Segment 2</code> <span class="ent">➌</span>. The <code>#else</code> is optional.</p>&#13;
<h5 class="h5" id="ch21lev3sec7"><span epub:type="pagebreak" id="page_710"/><strong>Double Inclusion</strong></h5>&#13;
<p class="noindent">Aside from using <code>#include</code>, you should use the preprocessor as little as possible. The preprocessor is extremely primitive and will cause difficult-to-debug errors if you lean on it too heavily. This is evident with <code>#include</code>, which is a simple copy-and-paste command.</p>&#13;
<p class="indent">Because you can define a symbol only once (a rule appropriately called the <em>one-definition rule</em>), you must ensure that your headers don’t attempt to redefine symbols. The easiest way to make this mistake is by including the same header twice, which is called the <em>double-inclusion problem</em>.</p>&#13;
<p class="indent">The usual way to avoid the double-inclusion problem is to use conditional compilation to make an <em>include guard</em>. The include guard detects whether a header has been included before. If it has, it uses conditional compilation to empty the header. <a href="ch21.xhtml#ch21ex19">Listing 21-19</a> illustrates how to put include guards around a header.</p>&#13;
<pre>// step_function.h&#13;
#ifndef STEP_FUNCTION_H <span class="ent">➊</span>&#13;
int step_function(int x);&#13;
#define STEP_FUNCTION_H <span class="ent">➋</span>&#13;
#endif</pre>&#13;
<p class="listing"><a id="ch21ex19"/><em>Listing 21-19: A <code>step_function.h</code> updated with include guards</em></p>&#13;
<p class="indent">The first time that the preprocessor includes <code>step_function.h</code> in a source file, the macro <code>STEP_FUNCTION_H</code> won’t be defined, so <code>#ifndef</code> <span class="ent">➊</span> yields the code up to <code>#endif</code>. Within this code, you <code>#define</code> the <code>STEP_FUNCTION_H</code> macro <span class="ent">➋</span>. This ensures that if the preprocessor includes <code>step_function.h</code> again, <code>#ifndef STEP_FUNCTION_H</code> will evaluate to false and no code will get generated.</p>&#13;
<p class="indent">Include guards are so ubiquitous that most modern tool chains support the <code>#pragma once</code> special syntax. If one of the supporting preprocessors sees this line, it will behave as if the header has include guards. This eliminates quite a bit of ceremony. Using this construct, you could refactor <a href="ch21.xhtml#ch21ex19">Listing 21-19</a> into <a href="ch21.xhtml#ch21ex20">Listing 21-20</a>.</p>&#13;
<pre>#pragma once <span class="ent">➊</span>&#13;
int step_function(int x);</pre>&#13;
<p class="listing"><a id="ch21ex20"/><em>Listing 21-20: A <code>step_function.h</code> updated with <code>#pragma once</code></em></p>&#13;
<p class="indent">All you’ve done here is start the header with <code>#pragma once</code> <span class="ent">➊</span>, which is the preferred method. As a general rule, start every header with <code>#pragma once</code>.</p>&#13;
<h4 class="h4" id="ch21lev2sec9"><strong><em>Compiler Optimization</em></strong></h4>&#13;
<p class="noindent">Modern compilers can perform sophisticated transformations on code to increase runtime performance and reduce binary size. These transformations are called <em>optimizations</em>, and they entail some cost to programmers. Optimization necessarily increases compilation time. Additionally, optimized code is often harder to debug than non-optimized code, because the <span epub:type="pagebreak" id="page_711"/>optimizer usually eliminates and reorders instructions. In short, you usually want to turn off optimizations while you’re programming, but turn them on during testing and in production. Accordingly, compilers typically provide several optimization options. <a href="ch21.xhtml#ch21tab01">Table 21-1</a> describes one such example—the optimization options available in GCC 8.3, although these flags are fairly ubiquitous across the major compilers.</p>&#13;
<p class="tabcap" id="ch21tab01"><strong>Table 21-1:</strong> GCC 8.3 Optimization Options</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Flag</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>-O0 (default)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Reduces compilation time by turning off optimizations. Yields a good debugging experience but suboptimal runtime performance.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-O</code> or <code>-O1</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Performs the majority of available optimizations, but omits those that can take a lot of (compile) time.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>-O2</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs all optimizations at <code>-O1</code>, plus nearly all optimizations that don’t substantially increase binary size. Compilation might take much longer than with <code>-O1</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-O3</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Performs all optimizations at <code>-O2</code>, plus many optimizations that can substantially increase binary size. Again, this increases compilation time over <code>-O1</code> and <code>-O2</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>-Os</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Optimizes similarly to <code>-O2</code> but with a priority for decreasing binary size. You can think of this (loosely) as a foil to <code>-O3</code>, which is willing to increase binary size in exchange for performance. Any <code>-O2</code> optimizations that don’t increase binary size are performed.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>-Ofast</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Enables all <code>-O3</code> optimizations, plus some dangerous optimizations that might violate standards compliance. Caveat emptor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>-Og</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Enables optimizations that don’t degrade the debugging experience. Provides a good balance of reasonable optimizations, fast compilation, and ease of debugging.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As a general rule, use <code>-O2</code> for your production binary unless you have a good reason to change it. For debugging, use <code>-Og</code>.</p>&#13;
<h4 class="h4" id="ch21lev2sec10"><strong><em>Linking with C</em></strong></h4>&#13;
<p class="noindent">You can allow C code to incorporate functions and variables from your programs using <em>language linkage</em>. Language linkage instructs the compiler to generate symbols with a specific format friendly to another target language. For example, to allow a C program to use your functions, you simply add the <code>extern "C"</code> language linkage to your code.</p>&#13;
<p class="indent">Consider the <code>sum.h</code> header in <a href="ch21.xhtml#ch21ex21">Listing 21-21</a>, which generates a C-compatible symbol for <code>sum</code>.</p>&#13;
<pre> // sum.h&#13;
#pragma once&#13;
extern "C" int sum(const int* x, int len);</pre>&#13;
<p class="listing"><a id="ch21ex21"/><em>Listing 21-21: A header that makes the <code>sum</code> function available to C linkers</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_712"/>Now the compiler will generate objects that the C linker can use. To use this function within C code, you simply declare the <code>sum</code> function per usual:</p>&#13;
<pre>int sum(const int* x, size_t len);</pre>&#13;
<p class="indent">Then instruct your C linker to include the C++ object file.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>According to the C++ Standard,</em> pragma <em>is a method to provide additional information to the compiler beyond what is embedded in the source code. This information is implementation defined, so the compiler isn’t required to use the information specified by the pragma in any way.</em> Pragma <em>is the Greek root for “a fact.”</em></p>&#13;
</div>&#13;
<p class="indent">You can also interoperate the opposite way: use C compiler output within your C++ programs by giving the linker the C compiler-generated object file.</p>&#13;
<p class="indent">Suppose a C compiler generated a function equivalent to <code>sum</code>. You could compile using the <code>sum.h</code> header, and the linker would have no problem consuming the object file, thanks to language linkage.</p>&#13;
<p class="indent">If you have many externed functions, you can use braces <code>{}</code>, as <a href="ch21.xhtml#ch21ex22">Listing 21-22</a> illustrates.</p>&#13;
<pre>// sum.h&#13;
#pragma once&#13;
&#13;
extern "C" {&#13;
  int sum_int(const int* x, int len);&#13;
  double sum_double(const double* x, int len);&#13;
--snip--&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex22"/><em>Listing 21-22: A refactoring of <a href="ch21.xhtml#ch21ex21">Listing 21-21</a> containing multiple functions with the <code>extern</code> modifier.</em></p>&#13;
<p class="indent">The <code>sum_int</code> and <code>sum_double</code> functions will have C language linkage.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can also interoperate between C++ and Python with Boost Python. See the Boost documentation for details.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch21lev1sec4"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you first learned about program support features that allow you to interact with the application life cycle. Next, you explored Boost ProgramOptions, which allows you to accept input from users easily using a declarative syntax. Then you examined some selected topics in compilation that will be helpful as you expand your C++ application development horizons.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_713"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>21-1.</strong> Add graceful keyboard interrupt handling to the asynchronous upper-casing echo server in <a href="ch21.xhtml#ch21ex12">Listing 20-12</a>. Add a kill switch with static storage duration that the session objects and acceptors check before queueing more asynchronous I/O.</p>&#13;
<p class="noindent"><strong>21-2.</strong> Add program options to the asynchronous HTTP client in <a href="ch20.xhtml#ch20ex10">Listing 20-10</a>. It should accept options for the host (like <em><a href="http://www.nostarch.com">www.nostarch.com</a></em>) and one or more resources (like <em>/index.htm</em>). It should create a separate request for each resource.</p>&#13;
<p class="noindent"><strong>21-3.</strong> Add another option to your program in exercise 21-2 that accepts a directory where you’ll write all the HTTP responses. Derive a filename from each host/resource combination.</p>&#13;
<p class="noindent"><strong>21-4.</strong> Implement the mgrep program. It should incorporate many of the libraries you’ve learned about in <a href="part02.xhtml#part02">Part II</a>. Investigate the Boyer-Moore search algorithm in Boost Algorithm (in the  <code>&lt;boost/algorithm/searching/boyer_moore.hpp&gt;</code> header).  Use  std::async to launch tasks and determine a way to coordinate work  between them.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>API Design for C++</em> by Martin Reddy (Morgan Kaufmann, 2011)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>