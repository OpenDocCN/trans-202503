<html><head></head><body>
<h2 class="h2" id="ch21"><span epub:type="pagebreak" id="page_690"/><span epub:type="pagebreak" id="page_691"/><strong><span class="big">21</span><br/>WRITING APPLICATIONS</strong></h2>&#13;
<p class="quote"><em>For a bunch of hairless apes, we’ve actually managed to invent some pretty incredible things.<br/>—Ernest Cline</em>, Ready Player One</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This chapter contains a potpourri of important topics that will add to your practical understanding of C++ by teaching you the basics of building real-world applications. It begins with a discussion of program support built into C++ that allows you to interact with the application life cycle. Next, you’ll learn about Boost ProgramOptions, an excellent library for developing console applications. It contains facilities to accept input from users without your having to reinvent the wheel. Additionally, you’ll learn some special topics about the preprocessor and compiler that you’ll likely come across when building an application whose source exceeds a single file.</p>&#13;
<h3 class="h3" id="ch21lev1sec1"><span epub:type="pagebreak" id="page_692"/><strong>Program Support</strong></h3>&#13;
<p class="noindent">Sometimes your programs need to interact with your operating environment’s application life cycle. This section covers three major categories of such interactions:</p>&#13;
<ul>&#13;
<li class="noindent">Handling program termination and cleanup</li>&#13;
<li class="noindent">Communicating with the environment</li>&#13;
<li class="noindent">Managing operating system signals</li>&#13;
</ul>&#13;
<p class="indent">To help illustrate the various facilities in this section, you’ll use <a href="ch21.xhtml#ch21ex01">Listing 21-1</a> as a framework. It uses a spruced up analog to the <span class="literal">Tracer</span> class from <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> in <a href="ch04.xhtml#ch04">Chapter 4</a> to help track which objects get cleaned up in various program termination scenarios.</p>&#13;
<pre>#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer { <span class="ent">➊</span>&#13;
  Tracer(std::string name_in)&#13;
    : name{ std::move(name_in) } {&#13;
    std::cout &lt;&lt; name &lt;&lt; " constructed.\n";&#13;
  }&#13;
  ~Tracer() {&#13;
    std::cout &lt;&lt; name &lt;&lt; " destructed.\n";&#13;
  }&#13;
private:&#13;
  const std::string name;&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" }; <span class="ent">➋</span>&#13;
&#13;
void run() { <span class="ent">➌</span>&#13;
  std::cout &lt;&lt; "Entering run()\n";&#13;
  // ...&#13;
  std::cout &lt;&lt; "Exiting run()\n";&#13;
}&#13;
&#13;
int main() {&#13;
  std::cout &lt;&lt; "Entering main()\n"; <span class="ent">➍</span>&#13;
  Tracer local_tracer{ "local Tracer" }; <span class="ent">➎</span>&#13;
  thread_local Tracer thread_local_tracer{ "thread_local Tracer" }; <span class="ent">➏</span>&#13;
  const auto* dynamic_tracer = new Tracer{ "dynamic Tracer" }; <span class="ent">➐</span>&#13;
  run(); <span class="ent">➑</span>&#13;
  delete dynamic_tracer; <span class="ent">➒</span>&#13;
  std::cout &lt;&lt; "Exiting main()\n"; <span class="ent">➓</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed. <span class="ent">➋</span></span>&#13;
<span class="color1">Entering main() <span class="ent">➍</span></span>&#13;
<span class="color1">local Tracer constructed. <span class="ent">➎</span></span>&#13;
<span class="color1">thread_local Tracer constructed. <span class="ent">➏</span></span>&#13;
<span class="color1">dynamic Tracer constructed. <span class="ent">➐</span></span>&#13;
<span epub:type="pagebreak" id="page_693"/><span class="color1">Entering run() <span class="ent">➑</span></span>&#13;
<span class="color1">Exiting run() <span class="ent">➑</span></span>&#13;
<span class="color1">dynamic Tracer destructed. <span class="ent">➒</span></span>&#13;
<span class="color1">Exiting main() <span class="ent">➓</span></span>&#13;
<span class="color1">local Tracer destructed. <span class="ent">➎</span></span>&#13;
<span class="color1">thread_local Tracer destructed. <span class="ent">➏</span></span>&#13;
<span class="color1">static Tracer destructed. <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch21ex01"/><em>Listing 21-1: A framework for investigating program termination and cleanup facilities</em></p>&#13;
<p class="indent">First, you declare a <span class="literal">Tracer</span> class that accepts an arbitrary <span class="literal">std::string</span> tag and reports to stdout when the <span class="literal">Tracer</span> object is constructed and destructed <span class="ent">➊</span>. Next, you declare a <span class="literal">Tracer</span> with static storage duration <span class="ent">➋</span>. The <span class="literal">run</span> function reports when the program has entered and exited it <span class="ent">➌</span>. In the middle is a single comment that you’ll replace with other code in the sections that follow. Within <span class="literal">main</span>, you make an announcement <span class="ent">➍</span>; initialize <span class="literal">Tracer</span> objects with local <span class="ent">➎</span>, thread-local <span class="ent">➏</span>, and dynamic <span class="ent">➐</span> storage duration; and invoke <span class="literal">run</span> <span class="ent">➑</span>. Then you delete the dynamic Tracer object <span class="ent">➒</span> and announce that you’re about to return from <span class="literal">main</span> <span class="ent">➓</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>If any of the <a href="ch21.xhtml#ch21ex01">Listing 21-1</a> output is surprising, please review “An Object’s Storage Duration” on <a href="ch04.xhtml#page_89">page 89</a> before proceeding!</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch21lev2sec1"><strong><em>Handling Program Termination and Cleanup</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">&lt;cstdlib&gt;</span> header contains several functions for managing program termination and resource cleanup. There are two broad categories of program termination functions:</p>&#13;
<ul>&#13;
<li class="noindent">Those that cause program termination</li>&#13;
<li class="noindent">Those that register a callback when termination is about to happen</li>&#13;
</ul>&#13;
<h5 class="h5" id="ch21lev3sec1"><strong>Termination Callback with std::atexit</strong></h5>&#13;
<p class="noindent">To register a function to be called when normal program termination occurs, you use the <span class="literal">std::atexit</span> function. You can register multiple functions, and they’ll be called in reverse order from their registration. The callback functions take no arguments and return <span class="literal">void</span>. If <span class="literal">std::atexit</span> registers a function successfully, it will return a non-zero value; otherwise, it returns zero.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex02">Listing 21-2</a> illustrates that you can register an <span class="literal">atexit</span> callback and it will be called at the expected moment.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" };&#13;
&#13;
<span epub:type="pagebreak" id="page_694"/>&#13;
void run() {&#13;
  std::cout &lt;&lt; "Registering a callback\n"; <span class="ent">➊</span>&#13;
  std::atexit([] { std::cout &lt;&lt; "***std::atexit callback executing***\n"; }); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "Callback registered\n"; <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed.</span>&#13;
<span class="color1">Entering main()</span>&#13;
<span class="color1">local Tracer constructed.</span>&#13;
<span class="color1">thread_local Tracer constructed.</span>&#13;
<span class="color1">dynamic Tracer constructed.</span>&#13;
<span class="color1">Registering a callback</span>&#13;
<span class="color1">Callback registered <span class="ent">➌</span></span>&#13;
<span class="color1">dynamic Tracer destructed.</span>&#13;
<span class="color1">Exiting main()</span>&#13;
<span class="color1">local Tracer destructed.</span>&#13;
<span class="color1">thread_local Tracer destructed.</span>&#13;
<span class="color1">***std::atexit callback executing*** <span class="ent">➋</span></span>&#13;
<span class="color1">static Tracer destructed.</span></pre>&#13;
<p class="listing"><a id="ch21ex02"/><em>Listing 21-2: Registering an <span class="literal">atexit</span> callback</em></p>&#13;
<p class="indent">Within <span class="literal">run</span>, you announce that you’re about to register a callback <span class="ent">➊</span>, you do it <span class="ent">➋</span>, and then you announce that you’re about to return from <span class="literal">run</span> <span class="ent">➌</span>. In the output, you can plainly see that the callback occurs after you’ve returned from <span class="literal">main</span> and all the non-static objects have destructed.</p>&#13;
<p class="indent">There are two important admonitions when programming a callback function:</p>&#13;
<ul>&#13;
<li class="noindent">You must not throw an uncaught exception from the callback function. Doing so will cause <span class="literal">std::terminate</span> to get invoked.</li>&#13;
<li class="noindent">You need to be very careful interacting with non-static objects in your program. The <span class="literal">atexit</span> callback functions execute after <span class="literal">main</span> returns, so all local, thread local, and dynamic objects will be destroyed at that point unless you take special care to keep them alive.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>You can register at least 32 functions with <span class="codeitalic">std::atexit</span>, although the exact limit is implementation defined.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch21lev3sec2"><strong>Exiting with std::exit</strong></h5>&#13;
<p class="noindent">Throughout the book, you’ve been terminating programs by returning from <span class="literal">main</span>. In some circumstances, such as in multithreaded programs, you might want to exit the program gracefully in some other way, although you <span epub:type="pagebreak" id="page_695"/>should avoid introducing the associated complications. You can use the <span class="literal">std::exit</span> function, which accepts a single <span class="literal">int</span> corresponding to the program’s exit code. It will perform the following cleanup steps:</p>&#13;
<ol>&#13;
<li class="noindent">Thread-local objects associated with the current thread and static objects get destroyed. Any <span class="literal">atexit</span> callback functions get called.</li>&#13;
<li class="noindent">All of stdin, stdout, and stderr get flushed.</li>&#13;
<li class="noindent">Any temporary files get removed.</li>&#13;
<li class="noindent">The program reports the given status code to the operating environment, which resumes control.</li>&#13;
</ol>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex03">Listing 21-3</a> illustrates the behavior of <span class="literal">std::exit</span> by registering an <span class="literal">atexit</span> callback and invoking <span class="literal">exit</span> from within <span class="literal">run</span>.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" };&#13;
&#13;
void run() {&#13;
  std::cout &lt;&lt; "Registering a callback\n"; <span class="ent">➊</span>&#13;
  std::atexit([] { std::cout &lt;&lt; "***std::atexit callback executing***\n"; }); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "Callback registered\n"; <span class="ent">➌</span>&#13;
  std::exit(0); <span class="ent">➍</span>&#13;
}&#13;
&#13;
int main() {&#13;
--<span class="codeitalic1">snip</span>--&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed.</span>&#13;
<span class="color1">Entering main()</span>&#13;
<span class="color1">local Tracer constructed.</span>&#13;
<span class="color1">thread_local Tracer constructed.</span>&#13;
<span class="color1">dynamic Tracer constructed.</span>&#13;
<span class="color1">Registering a callback <span class="ent">➊</span></span>&#13;
<span class="color1">Callback registered <span class="ent">➌</span></span>&#13;
<span class="color1">thread_local Tracer destructed.</span>&#13;
<span class="color1">***std::atexit callback executing*** <span class="ent">➍</span></span>&#13;
<span class="color1">static Tracer destructed.</span></pre>&#13;
<p class="listing"><a id="ch21ex03"/><em>Listing 21-3: Invoking <span class="literal">std::exit</span></em></p>&#13;
<p class="indent">Within <span class="literal">run</span>, you announce that you’re registering a callback <span class="ent">➊</span>, you register one with <span class="literal">atexit</span> <span class="ent">➋</span>, you announce that you’ve completed registering <span class="ent">➌</span>, <span epub:type="pagebreak" id="page_696"/>and you invoke <span class="literal">exit</span> with argument zero <span class="ent">➍</span>. Compare the program output from <a href="ch21.xhtml#ch21ex03">Listing 21-3</a> to the output from <a href="ch21.xhtml#ch21ex02">Listing 21-2</a>. Notice that the following lines don’t appear:</p>&#13;
<pre>dynamic Tracer destructed.&#13;
Exiting main()&#13;
local Tracer destructed.</pre>&#13;
<p class="indent">According to the rules for <span class="literal">std::exit</span>, local variables on the call stack don’t get cleaned up. And of course, because the program never returns to <span class="literal">main</span> from <span class="literal">run</span>, <span class="literal">delete</span> never gets called. Ouch.</p>&#13;
<p class="indent">This example highlights an important consideration: you shouldn’t use <span class="literal">std::exit</span> to handle normal program execution. It’s mentioned here for completeness, because you might see it in earlier C++ code.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="literal">&lt;cstdlib&gt;</span> header also includes a <span class="literal">std::quick_exit</span>, which invokes callbacks that you register with <span class="literal">std::at_quick_exit</span>, which has a similar interface to <span class="literal">std::atexit</span>. The main difference is that <span class="literal">at_quick_exit</span> callbacks won’t execute unless you explicitly invoke <span class="literal">quick_exit</span>, whereas <span class="literal">atexit</span> callbacks will always execute when the program is about to exit.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch21lev3sec3"><strong>std::abort</strong></h5>&#13;
<p class="noindent">To end a program, you also have a nuclear option by using <span class="literal">std::abort</span>. This function accepts a single integer-valued status code and immediately returns it to the operating environment. No object destructors get called and no <span class="literal">std::atexit</span> callbacks get invoked. <a href="ch21.xhtml#ch21ex04">Listing 21-4</a> illustrates how to use <span class="literal">std::abort</span>.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
struct Tracer {&#13;
--<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Tracer static_tracer{ "static Tracer" };&#13;
&#13;
void run() {&#13;
  std::cout &lt;&lt; "Registering a callback\n"; <span class="ent">➊</span>&#13;
  std::atexit([] { std::cout &lt;&lt; "***std::atexit callback executing***\n"; }); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "Callback registered\n"; <span class="ent">➌</span>&#13;
  std::abort(); <span class="ent">➍</span>&#13;
}&#13;
&#13;
int main() {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">static Tracer constructed.</span>&#13;
<span class="color1">Entering main()</span>&#13;
<span class="color1">local Tracer constructed.</span>&#13;
<span class="color1">thread_local Tracer constructed.</span>&#13;
<span class="color1">dynamic Tracer constructed.</span>&#13;
<span class="color1">Registering a callback</span>&#13;
<span class="color1">Callback registered</span></pre>&#13;
<p class="listing"><a id="ch21ex04"/><em>Listing 21-4: Calling <span class="literal">std::abort</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_697"/>Within <span class="literal">run</span>, you again announce that you’re registering a callback <span class="ent">➊</span>, you register one with <span class="literal">atexit</span> and you announce that you’ve completed registering <span class="ent">➌</span>. This time, you invoke <span class="literal">abort</span> instead <span class="ent">➍</span>. Notice that no output prints after you announce that you’ve completed callback registration <span class="ent">➊</span>. The program doesn’t clean up any objects, and your <span class="literal">atexit</span> callback doesn’t get called.</p>&#13;
<p class="indent">As you might imagine, there aren’t too many canonical uses for <span class="literal">std::abort</span>. The main one you’re likely to encounter is the default behavior of <span class="literal">std::terminate</span>, which gets called when two exceptions are in flight at once.</p>&#13;
<h4 class="h4" id="ch21lev2sec2"><strong><em>Communicating with the Environment</em></strong></h4>&#13;
<p class="noindent">Sometimes, you might want to spawn another process. For example, Google’s Chrome Browser launches many processes to service a single browser session. This builds in some security and robustness by piggybacking the operating system’s process model. Web apps and plug-ins, for example, run in separate processes, so if they crash, the entire browser doesn’t crash. Also, by running the browser’s rendering engine in a separate process, any security vulnerabilities become more difficult to exploit because Google locks down that process’s permissions in what is known as a sandboxed environment.</p>&#13;
<h5 class="h5" id="ch21lev3sec4"><strong>std::system</strong></h5>&#13;
<p class="noindent">You can launch a separate process with the <span class="literal">std::system</span> function in the <span class="literal">&lt;cstdlib&gt;</span> header, which accepts a C-style string corresponding to the command you want to execute and returns an <span class="literal">int</span> corresponding to the return code from the command. The actual behavior depends on the operating environment. For example, the function will call <em>cmd.exe</em> on a Windows machine and <em>/bin/sh</em> on a Linux machine. This function blocks while the command is still executing.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex05">Listing 21-5</a> illustrates how to use <span class="literal">std::system</span> to ping a remote host. (You’ll need to update the contents of <span class="literal">command</span> to a relevant command for your operating system if you’re not using a Unix-like operating system.)</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main() {&#13;
  std::string command{ "ping -c 4 google.com" }; <span class="ent">➊</span>&#13;
  const auto result = std::system(command.c_str()); <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "The command \'" &lt;&lt; command&#13;
            &lt;&lt; "\' returned " &lt;&lt; result &lt;&lt; "\n";&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_698"/><span class="color1">PING google.com (172.217.15.78): 56 data bytes</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=0 ttl=56 time=4.447 ms</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=1 ttl=56 time=12.162 ms</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=2 ttl=56 time=8.376 ms</span>&#13;
<span class="color1">64 bytes from 172.217.15.78: icmp_seq=3 ttl=56 time=10.813 ms</span>&#13;
&#13;
<span class="color1">--- google.com ping statistics ---</span>&#13;
<span class="color1">4 packets transmitted, 4 packets received, 0.0% packet loss</span>&#13;
<span class="color1">round-trip min/avg/max/stddev = 4.447/8.950/12.162/2.932 ms</span>&#13;
<span class="color1">The command 'ping -c 4 google.com' returned 0 <span class="ent">➌</span></span></pre>&#13;
<p class="listing"><a id="ch21ex05"/><em>Listing 21-5: Using <span class="literal">std::system</span> to invoke the <span class="literal">ping</span> utility (Output is from macOS Mojave version 10.14.)</em></p>&#13;
<p class="indent">First, you initialize a <span class="literal">string</span> called <span class="literal">command</span> containing <span class="literal">ping -c 4 google.com</span> <span class="ent">➊</span>. You then invoke <span class="literal">std::system</span> by passing the contents of <span class="literal">command</span> <span class="ent">➋</span>. This causes the operating system to invoke the <span class="literal">ping</span> command with the argument <span class="literal">-c 4</span>, which specifies four pings, and the address <span class="literal">google.com</span>. Then you print a status message reporting the return value from <span class="literal">std::system</span> <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch21lev3sec5"><strong>std::getenv</strong></h5>&#13;
<p class="noindent">Operating environments usually have <em>environment variables</em>, which users and developers can set to help programs find important information that the programs need to run. The <span class="literal">&lt;cstdlib&gt;</span> header contains the <span class="literal">std::getenv</span> function, which accepts a C-style string corresponding to the name of the environment variable you want to look up, and it returns a C-style string with the contents of the corresponding variable. If no such variable is found, the function returns <span class="literal">nullptr</span> instead.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex06">Listing 21-6</a> illustrates how to use <span class="literal">std::getenv</span> to obtain the <em>path variable</em>, which contains a list of directories containing important executable files.</p>&#13;
<pre>#include &lt;cstdlib&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main() {&#13;
  std::string variable_name{ "PATH" }; <span class="ent">➊</span>&#13;
  std::string result{ std::getenv(variable_name.c_str()) }; <span class="ent">➋</span>&#13;
  std::cout &lt;&lt; "The variable " &lt;&lt; variable_name&#13;
            &lt;&lt; " equals " &lt;&lt; result &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">The variable PATH equals /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span></pre>&#13;
<p class="listing"><a id="ch21ex06"/><em>Listing 21-6: Using <span class="literal">std::getenv</span> to retrieve the path variable (Output is from macOS Mojave version 10.14.)</em></p>&#13;
<p class="indent">First, you initialize a <span class="literal">string</span> called <span class="literal">variable_name</span> containing <span class="literal">PATH</span> <span class="ent">➊</span>. Next, you store the result of invoking <span class="literal">std::getenv</span> with <span class="literal">PATH</span> into a string called <span class="literal">result</span> <span class="ent">➋</span>. Then you print the results to stdout <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch21lev2sec3"><span epub:type="pagebreak" id="page_699"/><strong><em>Managing Operating System Signals</em></strong></h4>&#13;
<p class="noindent">Operating system signals are asynchronous notifications sent to processes that notify the program that an event occurred. The <span class="literal">&lt;csignal&gt;</span> header contains six macro constants that represent different signals from the operating system to the program (these signals are operating system agnostic):</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">SIGTERM</span> represents a termination request.</li>&#13;
<li class="noindent"><span class="literal">SIGSEGV</span> represents invalid memory access.</li>&#13;
<li class="noindent"><span class="literal">SIGINT</span> represents an external interrupt, such as a keyboard interrupt.</li>&#13;
<li class="noindent"><span class="literal">SIGILL</span> represents an invalid program image.</li>&#13;
<li class="noindent"><span class="literal">SIGABRT</span> represents an abnormal termination condition, such as <span class="literal">std::abort</span>.</li>&#13;
<li class="noindent"><span class="literal">SIGFPE</span> represents a floating-point error, such as division by zero.</li>&#13;
</ul>&#13;
<p class="indent">To register a handler for one of these signals, you use the <span class="literal">std::signal</span> function in the <span class="literal">&lt;csignal&gt;</span> header. It accepts a single <span class="literal">int</span> value corresponding to one of the listed signal macros as its first argument. Its second argument is a function pointer (not a function object!) to a function that accepts an <span class="literal">int</span> corresponding to the signal macro and returning <span class="literal">void</span>. This function must have C linkage (although most implementations also permit C++ linkage). You’ll learn about C linkage later in the chapter. For now, simply prepend <span class="literal">extern "C"</span> to your function definition. Notice that, due to the asynchronous nature of the interrupts, any accesses to a global, mutable state must be synchronized.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex07">Listing 21-7</a> contains a program that waits for a keyboard interrupt.</p>&#13;
<pre>#include &lt;csignal&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;chrono&gt;&#13;
#include &lt;thread&gt;&#13;
#include &lt;atomic&gt;&#13;
&#13;
std::atomic_bool interrupted{}; <span class="ent">➊</span>&#13;
&#13;
extern "C" void handler(int signal) {&#13;
  std::cout &lt;&lt; "Handler invoked with signal " &lt;&lt; signal &lt;&lt; ".\n"; <span class="ent">➋</span>&#13;
  interrupted = true; <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
  using namespace std::chrono_literals;&#13;
  std::signal(SIGINT, handler); <span class="ent">➍</span>&#13;
  while(!interrupted) { <span class="ent">➎</span>&#13;
    std::cout &lt;&lt; "Waiting..." &lt;&lt; std::endl; <span class="ent">➏</span>&#13;
    std::this_thread::sleep_for(1s);&#13;
  }&#13;
  std::cout &lt;&lt; "Interrupted!\n"; <span class="ent">➐</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">Waiting...</span>&#13;
<span class="color1">Waiting...</span>&#13;
<span class="color1">Waiting...</span>&#13;
<span class="color1">Handler invoked with signal 2.</span>&#13;
<span class="color1">Interrupted! <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_700"/><a id="ch21ex07"/><em>Listing 21-7: Registering for keyboard interrupts with <span class="literal">std::signal</span></em></p>&#13;
<p class="indent">You first declare an <span class="literal">atomic_bool</span> called <span class="literal">interrupted</span> that stores whether the program has received a keyboard interrupt <span class="ent">➊</span> (it has static storage duration because you cannot use function objects with <span class="literal">std::signal</span> and therefore must use a non-member function to handle the callback). Next, you declare a callback handler that accepts an <span class="literal">int</span> called <span class="literal">signal</span>, prints its value to stdout <span class="ent">➋</span>, and sets <span class="literal">interrupted</span> to true <span class="ent">➌</span>.</p>&#13;
<p class="indent">Within <span class="literal">main</span>, you set the signal handler for the <span class="literal">SIGINT</span> interrupt code to <span class="literal">handler</span> <span class="ent">➍</span>. Within a loop, you wait for the program to get interrupted <span class="ent">➎</span> by printing a message <span class="ent">➏</span> and sleeping for a second <span class="ent">➐</span>. Once the program has been interrupted, you print a message and return from <span class="literal">main</span> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Typically, you can cause a keyboard interrupt on modern operating systems by pressing <small>CTRL</small>-C.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch21lev1sec2"><strong>Boost ProgramOptions</strong></h3>&#13;
<p class="noindent">Most console applications accept command line parameters. As you learned in “The Three <span class="literal">main</span> Overloads” on <a href="ch09.xhtml#page_272">page 272</a>, you can define <span class="literal">main</span> to accept the parameters <span class="literal">argc</span> and <span class="literal">argv</span>, which the operating environment will populate with the number of arguments and argument contents, respectively. You can always parse these manually and modify your program’s behavior accordingly, but there’s a better way: the Boost ProgramOptions library is an essential ingredient for writing console applications.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>All the Boost ProgramOptions classes presented in this section are available in the <span class="literal">&lt;boost/program_options.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<p class="indent">You might be tempted to write your own argument-parsing code, but ProgramOptions is a smarter choice for four reasons:</p>&#13;
<ol>&#13;
<li class="noindent"><strong>It’s far more convenient.</strong> Once you learn the succinct, declarative syntax of ProgramOptions, you can easily describe fairly complicated console interfaces in a few lines of code.</li>&#13;
<li class="noindent"><strong>It handles errors effortlessly.</strong> When the user misuses your program, ProgramOptions tells the user how they misused the program without any additional effort on your part.</li>&#13;
<li class="noindent"><strong>It automatically generates a help prompt.</strong> Based on your declarative markup, ProgramOptions creates nicely formatted, easy to employ documentation on your behalf.</li>&#13;
<li class="noindent"><strong>It grows beyond the command line.</strong> If you want to draw configuration from config files or environment variables, it’s easy to transition from command line arguments.</li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_701"/>ProgramOptions comprises three parts:</p>&#13;
<ol>&#13;
<li class="noindent"><strong>The options description</strong> allows you to specify the allowed options.</li>&#13;
<li class="noindent"><strong>The parsers component</strong> extracts option names and values from the command line, config files, and environment variables.</li>&#13;
<li class="noindent"><strong>The storage component</strong> provides you with the interface to access typed options.</li>&#13;
</ol>&#13;
<p class="indent">In the subsections that follow, you’ll learn about each of these parts.</p>&#13;
<h4 class="h4" id="ch21lev2sec4"><strong><em>The Options Description</em></strong></h4>&#13;
<p class="noindent">Three main classes comprise the options description component:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">boost::program_options::option_description</span> describes a single option.</li>&#13;
<li class="noindent"><span class="literal">boost::program_options::value_semantic</span> knows the desired type of a single option.</li>&#13;
<li class="noindent"><span class="literal">boost::program_options::options_description</span> is a container for multiple objects of type <span class="literal">option_description</span>.</li>&#13;
</ul>&#13;
<p class="indent">You construct an <span class="literal">options_description</span> to, unsurprisingly, specify a description for the program’s options. Optionally, you can include a single string argument in the constructor that describes your program. This will print in the description if you include it, but it will have no functional impact. Next, you use its <span class="literal">add_options</span> method, which returns a special kind of object of type <span class="literal">boost::program_options::options_description_easy_init</span>. This class has a special <span class="literal">operator()</span> that accepts at least two arguments.</p>&#13;
<p class="indent">The first argument is the name of the option you want to add. ProgramOptions is very smart, so you can provide a long name and a short name separated by a comma. For example, if you had an option called <span class="literal">threads</span>, ProgramOptions would bind the parameter <span class="literal">--threads</span> from the command line to this option. If instead you named the option <span class="literal">threads,t</span>, ProgramOptions would bind either <span class="literal">--threads</span> or <span class="literal">-t</span> to your option.</p>&#13;
<p class="indent">The second argument is the description of the option. You can employ a <span class="literal">value_semantic</span>, a C-style string description, or both. Because <span class="literal">options_description_easy_init</span> returns a reference to itself from <span class="literal">operator()</span>, you can chain these calls together to form a succinct representation of your program’s options. Typically, you don’t create <span class="literal">value_semantic</span> objects directly. Instead, you use the convenience template function <span class="literal">boost::program_options::value</span> to generate them. It accepts a single template parameter corresponding to the desired type of the option. The resulting pointer points to an object that has code to parse text input (from the command line, for example) into the desired type. To specify an option of <span class="literal">int</span> type, for example, you would invoke <span class="literal">value&lt;int&gt;()</span>.</p>&#13;
<p class="indent">The resulting pointed-to object will have several methods that allow you to specify additional information about the option. For example, you can employ the <span class="literal">default_value</span> method to set the option’s default value. To specify <span epub:type="pagebreak" id="page_702"/>that an option of <span class="literal">int</span> type should default to 42, you would use the following construction:</p>&#13;
<pre>value&lt;int&gt;()-&gt;default_value(42)</pre>&#13;
<p class="indent">Another common pattern is an option that can take multiple tokens. Such options are allowed to have spaces between elements, and they’ll be parsed into a single string. To allow this, simply use the <span class="literal">multitoken</span> method. For example, to specify that an option can take multiple <span class="literal">std::string</span> values, you would use the following construction:</p>&#13;
<pre>value&lt;std::string&gt;()-&gt;multitoken()</pre>&#13;
<p class="indent">If instead you want to allow multiple instances of the same option, you can specify a <span class="literal">std::vector</span> as a value, like this:</p>&#13;
<pre>value&lt;std::vector&lt;std::string&gt;&gt;()</pre>&#13;
<p class="indent">If you have a Boolean option, you’ll use the convenience function <span class="literal">boost::program_options::bool_switch</span>, which accepts a pointer to a <span class="literal">bool</span>. If a user includes the corresponding option, the function will set the pointed-to <span class="literal">bool</span> to true. For example, the following construction will set a <span class="literal">bool</span> called <span class="literal">flag</span> to <span class="literal">true</span> if the corresponding option is included:</p>&#13;
<pre>bool_switch(&amp;flag)</pre>&#13;
<p class="indent">The <span class="literal">options_description</span> class supports <span class="literal">operator&lt;&lt;</span>, so you can create a nicely formatted help dialog without any additional effort. <a href="ch21.xhtml#ch21ex08">Listing 21-8</a> illustrates how to use ProgramOptions to create a <span class="literal">program_options</span> object for a sample program called <em>mgrep</em>.</p>&#13;
<pre>#include &lt;boost/program_options.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main(int argc, char** argv) {&#13;
  using namespace boost::program_options;&#13;
  bool is_recursive{}, is_help{};&#13;
&#13;
  options_description description{ "mgrep [options] pattern path1 path2 ..."&#13;
}; <span class="ent">➊</span>&#13;
  description.add_options()&#13;
          ("help,h", bool_switch(&amp;is_help), "display a help dialog") <span class="ent">➋</span>&#13;
          ("threads,t", value&lt;int&gt;()-&gt;default_value(4),&#13;
                        "number of threads to use") <span class="ent">➌</span>&#13;
          ("recursive,r", bool_switch(&amp;is_recursive),&#13;
                          "search subdirectories recursively") <span class="ent">➍</span>&#13;
          ("pattern", value&lt;std::string&gt;(), "pattern to search for") <span class="ent">➎</span>&#13;
          ("paths", value&lt;std::vector&lt;std::string&gt;&gt;(), "path to search"); <span class="ent">➏</span>&#13;
  std::cout &lt;&lt; description; <span class="ent">➐</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_703"/>-----------------------------------------------------------------------&#13;
<span class="color1">mgrep [options] pattern path1 path2 ...:</span>&#13;
<span class="color1">  -h [ --help ]             display a help dialog</span>&#13;
<span class="color1">  -t [ --threads ] arg (=4) number of threads to use</span>&#13;
<span class="color1">  -r [ --recursive ]        search subdirectories recursively</span>&#13;
<span class="color1">  --pattern arg             pattern to search for</span>&#13;
<span class="color1">  --path arg                path to search</span></pre>&#13;
<p class="listing"><a id="ch21ex08"/><em>Listing 21-8: Using Boost ProgramOptions to generate a nicely formatted help dialog</em></p>&#13;
<p class="indent">First, you initialize an <span class="literal">options_description</span> object using a custom usage string <span class="ent">➊</span>. Next, you invoke <span class="literal">add_options</span> and begin adding options: a Boolean flag indicating whether to display a help dialog <span class="ent">➋</span>, an <span class="literal">int</span> indicating how many threads to use <span class="ent">➌</span>, another Boolean flag indicating whether to search subdirectories in a <span class="literal">recursive</span> manner <span class="ent">➍</span>, a <span class="literal">std::string</span> indicating which <span class="literal">pattern</span> to search for within files <span class="ent">➎</span>, and a list of <span class="literal">std::string</span> values corresponding to the <span class="literal">paths</span> to search <span class="ent">➏</span>. You then write the <span class="literal">description</span> to stdout <span class="ent">➐</span>.</p>&#13;
<p class="indent">Suppose that your yet to be implemented mgrep program will always require a <span class="literal">pattern</span> and a <span class="literal">paths</span> argument. You could convert these into <em>positional</em><em>arguments</em>, which as their name implies will assign arguments based on their position. To do this, you employ the <span class="literal">boost::program_options::positional_options_description</span> class, which doesn’t take any constructor arguments. You use the <span class="literal">add</span> method, which takes two arguments: a C-style string corresponding to the option you want to convert to positional and an <span class="literal">int</span> corresponding to the number of arguments you want to bind to it. You can invoke <span class="literal">add</span> multiple times to add multiple positional arguments. But the order matters. Positional arguments will bind from left to right, so your first <span class="literal">add</span> invocation applies to the left positional arguments. For the last positional option, you can use the number <span class="literal">-1</span> to tell ProgramOptions to bind all remaining elements to the corresponding option.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex09">Listing 21-9</a> provides a snippet that you could append into <span class="literal">main</span> in <a href="ch21.xhtml#ch21ex07">Listing 21-7</a> to add the positional arguments.</p>&#13;
<pre>  positional_options_description positional; <span class="ent">➊</span>&#13;
  positional.add("pattern", 1); <span class="ent">➋</span>&#13;
  positional.add("path", -1); <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch21ex09"/><em>Listing 21-9: Adding positional arguments to <a href="ch21.xhtml#ch21ex08">Listing 21-8</a></em></p>&#13;
<p class="indent">You initialize a <span class="literal">positional_options_description</span> without any constructor arguments <span class="ent">➊</span>. Next, you invoke <span class="literal">add</span> and pass the arguments <span class="literal">pattern</span> and <span class="literal">1</span>, which will bind the first positional option to the <em>pattern</em> option <span class="ent">➋</span>. You invoke <span class="literal">add</span> again, this time passing the arguments <span class="literal">path</span> and <span class="literal">-1</span> <span class="ent">➌</span>, which will bind the remaining positional options to the <em>path</em> option.</p>&#13;
<h4 class="h4" id="ch21lev2sec5"><strong><em>Parsing Options</em></strong></h4>&#13;
<p class="noindent">Now that you’ve declared how your program accepts options, you can parse user input. It’s possible to take configuration from environment variables, configuration files, and the command line. For brevity, this section only discusses the last.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_704"/><em>For information on how to obtain configuration from environment variables and configuration files, refer to the Boost ProgramOptions documentation, especially the tutorial.</em></p>&#13;
</div>&#13;
<p class="indent">To parse command line input, you use the <span class="literal">boost::program_options::command_line_parser</span> class, which accepts two constructor parameters arguments: an <span class="literal">int</span> corresponding to <em>argc</em>, the number of arguments on the command line, and a <span class="literal">char**</span> corresponding to <em>argv</em>, the value (or content) of the arguments on the command line. This class offers several important methods that you’ll use to declare how the parser should interpret user input.</p>&#13;
<p class="indent">First, you’ll invoke its <span class="literal">options</span> method, which takes a single argument corresponding to your <span class="literal">options_description</span>. Next, you’ll use the positional method, which takes a single argument corresponding to your <span class="literal">positional_options_description</span>. Finally, you’ll invoke <span class="literal">run</span> without any arguments. This causes the parser to parse the command line input and return a <span class="literal">parsed_options</span> object.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex10">Listing 21-10</a> provides a snippet that you could append into <span class="literal">main</span> after <a href="ch21.xhtml#ch21ex08">Listing 21-8</a> to incorporate a <span class="literal">command_line_parser</span>.</p>&#13;
<pre>command_line_parser parser{ argc, argv }; <span class="ent">➊</span>&#13;
parser.options(description); <span class="ent">➋</span>&#13;
parser.positional(positional); <span class="ent">➌</span>&#13;
auto parsed_result = parser.run(); <span class="ent">➍</span></pre>&#13;
<p class="listing"><a id="ch21ex10"/><em>Listing 21-10: Adding the <span class="literal">command_line_parser</span> to <a href="ch21.xhtml#ch21ex08">Listing 21-8</a></em></p>&#13;
<p class="indent">You initialize a <span class="literal">command_line_parser</span> called <span class="literal">parser</span> by passing in the arguments from <span class="literal">main</span> <span class="ent">➊</span>. Next, you pass the <span class="literal">options_description</span> object to the <span class="literal">options</span> method <span class="ent">➋</span> and the <span class="literal">positional_options_description</span> to the <span class="literal">positional</span> method <span class="ent">➌</span>. Then you invoke the <span class="literal">run</span> method to produce your <span class="literal">parsed_options</span> object <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>If the user passes input that doesn’t parse, for example, because they provide an option that isn’t part of your description, the parser will throw an exception that inherits from <span class="literal">std::exception</span>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch21lev2sec6"><strong><em>Storing and Accessing Options</em></strong></h4>&#13;
<p class="noindent">You store program options into a <span class="literal">boost::program_options::variables_map</span> class, which takes no arguments in its constructor. To place your parsed options into a <span class="literal">variables_map</span>, you use the <span class="literal">boost::program_options::store</span> method, which takes a <span class="literal">parsed_options</span> object as its first argument and a <span class="literal">variables_map</span> object as its second argument. Then you call the <span class="literal">boost::program_options::notify</span> method, which takes a single <span class="literal">variables_map</span> argument. At this point, your <span class="literal">variables_map</span> contains all the options your user has specified.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex11">Listing 21-11</a> provides a snippet that you could append into <span class="literal">main</span> after <a href="ch21.xhtml#ch21ex10">Listing 21-10</a> to parse results into a <span class="literal">variables_map</span>.</p>&#13;
<pre>variables_map vm; <span class="ent">➊</span>&#13;
store(parsed_result, vm); <span class="ent">➋</span>&#13;
notify(vm); <span class="ent">➌</span></pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_705"/><a id="ch21ex11"/><em>Listing 21-11: Storing results into a <span class="literal">variables_map</span></em></p>&#13;
<p class="indent">You first declare a <span class="literal">variables_map</span> <span class="ent">➊</span>. Next, you pass your <span class="literal">parsed_result</span> from <a href="ch21.xhtml#ch21ex10">Listing 21-10</a> and your newly declared <span class="literal">variables_map</span> to <span class="literal">store</span> <span class="ent">➋</span>. Then you call <span class="literal">notify</span> on your <span class="literal">variables_map</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The <span class="literal">variables_map</span> class is an associative container that is essentially similar to a <span class="literal">std::map&lt;std::string, boost::any&gt;</span>. To extract an element, you use <span class="literal">operator[]</span> by passing the option name as the key. The result is a <span class="literal">boost::any</span>, so you’ll need to convert it to the correct type using its <span class="literal">as</span> method. (You learned about <span class="literal">boost::any</span> in “<span class="literal">any</span>” on <a href="ch12.xhtml#page_378">page 378</a>.) It’s crucial to check for any options that might be empty by using the <span class="literal">empty</span> method. If you fail to do so and you cast the <span class="literal">any</span> anyway, you’ll get a runtime error.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex12">Listing 21-12</a> illustrates how you can retrieve values from a <span class="literal">variables_map</span>.</p>&#13;
<pre>if (is_help) std::cout &lt;&lt; "Is help.\n"; <span class="ent">➊</span>&#13;
if (is_recursive) std::cout &lt;&lt; "Is recursive.\n"; <span class="ent">➋</span>&#13;
std::cout &lt;&lt; "Threads: " &lt;&lt; vm["threads"].as&lt;int&gt;() &lt;&lt; "\n"; <span class="ent">➌</span>&#13;
if (!vm["pattern"].empty()) { <span class="ent">➍</span>&#13;
  std::cout &lt;&lt; "Pattern: " &lt;&lt; vm["pattern"].as&lt;std::string&gt;() &lt;&lt; "\n"; <span class="ent">➎</span>&#13;
} else {&#13;
  std::cout &lt;&lt; "Empty pattern.\n";&#13;
}&#13;
if (!vm["path"].empty()) { <span class="ent">➏</span>&#13;
  std::cout &lt;&lt; "Paths:\n";&#13;
  for(const auto&amp; path : vm["path"].as&lt;std::vector&lt;std::string&gt;&gt;()) <span class="ent">➐</span>&#13;
    std::cout &lt;&lt; "\t" &lt;&lt; path &lt;&lt; "\n";&#13;
} else {&#13;
  std::cout &lt;&lt; "Empty path.\n";&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex12"/><em>Listing 21-12: Retrieving values from a <span class="literal">variables_map</span></em></p>&#13;
<p class="indent">Because you use the <span class="literal">bool_switch</span> value for the <span class="literal">help</span> and <span class="literal">recursive</span> options, you simply use those Boolean values directly to determine whether the user has requested either <span class="ent">➊</span><span class="ent">➋</span>. Because <span class="literal">threads</span> has a default value, you don’t need to make sure that it’s empty, so you can extract its value using as<span class="literal">&lt;int&gt;</span> directly <span class="ent">➌</span>. For those options without defaults, such as <span class="literal">pattern</span>, you first check for <span class="literal">empty</span> <span class="ent">➍</span>. If those options aren’t empty, you can extract their values using <span class="literal">as&lt;std::string&gt;</span> <span class="ent">➎</span>. You do the same for <span class="literal">path</span> <span class="ent">➏</span>, which allows you extract the user-provided collection with <span class="literal">as&lt;std::vector&lt;std::string&gt;&gt;</span> <span class="ent">➐</span>.</p>&#13;
<h4 class="h4" id="ch21lev2sec7"><strong><em>Putting It All Together</em></strong></h4>&#13;
<p class="noindent">Now you have all the requisite knowledge to assemble a ProgramOptions-based application. <a href="ch21.xhtml#ch21ex13">Listing 21-13</a> illustrates one way to stitch the previous listings together.</p>&#13;
<pre><span epub:type="pagebreak" id="page_706"/>#include &lt;boost/program_options.hpp&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
int main(int argc, char** argv) {&#13;
  using namespace boost::program_options;&#13;
  bool is_recursive{}, is_help{};&#13;
&#13;
  options_description description{ "mgrep [options] pattern path1 path2 ..." };&#13;
  description.add_options()&#13;
          ("help,h", bool_switch(&amp;is_help), "display a help dialog")&#13;
          ("threads,t", value&lt;int&gt;()-&gt;default_value(4),&#13;
                        "number of threads to use")&#13;
          ("recursive,r", bool_switch(&amp;is_recursive),&#13;
                         "search subdirectories recursively")&#13;
          ("pattern", value&lt;std::string&gt;(), "pattern to search for")&#13;
          ("path", value&lt;std::vector&lt;std::string&gt;&gt;(), "path to search");&#13;
&#13;
  positional_options_description positional;&#13;
  positional.add("pattern", 1);&#13;
  positional.add("path", -1);&#13;
&#13;
  command_line_parser parser{ argc, argv };&#13;
  parser.options(description);&#13;
  parser.positional(positional);&#13;
&#13;
  variables_map vm;&#13;
  try {&#13;
    auto parsed_result = parser.run(); <span class="ent">➊</span>&#13;
    store(parsed_result, vm);&#13;
    notify(vm);&#13;
  } catch (const std::exception&amp; e) {&#13;
    std::cerr &lt;&lt; e.what() &lt;&lt; "\n";&#13;
    return -1;&#13;
  }&#13;
&#13;
  if (is_help) { <span class="ent">➋</span>&#13;
    std::cout &lt;&lt; description;&#13;
    return 0;&#13;
  }&#13;
  if (vm["pattern"].empty()) { <span class="ent">➌</span>&#13;
    std::cerr &lt;&lt; "You must provide a pattern.\n";&#13;
    return -1;&#13;
  }&#13;
  if (vm["path"].empty()) { <span class="ent">➍</span>&#13;
    std::cerr &lt;&lt; "You must provide at least one path.\n";&#13;
    return -1;&#13;
  }&#13;
  const auto threads = vm["threads"].as&lt;int&gt;();&#13;
  const auto&amp; pattern = vm["pattern"].as&lt;std::string&gt;();&#13;
  const auto&amp; paths = vm["path"].as&lt;std::vector&lt;std::string&gt;&gt;();&#13;
  // Continue program here ... <span class="ent">➎</span>&#13;
  std::cout &lt;&lt; "Ok." &lt;&lt; std::endl;&#13;
}</pre>&#13;
<p class="listing"><span epub:type="pagebreak" id="page_707"/><a id="ch21ex13"/><em>Listing 21-13: A complete command line parameter-parsing application using the previous listings</em></p>&#13;
<p class="indent">The first departure from the previous listings is that you wrap the call to run on your parser using a <span class="literal">try</span>-<span class="literal">catch</span> block to mitigate erroneous input provided by the user <span class="ent">➊</span>. If they do provide erroneous input, you simply catch the exception, print the error to stderr, and <span class="literal">return</span>.</p>&#13;
<p class="indent">Once you declare your program options and store them, as in <a href="ch21.xhtml#ch21ex08">Listings 21-8</a> to <a href="ch21.xhtml#ch21ex12">21-12</a>, you first check whether the user has requested a help prompt <span class="ent">➋</span>. If so, you simply print the usage and exit, because there’s no need to perform any further checking. Next, you perform some error checking to make sure the user has provided a pattern <span class="ent">➌</span> and at least one path <span class="ent">➍</span>. If not, you print an error along with the program’s correct usage and exit; otherwise, you can continue writing your program <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch21.xhtml#ch21ex14">Listing 21-14</a> shows various outputs from your program, which is compiled into the binary mgrep.</p>&#13;
<pre>$ ./mgrep <span class="ent">➊</span>&#13;
You must provide a pattern.&#13;
$ ./mgrep needle <span class="ent">➋</span>&#13;
You must provide at least one path.&#13;
$ ./mgrep --supercharge needle haystack1.txt haystack2.txt <span class="ent">➌</span>&#13;
unrecognised option '--supercharge'&#13;
$ ./mgrep --help <span class="ent">➍</span>&#13;
mgrep [options] pattern path1 path2 ...:&#13;
  -h [ --help ]             display a help dialog&#13;
  -t [ --threads ] arg (=4) number of threads to use&#13;
  -r [ --recursive ]        search subdirectories recursively&#13;
  --pattern arg             pattern to search for&#13;
  --path arg                path to search&#13;
$ ./mgrep needle haystack1.txt haystack2.txt haystack3.txt <span class="ent">➎</span>&#13;
Ok.&#13;
$ ./mgrep --recursive needle haystack1.txt <span class="ent">➏</span>&#13;
Ok.&#13;
$ ./mgrep -rt 10 needle haystack1.txt haystack2.txt <span class="ent">➐</span>&#13;
Ok.</pre>&#13;
<p class="listing"><a id="ch21ex14"/><em>Listing 21-14: Various invocations and outputs from the program in <a href="ch21.xhtml#ch21ex13">Listing 21-13</a></em></p>&#13;
<p class="indent">The first three invocations return errors for different reasons: you haven’t provided a pattern <span class="ent">➊</span>, you haven’t provided a path <span class="ent">➋</span>, or you provided an unrecognized option <span class="ent">➌</span>.</p>&#13;
<p class="indent">In the next invocation, you get the friendly help dialog because you provided the <span class="literal">--help</span> option <span class="ent">➍</span>. The final three invocations parse correctly because all contain a pattern and at least one path. The first contains no options <span class="ent">➎</span>, the second uses the longhand option syntax <span class="ent">➏</span>, and the third uses the shorthand option syntax <span class="ent">➐</span>.</p>&#13;
<h3 class="h3" id="ch21lev1sec3"><span epub:type="pagebreak" id="page_708"/><strong>Special Topics in Compilation</strong></h3>&#13;
<p class="noindent">This section explains several important preprocessor features that will help you understand the double-inclusion problem, which is described in the following subsection, and how to solve it. You’ll learn about different options for optimizing your code by using compiler flags. Additionally, you’ll learn how to allow your linker to interoperate with C using a special language keyword.</p>&#13;
<h4 class="h4" id="ch21lev2sec8"><strong><em>Revisiting the Preprocessor</em></strong></h4>&#13;
<p class="noindent">The preprocessor is a program that applies simple transformations to source code before compilation. You give instructions to the preprocessor using preprocessor directives. All preprocessor directives begin with a hash mark (<span class="literal">#</span>). Recall from “The Compiler Tool Chain,” on <a href="ch01.xhtml#page_5">page 5</a> that <span class="literal">#include</span> is a preprocessor directive that tells the preprocessor to copy and paste the contents of the corresponding header directly into the source code.</p>&#13;
<p class="indent">The preprocessor also supports other directives. The most common is the <em>macro</em>, which is a fragment of code that’s been given a name. Whenever you use that name within C++ code, the preprocessor replaces that name with the contents of the macro.</p>&#13;
<p class="indent">The two different kinds of macros are object-like and function-like. You declare an object-like macro using the following syntax:</p>&#13;
<pre>#define <span class="codeitalic1">&lt;NAME&gt; &lt;CODE&gt;</span></pre>&#13;
<p class="noindent">where <span class="codeitalic">NAME</span> is the name of the macro and <span class="literal">CODE</span> is the code to replace that name. For example, <a href="ch21.xhtml#ch21ex15">Listing 21-15</a> illustrates how to define a string literal to a macro.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#define MESSAGE "LOL" <span class="ent">➊</span>&#13;
&#13;
int main(){&#13;
  printf(MESSAGE); <span class="ent">➋</span>&#13;
}&#13;
-----------------------------------------------------------------------&#13;
<span class="color1">LOL</span></pre>&#13;
<p class="listing"><a id="ch21ex15"/><em>Listing 21-15: A C++ program with an object-like macro</em></p>&#13;
<p class="indent">You define the macro <span class="literal">MESSAGE</span> to correspond with the code <span class="literal">"LOL"</span> <span class="ent">➊</span>. Next, you use the <span class="literal">MESSAGE</span> macro as the format string to <span class="literal">printf</span> <span class="ent">➋</span>. After the preprocessor has completed work on <a href="ch21.xhtml#ch21ex15">Listing 21-15</a>, it appears as <a href="ch21.xhtml#ch21ex16">Listing 21-16</a> to the compiler.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main(){&#13;
  printf("LOL");&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex16"/><em>Listing 21-16: The result of preprocessing <a href="ch21.xhtml#ch21ex15">Listing 21-15</a></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_709"/>The preprocessor is nothing more than a copy-and-paste tool here. The macro disappears, and you’re left with a simple program that prints <span class="literal">LOL</span> to the console.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you want to inspect the work that the preprocessor does, compilers usually have a flag that will limit compilation to just the preprocessing step. This will cause the compiler to emit the preprocessed source file corresponding to each translation unit. On GCC, Clang, and MSVC, for example, you can use the <span class="literal">-E</span> flag.</em></p>&#13;
</div>&#13;
<p class="indent">A function-like macro is just like an object-like macro except it can take a list of parameters after its identifier:</p>&#13;
<pre>#define <span class="codeitalic1">&lt;NAME&gt;</span>(<span class="codeitalic1">&lt;PARAMETERS&gt;</span>) <span class="codeitalic1">&lt;CODE&gt;</span></pre>&#13;
<p class="indent">You can use these <span class="codeitalic">PARAMETERS</span> within the <span class="codeitalic">CODE</span>, allowing the user to customize the macro’s behavior. <a href="ch21.xhtml#ch21ex17">Listing 21-17</a> contains the function-like macro <span class="literal">SAY_LOL_WITH</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#define SAY_LOL_WITH(fn) fn("LOL") <span class="ent">➊</span>&#13;
&#13;
int main() {&#13;
  SAY_LOL_WITH(printf); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex17"/><em>Listing 21-17: A C++ program with a function-like macro</em></p>&#13;
<p class="indent">The <span class="literal">SAY_LOL_WITH</span> macro accepts a single parameter named <span class="literal">fn</span> <span class="ent">➊</span>. The preprocessor pastes the macro into the expression <span class="literal">fn("LOL")</span>. When it evaluates <span class="literal">SAY_LOL_WITH</span>, the preprocessor pastes <span class="literal">printf</span> into the expression <span class="ent">➋</span>, yielding a translation unit just like <a href="ch21.xhtml#ch21ex16">Listing 21-16</a>.</p>&#13;
<h5 class="h5" id="ch21lev3sec6"><strong>Conditional Compilation</strong></h5>&#13;
<p class="noindent">The preprocessor also offers <em>conditional compilation</em>, a facility that provides basic <span class="literal">if</span>-<span class="literal">else</span> logic. Several flavors of conditional compilation are available, but the one you’re likely to encounter is illustrated in <a href="ch21.xhtml#ch21ex18">Listing 21-18</a>.</p>&#13;
<pre>#ifndef MY_MACRO <span class="ent">➊</span>&#13;
// Segment 1 <span class="ent">➋</span>&#13;
#else&#13;
// Segment 2 <span class="ent">➌</span>&#13;
#endif</pre>&#13;
<p class="listing"><a id="ch21ex18"/><em>Listing 21-18: A C++ program with a conditional compilation</em></p>&#13;
<p class="indent">If <span class="literal">MY_MACRO</span> isn’t defined at the point where the preprocessor evaluates <span class="literal">#ifndef</span> <span class="ent">➊</span>, <a href="ch21.xhtml#ch21ex18">Listing 21-18</a> reduces to the code represented by <span class="literal">// Segment 1</span> <span class="ent">➋</span>. If <span class="literal">MY_MACRO</span> is <span class="literal">#defined</span>, <a href="ch21.xhtml#ch21ex18">Listing 21-18</a> evaluates to the code represented by <span class="literal">// Segment 2</span> <span class="ent">➌</span>. The <span class="literal">#else</span> is optional.</p>&#13;
<h5 class="h5" id="ch21lev3sec7"><span epub:type="pagebreak" id="page_710"/><strong>Double Inclusion</strong></h5>&#13;
<p class="noindent">Aside from using <span class="literal">#include</span>, you should use the preprocessor as little as possible. The preprocessor is extremely primitive and will cause difficult-to-debug errors if you lean on it too heavily. This is evident with <span class="literal">#include</span>, which is a simple copy-and-paste command.</p>&#13;
<p class="indent">Because you can define a symbol only once (a rule appropriately called the <em>one-definition rule</em>), you must ensure that your headers don’t attempt to redefine symbols. The easiest way to make this mistake is by including the same header twice, which is called the <em>double-inclusion problem</em>.</p>&#13;
<p class="indent">The usual way to avoid the double-inclusion problem is to use conditional compilation to make an <em>include guard</em>. The include guard detects whether a header has been included before. If it has, it uses conditional compilation to empty the header. <a href="ch21.xhtml#ch21ex19">Listing 21-19</a> illustrates how to put include guards around a header.</p>&#13;
<pre>// step_function.h&#13;
#ifndef STEP_FUNCTION_H <span class="ent">➊</span>&#13;
int step_function(int x);&#13;
#define STEP_FUNCTION_H <span class="ent">➋</span>&#13;
#endif</pre>&#13;
<p class="listing"><a id="ch21ex19"/><em>Listing 21-19: A <span class="literal">step_function.h</span> updated with include guards</em></p>&#13;
<p class="indent">The first time that the preprocessor includes <span class="literal">step_function.h</span> in a source file, the macro <span class="literal">STEP_FUNCTION_H</span> won’t be defined, so <span class="literal">#ifndef</span> <span class="ent">➊</span> yields the code up to <span class="literal">#endif</span>. Within this code, you <span class="literal">#define</span> the <span class="literal">STEP_FUNCTION_H</span> macro <span class="ent">➋</span>. This ensures that if the preprocessor includes <span class="literal">step_function.h</span> again, <span class="literal">#ifndef STEP_FUNCTION_H</span> will evaluate to false and no code will get generated.</p>&#13;
<p class="indent">Include guards are so ubiquitous that most modern tool chains support the <span class="literal">#pragma once</span> special syntax. If one of the supporting preprocessors sees this line, it will behave as if the header has include guards. This eliminates quite a bit of ceremony. Using this construct, you could refactor <a href="ch21.xhtml#ch21ex19">Listing 21-19</a> into <a href="ch21.xhtml#ch21ex20">Listing 21-20</a>.</p>&#13;
<pre>#pragma once <span class="ent">➊</span>&#13;
int step_function(int x);</pre>&#13;
<p class="listing"><a id="ch21ex20"/><em>Listing 21-20: A <span class="literal">step_function.h</span> updated with <span class="literal">#pragma once</span></em></p>&#13;
<p class="indent">All you’ve done here is start the header with <span class="literal">#pragma once</span> <span class="ent">➊</span>, which is the preferred method. As a general rule, start every header with <span class="literal">#pragma once</span>.</p>&#13;
<h4 class="h4" id="ch21lev2sec9"><strong><em>Compiler Optimization</em></strong></h4>&#13;
<p class="noindent">Modern compilers can perform sophisticated transformations on code to increase runtime performance and reduce binary size. These transformations are called <em>optimizations</em>, and they entail some cost to programmers. Optimization necessarily increases compilation time. Additionally, optimized code is often harder to debug than non-optimized code, because the <span epub:type="pagebreak" id="page_711"/>optimizer usually eliminates and reorders instructions. In short, you usually want to turn off optimizations while you’re programming, but turn them on during testing and in production. Accordingly, compilers typically provide several optimization options. <a href="ch21.xhtml#ch21tab01">Table 21-1</a> describes one such example—the optimization options available in GCC 8.3, although these flags are fairly ubiquitous across the major compilers.</p>&#13;
<p class="tabcap" id="ch21tab01"><strong>Table 21-1:</strong> GCC 8.3 Optimization Options</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Flag</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">-O0 (default)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Reduces compilation time by turning off optimizations. Yields a good debugging experience but suboptimal runtime performance.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-O</span> or <span class="literal">-O1</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Performs the majority of available optimizations, but omits those that can take a lot of (compile) time.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">-O2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Performs all optimizations at <span class="literal">-O1</span>, plus nearly all optimizations that don’t substantially increase binary size. Compilation might take much longer than with <span class="literal">-O1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-O3</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Performs all optimizations at <span class="literal">-O2</span>, plus many optimizations that can substantially increase binary size. Again, this increases compilation time over <span class="literal">-O1</span> and <span class="literal">-O2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">-Os</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Optimizes similarly to <span class="literal">-O2</span> but with a priority for decreasing binary size. You can think of this (loosely) as a foil to <span class="literal">-O3</span>, which is willing to increase binary size in exchange for performance. Any <span class="literal">-O2</span> optimizations that don’t increase binary size are performed.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">-Ofast</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Enables all <span class="literal">-O3</span> optimizations, plus some dangerous optimizations that might violate standards compliance. Caveat emptor.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">-Og</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Enables optimizations that don’t degrade the debugging experience. Provides a good balance of reasonable optimizations, fast compilation, and ease of debugging.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As a general rule, use <span class="literal">-O2</span> for your production binary unless you have a good reason to change it. For debugging, use <span class="literal">-Og</span>.</p>&#13;
<h4 class="h4" id="ch21lev2sec10"><strong><em>Linking with C</em></strong></h4>&#13;
<p class="noindent">You can allow C code to incorporate functions and variables from your programs using <em>language linkage</em>. Language linkage instructs the compiler to generate symbols with a specific format friendly to another target language. For example, to allow a C program to use your functions, you simply add the <span class="literal">extern "C"</span> language linkage to your code.</p>&#13;
<p class="indent">Consider the <span class="literal">sum.h</span> header in <a href="ch21.xhtml#ch21ex21">Listing 21-21</a>, which generates a C-compatible symbol for <span class="literal">sum</span>.</p>&#13;
<pre> // sum.h&#13;
#pragma once&#13;
extern "C" int sum(const int* x, int len);</pre>&#13;
<p class="listing"><a id="ch21ex21"/><em>Listing 21-21: A header that makes the <span class="literal">sum</span> function available to C linkers</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_712"/>Now the compiler will generate objects that the C linker can use. To use this function within C code, you simply declare the <span class="literal">sum</span> function per usual:</p>&#13;
<pre>int sum(const int* x, size_t len);</pre>&#13;
<p class="indent">Then instruct your C linker to include the C++ object file.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>According to the C++ Standard,</em> pragma <em>is a method to provide additional information to the compiler beyond what is embedded in the source code. This information is implementation defined, so the compiler isn’t required to use the information specified by the pragma in any way.</em> Pragma <em>is the Greek root for “a fact.”</em></p>&#13;
</div>&#13;
<p class="indent">You can also interoperate the opposite way: use C compiler output within your C++ programs by giving the linker the C compiler-generated object file.</p>&#13;
<p class="indent">Suppose a C compiler generated a function equivalent to <span class="literal">sum</span>. You could compile using the <span class="literal">sum.h</span> header, and the linker would have no problem consuming the object file, thanks to language linkage.</p>&#13;
<p class="indent">If you have many externed functions, you can use braces <span class="literal">{}</span>, as <a href="ch21.xhtml#ch21ex22">Listing 21-22</a> illustrates.</p>&#13;
<pre>// sum.h&#13;
#pragma once&#13;
&#13;
extern "C" {&#13;
  int sum_int(const int* x, int len);&#13;
  double sum_double(const double* x, int len);&#13;
--snip--&#13;
}</pre>&#13;
<p class="listing"><a id="ch21ex22"/><em>Listing 21-22: A refactoring of <a href="ch21.xhtml#ch21ex21">Listing 21-21</a> containing multiple functions with the <span class="literal">extern</span> modifier.</em></p>&#13;
<p class="indent">The <span class="literal">sum_int</span> and <span class="literal">sum_double</span> functions will have C language linkage.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can also interoperate between C++ and Python with Boost Python. See the Boost documentation for details.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch21lev1sec4"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you first learned about program support features that allow you to interact with the application life cycle. Next, you explored Boost ProgramOptions, which allows you to accept input from users easily using a declarative syntax. Then you examined some selected topics in compilation that will be helpful as you expand your C++ application development horizons.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_713"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>21-1.</strong> Add graceful keyboard interrupt handling to the asynchronous upper-casing echo server in <a href="ch21.xhtml#ch21ex12">Listing 20-12</a>. Add a kill switch with static storage duration that the session objects and acceptors check before queueing more asynchronous I/O.</p>&#13;
<p class="noindent"><strong>21-2.</strong> Add program options to the asynchronous HTTP client in <a href="ch20.xhtml#ch20ex10">Listing 20-10</a>. It should accept options for the host (like <em><a href="http://www.nostarch.com">www.nostarch.com</a></em>) and one or more resources (like <em>/index.htm</em>). It should create a separate request for each resource.</p>&#13;
<p class="noindent"><strong>21-3.</strong> Add another option to your program in exercise 21-2 that accepts a directory where you’ll write all the HTTP responses. Derive a filename from each host/resource combination.</p>&#13;
<p class="noindent"><strong>21-4.</strong> Implement the mgrep program. It should incorporate many of the libraries you’ve learned about in <a href="part02.xhtml#part02">Part II</a>. Investigate the Boyer-Moore search algorithm in Boost Algorithm (in the  <span class="literal">&lt;boost/algorithm/searching/boyer_moore.hpp&gt;</span> header).  Use  std::async to launch tasks and determine a way to coordinate work  between them.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>API Design for C++</em> by Martin Reddy (Morgan Kaufmann, 2011)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>