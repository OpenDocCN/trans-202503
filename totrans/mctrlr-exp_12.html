<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch12"><span epub:type="pagebreak" id="page_119"/><strong>12  PIC18F452 ICSP and HID</strong></h2>&#13;
<p class="noindent">Back in 2010, there was a lot of interest in exploiting RFID tags that hold symmetric keys. The cards themselves were reasonably well protected from memory extraction, and keys might be unique to each customer’s installation, so researchers would instead attack the readers. These readers often used commodity microcontrollers and trusted their readout protection to keep the symmetric keys safe.</p>&#13;
<p class="indent">In this chapter, we’ll cover two such exploits that were used to extract keys from HID iClass readers. Both of them exploit nuances in ICSP, Microchip’s in circuit serial programming standard. The first, published at 27C3 as Meriac (2010), involves erasing a protected page of flash memory over ICSP and replacing it with shellcode that dumps the rest. The second, Huffstutter (2011), involves using the same ICSP protocol to dump RAM, rather than flash memory, because the chip has no protection bits set for RAM.</p>&#13;
<p class="indent">The target reader in this case is the HID RW400, which was chosen by Meriac because it was the oldest programmer to support the iClass cards. This is shown in <a href="ch12.xhtml#ch12fig1">Figure 12.1</a>, where an opaque epoxy potting covers the circuits that we can see in X-ray in <a href="ch12.xhtml#ch12fig2">Figure 12.2</a>.</p>&#13;
<p class="indent">There are many minor variants of the ICSP protocol, each explained in a “FLASH Microcontroller Programming Specification” document that covers ten or twenty part numbers.</p>&#13;
<p class="indent">Older chips require a high voltage for erasure to be externally applied, while modern chips also support a low-voltage mode in which the programming voltage is internally generated. If no other vulnerabilities are handy, it would certainly be worth experimenting with bad voltages and timing here. <a href="app08.xhtml#app08_1">Chapter H.1</a> describes just such an attack from the Nineties.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_120"/><img id="ch12fig1" src="../images/f0120-01.jpg" alt="Image" width="747" height="1097"/></div>&#13;
<p class="figcap">Figure 12.1: HID RW400 Card Reader</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_121"/><img id="ch12fig2" src="../images/f0121-01.jpg" alt="Image" width="778" height="1083"/></div>&#13;
<p class="figcap">Figure 12.2: HID RW400 in X-ray</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_122"/>PIC18 is a bit less threadbare than the earlier PIC architectures, but it is still designed around a philosophy of reusing as many components as possible in order to keep the transistor count as small as possible.</p>&#13;
<p class="indent">The ICSP protocol looks much like SPI, except that there is a single data pin whose direction changes as appropriate. See <a href="ch12.xhtml#ch12fig3">Figure 12.3</a> for the pinout of the six pins to the left of the piezoelectric buzzer in <a href="ch12.xhtml#ch12fig1">Figure 12.1</a>. All transactions are exactly twenty bits, consisting of a 4-bit opcode command and a 16-bit parameter.</p>&#13;
<p class="indent">In ICSP, command <code>0000</code> executes the parameter as a raw PIC18 instruction. <code>0010</code> reads out the <code>TABLAT</code> (Table Latch) register, while <code>1000</code> to <code>1011</code> are Table Read commands and <code>1100</code> to <code>1111</code> are Table Write commands. This is a rather roundabout way to read code memory, but it is roughly in line with the table pointer operations in PIC18 assembly language. The programming specification contains example pairs of commands and instructions for erasing memory and writing code into it.</p>&#13;
<p class="indent">Flash (code), RAM, and EEPROM are in separate address spaces, and a series of Configuration Words describe the protection settings, along with settings for the oscillators, timers, brownout protection, and other configurable features. These 16-bit words begin at <code>0x300000</code> in flash memory. To the developer, these settings are defined as <code>#pragma</code> lines, such as those in <a href="ch12.xhtml#ch12fig4">Figure 12.4</a>.</p>&#13;
<p class="indent">Code memory is divided into pages of somewhat awkward sizes. The first is a bootloader page of 512 bytes at <code>0x0000</code>, followed by 7,680 bytes of Page 0 from <code>0x0200</code> to <code>0x1fff</code>. The remaining pages are each 8kB. See <a href="ch12.xhtml#ch12fig6">Figure 12.6</a> for a diagram of the layout.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_123"/><img id="ch12fig3" src="../images/f0123-01.jpg" alt="Image" width="444" height="265"/></div>&#13;
<p class="figcap">Figure 12.3: Custom ICSP Pinout on the HID RW400</p>&#13;
<div class="image"><img id="ch12fig4" src="../images/f0123-02.jpg" alt="Image" width="821" height="554"/></div>&#13;
<p class="figcap">Figure 12.4: Configuration Words of the HID RW400 Reader</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>Each page has a <code>CP</code> bit. This bit is cleared to enable Code Protection, a <code>WRT</code> bit to enable Write Protection, and an <code>EBT</code> bit to enable Table Read Protection so that code running from another page may not read this page as data through the table interface. These bits are set by erasing the page in question.</p>&#13;
<h3 class="h3" id="ch00lev1sec43"><strong>Meriac’s Boot Block Exploit</strong></h3>&#13;
<p class="noindent">When Milosch Meriac wanted to dump this chip from an HID RW400 reader in Meriac (2010), he found that the <code>CP</code> and <code>WRT</code> bits had been cleared so that instructions executing from the ICSP context were not permitted to read or write any blocks of flash memory. He chose these readers because they were the oldest to support the iClass cards, and you can find the configuration bits of a reader in <a href="ch12.xhtml#ch12fig4">Figure 12.4</a>.</p>&#13;
<p class="indent">Fortunately, the <code>EBT</code> bits had not been cleared. If they had been, code running from one page of flash memory would not be allowed to perform table reads on any other page. Because these bits are still set, the entire chip’s memory can be dumped from code running in any page.</p>&#13;
<p class="indent">Meriac observed that by erasing a page, he could set the <code>CP</code>, <code>WRT</code>, and <code>EBT</code> bits of that page.<sup><a id="ch12fn_1" href="footnotes.xhtml#ch12fn1">1</a></sup> This then allowed him to write a bit of shellcode into the page, which would dump the rest of memory out the serial port.</p>&#13;
<p class="indent">He packaged this as a C<code>++</code> application for Windows, that bit-bangs ICSP into the debug interface through an FTDI chip’s GPIO pins and then reads back the firmware through that same chip’s UART. His shellcode is shown in <a href="ch12.xhtml#ch12fig5">Figure 12.5</a>; it simply dumps the firmware to the UART.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_125"/><img id="ch12fig5" src="../images/f0125-01.jpg" alt="Image" width="823" height="1019"/></div>&#13;
<p class="figcap">Figure 12.5: Meriac’s PIC18 Dumper Source</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_126"/><img id="ch12fig6" src="../images/f0126-01.jpg" alt="Image" width="561" height="575"/></div>&#13;
<p class="figcap">Figure 12.6: PIC18F452 Flash Map</p>&#13;
<div class="image"><img id="ch12fig7" src="../images/f0126-02.jpg" alt="Image" width="811" height="229"/></div>&#13;
<p class="figcap">Figure 12.7: Meriac’s PIC18 Dumper Shellcode</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_127"/><img id="ch12fig8" src="../images/f0127-01.jpg" alt="Image" width="777" height="1001"/></div>&#13;
<p class="figcap">Figure 12.8: Microchip PIC18F452</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_128"/><img id="ch12fig9" src="../images/f0128-01.jpg" alt="Image" width="784" height="274"/></div>&#13;
<p class="figcap">Figure 12.9: Huffstutter’s ICSP RAM Extraction</p>&#13;
<p class="indent">For his target, it was sufficient to erase and rewrite the 512-byte bootloader page with the shellcode binary, as this page conveniently had no contents worth missing. Other targets might have something important in the boot block, and on those targets, a second victim device is required. This second device has every page <em>except</em> for the first page erased. These pages are then overwritten with a sled of repeated NOP instructions, leading to the shellcode at the very end of memory. The idea is that the boot block will eventually branch somewhere in the other blocks, and that almost every legal address will then slide to the shellcode to dump the very first block.</p>&#13;
<h3 class="h3" id="ch00lev1sec44"><span epub:type="pagebreak" id="page_129"/><strong>Huffstutter’s ICSP SRAM Exploit</strong></h3>&#13;
<p class="noindent">Carl Huffstutter describes a different exploit for the same firmware image on the same chip in Huffstutter (2011). He saw that while every bank of flash memory and EEPROM has its own protection fuse bits, there are no such bits for protecting RAM. Sure enough, the ICSP transactions in <a href="ch12.xhtml#ch12fig9">Figure 12.9</a> cleanly and non-destructively extract all RAM from a locked microcontroller.</p>&#13;
<p class="indent">In RAM, he found the 64-bit HID Master authentication key, two 64-bit Triple DES keys for encrypting comms between the reader and the card, the 128-byte key table for use with High Security cards, and all the details of the last card read. This information wasn’t erased after use, but had it been, the machine might still be interrupted mid-read to reveal the contents in use.</p>&#13;
<p class="indent">Many other devices expose SRAM while protecting flash memory, so it’s worth considering this attack whenever you need data from a chip and don’t necessarily need a copy of the code. On the defensive side, it might help to declare any important keys and tables as <code>const</code> so that they are located only in flash memory and never copied into RAM.<span epub:type="pagebreak" id="page_130"/></p>&#13;
</div>
</div>
</body></html>