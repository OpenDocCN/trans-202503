- en: '![](../images/pg422.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-40.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CHARACTERS
    AND STRINGS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll implement three new integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. These are the *character types*, which have a size of 1 byte. Because
    your compiler already supports signed and unsigned integers in multiple sizes,
    you can add these new types with minimal effort. You’ll also add support for string
    literals and character constants. String literals play a weird role in C: sometimes
    they behave like compound initializers, and at other times they represent constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> arrays. To support the
    latter case, you’ll store constant strings alongside variables in the symbol table,
    and you’ll introduce static constants as a top-level construct in TACKY.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, we’ll compile “Hello, World!” In [Chapter 9](chapter9.xhtml),
    we compiled a version of this program that printed one character at a time. This
    time, we’ll compile a more reasonable version that prints out an entire string.
    Before we get started, I’ll give you a bit of background information: I’ll first
    touch on a few notable differences between the character types and the other integers,
    then describe how strings work in C and assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Character Traits</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most surprising thing about the character types is that there are three
    of them. There’s no distinction between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> or between
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp>, but the specifiers <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> refer to
    two distinct types. Whether “plain” <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is signed or unsigned is implementation-defined. We’ll follow the System V ABI,
    which specifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is signed.
  prefs: []
  type: TYPE_NORMAL
- en: Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> will behave identically
    in our implementation, the fact that they’re different types has real consequences.
    For instance, [Listing 16-1](chapter16.xhtml#list16-1) is illegal because it declares
    the same global variable as both a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-1: Conflicting file
    scope variable declarations with different character types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a global variable as both an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, on the
    other hand, is perfectly legal, since both declarations specify the same type.
  prefs: []
  type: TYPE_NORMAL
- en: The character types also follow slightly different type conversion rules than
    the other integer types. When a character is used in a unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    operation; a bitwise binary operation; or the usual arithmetic conversions, it’s
    first converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    These conversions are called the *integer promotions*. (If <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    can’t fit every value of a particular character type, the character is converted
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> instead.
    In our implementation, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    can hold every value of every character type, so this is a moot point. Of course,
    we can also ignore the typing rules for operations we haven’t implemented, like
    unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and the bitwise binary
    operations; I’m mentioning them here only for the sake of completeness.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more noteworthy difference between characters and other integers:
    in C17, there are no scalar constants of character type. Tokens like <samp class="SANS_TheSansMonoCd_W5Regular_11">''a''</samp>
    all have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, despite
    being called “character constants.” There are constants with *wide character types*
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>, which are intended
    to represent multibyte characters, but we won’t implement them.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*C23 introduces u8 character constants with type unsigned char. These represent
    1-byte UTF-8 characters.*'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">String Literals</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, I’ll distinguish between string literals and strings.
    A *string literal* is an expression that appears in the source code, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>. A *string* is an object
    that lives in memory—specifically, a null-terminated <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    array. Some strings can’t be modified at runtime; I’ll call these *constant strings*,
    although this isn’t a standard term.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a string literal in two distinct ways. First, it can initialize
    an array of any character type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll include a terminating null byte if there’s space and omit it if there
    isn’t. This coincides with our usual rules for array initialization: if the initializer
    is shorter than the target object, we pad out the remainder with zeros. Therefore,
    the previous declaration is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In [Listing 16-2](chapter16.xhtml#list16-2), on the other hand, we leave out
    the null byte in <samp class="SANS_TheSansMonoCd_W5Regular_11">array1</samp> because
    the array isn’t large enough to include it. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">array1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">array2</samp> have identical
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-2: Using a string
    literal as an array initializer without the null byte</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a string literal appears anywhere other than as an array initializer,
    it designates a constant string. In this context, string literals act a lot like
    other expressions of array type. They decay to pointers like other array expressions,
    so you can subscript them or assign them to <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp> objects. The following declaration initializes the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">str_ptr</samp>
    with the address of the first character in the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'String literals are also lvalues, so they support the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator. Here, we use this operator to take the address of the constant string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>, then assign it to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">array_ptr</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only difference from the previous example is that the string literal doesn’t
    undergo array decay. We end up with a pointer to the whole string, with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char (*)[4]</samp>, instead of a pointer
    to its first element, with type <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp>. In both examples, we treat <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>
    like any other expression of array type.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other arrays, constant strings are, well, constant. Attempting to modify
    them, as in [Listing 16-3](chapter16.xhtml#list16-3), produces undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-3: Illegally modifying
    a constant string</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although this code compiles, it will probably throw a runtime error, because
    most C implementations—including ours—store constant strings in read-only memory.
    (The <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier, which
    we won’t implement, informs the compiler that an object cannot be modified. If
    [Listing 16-3](chapter16.xhtml#list16-3) were part of a real C program, it would
    be a good idea to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualifier to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at one more example, shown in [Listing 16-4](chapter16.xhtml#list16-4),
    to clarify the difference between string literals that designate constant strings
    and string literals that initialize arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-4: Legally modifying
    an array initialized from a string literal</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike [Listing 16-3](chapter16.xhtml#list16-3), this code is perfectly legal.
    In [Listing 16-3](chapter16.xhtml#list16-3), <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to the start of the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>.
    In [Listing 16-4](chapter16.xhtml#list16-4), on the other hand, we use each character
    of the string literal <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>
    to initialize one element of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>,
    which is an ordinary, non-constant <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Both cases are easier to understand once we see how they translate to assembly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Strings in Assembly</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use two different assembly directives to initialize strings in assembly.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    directives both tell the assembler to write an ASCII string to the object file,
    much like <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> tells it
    to write a quadword. The difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    will include a terminating null byte and <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    won’t. The three declarations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: correspond to the assembly in [Listing 16-5](chapter16.xhtml#list16-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-5: Initializing
    three static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">arrays from string literals in
    assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    is long enough to accommodate a null byte, we initialize it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    directive. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">not_null _terminated</samp>
    so we don’t go past the bounds of the array. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">extra_padding</samp>
    needs two zero bytes to reach the correct length, we write a null-terminated string,
    then write an extra zero byte with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>
    directive. Note that none of these variables needs an <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp>
    directive. The character types are all 1-byte aligned, so arrays of characters
    are too. (Array variables containing 16 or more characters are the exception;
    they’re 16-byte aligned, like all array variables that are 16 bytes or larger.)
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    directives initialize objects with static storage duration. Next, let’s consider
    [Listing 16-6](chapter16.xhtml#list16-6), which initializes a non-static array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-6: Using a string
    literal to initialize a non-static array</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-7](chapter16.xhtml#list16-7) illustrates one way to initialize
    <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> in assembly, by copying
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcde"</samp> onto the stack one
    byte at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-7: Initializing
    a non-static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">array in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The characters <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp>
    have ASCII values <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    respectively. Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    starts at stack address <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>,
    the instructions in [Listing 16-7](chapter16.xhtml#list16-7) copy each character
    to the appropriate location in the array. The <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    suffix in each <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instruction
    indicates that it operates on a single byte.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-8](chapter16.xhtml#list16-8) demonstrates a more efficient approach.
    We initialize the first 4 bytes of this string with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction, then use <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instructions to initialize the remaining 2 bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-8: A more efficient
    way to initialize a non-static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">array in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We get <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp> when
    we interpret the first 4 bytes of our string as an integer. (I’ll discuss how
    we get this integer in more detail later in the chapter.) This listing has the
    same effect as [Listing 16-7](chapter16.xhtml#list16-7), but it saves us a few
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at constant strings. We write these to read-only sections of
    the object file, just like floating-point constants. On Linux, we store constant
    strings in <samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp>; on macOS,
    we store them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp>
    section. Consider the code fragment in [Listing 16-9](chapter16.xhtml#list16-9),
    which returns a pointer to the start of a constant string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-9: Returning a pointer
    to the start of a string</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll generate a unique label for this string, then define it in the appropriate
    section. [Listing 16-10](chapter16.xhtml#list16-10) gives the resulting assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-10: Defining a constant
    string in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant strings are always null-terminated, since they don’t need to fit into
    any particular array dimensions. Once we’ve defined a constant string, we can
    access it with RIP-relative addressing, like any other static object. In this
    particular example, we want to return the string’s address, so we’ll load it into
    RAX with this instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s see how to initialize a static pointer with a string literal,
    like in [Listing 16-11](chapter16.xhtml#list16-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-11: Initializing
    a static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char *</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">from a string literal</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll define the string the same way as in [Listing 16-10](chapter16.xhtml#list16-10).
    However, we can’t load it into <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction.
    Because <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is static, it
    must be initialized before the program starts. Luckily, the <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp>
    directive accepts labels as well as constants. [Listing 16-12](chapter16.xhtml#list16-12)
    illustrates how to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    with this directive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-12: Initializing
    a static variable with the address of a static constant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The directive <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad .Lstring.0</samp>
    tells the assembler and linker to write the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">.Lstring.0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, it’s possible to initialize any static pointer this way, not
    just pointers to strings. While our implementation doesn’t accept expressions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp> as static initializers,
    a more complete compiler might translate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you know enough about how to use strings in C and assembly to
    get started. The first step is to extend the lexer to recognize string literals
    and character constants.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add three new tokens in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp> A keyword, used to
    specify character types
  prefs: []
  type: TYPE_NORMAL
- en: '**Character constants** Individual characters, like <samp class="SANS_TheSansMonoCd_W5Regular_11">''a''</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">''\n''</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '**String literals** Sequences of characters, like <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello,
    World!"</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A character constant consists of one character (like <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>)
    or escape sequence (like <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>)
    wrapped in single quotes. Section 6.4.4.4 of the C standard defines a set of escape
    sequences to represent special characters. [Table 16-1](chapter16.xhtml#tab16-1)
    lists these escape sequences and their ASCII codes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-1:</samp> <samp class="SANS_Futura_Std_Book_11">Escape
    Sequences for Special Characters</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Escape sequence</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">ASCII code</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp> | <samp class="SANS_Futura_Std_Book_11">Single
    quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">39</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp> | <samp class="SANS_Futura_Std_Book_11">Double
    quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">34</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp> | <samp class="SANS_Futura_Std_Book_11">Question
    mark</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp> | <samp class="SANS_Futura_Std_Book_11">Backslash</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">92</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp> | <samp class="SANS_Futura_Std_Book_11">Audible
    alert</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp> | <samp class="SANS_Futura_Std_Book_11">Backspace</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp> | <samp class="SANS_Futura_Std_Book_11">Form
    feed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> | <samp class="SANS_Futura_Std_Book_11">New
    line</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp> | <samp class="SANS_Futura_Std_Book_11">Carriage
    return</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp> | <samp class="SANS_Futura_Std_Book_11">Horizontal
    tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp> | <samp class="SANS_Futura_Std_Book_11">Vertical
    tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> |'
  prefs: []
  type: TYPE_TB
- en: The new line, single quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>),
    and backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) characters
    can’t appear on their own as character constants and must be escaped. Any other
    character can be used directly as a character constant as long as it’s in the
    *source character set*, the complete set of characters that can appear in a source
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source character set is implementation-defined, but it has to include at
    least the *basic source character set*, which is specified in section 5.2.1 of
    the C standard. In our implementation, the source character set includes all the
    printable ASCII characters, plus the required control characters: the new line,
    horizontal tab, vertical tab, and form feed. You don’t need to explicitly reject
    characters outside of this set; you can simply assume that they never show up
    in source files.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the characters in [Table 16-1](chapter16.xhtml#tab16-1), like the audible
    alert (<samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>) and backspace
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>), aren’t in our source
    character set, so they can be represented only by escape characters. Other characters,
    including the double quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>),
    question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>), form feed,
    and horizontal and vertical tabs, are in the source character set; they can be
    escaped in character constants, but they don’t have to be. For example, the character
    constants <samp class="SANS_TheSansMonoCd_W5Regular_11">'?'</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">'\?'</samp>
    are equivalent; they both represent the question mark character. The new line,
    single quote, and backslash are all in the source character set but still need
    to be escaped.
  prefs: []
  type: TYPE_NORMAL
- en: We can recognize character constants with the truly egregious regular expression
    in [Listing 16-13](chapter16.xhtml#list16-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-13: The regular
    expression to recognize a character constant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break this down. The first alternative in the parenthesized expression,
    the character class <samp class="SANS_TheSansMonoCd_W5Regular_11">[^'\\\n]</samp>,
    matches any single character except for a single quote, backslash, or new line.
    We have to escape the backslash, because it’s a control character in PCRE regexes
    as well as in C string literals. Similarly, we use the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    in this regex to match a literal new line character. The second alternative, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\\['"?\\abfnrtv]</samp>, matches an escape
    sequence. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp> matches
    a single backslash, and the character class that follows includes every character
    that can follow the backslash in an escape sequence. The whole thing must start
    and end with single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: A string literal consists of a possibly empty sequence of characters and escape
    sequences, wrapped in double quotes. A single quote can appear on its own in a
    string literal, but a double quote must be escaped. [Listing 16-14](chapter16.xhtml#list16-14)
    shows the regular expression to recognize a string literal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-14: The regular
    expression to recognize a string literal</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">[^"\\\n]</samp> matches
    any single character except a double quote, backslash, or new line. Like in [Listing
    16-13](chapter16.xhtml#list16-13), the second alternative matches every escape
    sequence. We apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    quantifier to the whole parenthesized expression because it can repeat zero or
    more times, and we delimit it all with double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: After lexing a string literal or character token, you need to unescape it. In
    other words, you need to convert every escape sequence in that token to the corresponding
    ASCII character. You can do that either now or in the parser.
  prefs: []
  type: TYPE_NORMAL
- en: The standard defines a few other types of string literals and character constants
    that we won’t implement. In particular, we won’t support hexadecimal escape sequences
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">\xff</samp>, octal escape sequences
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">\012</samp>, or multicharacter
    constants like <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>. We also
    won’t support any of the types or constants used for non-ASCII encodings, like
    wide character types, wide string literals, or UTF-8 string literals.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll extend the AST definition in three ways. First, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> types. Second, we’ll add a new kind of expression to represent string
    literals. Third, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST node to represent constants with character types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These new constant constructors are a little unusual because they don’t correspond
    to constant literals that actually appear in C programs. Character constants like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp> have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    so the parser will convert them to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>
    nodes; it won’t use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp> constructors
    at all. But we’ll need these constructors later, when we pad out partially initialized
    character arrays during type checking and when we initialize character arrays
    in TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-15](chapter16.xhtml#list16-15) gives the complete AST definition,
    with this chapter’s changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-15: The abstract
    syntax tree with character types, character constants, and string literals</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: It’s tempting to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>, to include
    string literals, but string literals are distinct enough from other kinds of constants
    that it’s easiest to define them separately. For example, the type checker will
    need to handle them differently than other constants when it processes initializers.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Type
    Specifiers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp>,
    which converts a list of type specifiers into a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node, to handle character types. I won’t provide the pseudocode for this,
    because the logic is pretty simple. If <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    appears in a declaration by itself, it specifies the plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type. If it appears with the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    keyword, it specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> type. If it appears with the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    keyword, it specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> type. As usual, the order of type specifiers doesn’t matter. It’s
    illegal for <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> to appear
    in a declaration with any other type specifier.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Character
    Constants</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The parser should convert each character constant token to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>
    with the appropriate ASCII value. It should convert the token <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(97)</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(10)</samp>, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing String Literals</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The parser should unescape string literals if the lexer hasn’t done that already.
    Each character in the string literal, including characters represented by escape
    sequences in the original source code, must be represented as a single byte internally.
    Otherwise, we’ll calculate inaccurate string lengths in the type checker and initialize
    arrays with incorrect values at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacent string literal tokens should be concatenated into a single <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    AST node. For example, the parser should convert the statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: to the AST node <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(String("foobar"))</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-16](chapter16.xhtml#list16-16) defines the complete grammar, with
    this chapter’s changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-16: The grammar
    with character types, character constants, and string literals</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The bolded additions to the grammar correspond to the three changes to the parser
    we just discussed. The grammar now includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">"char"</samp>
    type specifier ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11"><string></samp>
    ❹ and <samp class="SANS_TheSansMonoCd_W5Regular_11"><char></samp> tokens ❺. We
    recognize a sequence of one or more string literals as a primary expression ❷
    and a character token as a constant ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, the type checker can treat characters like the other integer
    types. They follow the same typing rules and support the same operations. The
    integer promotions are the one exception to this pattern, so we’ll implement them
    in this section. We’ll also introduce static initializers for the character types.
  prefs: []
  type: TYPE_NORMAL
- en: String literals are more challenging to type check, particularly when they appear
    in initializers. We’ll need to track whether each string should be used directly
    or converted to a pointer and which strings should be terminated with null bytes.
    We’ll add a few new constructs to the symbol table to represent each of these
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Characters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll promote character types to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    as part of the usual arithmetic conversions. [Listing 16-17](chapter16.xhtml#list16-17)
    shows how to perform this promotion in <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-17: Applying the
    integer promotions during the usual arithmetic conversions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After promoting the types of both operands, we’ll find their common type as
    usual. We’ll also promote the operands of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operations. [Listing
    16-18](chapter16.xhtml#list16-18) demonstrates how to promote a negated operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-18: Applying the
    integer promotions to a negation expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we make sure the operand isn’t a pointer (we introduced this validation
    in [Chapter 14](chapter14.xhtml)). Then, we apply the integer promotions. We check
    whether the operand is one of the character types ❶; if it is, we convert it to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp> and then negate the promoted
    value. The result of the expression has the same type as its promoted operand
    ❷. We’ll handle <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> the same
    way, so I won’t provide the pseudocode for that here.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll always recognize characters as integer types during type checking. For
    example, we’ll accept characters as operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> expressions and as
    indices in pointer arithmetic. Because all integer types are also arithmetic types,
    we’ll permit implicit conversions between the character types and any other arithmetic
    type in <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add two static initializers for the character types. [Listing 16-19](chapter16.xhtml#list16-19)
    gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-19: Adding the static
    initializers for character types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> and plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> are both signed types,
    we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">CharInit</samp> to initialize
    both of them. We’ll convert each initializer to the type it initializes according
    to the type conversion rules we covered in [Chapters 11](chapter11.xhtml) and
    [12](chapter12.xhtml). For example, if an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> is initialized with a value greater than 255, we’ll reduce its value
    modulo 256.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll make one small, straightforward update to the way we type check
    compound initializers for non-static arrays. (We’ll handle string literals that
    initialize arrays as a separate case in the next section.) In the previous chapter,
    we dealt with partly initialized arrays by padding out the remaining elements
    with zeros. I suggested writing a <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    helper function to generate these zeroed-out initializers. Now we can extend that
    function to emit <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp> to zero out
    elements of character type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals in
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we encounter a string literal in an expression, rather than in an array
    initializer, we’ll annotate it as a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    array of the appropriate size. [Listing 16-20](chapter16.xhtml#list16-20) shows
    how to handle string literals in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-20: Type checking
    a string literal</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the array size accounts for a terminating null byte. The type checker
    already handles implicit conversions from arrays to pointers in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>.
    Now <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    will convert string literals to pointers too, since they also have array type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll update the type checker to recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    expressions as lvalues, along with variables, subscript operators, and dereference
    expressions. This allows programs to take their address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of string literals in ordinary expressions; now we’ll type check
    string literals in initializers.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals
    Initializing Non-static Variables</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we type check <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp>
    constructs with <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>,
    which converts values of array type to pointers. This approach correctly handles
    string literals that initialize pointers. But when a string literal is used to
    initialize an array, we’ll type check it differently. [Listing 16-21](chapter16.xhtml#list16-21)
    shows how to handle this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-21: Type checking
    a string literal that initializes an array</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we make sure the target type is an array of characters, since string
    literals can’t initialize arrays of any other type ❶. Then, we validate that the
    string isn’t too long to initialize the array ❷. Finally, we annotate the initializer
    with the target type ❸. We’ll use this annotation later to figure out how many
    null bytes to append to the string.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals Initializing
    Static Variables</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our final task is to process string literals that initialize static variables.
    We’ll need to represent two new kinds of initial values in the symbol table: ASCII
    strings (which correspond to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives) and
    the addresses of static objects (which correspond to directives like <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad
    .Lstring.0</samp>). We’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    once again to include both kinds of initializers. [Listing 16-22](chapter16.xhtml#list16-22)
    gives the new definition with these two additions bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-22: Adding the static
    initializers for strings and pointers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp> defines an ASCII
    string initializer. We’ll use it to initialize both constant strings and character
    arrays. The <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    argument specifies whether to include a null byte at the end; we’ll use this argument
    to choose between the <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives during
    code emission. <samp class="SANS_TheSansMonoCd_W5Regular_11">PointerInit</samp>
    initializes a pointer with the address of another static object.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also start tracking constant strings in the symbol table. [Listing 16-23](chapter16.xhtml#list16-23)
    gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>,
    which includes constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-23: Tracking constants
    in the symbol table</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a variable, which may be uninitialized, tentatively initialized, or initialized
    with a list of values, a constant is initialized with a single value. It also
    doesn’t need a <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> flag,
    since we’ll never define a global constant.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve extended <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>, let’s
    discuss how to process string initializers for both character arrays and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> pointers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing a Static Array
    with a String Literal</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a string literal initializes a static array, we first validate the array’s
    type: we make sure that the array elements have character type and that the array
    is long enough to contain the string. (This is the same validation we performed
    for non-static arrays back in [Listing 16-21](chapter16.xhtml#list16-21).) We
    then convert the string literal to a <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp>
    initializer, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    flag if the array has enough space for the terminating null byte. We add <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to the initializer list
    if we need to pad it out with additional null bytes. For example, we’ll convert
    the declaration'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: to the symbol table entry in [Listing 16-24](chapter16.xhtml#list16-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-24: The symbol table
    entry for an array initialized from a string literal</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This entry initializes <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with the null-terminated string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>,
    followed by 6 bytes of zeros.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing a Static Pointer
    with a String Literal</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a string literal initializes a static variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp>, we create two entries in the symbol table. The first defines the string
    itself, and the second defines the variable that points to that string. Let’s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, we generate an identifier for the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp>;
    let’s say this identifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">"string.0"</samp>.
    Then, we add the entry shown in [Listing 16-25](chapter16.xhtml#list16-25) to
    the symbol table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-25: Defining a constant
    string in the symbol table</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This identifier must be globally unique and must be a syntactically valid label
    in assembly. In other words, it should follow the same constraints as the identifiers
    we generate for floating-point constants. Because [Listing 16-25](chapter16.xhtml#list16-25)
    defines a constant string, we use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp>
    construct, and we’ll initialize it with the null-terminated string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when we add <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    itself to the symbol table, we initialize it with a pointer to the symbol we just
    added. [Listing 16-26](chapter16.xhtml#list16-26) shows the symbol table entry
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-26: Defining a static
    pointer to a string in the symbol table</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a string literal initializes a pointer to a type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    we throw an error. (Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>
    already catches this error in the non-static case.) Even using a string literal
    to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char *</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char *</samp> is illegal.
    This is in keeping with the ordinary rules for type conversions: string literals
    have type <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>, and we
    can’t implicitly convert from one pointer type to another. By contrast, a string
    literal can initialize an *array* of any character type because it’s legal to
    implicitly convert each individual character from one character type to another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have symbol table entries for all the strings that appear
    in static initializers. During TACKY generation, we’ll add all the other constant
    strings in the program to the symbol table too.  ### <samp class="SANS_Futura_Std_Bold_B_11">TACKY
    Generation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we convert a program to TACKY, we can treat characters exactly like all
    the other integers. In particular, we’ll implement casts to and from character
    types with the existing type conversion instructions. For example, we’ll implement
    casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>
    instruction, and we’ll implement casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>.
    Processing string literals, however, requires a bit more work.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals as
    Array Initializers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the type checker, we dealt with string literals that initialized static arrays.
    Now we’ll do the same for arrays with automatic storage duration.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in the chapter, there are two options here. The simpler option
    is to initialize these arrays one character at a time. The more efficient option
    is to initialize entire 4- or 8-byte chunks at once. Either way, we’ll copy the
    string into the array with a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through both options. We’ll use the initializer from [Listing 16-6](chapter16.xhtml#list16-6),
    reproduced here, as a running example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When we first looked at this example, we learned that the ASCII values of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>.
    Using the simple one-byte-at-a-time approach, we’ll initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with the TACKY instructions in [Listing 16-27](chapter16.xhtml#list16-27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-27: Initializing
    a non-static array in TACKY, one byte at a time</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the more efficient approach, we’ll initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with a single 4-byte integer, followed by 2 individual bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To come up with the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp>,
    we take the 4 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> and interpret them
    as a single little-endian integer. In hexadecimal, these bytes are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x61</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x62</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x63</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x64</samp>. The first byte
    in little-endian integers is least significant, so interpreting this byte sequence
    as an integer gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">0x64636261</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp> in decimal.
    Whatever language you’re implementing your compiler in, it likely has utility
    functions to manipulate byte buffers and interpret them as integers, so you won’t
    need to implement this fiddly logic yourself.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize eight characters at once, we’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>. We
    need to be careful not to overrun the bounds of the array we’re initializing;
    in this example, it would be incorrect to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with two 4-byte integers, because it would clobber neighboring values.
  prefs: []
  type: TYPE_NORMAL
- en: It’s up to you which of these approaches to use; they’re both equally correct.
    In either case, make sure to initialize the correct number of null bytes at the
    end of the string. In the type checker, you annotated every initializer, including
    string literals, with type information. Now you’ll use that type information to
    figure out how many null bytes to include. If a string literal is longer than
    the array it initializes, copy in only as many characters as the array can hold.
    In other words, leave off the null byte. If the string literal is too short, copy
    zeros into the rest of the array.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals in
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we encounter a string literal outside of an array initializer, we’ll add
    it to the symbol table as a constant string. Then, we’ll use its identifier as
    a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>. Let’s revisit
    [Listing 16-9](chapter16.xhtml#list16-9), which returns a pointer to the first
    character in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser and type checker transform this into the following AST node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert this AST node to TACKY, we first define <samp class="SANS_TheSansMonoCd_W5Regular_11">"A
    profound statement."</samp> in the symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This entry is no different from the constant strings we defined in the type
    checker. It has a globally unique, automatically generated label. It’s a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> array that’s just large enough
    to contain the whole string, including the terminating null byte. It’s initialized
    with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp>
    construct because we’ll ultimately store it in read-only memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can refer to the identifier we just defined—<samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp>,
    in this example—to load the string’s address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In short, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp>
    like any other symbol of array type.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Top-Level Constants
    in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to account for all these new constant strings when we convert entries
    in the symbol table to top-level TACKY definitions. The assembly AST already has
    a top-level constant construct. Now we’ll add the corresponding construct to TACKY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When we’re generating top-level TACKY definitions from the symbol table, we’ll
    generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    for every constant in the symbol table, just like we generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    for each static variable. Make sure to convert function definitions to TACKY before
    traversing the symbol table; otherwise, you’ll miss the constant strings that
    get added to the symbol table during this pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-28](chapter16.xhtml#list16-28) summarizes the TACKY IR, with this
    chapter’s addition bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-28: Adding static
    constants to the TACKY IR</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your TACKY generation pass should be good to go: it can handle
    individual characters, string literals that are implicitly converted to pointers,
    and string literals that initialize arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won’t do anything too fancy in this stage. First, we’ll convert operations
    on individual characters to assembly. This will require a few changes to the assembly
    AST. Then, we’ll handle TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    constructs and add constant strings to the backend symbol table.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Operations on Characters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most instructions support 1-byte operands as well as longwords and quadwords.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> suffix, like in the instructions
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">andb</samp>,
    indicates that an instruction operates on a single byte. We’ll introduce a new
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> assembly type to represent
    this new operand size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We’ll convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> types to <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>.
    The general-purpose registers have 1-byte aliases too; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp>
    is the 1-byte alias for RAX. Luckily, our code emission pass already supports
    these aliases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    type, we’ll need to convert to and from character types correctly. You can zero
    extend a 1-byte value to a wider type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction. This instruction takes a two-letter suffix, indicating the types
    of the source and destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movzbl</samp>
    instruction extends a byte to a longword, and <samp class="SANS_TheSansMonoCd_W5Regular_11">movzbq</samp>
    extends a byte to a quadword. (You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">movzwl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">movzwq</samp> to extend a 2-byte
    word to a larger type, but we don’t use 2-byte operands.) We’ll represent <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> with the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction in the assembly AST, but we’ll add the types of both operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    we’ll ultimately emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction with the correct suffix. If <samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, we’ll rewrite
    this to an ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    during the fix-up pass, just like in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign extend a byte to a larger type, we’ll use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp>
    instruction. This instruction also takes a suffix to specify the types of both
    the source and the destination: <samp class="SANS_TheSansMonoCd_W5Regular_11">movsbl</samp>
    extends a byte to a longword, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsbq</samp>
    extends a byte to a quadword, and <samp class="SANS_TheSansMonoCd_W5Regular_11">movslq</samp>
    extends a longword into a quadword. We’ll add type information to this instruction
    in the assembly AST too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can truncate a larger integer to a single byte with a <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instruction, just like you can truncate a quadword to a longword with <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>.
    Note that when you copy a value to a register with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instruction, the register’s upper bytes aren’t zeroed out. This isn’t a problem;
    whether we’re operating on a single byte or a longword, we use only the part of
    the register that holds the value itself, and we ignore the register’s upper bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s consider how to convert between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the character types. There’s no assembly instruction to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    directly to a 1-byte integer or vice versa. Instead, we’ll convert to or from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> as an intermediate step.
    To convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to any
    character type, we’ll first convert it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and then truncate it, as [Listing 16-29](chapter16.xhtml#list16-29) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-29: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a character type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-30](chapter16.xhtml#list16-30) gives the assembly to convert an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> to a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We’ll zero extend it to
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, then convert the
    result to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-30: Converting an</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: And to convert either signed character type to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we’ll sign extend it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    first, as [Listing 16-31](chapter16.xhtml#list16-31) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-31: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">or</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll deal with our second task: converting top-level constants from
    TACKY to assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Top-Level Constants</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Processing a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    is extremely simple: we just convert it to an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>.
    You’ll also need to convert each constant string in the symbol table to an equivalent
    entry in the backend symbol table, like you do for variables. When you add a constant
    string to the backend symbol table, set its <samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp>
    attribute to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If your
    backend symbol table includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    attribute, set this to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    as well. (Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    was an optional addition in [Chapter 13](chapter13.xhtml); it tells us when to
    use local labels during code emission.)'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Complete Conversion
    from TACKY to Assembly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-32](chapter16.xhtml#list16-32) shows this chapter’s additions to
    the assembly AST.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-32: The assembly
    AST with byte operands</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 16-2](chapter16.xhtml#tab16-2) through [16-5](chapter16.xhtml#tab16-5)
    summarize the latest updates to the conversion from TACKY to assembly, with new
    constructs and changes to the conversions for existing constructs bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name, t, init)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><alignment
    of t></samp><samp class="SANS_Futura_Std_Heavy_B_11">, init)</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate(src, dst)</samp> |  |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble(src, dst)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Movsx(Byte,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">Longword,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">)) Cvtsi2sd(Longword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">), dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><src type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt(src, dst)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Cvttsd2si(Longword,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_Futura_Std_Heavy_B_11">))
    Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">), dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><dst type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned char</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(Byte,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">)) Cvtsi2sd(Longword, Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),
    dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword,
    Quadword,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)) Cvtsi2sd(Quadword, Reg(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),
    dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Quadword,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(0),</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src) JmpCC(L,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)'
  prefs: []
  type: TYPE_NORMAL
- en: Cvtsi2sd(Quadword, src, dst)
  prefs: []
  type: TYPE_NORMAL
- en: Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  prefs: []
  type: TYPE_NORMAL
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  prefs: []
  type: TYPE_NORMAL
- en: Mov(Quadword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Mov(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Unary(Shr, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Binary(And, Quadword, Imm(1), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Binary(Or, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Cvtsi2sd(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
  prefs: []
  type: TYPE_NORMAL
- en: Binary(Add, Double, dst, dst)
  prefs: []
  type: TYPE_NORMAL
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned char</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(Longword,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))
    Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(Quadword, src, Reg(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))
    Mov(Longword, Reg(<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">R</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">>), dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), src) JmpCC(AE,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)'
  prefs: []
  type: TYPE_NORMAL
- en: Cvttsd2si(Quadword, src, dst)
  prefs: []
  type: TYPE_NORMAL
- en: Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  prefs: []
  type: TYPE_NORMAL
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  prefs: []
  type: TYPE_NORMAL
- en: Mov(Double, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Binary(Sub, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Cvttsd2si(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
  prefs: []
  type: TYPE_NORMAL
- en: Mov(Quadword, Imm(9223372036854775808), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  prefs: []
  type: TYPE_NORMAL
- en: Binary(Add, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
  prefs: []
  type: TYPE_NORMAL
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">And add a top-level constant:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, 8,
  prefs: []
  type: TYPE_NORMAL
- en: DoubleInit(9223372036854775808.0))</samp> |
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstChar(int))</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstUChar(int))</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp> |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">SChar</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">UChar</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: Next, let’s move on to pseudo-operand replacement and instruction fix-up. The
    updates to both of these passes are pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pseudo-Operand Replacement</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll allocate 1 byte on the stack for each <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    object. We don’t need to worry about rounding these down to the right alignment,
    because they’re all 1-byte aligned.
  prefs: []
  type: TYPE_NORMAL
- en: This pass shouldn’t require any dedicated logic to deal with constant strings.
    We’ve already recorded that they have static storage duration in the backend symbol
    table. Now we’ll access them with <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands like any other static object.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instruction
    Fix-Up</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The destination of a <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction must be a register, and its source must not be an immediate value.
    If the size of the source operand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction is 1 byte and its source or destination is invalid, we rewrite it
    according to the usual pattern. For instance, we rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If its source operand is a longword, we replace it with one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions, like in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If the source of a <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instruction is an immediate value that can’t fit in a single byte, we’ll reduce
    it modulo 256\. For example, we’ll rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is the same pattern we introduced in [Chapter 11](chapter11.xhtml) to handle
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instructions whose source
    operands are 8-byte immediate values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code emission stage needs to support string constants, pointer initializers,
    and a handful of other changes. We’ll emit each <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp>
    as either an <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> or an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directive, depending
    on whether it should include a null byte. Double quotes, backslashes, and new
    lines in ASCII strings must be escaped. To escape these characters, you can use
    either the <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> escape sequences or
    three-digit octal escape sequences that specify their ASCII values. For example,
    the ASCII code for the backslash character is <samp class="SANS_TheSansMonoCd_W5Regular_11">92</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">134</samp> in octal, so you could
    represent it with the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\134</samp>.
    You can escape other special characters too, but you don’t need to. Some escape
    sequences, like <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>, are valid
    in C but not assembly, so octal escape sequences are the safest way to escape
    arbitrary characters.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll emit each <samp class="SANS_TheSansMonoCd_W5Regular_11">PointerInit</samp>
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> directive, followed
    by the label we want to point to. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">CharInit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UCharInit</samp> to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.byte</samp> directive, which works exactly
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp>.
    When you emit a 1-byte-aligned object, you can either include the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp>
    directive or omit it. Every object is at least 1-byte aligned by definition, so
    specifying a 1-byte alignment has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, string constants will live in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp>
    section along with floating-point constants. On macOS, they’ll live in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp> section. If you use local
    labels (which begin with a <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> prefix) for floating-point
    constants, you should use them for string constants too. The logic to add this
    prefix to <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands won’t
    change; we’ll still look up each <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand in the backend symbol table and add this prefix if its <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    attribute is true.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    instructions should include suffixes to indicate both the source and destination
    types. Other instructions should include a <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    suffix when they operate on bytes. [Tables 16-6](chapter16.xhtml#tab16-6) through
    [16-9](chapter16.xhtml#tab16-6) summarize the latest updates to the code emission
    pass; new constructs and changes to the way we emit existing constructs are bolded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(name, alignment,
    init)</samp> | <samp class="SANS_Futura_Std_Book_11">Linux</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_11">macOS (8-byte-aligned numeric constants)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_11">macOS (16-byte-aligned numeric constants)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">macOS (string constants)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">CharInit(0)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero
    1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">CharInit(i)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(0)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero
    1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(i)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, True)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.asciz "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><s></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">"</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, False)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.ascii "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><s></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">"</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PointerInit(label)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><label></samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_Futura_Std_Heavy_B_11">src_t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">dst_t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">MovZeroExtend(src_t, dst_t, src,
    dst)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-9:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Assembly Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Your compiler now supports strings and characters! You still need to run this
    chapter’s tests to make sure you’ve implemented these features correctly, but
    first, we’ll try out a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hello Again, World!</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Back in [Chapter 9](chapter9.xhtml), we printed “Hello, World!” one character
    at a time. Now we can write a more traditional “Hello, World!” program using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> standard library function,
    which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Since we don’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    we’ll declare <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> without
    it. [Listing 16-33](chapter16.xhtml#list16-33) shows our new “Hello, World!” program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-33: Printing out
    a string with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">puts</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is not entirely legal, since the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    isn’t compatible with the definition in the standard library. However, the program
    should work correctly in spite of this minor bit of rule breaking. Compile it,
    then run it to print a message to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you want to get really wild, you can even compile [Listing 16-34](chapter16.xhtml#list16-34),
    which reads from stdin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-34: Reading from
    stdin</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Much like [Listing 16-33](chapter16.xhtml#list16-33) declares <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    without the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier,
    this program declares several library functions without their usual qualifiers,
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    to read from stdin one character at a time, since our compiler can’t easily handle
    most other ways to read from stdin using C standard library functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-34](chapter16.xhtml#list16-34) declares two static arrays: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>.
    Because <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is static but
    has no explicit initializer, it will be initialized with all zeros ❶. The beginning
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> is initialized
    with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, "</samp>,
    and the remainder is filled with null bytes ❷. This program calls <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    to emit a prompt, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    in a loop to read the user’s response into the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    array, one character at a time. We exit the loop when <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    returns a negative number (which indicates end-of-file or an error), a null byte,
    or a new line character, or after we’ve read in 29 characters, whichever comes
    first. (We check whether the result is negative, instead of comparing it to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> macro like a normal C
    program would, because we can’t include <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> is defined.) Reading
    in at most 29 characters leaves room for a terminating null byte, which we add
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> after exiting the
    loop ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> appends
    the user’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>,
    and the subsequent call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>
    appends an exclamation point. Finally, the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    writes the whole message to stdout. Your compiler should be able to handle this
    listing; go ahead and give it a try! I’ll use the program to say hello to my dog,
    Arlo. (I promised him I’d mention him in this book at least once.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If this program works correctly, you’re ready to run the full test suite.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your compiler can now process programs that work with text. In this chapter,
    you learned how to lex string literals and character constants, and you extended
    the type checker to distinguish between constant strings and string literals that
    initialize arrays. You also introduced new ways to define constants in the symbol
    table and the TACKY IR. In the next chapter, you’ll introduce two features that
    make it easier to dynamically allocate memory: the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator and the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type.'
  prefs: []
  type: TYPE_NORMAL
