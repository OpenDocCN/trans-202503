- en: '![](../images/pg422.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg422.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-40.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-40.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CHARACTERS
    AND STRINGS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">字符与字符串</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'In this chapter, you’ll implement three new integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. These are the *character types*, which have a size of 1 byte. Because
    your compiler already supports signed and unsigned integers in multiple sizes,
    you can add these new types with minimal effort. You’ll also add support for string
    literals and character constants. String literals play a weird role in C: sometimes
    they behave like compound initializers, and at other times they represent constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> arrays. To support the
    latter case, you’ll store constant strings alongside variables in the symbol table,
    and you’ll introduce static constants as a top-level construct in TACKY.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将实现三种新的整数类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>。这些是*字符类型*，它们的大小为 1 字节。由于你的编译器已经支持多种大小的有符号和无符号整数，你可以很轻松地添加这些新类型。你还将支持字符串字面量和字符常量。字符串字面量在
    C 中扮演着一个奇怪的角色：有时它们表现得像复合初始化器，而有时它们表示常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    数组。为了支持后者，你将把常量字符串和变量一起存储在符号表中，并且在 TACKY 中引入静态常量作为顶级构造。
- en: 'At the end of the chapter, we’ll compile “Hello, World!” In [Chapter 9](chapter9.xhtml),
    we compiled a version of this program that printed one character at a time. This
    time, we’ll compile a more reasonable version that prints out an entire string.
    Before we get started, I’ll give you a bit of background information: I’ll first
    touch on a few notable differences between the character types and the other integers,
    then describe how strings work in C and assembly.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将编译一个“Hello, World!”程序。在[第9章](chapter9.xhtml)中，我们编译了一个每次打印一个字符的版本。这一次，我们将编译一个更合理的版本，能够打印整个字符串。在开始之前，我先给你一些背景信息：我将首先简要介绍字符类型与其他整数类型之间的几个显著差异，然后描述在
    C 和汇编中字符串是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Character Traits</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字符类型</samp>
- en: The most surprising thing about the character types is that there are three
    of them. There’s no distinction between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> or between
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp>, but the specifiers <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> refer to
    two distinct types. Whether “plain” <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is signed or unsigned is implementation-defined. We’ll follow the System V ABI,
    which specifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is signed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符类型，最让人惊讶的是它们竟然有三种。<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> 之间没有区别，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp> 也没有区别，但规格说明符 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 指代的是两种不同的类型。是否“普通”的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 是有符号还是无符号是由实现决定的。我们将遵循
    System V ABI，它规定 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 是有符号的。
- en: Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> will behave identically
    in our implementation, the fact that they’re different types has real consequences.
    For instance, [Listing 16-1](chapter16.xhtml#list16-1) is illegal because it declares
    the same global variable as both a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们的实现中 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 的行为完全相同，但它们作为不同类型的事实仍然会产生实际后果。例如，[示例
    16-1](chapter16.xhtml#list16-1) 是非法的，因为它将同一个全局变量同时声明为 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-1: Conflicting file
    scope variable declarations with different character types</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 16-1：具有不同字符类型的冲突文件范围变量声明</samp>
- en: Declaring a global variable as both an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>, on the
    other hand, is perfectly legal, since both declarations specify the same type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，将全局变量同时声明为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp> 是完全合法的，因为这两种声明指定了相同的类型。
- en: The character types also follow slightly different type conversion rules than
    the other integer types. When a character is used in a unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    operation; a bitwise binary operation; or the usual arithmetic conversions, it’s
    first converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    These conversions are called the *integer promotions*. (If <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    can’t fit every value of a particular character type, the character is converted
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> instead.
    In our implementation, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    can hold every value of every character type, so this is a moot point. Of course,
    we can also ignore the typing rules for operations we haven’t implemented, like
    unary <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and the bitwise binary
    operations; I’m mentioning them here only for the sake of completeness.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类型在类型转换规则上也与其他整数类型略有不同。当字符用于一元 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    操作；按位二进制操作；或常规的算术转换时，它首先会被转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。这些转换称为*整数提升*。（如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 无法容纳某个特定字符类型的所有值，则该字符会被转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>。在我们的实现中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 可以容纳每种字符类型的所有值，因此这一点不重要。当然，我们也可以忽略未实现操作的类型规则，比如一元
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 和按位二进制操作；我在这里提到它们只是为了完整性。）
- en: 'There’s one more noteworthy difference between characters and other integers:
    in C17, there are no scalar constants of character type. Tokens like <samp class="SANS_TheSansMonoCd_W5Regular_11">''a''</samp>
    all have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, despite
    being called “character constants.” There are constants with *wide character types*
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>, which are intended
    to represent multibyte characters, but we won’t implement them.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字符和其他整数之间还有一个值得注意的区别：在 C17 中，字符类型没有标量常量。像 <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>
    这样的符号都具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型，尽管它们被称为“字符常量”。也有像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 这样的*宽字符类型*常量，它们用于表示多字节字符，但我们不会实现它们。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*C23 introduces u8 character constants with type unsigned char. These represent
    1-byte UTF-8 characters.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*C23 引入了 u8 字符常量，类型为 unsigned char。它们表示 1 字节的 UTF-8 字符。*'
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">String Literals</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">字符串字面量</samp>'
- en: Throughout this chapter, I’ll distinguish between string literals and strings.
    A *string literal* is an expression that appears in the source code, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>. A *string* is an object
    that lives in memory—specifically, a null-terminated <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    array. Some strings can’t be modified at runtime; I’ll call these *constant strings*,
    although this isn’t a standard term.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将区分字符串字面量和字符串。*字符串字面量*是源代码中出现的表达式，如<samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>。*字符串*是一个存在于内存中的对象——具体来说，是一个空字符终止的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>数组。某些字符串在运行时不能被修改；我将这些称为*常量字符串*，尽管这不是一个标准术语。
- en: 'You can use a string literal in two distinct ways. First, it can initialize
    an array of any character type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以两种不同的方式使用字符串字面量。首先，它可以初始化任何字符类型的数组：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We’ll include a terminating null byte if there’s space and omit it if there
    isn’t. This coincides with our usual rules for array initialization: if the initializer
    is shorter than the target object, we pad out the remainder with zeros. Therefore,
    the previous declaration is equivalent to:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有空间，我们会包含一个终止的空字符；如果没有空间，则省略它。这与我们通常的数组初始化规则一致：如果初始化器比目标对象短，我们会用零填充剩余部分。因此，之前的声明等价于：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [Listing 16-2](chapter16.xhtml#list16-2), on the other hand, we leave out
    the null byte in <samp class="SANS_TheSansMonoCd_W5Regular_11">array1</samp> because
    the array isn’t large enough to include it. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">array1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">array2</samp> have identical
    contents.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在[清单16-2](chapter16.xhtml#list16-2)中，我们省略了<samp class="SANS_TheSansMonoCd_W5Regular_11">array1</samp>中的空字符，因为数组不足够大，无法包含它。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">array1</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">array2</samp>具有相同的内容。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-2: Using a string
    literal as an array initializer without the null byte</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单16-2：将字符串字面量用作数组初始化器而不带空字符</samp>
- en: 'When a string literal appears anywhere other than as an array initializer,
    it designates a constant string. In this context, string literals act a lot like
    other expressions of array type. They decay to pointers like other array expressions,
    so you can subscript them or assign them to <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp> objects. The following declaration initializes the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">str_ptr</samp>
    with the address of the first character in the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串字面量出现在数组初始化器之外时，它表示一个常量字符串。在这种情况下，字符串字面量的行为类似于其他数组类型的表达式。它们像其他数组表达式一样衰退为指针，因此你可以对其进行下标操作，或者将其赋值给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>类型的对象。以下声明用常量字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>中第一个字符的地址初始化变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">str_ptr</samp>：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'String literals are also lvalues, so they support the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator. Here, we use this operator to take the address of the constant string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>, then assign it to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">array_ptr</samp>:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量也是左值，因此它们支持<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>操作符。在这里，我们使用该操作符获取常量字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>的地址，然后将其赋值给<samp class="SANS_TheSansMonoCd_W5Regular_11">array_ptr</samp>：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only difference from the previous example is that the string literal doesn’t
    undergo array decay. We end up with a pointer to the whole string, with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char (*)[4]</samp>, instead of a pointer
    to its first element, with type <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp>. In both examples, we treat <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>
    like any other expression of array type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子唯一不同的是，字符串字面量不会发生数组衰退。我们最终得到一个指向整个字符串的指针，类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">char
    (*)[4]</samp>，而不是指向其第一个元素的指针，类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp>。在这两个例子中，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>当作任何其他数组类型的表达式来处理。
- en: Unlike other arrays, constant strings are, well, constant. Attempting to modify
    them, as in [Listing 16-3](chapter16.xhtml#list16-3), produces undefined behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数组不同，常量字符串是恒定的。尝试修改它们，如在[清单16-3](chapter16.xhtml#list16-3)中所示，会导致未定义行为。
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-3: Illegally modifying
    a constant string</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单16-3：非法修改常量字符串</samp>
- en: Although this code compiles, it will probably throw a runtime error, because
    most C implementations—including ours—store constant strings in read-only memory.
    (The <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier, which
    we won’t implement, informs the compiler that an object cannot be modified. If
    [Listing 16-3](chapter16.xhtml#list16-3) were part of a real C program, it would
    be a good idea to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualifier to <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码能够编译，但它可能会抛出运行时错误，因为大多数C语言实现——包括我们的实现——将常量字符串存储在只读内存中。（<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>限定符，虽然我们不会实现它，告诉编译器对象不能被修改。如果[清单16-3](chapter16.xhtml#list16-3)是一个实际的C程序的一部分，那么给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>添加一个<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>限定符会是一个好主意。）
- en: Let’s look at one more example, shown in [Listing 16-4](chapter16.xhtml#list16-4),
    to clarify the difference between string literals that designate constant strings
    and string literals that initialize arrays.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，如[清单16-4](chapter16.xhtml#list16-4)所示，以澄清表示常量字符串的字符串字面量与初始化数组的字符串字面量之间的区别。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-4: Legally modifying
    an array initialized from a string literal</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单16-4：合法地修改从字符串字面量初始化的数组</samp>
- en: Unlike [Listing 16-3](chapter16.xhtml#list16-3), this code is perfectly legal.
    In [Listing 16-3](chapter16.xhtml#list16-3), <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to the start of the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>.
    In [Listing 16-4](chapter16.xhtml#list16-4), on the other hand, we use each character
    of the string literal <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>
    to initialize one element of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>,
    which is an ordinary, non-constant <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    array.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与[清单16-3](chapter16.xhtml#list16-3)不同，这段代码是完全合法的。在[清单16-3](chapter16.xhtml#list16-3)中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>指向常量字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>的开头。另一方面，在[清单16-4](chapter16.xhtml#list16-4)中，我们使用字符串字面量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>的每个字符来初始化<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>的一个元素，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>是一个普通的、非常量的<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>数组。
- en: Both cases are easier to understand once we see how they translate to assembly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们看到它们如何转换为汇编语言，这两种情况就更容易理解了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Working with Strings in Assembly</samp>
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编中处理字符串</samp>
- en: We’ll use two different assembly directives to initialize strings in assembly.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    directives both tell the assembler to write an ASCII string to the object file,
    much like <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> tells it
    to write a quadword. The difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    will include a terminating null byte and <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    won’t. The three declarations
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种不同的汇编指令来初始化汇编中的字符串。<samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>指令都告诉汇编器将ASCII字符串写入目标文件，就像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp>指令告诉它写入一个四字节数一样。区别在于，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>会包含一个终止的空字节，而<samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>则不会。三条声明
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: correspond to the assembly in [Listing 16-5](chapter16.xhtml#list16-5).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于[清单16-5](chapter16.xhtml#list16-5)中的汇编代码。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-5: Initializing
    three static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">arrays from string literals in
    assembly</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单16-5：从字符串字面量在汇编中初始化三个静态</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">数组</samp>
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    is long enough to accommodate a null byte, we initialize it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    directive. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">not_null _terminated</samp>
    so we don’t go past the bounds of the array. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">extra_padding</samp>
    needs two zero bytes to reach the correct length, we write a null-terminated string,
    then write an extra zero byte with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>
    directive. Note that none of these variables needs an <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp>
    directive. The character types are all 1-byte aligned, so arrays of characters
    are too. (Array variables containing 16 or more characters are the exception;
    they’re 16-byte aligned, like all array variables that are 16 bytes or larger.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp> 的长度足以容纳一个空字节，我们用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> 指令初始化它。我们用 <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    来初始化 <samp class="SANS_TheSansMonoCd_W5Regular_11">not_null_terminated</samp>，这样我们就不会越界访问数组。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extra_padding</samp> 需要两个零字节来达到正确的长度，我们先写一个空终止字符串，然后用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> 指令再写一个额外的零字节。请注意，这些变量都不需要
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp> 指令。字符类型本身是1字节对齐的，因此字符数组也是如此。（包含16个或更多字符的数组是例外；它们是16字节对齐的，就像所有大于或等于16字节的数组变量一样。）
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    directives initialize objects with static storage duration. Next, let’s consider
    [Listing 16-6](chapter16.xhtml#list16-6), which initializes a non-static array.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>
    指令用来初始化具有静态存储持续时间的对象。接下来，让我们看看 [列表 16-6](chapter16.xhtml#list16-6)，它初始化了一个非静态数组。
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-6: Using a string
    literal to initialize a non-static array</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-6：使用字符串字面量初始化一个非静态数组</samp>
- en: '[Listing 16-7](chapter16.xhtml#list16-7) illustrates one way to initialize
    <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp> in assembly, by copying
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcde"</samp> onto the stack one
    byte at a time.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-7](chapter16.xhtml#list16-7) 展示了一种在汇编中初始化 <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    的方法，通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcde"</samp> 每次一个字节地复制到栈上。'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-7: Initializing
    a non-static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">array in assembly</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-7：在汇编中初始化一个非静态</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">数组</samp>
- en: The characters <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp>
    have ASCII values <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>,
    respectively. Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    starts at stack address <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>,
    the instructions in [Listing 16-7](chapter16.xhtml#list16-7) copy each character
    to the appropriate location in the array. The <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    suffix in each <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> instruction
    indicates that it operates on a single byte.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 字符<samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp>的ASCII值分别是<samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">98</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>。假设<samp
    class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>从栈地址<samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>开始，[列表
    16-7](chapter16.xhtml#list16-7)中的指令会将每个字符复制到数组的适当位置。每条<samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>指令中的<b>b</b>后缀表示它是操作一个字节。
- en: '[Listing 16-8](chapter16.xhtml#list16-8) demonstrates a more efficient approach.
    We initialize the first 4 bytes of this string with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction, then use <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instructions to initialize the remaining 2 bytes.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-8](chapter16.xhtml#list16-8)展示了一种更高效的方法。我们使用一条<samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>指令初始化字符串的前4个字节，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>指令初始化剩下的2个字节。'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-8: A more efficient
    way to initialize a non-static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">array in assembly</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-8：在汇编中更高效地初始化一个非静态</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">数组</samp>
- en: We get <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp> when
    we interpret the first 4 bytes of our string as an integer. (I’ll discuss how
    we get this integer in more detail later in the chapter.) This listing has the
    same effect as [Listing 16-7](chapter16.xhtml#list16-7), but it saves us a few
    instructions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将字符串的前4个字节解释为一个整数时，得到的值是<samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp>。（我将在本章后面详细讨论如何得到这个整数。）这个列表与[列表
    16-7](chapter16.xhtml#list16-7)的效果相同，但节省了几条指令。
- en: Next, let’s look at constant strings. We write these to read-only sections of
    the object file, just like floating-point constants. On Linux, we store constant
    strings in <samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp>; on macOS,
    we store them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp>
    section. Consider the code fragment in [Listing 16-9](chapter16.xhtml#list16-9),
    which returns a pointer to the start of a constant string.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看常量字符串。我们将这些字符串写入目标文件的只读部分，就像浮点常量一样。在Linux上，我们将常量字符串存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp>中；在macOS上，我们将它们存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp>部分。请看[列表 16-9](chapter16.xhtml#list16-9)中的代码片段，它返回指向常量字符串起始位置的指针。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-9: Returning a pointer
    to the start of a string</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-9：返回指向字符串起始位置的指针</samp>
- en: We’ll generate a unique label for this string, then define it in the appropriate
    section. [Listing 16-10](chapter16.xhtml#list16-10) gives the resulting assembly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会为这个字符串生成一个唯一的标签，然后在适当的部分定义它。[列表 16-10](chapter16.xhtml#list16-10)给出了结果汇编代码。
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-10: Defining a constant
    string in assembly</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-10：在汇编中定义一个常量字符串</samp>
- en: 'Constant strings are always null-terminated, since they don’t need to fit into
    any particular array dimensions. Once we’ve defined a constant string, we can
    access it with RIP-relative addressing, like any other static object. In this
    particular example, we want to return the string’s address, so we’ll load it into
    RAX with this instruction:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 常量字符串总是以空字符结尾，因为它们不需要适配任何特定的数组维度。一旦我们定义了常量字符串，就可以像访问其他静态对象一样，通过 RIP 相对寻址访问它。在这个特定的例子中，我们想要返回字符串的地址，因此我们将通过以下指令将其加载到
    RAX 中：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, let’s see how to initialize a static pointer with a string literal,
    like in [Listing 16-11](chapter16.xhtml#list16-11).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何像在[示例 16-11](chapter16.xhtml#list16-11)中那样，使用字符串常量初始化静态指针。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-11: Initializing
    a static</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char *</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">from a string literal</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 16-11：从字符串常量初始化静态</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">char *</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">指针</samp>
- en: We’ll define the string the same way as in [Listing 16-10](chapter16.xhtml#list16-10).
    However, we can’t load it into <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction.
    Because <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is static, it
    must be initialized before the program starts. Luckily, the <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp>
    directive accepts labels as well as constants. [Listing 16-12](chapter16.xhtml#list16-12)
    illustrates how to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    with this directive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与[示例 16-10](chapter16.xhtml#list16-10)相同的方式定义字符串。然而，我们不能通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp>
    指令将其加载到 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> 中。因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    是静态的，它必须在程序启动之前初始化。幸运的是，<samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp>
    指令不仅接受常量，还接受标签。[示例 16-12](chapter16.xhtml#list16-12) 演示了如何使用该指令初始化 <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>。
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-12: Initializing
    a static variable with the address of a static constant</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 16-12：用静态常量的地址初始化静态变量</samp>
- en: The directive <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad .Lstring.0</samp>
    tells the assembler and linker to write the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">.Lstring.0</samp>.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad .Lstring.0</samp> 告诉汇编器和链接器写入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.Lstring.0</samp> 的地址。
- en: As a side note, it’s possible to initialize any static pointer this way, not
    just pointers to strings. While our implementation doesn’t accept expressions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp> as static initializers,
    a more complete compiler might translate
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，实际上可以用这种方式初始化任何静态指针，而不仅仅是字符串指针。虽然我们的实现不接受像 <samp class="SANS_TheSansMonoCd_W5Regular_11">&x</samp>
    这样的表达式作为静态初始化器，但一个更完整的编译器可能会进行转换
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'into:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 进入：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, you know enough about how to use strings in C and assembly to
    get started. The first step is to extend the lexer to recognize string literals
    and character constants.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经了解了如何在 C 和汇编中使用字符串，可以开始编写代码了。第一步是扩展词法分析器，使其能够识别字符串常量和字符常量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add three new tokens in this chapter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍三个新的标记：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp> A keyword, used to
    specify character types
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp> 一个关键字，用来指定字符类型
- en: '**Character constants** Individual characters, like <samp class="SANS_TheSansMonoCd_W5Regular_11">''a''</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">''\n''</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符常量** 单个字符，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">''a''</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">''\n''</samp>'
- en: '**String literals** Sequences of characters, like <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello,
    World!"</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串常量** 一系列字符，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, World!"</samp>'
- en: A character constant consists of one character (like <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>)
    or escape sequence (like <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>)
    wrapped in single quotes. Section 6.4.4.4 of the C standard defines a set of escape
    sequences to represent special characters. [Table 16-1](chapter16.xhtml#tab16-1)
    lists these escape sequences and their ASCII codes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 字符常量由一个字符（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>）或转义序列（如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>）组成，并被单引号包围。C标准第6.4.4.4节定义了一组转义序列，用于表示特殊字符。[表16-1](chapter16.xhtml#tab16-1)列出了这些转义序列及其ASCII码。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-1:</samp> <samp class="SANS_Futura_Std_Book_11">Escape
    Sequences for Special Characters</samp>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表16-1：</samp> <samp class="SANS_Futura_Std_Book_11">特殊字符的转义序列</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Escape sequence</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">ASCII code</samp> |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">转义序列</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">ASCII码</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp> | <samp class="SANS_Futura_Std_Book_11">Single
    quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">39</samp> |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp> | <samp class="SANS_Futura_Std_Book_11">单引号</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">39</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp> | <samp class="SANS_Futura_Std_Book_11">Double
    quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">34</samp> |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp> | <samp class="SANS_Futura_Std_Book_11">双引号</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">34</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp> | <samp class="SANS_Futura_Std_Book_11">Question
    mark</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp> |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp> | <samp class="SANS_Futura_Std_Book_11">问号</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp> | <samp class="SANS_Futura_Std_Book_11">Backslash</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">92</samp> |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp> | <samp class="SANS_Futura_Std_Book_11">反斜杠</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">92</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp> | <samp class="SANS_Futura_Std_Book_11">Audible
    alert</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp> | <samp class="SANS_Futura_Std_Book_11">可听警告</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp> | <samp class="SANS_Futura_Std_Book_11">Backspace</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp> | <samp class="SANS_Futura_Std_Book_11">退格</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp> | <samp class="SANS_Futura_Std_Book_11">Form
    feed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp> | <samp class="SANS_Futura_Std_Book_11">换页符</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> | <samp class="SANS_Futura_Std_Book_11">New
    line</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> | <samp class="SANS_Futura_Std_Book_11">新行</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp> | <samp class="SANS_Futura_Std_Book_11">Carriage
    return</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp> |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp> | <samp class="SANS_Futura_Std_Book_11">回车</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp> | <samp class="SANS_Futura_Std_Book_11">Horizontal
    tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp> | <samp class="SANS_Futura_Std_Book_11">水平制表符</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp> | <samp class="SANS_Futura_Std_Book_11">Vertical
    tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp> | <samp class="SANS_Futura_Std_Book_11">垂直制表符</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp> |'
- en: The new line, single quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>),
    and backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) characters
    can’t appear on their own as character constants and must be escaped. Any other
    character can be used directly as a character constant as long as it’s in the
    *source character set*, the complete set of characters that can appear in a source
    file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符、单引号（<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>）和反斜杠（<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>）字符不能单独作为字符常量出现，必须进行转义。其他任何字符，只要它在*源字符集*中，即可直接用作字符常量，源字符集是可以出现在源文件中的完整字符集合。
- en: 'The source character set is implementation-defined, but it has to include at
    least the *basic source character set*, which is specified in section 5.2.1 of
    the C standard. In our implementation, the source character set includes all the
    printable ASCII characters, plus the required control characters: the new line,
    horizontal tab, vertical tab, and form feed. You don’t need to explicitly reject
    characters outside of this set; you can simply assume that they never show up
    in source files.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 源字符集是由实现定义的，但它必须至少包含*C标准*第5.2.1节中规定的*基本源字符集*。在我们的实现中，源字符集包括所有可打印的ASCII字符，以及所需的控制字符：换行符、水平制表符、垂直制表符和换页符。你不需要显式地排除这个集合以外的字符；你可以简单地假设它们在源文件中永远不会出现。
- en: Some of the characters in [Table 16-1](chapter16.xhtml#tab16-1), like the audible
    alert (<samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>) and backspace
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>), aren’t in our source
    character set, so they can be represented only by escape characters. Other characters,
    including the double quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>),
    question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>), form feed,
    and horizontal and vertical tabs, are in the source character set; they can be
    escaped in character constants, but they don’t have to be. For example, the character
    constants <samp class="SANS_TheSansMonoCd_W5Regular_11">'?'</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">'\?'</samp>
    are equivalent; they both represent the question mark character. The new line,
    single quote, and backslash are all in the source character set but still need
    to be escaped.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[表16-1](chapter16.xhtml#tab16-1)中的一些字符，如可听警告（<samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>）和退格（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>），不在我们的源字符集内，因此它们只能通过转义字符表示。其他字符，包括双引号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"</samp>）、问号（<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>）、换页符，以及水平和垂直制表符，都是源字符集的一部分；它们可以在字符常量中进行转义，但不一定需要这样做。例如，字符常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">''?''</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">''\?''</samp>
    是等效的；它们都表示问号字符。换行符、单引号和反斜杠都在源字符集中，但仍然需要进行转义。'
- en: We can recognize character constants with the truly egregious regular expression
    in [Listing 16-13](chapter16.xhtml#list16-13).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过[列表16-13](chapter16.xhtml#list16-13)中的真正令人震惊的正则表达式来识别字符常量。
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-13: The regular
    expression to recognize a character constant</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-13：用于识别字符常量的正则表达式</samp>
- en: Let’s break this down. The first alternative in the parenthesized expression,
    the character class <samp class="SANS_TheSansMonoCd_W5Regular_11">[^'\\\n]</samp>,
    matches any single character except for a single quote, backslash, or new line.
    We have to escape the backslash, because it’s a control character in PCRE regexes
    as well as in C string literals. Similarly, we use the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    in this regex to match a literal new line character. The second alternative, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\\['"?\\abfnrtv]</samp>, matches an escape
    sequence. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp> matches
    a single backslash, and the character class that follows includes every character
    that can follow the backslash in an escape sequence. The whole thing must start
    and end with single quotes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下。括号表达式中的第一个备选项，字符类 <samp class="SANS_TheSansMonoCd_W5Regular_11">[^'\\\n]</samp>，匹配除了单引号、反斜杠或换行符之外的任何单个字符。我们必须对反斜杠进行转义，因为它是
    PCRE 正则表达式以及 C 字符串文字中的控制字符。类似地，我们在这个正则表达式中使用转义序列 <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    来匹配字面量换行符。第二个备选项 <samp class="SANS_TheSansMonoCd_W5Regular_11">\\['"?\\abfnrtv]</samp>
    匹配一个转义序列。第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp> 匹配一个单独的反斜杠，紧随其后的字符类包含在转义序列中可能跟随的每个字符。整个表达式必须以单引号开始并结束。
- en: A string literal consists of a possibly empty sequence of characters and escape
    sequences, wrapped in double quotes. A single quote can appear on its own in a
    string literal, but a double quote must be escaped. [Listing 16-14](chapter16.xhtml#list16-14)
    shows the regular expression to recognize a string literal.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字由可能为空的字符和转义序列组成，且被双引号包裹。单引号可以单独出现在字符串文字中，但双引号必须转义。[清单 16-14](chapter16.xhtml#list16-14)展示了用于识别字符串文字的正则表达式。
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-14: The regular
    expression to recognize a string literal</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-14：用于识别字符串文字的正则表达式</samp>
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">[^"\\\n]</samp> matches
    any single character except a double quote, backslash, or new line. Like in [Listing
    16-13](chapter16.xhtml#list16-13), the second alternative matches every escape
    sequence. We apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    quantifier to the whole parenthesized expression because it can repeat zero or
    more times, and we delimit it all with double quotes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">[^"\\\n]</samp> 匹配任何单个字符，除了双引号、反斜杠或换行符。与[清单
    16-13](chapter16.xhtml#list16-13)中的情况类似，第二个备选项匹配每个转义序列。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    量词应用于整个括号表达式，因为它可以重复零次或多次，并且我们用双引号将其界定。
- en: After lexing a string literal or character token, you need to unescape it. In
    other words, you need to convert every escape sequence in that token to the corresponding
    ASCII character. You can do that either now or in the parser.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在对字符串文字或字符标记进行词法分析后，你需要解除转义。换句话说，你需要将该标记中的每个转义序列转换为相应的 ASCII 字符。你可以现在进行，也可以在解析器中进行。
- en: The standard defines a few other types of string literals and character constants
    that we won’t implement. In particular, we won’t support hexadecimal escape sequences
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">\xff</samp>, octal escape sequences
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">\012</samp>, or multicharacter
    constants like <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>. We also
    won’t support any of the types or constants used for non-ASCII encodings, like
    wide character types, wide string literals, or UTF-8 string literals.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 标准定义了一些其他类型的字符串文字和字符常量，我们不会实现它们。特别地，我们不会支持十六进制转义序列，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">\xff</samp>，八进制转义序列，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\012</samp>，或者多字符常量，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>。我们也不会支持任何用于非
    ASCII 编码的类型或常量，比如宽字符类型、宽字符串文字或 UTF-8 字符串文字。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: 'We’ll extend the AST definition in three ways. First, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> types. Second, we’ll add a new kind of expression to represent string
    literals. Third, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST node to represent constants with character types:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从三个方面扩展 AST 定义。首先，我们将添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> 类型。第二，我们将添加一种新的表达式类型来表示字符串字面量。第三，我们将扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    AST 节点，以表示具有字符类型的常量：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These new constant constructors are a little unusual because they don’t correspond
    to constant literals that actually appear in C programs. Character constants like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp> have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    so the parser will convert them to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>
    nodes; it won’t use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp> constructors
    at all. But we’ll need these constructors later, when we pad out partially initialized
    character arrays during type checking and when we initialize character arrays
    in TACKY.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的常量构造函数有些不寻常，因为它们与实际出现在 C 程序中的常量字面量不对应。像 <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>
    这样的字符常量的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，因此解析器会将它们转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp> 节点；它不会使用新的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp>
    构造函数。但我们将在稍后需要这些构造函数，尤其是在类型检查期间填充部分初始化的字符数组和在 TACKY 中初始化字符数组时。
- en: '[Listing 16-15](chapter16.xhtml#list16-15) gives the complete AST definition,
    with this chapter’s changes bolded.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-15](chapter16.xhtml#list16-15) 给出了完整的 AST 定义，本章的更改部分已加粗。'
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-15: The abstract
    syntax tree with character types, character constants, and string literals</samp>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-15：带有字符类型、字符常量和字符串字面量的抽象语法树</samp>
- en: It’s tempting to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>, to include
    string literals, but string literals are distinct enough from other kinds of constants
    that it’s easiest to define them separately. For example, the type checker will
    need to handle them differently than other constants when it processes initializers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>，以包括字符串字面量，但字符串字面量与其他类型的常量足够不同，因此最容易将它们单独定义。例如，类型检查器在处理初始化器时，需要将它们与其他常量区分开来。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Type
    Specifiers</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析类型说明符</samp>'
- en: We’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp>,
    which converts a list of type specifiers into a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node, to handle character types. I won’t provide the pseudocode for this,
    because the logic is pretty simple. If <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    appears in a declaration by itself, it specifies the plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type. If it appears with the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    keyword, it specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> type. If it appears with the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>
    keyword, it specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> type. As usual, the order of type specifiers doesn’t matter. It’s
    illegal for <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> to appear
    in a declaration with any other type specifier.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要扩展<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp>，它将类型说明符的列表转换为一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST 节点，以处理字符类型。我不会提供此部分的伪代码，因为逻辑非常简单。如果声明中单独出现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>，则表示普通的<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>类型。如果与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>关键字一起出现，则表示<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>类型。如果与<samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp>关键字一起出现，则表示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>类型。像往常一样，类型说明符的顺序不重要。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>与其他任何类型说明符一起出现在声明中都是非法的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Character
    Constants</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析字符常量</samp>
- en: The parser should convert each character constant token to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>
    with the appropriate ASCII value. It should convert the token <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(97)</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(10)</samp>, and so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器应该将每个字符常量标记转换为具有适当 ASCII 值的<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>。例如，应该将标记<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(97)</samp>，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt(10)</samp>，以此类推。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing String Literals</samp>
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">解析字符串字面量</samp>
- en: The parser should unescape string literals if the lexer hasn’t done that already.
    Each character in the string literal, including characters represented by escape
    sequences in the original source code, must be represented as a single byte internally.
    Otherwise, we’ll calculate inaccurate string lengths in the type checker and initialize
    arrays with incorrect values at runtime.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果词法分析器没有处理过，解析器应该解除字符串字面量的转义。字符串字面量中的每个字符，包括原始源代码中由转义序列表示的字符，必须在内部表示为一个单字节。否则，我们将在类型检查器中计算不准确的字符串长度，并在运行时使用不正确的值初始化数组。
- en: Adjacent string literal tokens should be concatenated into a single <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    AST node. For example, the parser should convert the statement
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相邻的字符串字面量标记应该连接成一个单独的<samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    AST 节点。例如，解析器应该将语句
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: to the AST node <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(String("foobar"))</samp>.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为 AST 节点 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(String("foobar"))</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将所有内容整合在一起</samp>
- en: '[Listing 16-16](chapter16.xhtml#list16-16) defines the complete grammar, with
    this chapter’s changes bolded.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16-16列表](chapter16.xhtml#list16-16)定义了完整的语法，并将本章的更改以粗体显示。'
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-16: The grammar
    with character types, character constants, and string literals</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">第16-16列表：包含字符类型、字符常量和字符串字面量的语法</samp>
- en: The bolded additions to the grammar correspond to the three changes to the parser
    we just discussed. The grammar now includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">"char"</samp>
    type specifier ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11"><string></samp>
    ❹ and <samp class="SANS_TheSansMonoCd_W5Regular_11"><char></samp> tokens ❺. We
    recognize a sequence of one or more string literals as a primary expression ❷
    and a character token as a constant ❸.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 语法中加粗的部分对应于我们刚刚讨论的解析器的三个更改。现在语法包括了<samp class="SANS_TheSansMonoCd_W5Regular_11">"char"</samp>类型说明符❶以及<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><string></samp> ❹和<samp class="SANS_TheSansMonoCd_W5Regular_11"><char></samp>标记❺。我们将一个或多个字符串字面量的序列识别为一个基本表达式❷，将字符标记识别为常量❸。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">类型检查器</samp>'
- en: For the most part, the type checker can treat characters like the other integer
    types. They follow the same typing rules and support the same operations. The
    integer promotions are the one exception to this pattern, so we’ll implement them
    in this section. We’ll also introduce static initializers for the character types.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，类型检查器可以像处理其他整数类型一样处理字符类型。它们遵循相同的类型规则并支持相同的操作。整数提升是这一模式的唯一例外，因此我们将在本节中实现它们。我们还将为字符类型引入静态初始化器。
- en: String literals are more challenging to type check, particularly when they appear
    in initializers. We’ll need to track whether each string should be used directly
    or converted to a pointer and which strings should be terminated with null bytes.
    We’ll add a few new constructs to the symbol table to represent each of these
    cases.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量的类型检查更加复杂，尤其是当它们出现在初始化器中时。我们需要跟踪每个字符串是否应该直接使用或转换为指针，并且需要确定哪些字符串应以空字节终止。我们将向符号表中添加一些新的构造来表示这些情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Characters</samp>
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符</samp>
- en: We’ll promote character types to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    as part of the usual arithmetic conversions. [Listing 16-17](chapter16.xhtml#list16-17)
    shows how to perform this promotion in <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会在常规算术转换中将字符类型提升为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。[清单
    16-17](chapter16.xhtml#list16-17)展示了如何在<samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>中执行这种提升。
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-17: Applying the
    integer promotions during the usual arithmetic conversions</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-17：在常规算术转换中应用整数提升</samp>
- en: After promoting the types of both operands, we’ll find their common type as
    usual. We’ll also promote the operands of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operations. [Listing
    16-18](chapter16.xhtml#list16-18) demonstrates how to promote a negated operand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在提升了两个操作数的类型后，我们将像往常一样找到它们的公共类型。我们还将提升一元操作符<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">~</samp>的操作数。[清单 16-18](chapter16.xhtml#list16-18)演示了如何提升一个取反操作数。
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-18: Applying the
    integer promotions to a negation expression</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-18：将整数提升应用于取反表达式</samp>
- en: First, we make sure the operand isn’t a pointer (we introduced this validation
    in [Chapter 14](chapter14.xhtml)). Then, we apply the integer promotions. We check
    whether the operand is one of the character types ❶; if it is, we convert it to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Int</samp> and then negate the promoted
    value. The result of the expression has the same type as its promoted operand
    ❷. We’ll handle <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> the same
    way, so I won’t provide the pseudocode for that here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保操作数不是指针（我们在[第14章](chapter14.xhtml)引入了此验证）。然后，我们应用整数提升。我们检查操作数是否是字符类型之一❶；如果是，我们将其转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Int</samp>，然后对提升后的值进行取反。表达式的结果与其提升后的操作数具有相同的类型❷。我们将以相同的方式处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">~</samp>，所以这里不提供该部分的伪代码。
- en: We’ll always recognize characters as integer types during type checking. For
    example, we’ll accept characters as operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> expressions and as
    indices in pointer arithmetic. Because all integer types are also arithmetic types,
    we’ll permit implicit conversions between the character types and any other arithmetic
    type in <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行类型检查时，我们总是会将字符识别为整数类型。例如，我们会接受字符作为<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">%</samp>表达式的操作数，以及指针运算中的索引。因为所有整数类型也是算术类型，所以我们会允许字符类型与任何其他算术类型之间的隐式转换，像在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>中那样。
- en: We’ll add two static initializers for the character types. [Listing 16-19](chapter16.xhtml#list16-19)
    gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为字符类型添加两个静态初始化器。[清单 16-19](chapter16.xhtml#list16-19)给出了更新后的<samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>定义。
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-19: Adding the static
    initializers for character types</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-19：为字符类型添加静态初始化器</samp>
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> and plain
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> are both signed types,
    we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">CharInit</samp> to initialize
    both of them. We’ll convert each initializer to the type it initializes according
    to the type conversion rules we covered in [Chapters 11](chapter11.xhtml) and
    [12](chapter12.xhtml). For example, if an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> is initialized with a value greater than 255, we’ll reduce its value
    modulo 256.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>和普通的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>都是有符号类型，我们将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">CharInit</samp>来初始化它们。我们将根据在[第
    11 章](chapter11.xhtml)和[第 12 章](chapter12.xhtml)中讨论的类型转换规则，将每个初始化器转换为它所初始化的类型。例如，如果一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>的值大于255，我们将其值取模256。
- en: Finally, we’ll make one small, straightforward update to the way we type check
    compound initializers for non-static arrays. (We’ll handle string literals that
    initialize arrays as a separate case in the next section.) In the previous chapter,
    we dealt with partly initialized arrays by padding out the remaining elements
    with zeros. I suggested writing a <samp class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>
    helper function to generate these zeroed-out initializers. Now we can extend that
    function to emit <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp> to zero out
    elements of character type.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将对非静态数组的复合初始化器进行类型检查的方式做一个小的、直接的更新。（我们将在下一节处理初始化数组的字符串字面量，作为一个单独的情况。）在前一章中，我们通过用零填充剩余元素来处理部分初始化的数组。我建议编写一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">zero_initializer</samp>辅助函数来生成这些填充零的初始化器。现在，我们可以扩展该函数，以便输出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ConstChar</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUChar</samp>来将字符类型的元素初始化为零。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals in
    Expressions</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">表达式中的字符串字面量</samp>
- en: When we encounter a string literal in an expression, rather than in an array
    initializer, we’ll annotate it as a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    array of the appropriate size. [Listing 16-20](chapter16.xhtml#list16-20) shows
    how to handle string literals in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在表达式中遇到字符串字面量时，而不是在数组初始化器中，我们会将其标注为适当大小的<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>数组。[清单
    16-20](chapter16.xhtml#list16-20)展示了如何在<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>中处理字符串字面量。
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-20: Type checking
    a string literal</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-20：类型检查字符串字面量</samp>
- en: Note that the array size accounts for a terminating null byte. The type checker
    already handles implicit conversions from arrays to pointers in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>.
    Now <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    will convert string literals to pointers too, since they also have array type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组大小会考虑一个终止的空字节。类型检查器已经在 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    中处理了数组到指针的隐式转换。现在 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    还会将字符串字面量转换为指针，因为它们也具有数组类型。
- en: Next, we’ll update the type checker to recognize <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    expressions as lvalues, along with variables, subscript operators, and dereference
    expressions. This allows programs to take their address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新类型检查器，使其识别 <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>
    表达式为左值，同时识别变量、下标运算符和解引用表达式。这使得程序可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    运算符获取它们的地址。
- en: That takes care of string literals in ordinary expressions; now we’ll type check
    string literals in initializers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经处理了普通表达式中的字符串字面量；现在我们将对初始化器中的字符串字面量进行类型检查。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals
    Initializing Non-static Variables</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符串字面量初始化非静态变量</samp>'
- en: Usually, we type check <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp>
    constructs with <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>,
    which converts values of array type to pointers. This approach correctly handles
    string literals that initialize pointers. But when a string literal is used to
    initialize an array, we’ll type check it differently. [Listing 16-21](chapter16.xhtml#list16-21)
    shows how to handle this case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>
    对 <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleInit</samp> 构造进行类型检查，该函数将数组类型的值转换为指针。这种方法正确处理了初始化指针的字符串字面量。但当字符串字面量用于初始化数组时，我们会采用不同的方式进行类型检查。[Listing
    16-21](chapter16.xhtml#list16-21) 展示了如何处理这种情况。
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-21: Type checking
    a string literal that initializes an array</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-21：类型检查初始化数组的字符串字面量</samp>
- en: First, we make sure the target type is an array of characters, since string
    literals can’t initialize arrays of any other type ❶. Then, we validate that the
    string isn’t too long to initialize the array ❷. Finally, we annotate the initializer
    with the target type ❸. We’ll use this annotation later to figure out how many
    null bytes to append to the string.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保目标类型是字符数组，因为字符串字面量不能初始化任何其他类型的数组 ❶。然后，我们验证字符串的长度是否适合初始化该数组 ❷。最后，我们使用目标类型注释初始化器
    ❸。稍后我们将使用这个注释来确定需要向字符串附加多少个空字节。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals Initializing
    Static Variables</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符串字面量初始化静态变量</samp>
- en: 'Our final task is to process string literals that initialize static variables.
    We’ll need to represent two new kinds of initial values in the symbol table: ASCII
    strings (which correspond to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives) and
    the addresses of static objects (which correspond to directives like <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad
    .Lstring.0</samp>). We’ll update <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    once again to include both kinds of initializers. [Listing 16-22](chapter16.xhtml#list16-22)
    gives the new definition with these two additions bolded.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终任务是处理初始化静态变量的字符串字面量。我们需要在符号表中表示两种新的初始值：ASCII 字符串（对应于 <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> 指令）和静态对象的地址（对应于像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad .Lstring.0</samp> 这样的指令）。我们将再次更新
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>，以包含这两种类型的初始化器。[Listing
    16-22](chapter16.xhtml#list16-22) 给出了包含这两个新增项的更新定义。
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-22: Adding the static
    initializers for strings and pointers</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-22：为字符串和指针添加静态初始化器</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp> defines an ASCII
    string initializer. We’ll use it to initialize both constant strings and character
    arrays. The <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    argument specifies whether to include a null byte at the end; we’ll use this argument
    to choose between the <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directives during
    code emission. <samp class="SANS_TheSansMonoCd_W5Regular_11">PointerInit</samp>
    initializes a pointer with the address of another static object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp> 定义了一个 ASCII
    字符串初始化器。我们将用它来初始化常量字符串和字符数组。<samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    参数指定是否在末尾包含空字节；我们将使用此参数在代码生成时在 <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> 指令之间进行选择。<samp class="SANS_TheSansMonoCd_W5Regular_11">PointerInit</samp>
    使用另一个静态对象的地址来初始化指针。
- en: We’ll also start tracking constant strings in the symbol table. [Listing 16-23](chapter16.xhtml#list16-23)
    gives the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>,
    which includes constants.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将开始在符号表中跟踪常量字符串。[清单 16-23](chapter16.xhtml#list16-23) 给出了更新后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>
    定义，其中包括常量。
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-23: Tracking constants
    in the symbol table</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-23：在符号表中跟踪常量</samp>
- en: Unlike a variable, which may be uninitialized, tentatively initialized, or initialized
    with a list of values, a constant is initialized with a single value. It also
    doesn’t need a <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> flag,
    since we’ll never define a global constant.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量不同，变量可能未初始化、暂时初始化或通过值列表初始化，常量则仅通过单一值进行初始化。常量也不需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp>
    标志，因为我们永远不会定义全局常量。
- en: Now that we’ve extended <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>, let’s
    discuss how to process string initializers for both character arrays and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> pointers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经扩展了 <samp class="SANS_TheSansMonoCd_W5Regular_11">static_init</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_attrs</samp>，让我们讨论如何处理字符数组和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 指针的字符串初始化器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing a Static Array
    with a String Literal</samp>
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用字符串字面量初始化静态数组</samp>
- en: 'If a string literal initializes a static array, we first validate the array’s
    type: we make sure that the array elements have character type and that the array
    is long enough to contain the string. (This is the same validation we performed
    for non-static arrays back in [Listing 16-21](chapter16.xhtml#list16-21).) We
    then convert the string literal to a <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp>
    initializer, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    flag if the array has enough space for the terminating null byte. We add <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp> to the initializer list
    if we need to pad it out with additional null bytes. For example, we’ll convert
    the declaration'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串字面量初始化了静态数组，我们首先验证数组的类型：确保数组元素是字符类型，并且数组足够大以容纳该字符串。（这与我们在 [清单 16-21](chapter16.xhtml#list16-21)
    中对非静态数组执行的验证相同。）然后，我们将字符串字面量转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp>
    初始化器，如果数组有足够的空间容纳终止的空字节，则设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">null_terminated</samp>
    标志。如果我们需要用额外的空字节填充它，则将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroInit</samp>
    添加到初始化器列表中。例如，我们将转换声明
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: to the symbol table entry in [Listing 16-24](chapter16.xhtml#list16-24).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对应符号表条目见 [清单 16-24](chapter16.xhtml#list16-24)。
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-24: The symbol table
    entry for an array initialized from a string literal</samp>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 16-24：由字符串字面量初始化的数组的符号表条目</samp>
- en: This entry initializes <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with the null-terminated string <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp>,
    followed by 6 bytes of zeros.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目用以空字符终止的字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"abc"</samp> 初始化
    <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>，接着是 6 字节的零。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing a Static Pointer
    with a String Literal</samp>
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用字符串字面量初始化静态指针</samp>
- en: 'If a string literal initializes a static variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp>, we create two entries in the symbol table. The first defines the string
    itself, and the second defines the variable that points to that string. Let’s
    look at an example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字符串字面量初始化了一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>
    的静态变量，我们将在符号表中创建两个条目。第一个定义了字符串本身，第二个定义了指向该字符串的变量。让我们来看一个例子：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we generate an identifier for the constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp>;
    let’s say this identifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">"string.0"</samp>.
    Then, we add the entry shown in [Listing 16-25](chapter16.xhtml#list16-25) to
    the symbol table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为常量字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp> 生成一个标识符；假设这个标识符是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"string.0"</samp>。然后，我们将 [Listing
    16-25](chapter16.xhtml#list16-25) 中显示的条目添加到符号表中。
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-25: Defining a constant
    string in the symbol table</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-25: 在符号表中定义一个常量字符串</samp>'
- en: This identifier must be globally unique and must be a syntactically valid label
    in assembly. In other words, it should follow the same constraints as the identifiers
    we generate for floating-point constants. Because [Listing 16-25](chapter16.xhtml#list16-25)
    defines a constant string, we use the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp>
    construct, and we’ll initialize it with the null-terminated string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp>.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标识符必须是全局唯一的，并且必须是语法上有效的汇编标签。换句话说，它应遵循我们为浮点常量生成标识符时相同的约束条件。由于 [Listing 16-25](chapter16.xhtml#list16-25)
    定义了一个常量字符串，我们使用新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp>
    结构，并用以空字符结尾的字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello!"</samp>
    来初始化它。
- en: Then, when we add <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    itself to the symbol table, we initialize it with a pointer to the symbol we just
    added. [Listing 16-26](chapter16.xhtml#list16-26) shows the symbol table entry
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，当我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> 本身添加到符号表时，我们用一个指向刚才添加的符号的指针来初始化它。[Listing
    16-26](chapter16.xhtml#list16-26) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    的符号表条目。
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-26: Defining a static
    pointer to a string in the symbol table</samp>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-26: 在符号表中定义指向字符串的静态指针</samp>'
- en: 'If a string literal initializes a pointer to a type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    we throw an error. (Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>
    already catches this error in the non-static case.) Even using a string literal
    to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char *</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char *</samp> is illegal.
    This is in keeping with the ordinary rules for type conversions: string literals
    have type <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>, and we
    can’t implicitly convert from one pointer type to another. By contrast, a string
    literal can initialize an *array* of any character type because it’s legal to
    implicitly convert each individual character from one character type to another.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字符串字面量初始化了一个指向除 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型以外的指针，我们将抛出错误。（请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_init</samp>
    已经在非静态情况下捕获了这个错误。）即使是使用字符串字面量初始化一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char *</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char *</samp>
    也是不合法的。这与普通的类型转换规则一致：字符串字面量的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp>，而我们不能隐式地从一种指针类型转换到另一种。相反，一个字符串字面量可以初始化任何字符类型的*数组*，因为将每个单独的字符从一种字符类型隐式转换到另一种字符类型是合法的。
- en: 'At this point, we have symbol table entries for all the strings that appear
    in static initializers. During TACKY generation, we’ll add all the other constant
    strings in the program to the symbol table too.  ### <samp class="SANS_Futura_Std_Bold_B_11">TACKY
    Generation</samp>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经为所有出现在静态初始化器中的字符串创建了符号表条目。在 TACKY 生成过程中，我们还将把程序中的所有其他常量字符串添加到符号表中。
    ### <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>'
- en: When we convert a program to TACKY, we can treat characters exactly like all
    the other integers. In particular, we’ll implement casts to and from character
    types with the existing type conversion instructions. For example, we’ll implement
    casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>
    instruction, and we’ll implement casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>.
    Processing string literals, however, requires a bit more work.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: "当我们将程序转换为TACKY时，我们可以像处理其他整数一样处理字符。特别地，我们将使用现有的类型转换指令实现从字符类型到其他类型的转换。例如，我们将使用<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">DoubleToUInt</samp>指令实现从<samp class=\"\
    SANS_TheSansMonoCd_W5Regular_11\">double</samp>到<samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >unsigned char</samp>的转换，我们将使用<samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >SignExtend</samp>指令实现从<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">char</samp>到<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">int</samp>的转换。然而，处理字符串字面量需要稍微多一点的工作。"
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals as
    Array Initializers</samp>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符串字面量作为数组初始化器</samp>
- en: In the type checker, we dealt with string literals that initialized static arrays.
    Now we’ll do the same for arrays with automatic storage duration.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型检查器中，我们处理了初始化静态数组的字符串字面量。现在我们将对具有自动存储持续时间的数组执行相同的操作。
- en: As we saw earlier in the chapter, there are two options here. The simpler option
    is to initialize these arrays one character at a time. The more efficient option
    is to initialize entire 4- or 8-byte chunks at once. Either way, we’ll copy the
    string into the array with a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    instructions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所看到的，这里有两种选择。更简单的选择是一次初始化一个字符的数组。更高效的选择是一次初始化整个4字节或8字节的块。无论哪种方式，我们都会通过一系列的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>指令将字符串复制到数组中。
- en: 'Let’s walk through both options. We’ll use the initializer from [Listing 16-6](chapter16.xhtml#list16-6),
    reproduced here, as a running example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来详细讲解这两种选择。我们将使用[清单16-6](chapter16.xhtml#list16-6)中的初始化器作为一个示例，具体如下：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we first looked at this example, we learned that the ASCII values of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>.
    Using the simple one-byte-at-a-time approach, we’ll initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with the TACKY instructions in [Listing 16-27](chapter16.xhtml#list16-27).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次查看这个例子时，我们了解到<samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'b'</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">'c'</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'d'</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">'e'</samp>的ASCII值分别为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">97</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">98</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">99</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">101</samp>。使用简单的逐字节初始化方法，我们将用TACKY指令初始化<samp
    class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>，具体见[清单16-27](chapter16.xhtml#list16-27)。
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-27: Initializing
    a non-static array in TACKY, one byte at a time</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单16-27：在TACKY中逐字节初始化一个非静态数组</samp>
- en: 'Using the more efficient approach, we’ll initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with a single 4-byte integer, followed by 2 individual bytes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更高效的方法，我们将用一个4字节的整数初始化<samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>，然后跟随2个单独的字节：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To come up with the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp>,
    we take the 4 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">97</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">98</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> and interpret them
    as a single little-endian integer. In hexadecimal, these bytes are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x61</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x62</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x63</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x64</samp>. The first byte
    in little-endian integers is least significant, so interpreting this byte sequence
    as an integer gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">0x64636261</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">1684234849</samp> in decimal.
    Whatever language you’re implementing your compiler in, it likely has utility
    functions to manipulate byte buffers and interpret them as integers, so you won’t
    need to implement this fiddly logic yourself.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To initialize eight characters at once, we’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp>
    instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstInt</samp>. We
    need to be careful not to overrun the bounds of the array we’re initializing;
    in this example, it would be incorrect to initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">letters</samp>
    with two 4-byte integers, because it would clobber neighboring values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: It’s up to you which of these approaches to use; they’re both equally correct.
    In either case, make sure to initialize the correct number of null bytes at the
    end of the string. In the type checker, you annotated every initializer, including
    string literals, with type information. Now you’ll use that type information to
    figure out how many null bytes to include. If a string literal is longer than
    the array it initializes, copy in only as many characters as the array can hold.
    In other words, leave off the null byte. If the string literal is too short, copy
    zeros into the rest of the array.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">String Literals in
    Expressions</samp>
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we encounter a string literal outside of an array initializer, we’ll add
    it to the symbol table as a constant string. Then, we’ll use its identifier as
    a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>. Let’s revisit
    [Listing 16-9](chapter16.xhtml#list16-9), which returns a pointer to the first
    character in a string:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The parser and type checker transform this into the following AST node:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To convert this AST node to TACKY, we first define <samp class="SANS_TheSansMonoCd_W5Regular_11">"A
    profound statement."</samp> in the symbol table:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This entry is no different from the constant strings we defined in the type
    checker. It has a globally unique, automatically generated label. It’s a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> array that’s just large enough
    to contain the whole string, including the terminating null byte. It’s initialized
    with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp>
    construct because we’ll ultimately store it in read-only memory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目与我们在类型检查器中定义的常量字符串没有什么不同。它有一个全局唯一的、自动生成的标签。它是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    数组，足够大以容纳整个字符串，包括终止的空字节。它通过新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstantAttr</samp>
    结构进行初始化，因为我们最终会将其存储在只读内存中。
- en: 'Now we can refer to the identifier we just defined—<samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp>,
    in this example—to load the string’s address:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以引用刚刚定义的标识符—在这个例子中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp>—来加载字符串的地址：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In short, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp>
    like any other symbol of array type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们像使用其他数组类型的符号一样使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">string.1</samp>。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Top-Level Constants
    in TACKY</samp>'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TACKY 中的顶层常量</samp>'
- en: 'We need to account for all these new constant strings when we convert entries
    in the symbol table to top-level TACKY definitions. The assembly AST already has
    a top-level constant construct. Now we’ll add the corresponding construct to TACKY:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在将符号表中的条目转换为顶层 TACKY 定义时，我们需要考虑所有这些新的常量字符串。汇编 AST 已经有一个顶层常量结构。现在我们将为 TACKY 添加相应的结构：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When we’re generating top-level TACKY definitions from the symbol table, we’ll
    generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    for every constant in the symbol table, just like we generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    for each static variable. Make sure to convert function definitions to TACKY before
    traversing the symbol table; otherwise, you’ll miss the constant strings that
    get added to the symbol table during this pass.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从符号表生成顶层 TACKY 定义时，我们会为符号表中的每个常量生成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>，就像我们为每个静态变量生成一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp> 一样。在遍历符号表之前，请确保将函数定义转换为
    TACKY；否则，您将错过在此过程中添加到符号表中的常量字符串。
- en: '[Listing 16-28](chapter16.xhtml#list16-28) summarizes the TACKY IR, with this
    chapter’s addition bolded.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-28](chapter16.xhtml#list16-28) 总结了 TACKY IR，并将本章新增部分加粗显示。'
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-28: Adding static
    constants to the TACKY IR</samp>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-28：将静态常量添加到 TACKY IR</samp>
- en: 'At this point, your TACKY generation pass should be good to go: it can handle
    individual characters, string literals that are implicitly converted to pointers,
    and string literals that initialize arrays.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的 TACKY 生成过程应该已经可以顺利进行：它可以处理单个字符、隐式转换为指针的字符串字面量以及初始化数组的字符串字面量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: We won’t do anything too fancy in this stage. First, we’ll convert operations
    on individual characters to assembly. This will require a few changes to the assembly
    AST. Then, we’ll handle TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    constructs and add constant strings to the backend symbol table.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们不会做太复杂的操作。首先，我们将把对单个字符的操作转换为汇编。这将需要对汇编 AST 进行一些修改。然后，我们将处理 TACKY <samp
    class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> 结构，并将常量字符串添加到后端符号表中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Operations on Characters</samp>
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符操作</samp>
- en: 'Most instructions support 1-byte operands as well as longwords and quadwords.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> suffix, like in the instructions
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">andb</samp>,
    indicates that an instruction operates on a single byte. We’ll introduce a new
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> assembly type to represent
    this new operand size:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数指令支持 1 字节操作数以及长字和四字。像指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">andb</samp> 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    后缀表示指令作用于单个字节。我们将引入一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    汇编类型来表示这种新的操作数大小：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We’ll convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> types to <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>.
    The general-purpose registers have 1-byte aliases too; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp>
    is the 1-byte alias for RAX. Luckily, our code emission pass already supports
    these aliases.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>类型转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>。通用寄存器也有1字节的别名；例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp>是RAX的1字节别名。幸运的是，我们的代码生成阶段已经支持这些别名。
- en: 'Aside from adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    type, we’ll need to convert to and from character types correctly. You can zero
    extend a 1-byte value to a wider type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction. This instruction takes a two-letter suffix, indicating the types
    of the source and destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movzbl</samp>
    instruction extends a byte to a longword, and <samp class="SANS_TheSansMonoCd_W5Regular_11">movzbq</samp>
    extends a byte to a quadword. (You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">movzwl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">movzwq</samp> to extend a 2-byte
    word to a larger type, but we don’t use 2-byte operands.) We’ll represent <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> with the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction in the assembly AST, but we’ll add the types of both operands:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加<samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>类型外，我们还需要正确地转换字符类型。你可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>指令将1字节的值零扩展到更大的类型。此指令带有两个字母的后缀，用于指示源和目标的类型。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movzbl</samp>指令将字节扩展为长字，<samp class="SANS_TheSansMonoCd_W5Regular_11">movzbq</samp>将字节扩展为四字。（你还可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movzwl</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">movzwq</samp>将2字节的字扩展为更大的类型，但我们不使用2字节操作数。）我们将在汇编抽象语法树中使用现有的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>指令来表示<samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>，但我们将添加两个操作数的类型信息。
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>,
    we’ll ultimately emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction with the correct suffix. If <samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, we’ll rewrite
    this to an ordinary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction
    during the fix-up pass, just like in earlier chapters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>，我们最终将生成带有正确后缀的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>指令。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">src_type</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>，我们将在修复阶段将其重写为普通的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令，就像在前面的章节中一样。
- en: 'To sign extend a byte to a larger type, we’ll use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp>
    instruction. This instruction also takes a suffix to specify the types of both
    the source and the destination: <samp class="SANS_TheSansMonoCd_W5Regular_11">movsbl</samp>
    extends a byte to a longword, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsbq</samp>
    extends a byte to a quadword, and <samp class="SANS_TheSansMonoCd_W5Regular_11">movslq</samp>
    extends a longword into a quadword. We’ll add type information to this instruction
    in the assembly AST too:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个字节符号扩展到更大的类型，我们将使用现有的<samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx</samp>指令。此指令还可以使用后缀来指定源和目标的类型：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movsbl</samp>将字节扩展到长字，<samp class="SANS_TheSansMonoCd_W5Regular_11">movsbq</samp>将字节扩展到四字，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movslq</samp>将长字扩展到四字。我们还将在汇编抽象语法树中为此指令添加类型信息：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can truncate a larger integer to a single byte with a <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instruction, just like you can truncate a quadword to a longword with <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>.
    Note that when you copy a value to a register with the <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instruction, the register’s upper bytes aren’t zeroed out. This isn’t a problem;
    whether we’re operating on a single byte or a longword, we use only the part of
    the register that holds the value itself, and we ignore the register’s upper bytes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> 指令将一个较大的整数截断为单字节，就像你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> 将四字长截断为长字一样。请注意，当你使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp> 指令将一个值复制到寄存器时，寄存器的高字节不会被清零。这不是问题；无论我们操作的是单字节还是长字，我们只使用寄存器中存储值的部分，忽略寄存器的高字节。
- en: Finally, let’s consider how to convert between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the character types. There’s no assembly instruction to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    directly to a 1-byte integer or vice versa. Instead, we’ll convert to or from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> as an intermediate step.
    To convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to any
    character type, we’ll first convert it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and then truncate it, as [Listing 16-29](chapter16.xhtml#list16-29) demonstrates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑如何在 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和字符类型之间进行转换。没有汇编指令可以直接将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 转换为 1 字节整数或反之。相反，我们会先将其转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，作为中间步骤。为了将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    转换为任何字符类型，我们首先将其转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，然后进行截断，如
    [列表 16-29](chapter16.xhtml#list16-29) 所示。
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-29: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a character type</samp>'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-29：将一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为字符类型</samp>
- en: '[Listing 16-30](chapter16.xhtml#list16-30) gives the assembly to convert an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> to a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We’ll zero extend it to
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, then convert the
    result to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-30](chapter16.xhtml#list16-30) 给出了将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的汇编代码。我们将其零扩展为一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，然后将结果转换为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。'
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-30: Converting an</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-30：将一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned
    char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
- en: And to convert either signed character type to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we’ll sign extend it to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    first, as [Listing 16-31](chapter16.xhtml#list16-31) demonstrates.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 而要将任意符号字符类型转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，我们将首先将其符号扩展为一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，正如 [列表 16-31](chapter16.xhtml#list16-31)
    所示。
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-31: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">or</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-31：将一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">char</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">或</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed
    char</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
- en: 'Next, we’ll deal with our second task: converting top-level constants from
    TACKY to assembly.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理第二个任务：将顶级常量从 TACKY 转换为汇编。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Top-Level Constants</samp>
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">顶级常量</samp>
- en: 'Processing a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    is extremely simple: we just convert it to an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>.
    You’ll also need to convert each constant string in the symbol table to an equivalent
    entry in the backend symbol table, like you do for variables. When you add a constant
    string to the backend symbol table, set its <samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp>
    attribute to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. If your
    backend symbol table includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    attribute, set this to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    as well. (Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    was an optional addition in [Chapter 13](chapter13.xhtml); it tells us when to
    use local labels during code emission.)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    非常简单：我们只需将其转换为汇编的 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>。你还需要将符号表中的每个常量字符串转换为后端符号表中的等效条目，就像处理变量一样。当你将常量字符串添加到后端符号表时，将其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp> 属性设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。如果你的后端符号表包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp> 属性，也将其设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。（请记住，<samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    是在 [第 13 章](chapter13.xhtml) 中添加的可选项；它告诉我们在代码生成时何时使用局部标签。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Complete Conversion
    from TACKY to Assembly</samp>
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从 TACKY 到汇编的完整转换</samp>
- en: '[Listing 16-32](chapter16.xhtml#list16-32) shows this chapter’s additions to
    the assembly AST.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-32](chapter16.xhtml#list16-32) 显示了本章对汇编 AST 的扩展。'
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-32: The assembly
    AST with byte operands</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 16-32：带字节操作数的汇编 AST</samp>
- en: '[Tables 16-2](chapter16.xhtml#tab16-2) through [16-5](chapter16.xhtml#tab16-5)
    summarize the latest updates to the conversion from TACKY to assembly, with new
    constructs and changes to the conversions for existing constructs bolded.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-2](chapter16.xhtml#tab16-2) 至 [16-5](chapter16.xhtml#tab16-5) 概述了从 TACKY
    到汇编的最新更新，新增的构造和现有构造的转换更改已加粗。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 16-2：</samp> <samp class="SANS_Futura_Std_Book_11">将顶级
    TACKY 构造转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 顶级构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶级构造</samp>
    |'
- en: '| --- | --- |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name, t, init)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><alignment
    of t></samp><samp class="SANS_Futura_Std_Heavy_B_11">, init)</samp> |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name, t, init)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">StaticConstant(name,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><t
    的对齐方式></samp><samp class="SANS_Futura_Std_Heavy_B_11">, init)</samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 16-3：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src, dst)</samp> |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src, dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp> |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend(src, dst)</samp>
    |  | <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><src
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate(src, dst)</samp> |  |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate(src, dst)</samp> |  |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><dst
    type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble(src, dst)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Movsx(Byte,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">Longword,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">)) Cvtsi2sd(Longword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">), dst)</samp> |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble(src, dst)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">或</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Movsx(Byte,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">Longword,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">)) Cvtsi2sd(Longword, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">), dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><src type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp>
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><src type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dst)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt(src, dst)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Cvttsd2si(Longword,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_Futura_Std_Heavy_B_11">))
    Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">), dst)</samp> |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt(src, dst)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">char</samp> <samp class="SANS_Futura_Std_Heavy_B_11">或</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">signed char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Cvttsd2si(Longword,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">src,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_Futura_Std_Heavy_B_11">))
    Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">), dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><dst type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    src, dst)</samp> |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">整数</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">长整数</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><dst 类型></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    src, dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned char</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(Byte,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">)) Cvtsi2sd(Longword, Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">),
    dst)</samp> |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">无符号字符</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(Byte,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">长字,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">寄存器(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">)) Cvtsi2sd(长字, 寄存器(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword,
    Quadword,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)) Cvtsi2sd(Quadword, Reg(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),
    dst)</samp> |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整数</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">长字, 四字长,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)) Cvtsi2sd(四字长, 寄存器(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Quadword,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(0),</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src) JmpCC(L,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长整数</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(四字长,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">常量(0),</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src)
    JmpCC(L,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)'
- en: Cvtsi2sd(Quadword, src, dst)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Cvtsi2sd(四字长, src, dst)
- en: Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 标签(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
- en: Mov(Quadword, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(四字长, src, 寄存器(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Mov(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(四字长, 寄存器(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), 寄存器(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Unary(Shr, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Unary(Shr, 四字长, 寄存器(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Binary(And, Quadword, Imm(1), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制(And, Quadword, Imm(1), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Binary(Or, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制(Or, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Cvtsi2sd(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Cvtsi2sd(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
- en: Binary(Add, Double, dst, dst)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制(Add, Double, dst, dst)
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 标签(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned char</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(Longword,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))
    Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp> |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">无符号字符型</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(长整型,</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">src,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">))
    Mov(Byte, Reg(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">), dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(Quadword, src, Reg(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">))
    Mov(Longword, Reg(<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">R</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">>), dst)</samp> |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整数</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si(Quadword,
    src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)) Mov(长整型, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">R</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)</samp> |'
- en: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), src) JmpCC(AE,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长整型</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp(Double,
    Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), src) JmpCC(AE,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)'
- en: Cvttsd2si(Quadword, src, dst)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Cvttsd2si(Quadword, src, dst)
- en: Jmp(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 标签(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label1></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)
- en: Mov(Double, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(Double, src, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Binary(Sub, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制(Sub, Double, Data(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Cvttsd2si(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Cvttsd2si(Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
- en: Mov(Quadword, Imm(9223372036854775808), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(Quadword, Imm(9223372036854775808), Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">))
- en: Binary(Add, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Binary(Add, Quadword, Reg(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">), dst)
- en: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Label(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><label2></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
- en: <samp class="SANS_Futura_Std_Book_11">And add a top-level constant:</samp>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_11">并添加一个顶级常量：</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, 8,
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><upper-bound></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, 8,
- en: DoubleInit(9223372036854775808.0))</samp> |
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleInit(9223372036854775808.0))</samp> |
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 16-4：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 操作数转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstChar(int))</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp> |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstChar(int))</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstUChar(int))</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp> |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant(ConstUChar(int))</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Imm(int)</samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 16-5：</samp> <samp class="SANS_Futura_Std_Book_11">类型转换为汇编代码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">源类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">对齐方式</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">SChar</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">SChar</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">UChar</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">UChar</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp> |'
- en: Next, let’s move on to pseudo-operand replacement and instruction fix-up. The
    updates to both of these passes are pretty straightforward.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看伪操作数替换和指令修复。这两个过程的更新都很直接。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pseudo-Operand Replacement</samp>
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">伪操作数替换</samp>
- en: We’ll allocate 1 byte on the stack for each <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>
    object. We don’t need to worry about rounding these down to the right alignment,
    because they’re all 1-byte aligned.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在堆栈上为每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp> 对象分配 1
    字节的空间。我们不需要担心将这些向下舍入到正确的对齐方式，因为它们都是 1 字节对齐的。
- en: This pass shouldn’t require any dedicated logic to deal with constant strings.
    We’ve already recorded that they have static storage duration in the backend symbol
    table. Now we’ll access them with <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands like any other static object.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这一阶段不需要任何专门的逻辑来处理常量字符串。我们已经在后端符号表中记录了它们具有静态存储持续时间。现在，我们将像访问其他静态对象一样访问它们，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>操作数。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instruction
    Fix-Up</samp>'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指令修复</samp>'
- en: The destination of a <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>
    instruction must be a register, and its source must not be an immediate value.
    If the size of the source operand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction is 1 byte and its source or destination is invalid, we rewrite it
    according to the usual pattern. For instance, we rewrite
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp>指令的目标必须是一个寄存器，且源操作数不能是立即数。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>指令的源操作数大小为1字节且其源或目标无效，我们将按照通常的模式重写它。例如，我们将重写
- en: '[PRE54]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'as:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE55]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If its source operand is a longword, we replace it with one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions, like in earlier chapters.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其源操作数是一个长字，我们将用一个或多个<samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令替换它，像前几章中那样。
- en: If the source of a <samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>
    instruction is an immediate value that can’t fit in a single byte, we’ll reduce
    it modulo 256\. For example, we’ll rewrite
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">movb</samp>指令的源操作数是一个无法放入单个字节的立即数，我们将对其进行模256操作。例如，我们将重写
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'as:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE57]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is the same pattern we introduced in [Chapter 11](chapter11.xhtml) to handle
    <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instructions whose source
    operands are 8-byte immediate values.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在[第11章](chapter11.xhtml)中介绍的相同模式，用于处理源操作数为8字节立即数的<samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>指令。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: The code emission stage needs to support string constants, pointer initializers,
    and a handful of other changes. We’ll emit each <samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp>
    as either an <samp class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp> or an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp> directive, depending
    on whether it should include a null byte. Double quotes, backslashes, and new
    lines in ASCII strings must be escaped. To escape these characters, you can use
    either the <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> escape sequences or
    three-digit octal escape sequences that specify their ASCII values. For example,
    the ASCII code for the backslash character is <samp class="SANS_TheSansMonoCd_W5Regular_11">92</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">134</samp> in octal, so you could
    represent it with the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\134</samp>.
    You can escape other special characters too, but you don’t need to. Some escape
    sequences, like <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>, are valid
    in C but not assembly, so octal escape sequences are the safest way to escape
    arbitrary characters.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成阶段需要支持字符串常量、指针初始化器以及其他一些更改。我们将每个<samp class="SANS_TheSansMonoCd_W5Regular_11">StringInit</samp>发射为一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.ascii</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">.asciz</samp>指令，具体取决于它是否包含一个空字节。ASCII字符串中的双引号、反斜杠和换行符必须进行转义。要转义这些字符，您可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>转义序列，或者使用三位八进制转义序列来指定它们的ASCII值。例如，反斜杠字符的ASCII码是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">92</samp>，或八进制表示为<samp class="SANS_TheSansMonoCd_W5Regular_11">134</samp>，因此可以使用转义序列<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\134</samp>表示它。你还可以转义其他特殊字符，但不需要。某些转义序列，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>，在C语言中有效，但在汇编中无效，因此八进制转义序列是转义任意字符的最安全方式。
- en: We’ll emit each <samp class="SANS_TheSansMonoCd_W5Regular_11">PointerInit</samp>
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> directive, followed
    by the label we want to point to. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">CharInit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UCharInit</samp> to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.byte</samp> directive, which works exactly
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp>.
    When you emit a 1-byte-aligned object, you can either include the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align</samp>
    directive or omit it. Every object is at least 1-byte aligned by definition, so
    specifying a 1-byte alignment has no effect.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, string constants will live in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.rodata</samp>
    section along with floating-point constants. On macOS, they’ll live in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.cstring</samp> section. If you use local
    labels (which begin with a <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> prefix) for floating-point
    constants, you should use them for string constants too. The logic to add this
    prefix to <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operands won’t
    change; we’ll still look up each <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operand in the backend symbol table and add this prefix if its <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    attribute is true.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">movsx</samp>
    instructions should include suffixes to indicate both the source and destination
    types. Other instructions should include a <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    suffix when they operate on bytes. [Tables 16-6](chapter16.xhtml#tab16-6) through
    [16-9](chapter16.xhtml#tab16-6) summarize the latest updates to the code emission
    pass; new constructs and changes to the way we emit existing constructs are bolded.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-6:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant(name, alignment,
    init)</samp> | <samp class="SANS_Futura_Std_Book_11">Linux</samp> |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_11">macOS (8-byte-aligned numeric constants)</samp>
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_11">macOS (16-byte-aligned numeric constants)</samp>
    |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '[PRE60]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">macOS (string constants)</samp>
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表16-7：</samp> <samp class="SANS_Futura_Std_Book_11">格式化静态初始化器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">静态初始化器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">CharInit(0)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero
    1</samp> |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">CharInit(0)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero
    1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">CharInit(i)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">CharInit(i)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(0)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero
    1</samp> |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(0)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.zero
    1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(i)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">UCharInit(i)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">.byte</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><i></samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, True)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.asciz "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><s></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">"</samp> |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, True)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.asciz "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><s></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">"</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, False)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.ascii "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><s></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">"</samp> |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">StringInit(s, False)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.ascii "</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><s></samp><samp
    class="SANS_Futura_Std_Heavy_B_11">"</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PointerInit(label)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><label></samp>
    |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">PointerInit(label)</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><label></samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表16-8：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_Futura_Std_Heavy_B_11">src_t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">dst_t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp> |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Movsx(</samp><samp class="SANS_Futura_Std_Heavy_B_11">src_t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_Futura_Std_Heavy_B_11">dst_t</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">, src, dst)</samp> |'
- en: '[PRE62]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">MovZeroExtend(src_t, dst_t, src,
    dst)</samp> |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">MovZeroExtend(src_t, dst_t, src,
    dst)</samp> |'
- en: '[PRE63]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-9:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Assembly Types</samp>
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表16-9：</samp> <samp class="SANS_Futura_Std_Book_11">汇编类型的指令后缀</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">指令后缀</samp>
    |'
- en: '| --- | --- |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Byte</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">b</samp>
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">字节</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">b</samp>
    |'
- en: Your compiler now supports strings and characters! You still need to run this
    chapter’s tests to make sure you’ve implemented these features correctly, but
    first, we’ll try out a couple of examples.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的编译器支持字符串和字符了！你仍然需要运行本章的测试，以确保这些功能已正确实现，但首先，我们将尝试几个例子。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hello Again, World!</samp>
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">再次见面，世界！</samp>
- en: 'Back in [Chapter 9](chapter9.xhtml), we printed “Hello, World!” one character
    at a time. Now we can write a more traditional “Hello, World!” program using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> standard library function,
    which has the following signature:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Since we don’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    we’ll declare <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> without
    it. [Listing 16-33](chapter16.xhtml#list16-33) shows our new “Hello, World!” program.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-33: Printing out
    a string with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">puts</samp>'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is not entirely legal, since the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    isn’t compatible with the definition in the standard library. However, the program
    should work correctly in spite of this minor bit of rule breaking. Compile it,
    then run it to print a message to stdout:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you want to get really wild, you can even compile [Listing 16-34](chapter16.xhtml#list16-34),
    which reads from stdin.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 16-34: Reading from
    stdin</samp>'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Much like [Listing 16-33](chapter16.xhtml#list16-33) declares <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    without the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier,
    this program declares several library functions without their usual qualifiers,
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    to read from stdin one character at a time, since our compiler can’t easily handle
    most other ways to read from stdin using C standard library functions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-34](chapter16.xhtml#list16-34) declares two static arrays: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>.
    Because <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is static but
    has no explicit initializer, it will be initialized with all zeros ❶. The beginning
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp> is initialized
    with the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello, "</samp>,
    and the remainder is filled with null bytes ❷. This program calls <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    to emit a prompt, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    in a loop to read the user’s response into the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    array, one character at a time. We exit the loop when <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    returns a negative number (which indicates end-of-file or an error), a null byte,
    or a new line character, or after we’ve read in 29 characters, whichever comes
    first. (We check whether the result is negative, instead of comparing it to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> macro like a normal C
    program would, because we can’t include <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> is defined.) Reading
    in at most 29 characters leaves room for a terminating null byte, which we add
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> after exiting the
    loop ❸.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> appends
    the user’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>,
    and the subsequent call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>
    appends an exclamation point. Finally, the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    writes the whole message to stdout. Your compiler should be able to handle this
    listing; go ahead and give it a try! I’ll use the program to say hello to my dog,
    Arlo. (I promised him I’d mention him in this book at least once.)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If this program works correctly, you’re ready to run the full test suite.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Your compiler can now process programs that work with text. In this chapter,
    you learned how to lex string literals and character constants, and you extended
    the type checker to distinguish between constant strings and string literals that
    initialize arrays. You also introduced new ways to define constants in the symbol
    table and the TACKY IR. In the next chapter, you’ll introduce two features that
    make it easier to dynamically allocate memory: the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator and the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
