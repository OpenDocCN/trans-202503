- en: Chapter 45. Introduction to System V IPC
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第45章. System V IPC简介
- en: 'System V IPC is the label used to refer to three different mechanisms for interprocess
    communication:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: System V IPC是用于指代三种不同进程间通信机制的标签：
- en: '*Message queues* can be used to pass messages between processes. Message queues
    are somewhat like pipes, but differ in two important respects. First, message
    boundaries are preserved, so that readers and writers communicate in units of
    messages, rather than via an undelimited byte stream. Second, each message includes
    an integer *type* field, and it is possible to select messages by type, rather
    than reading them in the order in which they were written.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息队列*可用于在进程之间传递消息。消息队列有点像管道，但在两个重要方面有所不同。首先，消息边界被保留，因此读者和写者按消息单位进行通信，而不是通过没有分隔符的字节流进行通信。其次，每个消息包括一个整数*类型*字段，可以按类型选择消息，而不是按照它们写入的顺序读取消息。'
- en: '*Semaphores* permit multiple processes to synchronize their actions. A semaphore
    is a kernel-maintained integer value that is visible to all processes that have
    the necessary permissions. A process indicates to its peers that it is performing
    some action by making an appropriate modification to the value of the semaphore.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号量*允许多个进程同步它们的操作。信号量是由内核维护的整数值，所有具有必要权限的进程都可以看到该值。一个进程通过适当修改信号量的值来向其同伴指示自己正在执行某个操作。'
- en: '*Shared memory* enables multiple processes to share the same region (called
    a *segment*) of memory (i.e., the same page frames are mapped into the virtual
    memory of multiple processes). Since access to user-space memory is a fast operation,
    shared memory is one of the quickest methods of IPC: once one process has updated
    the shared memory, the change is immediately visible to other processes sharing
    the same segment.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享内存*使得多个进程可以共享同一区域（称为*段*）的内存（即，相同的页面框架映射到多个进程的虚拟内存中）。由于访问用户空间内存是一个快速操作，共享内存是IPC中最快的方法之一：一旦一个进程更新了共享内存，其他共享相同段的进程就能立即看到该更改。'
- en: Although these three IPC mechanisms are quite diverse in function, there are
    good reasons for discussing them together. One reason is that they were developed
    together, first appearing in the late 1970s in Columbus UNIX. This was a Bell-internal
    UNIX implementation used for database and transaction-processing systems for telephone
    company record keeping and administration. Around 1983, these IPC mechanisms made
    their way into mainstream UNIX by appearing in System V—hence the appellation
    System V IPC.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这三种IPC机制在功能上各有不同，但有充分的理由将它们一起讨论。一个原因是它们是一起开发的，首次出现在1970年代末期的哥伦布UNIX中。这是贝尔公司内部用于数据库和事务处理系统的UNIX实现，用于电话公司记录保存和管理。大约在1983年，这些IPC机制通过出现在System
    V中进入了主流UNIX——因此被称为System V IPC。
- en: A more significant reason for discussing the System V IPC mechanisms together
    is that their programming interfaces share a number of common characteristics,
    so that many of the same concepts apply to all of these mechanisms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论System V IPC机制的另一个重要原因是它们的编程接口共享许多共同特性，因此许多相同的概念适用于所有这些机制。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because System V IPC is required by SUSv3 for XSI conformance, it is sometimes
    alternatively labeled *XSI IPC*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为系统V IPC是SUSv3为XSI兼容性所要求的，它有时被称为*XSI IPC*。
- en: This chapter provides an overview of the System V IPC mechanisms and details
    those features that are common to all three mechanisms. The three mechanisms are
    then discussed individually in the following chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了System V IPC机制的概述，并详细介绍了所有三种机制共有的特性。接下来的章节将逐一讨论这三种机制。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: System V IPC is a kernel option that is configured via the CONFIG_SYSVIPC option.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: System V IPC是一个内核选项，可以通过CONFIG_SYSVIPC选项进行配置。
- en: API Overview
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API概述
- en: '[Table 45-1](ch45.html#summary_of_programming_interfaces_for_sy "Table 45-1. Summary
    of programming interfaces for System V IPC objects") summarizes the header files
    and system calls used for working with System V IPC objects.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[表45-1](ch45.html#summary_of_programming_interfaces_for_sy "表45-1. System V
    IPC对象的编程接口总结")总结了用于操作System V IPC对象的头文件和系统调用。'
- en: Some implementations require the inclusion of `<sys/types.h>` before including
    the header files shown in [Table 45-1](ch45.html#summary_of_programming_interfaces_for_sy
    "Table 45-1. Summary of programming interfaces for System V IPC objects"). Some
    older UNIX implementations may also require the inclusion of `<sys/ipc.h>`. (No
    versions of the Single UNIX Specification required these header files.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现要求在包含表 [45-1](ch45.html#summary_of_programming_interfaces_for_sy "Table 45-1. Summary
    of programming interfaces for System V IPC objects") 中显示的头文件之前，先包含 `<sys/types.h>`。一些较旧的
    UNIX 实现可能还要求包含 `<sys/ipc.h>`。（没有版本的单一 UNIX 规范要求这些头文件。）
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On most hardware architectures on which Linux is implemented, a single system
    call (*ipc(2)*) acts as the entry point to the kernel for all System V IPC operations,
    and all of the calls listed in [Table 45-1](ch45.html#summary_of_programming_interfaces_for_sy
    "Table 45-1. Summary of programming interfaces for System V IPC objects") are
    actually implemented as library functions layered on top of this system call.
    (Two exceptions to this arrangement are Alpha and IA-64, where the functions listed
    in the table really are implemented as individual system calls.) This somewhat
    unusual approach is an artifact of the initial implementation of System V IPC
    as a loadable kernel module. Although they are actually library functions on most
    Linux architectures, throughout this chapter, we’ll refer to the functions in
    [Table 45-1](ch45.html#summary_of_programming_interfaces_for_sy "Table 45-1. Summary
    of programming interfaces for System V IPC objects") as system calls. Only implementers
    of C libraries need to use *ipc(2)*; any other use in applications is not portable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实现 Linux 的硬件架构上，一个系统调用（*ipc(2)*) 作为所有系统 V IPC 操作进入内核的入口点，表 [45-1](ch45.html#summary_of_programming_interfaces_for_sy
    "Table 45-1. Summary of programming interfaces for System V IPC objects") 中列出的所有调用，实际上都作为库函数实现，并层叠在此系统调用之上。（Alpha
    和 IA-64 是两个例外，表中的函数实际上是作为单独的系统调用实现的。）这种略显不寻常的方法是系统 V IPC 最初作为可加载内核模块实现时的产物。尽管在大多数
    Linux 架构上它们实际上是库函数，但在本章中，我们将表 [45-1](ch45.html#summary_of_programming_interfaces_for_sy
    "Table 45-1. Summary of programming interfaces for System V IPC objects") 中的函数称为系统调用。只有
    C 库的实现者需要使用 *ipc(2)*；在应用程序中的任何其他用途都不是可移植的。
- en: Table 45-1. Summary of programming interfaces for System V IPC objects
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表 45-1. 系统 V IPC 对象的编程接口总结
- en: '| Interface | Message queues | Semaphores | Shared memory |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 消息队列 | 信号量 | 共享内存 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Header file | `<sys/msg.h>` | `<sys/sem.h>` | `<sys/shm.h>` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 头文件 | `<sys/msg.h>` | `<sys/sem.h>` | `<sys/shm.h>` |'
- en: '| Associated data structure | *msqid_ds* | *semid_ds* | *shmid_ds* |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 关联数据结构 | *msqid_ds* | *semid_ds* | *shmid_ds* |'
- en: '| Create/open object | *msgget()* | *semget()* | *shmget()* + *shmat()* |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 创建/打开对象 | *msgget()* | *semget()* | *shmget()* + *shmat()* |'
- en: '| Close object | (none) | (none) | *shmdt()* |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 关闭对象 | （无） | （无） | *shmdt()* |'
- en: '| Control operations | *msgctl()* | *semctl()* | *shmctl()* |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 控制操作 | *msgctl()* | *semctl()* | *shmctl()* |'
- en: '| Performing IPC | *msgsnd()*—write message *msgrcv()*—read message | *semop()*—test/adjust
    semaphore | access memory in shared region |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 执行 IPC | *msgsnd()*—写消息 *msgrcv()*—读消息 | *semop()*—测试/调整信号量 | 在共享区域访问内存 |'
- en: Creating and opening a System V IPC object
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建和打开一个系统 V IPC 对象
- en: 'Each System V IPC mechanism has an associated *get* system call (*msgget()*,
    *semget()*, or *shmget()*), which is analogous to the *open()* system call used
    for files. Given an integer *key* (analogous to a filename), the *get* call either:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每种系统 V IPC 机制都有一个关联的 *get* 系统调用（*msgget()*、*semget()* 或 *shmget()*），它类似于用于文件的
    *open()* 系统调用。给定一个整数 *key*（类似于文件名），*get* 调用要么：
- en: creates a new IPC object with the given key and returns a unique identifier
    for that object; or
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的键创建一个新的 IPC 对象，并返回该对象的唯一标识符；或者
- en: returns the identifier of an existing IPC object with the given key.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回具有给定键的现有 IPC 对象的标识符。
- en: We’ll (loosely) term the second use *opening* an existing IPC object. In this
    case, all that the *get* call is doing is converting one number (the key) into
    another number (the identifier).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们（大致地）称第二种用法为“打开”现有的 IPC 对象。在这种情况下，*get* 调用所做的只是将一个数字（键）转换为另一个数字（标识符）。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the context of System V IPC, the *object* doesn’t carry any of the connotations
    associated with object-oriented programming. The term merely serves to distinguish
    the System V IPC mechanisms from files. Although there are several analogies between
    files and System V IPC objects, the use of IPC objects differs in several important
    respects from the standard UNIX file I/O model, and this is a source of some complications
    when using the System V IPC mechanisms.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在System V IPC的上下文中，*对象*并不包含面向对象编程中的任何含义。这个术语仅用于区分System V IPC机制与文件。尽管文件和System
    V IPC对象之间有许多相似之处，但IPC对象的使用在几个重要方面与标准的UNIX文件I/O模型不同，这也是使用System V IPC机制时的一些复杂性来源。
- en: An IPC *identifier* is analogous to a file descriptor in that it is used in
    all subsequent system calls to refer to the IPC object. There is, however, an
    important semantic difference. Whereas a file descriptor is a process attribute,
    an IPC identifier is a property of the object itself and is visible system-wide.
    All processes accessing the same object use the same identifier. This means that
    if we know an IPC object already exists, we can skip the *get* call, provided
    we have some other means of knowing the identifier of the object. For example,
    the process that created the object might write the identifier to a file that
    can then be read by other processes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: IPC *标识符* 类似于文件描述符，因为它在所有后续的系统调用中用于引用IPC对象。然而，它们之间有一个重要的语义差异。文件描述符是进程属性，而IPC标识符是对象本身的属性，并且在系统范围内可见。所有访问同一对象的进程都使用相同的标识符。这意味着，如果我们知道某个IPC对象已经存在，并且有其他方式知道该对象的标识符，则可以跳过*get*调用。例如，创建该对象的进程可能会将标识符写入一个文件，其他进程可以读取该文件。
- en: 'The following example shows how to create a System V message queue:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何创建一个System V消息队列：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As with all of the *get* calls, the key is the first argument, and the identifier
    is returned as the function result. We specify the permissions to be placed on
    the new object as part of the final (*flags*) argument to the *get* call, using
    the same bit-mask constants as are used for files ([Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Regular
    Files](ch15.html#permissions_on_regular_files "Permissions on Regular Files")).
    In the above example, permission is granted to just the owner of the object to
    read and write messages on the queue.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有*get*调用一样，关键字是第一个参数，标识符作为函数结果返回。我们在*get*调用的最后一个（*flags*）参数中指定要放置在新对象上的权限，使用与文件相同的位掩码常量（[表
    15-4](ch15.html#constants_for_file_permission_bits "表 15-4. 文件权限位常量")，[常规文件权限](ch15.html#permissions_on_regular_files
    "常规文件权限")）。在上面的例子中，只有对象的所有者被授予读取和写入队列消息的权限。
- en: 'The process umask ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")) is not applied to the permissions
    placed on a newly created IPC object.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的umask（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")）不适用于新创建的IPC对象的权限。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Several UNIX implementations define the following bit-mask constants for IPC
    permissions: `MSG_R, MSG_W, SEM_R, SEM_A, SHM_R`, and `SHM_W`. These correspond
    to owner (user) read and write permissions for each IPC mechanism. To get the
    corresponding group and other permission bit masks, these constants can be right-shifted
    3 and 6 bits. These constants are not specified by SUSv3, which employs the same
    bit masks as are used for files, and are not defined in *glibc* headers.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX实现定义了以下位掩码常量用于IPC权限：`MSG_R, MSG_W, SEM_R, SEM_A, SHM_R` 和 `SHM_W`。这些常量对应于每个IPC机制的所有者（用户）读写权限。要获得相应的组和其他权限位掩码，可以将这些常量右移3位和6位。这些常量并未被SUSv3指定，SUSv3采用与文件相同的位掩码，并且在*glibc*头文件中没有定义。
- en: Each process that wants to access the same IPC object performs a *get* call
    specifying the same key in order to obtain the same identifier for that object.
    We consider how to choose a key for an application in Section 45.2.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个希望访问同一IPC对象的进程都会执行一个*get*调用，指定相同的关键字，以便获得该对象的相同标识符。我们将在第45.2节中讨论如何为应用程序选择关键字。
- en: If no IPC object corresponding to the given key currently exists, and `IPC_CREAT`
    (analogous to the *open()* `O_CREAT` flag) was specified as part of the *flags*
    argument, then the *get* call creates a new IPC object. If no corresponding IPC
    object currently exists, and `IPC_CREAT` was not specified (and the key was not
    specified as `IPC_PRIVATE`, described in [IPC Keys](ch45.html#ipc_keys "IPC Keys")),
    then the *get* call fails with the error `ENOENT`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前没有与给定键对应的IPC对象，并且在*flags*参数中指定了`IPC_CREAT`（类似于*open()*的`O_CREAT`标志），则*get*调用会创建一个新的IPC对象。如果当前没有对应的IPC对象，并且没有指定`IPC_CREAT`（且键未指定为`IPC_PRIVATE`，参见[IPC
    Keys](ch45.html#ipc_keys "IPC Keys")），则*get*调用会因错误`ENOENT`而失败。
- en: A process can guarantee that it is the one creating an IPC object by specifying
    the `IPC_EXCL` flag (analogous to the *open()* `O_EXCL` flag). If `IPC_EXCL` is
    specified and the IPC object corresponding to the given key already exists, then
    the *get* call fails with the error `EEXIST`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过指定`IPC_EXCL`标志（类似于*open()*的`O_EXCL`标志）来保证它是唯一创建IPC对象的进程。如果指定了`IPC_EXCL`，并且与给定键对应的IPC对象已经存在，则*get*调用会因错误`EEXIST`而失败。
- en: IPC object deletion and object persistence
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPC对象删除与对象持久性
- en: 'The ctl system call (*msgctl(), semctl(), shmctl()*) for each System V IPC
    mechanism performs a range of *control operations* for the object. Many of these
    operations are specific to the IPC mechanism, but a few are generic to all IPC
    mechanisms. An example of a generic control operation is `IPC_RMID`, which is
    used to delete an object. For example, we can use the following call to delete
    a shared memory object:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个System V IPC机制的ctl系统调用（*msgctl(), semctl(), shmctl()*）执行一系列对对象的*控制操作*。其中许多操作是特定于IPC机制的，但也有一些是所有IPC机制通用的。例如，`IPC_RMID`就是一种通用的控制操作，用于删除对象。例如，我们可以使用以下调用来删除一个共享内存对象：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For message queues and semaphores, deletion of the IPC object is immediate,
    and any information contained within the object is destroyed, regardless of whether
    any other process is still using the object. (This is one of a number of points
    where the operation of System IPC objects is not analogous to files. In [Creating
    and Removing (Hard) Links: *link*() and *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "Creating and Removing (Hard) Links: link() and unlink()"), we saw that if we
    remove the last link to a file, then the file is actually removed only after all
    open file descriptors referring to it have been closed.)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息队列和信号量，IPC对象的删除是立即生效的，且对象中包含的任何信息都会被销毁，无论是否有其他进程仍在使用该对象。（这是System IPC对象的操作与文件操作不完全相同的一个例子。在[创建和删除（硬）链接：*link*()和*unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "创建和删除（硬）链接：link()和unlink()")中，我们看到如果删除文件的最后一个链接，只有在所有引用该文件的打开文件描述符关闭后，文件才会被真正删除。）
- en: Deletion of shared memory objects occurs differently. Following the *shmctl(id,
    IPC_RMID, NULL)* call, the shared memory segment is removed only after all processes
    using the segment detach it (using *shmdt()*). (This is much closer to the situation
    with file deletion.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存对象的删除方式不同。执行*shmctl(id, IPC_RMID, NULL)*调用后，只有在所有使用该段的进程分离该段（使用*shmdt()*）后，才会删除共享内存段。（这与文件删除的情况更为接近。）
- en: 'System V IPC objects have kernel persistence. Once created, an object continues
    to exist until it is explicitly deleted or the system is shut down. This property
    of System V IPC objects can be advantageous. It is possible for a process to create
    an object, modify its state, and then exit, leaving the object to be accessed
    by some process that is started at a later time. It can also be disadvantageous
    for the following reasons:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: System V IPC对象具有内核持久性。一旦创建，对象会一直存在，直到显式删除或系统关闭。System V IPC对象的这一特性可能带来优势。进程可以创建一个对象，修改其状态，然后退出，允许稍后启动的进程访问该对象。它也可能带来一些不利影响，原因如下：
- en: There are system-imposed limits on the number of IPC objects of each type. If
    we fail to remove unused objects, we may eventually encounter application errors
    as a result of reaching these limits.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种类型的IPC对象都有系统设定的数量限制。如果我们未能移除未使用的对象，最终可能会因为达到这些限制而遇到应用程序错误。
- en: When deleting a message queue or semaphore object, a multiprocess application
    may not be able to easily determine which will be the last process requiring access
    to the object, and thus when the object can be safely deleted. The problem is
    that these objects are *connectionless*—the kernel doesn’t keep a record of which
    processes have the object open. (This disadvantage doesn’t apply for shared memory
    segments, because of their different deletion semantics, described above.)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在删除消息队列或信号量对象时，多进程应用程序可能无法轻松确定哪个进程是最后一个需要访问该对象的进程，从而确定何时可以安全地删除该对象。问题在于这些对象是*无连接的*——内核并不会记录哪些进程打开了该对象。（这个缺点对于共享内存段并不适用，因为它们具有不同的删除语义，如上所述。）
- en: IPC Keys
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPC键值
- en: System V IPC keys are integer values represented using the data type *key_t*.
    The IPC *get* calls translate a key into the corresponding integer IPC identifier.
    These calls guarantee that if we create a new IPC object, then that object will
    have a unique identifier, and that if we specify the key of an existing object,
    then we’ll always obtain the (same) identifier for that object. (Internally, the
    kernel maintains data structures mapping keys to identifiers for each IPC mechanism,
    as described in Section 45.5.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: System V IPC键值是整数类型，用*key_t*数据类型表示。IPC *get*调用将键值转换为相应的整数IPC标识符。这些调用保证，如果我们创建一个新的IPC对象，那么该对象将具有唯一标识符；如果我们指定一个已存在对象的键值，则始终会获得该对象的（相同）标识符。（在内部，内核维护着将键值映射到每个IPC机制标识符的数据结构，如第45.5节所述。）
- en: 'So, how do we provide a unique key—one that guarantees that we won’t accidentally
    obtain the identifier of an existing IPC object used by some other application?
    There are three possibilities:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何提供一个唯一的键值——确保我们不会意外获得某个其他应用程序使用的现有IPC对象的标识符呢？有三种可能性：
- en: Randomly choose some integer key value, which is typically placed in a header
    file included by all programs using the IPC object. The difficulty with this approach
    is that we may accidentally choose a value used by another application.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择一个整数键值，通常将其放在一个所有使用IPC对象的程序都包含的头文件中。这个方法的难点在于，我们可能会不小心选择一个其他应用程序使用的值。
- en: Specify the `IPC_PRIVATE` constant as the *key* value to the *get* call when
    creating the IPC object, which always results in the creation of a new IPC object
    that is guaranteed to have a unique key.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建IPC对象时，将`IPC_PRIVATE`常量作为*key*值传递给*get*调用，这样总是会创建一个具有唯一键值的新IPC对象。
- en: Employ the *ftok()* function to generate a (likely unique) key.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*ftok()*函数生成一个（可能是唯一的）键值。
- en: Using either `IPC_PRIVATE` or *ftok()* is the usual technique.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IPC_PRIVATE`或*ftok()*是常用的技术。
- en: Generating a unique key with `IPC_PRIVATE`
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`IPC_PRIVATE`生成唯一键值
- en: 'When creating a new IPC object, the key may be specified as `IPC_PRIVATE`,
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的IPC对象时，键可以指定为`IPC_PRIVATE`，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, it is not necessary to specify the `IPC_CREAT` or `IPC_EXCL` flags.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，不需要指定`IPC_CREAT`或`IPC_EXCL`标志。
- en: This technique is especially useful in multiprocess applications where the parent
    process creates the IPC object prior to performing a *fork()*, with the result
    that the child inherits the identifier of the IPC object. We can also use this
    technique in client-server applications (i.e., those involving unrelated processes),
    but the clients must have a means of obtaining the identifiers of the IPC objects
    created by the server (and vice versa). For example, after creating an IPC object,
    the server could then write its identifier to a file that can be read by the clients.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术在多进程应用程序中特别有用，其中父进程在执行*fork()*之前创建IPC对象，结果是子进程继承了IPC对象的标识符。我们还可以在客户端-服务器应用程序中使用此技术（即涉及不相关进程的应用程序），但客户端必须有一种方法来获取服务器创建的IPC对象的标识符（反之亦然）。例如，创建IPC对象后，服务器可以将其标识符写入一个文件，供客户端读取。
- en: Generating a unique key with *ftok()*
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用*ftok()*生成唯一的键值。
- en: The *ftok()* (*file to key*) function returns a key value suitable for use in
    a subsequent call to one of the System V IPC *get* system calls.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*ftok()*（*文件到键值*）函数返回一个适用于随后的System V IPC *get*系统调用的键值。'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns integer key on success, or -1 on error
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回整数键值，出错时返回-1。
- en: 'This key value is generated from the supplied *pathname* and *proj* value using
    an implementation-defined algorithm. SUSv3 makes the following requirements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该键值是通过实现定义的算法，从提供的*路径名*和*proj*值生成的。SUSv3提出了以下要求：
- en: Only the least significant 8 bits of *proj* are employed by the algorithm.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有*proj*的最低有效8位会被算法使用。
- en: The application must ensure that the *pathname* refers to an existing file to
    which *stat()* can be applied (otherwise, *ftok()* returns -1).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须确保*pathname*引用的是一个存在的文件，并且*stat()*可以应用于该文件（否则，*ftok()*将返回-1）。
- en: If different pathnames (links) referring to the same file (i.e., i-node) are
    supplied to *ftok()* with the same *proj* value, the same key value must be returned.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不同的路径名（链接）引用同一个文件（即i节点），并且提供给*ftok()*时使用相同的*proj*值，则必须返回相同的键值。
- en: To put things another way, *ftok()* uses the i-node number rather than the name
    of the file to generate the key value. (Because the *ftok()* algorithm depends
    on the i-node number, the file should not be removed and re-created during the
    life of the application, since it is likely that the file will be re-created with
    a different i-node number.) The purpose of the *proj* value is simply to allow
    us to generate multiple keys from the same file, which is useful when an application
    needs to create multiple IPC objects of the same type. Historically, the *proj*
    argument was of type *char*, and it is often specified as such in calls to *ftok()*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*ftok()*使用的是i节点号，而不是文件名来生成键值。（因为*ftok()*算法依赖于i节点号，所以在应用程序的生命周期内，文件不应被删除并重新创建，因为很可能重新创建的文件会有不同的i节点号。）*proj*值的目的是让我们能够从同一个文件生成多个键值，这在应用程序需要创建多个相同类型的IPC对象时非常有用。从历史上看，*proj*参数是*char*类型，并且在调用*ftok()*时，通常指定为这种类型。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 leaves the behavior of *ftok()* unspecified if *proj* is 0\. Under AIX
    5.1, *ftok()* returns -1 if *proj* is specified as 0\. On Linux, this value has
    no special meaning. Nevertheless, portable applications should avoid specifying
    *proj* as 0; this still leaves a choice of 255 other values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*proj*为0，SUSv3未指定*ftok()*的行为。在AIX 5.1中，如果*proj*指定为0，*ftok()*将返回-1。在Linux上，这个值没有特殊含义。尽管如此，可移植的应用程序应该避免将*proj*指定为0；不过仍然可以选择255个其他值。
- en: Normally, the *pathname* given to *ftok()* refers to one of the files or directories
    that forms part of, or is created by, the application, and cooperating processes
    pass the same *pathname* to *ftok()*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，提供给*ftok()*的*pathname*是应用程序创建的文件或目录之一，且合作进程将相同的*pathname*传递给*ftok()*。
- en: On Linux, the key returned by *ftok()* is a 32-bit value, created by taking
    the least significant 8 bits from the *proj* argument, the least significant 8
    bits of the device number (i.e., the minor device number) of the device containing
    the file system in which the file resides, and the least significant 16 bits of
    the i-node number of the file referred to by *pathname*. (The last two pieces
    of information are obtained by calling *stat()* on *pathname*.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，*ftok()*返回的键值是一个32位值，通过取*proj*参数的最低有效8位、包含文件系统的设备的设备号（即设备的次设备号）的最低有效8位，以及*pathname*所指向文件的i节点号的最低有效16位来创建。（后两部分信息是通过对*pathname*调用*stat()*获得的。）
- en: 'The *glibc ftok()* algorithm is similar to that employed on other UNIX implementations,
    and suffers a similar limitation: there is a (very small) possibility that two
    different files could yield the same key value. This can occur because there is
    a chance that the least significant bits of an i-node number could be the same
    for two files on different file systems, coupled with the possibility that two
    different disk devices (on a system with multiple disk controllers) could have
    the same minor device number. However, in practice, the possibility of colliding
    key values for different applications is small enough that the use of *ftok()*
    for key generation is a viable technique.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc ftok()*算法与其他UNIX实现上使用的算法类似，并且存在相似的限制：有（非常小的）可能性导致两个不同的文件生成相同的键值。这是因为有可能两个不同文件的i节点号最低有效位在不同文件系统上相同，再加上在具有多个磁盘控制器的系统上，两个不同的磁盘设备可能具有相同的次设备号。然而，实际上，不同应用程序发生键值冲突的可能性足够小，因此使用*ftok()*生成键值仍然是一种可行的技术。'
- en: 'A typical usage of *ftok()* is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*ftok()*的典型用法如下：'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Associated Data Structure and Object Permissions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关数据结构和对象权限
- en: The kernel maintains an associated data structure for each instance of a System
    V IPC object. The form of this data structure varies according to the IPC mechanism
    (message queue, semaphore, or shared memory) and is defined in the corresponding
    header file for the IPC mechanism (see [Table 45-1](ch45.html#summary_of_programming_interfaces_for_sy
    "Table 45-1. Summary of programming interfaces for System V IPC objects")). We
    discuss mechanism-specific details of each of these data structures in the following
    chapters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内核为每个系统 V IPC 对象实例维护一个相关的数据结构。这个数据结构的形式根据 IPC 机制（消息队列、信号量或共享内存）不同而有所变化，并在相应的
    IPC 机制头文件中定义（见 [表 45-1](ch45.html#summary_of_programming_interfaces_for_sy "表
    45-1. 系统 V IPC 对象的编程接口汇总")）。我们将在后续章节中讨论这些数据结构的机制特定细节。
- en: The associated data structure for an IPC object is initialized when the object
    is created via the appropriate *get* system call. Once the object has been created,
    a program can obtain a copy of this data structure using the appropriate *ctl*
    system call, by specifying an operation type of `IPC_STAT`. Conversely, some parts
    of the data structure can be modified using the `IPC_SET` operation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IPC 对象的相关数据结构在通过适当的 *get* 系统调用创建对象时进行初始化。对象创建后，程序可以通过适当的 *ctl* 系统调用获取该数据结构的副本，并指定
    `IPC_STAT` 操作类型。相反，可以使用 `IPC_SET` 操作修改数据结构的某些部分。
- en: 'As well as data specific to the type of IPC object, the associated data structure
    for all three IPC mechanisms includes a substructure, *ipc_perm*, that holds information
    used to determine permissions granted on the object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特定于 IPC 对象类型的数据外，所有三种 IPC 机制的相关数据结构都包括一个子结构 *ipc_perm*，该子结构包含用于确定对象上授予的权限的信息：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SUSv3 mandates all of the *ipc_perm* fields shown here, except *__key* and *__seq*.
    However, most UNIX implementations provide some version of these fields.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 强制要求所有此处显示的 *ipc_perm* 字段，除了 *__key* 和 *__seq*。然而，大多数 UNIX 实现提供了这些字段的某些版本。
- en: 'The *uid* and *gid* fields specify the ownership of the IPC object. The *cuid*
    and *cgid* fields hold the user and group IDs of the process that created the
    object. Initially, the corresponding user and creator ID fields have the same
    values, which are taken from the effective IDs of the calling processes. The creator
    IDs are immutable, but the owner IDs can be changed via the `IPC_SET` operation.
    The following code demonstrates how to change the uid field for a shared memory
    segment (the associated data structure is of type *shmid_ds*):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*uid* 和 *gid* 字段指定了 IPC 对象的所有权。*cuid* 和 *cgid* 字段包含创建该对象的进程的用户 ID 和组 ID。最初，相关的用户和创建者
    ID 字段具有相同的值，这些值来自调用进程的有效 ID。创建者 ID 是不可变的，但所有者 ID 可以通过 `IPC_SET` 操作进行更改。以下代码演示了如何更改共享内存段的
    uid 字段（相关的数据结构类型为 *shmid_ds*）：'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *mode* field of the *ipc_perm* substructure holds the permissions mask for
    the IPC object. These permissions are initialized using the lower 9 bits of the
    *flags* specified in the *get* system call used to create the object, but can
    be changed subsequently using the `IPC_SET` operation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*ipc_perm* 子结构的 *mode* 字段包含 IPC 对象的权限掩码。这些权限使用 *get* 系统调用中指定的 *flags* 的低 9
    位进行初始化，该调用用于创建对象，但随后可以使用 `IPC_SET` 操作进行更改。'
- en: 'As with files, permissions are broken into three categories—*owner* (also known
    as *user*), *group*, and *other*—and it is possible to specify different permissions
    for each category. There are, however, some notable differences from the scheme
    used for files:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件类似，权限分为三类——*所有者*（也称为 *用户*）、*组* 和 *其他*——并且可以为每一类指定不同的权限。然而，与用于文件的方案相比，有一些显著的差异：
- en: Only read and write permissions are meaningful for IPC objects. (For semaphores,
    write permission is commonly referred to as *alter* permission.) Execute permission
    is meaningless, and is ignored when performing most access checks.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅读和写权限对于 IPC 对象是有意义的。（对于信号量，写权限通常被称为 *alter* 权限。）执行权限是无意义的，在进行大多数访问检查时会被忽略。
- en: Permission checks are made according to a process’s effective user ID, effective
    group IDs, and supplementary group IDs. (This contrasts with file-system permission
    checks on Linux, which are performed using the process’s file-system IDs, as described
    in Section 9.5.)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限检查是根据进程的有效用户 ID、有效组 ID 和附加组 ID 进行的。（这与 Linux 上文件系统权限检查不同，后者是通过进程的文件系统 ID 来执行的，详见第
    9.5 节。）
- en: 'The precise rules governing the permissions a process is granted on an IPC
    object are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 控制进程对 IPC 对象的权限的具体规则如下：
- en: If the process is privileged (`CAP_IPC_OWNER`), then all permissions are granted
    on the IPC object.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程具有特权（`CAP_IPC_OWNER`），则所有权限都会授予该 IPC 对象。
- en: If the effective user ID of the process matches either the owner or the creator
    user ID of the IPC object, then the process is granted the permissions defined
    for the *owner* (*user*) of the object.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的有效用户 ID 与 IPC 对象的所有者或创建者用户 ID 匹配，则该进程将被授予为该对象的 *owner* (*user*) 定义的权限。
- en: If the effective group ID or any of the supplementary group IDs of the process
    match either the owner group ID or the creator group ID of the IPC object, then
    the process is granted the *group* permissions defined for the object.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程的有效组 ID 或任何附加组 ID 与 IPC 对象的所有者组 ID 或创建者组 ID 匹配，则该进程将被授予为该对象定义的 *group* 权限。
- en: Otherwise, the process is granted the permissions defined for *other*.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，进程将获得为 *other* 定义的权限。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the kernel code, the above tests are constructed so that the test to see
    whether a process is privileged is performed only if the process is not granted
    the permissions it needs via one of the other tests. This is done to avoid unnecessarily
    setting the `ASU` process accounting flag, which indicates that the process made
    use of superuser privileges ([Process Accounting](ch28.html#process_accounting
    "Process Accounting")).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核代码中，上述测试构建方式是，当进程没有通过其他测试获得所需的权限时，才会执行测试以判断进程是否具有特权。这样做是为了避免不必要地设置 `ASU`
    进程会计标志，表示进程使用了超级用户权限（[进程会计](ch28.html#process_accounting "Process Accounting")）。
- en: Note that neither the use of the `IPC_PRIVATE` key value nor the presence of
    `IPC_EXCL` flag has any bearing on which processes may access an IPC object; such
    access is determined solely by the ownership and permissions of the object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IPC_PRIVATE` 键值的使用或 `IPC_EXCL` 标志的存在与哪些进程可以访问 IPC 对象无关；此类访问完全由对象的所有权和权限决定。
- en: How read and write permissions are interpreted for an object, and whether they
    are required, depend on the type of object and on the operation being performed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入权限如何被解释以及是否需要，取决于对象的类型和正在执行的操作。
- en: 'When a *get* call is performed to obtain the identifier of an existing IPC
    object, an initial permission check is made to ascertain whether the permissions
    specified in the *flags* argument are compatible with those on the existing object.
    If not, then the *get* call fails with the error `EACCES`. (Except as otherwise
    noted, this error code is also returned when permissions are denied in each of
    the cases listed below.) To illustrate, consider the example of two different
    users in the same group, with one user creating a message queue using the following
    call:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 *get* 调用以获取现有 IPC 对象的标识符时，会进行初始权限检查，以确定 *flags* 参数中指定的权限是否与现有对象上的权限兼容。如果不兼容，则
    *get* 调用失败，并返回错误 `EACCES`。（除非另有说明，否则在以下列出的每种情况下权限被拒绝时，也会返回此错误代码。）例如，考虑两个在同一组中的不同用户，其中一个用户使用以下调用创建一个消息队列：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An attempt by the second user to obtain an identifier for this message queue
    using the following call would fail, since the user is not permitted write access
    to the message queue:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用户尝试使用以下调用获取该消息队列的标识符时会失败，因为该用户没有被授权写访问该消息队列：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second user could bypass this check by specifying 0 for the second argument
    of the *msgget()* call, in which case an error would occur only when the program
    attempted an operation requiring write permission on the IPC object (e.g., writing
    a message with *msgsnd()*).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用户可以通过为 *msgget()* 调用的第二个参数指定 0 来绕过此检查，在这种情况下，只有在程序尝试执行需要写权限的操作时（例如，使用 *msgsnd()*
    写入消息）才会发生错误。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *get* call represents the one case where execute permission is not ignored.
    Even though it has no meaning for IPC objects, if execute permission is requested
    in a *get* call for an existing object, then a check is made to see if that permission
    is granted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*get* 调用表示执行权限未被忽略的情况。尽管对于 IPC 对象没有实际意义，但如果在对现有对象的 *get* 调用中请求执行权限，则会检查是否授予该权限。'
- en: 'The permissions required for other common operations are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见操作所需的权限如下：
- en: To retrieve information from the object (e.g., to read a message from a message
    queue, obtain the value of a semaphore, or attach a shared memory segment for
    read access) requires read permission.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从对象中检索信息（例如，从消息队列中读取消息、获取信号量的值或附加共享内存段以进行读访问）需要读取权限。
- en: To update information within the object (e.g., to write a message to a message
    queue, change the value of a semaphore, or attach a shared memory segment for
    write access) requires write permission.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更新对象中的信息（例如，向消息队列写入消息、更改信号量的值，或附加共享内存段进行写访问）需要写入权限。
- en: To obtain a copy of the associated data structure for an IPC object (the `IPC_STAT`
    *ctl* operation) requires read permission.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取与IPC对象关联的数据结构副本（`IPC_STAT` *ctl* 操作）需要读取权限。
- en: To remove an IPC object (the `IPC_RMID` *ctl* operation) or change its associated
    data structure (the `IPC_SET` *ctl* operation) requires neither read nor write
    permission. Rather, the calling process must either be privileged (`CAP_SYS_ADMIN`)
    or have an effective user ID matching either the owner user ID or the creator
    user ID of the object (otherwise, the error `EPERM` results).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除IPC对象（`IPC_RMID` *ctl* 操作）或更改其关联的数据结构（`IPC_SET` *ctl* 操作）既不需要读取权限也不需要写入权限。相反，调用进程必须具有特权（`CAP_SYS_ADMIN`），或者其有效用户ID必须与对象的拥有者用户ID或创建者用户ID匹配（否则将返回错误`EPERM`）。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to set the permissions on an IPC object so that the owner or
    creator can no longer use `IPC_STAT` to obtain the associated data structure containing
    the object permissions (which means that the object won’t be displayed by the
    *ipcs(1)* command described in [The *ipcs* and *ipcrm* Commands](ch45.html#the_ipcs_and_ipcrm_commands
    "The ipcs and ipcrm Commands")), although `IPC_SET` can still be used to change
    them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置IPC对象的权限，使得拥有者或创建者无法再使用`IPC_STAT`获取包含对象权限的关联数据结构（这意味着该对象不会被`*ipcs(1)*`命令显示，详见[《*ipcs*和*ipcrm*命令》](ch45.html#the_ipcs_and_ipcrm_commands
    "The ipcs and ipcrm Commands")），尽管`IPC_SET`仍然可以用来更改它们。
- en: Various other mechanism-specific operations require read or write permission,
    or the `CAP_IPC_OWNER` capability. We note the required permissions in the following
    chapters as the operations are described.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其他各种特定机制的操作可能需要读取或写入权限，或`CAP_IPC_OWNER`能力。我们将在接下来的章节中根据操作的描述注明所需的权限。
- en: IPC Identifiers and Client-Server Applications
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPC标识符与客户端-服务器应用
- en: In client-server applications, the server typically creates the System V IPC
    objects, while the client simply accesses them. In other words, the server performs
    an IPC *get* call specifying the flag `IPC_CREAT`, while the client omits this
    flag in its *get* call.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器应用中，服务器通常创建System V IPC对象，而客户端则仅访问这些对象。换句话说，服务器执行IPC *get*调用，指定标志`IPC_CREAT`，而客户端在其*get*调用中省略此标志。
- en: Suppose a client engages in an extended dialogue with a server, with multiple
    IPC operations being performed by each process (e.g., multiple messages exchanged,
    a sequence of semaphore operations, or multiple updates to shared memory). What
    happens if the server process crashes or is deliberately halted and then restarted?
    At this point, it would make no sense to blindly reuse the existing IPC object
    created by the previous server process, since the new server process has no knowledge
    of the historical information associated with the current state of the IPC object.
    (For example, there may be a secondary request within a message queue that was
    sent by a client in response to an earlier message from the old server process.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设客户端与服务器进行长时间的对话，每个进程执行多个IPC操作（例如，交换多条消息、一系列信号量操作，或者多次更新共享内存）。如果服务器进程崩溃或被故意停止然后重启，会发生什么？在这种情况下，盲目地重用由先前的服务器进程创建的现有IPC对象是没有意义的，因为新的服务器进程并不了解与当前IPC对象状态相关的历史信息。（例如，可能存在一个由客户端发送的次级请求，它是对旧服务器进程之前发送的消息的回应。）
- en: In such a scenario, the only option for the server may be to abandon all existing
    clients, delete the IPC objects created by the previous server process, and create
    new instances of the IPC objects. A newly started server handles the possibility
    that a previous instance of the server terminated prematurely by first trying
    to create an IPC object by specifying both the `IPC_CREAT` and the `IPC_EXCL`
    flags within the *get* call. If the *get* call fails because an object with the
    specified key already exists, then the server assumes the object was created by
    an old server process; it therefore uses the `IPC_RMID` *ctl* operation to delete
    the object, and once more performs a get call to create the object. (This may
    be combined with other steps to ensure that another server process is not currently
    running, such as those described in Section 55.6.) For a message queue, these
    steps might appear as shown in [Example 45-1](ch45.html#cleanup_of_ipc_objects_within_a_server
    "Example 45-1. Cleanup of IPC objects within a server").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器可能唯一的选择是放弃所有现有客户端，删除由之前的服务器进程创建的IPC对象，并创建新的IPC对象实例。新启动的服务器通过首先尝试在*get*调用中同时指定`IPC_CREAT`和`IPC_EXCL`标志来处理服务器实例提前终止的可能性。如果*get*调用失败，因为具有指定键的对象已经存在，则服务器假设该对象是由旧服务器进程创建的；因此，它使用`IPC_RMID`
    *ctl*操作删除该对象，并再次执行get调用来创建该对象。（这可能与其他步骤结合使用，以确保没有其他服务器进程当前在运行，具体步骤可参见第55.6节。）对于消息队列，这些步骤可能如[示例
    45-1](ch45.html#cleanup_of_ipc_objects_within_a_server "示例 45-1. 清理服务器中的IPC对象")所示。
- en: Example 45-1. Cleanup of IPC objects within a server
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 45-1. 清理服务器中的IPC对象
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even if a restarted server re-created the IPC objects, there still would be
    a potential problem if supplying the same key to the *get* call always generated
    the same identifier whenever a new IPC object was created. Consider the solution
    just outlined from the point of view of the client. If the IPC objects re-created
    by the server use the same identifiers, then the client would have no way of becoming
    aware that the server has been restarted and that the IPC objects don’t contain
    the expected historical information.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使重启后的服务器重新创建了IPC对象，如果每次创建新的IPC对象时总是生成相同的标识符，问题依然存在。请从客户端的角度考虑刚刚概述的解决方案。如果服务器重新创建的IPC对象使用相同的标识符，那么客户端将无法意识到服务器已经重启，并且这些IPC对象不包含预期的历史信息。
- en: To solve this problem, the kernel employs an algorithm (described in the next
    section) that normally ensures that when a new IPC object is created, the object’s
    identifier will be different, even when the same key is supplied. Consequently,
    any clients of the old server process that attempt to use the old identifier will
    receive an error from the relevant IPC system call.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，内核使用一种算法（将在下一节中描述），通常确保当创建新IPC对象时，即使提供相同的键，对象的标识符也会有所不同。因此，任何尝试使用旧标识符的旧服务器进程的客户端都会收到相关IPC系统调用的错误。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Solutions such as that shown in [Example 45-1](ch45.html#cleanup_of_ipc_objects_within_a_server
    "Example 45-1. Cleanup of IPC objects within a server") don’t completely solve
    the problem of identifying a server restart when using System V shared memory,
    since a shared memory object is deleted only when all processes have detached
    it from their virtual address space. However, shared memory objects are typically
    used in conjunction with System V semaphores, which *are* immediately deleted
    in response to an `IPC_RMID` operation. This means that a client process will
    become aware of a server restart when it tries to access the deleted semaphore
    object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 45-1](ch45.html#cleanup_of_ipc_objects_within_a_server "示例 45-1. 清理服务器中的IPC对象")所示的解决方案，并不能完全解决在使用System
    V共享内存时识别服务器重启的问题，因为只有当所有进程都将共享内存对象从其虚拟地址空间中分离时，才会删除共享内存对象。然而，共享内存对象通常与System V信号量一起使用，而信号量*会*在执行`IPC_RMID`操作时立即被删除。这意味着，当客户端进程尝试访问已删除的信号量对象时，它将意识到服务器已经重启。
- en: Algorithm Employed by System V IPC *get* Calls
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: System V IPC *get*调用使用的算法
- en: '[Figure 45-1](ch45.html#kernel_data_structures_used_to_represent "Figure 45-1. Kernel
    data structures used to represent System V IPC (semaphore) objects") shows some
    of the structures used internally by the kernel to represent information about
    System V IPC objects (in this case semaphores, but the details are similar for
    other IPC mechanisms), including the fields used to calculate IPC keys. For each
    IPC mechanism (shared memory, message queue, or semaphore), the kernel maintains
    an associated *ipc_ids* structure that records various global information about
    all instances of that IPC mechanism. This information includes a dynamically sized
    array of pointers, *entries*, to the associated data structure for each object
    instance (*semid_ds* structures in the case of semaphores). The current size of
    the *entries* array is recorded in the *size* field, with the *max_id* field holding
    the index of the highest currently in-use element.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[图45-1](ch45.html#kernel_data_structures_used_to_represent "图45-1. 用于表示System
    V IPC（信号量）对象的内核数据结构")展示了内核用于表示System V IPC对象信息（此例为信号量，但其他IPC机制的细节类似）的一些数据结构，包括用于计算IPC键的字段。对于每种IPC机制（共享内存、消息队列或信号量），内核维护一个相关的*ipc_ids*结构，记录关于该IPC机制所有实例的各种全局信息。该信息包括一个动态大小的指针数组*entries*，指向每个对象实例的相关数据结构（在信号量的情况下是*semid_ds*结构）。*entries*数组的当前大小记录在*size*字段中，而*max_id*字段则保存当前正在使用的最大元素索引。'
- en: '![Kernel data structures used to represent System V IPC (semaphore) objects](figs/web/45-1_SVIPC-data-structures.png.jpg)Figure 45-1. Kernel
    data structures used to represent System V IPC (semaphore) objects'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![用于表示System V IPC（信号量）对象的内核数据结构](figs/web/45-1_SVIPC-data-structures.png.jpg)图45-1.
    用于表示System V IPC（信号量）对象的内核数据结构'
- en: 'When an IPC *get* call is made, the algorithm used on Linux (other systems
    use similar algorithms) is approximately as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行IPC的*get*调用时，Linux使用的算法大致如下（其他系统使用类似的算法）：
- en: The list of associated data structures (pointed to by elements of the *entries*
    array) is searched for one whose *key* field matches that specified in the *get*
    call.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将搜索与*entries*数组元素指向的相关数据结构列表，以查找其*key*字段与*get*调用中指定的匹配项。
- en: If no match is found, and `IPC_CREAT` was not specified, then the error `ENOENT`
    is returned.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未找到匹配项，并且未指定`IPC_CREAT`，则返回错误`ENOENT`。
- en: If a match is found, but both `IPC_CREAT` and `IPC_EXCL` were specified, then
    the error `EEXIST` is returned.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，但同时指定了`IPC_CREAT`和`IPC_EXCL`，则返回错误`EEXIST`。
- en: Otherwise, if a match is found, then the following step is skipped.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果找到匹配项，则跳过以下步骤。
- en: 'If no match was found, and `IPC_CREAT` was specified, then a new mechanism-specific
    associated data structure (*semid_ds* in [Figure 45-1](ch45.html#kernel_data_structures_used_to_represent
    "Figure 45-1. Kernel data structures used to represent System V IPC (semaphore)
    objects")) is allocated and initialized. This also involves updating various fields
    of the *ipc_ids* structure, and may involve resizing the *entries* array. A pointer
    to the new structure is placed in the first free element of *entries*. Two substeps
    are included as part of this initialization:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未找到匹配项，并且指定了`IPC_CREAT`，则分配并初始化一个新的机制特定的相关数据结构（在[图45-1](ch45.html#kernel_data_structures_used_to_represent
    "图45-1. 用于表示System V IPC（信号量）对象的内核数据结构")中为*semid_ds*）。这还涉及更新*ipc_ids*结构的各种字段，并可能会调整*entries*数组的大小。一个指向新结构的指针将放置在*entries*的第一个空闲元素中。此初始化过程包括以下两个子步骤：
- en: The *key* value supplied in the *get* call is copied into the *xxx_perm.__key*
    field of the newly allocated structure.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*get*调用中提供的*key*值被复制到新分配结构的*xxx_perm.__key*字段中。
- en: The current value of the *seq* field of the *ipc_ids* structure is copied into
    the *xxx_perm.__seq* field of the associated data structure, and the *seq* field
    is incremented by one.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ipc_ids*结构的*seq*字段的当前值被复制到相关数据结构的*xxx_perm.__seq*字段中，并且*seq*字段递增1。'
- en: 'The identifier for the IPC object is calculated using the following formula:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下公式计算IPC对象的标识符：
- en: '[PRE10]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the formula used to calculate the IPC identifier, *index* is the index of
    this object instance within the *entries* array, and `SEQ_MULTIPLIER` is a constant
    defined with the value 32,768 (`IPCMNI` in the kernel source file `include/linux/ipc.h`).
    For example, in [Figure 45-1](ch45.html#kernel_data_structures_used_to_represent
    "Figure 45-1. Kernel data structures used to represent System V IPC (semaphore)
    objects"), the identifier generated for the semaphore with the *key* value `0x4b079002`
    would be (2 + 5 * 32,768) = 163,842.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算IPC标识符的公式中，*index*是该对象实例在*entries*数组中的索引，而`SEQ_MULTIPLIER`是一个常量，其值为32,768（在内核源文件`include/linux/ipc.h`中的`IPCMNI`）。例如，在[图45-1](ch45.html#kernel_data_structures_used_to_represent
    "图45-1. 表示System V IPC（信号量）对象的内核数据结构")中，为具有*key*值`0x4b079002`的信号量生成的标识符将是(2 +
    5 * 32,768) = 163,842。
- en: 'Note the following points about the algorithm employed by the *get* calls:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意关于*get*调用所采用的算法的以下几点：
- en: Even if a new IPC object is created with the same key, it will almost certainly
    have a different identifier, since the identifier is calculated based on the *seq*
    value saved in the associated data structure, and this value is incremented by
    one during the creation of each object of this type.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使使用相同的键值创建一个新的IPC对象，它几乎肯定会有一个不同的标识符，因为该标识符是基于关联数据结构中保存的*seq*值计算的，并且该值在每个此类对象创建时都会增加1。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The algorithm employed within the kernel wraps the *seq* value back to 0 when
    it reaches the value `(INT_MAX / IPCMNI)`—that is, 2,147,483,647 / 32,768 = 65,535\.
    Thus, a new IPC object could have the same identifier as a previous object if
    65,535 objects are created in the interim and the new object reuses the same element
    in the *entries* array as the previous object (i.e., this element must also have
    been freed in the interim). However, the chances of this occurring are small.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中采用的算法在*seq*值达到`(INT_MAX / IPCMNI)`时会将其重置为0——即2,147,483,647 / 32,768 = 65,535。因此，如果在此期间创建了65,535个对象，并且新对象重新使用与先前对象相同的*entries*数组元素（即该元素也必须在此期间被释放），则一个新的IPC对象可能会与先前的对象具有相同的标识符。但是，这种情况发生的概率较小。
- en: The algorithm generates a distinct set of identifier values for each index of
    the *entries* array.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该算法为*entries*数组的每个索引生成一个不同的标识符值。
- en: Since the constant `IPCMNI` defines an upper limit on the number of System V
    objects of each type, the algorithm guarantees that each existing IPC object has
    a unique identifier.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于常量`IPCMNI`定义了每种类型的System V对象的最大数量，因此该算法保证每个现有IPC对象都有一个唯一的标识符。
- en: 'Given an identifier value, the corresponding index into the *entries* array
    can be quickly calculated using this equation:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个标识符值，可以使用以下公式快速计算对应的*entries*数组索引：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Being able to rapidly perform this calculation is necessary for the efficient
    operation of those IPC system calls that are supplied with the identifier of an
    IPC object (i.e., those calls in [Table 45-1](ch45.html#summary_of_programming_interfaces_for_sy
    "Table 45-1. Summary of programming interfaces for System V IPC objects") other
    than the *get* calls).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 能够快速执行此计算对于那些需要IPC对象标识符的IPC系统调用的高效运行是必要的（即，[表45-1](ch45.html#summary_of_programming_interfaces_for_sy
    "表45-1. 系统V IPC对象的编程接口概览")中列出的除了*get*调用之外的那些调用）。
- en: In passing, it is worth noting that two different errors can result if a process
    makes an IPC system call (e.g., *msgctl()*, *semop()*, or *shmat()*) that specifies
    an identifier that doesn’t correspond to an existing object. If the corresponding
    index of *entries* is empty, the error `EINVAL` results. If the index points to
    an associated data structure, but the sequence number stored in that structure
    doesn’t yield the same identifier value, then it is assumed that an old object
    pointed to by this array index has been deleted and the index reused. This scenario
    is diagnosed with the error `EIDRM`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果一个进程执行IPC系统调用（例如，*msgctl()*, *semop()*, 或 *shmat()*），并指定一个与现有对象不对应的标识符，则可能会导致两种不同的错误。如果*entries*的对应索引为空，则会产生错误`EINVAL`。如果该索引指向一个关联的数据结构，但该结构中存储的序列号与标识符值不匹配，则假定该数组索引指向的旧对象已经被删除，并且该索引已被重新使用。此情况会通过错误`EIDRM`诊断出来。
- en: The *ipcs* and *ipcrm* Commands
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*ipcs*和*ipcrm*命令'
- en: 'The *ipcs* and *ipcrm* commands are the System V IPC analogs of the *ls* and
    *rm* file commands. Using *ipcs*, we can obtain information about IPC objects
    on the system. By default, *ipcs* displays all objects, as in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*ipcs*和*ipcrm*命令是System V IPC的*ls*和*rm*文件命令的类比。使用*ipcs*，我们可以获取有关系统中IPC对象的信息。默认情况下，*ipcs*显示所有对象，如下例所示：'
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On Linux, *ipcs(1)* displays information only about IPC objects for which we
    have read permission, regardless of whether we own the objects. On some UNIX implementations,
    *ipcs* shows the same behavior as on Linux. However, on other implementations,
    *ipcs* displays all objects regardless of whether read permission is granted to
    the user.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，*ipcs(1)*仅显示我们具有读取权限的IPC对象的信息，而不管我们是否拥有这些对象。在一些UNIX实现中，*ipcs*表现得与Linux相同。然而，在其他实现中，*ipcs*会显示所有对象，无论是否授予用户读取权限。
- en: 'By default, for each object, *ipcs* displays the key, the identifier, the owner,
    and the permissions (expressed as an octal number), followed by information specific
    to the object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对于每个对象，*ipcs*显示键、标识符、所有者和权限（以八进制数字表示），后跟与该对象相关的信息：
- en: For shared memory, *ipcs* displays the size of the shared memory region, the
    number of processes that currently have the shared memory region attached to their
    virtual address space, and status flags. The status flags indicate whether the
    region has been locked into RAM to prevent swapping ([Shared Memory Control Operations](ch48.html#shared_memory_control_operations
    "Shared Memory Control Operations")) and whether the region has been marked to
    be destroyed when all processes have detached it.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于共享内存，*ipcs*显示共享内存区域的大小、当前附加到其虚拟地址空间的进程数，以及状态标志。状态标志指示该区域是否已被锁定到RAM中以防止交换（[共享内存控制操作](ch48.html#shared_memory_control_operations
    "共享内存控制操作")），以及该区域是否已标记为在所有进程分离时销毁。
- en: For semaphores, *ipcs* displays the size of the semaphore set.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于信号量，*ipcs*显示信号量集的大小。
- en: For message queues, *ipcs* displays the total number of bytes of data and the
    number of messages in the queue.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于消息队列，*ipcs*显示队列中数据的总字节数和消息的数量。
- en: The *ipcs(1)* manual page documents various options for displaying other information
    about IPC objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*ipcs(1)*手册页记录了显示关于IPC对象的其他信息的各种选项。'
- en: 'The *ipcrm* command deletes an IPC object. The general form of this command
    is one of the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*ipcrm*命令用于删除IPC对象。此命令的一般形式如下：'
- en: '[PRE13]*`X key`*``'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]*`X key`*``'
- en: $ `ipcrm -[PRE14]
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: $ `ipcrm -[PRE14]`
- en: 'In the above, we either specify *key* as an IPC object key or *id* as an IPC
    object identifier, and the letter *x* is replaced by an uppercase or lowercase
    *q* (for message queues), *s* (for semaphores), or *m* (for shared memory). Thus,
    we could use the following command to delete the semaphore set with the identifier
    65538:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的内容中，我们可以指定*key*作为IPC对象的键，或者*id*作为IPC对象的标识符，字母*x*会被大写或小写的*q*（表示消息队列）、*s*（表示信号量）或*m*（表示共享内存）替换。因此，我们可以使用以下命令删除标识符为65538的信号量集：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Obtaining a List of All IPC Objects
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取所有IPC对象的列表
- en: 'Linux provides two nonstandard methods of obtaining a list of all IPC objects
    on the system:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了两种非标准的方法来获取系统上所有IPC对象的列表：
- en: files within the `/proc/sysvipc` directory that list all IPC objects; and
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/sysvipc`目录中的文件列出了所有IPC对象；以及'
- en: the use of Linux-specific *ctl* calls.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Linux特有的*ctl*调用。
- en: We describe the files in `/proc/sysvipc` directory here, and defer discussion
    of the *ctl* calls until [Displaying All Message Queues on the System](ch46.html#displaying_all_message_queues_on_the_sys
    "Displaying All Message Queues on the System"), where we provide an example program
    that lists all System V message queues on the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述了`/proc/sysvipc`目录中的文件，并将*ctl*调用的讨论推迟到[显示系统中的所有消息队列](ch46.html#displaying_all_message_queues_on_the_sys
    "显示所有消息队列"), 在那里我们提供了一个示例程序，列出了系统上的所有System V消息队列。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some other UNIX implementations have their own nonstandard methods of obtaining
    a list of all IPC identifiers; for example, Solaris provides the *msgids()*, *semids()*,
    and *shmids()* system calls for this purpose.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他UNIX实现有自己非标准的方法来获取所有IPC标识符的列表；例如，Solaris提供了*msgids()*、*semids()*和*shmids()*系统调用用于此目的。
- en: 'Three read-only files in the `/proc/sysvipc` directory provide the same information
    as can be obtained via *ipcs*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/sysvipc`目录中的三个只读文件提供了与通过*ipcs*获得的信息相同的信息：'
- en: '`/proc/sysvipc/msg` lists all messages queues and their attributes.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/sysvipc/msg`列出了所有消息队列及其属性。'
- en: '`/proc/sysvipc/sem` lists all semaphore sets and their attributes.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/sysvipc/sem` 列出了所有信号量集及其属性。'
- en: '`/proc/sysvipc/shm` lists all shared memory segments and their attributes.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/sysvipc/shm` 列出了所有共享内存段及其属性。'
- en: Unlike the *ipcs* command, these files always show all objects of the corresponding
    type, regardless of whether read permission is available on the objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *ipcs* 命令不同，这些文件始终会显示所有相应类型的对象，无论是否可以读取这些对象的权限。
- en: 'An example of the contents of `/proc/sysvipc/sem` is the following (with some
    white space removed to fit this example on the page):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/sysvipc/sem` 文件的一个示例如下（为了适应页面，去掉了一些空白字符）：'
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The three `/proc/sysvipc` files provide a (nonportable) method for programs
    and scripts to walk through a list of all of the existing IPC objects of a given
    type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 三个 `/proc/sysvipc` 文件提供了一种（不可移植的）方法，供程序和脚本遍历给定类型的所有现有 IPC 对象的列表。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The best that we can achieve by way of a portable approach to obtaining a list
    of all IPC objects of a given type is to parse the output of *ipcs(1)*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做到的最具移植性的方法是解析 *ipcs(1)* 命令的输出，从而获得所有给定类型 IPC 对象的列表。
- en: IPC Limits
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPC 限制
- en: Since System V IPC objects consume system resources, the kernel places various
    limits on each class of IPC object in order to prevent resources from being exhausted.
    The methods for placing limits on System V IPC objects are not specified by SUSv3,
    but most UNIX implementations (including Linux) follow a similar framework for
    the types of limits that may be placed. As we cover each System V IPC mechanism
    in the following chapters, we discuss the associated limits and note differences
    from other UNIX implementations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 System V IPC 对象会消耗系统资源，内核对每类 IPC 对象设置了各种限制，以防止资源耗尽。System V IPC 对象的限制方法并未由
    SUSv3 规定，但大多数 UNIX 实现（包括 Linux）遵循类似的框架来设置可施加的限制类型。我们将在接下来的章节中讨论每种 System V IPC
    机制，并说明相关限制及与其他 UNIX 实现的差异。
- en: Although the types of limits that can be placed on each class of IPC object
    are generally similar across various UNIX implementations, the methods of viewing
    and changing these limits are not. The methods described in the following chapters
    are Linux-specific (they generally involve the use of files in the `/proc/sys/kernel`
    directory); things are done differently on other implementations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在各种 UNIX 实现中，可以对每类 IPC 对象设置的限制类型通常是相似的，但查看和修改这些限制的方法却并不相同。以下章节中描述的方法是 Linux
    特有的（它们通常涉及使用 `/proc/sys/kernel` 目录中的文件）；在其他实现中，操作方式有所不同。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, the *ipcs -l* command can be used to list the limits on each of the
    IPC mechanisms. Programs can employ the Linux-specific `IPC_INFO` *ctl* operation
    to retrieve the same information.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，可以使用 *ipcs -l* 命令列出每个 IPC 机制的限制。程序还可以使用 Linux 特有的 `IPC_INFO` *ctl*
    操作来检索相同的信息。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: System V IPC is the name given to three IPC mechanisms that first appeared widely
    in System V, and have subsequently been ported to most UNIX implementations and
    incorporated into various standards. The three IPC mechanisms are message queues,
    which allow processes to exchange messages; semaphores, which allow processes
    to synchronize access to shared resources; and shared memory, which allows two
    or more processes to share the same pages of memory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: System V IPC 是指最初广泛出现在 System V 中的三种 IPC 机制，随后被移植到大多数 UNIX 实现中，并被纳入各种标准。这三种
    IPC 机制分别是：消息队列，允许进程交换消息；信号量，允许进程同步对共享资源的访问；共享内存，允许两个或多个进程共享相同的内存页。
- en: The three IPC mechanisms have many similarities in their APIs and semantics.
    For each IPC mechanism, a *get* system call creates or opens an object. Given
    an integer *key*, the *get* calls return an integer *identifier* used to refer
    to the object in subsequent system calls. Each IPC mechanism also has a corresponding
    a *ctl* call that is used to delete an object and to retrieve and modify various
    attributes (e.g., ownership and permissions) in an object’s associated data structure.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种 IPC 机制在其 API 和语义上有许多相似之处。对于每个 IPC 机制，*get* 系统调用用于创建或打开一个对象。给定一个整数 *key*，*get*
    调用返回一个整数 *identifier*，用于在随后的系统调用中引用该对象。每个 IPC 机制还具有相应的 *ctl* 调用，用于删除对象，并在对象的相关数据结构中检索和修改各种属性（例如所有权和权限）。
- en: The algorithm used to generate identifiers for new IPC objects is designed to
    minimize the possibility of the same identifier being (immediately) reused if
    an object is deleted, even if the same key is used to create a new object. This
    enables client-server applications to function correctly—a restarted server process
    is able to detect and remove IPC objects created by its predecessor, and this
    action invalidates the identifiers held by any clients of the previous server
    process.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 用于为新IPC对象生成标识符的算法旨在最小化如果对象被删除后，使用相同的标识符（立即）被重用的可能性，即使使用相同的键来创建新对象。这使得客户端-服务器应用程序能够正常运行——重启的服务器进程能够检测并删除其前任创建的IPC对象，而这个操作会使之前服务器进程的任何客户端所持有的标识符失效。
- en: The *ipcs* command lists the System V IPC objects that currently exist on the
    system. The *ipcrm* command is used to remove System IPC objects.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*ipcs*命令列出了当前系统上存在的System V IPC对象。*ipcrm*命令用于删除System V IPC对象。'
- en: On Linux, files in the `/proc/sysvipc` directory can be used to obtain information
    about all of the System V IPC objects on the system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，`/proc/sysvipc`目录中的文件可以用来获取系统上所有System V IPC对象的信息。
- en: Each IPC mechanism has an associated set of limits that can be used to avoid
    exhaustion of system resources by preventing the creation of an arbitrary number
    of IPC objects. Various files under the `/proc/sys/kernel` directory can be used
    to view and modify these limits.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IPC机制都有一组关联的限制，用来防止通过限制创建任意数量的IPC对象来避免系统资源的耗尽。可以通过查看和修改`/proc/sys/kernel`目录下的各种文件来管理这些限制。
- en: Further information
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: Information about the implementation of System V IPC on Linux can be found in
    [Maxwell, 1999] and [Bovet & Cesati, 2005]. [Goodheart & Cox, 1994] describes
    the implementation of System V IPC for System V Release 4.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Linux上System V IPC实现的信息可以在[Maxwell, 1999]和[Bovet & Cesati, 2005]中找到。[Goodheart
    & Cox, 1994]描述了System V Release 4中System V IPC的实现。
- en: Exercises
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program to verify that the algorithm employed by *ftok()* uses the file’s
    i-node number, minor device number, and *proj* value, as described in Section
    45.2. (It is sufficient to print all of these values, as well as the return value
    from *ftok()*, in hexadecimal, and inspect the results for a few examples.)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来验证*ftok()*所采用的算法是否使用了文件的i节点号、次设备号和*proj*值，如第45.2节所述。（只需打印出这些值，以及*ftok()*的返回值，以十六进制显示，并检查几个示例的结果即可。）
- en: Implement *ftok()*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现*ftok()*。
- en: Verify (by experiment) the statements made in [Algorithm Employed by System
    V IPC *get* Calls](ch45.html#algorithm_employed_by_system_v_ipc_get_c "Algorithm
    Employed by System V IPC get Calls") about the algorithm used to generate System
    V IPC identifiers.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实验验证[System V IPC *get*调用所采用的算法](ch45.html#algorithm_employed_by_system_v_ipc_get_c
    "System V IPC get调用所采用的算法")中关于生成System V IPC标识符的算法的说法。
