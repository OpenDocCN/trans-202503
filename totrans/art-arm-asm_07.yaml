- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 5 PROCEDURES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a procedural programming language, the basic unit of code is the procedure.
    A *procedure* is a set of instructions that compute a value or take an action,
    such as printing or reading a character value. This chapter discusses how Gas
    implements procedures, parameters, and local variables. By the end of this chapter,
    you should be well versed in writing your own procedures and functions. You’ll
    also fully understand parameter passing and the ARM application binary interface
    (ABI) calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers several topics, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to assembly language programming style, along with some *aoaa.inc*
    macros to improve the readability of your programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gas procedures/functions and their implementation (including the use of the
    bl, br, and ret instructions), along with more *aoaa.inc* macros to allow the
    better declaration of procedures in your source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activation records, automatic variables, local symbols, register preservation,
    and the ARM stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various ways to pass parameters to a procedure, including pass by value and
    pass by reference, and how to use procedure pointers and procedural parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter also discusses how to return function results to a caller and how
    to call and use recursive functions.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Assembly Language Programming Style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up until this chapter, I’ve not stressed good assembly language programming
    style for two reasons. First, this book assumes you’re already familiar with the
    need for good programming style based on your experience with HLLs. Second, the
    programs quoted up to this point have been relatively trivial, and programming
    style doesn’t matter much with trivial code. However, as you begin to write more
    advanced ARM assembly language programs, style becomes more important.
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably tell by now, ARM assembly language code is nowhere near
    as readable as code written in an HLL such as C/C++, Java, or Swift. Therefore,
    as an assembly language programmer, you must expend extra effort to write assembly
    code that is as readable and maintainable as possible. As I’ve pointed out, the
    GNU assembler was written not as a tool for assembly language programmers but
    as a backend to the GCC compiler to process the compiler’s output. Because of
    this and the fact that Gas attempted to absorb as many features as possible from
    a huge number of assembly languages (for many CPUs, not just the ARM), writing
    high-quality code with Gas is a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can use Gas’s macro processor (and ability to take advantage
    of the CPP) to modify the Gas assembly language somewhat, accessing features that
    can help improve your programming style. The *aoaa.inc* include file contains
    a fair number of predefined macros and symbol definitions to help achieve this
    goal. [Chapter 13](chapter13.xhtml) covers the contents of *aoaa.inc* line by
    line and explains how you can use these macros, and create macros of your own,
    to improve the readability of your ARM assembly language programs.
  prefs: []
  type: TYPE_NORMAL
- en: When you write assembly language source files, feel free to include *aoaa.inc*
    in that code or incorporate any features from that code in your assembly language
    source files. Even if you don’t require the cross-platform portability offered
    by *aoaa.inc*, its macros and other definitions can help you write more readable
    and maintainable code. The *aoaa.inc* header file is open source and covered by
    the Creative Commons 4.0 Attribution license (see section 5.12, “For More Information,”
    on [page 290](chapter5.xhtml#pg_290)).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of using macros to make code more readable, consider the .code
    macro from *aoaa.inc*. It expands into the following two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule, you should always ensure that the .text section is aligned
    on a word boundary (code could get misaligned if you’ve declared some data in
    the previous code section whose length is not a multiple of 4). It’s good programming
    style to always align a .text section; just to be sure an instruction begins at
    a proper address. Rather than clutter up your code with a bunch of extra .align
    directives, I recommend using the .code directive to automatically handle the
    alignment. Having less clutter makes your code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: The *aoaa.inc* header file contains several additional macros I will present
    throughout the rest of this chapter that take the 1960s-style Gas syntax and attempt
    to provide features found in more modern assemblers (such as the Microsoft Macro
    Assembler, or MASM, and the HLA assemblers available for the x86 processor family).
    Using these features (such as formal procedure declarations and local variable
    declarations) can help produce easier-to-read assembly language source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when writing traditional assembly language source code, you can follow
    certain rules to produce more readable code. Throughout this book, I’ve generally
    organized assembly language statements as follows (braces surround optional items
    and don’t appear in the actual source code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule, I try to put all label definitions in column 1 and to line
    up all the instruction mnemonics in column 2\. I try to start the operands in
    column 3\. The exact number of spaces between these columns is not important,
    but be sure that the mnemonics are generally lined up together, in one column,
    and that the operands tend to start in the next column. This is the traditional
    assembly language programming style and the format that most assembly language
    programmers will want to see when reading your code.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For formatting reasons, this book often compresses the amount of space between
    the columns and sometimes varies the position of each column within the same listing.
    This was done to ensure source lines fit on one line within the book. In a normal
    source file, you should try to keep all the columns aligned (two 4-character tab
    positions for column 2, column 3 around character position 16, and so on).*'
  prefs: []
  type: TYPE_NORMAL
- en: In general, don’t try to indent statements as you would blocks in an HLL. Assembly
    language is not a block-structured language and does not lend itself to the same
    indentation techniques that work well for block-structured languages. If you need
    to set apart a sequence of statements, the best approach is to insert two or more
    blank lines before and after that sequence of statements. Comments are also useful
    for differentiating two separate, loosely coupled blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gas usually expects an entire assembly language instruction to reside on a
    single line of source code. In theory, you could use the backslash character immediately
    before a newline character to break a single statement across two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there’s almost never a good argument for doing this. Keep your instructions
    on a single line unless you have a really good reason to split them across multiple
    lines (for example, if the source line becomes inordinately long for some reason,
    which is rare). The label field is an exception to this rule: labels may appear
    on a line by themselves even if they are associated with the next machine instruction
    in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Gas (under Linux) allows putting multiple assembly language instructions on
    the same line, separated by a semicolon. However, putting multiple statements
    on the same source line is an even worse idea in assembly language than it is
    in HLLs—don’t do it. In any case, the macOS assembler does not support this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few assembly language style guidelines out of the way, it’s time to
    consider the main topic of this chapter: procedures (functions) in assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Gas Procedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most procedural programming languages implement procedures by using the call/return
    mechanism. The code calls a procedure, the procedure performs whatever actions
    it was written to do, and then the procedure returns to the caller. The call and
    return operations provide the ARM’s *procedure invocation mechanism*. The calling
    code calls a procedure with the bl instruction, and the procedure returns to the
    caller with the ret instruction. For example, the following ARM instruction calls
    the C stdlib library printf() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, the C stdlib does not supply all the routines you’ll need. Most of the
    time, you’ll have to write your own Gas procedures. A basic Gas procedure declaration
    takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Technically, the procedure does not need to end with a ret instruction; the
    ret could be somewhere in the middle of the procedure, with a b.al instruction
    at the end. However, it’s considered good programming style to use a ret instruction
    (or an equivalent) as the last instruction of a procedure’s body.
  prefs: []
  type: TYPE_NORMAL
- en: Procedure declarations appear in the .text section of your program. In the preceding
    syntax example, procName represents the name of the procedure you wish to define.
    This can be any valid (and unique) Gas identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a concrete example of a Gas procedure declaration. This procedure stores
    0s into the 256 words at which X0 points upon entry into the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve probably noticed, this simple procedure doesn’t bother with the “magic”
    instructions that add and subtract a value to and from the SP register. Those
    instructions are a requirement of the ARM ABI when the procedure will be calling
    other C/C++ code (or other code written in an ARM ABI–compliant language). Because
    this little function doesn’t call any other procedures, it doesn’t bother executing
    such code.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that this code uses the loop index to count down from 1,024 down to
    0 by 4, filling in the 256-word array backward (from end to beginning) rather
    than filling it in from beginning to end. This is a common technique in assembly
    language. Finally, this code decrements X1 by 4 before storing the 0 into memory.
    This is because the loop index (X1) is initialized just beyond the end of the
    array pointed at by X0\. The str instruction does not affect the flags, so the
    bne instruction responds to the flags set by the subs instruction.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the ARM bl instruction to call this procedure. When, during program
    execution, the code falls into the ret instruction, the procedure returns to whoever
    called it and begins executing the first instruction beyond bl. Listing 5-1 provides
    an example of a call to the zeroBytes routine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I won’t bother with a build or run command, as this program doesn’t produce
    any real output beyond saying that it ran and terminated.
  prefs: []
  type: TYPE_NORMAL
- en: The Gas language doesn’t really have a syntactical concept of a program component
    we think of as a procedure (or function). It has labels you can call with the
    bl instruction, along with the ret instruction, which you can use to return from
    a procedure. However, it has no syntactical entity you can use to delineate one
    procedure from another in your assembly language source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, the few procedures in this book have delineated the code in the procedure
    by using a label and a return statement. For example, the following procedure
    begins with zeroBytes and ends with ret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A comment immediately before the procedure might help separate it from previous
    code. However, the person reading the code has to work to differentiate the zeroBytes
    label from the repeatlp label. In fact, there’s no reason you couldn’t use both
    labels as entry points for a procedure (zeroBytes would always zero out 256 words
    starting at the address passed in X0, and repeatlp would zero out the number of
    words specified in X1/4). Of course, a procedure isn’t required to use just a
    single ret instruction (or any at all, since there are other ways to return from
    a procedure). The last instruction of a procedure also doesn’t have to be a ret.
    Therefore, relying on a statement label and a ret instruction to delineate the
    procedure is not always appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though it’s always a good idea to put comments at the beginning and end of
    your Gas procedures to clarify what’s happening, the best way to solve this problem
    would be to use *syntactical sugar*—statements that clarify meaning without generating
    any code—to delineate procedures. Although Gas does not provide such statements,
    you can write your own macros for the same purpose. The *aoaa.inc* include file
    provides a couple of these macros: proc and endp. Here is their syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, procedureName will be the name of the procedure, and you must supply the
    same name in the proc and endp statements. The , public argument is optional,
    as denoted by the meta-symbol braces. If the public argument is present, the proc
    macro will automatically generate a .global directive for the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a very simple example of using the proc and endp macros with the getTitle
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These macros generate the usual statements for the getTitle procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The endp macro doesn’t generate anything in the program. It simply checks the
    identifier passed as an argument to ensure that it matches the procedure’s name
    in the proc macro invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Because the proc and endp statements neatly isolate a procedure’s body from
    other code in the program, this book uses them for procedures from this point
    forward. I suggest you take advantage of these macros to help make your own future
    procedures more readable too.
  prefs: []
  type: TYPE_NORMAL
- en: Procedures and functions in an HLL provide useful features in the form of local
    symbols. The next section covers the limited form of local labels supported by
    Gas.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Gas Local Labels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike HLLs, Gas does not support *lexically scoped symbols*. Labels you define
    in a procedure are not limited in scope to that procedure. Except for one special
    case, symbols you define in a Gas procedure, including those defined with proc/endp,
    are visible throughout the source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Gas does support a limited form of *local labels*, which consist of
    a single numeric digit followed by a colon (0: through 9:). In your code, refer
    to these symbols by using Nb or Nf, where N is the digit (0 through 9). A symbol
    of the form Nb references the previous N: label in the source file (b is for *backward*).
    A symbol of the form Nf references the next N: symbol in the source file (f is
    for *forward*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a Gas local label in the zeroBytes procedure (rewritten
    from the previous section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Local labels are useful when there is no compelling reason to use a more meaningful
    name. Be careful about using these local symbols, though. When used sparingly,
    they help reduce the distraction of meaningless labels in your program, but using
    too many will destroy the readability of your programs (“to which 0 label is this
    code jumping?”).
  prefs: []
  type: TYPE_NORMAL
- en: When you use local labels, your target label should be only a few instructions
    away; if the code jumps any great distance, you run the risk of inserting that
    same local label between the source and targets when enhancing your code later.
    This would produce undesirable consequences, and Gas won’t notify you of the error.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2 bl, ret, and br
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you can declare a procedure, the next problem is how to call (and return
    from) a procedure. As you’ve seen many times throughout this book, you call procedures
    by using bl and return from those procedures by using ret. This section covers
    those instructions (as well as the br instruction) in more detail, including the
    effects of their use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM bl instruction does two things: it copies the (64-bit) address of the
    instruction immediately following the bl to the LR register, and then it transfers
    control to the address of the specified procedure. The value that bl copies to
    LR is known as the *return address*.'
  prefs: []
  type: TYPE_NORMAL
- en: When a procedure wants to return to the caller and continue execution with the
    first statement following the bl instruction, that procedure commonly returns
    to its caller by executing a ret instruction. The ret instruction transfers control
    indirectly to that address held in the LR register (X30).
  prefs: []
  type: TYPE_NORMAL
- en: The ARM ret instruction takes two forms
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: where reg64 is one of the ARM’s thirty-two 64-bit registers. If a 64-bit register
    operand appears, the CPU uses the address held in that register as the return
    address; if no register is present, the default is X30 (LR).
  prefs: []
  type: TYPE_NORMAL
- en: The ret instruction is actually a special case of the br (branch indirect through
    register) instruction. The br syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where reg64 is one of the ARM’s thirty-two 64-bit registers. This instruction
    also transfers control to the address held in the specified register. Whereas
    the ret reg64 instruction provides a hint to the CPU that this is an actual return-from-subroutine,
    the br reg64 instruction offers no such hint. In some circumstances, the ARM can
    execute the code faster if it’s given the hint. [Chapter 7](chapter7.xhtml) covers
    some uses for the br instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the minimal Gas procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you call this procedure with the bl instruction, minimal will simply return
    to the caller. If you fail to put the ret instruction in the procedure, the program
    will not return to the caller upon encountering the endp statement. Instead, the
    program will fall through to whatever code happens to follow the procedure in
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-2 demonstrates this problem. The main program calls noRet, which falls
    straight through to followingProc (printing the followingProc was called message).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is no ret instruction in noRet, so when the main program
    (asmMain) calls noRet, it will fall straight through into followingProc. Here’s
    the build command and sample execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Although this behavior might be desirable in certain rare circumstances, it
    usually represents a defect in most programs. Therefore, always remember to explicitly
    return from the procedure by using the ret instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Saving the State of the Machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listing 5-3 attempts to print 20 lines of 40 spaces and an asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, a subtle bug creates an infinite loop. The main program uses
    the bne printLoop instruction to create a loop that calls Print40Spaces 20 times.
    This function uses W19 to count off the 40 spaces it prints, and then returns
    with W19 containing 0\. The main program prints an asterisk and a newline, decrements
    W19, and then repeats because W19 isn’t 0 (it will always contain –1 at this point).
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the print40Spaces subroutine doesn’t preserve the W19
    register. Preserving a register means you save it upon entry into the subroutine
    and restore it before leaving. Had the print40Spaces subroutine preserved the
    contents of the W19 register, Listing 5-3 would have functioned properly. There
    is no need to build and run this program; it just runs in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code for print40Spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This variant of print40Spaces saves and restores X19 on the stack, along with
    the LR register. Because X19 is a nonvolatile register (in the ARM ABI), it is
    the responsibility of the callee (the procedure) to preserve it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that print40Spaces uses X19 rather than one of the X0 to X15 registers
    specifically because it is nonvolatile. The printf() function does not have to
    preserve X0 to X15 because they are *volatile* registers in the ARM ABI. Any attempt
    to use those registers would have likely failed because printf() doesn’t have
    to preserve their values.
  prefs: []
  type: TYPE_NORMAL
- en: In general, either the caller (the code containing the call instruction) or
    the callee (the subroutine) can take responsibility for preserving the registers.
    When following the ARM ABI, it is the caller’s responsibility to preserve volatile
    registers and the callee’s responsibility to preserve nonvolatile registers. Of
    course, when writing your own procedures that won’t be called by ABI-compliant
    functions and don’t call any ABI-compliant functions, you can choose whichever
    register preservation scheme you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-4 shows the corrected version of the program in Listing 5-3, which
    properly preserves X19 in the call to print40Spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and sample output for Listing 5-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this program executes properly without entering an infinite
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Callee preservation has two advantages: space and maintainability. If the callee
    (the procedure) preserves all affected registers, only one copy of the str and
    ldr instructions exists—those that the procedure contains. If the caller saves
    the values in the registers, the program needs a set of preservation instructions
    around every call. This makes your programs not only longer but also harder to
    maintain. It’s not easy to remember which registers to save and restore on each
    procedure call.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a subroutine may unnecessarily preserve some registers if
    it preserves all the registers it modifies. If the caller is preserving the registers,
    the subroutine doesn’t have to save registers it doesn’t care about.
  prefs: []
  type: TYPE_NORMAL
- en: One big problem with having the caller preserve registers is that your program
    may change over time. You may modify the calling code or the procedure to use
    additional registers. Such changes, of course, may change the set of registers
    that you must preserve. Worse still, if the modification is in the subroutine
    itself, you will need to locate *every* call to the routine and verify that the
    subroutine does not change any registers that the calling code uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly language programmers typically use a common convention with respect
    to register preservation: unless there is a good reason (performance) for doing
    otherwise, most programmers will preserve each register that a procedure modifies
    (and doesn’t explicitly return a value in a modified register). This reduces the
    likelihood of defects occurring in a program because a procedure modifies a register
    the caller expects to be preserved. Of course, you could follow the rules concerning
    the ARM ABI with respect to volatile and nonvolatile registers; however, such
    calling conventions impose their own inefficiencies on both programmers and other
    programs. This book generally adheres to the ARM ABI with respect to volatile
    and nonvolatile registers, though many examples preserve all affected registers
    in a procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more to preserving the environment than preserving registers. You can
    also preserve variables and other values that a subroutine might change.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Call Trees, Leaf Procedures, and the Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a procedure, A, that calls two other procedures B and C. Also assume
    that B calls two procedures D and E, and procedure C calls two other procedures
    F and G. We can diagram this calling sequence by using a *call tree*, as shown
    in [Figure 5-1](chapter5.xhtml#fig5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: A call-tree diagram'
  prefs: []
  type: TYPE_NORMAL
- en: This entire call graph is the tree, and the procedures at the bottom that do
    not call any other procedures—in this case, D, E, F, and G—are known as *leaf
    procedures*.
  prefs: []
  type: TYPE_NORMAL
- en: Leaf procedures are different from non-leaf procedures in ARM assembly language
    because they can leave the return address in the LR register rather than saving
    it to memory (the stack). As leaf procedures don’t make any other calls via the
    bl instruction, the procedure won’t disturb the value in LR upon entry into the
    procedure. (This assumes that the procedure doesn’t explicitly modify LR, but
    generally, there is no good reason for doing so.) Therefore, leaf procedures can
    be slightly more efficient than non-leaf procedures, as they are spared the need
    to preserve the value in the LR register. Leaf procedures can also make full use
    of the volatile register set without worrying about their values being scrambled
    during a call to another procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-leaf procedures must preserve the value in the LR register because calls
    they make (via bl) will overwrite the value in LR. A procedure can preserve LR
    in a few places: in another register, on a stack, or in a global memory location,
    as our examples did before [Chapter 3](chapter3.xhtml) introduced the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already pointed out that using global variables to preserve LR is a poor
    choice in nearly every case. That scheme can handle only one level of calls and
    completely fails when using recursion (see section 5.8, “Recursion,” on [page
    277](chapter5.xhtml#pg_277)) or writing multithreaded applications. It’s also
    slower, uses more code, and is less convenient to use than other schemes.
  prefs: []
  type: TYPE_NORMAL
- en: You could use another register to temporarily hold the return address while
    calling another procedure. Of course, that register must be nonvolatile (or, at
    least, the procedure you’re calling must not modify that register’s value) so
    that it will still contain the saved return address whenever the procedure you
    call returns. Using a register to preserve LR like this is very fast. Unfortunately,
    guaranteeing that other procedures won’t modify the saved value often means you
    have to preserve that value in memory within the second procedure to be called.
    Since you still have to write the value to memory (and read it back), you may
    as well have saved LR directly to memory in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common place to save the return address in LR is on the stack. Usually,
    one of the first instructions in a procedure will move the contents of the LR
    register into the stack. This is typically done in one of two ways. The first
    is to directly push the LR register onto the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is to adjust the stack down in memory and store LR into the storage
    area just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, someAmount is a multiple of 16 (or another value that keeps the stack
    16-byte aligned), and someOffset is an index into the space just allocated on
    the stack by the sub instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the former example uses the pre-indexed addressing mode to adjust
    SP downward and store LR into the vacated space (because of stack alignment issues,
    this actually reserves 16 bytes, though it uses only 8 of them). The latter example
    uses the indirect-plus-offset addressing mode to simply store the return address
    into the storage allocated by the sub instruction. This book most commonly uses
    the latter form because the cost of sub is often shared by other code that uses
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wasting 8 bytes by using the pre-indexed addressing mode won’t turn out to
    be an issue. As you’ll see shortly, most of the time you’ll want to preserve the
    value of the FP register along with the return address, so you’ll commonly use
    an stp instruction, like one of the following, that won’t waste any memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The following subsections cover the use of the stack in procedures, including
    activation records, accessing data within activation records (local and automatic
    variables as well as parameters), how the ARM ABI influences activation records
    and passing parameters, and how to build and destroy activation records.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 Activation Records
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you call a procedure, the program associates certain information with that
    procedure call, including the return address, parameters, and automatic local
    variables (which I’ll discuss in later sections). To do so, it uses a data structure
    called an *activation record*, also known as a *stack frame*. The program creates
    an activation record when calling (activating) a procedure, and the data in the
    record is organized in a manner identical to structs.
  prefs: []
  type: TYPE_NORMAL
- en: This section covers traditional activation records created by a hypothetical
    compiler, ignoring the parameter-passing conventions of the ARM ABI. A later section
    of this chapter presents the ARM ABI conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller makes room for the parameter data (if any) on the stack and copies
    the data onto the stack. The bl instruction then passes the return address into
    the procedure. At this point, construction of the activation record continues
    within the procedure itself. The procedure typically pushes the value in LR onto
    the stack along with other registers and other important state information, then
    makes room in the activation record for local variables. The procedure might also
    update the FP register (X29) so that it points at the base address of the activation
    record.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what a traditional activation record looks like, consider the following
    C++ procedure declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a program calls this ARDemo procedure, it begins by pushing the data
    for the parameters onto the stack. In the original C/C++ calling convention (ignoring
    the ARM ABI), the calling code pushes all the parameters onto the stack in the
    opposite order in which they appear in the parameter list, from right to left.
    Therefore, the calling code pushes first the value for the k parameter, then the
    value for the j parameter, and finally the data for the i parameter (with possible
    padding for the parameters to keep the stack aligned).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the program calls ARDemo. Immediately upon entry into the ARDemo procedure,
    the stack contains these three items arranged as shown in [Figure 5-2](chapter5.xhtml#fig5-2).
    Since the program pushes the parameters in reverse order, they appear on the stack
    in the correct order, with the first parameter at the lowest address in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: Stack organization immediately upon entry into ARDemo'
  prefs: []
  type: TYPE_NORMAL
- en: The first few instructions in ARDemo push the current values of LR and FP onto
    the stack, then copy the value of SP into FP. Next, the code drops the stack pointer
    down in memory to make room for the local variables. This produces the stack organization
    shown in [Figure 5-3](chapter5.xhtml#fig5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The activation record for ARDemo'
  prefs: []
  type: TYPE_NORMAL
- en: Because local variables can be any size in the activation record, their total
    storage might not be a multiple of 16 bytes. However, the entire block of local
    variables must be a multiple of 16 bytes so that SP remains aligned on a 16-byte
    boundary as required by the ARM CPU—hence the presence of possible padding in
    [Figure 5-3](chapter5.xhtml#fig5-3).
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 Objects in the Activation Record
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access objects in the activation record, you can use offsets from the FP
    register to the desired object. The two items of immediate interest to you are
    the parameters and the local variables. You can access the parameters at positive
    offsets from the FP register; you can access the local variables at negative offsets
    from the FP register, as [Figure 5-4](chapter5.xhtml#fig5-4) shows (the figure
    assumes that the i, j, and k parameters are all 64-bit integers with appropriate
    padding to 8 bytes each).
  prefs: []
  type: TYPE_NORMAL
- en: ARM specifically reserves the X29/FP register for use as a pointer to the base
    of the activation record. This is why you should avoid using the FP register for
    general calculations. If you arbitrarily change the value in the FP register,
    you could lose access to the current procedure’s parameters and local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: Offsets of objects in the ARDemo activation record'
  prefs: []
  type: TYPE_NORMAL
- en: 'The local variables are aligned on offsets that are equal to their native size:
    chars are aligned on 1-byte addresses; shorts/hwords are aligned on 2-byte addresses;
    longs, ints, unsigned, and words are aligned on 4-byte addresses; and so forth.
    In the ARDemo example, all the locals just happen to be allocated on appropriate
    addresses (assuming a compiler allocates storage in the order of declaration).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3 ARM ABI Parameter-Passing Conventions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ARM ABI makes several modifications to the activation record model:'
  prefs: []
  type: TYPE_NORMAL
- en: The caller passes the first eight (non-floating-point) parameters in registers
    (X0 through X7) rather than on the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are always 8-byte values, either in registers or on the stack (if
    the formal parameter is fewer than 8 bytes in size, the unused HO bits are undefined).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures and unions greater than 16 bytes in size are passed by value on the
    stack above any other parameters, but with a pointer to the value in the normal
    parameter position (in a register or on the stack). Structs and unions that are
    8 bytes (or fewer) are passed in a 64-bit register; those that are 9 to 16 bytes
    are passed in two consecutive registers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must follow these conventions only when calling ARM ABI–compliant code.
    For assembly language procedures that you write and call, you can use any convention
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apple’s calling conventions for macOS (iOS, iPadOS, and so on) vary a little
    from the standard ARM ABI. This will affect your assembly code if you’re doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing more than eight parameters to a procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to a variadic procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing parameters on the stack—that is, when you’re passing more than
    eight arguments to a function—Apple packs them on the stack, meaning it doesn’t
    simply allocate 8 bytes for each parameter on the stack. It does ensure that each
    value is aligned in memory on its natural size (chars = 1 byte, half words = 2
    bytes, words = 4 bytes, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '*Variadic procedures* are those with a variable number of parameters, such
    as the C printf() function. Apple passes all variadic parameters on the stack
    and allocates 8 bytes for each parameter, regardless of type. This is the purpose
    behind the vparm2, vparm3, ..., macros in *aoaa.inc*: calls to printf() under
    macOS must pass the arguments on the stack, while the same calls on Linux pass
    the first eight parameters in registers.'
  prefs: []
  type: TYPE_NORMAL
- en: The vparm2, vparm3, and so on, macros automatically generate the appropriate
    code based on the OS (either putting the parameters in the stack or passing them
    in registers).
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.4 Standard Entry Sequence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The caller of a procedure is responsible for allocating storage for parameters
    on the stack and moving the parameter data to its appropriate location. In the
    simplest case, this just involves moving the data onto the stack by using str
    or stp instructions. It is the procedure’s responsibility to construct the rest
    of the activation record. You can accomplish this by using the following assembly
    language *standard entry sequence* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The mov fp, sp instruction copies the current address held in SP into the FP
    register. As SP is currently pointing at the old value of FP pushed on the stack,
    FP will point at the original FP value after the execution of this instruction,
    as shown in [Figure 5-4](chapter5.xhtml#fig5-4). When using the stp instruction
    in the standard entry sequence, make sure to specify the FP register as the first
    argument so that it is stored at location [SP] and LR is stored at location [SP,
    #8]. This ensures that FP will point at the old FP value after the mov instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: In the third instruction, NumVars represents the number of bytes of local variables
    needed by the procedure, a constant that should be a multiple of 16 so that the
    SP register remains aligned on a 16-byte boundary. If the number of bytes of local
    variables in the procedure is not a multiple of 16, round up the value to the
    next higher multiple of 16 before subtracting this constant from SP. Doing so
    will slightly increase the amount of storage the procedure uses for local variables
    but will not otherwise affect the operation of the procedure. If the procedure
    doesn’t have any local variables or call any other functions, the
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: instruction isn’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, you could use any register to access the data in the stack frame.
    However, the OS, and especially debugger applications, often depend on the activation
    record being built with FP pointing at the old FP value in the activation record.
  prefs: []
  type: TYPE_NORMAL
- en: If an ARM ABI–compliant program calls your procedure, the stack will be aligned
    on a 16-byte boundary immediately prior to the execution of the bl instruction.
    Pushing LR and FP onto the stack (before copying SP into FP) adds another 16 bytes
    to the stack so that SP remains 16-byte aligned. Therefore, assuming the stack
    was 16-byte aligned prior to the call, and the number you subtract from SP is
    a multiple of 16, the stack will be 16-byte aligned after allocating storage for
    local variables.
  prefs: []
  type: TYPE_NORMAL
- en: The ARDemo activation record from the previous section has only 12 bytes of
    local storage. Therefore, subtracting 12 from SP for the local variables will
    not leave the stack 16-byte aligned. The entry sequence in the ARDemo program
    must subtract 16 (which will include 4 bytes of padding) to keep the stack properly
    aligned (as shown in [Figure 5-4](chapter5.xhtml#fig5-4)).
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible alternate entry code sequence that is equivalent to the earlier
    example takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The ARM ABI calling convention suggests saving the LR and FP values *below*
    the local variables. However, it is often convenient to allocate parameter space
    for additional procedure calls (from the current procedure) while allocating local
    variables. If you save the LR and FP values at the bottom of the activation record
    in memory, you will need an extra instruction to make room for those parameters,
    and cleaning up the activation record will take more effort when the procedure
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you’ll so often use the standard entry sequence, the *aoaa.inc* include
    file provides a macro to generate this sequence for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The single constant argument is the amount of stack space to allocate (for
    local variables and other memory objects) in addition to the 16 bytes set aside
    to preserve the LR and FP registers. This macro generates the following sequence
    of instructions for the entry sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The final expression involving numVars ensures that the space allocated on the
    stack is a multiple of 16 bytes, to keep the stack 16-byte aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.5 Standard Exit Sequence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The standard exit sequence for an assembly language program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the *aoaa.inc* include file, the leave macro expands to the original standard
    exit sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Local Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Procedures and functions in most HLLs let you declare local variables (also
    known as *automatic variables*). The previous sections mentioned that procedures
    maintain local variables in an activation record, but they didn’t really define
    how to create and use them. This section (and the subsections that follow) defines
    local variables and describes how to allocate storage for them and use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables possess two special attributes in HLLs: scope and lifetime*.*
    The *scope* of an identifier determines where that identifier is visible (accessible)
    in the source file during compilation. In most HLLs, the scope of a procedure’s
    local variable is the body of that procedure; the identifier is inaccessible outside
    that procedure. Sadly, Gas does not support locally scoped variables in a procedure,
    since Gas has no syntax to determine the bounds of a procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: Whereas scope is a compile-time attribute of a symbol, lifetime is a runtime
    attribute. The *lifetime* of a variable is a range of time, from that point when
    storage is first bound to the variable until the point where the storage is no
    longer available for that variable. Static objects (those you declare in the .data,
    .rodata, .bss, and .text sections) have a lifetime equivalent to the total runtime
    of the application. The program allocates storage for such variables when the
    program first loads into memory, and those variables maintain that storage until
    the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables, more properly known as *automatic variables*, have their storage
    allocated upon entry into a procedure. That storage is then returned for other
    use when the procedure returns to its caller. The name *automatic* refers to the
    program automatically allocating and deallocating storage for the variable on
    procedure invocation and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Linux, a procedure can access any global .data, .bss, or .rodata object
    exactly the same way the main program accesses such variables: by referencing
    the name, using the PC-relative addressing mode (sadly, macOS’s PIE format doesn’t
    allow easy access to non-.text section objects). Accessing global objects is convenient
    and easy. However, accessing global objects makes your programs harder to read,
    understand, and maintain, so you should avoid using global variables within procedures.'
  prefs: []
  type: TYPE_NORMAL
- en: Although accessing global variables within a procedure may sometimes be the
    best solution to a given problem, you likely won’t be writing such code at this
    point, so carefully consider your options before doing so. (An example of a legitimate
    use of global variables might be when sharing data between threads in a multithreaded
    application, a bit beyond the scope of this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: This argument against accessing global variables does not apply to other global
    symbols, however. It is perfectly reasonable to access global constants, types,
    procedures, and other objects in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.1 Low-Level Implementation of Automatic Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your program accesses local variables in a procedure by using negative offsets
    from the activation record base address (FP). Consider the Gas procedure in Listing
    5-5, which is intended primarily to demonstrate the use of local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This program isn’t runnable, so I won’t bother providing a build command for
    it. The enter macro will actually allocate 16 bytes of storage, rather than the
    8 specified by the argument (for locals a and bb), in order to keep the stack
    16-byte aligned.
  prefs: []
  type: TYPE_NORMAL
- en: The activation record for local_vars appears in [Figure 5-5](chapter5.xhtml#fig5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: The activation record for the local_vars procedure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, having to refer to the local variables by the numeric offset from
    the FP register is truly horrible. This code is not only difficult to read (Is
    [FP, #-4] the a or the bb variable?) but also hard to maintain. For example, if
    you decide you no longer need the a variable, you’d have to go find every occurrence
    of [FP, #-8] (accessing the bb variable) and change it to [FP, #-4].'
  prefs: []
  type: TYPE_NORMAL
- en: A slightly better solution is to create equates for your local variable names.
    Consider the modification to Listing 5-5 shown in Listing 5-6.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In Listing 5-6, the CPP replaces a and bb with the appropriate indirect-plus-offset
    addressing mode to access those local variables on the stack. This is considerably
    easier to read and maintain than the program in Listing 5-5\. However, this approach
    still requires some manual work to set the local variable offsets in the #define
    statements, and modifying the code (when adding or removing local variables) can
    create maintenance issues. I’ll provide a better solution in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One big advantage to automatic storage allocation is that it efficiently shares
    a fixed pool of memory among several procedures. For example, say you call three
    procedures in a row, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, ProcA allocates its local variables on the stack. Upon return,
    ProcA deallocates that stack storage. Upon entry into ProcB, the program allocates
    storage for ProcB’s local variables by using the same memory locations just freed
    by ProcA. Likewise, when ProcB returns and the program calls ProcC, ProcC uses
    the same stack space for its local variables that ProcB recently freed up. This
    memory reuse makes efficient use of the system resources and is probably the greatest
    advantage to using automatic variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how assembly language allocates and deallocates storage
    for local variables, it’s easy to understand why automatic variables do not maintain
    their values between two calls to the same procedure. Once the procedure returns
    to its caller, the storage for the automatic variable is lost, and, therefore,
    the value is lost as well. Thus, *you must always assume that a local variable
    object is uninitialized upon entry into a procedure*. If you need to maintain
    the value of a variable between calls to a procedure, you should use one of the
    static variable declaration types.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.2 The locals Macro
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using equates to maintain local variable references is a lot of work. Granted,
    it’s better than using magic numbers in all your local variable references, but
    even when using equates, inserting and deleting local variables in a procedure
    takes time and effort. What would be really nice is a declaration section that
    lets you declare your local variables in an HLL-like fashion and leave it up to
    the assembler to maintain all the offsets into the activation record. The *aoaa.inc*
    header file provides a set of macros you can use to automate the creation of local
    variables. This section describes those macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'The activation record is a *record* (structure). In theory, you could use the
    struct macro from [Chapter 4](chapter4.xhtml) to define an activation record.
    However, it’s easy enough to modify the struct/ends macros to create something
    even better for local variables. To achieve that, the *aoaa.inc* include file
    includes two additional macros for declaring local variables: locals and endl.
    Use these in a manner almost identical to the struct/ends macros'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: where procName is an identifier (usually the name of the procedure that the
    local variables are associated with).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the ends macro, endl generates a symbol with the name procName.size that
    is an equate set to the size of the local variable space. You can supply this
    value to the enter macro to specify the amount of space to reserve for the local
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The locals/endl declarations create a set of equates whose values correspond
    to the offsets of the symbols within an activation record. For example, the symbols
    in the previous example have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: mp.ptrVar    –8
  prefs: []
  type: TYPE_NORMAL
- en: mp.counter    –12
  prefs: []
  type: TYPE_NORMAL
- en: mp.inputChar    –13
  prefs: []
  type: TYPE_NORMAL
- en: mp.endIndex    –20
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these offsets with the [FP, #offset] addressing mode to reference
    these local variables in the activation record. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is a whole lot easier than accessing global variables in the .data section!
  prefs: []
  type: TYPE_NORMAL
- en: When allocating offsets for variables between the locals and endl macros, the
    declaration macros first decrease the offset counter by the size of the variable’s
    declaration and then assign the decremented offset value to the symbol. Specifying
    the salign directive will then adjust the offset to the specified boundary (2*^n*,
    where *n* is the salign operand’s value). The next declaration will not use this
    offset, but rather it will first decrement the running offset counter by the size
    of the declaration and assign that offset to the variable. In the earlier example,
    the salign directive set the running offset to –16 (because 13 bytes of variables
    were allocated at that point). The following variable’s offset is –20, because
    mp.endIndex consumes 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, Gas does not support the concept of lexically scoped
    local variable names, which are private to a procedure. Therefore, all symbols
    you declare within the locals/endl block are visible throughout the source file.
    This can lead to *namespace pollution*, where you wind up creating names in one
    procedure and cannot reuse those names in a different procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples of this section, I use a convention that I continue throughout
    this book to alleviate namespace pollution: I use local variable names of the
    form proc.local, where proc is the procedure’s name (or an abbreviation of the
    procedure’s name) and local is the specific local variable name I want to use.
    For example, mp.ptrVar is the ptrVar local variable within the myProc (mp) procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although many procedures are totally self-contained, most procedures require
    input data and return data to the caller (parameters).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first aspect to consider when discussing parameters is how we pass them
    to a procedure. If you are familiar with Pascal or C/C++, you’ve probably seen
    two ways to pass parameters: pass by value and pass by reference. Anything you
    can do with an HLL can be done in assembly language (obviously, as HLL code compiles
    into machine code), but you have to provide the instruction sequence to access
    those parameters in an appropriate fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concern when dealing with parameters is *where* you pass them. There
    are many places to pass parameters: in registers, on the stack, in the code stream,
    in global variables, or a combination of these. The following subsections cover
    several of the possibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1 Passing by Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A parameter *passed by value* is just that—the caller passes a value to the
    procedure. Pass-by-value parameters are input-only parameters. You can pass them
    to a procedure, but the procedure cannot return values through them. Consider
    this C/C++ function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you pass I by value, CallProc() does not change the value of I, regardless
    of what happens to the parameter inside CallProc().
  prefs: []
  type: TYPE_NORMAL
- en: Because you must pass a copy of the data to the procedure, you should use this
    method only for passing small objects like bytes, words, double words, and quad
    words. Passing large arrays and records by value is inefficient, because you must
    create and pass a copy of the object to the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.2 Passing by Reference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To pass a parameter *by reference*, you must pass the address of a variable
    rather than its value. In other words, you must pass a pointer to the data. The
    procedure must dereference this pointer to access the data. Passing parameters
    by reference is useful when you must modify the actual parameter or when you pass
    large data structures between procedures. Because pointers on the ARM are 64 bits
    wide, a parameter that you pass by reference will consist of a double-word value,
    typically in one of the general-purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the lea macro to take the address of any static variable you’ve
    declared in your .data, .bss, .rodata, or .text sections. Listing 5-7 demonstrates
    how to obtain the address of a static variable (staticVar) and pass that address
    to a procedure (someFunc) in the X0 register.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the address of a nonstatic variable is a bit more work. Unfortunately,
    the adr and adrp instructions compute only the address of a PC-relative memory
    access. If your variable is referenced by one of the other ARM addressing modes,
    you’ll have to manually compute the effective address yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-1](chapter5.xhtml#tab5-1) describes the process for effective address
    calculation. In the table, the [Xn, #const] (scaled form) addressing mode describes
    a machine encoding, not an assembler syntax. In source code, the scaled and unscaled
    variants share the same syntax: [Xn, #const]. The assembler will pick the correct
    machine encoding based on the value of the constant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-1: Effective Address Calculations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Addressing mode | Effective address | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Xn] | Xn | For the register-indirect addressing mode, the effective address
    is just the value held in the register. |'
  prefs: []
  type: TYPE_TB
- en: '| [Xn, #const] | Xn + const | For the indirect-plus-offset addressing mode,
    the sum of the Xn register and the constant is the effective address. This assumes
    the constant is –256 to +255 and the shift is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| [Xn, #const] | Xn + const (scaled) | For the scaled-indirect-plus-offset
    mode (where the scaling factor is determined by the size of the data being loaded
    or stored), the constant has to be multiplied by the size of the memory operand
    prior to adding with the Xn register. For strb/ldrb, the multiplier is 1; for
    strh/ldrh, the multiplier is 2; for str/ldr (word register), the multiplier is
    4; and for str/ldr (dword register), the multiplier is 8\. For strb/ldrb, the
    constant must be in the range 0–4,096\. For strh/ldrh, the constant must be in
    the range 0–8,191 and must be an even number. For ldr/str with a word-sized register
    operand, the constant must be in the range 0–16,383 and must be a multiple of
    4\. For ldr/str with a dword-sized register operand, the constant must be in the
    range 0–32,767 and must be a multiple of 8. |'
  prefs: []
  type: TYPE_TB
- en: '| [Xn, #const]! | Xn + const | For the pre-indexed addressing mode, the effective
    address is the sum of the Xn register and the constant. |'
  prefs: []
  type: TYPE_TB
- en: '| [Xn], #const | Xn | For the post-indexed addressing mode, the effective address
    is just the value in the Xn register. |'
  prefs: []
  type: TYPE_TB
- en: '| [Xn, Xm] | Xn + Xm | For the scaled-indexed addressing mode, with a scaling
    factor of 1, the effective address is the sum of the two registers (sign- or zero-extend
    Xm, if specified). |'
  prefs: []
  type: TYPE_TB
- en: '| [Xn, Xm, extend #s] | Xn + (Xm << s) | For the scaled-indexed addressing
    mode with a shift extension, the effective address is the sum of Xn plus the value
    in Xm shifted to the left s positions (with Xm zero- or sign-extended, if specified).
    |'
  prefs: []
  type: TYPE_TB
- en: 'Suppose that a procedure has a local variable and you want to pass that on
    to a second procedure by reference. Because you access local variables by using
    the [FP, #offset] addressing mode, the effective address is FP + offset. You would
    have to use the following instruction to compute the address of that variable
    (leaving the address in X0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5-8 demonstrates passing a local variable as a reference parameter to
    a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass by reference is usually less efficient than pass by value. You must dereference
    all pass-by-reference parameters on each access; this is slower than simply using
    a value because it typically requires at least two instructions: one to fetch
    the address into a register and one to fetch the value indirectly through that
    register.'
  prefs: []
  type: TYPE_NORMAL
- en: However, when passing a large data structure, pass by reference is faster because
    you do not have to copy the large data structure before calling the procedure.
    Of course, you’d probably need to access elements of that large data structure
    (such as an array) by using a pointer, so little efficiency is lost when you pass
    large arrays by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3 Using Low-Level Parameter Implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A parameter-passing mechanism is a contract between the caller and the callee
    (the procedure). Both parties have to agree on where the parameter data will appear
    and what form it will take (for example, value or address).
  prefs: []
  type: TYPE_NORMAL
- en: If your assembly language procedures are being called only by other assembly
    language code that you’ve written, you control both sides of the contract negotiation
    and get to decide where and how you’re going to pass parameters. However, if external
    code is calling your procedure, or your procedure is calling external code, your
    procedure will have to adhere to whatever calling convention that external code
    uses.
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing the particular calling conventions, this section considers
    the situation of calling code that you’ve written (and, therefore, have complete
    control over its calling conventions). The following sections describe the various
    ways you can pass parameters in pure assembly language code (without the overhead
    associated with the ARM or macOS ABIs).
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3.1 Passing Parameters in Registers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having touched on *how* to pass parameters to a procedure, the next topic to
    discuss is *where* to pass parameters. This depends on the size and number of
    those parameters. If you are passing a small number of parameters to a procedure,
    the registers are an excellent place to pass them. If you are passing a single
    parameter to a procedure, pass that data in X0, as described in [Table 5-2](chapter5.xhtml#tab5-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-2: Parameter Size and Location'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter size | Location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Byte | Pass a byte parameter in the LO byte of W0. |'
  prefs: []
  type: TYPE_TB
- en: '| Half word | Pass a halfword parameter in the LO half-word of W0. |'
  prefs: []
  type: TYPE_TB
- en: '| Word | Pass a word in W0. |'
  prefs: []
  type: TYPE_TB
- en: '| Dword | Pass a dword in X0. |'
  prefs: []
  type: TYPE_TB
- en: '| > 8 bytes | I suggest passing a pointer to the data structure in X0, or the
    value in X0/X1 if 16 bytes or fewer. |'
  prefs: []
  type: TYPE_TB
- en: When passing fewer than 32 bits in X0, the macOS ABI requires that the value
    be zero- or sign-extended throughout the X0 register. The ARM ABI does not require
    this. Of course, when passing data to a procedure you’ve written in assembly language,
    it is up to you to define what must be done with the HO bits. The safest course
    of action, portable everywhere, is to zero-extend or sign-extend the value into
    the HO bits (depending on whether the value is unsigned or signed).
  prefs: []
  type: TYPE_NORMAL
- en: If you need to pass more than 8 bytes as a parameter, you could also pass that
    data in multiple registers (for example, under macOS and Linux, the C/C++ compiler
    will pass a 16-byte structure in two registers). Whether you pass the argument
    as a pointer or in multiple registers is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: For passing parameters to a procedure in registers, the ARM ABI reserves X0
    to X7\. Of course, in pure assembly language code (that won’t call, or be called
    by, ARM ABI–compliant code), you can use whichever registers you choose. However,
    X0 through X7 should probably be your first choice unless you can provide a good
    reason for using other registers.
  prefs: []
  type: TYPE_NORMAL
- en: Eight parameters probably cover 95 percent of the procedures ever written. If
    you are passing more than eight parameters to a pure assembly procedure, nothing
    is stopping you from using additional registers (for example, X8 through X15).
    Likewise, nothing is stopping you from passing large objects in multiple registers,
    if you really want to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '##### 5.6.3.2 Passing Parameters in the Code Stream'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass parameters in the code stream immediately after the bl instruction.
    Consider the following print routine that prints a literal string constant to
    the standard output device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Normally, a subroutine returns control to the first instruction immediately
    following the bl instruction. Were that to happen here, the ARM would attempt
    to interpret the ASCII codes for "This..." as an instruction. This would produce
    undesirable results. Fortunately, you can skip over this string before returning
    from the subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'One big issue arises with the design of the ARM CPU, however: all instructions
    must be word-aligned in memory. Therefore, the parameter data appearing in the
    code stream must be a multiple of 4 bytes long (I chose the string in this example
    to contain 39 characters so that the zero-terminating byte made the whole sequence
    40 bytes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do you gain access to these parameters? Easy: the return address in
    LR points at them. Consider the implementation of print in Listing 5-9.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The print procedure ❶ saves all the registers it modifies (even the volatile
    registers, because the call to write() might overwrite them). This is a normal
    assembly language convention, but it’s especially important for print because
    you want to be able to print (debug) messages without saving register values across
    your calls.
  prefs: []
  type: TYPE_NORMAL
- en: LR points at the string to print upon entry into the print procedure ❷. This
    code scans through that string to find the zero-terminating byte; this scan produces
    both the length and the (approximate) return address.
  prefs: []
  type: TYPE_NORMAL
- en: Because code must be aligned on a 4-byte boundary, the return address isn’t
    necessarily the byte after the zero-terminating byte. Instead, the code may need
    to pad the end of string pointer by 1 to 3 bytes to advance to the next word boundary
    in the .text section ❸. Adding 3 and then ANDing the result with 0xFFFFFFFFFFFFFFFC
    (-4) pads the return address up to the appropriate boundary. The code then stores
    the return address over the original on the stack ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the string length, you can call the C stdlib write function to
    print it ❺ (if the first argument is 0, this prints the string to the standard
    output device). On exit, the code restores the registers you saved earlier ❻.
  prefs: []
  type: TYPE_NORMAL
- en: For this listing, I included two exclamation marks ❼ so that the length of the
    string (including the zero-terminating byte) is a multiple of four characters.
    This ensures that the following instruction is aligned on a 4-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid a bus fault, the length of the data following the call to print must
    be a multiple of 4 bytes so that the next instruction is properly aligned on a
    4-byte boundary. The length of the string itself doesn’t have to be a multiple
    of 4 bytes; arbitrary padding after the zero-terminating byte is fine. Rather
    than counting the number of characters in the string, you could use the Gas .p2align
    directive. This directive will pad the location counter to a boundary that is
    a multiple of 2*^n* bytes, where *n* is the (first) value in the .p2align operand
    field. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: pads the location counter to the next word boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the .p2align 2 directive, you can call the print procedure with an arbitrary-length
    string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Remembering to put the .p2align 2 directive in the code can be difficult, not
    to mention that having to type it is a pain, and it clutters up your code. To
    resolve this, the *aoaa.inc* include file includes a wastr (word-aligned string)
    macro that automatically adds the padding for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides showing how to pass parameters in the code stream, the print routine
    also exhibits another concept: *variable-length parameters* (the length of the
    string can be arbitrarily long). The string following the bl can be any practical
    length. The zero-terminating byte marks the end of the parameter list. You can
    handle variable-length parameters in two easy ways: either use a special terminating
    value (like 0) or pass a special length value that tells the subroutine the number
    of parameters you are passing. Both methods have advantages and disadvantages.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a special value to terminate a parameter list requires that you choose
    a value that never appears in the list. For example, print uses 0 as the terminating
    value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes
    this isn’t a limitation. Specifying a length parameter is another mechanism you
    can use to pass a variable-length parameter list. While this doesn’t require any
    special codes or limit the range of possible values that can be passed to a subroutine,
    setting up the length parameter and maintaining the resulting code can be a real
    nightmare; this is especially true if the parameter list changes frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the convenience afforded by passing parameters in the code stream, this
    method also has disadvantages. First, if you fail to provide the exact number
    of parameters the procedure requires, the subroutine will get confused. Consider
    the print example. It prints a string of characters up to a zero-terminating byte
    and then returns control to the first instruction following that byte. If you
    leave off the zero-terminating byte, the print routine happily prints the following
    opcode bytes as ASCII characters until it finds a 0 byte. Because 0 bytes often
    appear in the middle of an instruction, the print routine might return control
    into the middle of another instruction, which will probably crash the machine.
  prefs: []
  type: TYPE_NORMAL
- en: On the ARM, you must ensure that the parameters you pass in the code stream
    are a multiple of 4 bytes long. The instructions following the parameters must
    lie on a word boundary. Problems notwithstanding, however, the code stream is
    an efficient place to pass parameters whose values do not change.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3.3 Passing Parameters on the Stack
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most HLLs use the stack to pass a large number of parameters because this method
    is fairly efficient. Although passing parameters on the stack is slightly less
    efficient than doing so in registers, the register set is limited (especially
    if you’re limiting yourself to the eight registers the ARM ABI sets aside for
    this purpose). The stack, on the other hand, allows you to pass a large amount
    of parameter data without difficulty. This is the reason that most programs pass
    their parameters on the stack (at least, when passing more than eight parameters).
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually pass parameters on the stack, push them immediately before calling
    the subroutine (just remember to keep the stack 16-byte aligned). The subroutine
    then reads this data from the stack memory and operates on it appropriately. Consider
    the following HLL function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Because keeping SP aligned on a 16-byte boundary is crucial, you can’t simply
    push one argument at a time with a str instruction, nor can you push values smaller
    than 32 bits. Assuming that i, j, and k are 32-bit integers, you would need to
    somehow marshal them together into a 128-bit package (including an extra 32 bits
    of unused data) and push 16 bytes onto the stack. This is so inconvenient that
    ARM code almost never pushes individual (or even pairs of) register values onto
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common solution in ARM assembly language is first to drop the stack down
    by however many bytes you need (plus any padding, to make sure the stack is aligned
    properly), and then to simply store your parameters into the stack space so allocated.
    For example, to call CallProc, you might use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The sub instruction allocates 16 bytes on the stack; you need only 12 for the
    three 32-bit parameters, but you must allocate 16 to keep the stack aligned.
  prefs: []
  type: TYPE_NORMAL
- en: The three str instructions store the parameter data (which is presumed to be
    in W0, W1, and W2 by this code) into the 12 bytes from SP + 0 through SP + 11\.
    The CallProc will simply ignore the extra 4 bytes allocated on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the three 32-bit integers are packed into memory, each consuming
    4 bytes on the stack. So the i parameter is found at SP + 0, the j parameter is
    found at SP + 4, and the k parameter is found at SP + 8 upon entry into CallProc
    (see [Figure 5-6](chapter5.xhtml#fig5-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Stack layout upon entry into CallProc'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your procedure includes the standard entry and exit sequences, you may directly
    access the parameter values in the activation record by indexing off the FP register.
    Consider the layout of the activation record for CallProc that uses the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, i’s value can be found at [FP, #16], j’s value can be found
    at [FP, #20], and k’s value can be found at [FP, #24] (see [Figure 5-7](chapter5.xhtml#fig5-7)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: CallProc activation record after standard entry sequence'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the CallProc procedure, you can access the parameter values with these
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, using magic numbers such as these to reference the parameter offsets
    is still a bad idea. It would be far better to use equates or, even better, create
    a declaration macro similar to struct and locals to define the parameters for
    a procedure. The *aoaa.inc* file contains just such a macro: args (and enda).
    Listing 5-10 demonstrates the use of this macro.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The args macro requires an argument list name, which can be the procedure name
    or an abbreviation of it, and an optional second argument with a starting offset.
    The second argument defaults to 16, which is an appropriate value if the procedure
    uses the standard entry sequence (pushing the LR and FP registers on the stack).
    Offsets associated with the parameters you declare are offsets from FP in the
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for Listing 5-10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If your procedure does not use the standard entry sequence, you can specify
    an explicit offset as the second argument. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If you aren’t pushing anything on the stack in the procedure (or allocating
    local variables), 0 is a good value to use; then the offsets are SP based rather
    than FP based.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3.4 Removing Parameters in Callee vs. Caller Stack Cleanup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When passing parameters on the stack, ultimately those parameters must be removed
    from the stack. The ARM ABI specifies that the caller is responsible for removing
    all parameters it pushes onto the stack. Most of the example programs in this
    book thus far have (implicitly) done this.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the parameters after every procedure call is slow and inefficient.
    Fortunately, an easy optimization eliminates the need to allocate and deallocate
    parameter storage for each function call. Upon entry into a procedure, when allocating
    storage for local variables, include additional storage to be used for parameters
    the procedure passes to other functions. This, in fact, has been the whole purpose
    of the “magic stack allocation” instructions at the beginning of most procedures
    in this book up to this point. The examples thus far have typically reserved 64
    or 256 bytes of storage on the stack (enough for between eight and thirty-two
    64-bit parameters, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: Functions that pass parameters on the stack, such as printf() running on macOS,
    can store data into this area prior to calling the function. Upon return from
    the function, your code does not have to worry about cleaning up the parameters.
    That stack space is now available for the next function you want to call that
    requires stack parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, of course, the parameters must be deallocated from the stack. That
    happens when the procedure executes the leave macro (or manually copies FP into
    SP, which is part of leave’s expansion). When using enter and leave to allocate
    this stack space for the parameters, along with any local variables a procedure
    might need, you need to allocate and deallocate the stack space only once, not
    for each individual procedure call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your procedure doesn’t have any local variables, you can easily allocate
    stack space for parameters by using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If your procedure requires local variable storage, just specify the extra stack
    space as a dummy local variable at the end of your locals declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Remember that enter always allocates a multiple of 16 bytes, so we know that
    the stack storage will be aligned on a 16-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3.5 Passing Parameters to the C/C++ printf() Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Under Linux, you pass the first eight printf() parameters in registers, just
    as you would any other nonvariadic function. On macOS, those parameters are always
    passed on the stack, each occupying a dword. Until now, this book has used the
    vparmsn macros to handle the difference in the way parameters are passed (and,
    of course, to avoid dealing with the stack, which the book hadn’t covered in the
    earlier chapters).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I strived to write code that is portable between Linux and macOS,
    resorting to OS-specific code only as necessary; this was part of the motivation
    for using the vparmsn macros when calling printf(). Now that you’ve learned how
    these two OSes expect you to pass variadic parameters, you’ll probably want to
    pass parameters in a more flexible manner than using the vparmsn macros. Nevertheless,
    there is great benefit (at least for the source code in this book) to writing
    portable code. Fortunately, with a little sleight of hand, it is possible to directly
    pass the parameters to printf() without using vparmsn and still have the code
    assemble and run on both OSes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule is to load each printf() argument into X0 through X7\. This
    puts the arguments into the locations where Linux expects them. Once the arguments
    are in these registers, you’ll also store them into the stack storage area at
    SP + 0, SP + 8, SP + 16, ..., SP + 56 (which is where macOS expects them). Here’s
    a typical call to printf() printing the values in X0, X5, and X7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Strictly speaking, the str instructions aren’t necessary when running under
    Linux. To allow the creation of slightly more efficient code, I’ve provided the
    following mstr macro in the *aoaa.inc* include file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro assembles to nothing under Linux and to the corresponding str instruction
    under macOS. If you rewrite the former code by using mstr, it will not generate
    any excess code under Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you’re writing code only for Linux and don’t care at all about
    macOS portability, you can drop the mstr instructions altogether to remove some
    clutter.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.4 Accessing Reference Parameters on the Stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because you pass the addresses of objects as reference parameters, accessing
    the reference parameters within a procedure is slightly more difficult than accessing
    value parameters, as you must dereference the pointers to the reference parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Consider Listing 5-11, which demonstrates a single pass-by-reference parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The refParm procedure fetches the reference parameter (a 64-bit pointer) into
    X1 1 and then immediately dereferences this pointer by fetching the 32-bit word
    at the address in X1\. The mstr macro ❷ stores the second parameter onto the stack
    (under macOS). To pass a variable by reference to refParm ❸, you must compute
    its effective address and pass that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the build command and sample output for the program in Listing 5-11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, accessing (small) pass-by-reference parameters is a little less
    efficient than accessing value parameters, because you need an extra instruction
    to load the address into a 64-bit pointer register (not to mention that you have
    to reserve a 64-bit register for this purpose). If you access reference parameters
    frequently, these extra instructions can really begin to add up, reducing the
    efficiency of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it’s easy to forget to dereference a reference parameter and use
    the address of the value in your calculations. Therefore, unless you really need
    to affect the value of the actual parameter, you should use pass by value to pass
    small objects to a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Passing large objects, like arrays and records, is where using reference parameters
    becomes efficient. When passing these objects by value, the calling code has to
    make a copy of the actual parameter; if it is a large object, the copy process
    can be inefficient. Because computing the address of a large object is just as
    efficient as computing the address of a small scalar object, no efficiency is
    lost when passing large objects by reference. Within the procedure, you must still
    dereference the pointer to access the object, but the efficiency loss due to indirection
    is minimal when you contrast this with the cost of copying that large object.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-12 demonstrates how to use pass by reference to initialize an array
    of structures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The code computes the address of the Pts array and passes this array (by reference)
    to the refAryParm procedure ❸. It loads this address into X1 ❶ and uses this pointer
    value as the base address of the array that refAryParm processes ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This output shows how the refAryParm procedure initialized the array.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Functions and Function Return Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Functions* are procedures that return a result to the caller. In assembly
    language, few syntactical differences exist between a procedure and a function.
    This is why *aoaa.inc* doesn’t provide a specific macro declaration for a function.
    Nevertheless, semantic differences exist; although you can declare them the same
    way in Gas, you use them differently.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Procedures* are a sequence of machine instructions that fulfill a task. The
    end result of the execution of a procedure is the accomplishment of that activity.
    Functions, on the other hand, execute a sequence of machine instructions specifically
    to compute a value to return to the caller. Of course, a function can perform
    an activity as well, and procedures can undoubtedly compute values, but the main
    difference is that the purpose of a function is to return a computed result; procedures
    don’t have this requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: In assembly language, you don’t specifically define a function by using special
    syntax. In Gas, everything is a procedure. A section of code becomes a function
    when the programmer explicitly decides to return a function result via the procedure’s
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: The registers are the most common place to return function results. The strlen()
    routine in the C stdlib is a good example of a function that returns a value in
    one of the CPU’s registers. It returns the length of the string (whose address
    you pass as a parameter) in the X0 register.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, programmers try to return 8-, 16-, and 32-bit results in the
    W0 register and 64-bit values in the X0 register. This is where most HLLs return
    these types of results, and it’s where the ARM ABI states that you should return
    function results. The exception is floating-point values; I discuss floating-point
    function results in [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing particularly sacred about the W0/X0 register. You can return
    function results in any register if it’s more convenient to do so. Of course,
    if you’re calling an ARM ABI–compliant function, such as strlen(), you have no
    choice but to expect the function’s return result in the X0 register. The strlen()
    function returns an integer in X0, for example.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to return a function result that is larger than 64 bits, you obviously
    must return it somewhere other than in X0 (which can hold only 64-bit values).
    For values slightly larger than 64 bits (for example, 128 bits or maybe even as
    many as 256 bits), you can split the result into pieces and return those parts
    in two or more registers. It is not uncommon to see functions returning 128-bit
    values in the X1:X0 register pair. Just keep in mind that these schemes are not
    ARM ABI compliant, so they’re practical only when calling code you’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to return a large object as a function result (say, an array of
    1,000 elements), you obviously are not going to be able to return the function
    result in the registers. When returning function results greater than 64 bits,
    the ARM ABI specifies that the caller allocate storage for the result and pass
    a pointer to that storage in X8\. The function places the result in that storage,
    and the caller retrieves the data from that location upon return.
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Recursion* occurs when a procedure calls itself. The following, for example,
    is a recursive procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the CPU will never return from this procedure. Upon entry into Recursive,
    this procedure will immediately call itself again, and control will never pass
    to the end of the procedure. In this case, runaway recursion results in a logical
    infinite loop that produces stack overflow, at which point the OS will raise an
    exception and stop the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a looping structure, recursion requires a termination condition in order
    to stop infinite recursion. Recursive could be rewritten with a termination condition
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This modification to the routine causes Recursive to call itself the number
    of times appearing in the X0 register. On each call, Recursive decrements the
    X0 register by 1 and then calls itself again. Eventually, Recursive decrements
    X0 to 0 and returns from each call until it returns to the original caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far in this section, there hasn’t been a real need for recursion. After
    all, you could efficiently code this procedure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Both of these last two examples would repeat the body of the procedure the number
    of times passed in the X0 register. (The latter version will do it considerably
    faster because it doesn’t have the overhead of the bl/ret instructions.) As it
    turns out, you cannot implement only a few recursive algorithms in an iterative
    fashion. However, many recursively implemented algorithms are more efficient than
    their iterative counterparts, and most of the time the recursive form of the algorithm
    is much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The *quicksort algorithm* is probably the most famous algorithm that usually
    appears in recursive form. Listing 5-13 shows a Gas implementation of this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and output for Listing 5-13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This output shows the contents of the array prior to sorting and after the quicksort
    procedure has sorted the array.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Procedure Pointers and Procedural Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ARM bl instruction supports an indirect form: blr. This instruction has
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction fetches the address of a procedure’s first instruction from
    this specified register. It is equivalent to the following pseudo-instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Gas treats procedure names like static objects. Therefore, you can compute the
    address of a procedure by using the lea macro along with the procedure’s name.
    For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'loads the address of the very first instruction of the procName procedure into
    X0\. The following code sequence winds up calling the procName procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the address of a procedure fits in a 64-bit object, you can store such
    an address into a double-word variable; in fact, you can initialize a double-word
    variable with the address of a procedure by using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note that although macOS does not allow you to initialize a dword variable in
    the .text section with the address of an object outside the .text section, it
    will allow you to initialize a pointer (in any section) with the address of some
    code within the .text section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all pointer objects, you should not attempt to indirectly call a procedure
    through a pointer variable unless you’ve initialized that variable with an appropriate
    address. You can initialize a procedure pointer variable in two ways: you can
    create dword variables with initializers in the .data, .text, and .rodata sections,
    or you can compute the address of a routine (as a 64-bit value) and store that
    64-bit address directly into the procedure pointer at runtime. The following code
    fragment demonstrates both ways to initialize a procedure pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Although all the examples in this section use static variable declarations (.data,
    .text, .bss, and .rodata), you aren’t limited to declaring simple procedure pointers
    in the static variable declaration sections. You can also declare procedure pointers
    (which are just dword variables) as local variables, pass them as parameters,
    or declare them as fields of a record or a union.
  prefs: []
  type: TYPE_NORMAL
- en: Procedure pointers are also invaluable in parameter lists. Selecting one of
    several procedures to call by passing the address of a procedure is a common operation.
    A *procedural parameter* is just a double-word parameter containing the address
    of a procedure, so passing a procedural parameter is really no different from
    using a local variable to hold a procedure pointer (except, of course, that the
    caller initializes the parameter with the address of the procedure to call indirectly).
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 A Program-Defined Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the pre- and post-indexed addressing modes, along with one of the ARM’s
    64-bit registers, it is possible to create software-controlled stacks that don’t
    use the SP register. Since the ARM CPU provides a hardware stack pointer register,
    it may not be obvious why you’d consider using another stack. As you’ve learned,
    one limitation of the ARM’s hardware stack is that it must be 16-byte aligned
    at all times. Return addresses and other values you might want to preserve on
    the stack are generally 8 bytes or smaller. For example, you cannot push the LR
    register onto the stack by itself without causing a bus error fault. However,
    if you create your own stack, you won’t have this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you’re wondering why anyone would ever want to use a second stack in
    their programs. If the normal hardware stack works fine, why add the complexity
    of a second stack? Having two stacks is useful in several situations. Particularly,
    coroutines, generators, and iterators can make use of an extra stack pointer.
    See section 5.12, “For More Information,” on [page 290](chapter5.xhtml#pg_290)
    for a Wikipedia link on this subject. Of course, as just pointed out, not having
    to 16-byte align the stack pointer is another good reason for using a program-defined
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating your own stack has two drawbacks: you must dedicate one of the ARM’s
    registers for this purpose, and you must explicitly allocate storage for that
    stack yourself (the OS automatically allocates the hardware stack when it runs
    your program).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily allocate storage in the .data segment. A typical stack will
    have at least 128 to 256 bytes of storage. The following is a simple example that
    allocates a 256-byte stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: You may need more than 256 bytes of storage if you use automatic variables in
    your procedures; see section 5.4.1, “Activation Records,” on [page 244](chapter5.xhtml#pg_244)
    and section 5.5, “Local Variables,” on [page 250](chapter5.xhtml#pg_250).
  prefs: []
  type: TYPE_NORMAL
- en: Normally, stacks start at the end of their allocated space in memory and grow
    downward toward smaller memory addresses. Having the endSmallStk label at the
    end of the stack in this example gives you a handle with which to initialize your
    stack pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the ARM uses SP for its hardware stack pointer, you must use a different
    register for your program-defined stack pointer. This needs to be a nonvolatile
    register—you don’t want a function call like printf() to mess with your stack.
    As X30 is already used for LR and X29 is reserved for FP (see [Chapter 1](chapter1.xhtml)),
    X28 is a good choice for a user-defined stack pointer (USP). You can initialize
    it to point at the end of smallStk as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This leaves USP pointing just beyond the end of the stack, which is exactly
    what you want; the stack pointer should point at the current top of the stack,
    and when the stack is empty, as it is after initialization, the stack pointer
    isn’t pointing at a valid stack address.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push and pop data on the stack, use the same str and ldr instructions, along
    with the pre-indexed and post-indexed addressing modes, just as you would with
    the hardware stack. The only differences are that you specify the USP register
    (X28) and you don’t have to keep the stack aligned to 16 bytes (in fact, you technically
    don’t have to keep it aligned to anything, but it will be faster if you keep it
    word or dword aligned). Here’s how you can push the LR register into the user
    stack and pop it off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5-14 is a rewrite of Listing 5-4 using a software stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Upon entry into print40Spaces, the code pushes LR and X19 onto the software
    stack ❶, using an stp instruction to save both registers at the same time. The
    pre-indexed addressing mode decrements USP by 16; then this instruction stores
    the two 8-bit registers on the software stack. Just before returning, print40Spaces
    restores the LR and X19 registers from the software stack ❷, using an lpd instruction
    and the post-indexed addressing mode.
  prefs: []
  type: TYPE_NORMAL
- en: Although this program demonstrates using a software-controlled stack, it must
    still use the hardware stack for a couple of purposes. In particular, the printf()
    function will push its return address (and parameters, as it turns out) onto the
    hardware stack. Therefore, the main program sets up storage space on the hardware
    stack for this purpose ❸. The program must also preserve the USP register (X28)
    before initializing it to point at the end of the smallStack data area. The space
    just allocated on the hardware stack is the perfect place for this. As long as
    the code is saving USP there, it may as well save LR at the same time, since you
    must always write 16 bytes to the hardware stack.
  prefs: []
  type: TYPE_NORMAL
- en: Once the code has preserved USP’s value (because it is a nonvolatile register),
    the next step is to initialize USP with the address of the end of the smallStack
    memory buffer ❹. Loading the address of endSmallStk into USP accomplishes this.
    Once the stack is initialized, the code can use it; for example, this statement
    pushes nonvolatile register X19 onto the software stack ❺ (to preserve it for
    the C++ program).
  prefs: []
  type: TYPE_NORMAL
- en: Before leaving, the code pops the X19 nonvolatile register off the software
    stack to restore its value ❻. Finally, the main program restores USP and LR from
    the hardware stack (and cleans up allocated storage) before returning to the C++
    code ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to prove it really works, here’s the build command and sample output for
    the program in Listing 5-14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Listing 5-14 produces the same output as Listing 5-4.
  prefs: []
  type: TYPE_NORMAL
- en: 5.11 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered considerable material, including an introduction to assembly
    language programming style, basic Gas procedure syntax, local labels, calling
    and returning from procedures, register preservation, activation records, function
    results, and more. Armed with this information, you’re ready to learn how to write
    functions that calculate arithmetic results in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 5.12 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on the Creative Commons 4.0 Attribution license, see *[https://<wbr>creativecommons<wbr>.org<wbr>/licenses<wbr>/by<wbr>/4<wbr>.0<wbr>/](https://creativecommons.org/licenses/by/4.0/)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM developer site has more on the AARCH64 (ARM64) calling convention and
    ABI at *[https://<wbr>github<wbr>.com<wbr>/ARM<wbr>-software<wbr>/abi<wbr>-aa<wbr>/releases](https://github.com/ARM-software/abi-aa/releases)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wikipedia provides a useful entry on coroutines, generators, and iterators at
    *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Coroutine](https://en.wikipedia.org/wiki/Coroutine)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
