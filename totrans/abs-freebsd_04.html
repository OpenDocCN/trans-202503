<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_49"/><strong><span class="big">4</span><br/>START ME UP! THE BOOT PROCESS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">While FreeBSD boots easily and automatically when you turn on the power, understanding exactly what happens at each stage will make you a better system administrator. Intervention during the boot process is rarely necessary, but one day you’ll be glad you know how to do it. And once you’re comfortable with adjusting the boot process, you’ll find you can solve problems you’ve previously accepted and endured.</p>
<p class="indent">We’ll start by discussing how the system loader starts and gathering information from the loader. You can use the loader to change the early boot process, including booting alternate kernels and starting in single-user mode. We’ll cover serial consoles, a standard system management tool. The FreeBSD multiuser startup process is responsible for starting all the various <span epub:type="pagebreak" id="page_50"/>services that make your computer useful, and we’ll give attention to that as well. In addition, we’ll cover the information FreeBSD records about the boot process and how FreeBSD turns itself off without corrupting data.</p>
<div class="sidebar">
<p class="sidebart"><strong>RECURSION WARNING</strong></p>
<p class="spara">Some of the topics in this chapter reference material found in later chapters. Those later chapters, in turn, require that you understand this chapter first. There’s no good place to begin learning. If you don’t quite understand a part of this chapter, just skim over it and continue reading; it really will coalesce in your mind as you proceed.</p>
</div>
<p class="indent">The boot process itself can be divided into three main parts: the loader, single-user startup, and multiuser startup.</p>
<h3 class="h3" id="lev91"><strong>Power-On</strong></h3>
<p class="noindent">A computer needs enough brains to find and load its operating system. For many years, this facility came from the basic input/output system (BIOS). Newer systems use the Unified Extensible Firmware Interface (UEFI) instead of the BIOS. New installs should use UEFI. Other hardware platforms have console firmware or bootroms that perform the same function, but we’re focused on commodity hardware, so we’ll cover UEFI and BIOS.</p>
<h4 class="h4" id="lev92"><strong><em>Unified Extensible Firmware Interface</em></strong></h4>
<p class="noindent">UEFI is a replacement for the three-decades-old BIOS. Any new system will come with UEFI enabled and will expect to use it.</p>
<p class="indent">UEFI searches the boot drive for a partition marked as a UEFI boot partition. Despite what the special mark might imply, that partition contains only a FAT filesystem with a specific directory and file layout. UEFI executes the file <em>/EFI/BOOT/BOOTX64.EFI</em>. That file might be a fancy multi-OS boot loader, or it might dump you straight into an operating system. In FreeBSD, the UEFI boot fires up the boot loader, <em>/boot/loader.efi</em>.</p>
<p class="indent">UEFI is comparatively new. If your new system has trouble booting FreeBSD, you might try enabling a BIOS or “legacy” mode. If the system boots FreeBSD in BIOS mode but not with UEFI, please file a bug, as discussed in <a href="ch24.xhtml#ch24">Chapter 24</a>.<sup><a href="footnote.xhtml#ch04fn1" id="ch04fn1a">1</a></sup></p>
<h4 class="h4" id="lev93"><strong><em>Basic Input/Output System</em></strong></h4>
<p class="noindent">The primordial Intel PC used a basic input/output system (BIOS) with just enough brains to look for an operating system somewhere on a disk. A BIOS <span epub:type="pagebreak" id="page_51"/>searches for a disk partition marked active and then executes the first section of that partition. For FreeBSD, that chunk of data is called the <em>loader</em>. Every FreeBSD system has a reference copy of the loader as <em>/boot/loader</em>.</p>
<p class="indent">A BIOS has all sorts of limitations. The boot loader must reside in a very specific section of the disk. BIOS can’t boot from disks larger than 2.2TB. The target boot loader must be smaller than 512KB—huge by 1980 standards, yes, but paltry today. The installed loader is a binary, not a filesystem, so even minor changes require recompiling. UEFI has none of these limitations and offers modern features, like mouse support.</p>
<p class="indent">Ultimately, though, a BIOS and UEFI both have the goal of getting your system to the FreeBSD loader.</p>
<h3 class="h3" id="lev94"><strong>The Loader</strong></h3>
<p class="noindent">The <em>loader</em>, or <em>boot blocks</em>, loads the FreeBSD kernel and presents you with a menu before starting that kernel. The loader(8) program offers a menu of seven options on the left. A new FreeBSD system presents these options:</p>
<ol>
<li class="noindent">Boot Multi User [Enter]</li>
<li class="noindent">Boot Single User</li>
<li class="noindent">Escape to loader prompt</li>
<li class="noindent">Reboot</li>
<li class="noindent">Kernel: default/kernel (1 of 2)</li>
<li class="noindent">Configure Boot Options…</li>
<li class="noindent">Select Boot Environment…</li>
</ol>
<p class="indent">Each option highlights certain words or characters, such as <em>S</em> in “Boot Single User” and <small>ESC</small> in “Escape to loader prompt.” Select an option by pressing the highlighted character or the number.</p>
<p class="indent">The options at the top of the menu control how FreeBSD boots. We’ll look at each option in turn. If you wait 10 seconds, the loader automatically boots FreeBSD by default.</p>
<p class="indent">The options at the bottom half let you fine-tune the boot process. You can tweak how you want the system to boot, as we’ll discuss later, and then choose one of the preceding booting options.</p>
<h4 class="h4" id="lev95"><strong><em>Boot Multi User [Enter]</em></strong></h4>
<p class="noindent">This is a normal boot. Hit <small>ENTER</small> to boot immediately, skipping the 10-second delay.</p>
<h4 class="h4" id="lev96"><strong><em>Boot FreeBSD in Single-User Mode</em></strong></h4>
<p class="noindent"><em>Single-user mode</em> is a minimal startup mode that’s very useful on damaged systems, especially when the damage was self-inflicted. It’s the earliest point where FreeBSD can provide a command prompt, and it’s important enough to have its own section later in this chapter.</p>
<h4 class="h4" id="lev97"><span epub:type="pagebreak" id="page_52"/><strong><em>Escape to Loader Prompt</em></strong></h4>
<p class="noindent">The loader includes a command line interpreter, where you can issue commands to tweak your system to boot exactly the way you need. We’ll cover this in detail in “<a href="ch04.xhtml#lev106">The Loader Prompt</a>” on <a href="ch04.xhtml#page_55">page 55</a>.</p>
<h4 class="h4" id="lev98"><strong><em>Reboot</em></strong></h4>
<p class="noindent">Once more, this time with feeling!</p>
<p class="indent">Of these options, the most important are single-user mode and the loader prompt.</p>
<h3 class="h3" id="lev99"><strong>Single-User Mode</strong></h3>
<p class="noindent">FreeBSD can perform a minimal boot, called <em>single-user mode</em>, that loads the kernel and finds devices but doesn’t automatically set up your filesystems, start the network, enable security, or run any standard Unix services. Single-user mode is the earliest the system can possibly give you a command prompt.</p>
<p class="indent">Why use single-user mode? If a badly configured daemon hangs the boot, you can enter single-user mode to prevent it from starting. If you’ve lost your root password, you can boot into single-user mode to change it. If you need to shuffle critical filesystems around, again, single-user mode is the place to do it.</p>
<p class="indent">When you choose a single-user mode boot, you’ll see the regular system startup messages flow past. Before any programs start, however, the kernel offers you a chance to choose a shell. You can enter any shell on the root partition; I usually just take the default <em>/bin/sh</em>, but use <em>/bin/tcsh</em> if you prefer.</p>
<h4 class="h4" id="lev100"><strong><em>Disks in Single-User Mode</em></strong></h4>
<p class="noindent">In single-user mode, the root partition is mounted read-only and no other disks are mounted. (We’ll discuss mounting filesystems in <a href="ch10.xhtml#ch10">Chapter 10</a>, but for now just follow along.) Many of the programs that you’ll want to use are on partitions other than the root, so you’ll want them all mounted read-write and available. The way to do this varies depending on whether you’re using UFS or ZFS.</p>
<h5 class="h5" id="lev101"><strong>UFS in Single-User Mode</strong></h5>
<p class="noindent">To make all the filesystems listed in the filesystem table <em>/etc/fstab</em> usable, run the following commands:</p>
<p class="programs"># <span class="codestrong1">fsck -p</span><br/># <span class="codestrong1">mount -o rw /</span><br/># <span class="codestrong1">mount -a</span></p>
<p class="indent">The fsck(8) program “cleans” the filesystems and confirms that they’re internally consistent and that all the files that a disk thinks it has are actually present and accounted for.</p>
<p class="indent"><span epub:type="pagebreak" id="page_53"/>The root filesystem is mounted read-only. Whatever drove us to single-user mode probably requires changing the root filesystem. Remount the root filesystem read-write.</p>
<p class="indent">Finally, the <span class="literal">-a</span> flag to mount(8) activates every filesystem listed in <em>/etc/fstab</em> (see <a href="ch10.xhtml#ch10">Chapter 10</a>). If one of these filesystems is causing you problems, you can mount the desired filesystems individually by specifying them on the command line (for example, <span class="literal">mount /usr</span>). If you’re an advanced user with NFS filesystems configured (see <a href="ch13.xhtml#ch13">Chapter 13</a>), you’ll see error messages for those filesystems at this point because the network isn’t up yet. If the host has network filesystems in <em>/etc/fstab</em>, mount only the UFS filesystems as shown next.</p>
<p class="indent">If you have trouble mounting partitions by name, try using the device name instead. The device name for the root partition is probably <em>/dev/ad0s1a</em>. You’ll also need to specify a mount point for this partition. For example, to mount your first IDE disk partition as root, enter the command:</p>
<p class="programs"># <span class="codestrong1">mount /dev/ad0s1a /</span></p>
<p class="indent">If you have network filesystems on your server but your network isn’t up yet, you can mount all your local partitions by specifying the filesystem type. Here, we mount all of the local filesystems of type UFS, which is FreeBSD’s default filesystem type:</p>
<p class="programs"># <span class="codestrong1">mount -a -t ufs</span></p>
<p class="indent">You can now access your UFS filesystems.</p>
<h5 class="h5" id="lev102"><strong>ZFS in Single-User Mode</strong></h5>
<p class="noindent">To make all of your ZFS datasets available, use <span class="literal">zfs mount</span>. You can either mount individual datasets by name or mount everything that’s marked as mountable with <span class="literal">-a</span>.</p>
<p class="programs"># <span class="codestrong1">zfs mount -a</span></p>
<p class="indent">ZFS will perform its usual integrity checks before mounting the datasets.</p>
<p class="indent">Most of the datasets will be exactly as accessible as in multiuser mode, but the dataset mounted as root will still be read-only. Turn that off. Here, I’m setting the root dataset to read-write on a default FreeBSD install.</p>
<p class="programs"># <span class="codestrong1">zfs set readonly=off zroot/ROOT/default</span></p>
<p class="indent">You can now change the filesystem.</p>
<h4 class="h4" id="lev103"><strong><em>Programs Available in Single-User Mode</em></strong></h4>
<p class="noindent">The commands available for your use depend on which partitions are mounted. Some basic commands are available on the root partition in <em>/bin</em> and <em>/sbin</em>, and they’re available even if root is mounted read-only. Others <span epub:type="pagebreak" id="page_54"/>live in <em>/usr</em> and are inaccessible until you mount that partition. (Take a look at <em>/bin</em> and <em>/sbin</em> on your system to get an idea of what you’ll have to work with when things go bad.)</p>
<p class="indent">If you’ve scrambled your shared library system (see <a href="ch17.xhtml#ch17">Chapter 17</a>), none of these programs will work. If you’re that unlucky, FreeBSD provides statically linked versions of many core utilities in the <em>/rescue</em> directory.</p>
<h4 class="h4" id="lev104"><strong><em>The Network in Single-User Mode</em></strong></h4>
<p class="noindent">If you want to have network connectivity in single-user mode, use the shell script <em>/etc/netstart</em>. This script calls the appropriate scripts to start the network, gives IP addresses to interfaces, and enables packet filtering and routing. If you want some, but not all, of these services, you’ll need to read that shell script and execute the appropriate commands manually.</p>
<h4 class="h4" id="lev105"><strong><em>Uses for Single-User Mode</em></strong></h4>
<p class="noindent">In single-user mode, your access to the system is limited only by your knowledge of FreeBSD and Unix.</p>
<p class="indent">For example, if you’ve forgotten your root password, you can reset it from single-user mode:</p>
<p class="programs"># <span class="codestrong1">passwd</span><br/>Changing local password for root<br/>New Password:<br/>Retype New Password:<br/>#</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>You’ll notice that you weren’t asked for the old root password. In single-user mode, you’re automatically root, and passwd(8) doesn’t ask root for any password.</em></p>
</div>
<p class="indent">Or, if you find that there’s a typo in <em>/etc/fstab</em> that confuses the system and makes it unbootable, you can mount the root partition with the device name and then edit <em>/etc/fstab</em> to resolve the issue.</p>
<p class="indent">If you have a program that panics the system on boot and you need to stop that program from starting again, you can either edit <em>/etc/rc.conf</em> to disable the program or set the permissions on the startup script so that it can’t execute.</p>
<p class="programs"># <span class="codestrong1">chmod a-x /usr/local/etc/rc.d/program.sh</span></p>
<p class="indent">We’ll discuss third-party programs (ports and packages) in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>
<p class="indent">You need to understand single-user mode to be a successful sysadmin, and we’ll refer to it throughout this book. For now, though, let’s look at the loader prompt.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_55"/><strong>SYSTEM FAILURES VERSUS HUMAN FAILINGS</strong></p>
<p class="spara">There’s a reason all of these examples involve recovering from human errors. Hardware failures aren’t common, and FreeBSD failures, even less so. If it weren’t for human error, our computers would almost never let us down. As you learn more about FreeBSD, you’ll be more and more capable in single-user mode.</p>
</div>
<h3 class="h3" id="lev106"><strong>The Loader Prompt</strong></h3>
<p class="noindent">The loader prompt allows you to make basic changes to your computer’s boot environment and the variables that must be configured early in the boot process. It’s not a Unix-like environment; it’s cramped and supports only a minimal feature set. When you escape to a loader prompt (the third option in the boot menu), you’ll see the following:</p>
<p class="programs">Type '?' for a list of commands, 'help' for more detailed help.<br/>OK</p>
<p class="indent">This is the loader prompt. While the word <em>OK</em> might be friendly and reassuring, it’s one of the few friendly things about the loader environment. This isn’t a full-featured operating system; it’s a tool for configuring a system boot that’s not intended for the ignorant nor the faint of heart. Any changes you make at the loader prompt affect only the current boot. To undo changes, reboot again. (We’ll see how to make loader changes permanent in the next section.)</p>
<p class="indent">To see all available commands, enter a question mark.</p>
<p class="programs">OK <span class="codestrong1">?</span><br/>Available commands:<br/>  heap             show heap usage<br/>  reboot           reboot the system<br/>  lszfs            list child datasets of a zfs dataset<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">Many loader commands aren’t useful to anyone except a developer, so we’ll focus on the commands useful to a system administrator.</p>
<h4 class="h4" id="lev107"><strong><em>Viewing Disks</em></strong></h4>
<p class="noindent">To view the disks that the loader knows about, use <span class="literal">lsdev</span>.</p>
<p class="programs">   OK <span class="codestrong1">lsdev</span><br/><span class="ent">➊</span> cd devices:<br/>   disk devices:<br/><span class="ent">➋</span> disk0:    BIOS drive C (33554432 X 512):<br/>      <span class="ent">➌</span> disk0p1: FreeBSD boot<br/>         disk0p2: FreeBSD swap<br/><span epub:type="pagebreak" id="page_56"/>       disk0p3: FreeBSD ZFS<br/><span class="ent">➍</span> zfs devices:<br/>       zfs:zroot</p>
<p class="indent">The loader checks for CD drives <span class="ent">➊</span> and doesn’t find any. (The loader finds CD drives only if you boot from a CD, so don’t be alarmed by this.) It finds a hard drive, known to the BIOS as drive C <span class="ent">➋</span>. It then describes the partitions on that hard drive. As we’ll see in <a href="ch10.xhtml#ch10">Chapter 10</a>, GPT partitions identify partitions with the letter <em>p</em> and a number. The partition disk0p1 <span class="ent">➌</span> is a FreeBSD boot partition used to bootstrap FreeBSD from the BIOS. You might find this knowledge useful on an unfamiliar system that’s having trouble booting. The loader can also identify the ZFS pools <span class="ent">➍</span> on the host.</p>
<h4 class="h4" id="lev108"><strong><em>Loader Variables</em></strong></h4>
<p class="noindent">The loader has variables set within the kernel and by a configuration file. View these variables and their settings with the <span class="literal">show</span> command, and use the spacebar to advance to the next page.</p>
<p class="programs">OK <span class="codestrong1">show</span><br/>LINES=24<br/>acpi.oem=VBOX<br/>acpi.revision=2<br/>acpi.rsdp=0x000e0000<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">These values include low-level kernel tunables and information gleaned from the hardware BIOS or UEFI. We’ll see a partial list of loader variables in “<a href="ch04.xhtml#lev111">Loader Configuration</a>” on <a href="ch04.xhtml#page_57">page 57</a>, and additional values will be brought up throughout the book in the appropriate sections.</p>
<p class="indent">You can show specific variables by name. Sadly, you can’t show all of a keyword’s sub-variables. A command like <span class="literal">show acpi.oem</span> works, but <span class="literal">show acpi</span> or <span class="literal">show acpi.*</span> doesn’t.</p>
<p class="indent">Change a value for a single boot with the <span class="literal">set</span> command. For example, to change the <span class="literal">console</span> setting to <span class="literal">comconsole</span>, you’d enter:</p>
<p class="programs">OK <span class="codestrong1">set console=comconsole</span></p>
<p class="indent">The loader lets you change variables that really shouldn’t change. Setting acpi.revision to 4 won’t suddenly upgrade your system to ACPI version 4, and you can’t change hard drives with a software setting.</p>
<h4 class="h4" id="lev109"><strong><em>Reboot</em></strong></h4>
<p class="noindent">You didn’t mean to get into the loader? Start over.</p>
<h4 class="h4" id="lev110"><span epub:type="pagebreak" id="page_57"/><strong><em>Booting from the Loader</em></strong></h4>
<p class="noindent">Now that you’ve twiddled your system’s low-level settings, you probably want to boot the system. Use the boot(8) command. You can adjust the boot further using the boot flags discussed in the man page.</p>
<p class="indent">Once your system boots just the way you need it to, you’ll probably want to make those settings permanent. FreeBSD lets you do this through the loader configuration file.</p>
<h3 class="h3" id="lev111"><strong>Loader Configuration</strong></h3>
<p class="noindent">Make loader setting changes permanent with the configuration file <em>/boot/loader.conf</em>. Settings in this file are fed directly into the boot loader at system startup. Of course, if you enjoy being at your console every time the system boots, then don’t bother with this!</p>
<p class="indent">The loader has a default configuration file, <em>/boot/defaults/loader.conf</em>. We override many of the values here.</p>
<p class="indent">If you look at the default loader configuration, you’ll see many options that resemble variables listed in the loader. For example, here we can set the name of the console device:</p>
<p class="programs">console="vidconsole"</p>
<p class="indent">Throughout the FreeBSD documentation, you’ll see references to <em>boot-time tunables</em> and <em>loader settings</em>. All of these are set in <em>loader.conf</em>, which includes many sysctl values that are read-only once the system is up and kicking. (For more on tunables and sysctls, see <a href="ch06.xhtml#ch06">Chapter 6</a>.) Here, we force the kernel variable <span class="literal">kern.maxusers</span> to <span class="literal">32</span>.</p>
<p class="programs">kern.maxusers="32"</p>
<p class="indent">Some of these variables don’t have a specific value set in <em>loader.conf</em>; instead, they appear as empty quotes. This means that the loader normally lets the kernel set this value, but if you want to override the kernel’s setting, you can.</p>
<p class="programs">kern.nbuf=""</p>
<p class="indent">The kernel has an idea of what the value of <span class="literal">kern.nbuf</span> should be, but you can have the loader dictate a different value if you must.</p>
<p class="indent">We’ll discuss system tuning via the boot loader in the appropriate section—for example, kernel values will be discussed in <a href="ch06.xhtml#ch06">Chapter 6</a>, where they’ll make something resembling sense—but here are some commonly used loader values that affect the appearance and operation of the loader itself and basic boot functionality. As FreeBSD matures, the developers introduce new loader values and alter the functionality of old ones, so be sure to check <em>/boot/defaults/loader.conf</em> on your installation for the current list.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_58"/><span class="codestrong">boot_verbose="NO"</span></p>
<p class="hang">This value toggles the verbose boot mode that you can reach through the boot menu. In a standard boot, the kernel prints out a few basic notes about each device as it identifies system hardware. When you boot in verbose mode, the kernel tells each device driver to print out any and all information it can about each device as well as display assorted kernel-related setup details. Verbose mode is useful for debugging and development, but not generally for day-to-day use.</p>
<p class="noindentt"><span class="codestrong">autoboot_delay="10"</span></p>
<p class="hang">This value indicates the number of seconds between the display of the boot menu and the automatic boot. I frequently turn this down to 2 or 3 seconds, as I want my machines to come up as quickly as possible.</p>
<p class="noindentt"><span class="codestrong">beastie_disable="NO"</span></p>
<p class="hang">This value controls the appearance of the boot menu (originally, an ASCII art image of the BSD “Beastie” mascot decorated the boot menu). If set to <span class="literal">YES</span>, the boot menu will not appear.</p>
<p class="noindentt"><span class="codestrong">loader_logo="fbsdbw"</span></p>
<p class="hang">This value allows you to choose which logo appears to the right of the boot menu. The <span class="literal">fbsdbw</span> option gives you the default FreeBSD logo in ASCII art. Other options include <span class="literal">beastiebw</span> (the original logo), <span class="literal">beastie</span> (the logo in color), and <span class="literal">none</span> (no logo).</p>
<h3 class="h3" id="lev112"><strong>Boot Options</strong></h3>
<p class="noindent">The boot menu also presents three options: choosing a kernel, setting boot options, and selecting a boot environment. We’ll discuss each of these in an appropriate section, but here’s a bit to orient you.</p>
<p class="indent">A host can have multiple kernels in its <em>/boot</em> directory. Hitting the <em>Kernel</em> option tells the loader to cycle between the available options. To have a kernel appear as an option, list it in <em>loader.conf</em> in the kernels variable.</p>
<p class="programs">KERNELS="kernel kernel.old kernel.GENERIC"</p>
<p class="indent">The menu recognizes kernels only in directories beginning with <em>/boot/kernel</em>. If you have a kernel in <em>/boot/gerbil</em>, you’ll have to load it from the loader prompt.</p>
<p class="indent">FreeBSD supports a number of boot options. Selecting the <em>Configure Boot Options</em> item brings up the most popular.</p>
<p class="noindentt"><strong>Load System Defaults</strong></p>
<p class="hang">You mucked with your settings and want to undo all that? Choose this. You can at least boot the system to single-user mode and fix your <em>loader.conf</em>.</p>
<p class="noindentt"><span epub:type="pagebreak" id="page_59"/><strong>ACPI Support</strong></p>
<p class="hang">ACPI is the Advanced Configuration and Power Interface, an Intel/Toshiba/Microsoft standard for hardware configuration. It replaces and subsumes a whole bunch of obscure standards. ACPI has been a standard for many years now, but if a particular piece of hardware has trouble running FreeBSD, you can turn it off and see what happens. If you even think of trying this option, also read <a href="ch24.xhtml#ch24">Chapter 24</a> and file a bug report.</p>
<p class="noindentt"><strong>Safe Mode</strong></p>
<p class="hang">FreeBSD’s <em>safe mode</em> turns on just about every conservative option in the operating system. It turns off DMA and write caching on hard disks, limiting their speed but increasing their reliability. It turns off ACPI. 32-bit systems disable SMP. USB keyboards no longer work in safe mode. This option is useful for debugging older hardware.</p>
<p class="noindentt"><strong>Verbose</strong></p>
<p class="hang">The FreeBSD kernel probes every piece of hardware as it boots. Most of the information discovered is irrelevant to day-to-day use, so the boot loader doesn’t display it. When you boot in verbose mode, FreeBSD prints all the details it can about every system setting and attached device. The information will be available later in <em>/var/run/dmesg.boot</em>, as discussed in the next section. I encourage you to try verbose mode on new machines, just to glimpse the system’s complexity.</p>
<p class="indentt">Finally, the <em>Select Boot Environment</em> option lets you choose between ZFS boot environments, as discussed in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>
<h3 class="h3" id="lev113"><strong>Startup Messages</strong></h3>
<p class="noindent">A booting FreeBSD system displays messages indicating the hardware attached to the system, the operating system version, and the status of various programs and services as they start. These messages are important when you first install your system and when you do troubleshooting. The boot messages always start off the same way, with a statement listing the copyrights for the FreeBSD Project and the Regents of the University of California:</p>
<p class="programs">Copyright (c) 1992-2018 The FreeBSD Project.<br/>Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994<br/>    The Regents of the University of California. All rights reserved.<br/>FreeBSD is a registered trademark of The FreeBSD Foundation.<br/>FreeBSD 12.0-CURRENT #3 r320502: Fri Jun 30 13:48:50 EDT 2017<br/>    root@storm:/usr/obj/usr/src/sys/GENERIC amd64<br/>FreeBSD clang version 4.0.0 (tags/RELEASE_400/final 297347) (based on LLVM 4.0.0)</p>
<p class="indent">In addition, you get a notice of the version of FreeBSD that’s booting, along with the date and time it was compiled and the compiler used. You can also see who compiled this kernel, what machine it was built on, and <span epub:type="pagebreak" id="page_60"/>even where in the filesystem this kernel was built. If you build a lot of kernels, this information can be invaluable when trying to identify exactly what system features are available.</p>
<p class="programs">WARNING: WITNESS option enabled, expect reduced performance.</p>
<p class="indent">The kernel will print out diagnostic messages throughout the boot process. The preceding message means that I have debugging and fault-identifying code enabled in this particular kernel, and my performance will suffer as a result. In this case, I don’t care about the performance impact, for reasons which will become clear momentarily.</p>
<p class="programs">Timecounter "i8254" frequency 1193182 Hz quality 100</p>
<p class="indent">This message identifies a particular piece of hardware. The <em>timecounter</em>, or <em>hardware clock</em>, is a special piece of hardware, and while your computer needs one, it’s such a low-level device that the end user really can’t do much with it directly. Now and then, you’ll see messages like this for hardware that isn’t directly visible to the user but is vital to the system. The boot messages dance between showing too much detail and obscuring details that might be critical. For example, it’ll also show all the information it can about the CPU in the system:</p>
<p class="programs">CPU: Intel(R) Xeon(R) CPU E5-1620 v2 @ <span class="ent">➊</span>3.70GHz (3700.08-MHz K8-class CPU)<br/>  Origin="GenuineIntel"  Id=0x306e4  Family=0x6  Model=0x3e  Stepping=4<br/>              <span class="ent">➋</span> Features=0xbfebfbff&lt;FPU,VME,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,<br/>CMOV,PAT,PSE36,CLFLUSH,DTS,ACPI,MMX,FXSR,SSE,SSE2,SS,HTT,TM,PBE&gt;<br/>  Features2=0x7fbee3ff&lt;SSE3,PCLMULQDQ,DTES64,MON,DS_CPL,VMX,SMX,EST,TM2,SSSE3,CX16,<br/>xTPR,PDCM,PCID,DCA,SSE4.1,SSE4.2,x2APIC,POPCNT,TSCDLT,AESNI,XSAVE,OSXSAVE,AVX,F16C,RDRAND&gt;<br/>  AMD Features=0x2c100800&lt;SYSCALL,NX,Page1GB,RDTSCP,LM&gt;<br/>  AMD Features2=0x1&lt;LAHF&gt;<br/>  Structured Extended Features=0x281&lt;FSGSBASE,SMEP,ERMS&gt;<br/>  XSAVE Features=0x1&lt;XSAVEOPT&gt;<br/>  VT-x: PAT,HLT,MTF,PAUSE,EPT,UG,VPID,VID,PostIntr<br/>  TSC: P-state invariant, performance statistics</p>
<p class="indent">You probably didn’t know that a simple CPU could have so many details and features, did you? But when you file a trouble report that advanced features don’t work, a developer might respond by asking whether your CPU has a particular feature.</p>
<p class="indent">Here’s why I’m not worried about the performance hit caused by the <span class="literal">WITNESS</span> option shown earlier: this box is pretty darn fast <span class="ent">➊</span> and supports a whole bunch of features important to modern CPUs <span class="ent">➋</span>. While I certainly want all the performance I paid for, I also want to catch any problems when they happen. I want to be able to file good bug reports on those problems, so the developers will listen to my problem report. That’s <em>why</em> I’m running a development version of FreeBSD that ships with WITNESS enabled, after all!</p>
<p class="programs">FreeBSD/SMP: Multiprocessor System Detected: 8 CPUs</p>
<p class="indent"><span epub:type="pagebreak" id="page_61"/>Here, the kernel announces that it’s found all eight CPU cores and is ready to manage them. I have CPU power to spare and a fair amount of memory as well.</p>
<p class="programs"><span class="ent">➊</span> real memory  = 34359738368 (32768 MB)<br/><span class="ent">➋</span> avail memory = 33207656448 <span class="ent">➌</span>(31669 MB)</p>
<p class="indent">The <em>real</em> memory <span class="ent">➊</span> is the amount of RAM physically installed in the computer, while the <em>avail</em> memory <span class="ent">➋</span> is the amount of memory left over after the kernel is loaded. I have 31,669MB of RAM <span class="ent">➌</span> available for real work, which more than suffices for the load on this system.</p>
<p class="programs"><span class="ent">➊</span>ioapic0 &lt;Version 2.0&gt; <span class="ent">➋</span>irqs 0-23 on motherboard<br/><span class="ent">➌</span>ioapic1 &lt;Version 2.0&gt; irqs 24-47 on motherboard</p>
<p class="indent">Here’s a fairly typical device entry. This device is known as ioapic, and the kernel has found that this hardware is version 2.0 and has extra information associated with it <span class="ent">➋</span>. What’s more, we’ve found two devices of that type, numbered 0 <span class="ent">➊</span> and 1 <span class="ent">➌</span>. (All devices are numbered starting with zero.) You can find out more about the device by reading the man page for the device driver. Almost all—but not all—device drivers have man pages.</p>
<p class="programs">usbus0: EHCI version 1.0<br/>usbus0 on ehci0<br/>usbus0: 480Mbps High Speed USB v2.0</p>
<p class="indent">Not all device drivers print all their information on a single line. Here, we have a single device, usbus, that takes up three lines with just a single instance of the device. The only way to know that this is a single USB bus rather than three separate ones is to check the number of the device. All of these are for device number zero, so it’s a single device.</p>
<p class="programs"><span class="ent">➊</span> pci0: &lt;simple comms&gt; at device 22.0 (no driver attached)<br/><span class="ent">➋</span> pcib8: &lt;ACPI PCI-PCI bridge&gt; irq 17 at device 28.0 on <span class="ent">➌</span>pci0<br/><span class="ent">➍</span> pci8: &lt;ACPI PCI bus&gt; on <span class="ent">➎</span>pcib8</p>
<p class="indent">One interesting thing about the boot messages is that they display how your computer’s components are attached to one another. Here, we have pci0 <span class="ent">➊</span>, a PCI interface directly on the mainboard. Then, there’s pcib8 <span class="ent">➋</span>, PCI bridge number eight attached to pci0 <span class="ent">➌</span>. We also find PCI bus pci8 <span class="ent">➍</span> attached to that PCI bridge <span class="ent">➎</span>. As you read on, you’ll find individual devices attached to that bus. You might not be equipped to do much with this information now, but you’ll find that having it available will be valuable when you have to troubleshoot a problem.</p>
<p class="programs"><span class="ent">➊</span>em0: &lt;Intel(R) PRO/<span class="ent">➋</span>1000 Network Connection&gt; port 0xd000-0xd01f mem <br/>0xfba00000-0xfba1ffff,0xfba20000-0xfba23fff irq 18 at device 0.0 on pci9</p>
<p class="indent"><span epub:type="pagebreak" id="page_62"/>This entry shows em0, a network card of type em(4) <span class="ent">➊</span>, and indicates that the card speaks gigabit Ethernet <span class="ent">➋</span>. We also see all sorts of information about its memory address, IRQ, and PCI bus attachment.</p>
<p class="indent">Every device on your computer has one or more entries like these. Taken as a whole, they describe your computer’s hardware in reasonable detail. If you boot in verbose mode, you’ll see even more detail—probably far more than you want.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE BOOT MESSAGES FILE</strong></p>
<p class="spara">While the boot information is handy, chances are it’ll disappear from the screen by the time you need it. For future reference, FreeBSD stores boot messages in the file <em>/var/run/dmesg.boot</em>. This means that you can inspect your kernel’s hardware messages even after your system has been up and running for months.</p>
</div>
<p class="indent">One key thing that the kernel displays in the boot messages is the device name for each piece of hardware. This is critical information for managing your system. Every piece of hardware has a device node name, and to configure it, you’ll need to know that name. For example, earlier we saw an entry for an Ethernet card called em0. The card uses the em(4) driver, and the first device controlled by this driver has number zero. Your second device of this type would be em1, then em2, and so on.</p>
<p class="indent">Most devices that can be configured or managed have a device node entry somewhere under <em>/dev</em>. For example, the first optical drive is represented by the file <em>/dev/cd0</em>. These files are called <em>device nodes</em>, and they’re a convenient way to address a particular piece of hardware. Most device nodes can’t be directly accessed as a regular file; you can’t cat(1) a device node or copy another file to it. However, device nodes are used as arguments to specialized programs. For example, the hard drive that showed up at boot as ada4 is the same as the device node <em>/dev/ada4</em>. When you want to mount that hard drive, you can use the device node name and be sure you’re getting that exact piece of hardware.</p>
<h3 class="h3" id="lev114"><strong>Multiuser Startup</strong></h3>
<p class="noindent">Beyond single-user mode, you’ll find multiuser mode. This is the standard operating mode for a Unix-like OS. If you’re doing real work, your system is in multiuser mode.</p>
<p class="indent">When FreeBSD finishes inspecting the hardware and attaching all the device drivers appropriately, it runs the shell script <em>/etc/rc</em>. This script mounts all filesystems, brings up the network interfaces, configures device nodes, identifies available shared libraries, and does all the other work necessary to make a system ready for normal work. Most systems have different startup <span epub:type="pagebreak" id="page_63"/>requirements; while almost every server needs to mount a hard drive, a web server’s operating requirements are very different from those of a database server, even if it’s running on absolutely identical hardware. This means that <em>/etc/rc</em> must be extremely flexible. It achieves flexibility by delegating everything to other shell scripts responsible for specific aspects of the system.</p>
<p class="indent">The <em>/etc/rc</em> script is controlled by the files <em>/etc/defaults/rc.conf</em> and <em>/etc/rc.conf</em>.</p>
<h4 class="h4" id="lev115"><strong><em>/etc/rc.conf, /etc/rc.conf.d, and /etc/defaults/rc.conf</em></strong></h4>
<p class="noindent">Much like the loader configuration file, the configuration of <em>/etc/rc</em> is split between two files: the default settings file, <em>/etc/defaults/rc.conf</em>, and the local settings file, <em>/etc/rc.conf</em>. Settings in <em>/etc/rc.conf</em> override any values given in <em>/etc/defaults/rc.conf</em>, exactly as with the loader.</p>
<p class="indent">The <em>/etc/defaults/rc.conf</em> file is huge and contains quite a few variables, frequently called <em>knobs</em>, or <em>tunables</em>. We aren’t going to discuss all of them, not only because knobs are added continually and such a list would be immediately obsolete but also because quite a few knobs aren’t commonly used on servers. Almost everything in a standard FreeBSD system has one or more <em>rc.conf</em> knobs, from your keyboard map to TCP/IP behavior. For a complete, up-to-date list, read rc.conf(5). To change <em>rc.conf</em> settings, you can either use a text editor or sysrc(8).</p>
<h5 class="h5" id="lev116"><strong>sysrc(8)</strong></h5>
<p class="noindent">While editing <em>rc.conf</em> by hand works just fine, in this age of cloud computing, it’s not sustainable across large numbers of machines. If you must change dozens of servers, you need a reliable way to alter the system without either manually editing each server’s config or resorting to sed/awk hackery.<sup><a href="footnote.xhtml#ch04fn2" id="ch04fn2a">2</a></sup></p>
<p class="indent">FreeBSD includes sysrc(8), a command line program to consistently and safely alter <em>/etc/rc.conf</em> and friends from the command line. Additionally, sysrc(8) can display information about your system’s non-default settings.</p>
<p class="indent">Start by using <span class="literal">-a</span> to ask sysrc(8) what it knows about your host.</p>
<p class="programs"># <span class="codestrong1">sysrc -a</span><br/>clear_tmp_enable: YES<br/>defaultrouter: 203.0.113.1<br/>dumpdev: AUTO<br/>keymap: us.dvorak.kbd<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">You’ll get a list of all non-default <em>/etc/rc.conf</em> settings.</p>
<p class="indent">To have sysrc(8) enable a service, give it the variable name, an equals sign, and the new value.</p>
<p class="programs"># <span class="codestrong1">sysrc rc_startmsgs=NO</span><br/>rc_startmsgs: YES -&gt; NO</p>
<p class="indent"><span epub:type="pagebreak" id="page_64"/>The variable <span class="literal">rc_startmsgs</span> is now set to <span class="literal">no</span>.</p>
<p class="indent">Remember that sysrc(8) is a tool for changing <em>rc.conf</em>, not for configuring FreeBSD. It does no validity checking. One of my very junior sysadmins really doesn’t want Bert logging in, and he took some bad advice on how to prevent that.</p>
<p class="programs"># <span class="codestrong1">sysrc bert=no</span></p>
<p class="indent">While this code sets <span class="literal">bert="no"</span> in <em>/etc/rc.conf</em>, this variable doesn’t do anything. Remove it with the <span class="literal">-x</span> flag.</p>
<p class="programs"># <span class="codestrong1">sysrc -x bert</span></p>
<p class="indent">Many FreeBSD configuration files closely resemble <em>rc.conf</em>. You can use sysrc(8) to manage them by adding the <span class="literal">-f</span> flag and the file name.</p>
<p class="programs"># <span class="codestrong1">sysrc -af /boot/loader.conf</span></p>
<p class="indent">Should you edit <em>rc.conf</em> or use sysrc(8)? If you’re making manual changes, then use whichever you prefer. Automation should err on the side of sysrc(8). This book mixes examples of both.</p>
<h5 class="h5" id="lev117"><strong>/etc/rc.conf.d/</strong></h5>
<p class="noindent">If you use a server configuration system such as Puppet or Ansible, you might trust copying entire files more than editing them. Use <em>/etc/rc.conf.d/</em> files to enable services through such tools.</p>
<p class="indent">To manage a service in <em>/etc/rc.conf.d/</em>, create a file named after the service. That is, to manage bsnmpd(8) you’d create <em>/etc/rc.conf.d/bsnmpd</em>. Enable or disable that service in this file.</p>
<p class="programs">bsnmpd_enable=YES</p>
<p class="indent">I normally use Ansible’s service enabling features that directly alter <em>/etc/rc.conf</em> rather than <em>/etc/rc.conf.d</em>, but use whatever you prefer.</p>
<p class="indent">The next few sections illustrate the types of things you can enable and disable in <em>/etc/rc.conf</em>. Each appears in <em>/etc/defaults/rc.conf</em> and can be overridden by an <em>/etc/rc.conf</em> entry. Each variable appears with its default setting.</p>
<h5 class="h5" id="lev118"><strong>Startup Options</strong></h5>
<p class="noindent">The following <em>rc.conf</em> options control how FreeBSD configures itself and starts other programs. These far-reaching settings affect how all other system programs and services run.</p>
<p class="indent">If you’re having a problem with the startup scripts themselves, you might enable debugging on <em>/etc/rc</em> and its subordinate scripts. This can provide additional information about why a script is or isn’t starting.</p>
<p class="programs">rc_debug="NO"</p>
<p class="indent"><span epub:type="pagebreak" id="page_65"/>If you don’t need the full debugging output but would like some additional information about the <em>/etc/rc process</em>, enable informational messages with <span class="literal">rc_info</span>:</p>
<p class="programs">rc_info="NO"</p>
<p class="indent">When the boot process hits multiuser startup, it prints out a message for each daemon it starts. Remove those messages with the <span class="literal">rc_startmsgs</span> option.</p>
<p class="programs">rc_startmsgs="NO"</p>
<h5 class="h5" id="lev119"><strong>Filesystem Options</strong></h5>
<p class="noindent">FreeBSD can use memory as a filesystem, as we’ll discuss in <a href="ch13.xhtml#ch13">Chapter 13</a>. One common use for this feature is to make <em>/tmp</em> really fast by using memory rather than a hard drive as its backend. Once you’ve read <a href="ch13.xhtml#ch13">Chapter 13</a>, you might consider implementing this. Variables in <em>rc.conf</em> let you enable a memory-backed <em>/tmp</em> and set its size transparently and painlessly. You can also choose the options FreeBSD will use to complete the filesystem. (The impatient among you are probably wondering what the <span class="literal">-S</span> flag means. It means <em>disable soft updates</em>. If you have no idea what this means, either, wait for <a href="ch11.xhtml#ch11">Chapter 11</a>.) If you want to use a memory filesystem <em>/tmp</em>, set <span class="literal">tmpmfs</span> to <span class="literal">YES</span> and set <span class="literal">tmpsize</span> to the desired size of your <em>/tmp</em>.</p>
<p class="programs">tmpmfs="AUTO"<br/>tmpsize="20m"<br/>tmpmfs_flags="-S"</p>
<p class="indent">Another popular FreeBSD filesystem feature is its integrated encrypted partitions. FreeBSD supports two different filesystem encryption systems out of the box: GBDE and GELI. <em>GEOM-Based Disk Encryption (GBDE)</em> was FreeBSD’s first encrypted filesystem designed for military-grade use. GELI is a little more friendly and complies with different standards than GBDE. (You definitely want to read <a href="ch23.xhtml#ch23">Chapter 23</a> before enabling either of these!)</p>
<p class="programs">geli_devices=""<br/>geli_tries=""<br/>geli_default_flags=""<br/>geli_autodetach="YES"</p>
<p class="indent">By default, FreeBSD mounts the root partition read-write upon achieving multiuser mode. If you want to run in read-only mode instead, you can set the following variable to <span class="literal">NO</span>. Many people consider this more secure, but a read-only root can interfere with operation of certain software, and it’ll certainly prevent you from editing any files on the root partition!</p>
<p class="programs">root_rw_mount="YES"</p>
<p class="indent"><span epub:type="pagebreak" id="page_66"/>When a booting FreeBSD attempts to mount its filesystems, it checks them for internal consistency. If the kernel finds major filesystem problems, it can try to fix them automatically with <span class="literal">fsck -y</span>. While this is necessary in certain situations, it’s not entirely safe. (Be sure to read <a href="ch11.xhtml#ch11">Chapter 11</a> very carefully before enabling this!)</p>
<p class="programs">fsck_y_enable="NO"</p>
<p class="indent">The kernel might also find minor filesystem problems, which it resolves on the fly using a <em>background fsck</em> while the system is running in multiuser mode, as discussed in <a href="ch11.xhtml#ch11">Chapter 11</a>. There are legitimate concerns about the safety of using this feature in certain circumstances. You can control the use of background fsck and set how long the system will wait before beginning the background fsck.</p>
<p class="programs">background_fsck="YES"<br/>background_fsck_delay="60"</p>
<h5 class="h5" id="lev120"><strong>Miscellaneous Network Daemons</strong></h5>
<p class="noindent">FreeBSD includes many smaller programs, or daemons, that run in the background to provide specific services. We’ll cover quite a few of these integrated services throughout the book, but here are a few specific ones that’ll be of interest to experienced system administrators. One popular daemon is syslogd(8). Logs are a Good Thing. Logs are so very, <em>very</em> good that large parts of <a href="ch21.xhtml#ch21">Chapter 21</a> are devoted to the topic of logging with, for, by, and on FreeBSD.</p>
<p class="programs">syslogd_enable="YES"</p>
<p class="indent">Once you’ve decided to run the logging daemon, you can choose exactly how it’ll run by setting command line flags for it. FreeBSD will use these flags when starting the daemon. For all the programs included in <em>rc.conf</em> that can take command line flags, the flags are given in this format:</p>
<p class="programs">syslogd_flags="-s"</p>
<p class="indent">Another popular daemon is inetd(8), the server for small network services. (We cover inetd in <a href="ch20.xhtml#ch20">Chapter 20</a>.)</p>
<p class="programs">inetd_enable="NO"</p>
<p class="indent">Most systems use the Secure Shell (SSH) daemon for remote logins. If you want to connect to your system remotely over the network, you’ll almost certainly need SSH services.</p>
<p class="programs">sshd_enable="NO"</p>
<p class="indent"><span epub:type="pagebreak" id="page_67"/>While the SSH daemon can be configured via the command line, you’re generally better off using the configuration files in <em>/etc/ssh/</em>. See <a href="ch20.xhtml#ch20">Chapter 20</a> for details.</p>
<p class="programs">sshd_flags=""</p>
<p class="indent">FreeBSD also incorporates extensive time-keeping software that functions to ensure the system clock remains synchronized with the rest of the world. You’ll need to configure this for it to be useful; we’ll cover that in <a href="ch20.xhtml#ch20">Chapter 20</a>.</p>
<p class="programs">ntpd_enable="NO"<br/>ntpd_flags="-p /var/run/ntpd.pid -f /var/db/ntpd.drift"</p>
<p class="indent">In addition, FreeBSD includes a small SNMP daemon for use in facilities with SNMP-based management tools. We’ll cover configuring SNMP in <a href="ch21.xhtml#ch21">Chapter 21</a>.</p>
<p class="programs">bsnmpd_enable="NO"</p>
<h5 class="h5" id="lev121"><strong>Network Options</strong></h5>
<p class="noindent">These knobs control how FreeBSD configures its network facilities during boot. We’ll discuss networking in <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>
<p class="indent">Every machine on the internet needs a hostname. The hostname is the fully qualified domain name of the system, such as <em>www.absolutefreebsd.org</em>. Many programs won’t run properly without this.</p>
<p class="programs">hostname=""</p>
<p class="indent">FreeBSD includes a few different integrated firewall packages. We’re going to briefly cover the packet filter (PF) in <a href="ch19.xhtml#ch19">Chapter 19</a>. Enable and disable PF in <em>rc.conf</em>.</p>
<p class="programs">pf_enable="NO"</p>
<p class="indent">You might be interested in failed attempts to connect to your system over the network. This will help detect port scans and network intrusion attempts, but it’ll also collect a lot of garbage. It’s interesting to set this for a short period of time just to see what really happens on your network. (Then again, knowing what’s <em>really</em> going on tends to cause heartburn.) Set this to <span class="literal">1</span> to log failed connection attempts.</p>
<p class="programs">log_in_vain="0"</p>
<p class="indent">Routers use ICMP redirects to inform client machines of the proper network gateways for particular routes. While this is completely legitimate, on some networks intruders can use this to capture data. If you don’t need <span epub:type="pagebreak" id="page_68"/>ICMP redirects on your network, you can set this option for an extremely tiny measure of added security. If you’re not sure whether you’re using them, ask your network administrator.</p>
<p class="programs">icmp_drop_redirect="NO"</p>
<p class="indent">If you <em>are</em> the network administrator and you’re not sure whether your network uses ICMP redirects, there’s an easy way to find out—just log all redirects received by your system to <em>/var/log/messages</em>.<sup><a href="footnote.xhtml#ch04fn3" id="ch04fn3a">3</a></sup> Note that if your server is under attack, this can fill your hard drive with redirect logs fairly quickly.</p>
<p class="programs">icmp_log_redirect="NO"</p>
<p class="indent">To get on the network, you’ll need to assign each interface an IP address. We’ll discuss this in some detail in <a href="ch08.xhtml#ch08">Chapter 8</a>. You can get a list of your network interfaces with the ifconfig(8) command. List each network interface on its own line, with its network configuration information in quotes. For example, to give your em0 network card an IP address of 172.18.11.3 and a netmask of 255.255.254.0, you would use:</p>
<p class="programs">ifconfig_em0="inet 172.18.11.3 netmask 255.255.254.0"</p>
<p class="indent">If your network uses DHCP, use the value <span class="literal">dhcp</span> as an IP address.</p>
<p class="programs">ifconfig_em0="dhcp"</p>
<p class="indent">Similarly, you can assign aliases to a network card. An alias is not the card’s actual IP address, but the card answers for that IP address, as discussed in <a href="ch08.xhtml#ch08">Chapter 8</a>. FreeBSD supports hundreds of aliases on a single card, with <em>rc.conf</em> entries in the following form:</p>
<p class="programs">ifconfig_em0_alias<span class="codeitalic1">number</span>="<span class="codeitalic1">address</span> netmask 255.255.255.255"</p>
<p class="indent">The alias numbers must be continuous, starting with 0. If there’s a break in numbering, aliases above the break won’t be installed at boot time. (This is a common problem, and when you see it, check your list of aliases.) For example, an alias of 192.168.3.4 would be listed as:</p>
<p class="programs">ifconfig_em0_alias0="192.168.3.4 netmask 255.255.255.255"</p>
<h5 class="h5" id="lev122"><strong>Network Routing Options</strong></h5>
<p class="noindent">FreeBSD’s network stack includes many features for routing internet traffic. These start with the very basic, such as configuring an IP for your default <span epub:type="pagebreak" id="page_69"/>gateway. While assigning a valid IP address to a network interface gets you on the local network, a default router will give you access to everything beyond your LAN.</p>
<p class="programs">defaultrouter=""</p>
<p class="indent">Network control devices, such as firewalls, must pass traffic between different interfaces. While FreeBSD won’t do this by default, it’s simple to enable. Just tell the system that it’s a gateway and it’ll connect multiple networks for you.</p>
<p class="programs">gateway_enable="NO"</p>
<h5 class="h5" id="lev123"><strong>Console Options</strong></h5>
<p class="noindent">The console options control how the monitor and keyboard behave. You can change the language of your keyboard, the monitor’s font size, or just about anything else you like. For example, the keyboard map defaults to the standard US keyboard, frequently called <em>QWERTY</em>. You’ll find all sorts of keymaps in the directory <em>/usr/share/syscons/keymaps</em>. I prefer the Dvorak keyboard layout, which has an entry there as <em>us.dvorak</em>. By changing the <span class="literal">keymap</span> knob to <em>us.dvorak</em>, my system will use a Dvorak keyboard once it boots to multiuser mode.</p>
<p class="programs">keymap="NO"</p>
<p class="indent">FreeBSD turns the monitor dark when the keyboard has been idle for a time specified in the <span class="literal">blanktime</span> knob. If you set this to <span class="literal">NO</span>, FreeBSD won’t dim the screen. Mind you, new hardware will dim the monitor after some time as well, to conserve power. If your screen goes blank even if you’ve set the <span class="literal">blanktime</span> knob to <span class="literal">NO</span>, check your BIOS and your monitor manual.</p>
<p class="programs">blanktime="300"</p>
<p class="indent">FreeBSD can also use a variety of fonts on the console. While the default font is fine for servers, you might want a different font on your desktop or laptop. My laptop has one of those 17-inch screens proportioned for watching movies, and the default fonts look kind of silly at that size. You can choose a new font from the directory <em>/usr/share/syscons/fonts</em>. Try a few to see how they look on your systems. The font’s name includes the size, so you can set the appropriate variable. For example, the font <em>swiss-8x8.fnt</em> is the Swiss font, 8 pixels by 8 pixels. To use it, you would set the <span class="literal">font8x8</span> knob.</p>
<p class="programs">font8x16="NO"<br/>font8x14="NO"<br/>font8x8="YES"</p>
<p class="indent">You can use a mouse on the console, even without a GUI. By default, FreeBSD will try to autodetect your mouse type. If you have a PS/2 or USB <span epub:type="pagebreak" id="page_70"/>mouse, chances are that it’ll just work when you enable the mouse daemon, without any special configuration. Some older and more unusual types of mice require manual configuration, as documented in moused(8).</p>
<p class="programs">moused_enable="NO"<br/>moused_type="AUTO"</p>
<p class="indent">You can also change the display on your monitor to fit your needs. If you have an odd-sized monitor, you can change the number of lines of text and their length to fit, change text colors, change your cursor and cursor behavior, and do all sorts of other little tweaks. You can get a full list of different options in man vidcontrol(1).</p>
<p class="programs">allscreens_flags=""</p>
<p class="indent">Similarly, you can adjust your keyboard behavior almost arbitrarily. Everything from key repeat speed to the effect of function keys can be configured, as documented in kbdcontrol(1).</p>
<p class="programs">allscreens_kbdflags=""</p>
<h5 class="h5" id="lev124"><strong>Other Options</strong></h5>
<p class="noindent">This final potpourri of knobs might or might not be useful in any given environment, but they’re needed frequently enough to deserve mention. For example, not all systems have access to a printer, but those that do will want to run the printing daemon lpd(8). We brush up against printer configuration in <a href="ch20.xhtml#ch20">Chapter 20</a>.</p>
<p class="programs">lpd_enable="NO"</p>
<p class="indent">The sendmail(8) daemon manages transmission and receipt of email between systems. While almost all systems need to transmit email, most FreeBSD machines don’t need to receive email. The <span class="literal">sendmail_enable</span> knob specifically handles incoming mail, while <span class="literal">sendmail_outbound_enable</span> allows the machine to transmit mail. See <a href="ch20.xhtml#ch20">Chapter 20</a> for more details.</p>
<p class="programs">sendmail_enable="NO"<br/>sendmail_submit_enable="YES"</p>
<p class="indent">One of FreeBSD’s more interesting features is its ability to run software built for Linux. We discuss this feature in <a href="ch17.xhtml#ch17">Chapter 17</a>. Running Linux software isn’t quite as easy as throwing this toggle, so don’t enable Linux compatibility modes without reading that chapter first!</p>
<p class="programs">linux_enable="NO"</p>
<p class="indent"><span epub:type="pagebreak" id="page_71"/>A vital part of any Unix-like operating system is shared libraries. You can control where FreeBSD looks for shared libraries. Although the default setting is usually adequate, if you find yourself regularly setting the <span class="literal">LD_LIBRARY_PATH</span> environment variable for your users, you should consider adjusting the library path instead. See <a href="ch17.xhtml#ch17">Chapter 17</a> for more advice on the library path.</p>
<p class="programs">ldconfig_paths="/usr/lib /usr/local/lib"</p>
<p class="indent">FreeBSD has a security profile system that allows the administrator to control basic system features. You can globally disallow mounting hard disks, accessing particular TCP/IP ports, and even changing files. See <a href="ch09.xhtml#ch09">Chapter 9</a> for details on how to use these.</p>
<p class="programs">kern_securelevel_enable="NO"<br/>kern_securelevel="-1"</p>
<p class="indent">Now that you know a smattering of the configuration knobs FreeBSD supports out of the box, let’s see how they’re used.</p>
<h3 class="h3" id="lev125"><strong>The rc.d Startup System</strong></h3>
<p class="noindent">FreeBSD bridges the gap between single-user mode and multiuser mode via the shell script <em>/etc/rc</em>. This script reads in the configuration files <em>/etc/defaults/rc.conf</em> and <em>/etc/rc.conf</em>, and runs a collection of other scripts based on what it finds there. For example, if you’ve enabled the network time daemon, <em>/etc/rc</em> runs a script written specifically for starting that daemon. FreeBSD includes scripts for starting services, mounting disks, configuring the network, and setting security parameters.</p>
<p class="indent">These scripts live in <em>/etc/rc.d</em> and <em>/usr/local/etc/rc.d</em>. I’d recommend reading a few of them if only to see how the <em>rc.d</em> system works.</p>
<p class="indent">Control these scripts with service(8).</p>
<h4 class="h4" id="lev126"><strong><em>The service(8) Command</em></strong></h4>
<p class="noindent">All of the <em>rc.d</em> scripts are readable, and the way they fit together is pretty straightforward. When you have a problem, you can read the scripts to see how they work and what they do. But that’s a lot like work, and most sysadmins have more interesting work to do. The service(8) command provides a friendly frontend to the <em>rc.d</em> scripts. You can use service(8) to see which scripts run automatically; to stop, start, and restart services; to check the status of a service; and more.</p>
<h5 class="h5" id="lev127"><strong>Listing and Identifying Enabled Services</strong></h5>
<p class="noindent">Use the <span class="literal">-e</span> flag to service(8) to see the full path of all scripts that’ll be run at system boot, in the order they’ll be run.</p>
<p class="programs"><span epub:type="pagebreak" id="page_72"/># <span class="codestrong1">service -e</span><br/>/etc/rc.d/hostid<br/>/etc/rc.d/zvol<br/>/etc/rc.d/hostid_save<br/>/etc/rc.d/zfsbe<br/>--<span class="codeitalic1">snip</span>--<br/>/etc/rc.d/sshd<br/>/etc/rc.d/sendmail<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">This tiny host runs 23 scripts at boot.</p>
<p class="indent">One important detail here is the script name. You’ll use the script name in other commands, like starting, stopping, and restarting services.</p>
<h5 class="h5" id="lev128"><strong>Managing Services</strong></h5>
<p class="noindent">While it’s entirely possible to restart, say, sshd(8) at the command line, a production host needs everything to run consistently. Best practice calls for using service(8) to manage processes. You’ll need the script name as shown earlier, but without the directory path.</p>
<p class="programs"># <span class="codestrong1">service</span> <span class="codestrongitalic1">name command</span></p>
<p class="indent">For example, suppose I want to restart the sshd(8) service. According to the <span class="literal">service -e</span> output shown earlier, there’s a script <em>/etc/rc.d/sshd</em>. I strongly suspect this script manages sshd(8), but I want to be certain I don’t accidentally restart the Stupidly Similarly named Harassment Daemon. This is where the <span class="literal">describe</span> command comes in. Let’s ask service(8) to describe the <em>sshd</em> script.</p>
<p class="programs"># <span class="codestrong1">service sshd describe</span><br/>Secure Shell Daemon</p>
<p class="indent">It’s the right daemon. Let’s restart it.</p>
<p class="programs">   # <span class="codestrong1">service sshd restart</span><br/><span class="ent">➊</span> Performing sanity check on sshd configuration.<br/><span class="ent">➋</span> Stopping sshd.<br/><span class="ent">➌</span> Performing sanity check on sshd configuration.<br/><span class="ent">➍</span> Starting sshd.</p>
<p class="indent">Restarting a service is a combination of “stop the service” and “start the service.” This particular service does more than that, though. It starts by verifying the configuration file <span class="ent">➊</span> and then stopping the daemon <span class="ent">➋</span>. It then reverifies the configuration <span class="ent">➌</span> and starts the daemon <span class="ent">➍</span>. Why?</p>
<p class="indent">SSH handles remote access to this host. If the SSH service breaks, nobody can log into the host to fix the SSH service. Yes, you could use a remote KVM or IPMI or drive to the colocation facility, but any of these prolongs the outage. It’s much better to verify that sshd(8) can <em>be</em> restarted before shutting it down. Many service scripts include this kind of safety check. If a service complains that it can’t stop, read the output carefully to find out why.</p>
<p class="indent"><span epub:type="pagebreak" id="page_73"/>The commands each service supports vary. The easiest way to get the full list of commands a particular service supports is to give the service a bogus argument. Something like “bert” is pretty bogus.</p>
<p class="programs"># <span class="codestrong1">service sshd bert</span><br/>/etc/rc.d/sshd: unknown directive 'bert'.<br/>Usage: /etc/rc.d/sshd [fast|force|one|quiet](start|stop|restart|rcvar|enabled|<br/>describe|extracommands|configtest|keygen|reload|status|poll)</p>
<p class="indent">You get a full list of commands this service supports, in two groups.</p>
<p class="indentb">The first group, in square brackets, contains options for the commands. Here are the standard options. Use them as prefixes for the commands in the second group.</p>
<p class="hang"><span class="codestrong">fast</span> Do no checking (used during startup).</p>
<p class="hang"><span class="codestrong">force</span> Try harder.</p>
<p class="hang"><span class="codestrong">one</span> Start this service despite not being enabled in <em>rc.conf</em>.</p>
<p class="hang"><span class="codestrong">quiet</span> Only print service name (used during startup).</p>
<p class="indenttb">The second group, in parentheses, contains the following commands:</p>
<p class="hang"><span class="codestrong">start</span> Start the service.</p>
<p class="hang"><span class="codestrong">stop</span> Stop the service.</p>
<p class="hang"><span class="codestrong">restart</span> Stop and restart the service.</p>
<p class="hang"><span class="codestrong">rcvar</span> Print the <em>rc.conf</em> variables for this service.</p>
<p class="hang"><span class="codestrong">enabled</span> Return true in shell if enabled (for script use).</p>
<p class="hang"><span class="codestrong">describe</span> Print service description.</p>
<p class="hang"><span class="codestrong">extracommands</span> Show service-specific commands.</p>
<p class="indenttb">The <span class="literal">extracommands</span> command is very specific to the service and lists only the additional commands this service accepts. By default, the extra commands appear after the default commands. Here are some common extra commands:</p>
<p class="hang"><span class="codestrong">configtest</span> Parse the service’s configuration file and stop if there’s an error.</p>
<p class="hang"><span class="codestrong">reload</span> Perform a soft reload (usually via SIGHUP) rather than a restart.</p>
<p class="hang"><span class="codestrong">status</span> Determine whether service is running.</p>
<p class="indentt">To determine exactly what a service’s extra commands do, you need to read the service script.</p>
<p class="indent">We’ll look at <em>rc.d</em> in more detail in <a href="ch17.xhtml#ch17">Chapter 17</a>, when we discuss customizing and writing your own <em>rc.d</em> scripts.</p>
<h4 class="h4" id="lev129"><strong><em>System Shutdown</em></strong></h4>
<p class="noindent">FreeBSD makes the <em>rc.d</em> startup system do double duty; not only must it handle system startup, it must also shut all those programs down when it’s time to power down. Something has to unmount all those hard drives, <span epub:type="pagebreak" id="page_74"/>shut down the daemons, and clean up after doing all the work. Some programs don’t care whether they’re unceremoniously killed when the system closes up for the night—after all, after the system goes down, any clients connected over SSH will be knocked off and any half-delivered web pages remain incomplete. Database software, however, cares very much about how it’s turned off, and unceremoniously killing the process will damage your data. Many other programs that manage actual data are just as particular, and if you don’t let them clean up after themselves, you’ll regret it.</p>
<p class="indent">When you shut down FreeBSD with the shutdown(8), halt(8), or reboot(8) commands, the system calls the shell script <em>/etc/rc.shutdown</em>. This script calls each <em>rc.d</em> script in turn with the <span class="literal">stop</span> option, reversing the order they were called during startup, thereby allowing server programs to terminate gracefully and disks to tidy themselves up before the power dies.</p>
<h3 class="h3" id="lev130"><strong>Serial Consoles</strong></h3>
<p class="noindent">All this console stuff is nice, but when your FreeBSD system is in a colocation facility on the other side of the country or on another continent, you can’t just walk up to the keyboard and start typing. Many data centers won’t have room for a keyboard or monitor. And how do you reset the machine remotely when it won’t respond to the network? Using a serial console to redirect the computer’s keyboard and video to the serial port instead of the keyboard and monitor helps with all of these problems.</p>
<p class="indent">Serial consoles can be physical, such as a serial port on the back of a computer. By hooking up a standard null modem cable to the serial port and attaching the other end to another computer’s serial port, you can access the first system’s boot messages from the second computer.</p>
<p class="indent">They might also be virtual, as provided by IPMI’s <em>Serial-over-LAN (SOL)</em> protocol. Rather than a null modem cable, you’ll need to set up the IPMI interface and use special software to configure and access the virtual serial port.</p>
<p class="indent">Before we set up a port, though, let’s talk about serial port protocol.</p>
<h4 class="h4" id="lev131"><strong><em>Serial Protocol</em></strong></h4>
<p class="noindent">Some of the first computer consoles were serial ports connected to teletypes. Serial has been around a long time and has evolved over the decades. Unlike modern protocols, serial lines do not autonegotiate. You must configure both sides of a serial link to the exact same settings. A configuration mismatch will cause either a blank screen or gibberish.</p>
<p class="indent">Original serial lines worked at low speeds. Many of the serial cables remain basically the same, but we’ve developed better software and hardware to stick at each end that allows us to transmit data much faster. Where old serial connections ran at 300 bits per second (baud), a whole bunch of modern hardware can run at 115,200 baud. Across hardware platforms, though, the common standard is 9600 baud, which is FreeBSD’s default console speed. A baud rate of 9600 is enough to carry whole screens of text at a comfortable speed.</p>
<p class="indent"><span epub:type="pagebreak" id="page_75"/>Stick with 9600 baud for physical connections, unless you can’t. Some modern hardware doesn’t support 9600 baud. Some claim to support 9600 baud, but don’t. I’ve worked with devices hardcoded to 115,200 baud. Anything that fails or flat-out refuses to do 9600 baud is busted by design, but we often don’t control the choice of hardware. Changing the serial console speed for reasons other than hardware limitations makes your connection more fragile, and if you’re using the console, you’re in no mood for fragility. When I mention changing the port speed, that’s for use only when you have to.</p>
<p class="indent">SOL connections aren’t physical wires, so you don’t have to worry about line noise. You can safely run them at higher speeds.</p>
<p class="indent">Serial protocols also include a whole bunch of settings beyond their speed. It’s possible to muck with them, but the standard settings of 8 data bits, no parity, and 1 stop bit are the most widely used. You can’t change these in FreeBSD without recompiling the kernel, so don’t muck with them.</p>
<p class="indent">With that in mind, let’s set up a console.</p>
<h4 class="h4" id="lev132"><strong><em>Physical Serial Console Setup</em></strong></h4>
<p class="noindent">No matter what sort of serial console you have, you’ll need to plug into it correctly to make it work. You’ll need a null modem cable, available at any computer store or from online vendors. While the gold-plated serial cables are not worth the money, don’t buy the cheapest cable you can find either; if you have an emergency and need the serial console, you’re probably not in the mood to endure line noise!<sup><a href="footnote.xhtml#ch04fn4" id="ch04fn4a">4</a></sup></p>
<p class="indent">Plug one end of the null modem cable into the serial console port on your FreeBSD server—by default the first serial port (COM1 or uart0, depending on what operating system you’re used to). You can change this with a server.</p>
<p class="indent">Plug the other end of your null modem cable into an open serial port on another system. I recommend either another FreeBSD (or other Unix) system or a terminal server, but you can use a Windows box if that’s all you have.</p>
<p class="indent">If you have two FreeBSD machines at a remote location, make sure that they each have two serial ports. Get two null modem cables and plug the first serial port on each box into the second serial port of the other machine. That way, you can use each machine as the console client for the other. If you have three machines, daisy-chain them into a loop. By combining twos and threes, you can get serial consoles on any number of systems. I’ve worked data centers with 30 or 40 FreeBSD machines, where installing monitors was simply not practical, and we used serial consoles to great effect. Once you have a rack or two of servers, however, investing in a terminal server is a really good idea. You can find them cheaply on eBay.</p>
<p class="indent">Another option is to use two DB9-to-RJ45 converters, one standard and one crossover. These allow you to run your console connections over a standard CAT5 cable. If you have a lights-out data center where human <span epub:type="pagebreak" id="page_76"/>beings are not allowed, you can have your serial consoles come out near your desk, in your warm room, or anywhere else your standard Ethernet-style patch panels reach. Most modern data facilities are better equipped to handle Ethernet than serial cables.</p>
<h4 class="h4" id="lev133"><strong><em>IPMI Serial Console Setup</em></strong></h4>
<p class="noindent">The <em>Intelligent Platform Management Interface (IPMI)</em> is a standard for managing computer systems at a hardware level. IPMI runs separately from the operating system, using a small device called a <em>baseboard management controller (BMC)</em>. Essentially, the BMC acts as your remote hands and eyes to control the server. To use an IPMI console, you’ll need to configure both the BMC and the host’s BIOS or UEFI.</p>
<p class="indent">I’ll try to orient you here, but the best resource for configuring BMC or UEFI is your hardware manual.<sup><a href="footnote.xhtml#ch04fn5" id="ch04fn5a">5</a></sup></p>
<h5 class="h5" id="lev134"><strong>BMC Setup</strong></h5>
<p class="noindent">A server’s BMC has its own IP address and normally gets a dedicated Ethernet port on the mainboard. Each vendor gets to design its own BMC in a way that conforms to its own biases. This means that configuring the BMC is way, way beyond the scope of this book, but here are a few hints.</p>
<p class="indent">You configure most BMCs through a web interface. Before you can access the web interface, though, the BMC needs an IP address. Set most BMC IP information in the BIOS or UEFI firmware’s setup menu. Once you get in the management interface, configure a username and password. Remember them.</p>
<p class="indent">A usual BMC also includes functions such as power cycling the main system, remote console access via some sort of downloaded application (often Java), virtual media, and more.</p>
<p class="indent">Never forget that the BMC is a small embedded computer running a web server and that it was written by some overworked corporate employee charged with building the minimum viable product. The BMC wasn’t tested for how it performed after several months of uptime. If it gives you even a sneeze of trouble, reboot it. No, you don’t have to power cycle the whole computer; there’s usually a “BMC Reset” or “Unit Reboot” menu option somewhere in the web interface.</p>
<p class="indent">If the BMC supports an applet-based console, why use a serial console? Because the BMC console is applet-based and BMC firmwares are rarely updated. I have quite a few BMC consoles that work only with obsolete, insecure<sup><a href="footnote.xhtml#ch04fn6" id="ch04fn6a">6</a></sup> versions of Java. Using them requires overriding security warnings and repeatedly clicking the “Yes, I know I’m an idiot, do it anyway” box. I have to keep a virtual machine with this insecure Java version specifically to access those consoles. The applet-based console doesn’t support copy and paste, and is often very laggy.</p>
<p class="indent"><span epub:type="pagebreak" id="page_77"/>IPMI works better than the Java console applet over slower connections. I can copy and paste. Also, I can use the IPMI console from the command line, from any modern operating system.</p>
<p class="indent">While you’re in the BMC setup, locate the option to launch SOL. That brings up an applet to connect to the host’s SOL interface, which will help you test your serial console configuration.</p>
<h5 class="h5" id="lev135"><strong>UEFI/BIOS Serial Console Configuration</strong></h5>
<p class="noindent">Once your BMC is ready, you must configure the server hardware to direct a serial port to the BMC. Go to the hardware’s Setup menu, where you configure your UEFI or BIOS. Somewhere in that maze of twisty little options, you’ll find something like “Serial Port Console Redirection.”</p>
<p class="indent">A vital question here is, how many serial ports does your host have? Maybe it has none. Maybe it has several. You can choose to redirect one of those ports or add an additional, virtual port. I encourage you to leave your existing serial ports alone and add a virtual port dedicated to SOL. It’s probably called something like “SOL Console Redirection.” Enable it, and go into the settings for that port.</p>
<p class="indentb">Here are some settings I find helpful for FreeBSD and SOL:</p>
<p class="hang"><strong>Terminal type</strong> vt100</p>
<p class="hang"><strong>Data bits</strong> 8</p>
<p class="hang"><strong>Parity</strong> none</p>
<p class="hang"><strong>Stop bits</strong> 1</p>
<p class="hang"><strong>Flow control</strong> none</p>
<p class="indentt">The tricky part is the baud, speed, or bits-per-second setting. Stick with the default speed, but make a note of it. You’ll need the speed to connect.</p>
<p class="indent">Now that you have a serial console, set up FreeBSD.</p>
<h4 class="h4" id="lev136"><strong><em>Configuring FreeBSD’s Serial Console</em></strong></h4>
<p class="noindent">As FreeBSD boots, the loader decides where to print console messages and where to accept input from. While this defaults to the monitor and keyboard, with a few tweaks, you can redirect the console to a serial port. The serial console won’t grant BIOS access, but you can tweak the FreeBSD boot itself in almost any way. You can configure a serial console in either the first- or second-stage boot loader.</p>
<p class="indent">A first-stage boot loader gets you console access at the earliest possible moment but requires you use the first serial port as a console. Changing the port requires recompiling the kernel. The first-stage boot loader allows you to perform tasks like choose which disk you’re going to load the second-stage loader from—essentially, to boot from a disk other than the disk the BIOS or UEFI selected. This is undeniably useful, but very few users need this.</p>
<p class="indent">The second-stage boot loader can use any serial port as a console, but the first bit of output you’ll get is the boot menu discussed in “<a href="ch04.xhtml#lev106">The Loader Prompt</a>” on <a href="ch04.xhtml#page_55">page 55</a>. For most of us, that’s perfectly acceptable.</p>
<h5 class="h5" id="lev137"><span epub:type="pagebreak" id="page_78"/><strong>Console Options</strong></h5>
<p class="noindent">FreeBSD’s default configuration uses the monitor and keyboard as the console. You can choose to switch to only the serial console or to use a dual console. Choose which with the <em>/boot/loader.conf</em> option <span class="literal">console</span>.</p>
<p class="indent">A serial-only console prevents some random colocation employee from power cycling your box, plugging in a monitor, and dinking with the menu. Yes, they could still work mayhem from the first-stage loader or boot off of USB, but that requires greater skill. Set the <em>console</em> variable to <span class="literal">comconsole</span> to use only the serial port as a console.</p>
<p class="programs">console="comconsole"</p>
<p class="indent">For most deployments, I recommend a dual console. Dual consoles show console activity on both the serial port and the monitor. You can use either the standard or the serial console as needed. Specify a dual-console configuration by listing both <span class="literal">comconsole</span> and <span class="literal">vidconsole</span>.</p>
<p class="programs">console="comconsole vidconsole"</p>
<p class="indent">If you’re in a server-room situation, you might want to switch back and forth between a standard console and a serial console. I generally manage large arrays of FreeBSD systems via the serial console but leave the video console in place in case of trouble.</p>
<p class="indent">The console won’t be effective until after a reboot. You can see whether FreeBSD put its console on a serial port by checking the boot messages.</p>
<p class="programs">uart0: &lt;16550 or compatible&gt; port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0<br/>uart0: console (9600,n,8,1)</p>
<p class="indent">The second line shows that the serial port uart0 is configured as a console, using the default settings. We’ll look at those settings in “<a href="ch04.xhtml#lev139">Using Serial Consoles</a>” on <a href="ch04.xhtml#page_79">page 79</a>.</p>
<h5 class="h5" id="lev138"><strong>Advanced Console Options</strong></h5>
<p class="noindent">In addition to enabling the console, you can adjust the console’s port and the speed.</p>
<p class="indent">Maybe I need to use the second serial port for the console. Perhaps the first serial port has something plugged into it, or maybe the second port is the virtual SOL port. Serial ports use the uart(4) device driver. Remember that FreeBSD devices start numbering at zero, while COM ports start numbering at 1. COM1 is uart0, COM2 is uart1, and so on. You’ll need the port’s base I/O port, which you can get from the system bootup messages.</p>
<p class="programs"># <span class="codestrong1">grep uart /var/run/dmesg.boot</span><br/>uart0: &lt;16550 or compatible&gt; port <span class="ent">➊</span>0x3f8-0x3ff irq 4 flags 0x10 on acpi0<br/>uart1: &lt;16550 or compatible&gt; port <span class="ent">➋</span>0x2f8-0x2ff irq 3 on acpi0</p>
<p class="indent"><span epub:type="pagebreak" id="page_79"/>The first number after the word port is the base I/O port <span class="ent">➊</span>. The base address of COM2, or uart1, is 0x2f8. Set <span class="literal">comconsole_port</span> to this value <span class="ent">➋</span>.</p>
<p class="programs">comconsole_port="0x2f8"</p>
<p class="indent">Your console is now on serial port COM2.</p>
<p class="indent">If my serial connection won’t do 9600 baud, I can change the port speed with the <span class="literal">comconsole_speed</span> option.</p>
<p class="programs">comconsole_speed="115200"</p>
<p class="indent">On a physical port, don’t increase the port speed just because you can.</p>
<h4 class="h4" id="lev139"><strong><em>Using Serial Consoles</em></strong></h4>
<p class="noindent">Now that you have both physical and software set up, configure your client to access the serial console. The key to using a serial console is to remember the following settings:</p>
<ul>
<li class="noindent">Speed (9600 baud, or whatever your hardware is set to)</li>
<li class="noindent">8 bits</li>
<li class="noindent">No parity</li>
<li class="noindent">1 stop bit</li>
</ul>
<p class="indent">The way you access a serial line depends on whether it’s a physical line or an IPMI SOL connection.</p>
<h5 class="h5" id="lev140"><strong>Physical Serial Lines</strong></h5>
<p class="noindent">Connect your client to the other end of the serial line. You can find terminal emulators for Microsoft platforms (PuTTY being the most famous), macOS, and almost any other operating system. Once upon a time, I used a Palm handheld with a serial cable to access serial consoles. Enter the correct value settings into the terminal emulator, and the serial console will “just work.”</p>
<p class="indent">FreeBSD accesses serial lines with tip(1), a program that allows you to connect to remote systems in a manner similar to telnet. To run tip, do this as root:</p>
<p class="programs"># <span class="codestrong1">tip</span> <span class="codestrongitalic1">portname</span></p>
<p class="indent">A port name is shorthand for specifying the serial port number and speed to be used on a serial port. The file <em>/etc/remote</em> contains a list of port <span epub:type="pagebreak" id="page_80"/>names. Most of the entries in this file are relics of the eon when UUCP was the major data transfer protocol and serial lines were the norm instead of the exception.<sup><a href="footnote.xhtml#ch04fn7" id="ch04fn7a">7</a></sup> At the end of this file, you’ll see a few entries like:</p>
<p class="programs"># Finger friendly shortcuts<br/>uart0|com1:dv=/dev/cuau0:br#9600:pa=none:<br/>uart1|com2:dv=/dev/cuau1:br#9600:pa=none:<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">The <span class="literal">uart</span> entries are the standard Unix-type device names, while the <span class="literal">com</span> names were added for the convenience of people who grew up on x86 hardware.</p>
<p class="indent">Assume that you have two FreeBSD boxes wired back-to-back, with each one’s serial port 1 null-modemed into serial port 2. Both machines are configured to use a serial console. You’ll want to connect to your local serial port 2 to talk to the other system’s serial console:</p>
<p class="programs"># <span class="codestrong1">tip uart1</span><br/>connected</p>
<p class="indent">You’re in!</p>
<p class="indent">To disconnect the serial console, press <small>ENTER</small> and then type the disconnect sequence “tilde-dot” at any time.</p>
<p class="programs">~.</p>
<p class="indent">You’ll be gracefully disconnected. (This also works in the OpenSSH client.)</p>
<p class="indent">The tip(1) program uses the tilde (<span class="literal">~</span>) as a control character. Read the man page for a full list of things you can do with it.</p>
<h5 class="h5" id="lev141"><strong>IPMI SOL Connections</strong></h5>
<p class="noindent">You’ll need a SOL client to connect to your IPMI serial port. The quickest way to test your configuration is probably with the SOL client applet included in your BMC. While that client has most of the disadvantages of the console applet, it’s a good place to test. If the BMC SOL client doesn’t work, check your SOL settings and FreeBSD configuration. Verify that the SOL client is set to use the same speed you set in the hardware and in FreeBSD. If it doesn’t work but all your settings appear to match, reboot the BMC. Once it works, you can use SOL from another host.</p>
<p class="indent">The standard IPMI SOL client is IPMItool (<em><a href="https://sourceforge.net/projects/ipmitool/">https://sourceforge.net/projects/ipmitool/</a></em>), available as the ipmitool package. (<a href="ch15.xhtml#ch15">Chapter 15</a> discusses packages.) IPMItool can interact with your BMC over the network, granting you all of the BMC functions without logging into a clunky web interface. You can reboot the host, check hardware alarms and sensors, and more, all <span epub:type="pagebreak" id="page_81"/>from the command line. But for the moment, we’ll stick with the SOL console. Use the BMC’s hostname or IP, the username, and the password to log into SOL.</p>
<p class="programs"># <span class="codestrong1">ipmitool -H</span> <span class="codestrongitalic1">bmc</span><span class="codestrong1"> -U</span> <span class="codestrongitalic1">username</span><span class="codestrong1"> -I lanplus sol activate</span></p>
<p class="indent">Here, I log into my web server’s BMC, with the hostname www-bmc, using the username “bert.”</p>
<p class="programs"># <span class="codestrong1">ipmitool -H www-kvm -U bert -I lanplus sol activate</span></p>
<p class="indent">Enter the password at the prompt, and the SOL will acknowledge your login.</p>
<p class="programs">[SOL Session operational.  Use ~? for help]</p>
<p class="indent">We have a console. Probably. Let’s do the final test.</p>
<h4 class="h4" id="lev142"><strong><em>Working at the Console</em></strong></h4>
<p class="noindent">The real test of a serial console is whether or not you can get data across it. Once you have your console connected, hit <small>ENTER</small>.</p>
<p class="programs">FreeBSD/amd64 (www) (ttyu2)<br/><br/>login:</p>
<p class="indent">FreeBSD permits logins on serial consoles by default. Log in to the host and reboot it, and you’ll get the usual console messages.</p>
<p class="programs">Jul 13 11:48:24 Stopping cron.<br/>Stopping sshd.<br/>Stopping devd.<br/>Writing entropy file:.<br/>Writing early boot entropy file:.<br/>Terminated<br/>.<br/>Jul 13 11:48:24 zfs1 syslogd: exiting on signal 15<br/>Waiting (max 60 seconds) for system process `vnlru' to stop... done<br/>Waiting (max 60 seconds) for system process `bufdaemon' to stop... done<br/>Waiting (max 60 seconds) for system process `syncer' to stop...<br/>Syncing disks, vnodes remaining... 0 0 0 done<br/>All buffers synced.</p>
<p class="indent">There will be a long pause while the system runs its BIOS routines and hands control over to the serial console. Just about the time you decide that the machine is never coming back up, you’ll get the loader menu. Congratulations! You’re using a serial console. Press the spacebar to interrupt the boot just as if you were at the keyboard.</p>
<p class="indent">It doesn’t matter how far away the system is; you can change your booting kernel, get a verbose boot, bring it up in single-user mode, or manually <span epub:type="pagebreak" id="page_82"/>fsck the hard drive—whatever. A software serial console might not show you the BIOS, but chances are that’s set up correctly already. Once you’ve used a serial console for a while, it won’t matter whether the machine is on the other side of the world or the other side of the room; getting out of your chair merely to access the console will feel like too much work.</p>
<p class="indent">If a system in a remote location entirely locks up, you can connect to your serial console and have the “remote hands” at the colocation facility power-cycle the system. It might not be good for your computer, but it’s also not good for it to be locked up. With the serial console, you can boot into single-user mode and fix the problem by digging through the logs and whatever other troubleshooting you feel capable of. We’ll discuss troubleshooting this sort of problem in <a href="ch24.xhtml#ch24">Chapter 24</a>.</p>
<p class="indent">Now that you understand how FreeBSD starts up and shuts down, let’s look at some basic tools you can use to ensure that your system will continue to run even after you’ve been experimenting with it.</p>
</body></html>