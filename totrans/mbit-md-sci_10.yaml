- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**10**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**RADIO ACTIVITY**'
  prefs: []
  type: TYPE_NORMAL
- en: The Mad Scientist has made a friend. After hitting it off at a Mad Science Conference,
    the two decided they wanted to keep talking—through micro:bit, of course. The
    micro:bit has a built-in radio transmitter and receiver, together known as a *transceiver*,
    that can communicate with Bluetooth devices. We saw this in action in the roving
    robot project in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: This radio transceiver can also be used to talk to other micro:bits using a
    simple message-sending and receiving protocol specific to the micro:bit. In this
    chapter, we’ll look at micro:bit-to-micro:bit communication, so you’ll need either
    two of your own micro:bits or a friend with a micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0226-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**EXPERIMENT 12: FINDING THE RADIO RANGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Difficulty: Easy*'
  prefs: []
  type: TYPE_NORMAL
- en: The Mad Scientist and a friend want to know how far apart they can be before
    their micro:bit communicators stop working.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll need a pair of micro:bits, each equipped with a battery pack. You’ll
    also need a friend to talk to and a field or other open space where you can move
    away from each other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    and click the link for **Experiment 12: Radio Range**. Copy the hex file onto
    both micro:bits. ([Chapter 1](ch01.xhtml#ch01) explains the full process of getting
    programs onto your micro:bit if you get stuck). If you want to run the MicroPython
    version of this experiment, that file is *Experiment_12.py*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equip both micro:bits with battery power—you’re probably used to doing this
    by now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you venture outdoors, test that both micro:bits are ready to go by pressing
    button **A** on one of the devices. An up arrow should appear on that micro:bit,
    and a check mark should appear on the other micro:bit. Repeat this test by pressing
    button **A** on the other micro:bit ([Figure 10-1](ch10.xhtml#ch10fig1)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/10fig01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 10-1: Testing the micro:bits*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to a place where you and your friend have plenty of room to move away from
    each other. Stand about a yard (or meter) apart, facing one another. You should
    have one micro:bit and your friend the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now either you or your friend presses button **A** on their micro:bit to transmit
    the signal. Then wave to let the other person know the signal was sent (in case
    they don’t receive it). When their device picks up the signal, they should wave
    back. Assuming the signal was successfully transmitted, take a few steps away
    from each other and repeat the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At some point, the message won’t be received! The sender should press the button
    and wave one more time. If the message still isn’t received, you both know to
    move one step closer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve determined the radio’s range, the sender uses a prearranged signal
    to tell the receiver to walk toward them, counting the number of steps that they
    take.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Measure the length of a step taken by the receiver and multiply that by the
    number of steps they took. The resulting value is the line-of-sight range of the
    micro:bit’s radio. Tip: To get a reasonably accurate stride length, have the person
    walk five steps, use a long tape measure to measure the total distance traveled,
    and divide that distance by 5.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Mad Scientist tested the range of two micro:bits and found it to be 192
    strides. Five strides covered 12 feet (3.65 meters), meaning that each stride
    was 2.4 feet. The range was therefore 192 × 2.4 or approximately 460 feet (140
    meters).
  prefs: []
  type: TYPE_NORMAL
- en: A range of over 1,100 feet (350 meters) has been reported by others carrying
    out this experiment. Note that the range will be considerably less if either your
    body or your friend’s is between the micro:bits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for the range test is fairly simple, whether you use Blocks or MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the Blocks code for the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0229-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can control the amount of power used by the radio. The `on start` block
    uses the `radio set transmit power` block to set the power to 7 (maximum)—more
    power means greater range. The `set radio group` block assigns a group for the
    radio to use. In this case, we use group 1, which means all the micro:bits set
    to radio group 1 will receive the transmissions. So, if you plan to carry out
    this experiment with multiple pairs of micro:bits at the same time, then each
    pair of experimenters should pick a different number between 0 and 255 and set
    the radio group to that number. This way, the different pairs won’t interfere
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `on button A pressed` block with the `radio send` block to transmit
    a simple message of `test`. This will flash the `North` arrow icon to show that
    the message has been sent.
  prefs: []
  type: TYPE_NORMAL
- en: We handle incoming messages with an `on received block`, specifying the name
    of the variable into which any incoming message should be put. In this case, whenever
    the micro:bit’s radio receives a message, it puts the message into the variable
    `receivedString`. If this message is `test`, then the check mark icon is displayed
    for a moment on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroPython Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the MicroPython version of the code. Note that the way messages are
    sent in MicroPython is slightly different from how they’re sent in the Blocks
    code, so the pair of micro:bits used in this experiment should both be programmed
    either in Blocks or in MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: import radio
  prefs: []
  type: TYPE_NORMAL
- en: radio.on()
  prefs: []
  type: TYPE_NORMAL
- en: radio.config(power=7, group=1)
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if button_a.was_pressed():'
  prefs: []
  type: TYPE_NORMAL
- en: radio.send("test")
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.ARROW_N)
  prefs: []
  type: TYPE_NORMAL
- en: sleep(1000)
  prefs: []
  type: TYPE_NORMAL
- en: display.clear()
  prefs: []
  type: TYPE_NORMAL
- en: message = radio.receive()
  prefs: []
  type: TYPE_NORMAL
- en: 'if message == ''test'':'
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.YES)
  prefs: []
  type: TYPE_NORMAL
- en: sleep(1000)
  prefs: []
  type: TYPE_NORMAL
- en: display.clear()
  prefs: []
  type: TYPE_NORMAL
- en: To set the radio’s power and radio group in MicroPython, we need to use the
    `radio.config` method. This method also allows you to control a number of other
    options. You can read about these at *[https://bbcmicrobitmicropython.readthedocs.io/en/latest/radio.html](https://bbcmicrobitmicropython.readthedocs.io/en/latest/radio.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: The Blocks version of the code is contained entirely in handlers. In MicroPython,
    we don’t have handlers, so we have to continually check for a button press or
    incoming message. We do this by having a set of `if` statements in a `while True`
    loop that is always running.
  prefs: []
  type: TYPE_NORMAL
- en: First, we check whether button A has been pressed since the previous check.
    If it has been, we send the message `test` and show the North arrow.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether we’ve received a message, we repeatedly call `message.receive`.
    When the radio receives messages, it puts them in a queue. If there is no message
    waiting, then `message.receive` returns `None`. However, if there is one or more
    messages, then `message.receive` returns the oldest message and removes that message
    from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: We only care whether the message is `test`, so we check this condition. If the
    message is `test`, we have the micro:bit display the YES icon for a second.
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works: Radio Signals**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When outdoors, the *range* of the micro:bits’ radios is likely to be much greater
    than when you’re indoors, where walls between the micro:bits will impede the signal.
  prefs: []
  type: TYPE_NORMAL
- en: The system of sending messages between devices is called *packet radio* because
    small packets of data are being sent. In this project’s code, these are text commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT: WIRELESS DOORBELL**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Difficulty: Medium*'
  prefs: []
  type: TYPE_NORMAL
- en: Distracted by experiments and insubordinate underlings, the Mad Scientist often
    misses packages when they’re delivered. To remedy this, they’ve decided to build
    a speaker in the lab that plays when the doorbell is rung.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll build on the doorbell project from way back in [Chapter 2](ch02.xhtml#ch02).
    In this version of the project, we’ll use two micro:bits: one connected to a speaker,
    responsible for playing a tune, and a second one that acts as the doorbell button
    ([Figure 10-2](ch10.xhtml#ch10fig2)). When one of the buttons on the second micro:bit
    is pressed, it sends a radio message to the sound-making micro:bit, telling it
    to play a tune. Because the micro:bit radios have a pretty good range, your sound-playing
    micro:bit can be some distance from your door and, thus, closer to you.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: The wireless doorbell project*'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 × Micro:bit** One that acts as a doorbell button and another that plays
    a tune'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 × Alligator clip cables** To connect the micro:bit to the speaker'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 × USB power adapters or 3V battery packs with power switch** To power the
    micro:bits'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speaker** To play the doorbell tune, I recommend the Monk Makes Speaker for
    micro:bit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blu-Tak adhesive putty or self-adhesive pads** To attach one of the micro:bits
    to the door frame'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    and click the link for **Wireless Doorbell**. Copy the hex file onto both micro:bits.
    [Chapter 1](ch01.xhtml#ch01) explains the full process of getting programs onto
    your micro:bit if you need a refresher. If you want to run the MicroPython version
    of this experiment, that file is *ch_10_Wireless_Doorbell.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a speaker to one of the micro:bits. You can use the speaker you used
    in the musical doorbell project from [Chapter 2](ch02.xhtml#ch02) (see the instructions
    for this project if you get stuck).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the speaker by pressing button **A** on the doorbell micro:bit. The micro:bit
    attached to the speaker should immediately start playing the tune “The Entertainer.”
    When it’s finished, try pressing button **B**, and the “Funeral March” should
    play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Blu-Tak adhesive putty or pads to attach the speakerless micro:bit to
    the outside of your door.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both versions of the code rely on sending a message over the radio of either
    *db1* or *db2*, depending on which button is pressed. The receiving micro:bit
    then plays one of two tunes, depending on which message it receives.
  prefs: []
  type: TYPE_NORMAL
- en: As with Experiment 12, you cannot mix and match the MicroPython and Blocks versions
    of the code, so decide to use one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the Blocks code for the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0234-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ll notice that the code here is similar to that in Experiment 12\. If Button
    A is pressed, then the string `db1` (doorbell 1) is sent and a north arrow displayed
    to indicate that the message has been sent. The handler for when button B is pressed
    sends the message `db2`.
  prefs: []
  type: TYPE_NORMAL
- en: The receiving code checks whether the received message is `db1` or `db2` and
    plays the appropriate tune.
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroPython Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here is MicroPython version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: import radio, music
  prefs: []
  type: TYPE_NORMAL
- en: radio.on()
  prefs: []
  type: TYPE_NORMAL
- en: radio.config(power=7, group=1)
  prefs: []
  type: TYPE_NORMAL
- en: 'def send_message(message):'
  prefs: []
  type: TYPE_NORMAL
- en: radio.send(message)
  prefs: []
  type: TYPE_NORMAL
- en: display.show(Image.ARROW_N)
  prefs: []
  type: TYPE_NORMAL
- en: sleep(1000)
  prefs: []
  type: TYPE_NORMAL
- en: display.clear()
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if button_a.was_pressed():'
  prefs: []
  type: TYPE_NORMAL
- en: send_message("db1")
  prefs: []
  type: TYPE_NORMAL
- en: 'if button_b.was_pressed():'
  prefs: []
  type: TYPE_NORMAL
- en: send_message("db2")
  prefs: []
  type: TYPE_NORMAL
- en: message = radio.receive()
  prefs: []
  type: TYPE_NORMAL
- en: 'if message == ''db1'':'
  prefs: []
  type: TYPE_NORMAL
- en: music.play(music.ENTERTAINER)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif message == ''db2'':'
  prefs: []
  type: TYPE_NORMAL
- en: music.play(music.FUNERAL)
  prefs: []
  type: TYPE_NORMAL
- en: In this version of the code, we’ve defined the function `send_message`, which
    sends a message using the radio and displays the north arrow for a second.
  prefs: []
  type: TYPE_NORMAL
- en: As with the code in Experiment 12, we use a `while True` loop to continuously
    check for button presses and received messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Things to Try**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try swapping in different tunes. Or you might try changing the code so that
    when `db1` or `db2` is received, the tune is played more than once. Then the Mad
    Scientist will be more likely to hear it!
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works: Sending and Receiving**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might be wondering why we use the same code for both the sender and the
    receiver. If we press button A on the micro:bit with a speaker attached, shouldn’t
    it receive its own message and play a tune? It turns out that while the micro:bit’s
    radio is busy transmitting, it cannot receive anything. Also, having just one
    program avoids confusion about which program goes on which micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT: MICRO:BIT-CONTROLLED ROVER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Difficulty: Hard*'
  prefs: []
  type: TYPE_NORMAL
- en: No secret lab would be complete without a robot that can give instructions.
    Back in [Chapter 6](ch06.xhtml#ch06), we made a robot rover that could be controlled
    over Bluetooth using your phone. This project uses the same basic rover, but instead
    of controlling the rover with your phone and Bluetooth, you’ll use a second micro:bit
    and the micro:bit’s own way of communicating wirelessly. You’ll steer the rover
    by tilting the controlling micro:bit left, right, forward, or backward. [Figure
    10-3](ch10.xhtml#ch10fig3) shows the project, and you can see it in action at
    *[https://youtu.be/Qqr0fknoPQ4/](https://youtu.be/Qqr0fknoPQ4/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: A micro:bit-controlled rover*'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 × Micro:bit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kitronik Motor Driver Board for micro:bit (V2)** To control the forward and
    backward motors'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-cost robot chassis kit** Includes two gear motors and a 4 × AA battery
    box'
  prefs: []
  type: TYPE_NORMAL
- en: '**4 × AA batteries**'
  prefs: []
  type: TYPE_NORMAL
- en: '**AAA battery pack for micro:bit** To power the micro:bit being used as the
    remote control'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screwdrivers** Suitable for both the nuts and bolts on the chassis and the
    screw terminals on the motor controller board'
  prefs: []
  type: TYPE_NORMAL
- en: '**Soldering equipment** To attach wires to the gearmotors'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blu-Tack adhesive putty** To attach the motor control board and micro:bit
    to the chassis'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0237-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the rover you built in [Chapter 6](ch06.xhtml#ch06) or, if you haven’t built
    the rover yet, go back and follow construction steps 1 to 4 from that project.
    We’ll be using different software, however, so once the chassis is built, follow
    the instructions here. Don’t fit the batteries yet, or your rover might accidentally
    drive itself off your table!
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll install the program for the rover part of the project. Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    and click the link for **Rover**. Copy the hex file onto the micro:bit attached
    to the rover chassis. Head back to [Chapter 1](ch01.xhtml#ch01) if you need more
    detailed instructions on how to get programs onto your micro:bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now install the program for the micro:bit being used as the remote control.
    Go to the Github page, click the link for **Rover Controller**, click **Download**,
    and copy the hex file onto the micro:bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you let your robot loose in the lab, it’s worth testing out your project
    without the wheels touching the ground. You may need to swap over some of the
    motor wires so the rover follows the commands you send it correctly. Insert the
    batteries and then flip the rover on its back so you can see what the wheels are
    doing, without any danger of its driving away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip the controlling micro:bit to the left, and you should see the same left
    arrow appear on the displays of both micro:bits. At the same time, both wheels
    should turn in the same direction. As you look from above, the right wheel should
    be turning faster than the left. If one of the wheels is turning in the wrong
    direction, swap over the red and black wires at the motor controller screw terminal
    for that motor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try driving the rover around. Remember that if the vehicle gets stuck, you can
    stop it by putting the controller micro:bit into a horizontal position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The software uses two programs, one for the controller and another for the rover
    micro:bit. You can only use Blocks code for this project
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the code for the remote controller micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0239-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ll notice that in the `on start` block, we use a `radio set group` block.
    This block makes the micro:bit listen only to messages from other micro:bits in
    the same group—here group 1\. This prevents your micro:bit from picking up stray
    messages from other scientists in the area who might be using the same radio group
    and behaving unpredictably as a result. If you want to add other micro:bit pairs,
    change the number in the `radio set group` block to a different value for each
    micro:bit pair. Then each rover will be paired to a single controller. You can
    pick any number between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the program consists of `on gesture` blocks that handle the possible
    movement commands for the rover. For example, below the `on start` block, you
    have the `on tilt left` block, which transmits the string `L` and displays an
    `East` arrow when the micro:bit is tilted. Here’s the full list of commands that
    can be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`S` Stop'
  prefs: []
  type: TYPE_NORMAL
- en: '`L` Left'
  prefs: []
  type: TYPE_NORMAL
- en: '`R` Right'
  prefs: []
  type: TYPE_NORMAL
- en: '`B` Backward'
  prefs: []
  type: TYPE_NORMAL
- en: '`F` Forward'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rover Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the receiving code for these commands.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0240-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similar to the controller code, we have an `on start` block that sets the radio
    group to 1\. Remember that if you decide to change the radio group code, you have
    to do it on both micro:bits!
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is contained in an `on radio received` block. Inside the
    block is a series of `if` statements that test the incoming command letter and
    perform the action that letter signals. If the `L` command is received, for example,
    a left arrow is shown, and then motor 1 is set to go forward at 50 percent and
    motor 2 to go forward at 100 percent (full speed). This will make motor 2 (the
    right motor) go faster than the left motor, making the rover turn in an arc toward
    the left.
  prefs: []
  type: TYPE_NORMAL
- en: '**Things to Try**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try adding extra commands to the pair of programs. You’re getting a bit short
    on gestures to use, but you could add a `D` (for *dance*) command that tells the
    rover to do a little sequence of moves when the controller micro:bit is shaken.
  prefs: []
  type: TYPE_NORMAL
- en: You could also add a `C` (for *circle*) command that instructs the rover to
    spin on the spot by setting one motor forward at full speed and the other in reverse
    at full speed. This could be triggered by pressing button A or B.
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works: Motor Driver Blocks**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed a new category of blocks that appeared in your Blocks
    code when you opened the code for the rover: *Motor Driver blocks*. These blocks
    were created by Kitronik, the makers of the motor controller used in the project.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re starting a new project and want to use these blocks, you first need
    to add them to your project. To do this, click **Extensions** at the bottom of
    the list of block categories. This will open a dialog that looks something like
    [Figure 10-4](ch10.xhtml#ch10fig4). If the package isn’t listed after you search
    for it, refresh the browser page and try searching again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: Managing extensions in the Blocks editor*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the field at the top labeled *Search or enter project URL . . .* enter the
    following: *[https://github.com/KitronikLtd/pxt-kitronik-motor-driver/](https://github.com/KitronikLtd/pxt-kitronik-motor-driver/)*.
    To make sure you get the URL right, enter it into another browser tab first. When
    you’ve found the page, copy and paste the URL from your browser’s address bar
    to the field.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve entered the URL, you should see *kitronik-motor-driver*, as shown
    in [Figure 10-5](ch10.xhtml#ch10fig5). Click it, and you’ll find that your Blocks
    editor now has a new category containing the motor control blocks that you can
    drag into your code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: Managing extensions in the Blocks editor*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the package has been added to your project, it will be stored in the project
    forever. You won’t need to install it again, unless you start a new project and
    want to use the package there. Because the package is stored in the project, you
    can easily share the project with someone else, with no need for them to install
    the package.
  prefs: []
  type: TYPE_NORMAL
- en: '**SUMMARY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you tested the range of the micro:bit’s built-in radio, built
    a better doorbell, and made a remote-controlled rover. With its good range, the
    radio lets micro:bits communicate with each other easily, and it lends itself
    to all sorts of communication projects.
  prefs: []
  type: TYPE_NORMAL
- en: This is the final chapter in this book. The [appendix](app01.xhtml) that follows
    will give you some information about the parts you need to build the projects
    in this book and where you might obtain them.
  prefs: []
  type: TYPE_NORMAL
- en: The micro:bit community is a vibrant and active one. You’ll find lots of interesting
    projects to make and experiments to carry out involving your micro:bit. Take a
    look at *[https://microbit.org/ideas/](https://microbit.org/ideas/)* if you want
    some inspiration for what you, as a Mad Scientist, might do next with your micro:bit.
  prefs: []
  type: TYPE_NORMAL
