- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CENTRAL PROCESSING UNIT**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg195_Image_241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve learned about the electronic components that are used to build
    a central processing unit (CPU), it’s time for you to learn about some of the
    specifics of the ARM CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Arm Ltd is a design company that licenses its designs as *intellectual property
    (IP)* to other companies. The Raspberry Pi uses a *System on a Chip (SoC)* made
    by Broadcom. An SoC is an assembly of IP blocks in a single integrated circuit
    that includes a CPU and many of the other components of a computer system. The
    SoC used on a Raspberry Pi includes an ARM CPU IP block and other device IP blocks
    to work with the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: This book is based on the eighth version of the ARM CPU architecture, Armv8-A.
    This version is used in several Raspberry Pi models, including the Raspberry Pi
    3 A+, B, and B+, the Raspberry Pi 4 B, and the Raspberry Pi 5.
  prefs: []
  type: TYPE_NORMAL
- en: An Armv8-A processor can be run in either the AArch64 or the AArch32 execution
    state. *AArch64* is a 64-bit execution state that supports 64-bit addresses and
    the *A64* instruction set. The A64 instructions can use 64-bit registers for processing.
    *AArch32* is a 32-bit execution state that supports 32-bit addresses and the *A32*
    and *T32* instruction sets. (In previous Arm documentation, A32 was called ARM
    and T32 was called Thumb.) The A32 and T32 instructions can use 32-bit registers
    for processing.
  prefs: []
  type: TYPE_NORMAL
- en: A64 and A32 instructions are all 32 bits long. T32 instructions are either 32
    or 16 bits long. The T32 instruction set can be useful in implementations of the
    ARM architecture for small devices because it can reduce the amount of memory
    needed for a program. I use the A64 instruction set in the AArch64 execution state
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter with an overview of a typical CPU, then look at the
    registers in the AArch64 execution state and how a programmer accesses them. I’ll
    conclude the chapter with an example of using the `gdb` debugger to view the contents
    of the registers.
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU Overview**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you probably already know, the CPU is the heart of the computer. It follows
    the execution path that you specify in your program and performs all the arithmetic
    and logic operations. It also fetches the instructions and data from memory as
    they are needed by your program.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a look at the major subsystems of a typical CPU. I’ll follow
    this with a description of how the CPU fetches instructions from memory as it
    executes a program.
  prefs: []
  type: TYPE_NORMAL
- en: '***CPU Subsystems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9-1](ch09.xhtml#ch9fig1) shows a block diagram of the major subsystems
    of a typical CPU. This is a highly simplified diagram that shows only one processing
    core; actual CPUs are much more complicated, but the general concepts discussed
    here apply to most of them.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg196_Image_242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: The major subsystems of a CPU*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The subsystems are connected through internal buses, which are the hardware
    pathways and the protocols that control communications over these pathways. Let’s
    briefly look at each of the subsystems in [Figure 9-1](ch09.xhtml#ch9fig1). After
    this general introduction, we’ll look at the subsystems a programmer will be most
    interested in and how they’re used in the A64 architecture. The major CPU subsystems
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program counter** In the A64 architecture, the program counter register contains
    the memory address of the currently executing instruction. In many other architectures,
    it contains the address of the instruction immediately following the current one
    in memory. In the ARM A32 and T32 architectures, it contains the address of the
    instruction following the immediately following instruction. It’s commonly called
    the *instruction pointer* in x86 architectures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cache memory** Although it could be argued that this is not part of the CPU,
    most modern CPUs include some cache memory on the CPU chip. The way the CPU uses
    cache memory was explained in [Chapter 8](ch08.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction register** When an instruction is fetched, it’s loaded into the
    instruction register to be decoded and executed. The instruction register’s bit
    pattern determines what the control unit causes the CPU to do. Once that action
    has been completed, the bit pattern in the instruction register will be changed
    to that of the next instruction in the program, and the CPU will perform the operation
    specified by this new bit pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Register file** As you saw in [Chapter 8](ch08.xhtml), a register file is
    a group of registers used in similar ways. Most CPUs have several register files.
    For example, the A64 architecture includes a register file for integer operations
    and another register file for floating-point and vector operations. Compilers
    and assemblers have names for each register. All arithmetic and logic operations
    and data movement operations involve at least one register in a register file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control unit** The bits in the instruction register are decoded in the control
    unit. To carry out the action(s) specified by the instruction, the control unit
    generates the signals that control the other subsystems in the CPU. It’s typically
    implemented as a finite state machine and contains decoders, multiplexers, and
    other logic components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic logic unit (ALU)** The ALU is used to perform the arithmetic and
    logic operations you specify in your program. It’s also used by the CPU when it
    needs to do its own arithmetic (for example, to add two values to compute a memory
    address).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Condition flags** Each operation performed by the ALU results in various
    conditions that can be recorded for possible use by the program. For example,
    as discussed in [Chapter 3](ch03.xhtml), addition can produce a carry. The A64
    instruction set includes add and subtract instructions that will set one of the
    condition flags to either `0` (no carry) or `1` (carry) after the ALU has completed
    the operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bus interface** This is how the CPU communicates with the other computer
    subsystems—the memory and input/output (I/O) in [Figure 1-1](ch01.xhtml#ch1fig1)
    (see [Chapter 1](ch01.xhtml)). It contains the circuitry to place addresses on
    the address bus, to read and write data via the data bus, and to place control
    signals on the control bus. The bus interface on many CPUs interfaces with external
    bus control units that in turn interface with memory and with different types
    of I/O buses (for example, USB, SATA, or PCI-E).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Instruction Execution Cycle***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s go into a bit more detail about how the CPU executes a program stored
    in main memory. It does this by fetching the instructions from main memory using
    the three buses that you learned about in [Chapter 1](ch01.xhtml)—address, data,
    and control—through the bus interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the A64 architecture, the address in the *program counter* register always
    points to (has the memory address of) the currently executing instruction in a
    program. After fetching the instruction at this address, the CPU decodes and executes
    it. The CPU then adds 4 (the number of bytes in an instruction) to the program
    counter, causing it to contain the address of the next instruction in the program.
    Thus, the program counter marks the current location in a program.
  prefs: []
  type: TYPE_NORMAL
- en: There are instructions that change the address in the program counter, thus
    causing a *branch* from one place in the program to another. In this case, the
    address in the program counter is not incremented after the instruction is executed.
  prefs: []
  type: TYPE_NORMAL
- en: When the CPU fetches an instruction from memory, it loads that instruction into
    the instruction register. The bit pattern in the instruction register causes the
    CPU to perform the operations specified in the instruction. Once that action has
    been completed, another instruction is automatically loaded into the instruction
    register, and the CPU will perform the operation specified by this next bit pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern CPUs use an *instruction queue*, where several instructions wait,
    ready to be executed. Separate electronic circuitry keeps the instruction queue
    full while the regular control unit is executing the instructions. This is an
    implementation detail that allows the control unit to run faster; the essence
    of how the control unit executes a program can be represented by the single instruction
    register model, which is what I’ll describe here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to fetch each instruction from memory, and thus to execute a program,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of instructions is stored in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The memory address where the first instruction is located is copied to the program
    counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CPU sends the address in the program counter to memory on the address bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CPU sends a “read” signal on the control bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The memory responds by sending a copy of the state of the bits at that memory
    location on the data bus, which the CPU then copies into its instruction register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CPU executes the instruction in the instruction register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the instruction did not change the address in the program counter, the CPU
    automatically increments the program counter to contain the address of the next
    instruction in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 3, 4, and 5 are called an *instruction fetch*. Notice that steps 3 through
    8 constitute a cycle, known as the *instruction execution cycle*. [Figure 9-2](ch09.xhtml#ch9fig2)
    shows this graphically for nonbranching A64 instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg199_Image_243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: The instruction execution cycle for non-branching A64 instructions*'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU adds 4 to the program counter because each A64 instruction is 32 bits
    long. Some computer architectures add the instruction length to the program counter
    before executing the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In the ARM A32 instruction set architecture, the CPU adds 8 (the length of two
    instructions) to the address of the currently executing instruction. You learned
    in [Chapter 7](ch07.xhtml) that instructions are fetched and executed in stages
    in a pipeline. In the older 32-bit ARM architecture, two more instructions have
    been fetched and are moving through the pipeline before the current instruction
    is executed. This difference was preserved in the A32 mode of the AArch64 architecture
    to give backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, these differences will not matter to you, but as you will
    see when we discuss the coding of instructions in [Chapter 12](ch12.xhtml), knowing
    the details might help when debugging a program.
  prefs: []
  type: TYPE_NORMAL
- en: The `wfi` instruction in [Figure 9-2](ch09.xhtml#ch9fig2) causes the CPU to
    stop executing instructions and wait for an interrupt. The A64 has another instruction,
    `wfe`, that also stops instruction execution and waits for an event. The differences
    between interrupts and events are beyond the scope of this book; the important
    point is that there are instructions to tell the CPU to stop executing instructions,
    thus pausing the instruction execution cycle. You’ll learn more about interrupts
    in [Chapter 21](ch21.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Most instructions in a program use at least one register in at least one of
    the register files. A program typically loads data from memory into a register,
    operates on the data, and stores the result in memory. Registers are also used
    to hold addresses of items that are stored in memory, thus serving as pointers
    to data or other addresses.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the book, I will focus mostly on the A64 instruction set architecture.
    I recommend you download *Learn the Architecture—Introducing the ARM Architecture*
    from *[https://developer.arm.com/documentation/102404/latest](https://developer.arm.com/documentation/102404/latest)*.
    That document is more advanced than what I cover in this book, but one of my goals
    here is to help you learn how to read the more advanced presentations. Going back
    and forth between the two discussions will help you gain a better understanding
    of the material.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this chapter is largely devoted to describing the general-purpose
    registers in the A64 architecture. You’ll learn how to view their contents in
    the `gdb` debugger, and you’ll learn how to start using them in assembly language
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**A64 Registers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A portion of the memory in the CPU is organized into registers. Machine instructions
    access CPU registers by their addresses, just like they access main memory. Of
    course, the register addressing space is separate from the main memory addressing
    space; register addresses are placed on the internal CPU bus, not on the address
    portion of the bus interface, since the registers are in the CPU. The difference
    from a programmer’s point of view is that the assembler has predefined names for
    the registers, whereas the programmer creates symbolic names for memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, in each program you write in assembly language, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU registers are accessed by using the names that are predefined in the assembler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory is accessed by the programmer providing a name for the memory location
    and using that name in the user program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09.xhtml#ch9tab1) lists the basic programming registers in the
    A64 architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** The Basic A64 Registers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number** | **Size** | **Name** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 31 | 64-bit | `x0`–`x30` or `w0`–`w30` | General-purpose |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 64-bit | `sp` | Stack pointer |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 64-bit | `xzr` or `wzr` | Zero register |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 64-bit | `pc` | Program counter |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 64-bit | `nzcv` | Condition flags |'
  prefs: []
  type: TYPE_TB
- en: '| 32 | 128-bit | `d0`–`x31`, `s0`–`s31`, or `h0`–`h31` | Floating-point or
    vector |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 64-bit | `fpcr` | Floating-point control |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 64-bit | `fpsr` | Floating-point status |'
  prefs: []
  type: TYPE_TB
- en: The names `x0`–`x30` refer to the full 64 bits of the registers, and `w0`–`w30`
    refer to the 32 low-order bits of the same registers. Similarly, `xzr` is a 64-bit
    0 integer and `wzr` is a 32-bit 0 integer. For the floating-point registers, `d0`–`d31`
    refer to the full 128 bits, `s0`–`s31` to the low-order 64 bits, and `h0`–`h31`
    to the low-order 32 bits of the registers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some of these registers in more detail. I’ll start with the 31
    general-purpose registers, then we’ll look at several registers that have a special
    purpose. I’ll cover the floating-point registers in [Chapter 19](ch19.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '***General-Purpose Registers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The general-purpose registers are used for *integral data types*, such as `int`
    and `char` integer values (signed and unsigned), character representations, Boolean
    values, and memory addresses. Each bit in each register is numbered from right
    to left, beginning with 0\. So, the rightmost bit is number 0, the next one to
    the left is 1, and so on. Since there are 64 bits in each general-purpose register,
    the leftmost bit is number 63.
  prefs: []
  type: TYPE_NORMAL
- en: Each instruction in a computer treats a group of bits as a single unit. In the
    early days, that unit was called a *word*. Each CPU architecture had a *word size*.
    In modern CPU architectures, different instructions operate on different numbers
    of bits, but the terminology has carried over from the original 32-bit ARM architecture
    to the current 64-bit architecture. Hence, 8 bits is called a *byte*, 16 bits
    a *halfword*, 32 bits a *word*, 64 bits a *doubleword*, and 128 bits a *quadword*.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the general-purpose registers, `r0`–`r30` in the A64 architecture, can
    be accessed as either a 32-bit word or a 64-bit doubleword. Our assembler uses
    `w0`–`w30` for the word portion and `x0`–`x30` for the doubleword, as shown in
    [Figure 9-3](ch09.xhtml#ch9fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg202_Image_244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: A64 general-purpose register names*'
  prefs: []
  type: TYPE_NORMAL
- en: When an instruction writes to the low-order 32 bits of a register, the high-order
    32 bits are set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Special-Purpose Registers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, the program counter register, named `pc`, contains the
    address of the current instruction. Software cannot write directly to `pc`; it
    can only be modified indirectly with a *branch* instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s considered a general-purpose register, *branch with link* instructions
    use the `x30` register as a *link register*, named `lr`, to pass the return address
    when a function is called. I’ll explain this in detail in [Chapter 11](ch11.xhtml),
    but for now keep in mind that you need to be careful how you use the `x30` register
    when you write assembly language code.
  prefs: []
  type: TYPE_NORMAL
- en: You’re probably used to most things in a computer occurring in multiples of
    2, so you might be wondering why there are only 31 general-purpose registers.
    There is no register named `w31` or `x31`. Instead, the A64 architecture treats
    the 32nd register as a *stack pointer*, named `sp`, or a *zero register*, named
    `wzr` or `xzr`.
  prefs: []
  type: TYPE_NORMAL
- en: The *stack* is a data structure located in memory, and the `sp` register contains
    its address. I’ll cover all of this in detail in [Chapter 11](ch11.xhtml). The
    register name `wsp` refers to the low-order 32 bits of the stack pointer register.
    This would be used in specialized cases using 32-bit addressing that I won’t cover
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If your algorithm needs the value 0, many instructions allow you to use the
    `wzr` register for a 32-bit 0 or the `xzr` register for a 64-bit 0\. If you use
    an instruction to store a value in the zero register, the value is simply discarded;
    however, this does actually have a use, as you’ll see when we look at instructions
    that compare values in [Chapter 13](ch13.xhtml). The zero register does not need
    to be implemented as a physical register.
  prefs: []
  type: TYPE_NORMAL
- en: The condition flags, which you saw in [Figure 9-1](ch09.xhtml#ch9fig1), are
    located in the `nzcv` register. Several arithmetic and logical operations affect
    the condition flags, which are in bits 31 to 28 of the `nzcv` register, as shown
    in [Figure 9-4](ch09.xhtml#ch9fig4). The other 60 bits in this register are reserved
    for other uses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg203_Image_245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: The A64* nzcv *register*'
  prefs: []
  type: TYPE_NORMAL
- en: The names of the flags and the conditions that cause them to be true (have a
    value of `1`) are shown in [Table 9-2](ch09.xhtml#ch9tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** The Condition Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Function** | **Condition that sets flag to 1** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | Negative flag | Highest-order bit of result is `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `Z` | Zero flag | Result is `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | Carry flag | Shows carry or borrow |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | Overflow flag | Overflow of signed integer (two’s complement) arithmetic
    |'
  prefs: []
  type: TYPE_TB
- en: There are machine instructions for testing the state of the condition flags.
    For example, there’s an instruction that will branch to another place in the program
    if the `Z` flag is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at some C/C++ data types as they relate to the sizes of the
    general-purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: '**C/C++ Integral Data Types and Register Sizes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every piece of data in a computer program has a *data type*, which specifies
    the possible values for the data, the bit patterns used to represent those values,
    the operations that can be performed on the data, and the data’s semantic usage
    in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages, including C, C++, and Java, require the programmer
    to explicitly state the data types of values used in the program. Other languages,
    such as Python, BASIC, and JavaScript, can determine a data type from the way
    the value is used.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages specify the ranges for values that can be stored
    in a variable of each data type. For example, in C and C++, an `int` must be able
    to store a value in the range –32,768 to +32,767; thus, it must be at least 16
    bits in size. An `unsigned int` must be able to store values in the range 0 to
    65,535, so it also must be at least 16 bits. Programming environments can exceed
    the minimums given in the language specifications.
  prefs: []
  type: TYPE_NORMAL
- en: CPU manufacturers specify machine-level data types specific to the CPU architecture,
    often including specialized data types that are unique to the design. [Table 9-3](ch09.xhtml#ch9tab3)
    gives A64 register sizes for C/C++ data types you can expect from our compilers,
    `gcc` and `g++`, but you should be careful not to count on these sizes to always
    be the same. The `*`<data type> notation means a pointer to the memory address
    of the specified data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-3:** The Sizes of Some C/C++ Data Types in the A64 Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Size (bits)** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | 8 | Byte |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | 16 | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | 32 | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | 32 | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `long long` | 64 | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | 32 | Single-precision floating point |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | 64 | Double-precision floating point |'
  prefs: []
  type: TYPE_TB
- en: '| `*`<data type> | 64 | Pointer |'
  prefs: []
  type: TYPE_TB
- en: A value can usually be represented by more than one data type. For example,
    most people would think of 123 as representing the integer one hundred and twenty-three,
    but this value could be stored in a computer either as an `int` or as a `char[]`
    (a `char` array where each element of the array holds one code point for a character).
  prefs: []
  type: TYPE_NORMAL
- en: As [Table 9-3](ch09.xhtml#ch9tab3) indicates, an `int` in our C/C++ environment
    is stored in a word, so 123 would be stored with the bit pattern `0x0000007b`.
    As a C-style text string, we’d also need 4 bytes of memory, but the bit patterns
    would be `0x31`, `0x32`, `0x33`, and `0x00`—that is, the characters `1`, `2`,
    `3`, and `NUL`. (Recall that a C-style string is terminated with a `NUL` character.)
  prefs: []
  type: TYPE_NORMAL
- en: If your solution to a problem depends on data sizes, C standard libraries often
    define specific sizes. For example, the GNU C libraries define `int16_t` to be
    a 16-bit signed integer and `u_int16_t` to be a 16-bit unsigned integer. In rare
    cases, you may want to use assembly language to ensure correctness.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn a lot about how the CPU works by viewing what takes place in the
    registers. In the next section, you’ll learn how to view the registers by using
    the `gdb` debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using gdb to View the CPU Registers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ll use the program in [Listing 9-1](ch09.xhtml#ch9list1) to show you how to
    use `gdb` to view the contents of the CPU registers.
  prefs: []
  type: TYPE_NORMAL
- en: '*inches_to_feet.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: A simple program to illustrate the use of* gdb *to view CPU registers*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve used the `register` storage class modifier ❶ to request that the compiler
    use a CPU register for the `feet` and `inches` variables, instead of storing them
    in memory. The `register` modifier is advisory only; the C language standard doesn’t
    require the compiler to honor the request. But notice that I didn’t request that
    the compiler use a CPU register for the `total_inches` variable ❷. This variable
    must be placed in memory, as `scanf` needs a pointer to the location of `total_inches`
    ❸ to store the value read from the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'I introduced some `gdb` commands in [Chapter 2](ch02.xhtml). When you hit a
    breakpoint in a program that has been running, here are some additional commands
    that you may find useful for moving through the program under your control and
    viewing information about the program:'
  prefs: []
  type: TYPE_NORMAL
- en: n **(next)** Execute the current source code statement. If it’s a call to a
    function, the entire function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: s **(step)** Execute the current source code statement. If it’s a call to a
    function, step into the function, arriving at the first instruction of the called
    function.
  prefs: []
  type: TYPE_NORMAL
- en: si **(step instruction)** Execute the current machine instruction. If it’s a
    call to a function, step into the function.
  prefs: []
  type: TYPE_NORMAL
- en: sho arc **(show architecture)** Display the architecture that `gdb` is currently
    using. You can use this command to make sure `gdb` is being used in the AArch64
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how I used `gdb` to control the execution of the program shown in [Listing
    9-1](ch09.xhtml#ch9list1) and observe the register contents—note that you’ll probably
    see different addresses if you replicate this example on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I first compile the program ❶ and then load it in `gdb` ❷. The debugger starts
    by printing information about itself, which I’ve removed here to save space. I
    then list the source code ❸ so I know where to set breakpoints. Using the ENTER
    key ❹ (RETURN on some keyboards) repeats the previous command (without showing
    it).
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to follow along as the program processes the data, which I can do by
    setting breakpoints at strategic points in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I set the first breakpoint where the program is about to prompt the user to
    enter the input data, at line 15, and a second at the statement where the program’s
    computations begins, at line 18.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run the program, it breaks at the first breakpoint it encounters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The program stops at line 15 of the source code, and control returns to `gdb`.
    The `i r` command shows the contents of the registers (be sure to type a space
    between `i` and `r`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This display tells us the contents of the registers before the user enters data
    (you’ll see different numbers). We might want to know if the compiler honored
    our request to use registers for the `feet` and `inches` variables, and if it
    did, which registers it used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’d like to know this information so we can look at the contents of the registers
    before and after they’re used by the program to determine if the program is storing
    the correct values in them. We can answer this question by asking `gdb` to print
    the addresses of these two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we ask for the address of a variable, `gdb` will give the memory address
    associated with a programmer-supplied identifier. But in this program I asked
    the compiler to use registers, and `gdb` tells us which register the compiler
    chose for each variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'I didn’t ask the compiler to use registers for the `total_inches` and `ptr`
    variables, so `gdb` should tell us where they are located in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know `x19` is being used for `inches` and `x20` for `feet`, we
    can see what’s currently stored in these two registers before using them for our
    computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Rather than display all the registers, we can specify the two we want to look
    at ❶. We know from [Table 9-3](ch09.xhtml#ch9tab3) that `inches` and `feet` are
    using only the `w19` and `w20` portions of the `x19` and `x20` registers, but
    `gdb` always shows us the entire 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the program’s execution, the program asks the user to enter the
    number of inches. Here, I respond with `123`. It then breaks back into `gdb` at
    the next breakpoint it encounters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is about to compute the number of feet, and then it will compute
    the remainder of inches. Before starting the computations, let’s make sure the
    user’s input is stored in the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll now let the program do its computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Pressing the ENTER key repeats the `n` command ❶. The program is now ready
    to print out the results of the computations. Let’s check to make sure all the
    computations were performed correctly and the results are stored in the right
    places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other ways to see what’s stored in `inches` and `feet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When using `gdb`’s `print` command, you can print only one variable at a time,
    even if a register is being used to store the variable. The `$` prefix on the
    register name isn’t required for the `i r` command, but it is for the `print`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before completing execution of the program, let’s take a final look at all
    the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s nothing remarkable in this display, but after you gain some experience
    looking at such displays, you’ll learn to sometimes spot that something is not
    right. Now that I’m satisfied that the program performed all the computations
    correctly, I’ll continue to the end of the program by using `c` and then exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The program continues to execute, printing the result and returning control
    to `gdb`. Of course, the last thing to do is to exit from `gdb` with `q`.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 9.1     Modify the program in [Listing 9-1](ch09.xhtml#ch9list1) to request
    that registers be used for the variables `total_inches` and `ptr`. Did the compiler
    allow you to do that? If not, why?
  prefs: []
  type: TYPE_NORMAL
- en: 9.2     Write a program in C that allows you to determine the endianness of
    your computer (described on [page 33](ch02.xhtml#page_33) in [Chapter 2](ch02.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 9.3     Modify the program from [exercise 9.2](ch09.xhtml#ch9exe2) so you can
    demonstrate, using `gdb`, that endianness is a property of the CPU. That is, even
    though a 32-bit `int` is stored little-endian in memory, it will be read into
    a register in the “proper” order.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**General-purpose registers** The thirty-one 64-bit registers in the A64 architecture
    that provide a small amount of memory for computations in the CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Condition flags** Bits that show whether some arithmetic or logic operations
    produce carry, overflow, or negative or zero values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program counter** A pointer that holds the address of the instruction currently
    being executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction register** Holds the instruction currently being executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic logic unit (ALU)** Performs the specified arithmetic and logic
    operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control unit** Controls the activity in the CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bus interface** Responsible for interfacing the CPU with the main memory
    and I/O devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cache memory** Holds portions of the program, both instructions and data,
    that are currently being worked on by the CPU. Cache memory is faster than main
    memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction execution cycle** Details how the CPU works its way through a
    list of instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**C/C++ data type sizes** Data type sizes are closely related to register sizes.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll start programming your Raspberry Pi in assembly
    language.
  prefs: []
  type: TYPE_NORMAL
