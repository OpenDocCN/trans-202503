- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9'
- en: CENTRAL PROCESSING UNIT**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**中央处理单元**'
- en: '![Image](../images/pg195_Image_241.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg195_Image_241.jpg)'
- en: Now that you’ve learned about the electronic components that are used to build
    a central processing unit (CPU), it’s time for you to learn about some of the
    specifics of the ARM CPU.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了构建中央处理单元（CPU）的电子组件，是时候学习一些ARM CPU的具体细节了。
- en: Arm Ltd is a design company that licenses its designs as *intellectual property
    (IP)* to other companies. The Raspberry Pi uses a *System on a Chip (SoC)* made
    by Broadcom. An SoC is an assembly of IP blocks in a single integrated circuit
    that includes a CPU and many of the other components of a computer system. The
    SoC used on a Raspberry Pi includes an ARM CPU IP block and other device IP blocks
    to work with the CPU.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Arm Ltd是一家设计公司，将其设计作为*知识产权（IP）*授权给其他公司。树莓派使用由博通公司制造的*系统级芯片（SoC）*。SoC是在单一集成电路中组合的多个IP模块，包含CPU以及计算机系统的其他许多组件。树莓派使用的SoC包含一个ARM
    CPU IP模块和与CPU协同工作的其他设备IP模块。
- en: This book is based on the eighth version of the ARM CPU architecture, Armv8-A.
    This version is used in several Raspberry Pi models, including the Raspberry Pi
    3 A+, B, and B+, the Raspberry Pi 4 B, and the Raspberry Pi 5.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书基于第八版ARM CPU架构，Armv8-A。这个版本被多个树莓派模型使用，包括树莓派3 A+、B和B+，树莓派4 B以及树莓派5。
- en: An Armv8-A processor can be run in either the AArch64 or the AArch32 execution
    state. *AArch64* is a 64-bit execution state that supports 64-bit addresses and
    the *A64* instruction set. The A64 instructions can use 64-bit registers for processing.
    *AArch32* is a 32-bit execution state that supports 32-bit addresses and the *A32*
    and *T32* instruction sets. (In previous Arm documentation, A32 was called ARM
    and T32 was called Thumb.) The A32 and T32 instructions can use 32-bit registers
    for processing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Armv8-A处理器可以在AArch64或AArch32执行状态下运行。*AArch64*是一个64位执行状态，支持64位地址和*A64*指令集。A64指令可以使用64位寄存器进行处理。*AArch32*是一个32位执行状态，支持32位地址和*A32*以及*T32*指令集。（在之前的Arm文档中，A32被称为ARM，T32被称为Thumb。）A32和T32指令可以使用32位寄存器进行处理。
- en: A64 and A32 instructions are all 32 bits long. T32 instructions are either 32
    or 16 bits long. The T32 instruction set can be useful in implementations of the
    ARM architecture for small devices because it can reduce the amount of memory
    needed for a program. I use the A64 instruction set in the AArch64 execution state
    in this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: A64和A32指令都是32位长的。T32指令的长度为32位或16位。T32指令集在ARM架构的小型设备实现中很有用，因为它可以减少程序所需的内存量。本书中，我使用的是AArch64执行状态下的A64指令集。
- en: We’ll begin this chapter with an overview of a typical CPU, then look at the
    registers in the AArch64 execution state and how a programmer accesses them. I’ll
    conclude the chapter with an example of using the `gdb` debugger to view the contents
    of the registers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从典型CPU的概述开始，接着介绍AArch64执行状态中的寄存器以及程序员如何访问它们。最后，我将通过一个使用`gdb`调试器查看寄存器内容的示例来结束本章。
- en: '**CPU Overview**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**CPU概述**'
- en: As you probably already know, the CPU is the heart of the computer. It follows
    the execution path that you specify in your program and performs all the arithmetic
    and logic operations. It also fetches the instructions and data from memory as
    they are needed by your program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经知道的，CPU是计算机的核心。它按照你在程序中指定的执行路径进行操作，执行所有的算术和逻辑运算。它还从内存中获取程序所需的指令和数据。
- en: Let’s start with a look at the major subsystems of a typical CPU. I’ll follow
    this with a description of how the CPU fetches instructions from memory as it
    executes a program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从典型CPU的主要子系统入手。接下来我将描述CPU如何从内存中获取指令，并在执行程序时使用这些指令。
- en: '***CPU Subsystems***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CPU子系统***'
- en: '[Figure 9-1](ch09.xhtml#ch9fig1) shows a block diagram of the major subsystems
    of a typical CPU. This is a highly simplified diagram that shows only one processing
    core; actual CPUs are much more complicated, but the general concepts discussed
    here apply to most of them.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](ch09.xhtml#ch9fig1)展示了典型CPU主要子系统的框图。这是一个高度简化的图示，只展示了一个处理核心；实际的CPU要复杂得多，但这里讨论的一般概念适用于大多数CPU。'
- en: '![Image](../images/pg196_Image_242.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg196_Image_242.jpg)'
- en: '*Figure 9-1: The major subsystems of a CPU*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：CPU的主要子系统*'
- en: 'The subsystems are connected through internal buses, which are the hardware
    pathways and the protocols that control communications over these pathways. Let’s
    briefly look at each of the subsystems in [Figure 9-1](ch09.xhtml#ch9fig1). After
    this general introduction, we’ll look at the subsystems a programmer will be most
    interested in and how they’re used in the A64 architecture. The major CPU subsystems
    are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 各子系统通过内部总线连接，总线是硬件通道和控制这些通道通信的协议。我们简要看一下[图 9-1](ch09.xhtml#ch9fig1)中的每个子系统。在这个概述之后，我们将重点讨论程序员最关心的子系统以及它们在
    A64 架构中的使用。主要的 CPU 子系统包括：
- en: '**Program counter** In the A64 architecture, the program counter register contains
    the memory address of the currently executing instruction. In many other architectures,
    it contains the address of the instruction immediately following the current one
    in memory. In the ARM A32 and T32 architectures, it contains the address of the
    instruction following the immediately following instruction. It’s commonly called
    the *instruction pointer* in x86 architectures.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序计数器** 在 A64 架构中，程序计数器寄存器包含当前正在执行的指令的内存地址。在许多其他架构中，它包含紧跟当前指令之后的指令的地址。在 ARM
    A32 和 T32 架构中，它包含紧跟在紧跟指令之后的指令的地址。在 x86 架构中，它通常被称为*指令指针*。'
- en: '**Cache memory** Although it could be argued that this is not part of the CPU,
    most modern CPUs include some cache memory on the CPU chip. The way the CPU uses
    cache memory was explained in [Chapter 8](ch08.xhtml).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存内存** 尽管可以认为这不是 CPU 的一部分，但大多数现代 CPU 都在 CPU 芯片上集成了一些缓存内存。CPU 如何使用缓存内存在[第8章](ch08.xhtml)中已做解释。'
- en: '**Instruction register** When an instruction is fetched, it’s loaded into the
    instruction register to be decoded and executed. The instruction register’s bit
    pattern determines what the control unit causes the CPU to do. Once that action
    has been completed, the bit pattern in the instruction register will be changed
    to that of the next instruction in the program, and the CPU will perform the operation
    specified by this new bit pattern.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令寄存器** 当指令被获取时，它会被加载到指令寄存器中进行解码和执行。指令寄存器的位模式决定了控制单元使 CPU 执行的操作。一旦该操作完成，指令寄存器中的位模式将被更改为程序中下一个指令的位模式，CPU
    将执行由此新位模式指定的操作。'
- en: '**Register file** As you saw in [Chapter 8](ch08.xhtml), a register file is
    a group of registers used in similar ways. Most CPUs have several register files.
    For example, the A64 architecture includes a register file for integer operations
    and another register file for floating-point and vector operations. Compilers
    and assemblers have names for each register. All arithmetic and logic operations
    and data movement operations involve at least one register in a register file.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄存器文件** 正如你在[第8章](ch08.xhtml)中看到的，寄存器文件是用于相似操作的一组寄存器。大多数 CPU 都有多个寄存器文件。例如，A64
    架构包括一个用于整数运算的寄存器文件和另一个用于浮点和向量运算的寄存器文件。编译器和汇编器为每个寄存器指定了名称。所有算术和逻辑操作以及数据移动操作都至少涉及一个寄存器文件中的寄存器。'
- en: '**Control unit** The bits in the instruction register are decoded in the control
    unit. To carry out the action(s) specified by the instruction, the control unit
    generates the signals that control the other subsystems in the CPU. It’s typically
    implemented as a finite state machine and contains decoders, multiplexers, and
    other logic components.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制单元** 指令寄存器中的位会在控制单元中解码。为了执行指令所指定的操作，控制单元会生成控制 CPU 其他子系统的信号。它通常作为有限状态机实现，包含解码器、多路复用器和其他逻辑组件。'
- en: '**Arithmetic logic unit (ALU)** The ALU is used to perform the arithmetic and
    logic operations you specify in your program. It’s also used by the CPU when it
    needs to do its own arithmetic (for example, to add two values to compute a memory
    address).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**算术逻辑单元 (ALU)** ALU 用于执行程序中指定的算术和逻辑操作。当 CPU 需要执行自己的算术运算（例如，两个值相加以计算内存地址）时，也会使用
    ALU。'
- en: '**Condition flags** Each operation performed by the ALU results in various
    conditions that can be recorded for possible use by the program. For example,
    as discussed in [Chapter 3](ch03.xhtml), addition can produce a carry. The A64
    instruction set includes add and subtract instructions that will set one of the
    condition flags to either `0` (no carry) or `1` (carry) after the ALU has completed
    the operation.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件标志** ALU执行的每个操作都会产生不同的条件，这些条件可以被记录下来供程序使用。例如，如[第3章](ch03.xhtml)中讨论的，加法可能会产生进位。A64指令集包含加法和减法指令，在ALU完成操作后，它们会将其中一个条件标志设置为`0`（无进位）或`1`（有进位）。'
- en: '**Bus interface** This is how the CPU communicates with the other computer
    subsystems—the memory and input/output (I/O) in [Figure 1-1](ch01.xhtml#ch1fig1)
    (see [Chapter 1](ch01.xhtml)). It contains the circuitry to place addresses on
    the address bus, to read and write data via the data bus, and to place control
    signals on the control bus. The bus interface on many CPUs interfaces with external
    bus control units that in turn interface with memory and with different types
    of I/O buses (for example, USB, SATA, or PCI-E).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**总线接口** 这就是CPU与其他计算机子系统——内存和输入/输出（I/O）——通信的方式，如[图1-1](ch01.xhtml#ch1fig1)所示（参见[第1章](ch01.xhtml)）。它包含将地址放到地址总线、通过数据总线读写数据，以及将控制信号放到控制总线的电路。许多CPU的总线接口与外部总线控制单元接口，外部总线控制单元再与内存以及不同类型的I/O总线（例如USB、SATA或PCI-E）接口。'
- en: '***Instruction Execution Cycle***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指令执行周期***'
- en: Let’s go into a bit more detail about how the CPU executes a program stored
    in main memory. It does this by fetching the instructions from main memory using
    the three buses that you learned about in [Chapter 1](ch01.xhtml)—address, data,
    and control—through the bus interface.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下CPU如何执行存储在主内存中的程序。CPU通过使用你在[第1章](ch01.xhtml)中学习到的三条总线——地址总线、数据总线和控制总线——通过总线接口从主内存中获取指令。
- en: In the A64 architecture, the address in the *program counter* register always
    points to (has the memory address of) the currently executing instruction in a
    program. After fetching the instruction at this address, the CPU decodes and executes
    it. The CPU then adds 4 (the number of bytes in an instruction) to the program
    counter, causing it to contain the address of the next instruction in the program.
    Thus, the program counter marks the current location in a program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在A64架构中，*程序计数器*寄存器中的地址始终指向（具有当前执行指令的内存地址）程序中正在执行的指令。CPU获取此地址处的指令后，会对其进行解码并执行。然后，CPU会将4（指令的字节数）加到程序计数器中，使其包含程序中下一个指令的地址。因此，程序计数器标记了程序中的当前位置。
- en: There are instructions that change the address in the program counter, thus
    causing a *branch* from one place in the program to another. In this case, the
    address in the program counter is not incremented after the instruction is executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有些指令会改变程序计数器中的地址，从而导致程序从一个位置跳转到另一个位置。在这种情况下，指令执行后程序计数器中的地址不会增加。
- en: When the CPU fetches an instruction from memory, it loads that instruction into
    the instruction register. The bit pattern in the instruction register causes the
    CPU to perform the operations specified in the instruction. Once that action has
    been completed, another instruction is automatically loaded into the instruction
    register, and the CPU will perform the operation specified by this next bit pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU从内存中获取指令时，它将该指令加载到指令寄存器中。指令寄存器中的位模式使得CPU执行指令中指定的操作。一旦该操作完成，另一个指令会自动加载到指令寄存器中，CPU将执行下一个位模式所指定的操作。
- en: Most modern CPUs use an *instruction queue*, where several instructions wait,
    ready to be executed. Separate electronic circuitry keeps the instruction queue
    full while the regular control unit is executing the instructions. This is an
    implementation detail that allows the control unit to run faster; the essence
    of how the control unit executes a program can be represented by the single instruction
    register model, which is what I’ll describe here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代CPU使用*指令队列*，其中多个指令等待执行。专用的电子电路在常规控制单元执行指令时，保持指令队列的满载。这是一种实现细节，允许控制单元运行得更快；控制单元如何执行程序的本质可以通过单一的指令寄存器模型来表示，接下来我会描述这一点。
- en: 'The steps to fetch each instruction from memory, and thus to execute a program,
    are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存中获取每条指令的步骤，也就是执行程序的步骤如下：
- en: A sequence of instructions is stored in memory.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一系列指令被存储在内存中。
- en: The memory address where the first instruction is located is copied to the program
    counter.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一条指令所在的内存地址被复制到程序计数器。
- en: The CPU sends the address in the program counter to memory on the address bus.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU将程序计数器中的地址通过地址总线发送到内存。
- en: The CPU sends a “read” signal on the control bus.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU通过控制总线发送“读取”信号。
- en: The memory responds by sending a copy of the state of the bits at that memory
    location on the data bus, which the CPU then copies into its instruction register.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存通过数据总线响应，发送该内存位置的位状态副本，CPU随后将其复制到指令寄存器中。
- en: The CPU executes the instruction in the instruction register.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU执行指令寄存器中的指令。
- en: If the instruction did not change the address in the program counter, the CPU
    automatically increments the program counter to contain the address of the next
    instruction in memory.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指令没有更改程序计数器中的地址，CPU会自动递增程序计数器，使其包含内存中下一条指令的地址。
- en: Go back to step 3.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回第3步。
- en: Steps 3, 4, and 5 are called an *instruction fetch*. Notice that steps 3 through
    8 constitute a cycle, known as the *instruction execution cycle*. [Figure 9-2](ch09.xhtml#ch9fig2)
    shows this graphically for nonbranching A64 instructions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第3、4和5步被称为*指令获取*。注意，第3步到第8步构成一个周期，称为*指令执行周期*。[图9-2](ch09.xhtml#ch9fig2)以图形方式展示了非分支A64指令的情况。
- en: '![Image](../images/pg199_Image_243.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg199_Image_243.jpg)'
- en: '*Figure 9-2: The instruction execution cycle for non-branching A64 instructions*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：非分支A64指令的指令执行周期*'
- en: The CPU adds 4 to the program counter because each A64 instruction is 32 bits
    long. Some computer architectures add the instruction length to the program counter
    before executing the instruction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CPU向程序计数器添加4，因为每条A64指令的长度是32位。一些计算机架构在执行指令之前，会将指令长度加到程序计数器中。
- en: In the ARM A32 instruction set architecture, the CPU adds 8 (the length of two
    instructions) to the address of the currently executing instruction. You learned
    in [Chapter 7](ch07.xhtml) that instructions are fetched and executed in stages
    in a pipeline. In the older 32-bit ARM architecture, two more instructions have
    been fetched and are moving through the pipeline before the current instruction
    is executed. This difference was preserved in the A32 mode of the AArch64 architecture
    to give backward compatibility.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM A32指令集架构中，CPU将当前执行指令的地址加上8（两个指令的长度）。你在[第7章](ch07.xhtml)中学到，指令是通过管道分阶段获取并执行的。在较早的32位ARM架构中，在当前指令执行之前，已经取出了另外两条指令，并且这些指令正在通过管道。这一差异在AArch64架构的A32模式中得以保留，以实现向后兼容。
- en: Most of the time, these differences will not matter to you, but as you will
    see when we discuss the coding of instructions in [Chapter 12](ch12.xhtml), knowing
    the details might help when debugging a program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，这些差异对你来说并不重要，但正如你在[第12章](ch12.xhtml)讨论指令编码时所看到的，了解这些细节可能有助于调试程序。
- en: The `wfi` instruction in [Figure 9-2](ch09.xhtml#ch9fig2) causes the CPU to
    stop executing instructions and wait for an interrupt. The A64 has another instruction,
    `wfe`, that also stops instruction execution and waits for an event. The differences
    between interrupts and events are beyond the scope of this book; the important
    point is that there are instructions to tell the CPU to stop executing instructions,
    thus pausing the instruction execution cycle. You’ll learn more about interrupts
    in [Chapter 21](ch21.xhtml).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-2](ch09.xhtml#ch9fig2)中的`wfi`指令使得CPU停止执行指令并等待中断。A64架构还有一条指令`wfe`，它也会停止指令执行并等待事件。中断和事件的区别超出了本书的范围；关键点是，存在一些指令可以告诉CPU停止执行指令，从而暂停指令执行周期。你将在[第21章](ch21.xhtml)中进一步了解中断。'
- en: Most instructions in a program use at least one register in at least one of
    the register files. A program typically loads data from memory into a register,
    operates on the data, and stores the result in memory. Registers are also used
    to hold addresses of items that are stored in memory, thus serving as pointers
    to data or other addresses.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的大多数指令至少会使用一个寄存器文件中的一个寄存器。程序通常将数据从内存加载到寄存器中，对数据进行操作，然后将结果存储回内存。寄存器还用于保存存储在内存中的项目的地址，从而充当指向数据或其他地址的指针。
- en: At this point in the book, I will focus mostly on the A64 instruction set architecture.
    I recommend you download *Learn the Architecture—Introducing the ARM Architecture*
    from *[https://developer.arm.com/documentation/102404/latest](https://developer.arm.com/documentation/102404/latest)*.
    That document is more advanced than what I cover in this book, but one of my goals
    here is to help you learn how to read the more advanced presentations. Going back
    and forth between the two discussions will help you gain a better understanding
    of the material.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到了本书的这一部分，我将主要关注 A64 指令集架构。我建议你下载 *《了解架构—介绍 ARM 架构》*，可以通过 *[https://developer.arm.com/documentation/102404/latest](https://developer.arm.com/documentation/102404/latest)*
    获取。该文档比本书所涵盖的内容更高级，但我在这里的一个目标是帮助你学会如何阅读更高级的资料。两者之间反复对照将帮助你更好地理解这些内容。
- en: The remainder of this chapter is largely devoted to describing the general-purpose
    registers in the A64 architecture. You’ll learn how to view their contents in
    the `gdb` debugger, and you’ll learn how to start using them in assembly language
    in the next chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分主要用于描述 A64 架构中的通用寄存器。你将学习如何在 `gdb` 调试器中查看它们的内容，并将在下一章中学习如何在汇编语言中开始使用它们。
- en: '**A64 Registers**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**A64 寄存器**'
- en: A portion of the memory in the CPU is organized into registers. Machine instructions
    access CPU registers by their addresses, just like they access main memory. Of
    course, the register addressing space is separate from the main memory addressing
    space; register addresses are placed on the internal CPU bus, not on the address
    portion of the bus interface, since the registers are in the CPU. The difference
    from a programmer’s point of view is that the assembler has predefined names for
    the registers, whereas the programmer creates symbolic names for memory addresses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 内存的一部分被组织成寄存器。机器指令通过它们的地址访问 CPU 寄存器，就像它们访问主内存一样。当然，寄存器寻址空间与主内存寻址空间是分开的；寄存器地址被放置在内部
    CPU 总线上，而不是总线接口的地址部分，因为寄存器就在 CPU 内部。从程序员的角度来看，区别在于汇编器为寄存器预定义了名称，而程序员为内存地址创建符号名称。
- en: 'Thus, in each program you write in assembly language, the following happens:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你编写的每个汇编语言程序中，以下情况会发生：
- en: CPU registers are accessed by using the names that are predefined in the assembler.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 寄存器通过使用在汇编器中预定义的名称进行访问。
- en: Memory is accessed by the programmer providing a name for the memory location
    and using that name in the user program.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存是通过程序员为内存位置提供名称，并在用户程序中使用该名称来访问的。
- en: '[Table 9-1](ch09.xhtml#ch9tab1) lists the basic programming registers in the
    A64 architecture.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09.xhtml#ch9tab1) 列出了 A64 架构中的基本编程寄存器。'
- en: '**Table 9-1:** The Basic A64 Registers'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 基本 A64 寄存器'
- en: '| **Number** | **Size** | **Name** | **Usage** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **编号** | **大小** | **名称** | **用途** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 31 | 64-bit | `x0`–`x30` or `w0`–`w30` | General-purpose |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 31 | 64位 | `x0`–`x30` 或 `w0`–`w30` | 通用寄存器 |'
- en: '| 1 | 64-bit | `sp` | Stack pointer |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `sp` | 栈指针 |'
- en: '| 1 | 64-bit | `xzr` or `wzr` | Zero register |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `xzr` 或 `wzr` | 零寄存器 |'
- en: '| 1 | 64-bit | `pc` | Program counter |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `pc` | 程序计数器 |'
- en: '| 1 | 64-bit | `nzcv` | Condition flags |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `nzcv` | 条件标志 |'
- en: '| 32 | 128-bit | `d0`–`x31`, `s0`–`s31`, or `h0`–`h31` | Floating-point or
    vector |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 128位 | `d0`–`x31`，`s0`–`s31`，或 `h0`–`h31` | 浮点或向量 |'
- en: '| 1 | 64-bit | `fpcr` | Floating-point control |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `fpcr` | 浮点控制 |'
- en: '| 1 | 64-bit | `fpsr` | Floating-point status |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `fpsr` | 浮点状态 |'
- en: The names `x0`–`x30` refer to the full 64 bits of the registers, and `w0`–`w30`
    refer to the 32 low-order bits of the same registers. Similarly, `xzr` is a 64-bit
    0 integer and `wzr` is a 32-bit 0 integer. For the floating-point registers, `d0`–`d31`
    refer to the full 128 bits, `s0`–`s31` to the low-order 64 bits, and `h0`–`h31`
    to the low-order 32 bits of the registers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`x0`–`x30` 指的是寄存器的完整 64 位，`w0`–`w30` 指的是相同寄存器的 32 位低位。同样，`xzr` 是一个 64 位的 0
    整数，`wzr` 是一个 32 位的 0 整数。对于浮点寄存器，`d0`–`d31` 指的是完整的 128 位，`s0`–`s31` 指的是低 64 位，`h0`–`h31`
    指的是低 32 位的寄存器。'
- en: Let’s look at some of these registers in more detail. I’ll start with the 31
    general-purpose registers, then we’ll look at several registers that have a special
    purpose. I’ll cover the floating-point registers in [Chapter 19](ch19.xhtml).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些寄存器。我将从 31 个通用寄存器开始，然后我们将查看几个具有特殊用途的寄存器。我将在[第 19 章](ch19.xhtml)中讲解浮点寄存器。
- en: '***General-Purpose Registers***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通用寄存器***'
- en: The general-purpose registers are used for *integral data types*, such as `int`
    and `char` integer values (signed and unsigned), character representations, Boolean
    values, and memory addresses. Each bit in each register is numbered from right
    to left, beginning with 0\. So, the rightmost bit is number 0, the next one to
    the left is 1, and so on. Since there are 64 bits in each general-purpose register,
    the leftmost bit is number 63.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通用寄存器用于*整数数据类型*，例如 `int` 和 `char` 整数值（有符号和无符号）、字符表示、布尔值和内存地址。每个寄存器中的每一位按从右到左的顺序编号，从
    0 开始。所以最右边的位是 0，紧接着左边的是 1，依此类推。由于每个通用寄存器有 64 位，最左边的位是 63。
- en: Each instruction in a computer treats a group of bits as a single unit. In the
    early days, that unit was called a *word*. Each CPU architecture had a *word size*.
    In modern CPU architectures, different instructions operate on different numbers
    of bits, but the terminology has carried over from the original 32-bit ARM architecture
    to the current 64-bit architecture. Hence, 8 bits is called a *byte*, 16 bits
    a *halfword*, 32 bits a *word*, 64 bits a *doubleword*, and 128 bits a *quadword*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中的每条指令将一组位视为一个单独的单位。早期，这个单位被称为*字*。每个 CPU 架构都有一个*字长*。在现代 CPU 架构中，不同的指令操作在不同数量的位上，但术语从最初的
    32 位 ARM 架构延续到当前的 64 位架构。因此，8 位称为*字节*，16 位称为*半字*，32 位称为*字*，64 位称为*双字*，128 位称为*四字*。
- en: Each of the general-purpose registers, `r0`–`r30` in the A64 architecture, can
    be accessed as either a 32-bit word or a 64-bit doubleword. Our assembler uses
    `w0`–`w30` for the word portion and `x0`–`x30` for the doubleword, as shown in
    [Figure 9-3](ch09.xhtml#ch9fig3).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 A64 架构中，通用寄存器 `r0`–`r30` 可以作为 32 位字或 64 位双字进行访问。我们的汇编器使用 `w0`–`w30` 表示字部分，使用
    `x0`–`x30` 表示双字部分，如[图 9-3](ch09.xhtml#ch9fig3)所示。
- en: '![Image](../images/pg202_Image_244.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg202_Image_244.jpg)'
- en: '*Figure 9-3: A64 general-purpose register names*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：A64 通用寄存器名称*'
- en: When an instruction writes to the low-order 32 bits of a register, the high-order
    32 bits are set to `0`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当一条指令写入寄存器的低 32 位时，高 32 位会被设置为 `0`。
- en: '***Special-Purpose Registers***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***专用寄存器***'
- en: As you just learned, the program counter register, named `pc`, contains the
    address of the current instruction. Software cannot write directly to `pc`; it
    can only be modified indirectly with a *branch* instruction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你刚刚学到的，程序计数器寄存器，命名为 `pc`，包含当前指令的地址。软件不能直接写入 `pc`；它只能通过*分支*指令间接修改。
- en: Although it’s considered a general-purpose register, *branch with link* instructions
    use the `x30` register as a *link register*, named `lr`, to pass the return address
    when a function is called. I’ll explain this in detail in [Chapter 11](ch11.xhtml),
    but for now keep in mind that you need to be careful how you use the `x30` register
    when you write assembly language code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它被视为通用寄存器，*带链接分支*指令使用 `x30` 寄存器作为*链接寄存器*，命名为 `lr`，当调用函数时传递返回地址。我将在[第 11 章](ch11.xhtml)中详细解释这一点，但现在请记住，当你编写汇编语言代码时，使用
    `x30` 寄存器时需要小心。
- en: You’re probably used to most things in a computer occurring in multiples of
    2, so you might be wondering why there are only 31 general-purpose registers.
    There is no register named `w31` or `x31`. Instead, the A64 architecture treats
    the 32nd register as a *stack pointer*, named `sp`, or a *zero register*, named
    `wzr` or `xzr`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能习惯了计算机中的大多数事情以 2 的倍数发生，所以你可能会想为什么只有 31 个通用寄存器。没有名为 `w31` 或 `x31` 的寄存器。相反，A64
    架构将第 32 个寄存器视为*堆栈指针*，命名为 `sp`，或者*零寄存器*，命名为 `wzr` 或 `xzr`。
- en: The *stack* is a data structure located in memory, and the `sp` register contains
    its address. I’ll cover all of this in detail in [Chapter 11](ch11.xhtml). The
    register name `wsp` refers to the low-order 32 bits of the stack pointer register.
    This would be used in specialized cases using 32-bit addressing that I won’t cover
    in this book.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈*是一个位于内存中的数据结构，`sp` 寄存器包含其地址。我将在[第 11 章](ch11.xhtml)中详细讲解这一部分。寄存器名称 `wsp`
    指的是堆栈指针寄存器的低 32 位。这将用于使用 32 位寻址的特殊情况，在本书中我不会详细介绍这些内容。'
- en: If your algorithm needs the value 0, many instructions allow you to use the
    `wzr` register for a 32-bit 0 or the `xzr` register for a 64-bit 0\. If you use
    an instruction to store a value in the zero register, the value is simply discarded;
    however, this does actually have a use, as you’ll see when we look at instructions
    that compare values in [Chapter 13](ch13.xhtml). The zero register does not need
    to be implemented as a physical register.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的算法需要值 0，许多指令允许您使用 `wzr` 寄存器表示 32 位 0 或使用 `xzr` 寄存器表示 64 位 0。如果使用指令将值存储到零寄存器中，该值将被简单丢弃；然而，这实际上是有用途的，正如我们在
    [第 13 章](ch13.xhtml) 中看到的那样，比较值的指令会使用它。零寄存器不需要实现为物理寄存器。
- en: The condition flags, which you saw in [Figure 9-1](ch09.xhtml#ch9fig1), are
    located in the `nzcv` register. Several arithmetic and logical operations affect
    the condition flags, which are in bits 31 to 28 of the `nzcv` register, as shown
    in [Figure 9-4](ch09.xhtml#ch9fig4). The other 60 bits in this register are reserved
    for other uses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 状态标志，如您在 [图 9-1](ch09.xhtml#ch9fig1) 中看到的，位于 `nzcv` 寄存器中。多个算术和逻辑操作会影响状态标志，这些标志位于
    `nzcv` 寄存器的第 31 位到第 28 位，如 [图 9-4](ch09.xhtml#ch9fig4) 所示。该寄存器中的其他 60 位保留供其他用途。
- en: '![Image](../images/pg203_Image_245.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg203_Image_245.jpg)'
- en: '*Figure 9-4: The A64* nzcv *register*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：A64* nzcv *寄存器*'
- en: The names of the flags and the conditions that cause them to be true (have a
    value of `1`) are shown in [Table 9-2](ch09.xhtml#ch9tab2).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 标志的名称和导致它们为真（即值为 `1`）的条件，如 [表 9-2](ch09.xhtml#ch9tab2) 所示。
- en: '**Table 9-2:** The Condition Flags'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** 状态标志'
- en: '| **Name** | **Function** | **Condition that sets flag to 1** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **功能** | **将标志设置为 1 的条件** |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `N` | Negative flag | Highest-order bit of result is `1` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 负数标志 | 结果的最高位为 `1` |'
- en: '| `Z` | Zero flag | Result is `0` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Z` | 零标志 | 结果为 `0` |'
- en: '| `C` | Carry flag | Shows carry or borrow |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `C` | 进位标志 | 显示进位或借位 |'
- en: '| `V` | Overflow flag | Overflow of signed integer (two’s complement) arithmetic
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `V` | 溢出标志 | 有符号整数（补码）算术溢出 |'
- en: There are machine instructions for testing the state of the condition flags.
    For example, there’s an instruction that will branch to another place in the program
    if the `Z` flag is `1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 机器指令可以用来测试状态标志的状态。例如，有一条指令，当 `Z` 标志为 `1` 时，会跳转到程序中的另一个位置。
- en: Next, we’ll look at some C/C++ data types as they relate to the sizes of the
    general-purpose registers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一些 C/C++ 数据类型，它们与通用寄存器的大小有关。
- en: '**C/C++ Integral Data Types and Register Sizes**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**C/C++ 整型数据类型和寄存器大小**'
- en: Every piece of data in a computer program has a *data type*, which specifies
    the possible values for the data, the bit patterns used to represent those values,
    the operations that can be performed on the data, and the data’s semantic usage
    in the program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的每一段数据都有一个 *数据类型*，该数据类型指定了数据的可能值、表示这些值的位模式、可以对数据执行的操作以及数据在程序中的语义使用。
- en: Some programming languages, including C, C++, and Java, require the programmer
    to explicitly state the data types of values used in the program. Other languages,
    such as Python, BASIC, and JavaScript, can determine a data type from the way
    the value is used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言，包括 C、C++ 和 Java，要求程序员显式声明程序中使用的值的数据类型。其他语言，如 Python、BASIC 和 JavaScript，可以根据值的使用方式来确定数据类型。
- en: Most programming languages specify the ranges for values that can be stored
    in a variable of each data type. For example, in C and C++, an `int` must be able
    to store a value in the range –32,768 to +32,767; thus, it must be at least 16
    bits in size. An `unsigned int` must be able to store values in the range 0 to
    65,535, so it also must be at least 16 bits. Programming environments can exceed
    the minimums given in the language specifications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言会指定每种数据类型的变量所能存储的值的范围。例如，在 C 和 C++ 中，`int` 必须能够存储范围为 -32,768 到 +32,767
    的值；因此，它的大小至少为 16 位。`unsigned int` 必须能够存储范围为 0 到 65,535 的值，因此它也必须至少为 16 位。编程环境可以超过语言规范中给出的最小要求。
- en: CPU manufacturers specify machine-level data types specific to the CPU architecture,
    often including specialized data types that are unique to the design. [Table 9-3](ch09.xhtml#ch9tab3)
    gives A64 register sizes for C/C++ data types you can expect from our compilers,
    `gcc` and `g++`, but you should be careful not to count on these sizes to always
    be the same. The `*`<data type> notation means a pointer to the memory address
    of the specified data type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: CPU制造商指定了与CPU架构特定的机器级数据类型，通常包括一些在设计中独有的专用数据类型。[表9-3](ch09.xhtml#ch9tab3)给出了你可以从我们的编译器`gcc`和`g++`中预期的A64寄存器大小，但你应该小心，不要指望这些大小总是相同的。`*`<数据类型>表示指向指定数据类型内存地址的指针。
- en: '**Table 9-3:** The Sizes of Some C/C++ Data Types in the A64 Architecture'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-3：** A64架构中某些C/C++数据类型的大小'
- en: '| **Data type** | **Size (bits)** | **Description** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **大小（位）** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `char` | 8 | Byte |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 8 | 字节 |'
- en: '| `short` | 16 | Integer |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 16 | 整数 |'
- en: '| `int` | 32 | Integer |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 32 | 整数 |'
- en: '| `long` | 32 | Integer |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 32 | 整数 |'
- en: '| `long long` | 64 | Integer |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | 64 | 整数 |'
- en: '| `float` | 32 | Single-precision floating point |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 32 | 单精度浮点数 |'
- en: '| `double` | 64 | Double-precision floating point |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 64 | 双精度浮点数 |'
- en: '| `*`<data type> | 64 | Pointer |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `*`<数据类型> | 64 | 指针 |'
- en: A value can usually be represented by more than one data type. For example,
    most people would think of 123 as representing the integer one hundred and twenty-three,
    but this value could be stored in a computer either as an `int` or as a `char[]`
    (a `char` array where each element of the array holds one code point for a character).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值通常可以由多种数据类型表示。例如，大多数人会认为123表示整数一百二十三，但这个值可以在计算机中以`int`或`char[]`（一个`char`数组，其中每个元素存储一个字符的代码点）形式存储。
- en: As [Table 9-3](ch09.xhtml#ch9tab3) indicates, an `int` in our C/C++ environment
    is stored in a word, so 123 would be stored with the bit pattern `0x0000007b`.
    As a C-style text string, we’d also need 4 bytes of memory, but the bit patterns
    would be `0x31`, `0x32`, `0x33`, and `0x00`—that is, the characters `1`, `2`,
    `3`, and `NUL`. (Recall that a C-style string is terminated with a `NUL` character.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表9-3](ch09.xhtml#ch9tab3)所示，在我们的C/C++环境中，`int`是存储在一个字中的，因此123将以位模式`0x0000007b`存储。作为C风格的文本字符串，我们还需要4字节的内存，但位模式将是`0x31`，`0x32`，`0x33`，和`0x00`——也就是字符`1`，`2`，`3`和`NUL`。（回忆一下，C风格的字符串是以`NUL`字符结束的。）
- en: If your solution to a problem depends on data sizes, C standard libraries often
    define specific sizes. For example, the GNU C libraries define `int16_t` to be
    a 16-bit signed integer and `u_int16_t` to be a 16-bit unsigned integer. In rare
    cases, you may want to use assembly language to ensure correctness.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对问题的解决方案依赖于数据大小，C标准库通常定义了特定的大小。例如，GNU C库定义`int16_t`为16位有符号整数，`u_int16_t`为16位无符号整数。在少数情况下，你可能希望使用汇编语言来确保正确性。
- en: You can learn a lot about how the CPU works by viewing what takes place in the
    registers. In the next section, you’ll learn how to view the registers by using
    the `gdb` debugger.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看寄存器中发生的事情来了解很多关于CPU如何工作的知识。在下一节中，你将学习如何使用`gdb`调试器查看寄存器。
- en: '**Using gdb to View the CPU Registers**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用gdb查看CPU寄存器**'
- en: I’ll use the program in [Listing 9-1](ch09.xhtml#ch9list1) to show you how to
    use `gdb` to view the contents of the CPU registers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用[清单9-1](ch09.xhtml#ch9list1)中的程序来向你展示如何使用`gdb`查看CPU寄存器的内容。
- en: '*inches_to_feet.c*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*inches_to_feet.c*'
- en: '[PRE0]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: A simple program to illustrate the use of* gdb *to view CPU registers*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-1：一个简单的程序，演示如何使用* gdb *查看CPU寄存器*'
- en: I’ve used the `register` storage class modifier ❶ to request that the compiler
    use a CPU register for the `feet` and `inches` variables, instead of storing them
    in memory. The `register` modifier is advisory only; the C language standard doesn’t
    require the compiler to honor the request. But notice that I didn’t request that
    the compiler use a CPU register for the `total_inches` variable ❷. This variable
    must be placed in memory, as `scanf` needs a pointer to the location of `total_inches`
    ❸ to store the value read from the keyboard.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了`register`存储类修饰符❶，请求编译器使用CPU寄存器来存储`feet`和`inches`变量，而不是将它们存储在内存中。`register`修饰符只是建议性的；C语言标准并不要求编译器遵循这一请求。但请注意，我并没有请求编译器使用CPU寄存器来存储`total_inches`变量❷。这个变量必须放在内存中，因为`scanf`需要一个指向`total_inches`位置的指针❸来存储从键盘读取的值。
- en: 'I introduced some `gdb` commands in [Chapter 2](ch02.xhtml). When you hit a
    breakpoint in a program that has been running, here are some additional commands
    that you may find useful for moving through the program under your control and
    viewing information about the program:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第2章](ch02.xhtml)中介绍了一些`gdb`命令。当你在一个已经运行的程序中触发断点时，这里有一些额外的命令，你可能会发现它们有助于在控制程序的情况下移动并查看程序的信息：
- en: n **(next)** Execute the current source code statement. If it’s a call to a
    function, the entire function is executed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: n **(next)** 执行当前源代码语句。如果它是函数调用，则执行整个函数。
- en: s **(step)** Execute the current source code statement. If it’s a call to a
    function, step into the function, arriving at the first instruction of the called
    function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: s **(step)** 执行当前源代码语句。如果它是函数调用，则进入该函数，达到被调用函数的第一条指令。
- en: si **(step instruction)** Execute the current machine instruction. If it’s a
    call to a function, step into the function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: si **(step instruction)** 执行当前机器指令。如果它是函数调用，则进入该函数。
- en: sho arc **(show architecture)** Display the architecture that `gdb` is currently
    using. You can use this command to make sure `gdb` is being used in the AArch64
    mode.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: sho arc **(show architecture)** 显示`gdb`当前使用的架构。你可以使用此命令确保`gdb`以AArch64模式运行。
- en: 'Here’s how I used `gdb` to control the execution of the program shown in [Listing
    9-1](ch09.xhtml#ch9list1) and observe the register contents—note that you’ll probably
    see different addresses if you replicate this example on your own:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我如何使用`gdb`控制程序执行并观察寄存器内容的示例——请注意，如果你自己复制这个例子，可能会看到不同的地址：
- en: '[PRE1]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I first compile the program ❶ and then load it in `gdb` ❷. The debugger starts
    by printing information about itself, which I’ve removed here to save space. I
    then list the source code ❸ so I know where to set breakpoints. Using the ENTER
    key ❹ (RETURN on some keyboards) repeats the previous command (without showing
    it).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我先编译程序❶，然后将其加载到`gdb`中❷。调试器首先打印关于它自身的信息，我在这里删除了这些信息以节省空间。然后，我列出源代码❸，以便知道在哪里设置断点。使用回车键❹（某些键盘上的RETURN键）可以重复上一个命令（但不会显示该命令）。
- en: 'I want to follow along as the program processes the data, which I can do by
    setting breakpoints at strategic points in the program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我想跟踪程序处理数据的过程，方法是设置程序中一些关键点的断点：
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I set the first breakpoint where the program is about to prompt the user to
    enter the input data, at line 15, and a second at the statement where the program’s
    computations begins, at line 18.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我在程序提示用户输入数据的地方（第15行）设置了第一个断点，在程序开始进行计算的地方（第18行）设置了第二个断点。
- en: 'When I run the program, it breaks at the first breakpoint it encounters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行程序时，它会在遇到第一个断点时暂停：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The program stops at line 15 of the source code, and control returns to `gdb`.
    The `i r` command shows the contents of the registers (be sure to type a space
    between `i` and `r`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在源代码的第15行停止，控制权返回到`gdb`。`i r`命令显示寄存器的内容（确保在`i`和`r`之间输入空格）：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This display tells us the contents of the registers before the user enters data
    (you’ll see different numbers). We might want to know if the compiler honored
    our request to use registers for the `feet` and `inches` variables, and if it
    did, which registers it used.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此显示器告诉我们用户输入数据之前寄存器的内容（你会看到不同的数字）。我们可能想知道编译器是否按照我们的要求使用了`feet`和`inches`变量的寄存器，如果是，它使用了哪些寄存器。
- en: 'We’d like to know this information so we can look at the contents of the registers
    before and after they’re used by the program to determine if the program is storing
    the correct values in them. We can answer this question by asking `gdb` to print
    the addresses of these two variables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道这些信息，以便在程序使用寄存器之前和之后查看寄存器的内容，从而判断程序是否将正确的值存储在寄存器中。我们可以通过要求`gdb`打印这两个变量的地址来回答这个问题：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we ask for the address of a variable, `gdb` will give the memory address
    associated with a programmer-supplied identifier. But in this program I asked
    the compiler to use registers, and `gdb` tells us which register the compiler
    chose for each variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们询问一个变量的地址时，`gdb`会给出与程序员提供的标识符相关联的内存地址。但在这个程序中，我要求编译器使用寄存器，`gdb`会告诉我们编译器为每个变量选择了哪个寄存器。
- en: 'I didn’t ask the compiler to use registers for the `total_inches` and `ptr`
    variables, so `gdb` should tell us where they are located in memory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有要求编译器为`total_inches`和`ptr`变量使用寄存器，因此`gdb`应该会告诉我们它们在内存中的位置：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we know `x19` is being used for `inches` and `x20` for `feet`, we
    can see what’s currently stored in these two registers before using them for our
    computations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道`x19`用于存储`inches`，`x20`用于存储`feet`，在使用它们进行计算之前，我们可以查看这两个寄存器当前存储的内容：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rather than display all the registers, we can specify the two we want to look
    at ❶. We know from [Table 9-3](ch09.xhtml#ch9tab3) that `inches` and `feet` are
    using only the `w19` and `w20` portions of the `x19` and `x20` registers, but
    `gdb` always shows us the entire 64 bits.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定只查看我们想看的两个寄存器❶，而不是显示所有寄存器。根据[表9-3](ch09.xhtml#ch9tab3)，我们知道`inches`和`feet`只使用`x19`和`x20`寄存器的`w19`和`w20`部分，但`gdb`始终显示整个64位内容。
- en: 'Continuing the program’s execution, the program asks the user to enter the
    number of inches. Here, I respond with `123`. It then breaks back into `gdb` at
    the next breakpoint it encounters:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 程序继续执行，程序要求用户输入英寸的数量。在这里，我输入了`123`。接着，程序在遇到下一个断点时返回到`gdb`：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The program is about to compute the number of feet, and then it will compute
    the remainder of inches. Before starting the computations, let’s make sure the
    user’s input is stored in the right place:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 程序即将计算英尺的数量，然后计算剩余的英寸。在开始计算之前，让我们确保用户的输入已存储在正确的位置：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll now let the program do its computations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让程序进行计算：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Pressing the ENTER key repeats the `n` command ❶. The program is now ready
    to print out the results of the computations. Let’s check to make sure all the
    computations were performed correctly and the results are stored in the right
    places:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ENTER键会重复执行`n`命令❶。程序现在准备好打印出计算结果。让我们检查一下，确保所有的计算都正确执行，并且结果已存储在正确的位置：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are other ways to see what’s stored in `inches` and `feet`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以查看`inches`和`feet`中存储的内容：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When using `gdb`’s `print` command, you can print only one variable at a time,
    even if a register is being used to store the variable. The `$` prefix on the
    register name isn’t required for the `i r` command, but it is for the `print`
    command.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gdb`的`print`命令时，即使一个寄存器用来存储变量，你一次只能打印一个变量。`i r`命令的寄存器名称前不需要加`$`前缀，但`print`命令则需要加上。
- en: 'Before completing execution of the program, let’s take a final look at all
    the registers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成程序执行之前，让我们最后检查一下所有的寄存器：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There’s nothing remarkable in this display, but after you gain some experience
    looking at such displays, you’ll learn to sometimes spot that something is not
    right. Now that I’m satisfied that the program performed all the computations
    correctly, I’ll continue to the end of the program by using `c` and then exit:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个显示中没有什么特别之处，但当你积累一些查看此类显示的经验后，你会学会在某些时候发现问题所在。现在我已经确认程序正确执行了所有计算，我将继续执行程序的后续部分，使用`c`命令，然后退出：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The program continues to execute, printing the result and returning control
    to `gdb`. Of course, the last thing to do is to exit from `gdb` with `q`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 程序继续执行，打印结果并返回控制权给`gdb`。当然，最后要做的就是使用`q`命令退出`gdb`。
- en: '**YOUR TURN**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的练习**'
- en: 9.1     Modify the program in [Listing 9-1](ch09.xhtml#ch9list1) to request
    that registers be used for the variables `total_inches` and `ptr`. Did the compiler
    allow you to do that? If not, why?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 9.1 修改[清单9-1](ch09.xhtml#ch9list1)中的程序，要求为变量`total_inches`和`ptr`使用寄存器。编译器允许你这么做吗？如果不允许，为什么？
- en: 9.2     Write a program in C that allows you to determine the endianness of
    your computer (described on [page 33](ch02.xhtml#page_33) in [Chapter 2](ch02.xhtml)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 9.2 编写一个C程序，允许你确定计算机的字节序（详见[第33页](ch02.xhtml#page_33)的[第2章](ch02.xhtml)）。
- en: 9.3     Modify the program from [exercise 9.2](ch09.xhtml#ch9exe2) so you can
    demonstrate, using `gdb`, that endianness is a property of the CPU. That is, even
    though a 32-bit `int` is stored little-endian in memory, it will be read into
    a register in the “proper” order.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 9.3 修改[练习9.2](ch09.xhtml#ch9exe2)中的程序，使用`gdb`演示字节序是CPU的一个属性。也就是说，尽管32位的`int`在内存中以小端方式存储，但它会以“正确”的顺序读取到寄存器中。
- en: '**What You’ve Learned**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: '**General-purpose registers** The thirty-one 64-bit registers in the A64 architecture
    that provide a small amount of memory for computations in the CPU.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用寄存器** A64架构中的31个64位寄存器，它们为CPU中的计算提供了一小块内存。'
- en: '**Condition flags** Bits that show whether some arithmetic or logic operations
    produce carry, overflow, or negative or zero values.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件标志** 用于表示某些算术或逻辑操作是否产生了进位、溢出、负值或零值的位。'
- en: '**Program counter** A pointer that holds the address of the instruction currently
    being executed.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序计数器** 一个指针，保存当前正在执行的指令的地址。'
- en: '**Instruction register** Holds the instruction currently being executed.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令寄存器** 保存当前正在执行的指令。'
- en: '**Arithmetic logic unit (ALU)** Performs the specified arithmetic and logic
    operations.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**算术逻辑单元（ALU）** 执行指定的算术和逻辑操作。'
- en: '**Control unit** Controls the activity in the CPU.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制单元** 控制CPU中的活动。'
- en: '**Bus interface** Responsible for interfacing the CPU with the main memory
    and I/O devices.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**总线接口** 负责将CPU与主内存和I/O设备连接。'
- en: '**Cache memory** Holds portions of the program, both instructions and data,
    that are currently being worked on by the CPU. Cache memory is faster than main
    memory.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存内存** 保存当前CPU正在处理的程序部分，包括指令和数据。缓存内存比主内存更快。'
- en: '**Instruction execution cycle** Details how the CPU works its way through a
    list of instructions.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令执行周期** 详细描述CPU如何处理一系列指令。'
- en: '**C/C++ data type sizes** Data type sizes are closely related to register sizes.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**C/C++数据类型大小** 数据类型的大小与寄存器的大小密切相关。'
- en: In the next chapter, you’ll start programming your Raspberry Pi in assembly
    language.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将开始用汇编语言编程你的树莓派。
