- en: Chapter 8. ADVANCED ARITHMETIC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![ADVANCED ARITHMETIC](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter deals with those arithmetic operations for which assembly language
    is especially well suited. It covers four main topics: extended-precision arithmetic,
    arithmetic on operands whose sizes are different, decimal arithmetic, and computation
    via table lookup.'
  prefs: []
  type: TYPE_NORMAL
- en: By far, the most extensive subject this chapter covers is multiprecision arithmetic.
    By the conclusion of this chapter you will know how to apply arithmetic and logical
    operations to integer operands of any size. If you need to work with integer values
    outside the range ±2 billion (or with unsigned values beyond 4 billion), no sweat;
    this chapter shows you how to get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Different-size operands also present some special problems. For example, you
    may want to add a 64-bit unsigned integer to a 128-bit signed integer value. This
    chapter discusses how to convert these two operands to a compatible format.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also discusses decimal arithmetic using the 80x86 BCD (binary-coded
    decimal) instructions and the FPU (floating-point unit). This lets you use decimal
    arithmetic in those few applications that absolutely require base-10 operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter concludes by discussing how to speed up complex computations
    using table lookups.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Multiprecision Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One big advantage of assembly language over high-level languages is that assembly
    language does not limit the size of integer operations. For example, the standard
    C programming language defines three different integer sizes: `short int`, `int`,
    and `long int`.^([[111](#ftn.CHP-8-FN-1)]) On the PC, these are often 16- and
    32-bit integers. Although the 80x86 machine instructions limit you to processing
    8-, 16-, or 32-bit integers with a single instruction, you can always use multiple
    instructions to process integers of any size. If you want to add 256-bit integer
    values together, no problem; it''s relatively easy to accomplish this in assembly
    language. The following sections describe how to extend various arithmetic and
    logical operations from 16 or 32 bits to as many bits as you please.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 HLA Standard Library Support for Extended-Precision Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it is important for you to understand how to do extended-precision
    arithmetic yourself, you should note that the HLA Standard Library provides a
    full set of 64-bit and 128-bit arithmetic and logical functions that you can use.
    These routines are general purpose and very convenient to use. This section briefly
    describes the HLA Standard Library support for extended-precision arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in earlier chapters, the HLA compiler supports several different 64-bit
    and 128-bit data types. These extended data types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uns64`: 64-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int64`: 64-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qword`: 64-bit untyped values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uns128`: 128-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int128`: 128-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lword`: 128-bit untyped values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HLA also provides a `tbyte` type, but we will not consider that here (see [8.2
    Operating on Different-Size Operands](ch08s02.html "8.2 Operating on Different-Size
    Operands")).
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA fully supports 64-bit and 128-bit literal constants and constant arithmetic.
    This allows you to initialize 64- and 128-bit static objects using standard decimal,
    hexadecimal, or binary notation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to easily manipulate 64-bit and 128-bit values, the HLA Standard Library''s
    `math.hhf` module provides a set of functions that handle most of the standard
    arithmetic and logical operations. You use these functions in a manner similar
    to the 32-bit arithmetic and logical instructions. For example, consider the `math.addq`
    (`qword`) and `math.addl` (`lword`) functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions compute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These functions set the 80x86 flags the same way you'd expect after the execution
    of an `add` instruction. Specifically, these functions set the zero flag if the
    (full) result is 0, they set the carry flag if there is a carry from the H.O.
    bit, they set the overflow flag if there is a signed overflow, and they set the
    sign flag if the H.O. bit of the result contains 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the remaining arithmetic and logical routines use the same calling
    sequence as `math.addq` and `math.addl`. Briefly, here are those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions set the flags the same way as the corresponding 32-bit machine
    instructions and, in the case of the division and remainder (modulo) functions,
    raise the same exceptions. Note that the multiplication functions do not produce
    an extended-precision result. The destination value is the same size as the source
    operands. These functions set the overflow and carry flags if the result does
    not fit into the destination operand. All of these functions compute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: where *`op`* represents the specific operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these functions, the HLA Standard Library''s math module also
    provides a few additional functions whose syntax is slightly different from `math.addq`
    and `math.addl`. These functions include `math.negq`, `math.negl`, `math.notq`,
    `math.notl`, `math.shlq`, `math.shll`, `math.shrq`, and `math.shrl`. Note that
    there are no rotates or arithmetic shift-right functions. However, you''ll soon
    see that these operations are easy to synthesize using standard instructions.
    Here are the prototypes for these additional functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, all these functions set the flags exactly the same way the corresponding
    machine instructions would set the flags were they to support 64-bit or 128-bit
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library also provides a full complement of I/O and conversion
    routines for 64-bit and 128-bit values. For example, you can use `stdout.put`
    to display 64- and 128-bit values, you may use `stdin.get` to read these values,
    and there is a set of routines in the HLA conversions module that convert between
    these values and their string equivalents. In general, anything you can do with
    a 32-bit value can be done with a 64-bit or 128-bit value as well. See the HLA
    Standard Library documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 Multiprecision Addition Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 80x86 `add` instruction adds two 8-, 16-, or 32- bit numbers. After the
    execution of the `add` instruction, the 80x86 carry flag is set if there is an
    overflow out of the H.O. bit of the sum. You can use this information to do multiprecision
    addition operations. Consider the way you manually perform a multidigit (multiprecision)
    addition operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The 80x86 handles extended-precision arithmetic in an identical fashion, except
    instead of adding the numbers a digit at a time, it adds them together a byte,
    word, or double word at a time. Consider the three double-word (96-bit) addition
    operation in [Figure 8-1](ch08.html#adding_two_96-bit_objects_together "Figure 8-1. Adding
    two 96-bit objects together").
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding two 96-bit objects together](tagoreillycom20100401nostarchimages578043.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. Adding two 96-bit objects together
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this figure, the idea is to break up a larger operation
    into a sequence of smaller operations. Since the x86 processor family is capable
    of adding together, at most, 32 bits at a time, the operation must proceed in
    blocks of 32 bits or less. So the first step is to add the two L.O. double words
    together just as you would add the two L.O. digits of a decimal number together
    in the manual algorithm. There is nothing special about this operation; you can
    use the `add` instruction to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step involves adding together the second pair of double words in
    the two 96-bit values. Note that in step 2, the calculation must also add in the
    carry out of the previous addition (if any). If there is a carry out of the L.O.
    addition, the `add` instruction sets the carry flag to 1; conversely, if there
    is no carry out of the L.O. addition, the earlier `add` instruction clears the
    carry flag. Therefore, in this second addition, we really need to compute the
    sum of the two double words plus the carry out of the first instruction. Fortunately,
    the x86 CPUs provide an instruction that does exactly this: the `adc` (add with
    carry) instruction. The `adc` instruction uses the same syntax as the `add` instruction
    and performs almost the same operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only difference between the `add` and `adc` instructions
    is that the `adc` instruction adds in the value of the carry flag along with the
    source and destination operands. It also sets the flags the same way the `add`
    instruction does (including setting the carry flag if there is an unsigned overflow).
    This is exactly what we need to add together the middle two double words of our
    96-bit sum.
  prefs: []
  type: TYPE_NORMAL
- en: In step 3 of [Figure 8-1](ch08.html#adding_two_96-bit_objects_together "Figure 8-1. Adding
    two 96-bit objects together"), the algorithm adds together the H.O. double words
    of the 96-bit value. This addition operation must also incorporate the carry out
    of the sum of the middle two double words; hence the `adc` instruction is needed
    here as well. To sum it up, the `add` instruction adds the L.O. double words together.
    The `adc` (add with carry) instruction adds all other double word pairs together.
    At the end of the extended-precision addition sequence, the carry flag indicates
    unsigned overflow (if set), a set overflow flag indicates signed overflow, and
    the sign flag indicates the sign of the result. The zero flag doesn't have any
    real meaning at the end of the extended-precision addition (it simply means that
    the sum of the two H.O. double words is 0 and does not indicate that the whole
    result is 0). If you want to see how to check for an extended-precision zero result,
    see the source code for the HLA Standard Library `math.addq` or `math.addl` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that you have two 64-bit values you wish to add together,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose also that you want to store the sum in a third variable, `Z`, which
    is also a `qword`. The following 80x86 code will accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember, these variables are `qword` objects. Therefore the compiler will not
    accept an instruction of the form `mov( X, eax );` because this instruction would
    attempt to load a 64-bit value into a 32-bit register. This code uses the coercion
    operator to coerce symbols `X`, `Y`, and `Z` to 32 bits. The first three instructions
    add the L.O. double words of `X` and `Y` together and store the result at the
    L.O. double word of `Z`. The last three instructions add the H.O. double words
    of `X` and `Y` together, along with the carry from the L.O. word, and store the
    result in the H.O. double word of `Z`. Remember, address expressions of the form
    `X[4]` access the H.O. double word of a 64-bit entity. This is because the x86
    memory space addresses bytes, and it takes 4 consecutive bytes to form a double
    word.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extend this to any number of bits by using the `adc` instruction to
    add in the higher-order values. For example, to add together two 128-bit values,
    you could use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.3 Multiprecision Subtraction Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The 80x86 performs multibyte subtraction, just as it does addition, the same
    way you would manually, except it subtracts whole bytes, words, or double words
    at a time rather than decimal digits. The mechanism is similar to that for the
    `add` operation. You use the `sub` instruction on the L.O. byte/word/double word
    and the `sbb` (subtract with borrow) instruction on the high-order values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a 64-bit subtraction using the 32-bit registers
    on the 80x86:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates a 128-bit subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.4 Extended-Precision Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, there isn't a "compare with borrow" instruction that you can
    use to perform extended-precision comparisons. Since the `cmp` and `sub` instructions
    perform the same operation, at least as far as the flags are concerned, you'd
    probably guess that you could use the `sbb` instruction to synthesize an extended-precision
    comparison; however, that approach won't always work. Fortunately, there is a
    better solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the two unsigned values $2157 and $1293\. The L.O. bytes of these
    two values do not affect the outcome of the comparison. Simply comparing the H.O.
    bytes, $21 with $12, tells us that the first value is greater than the second.
    In fact, the only time you ever need to look at both bytes of these values is
    if the H.O. bytes are equal. In all other cases comparing the H.O. bytes tells
    you everything you need to know about the values. Of course, this is true for
    any number of bytes, not just 2\. The following code compares two signed 64-bit
    integers by comparing their H.O. double words first and comparing their L.O. double
    words only if the H.O. double words are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To compare unsigned values, simply use the `ja` and `jb` instructions in place
    of `jg` and `jl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily synthesize any possible comparison from the preceding sequence.
    The following examples show how to do this. These examples demonstrate signed
    comparisons; just substitute `ja`, `jae`, `jb`, and `jbe` for `jg`, `jge`, `jl`,
    and `jle` (respectively) if you want unsigned comparisons. Each of the following
    examples assumes these declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The following code implements a 64-bit test to see if `QW1 < QW2` (signed).
    Control transfers to `IsLess` label if `QW1 < QW2`. Control falls through to the
    next statement if this is not true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here is a 64-bit test to see if `QW1 <= QW2` (signed). This code jumps to `IsLessEq`
    if the condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a 64-bit test to see if `QW1 > QW2` (signed). It jumps to `IsGtr` if
    this condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The following is a 64-bit test to see if `QW1 >= QW2` (signed). This code jumps
    to label `IsGtrEQ` if this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here is a 64-bit test to see if `QW1 = QW2` (signed or unsigned). This code
    branches to the label `IsEqual` if `QW1 = QW2`. It falls through to the next instruction
    if they are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The following is a 64-bit test to see if `QW1 <> QW2` (signed or unsigned).
    This code branches to the label `NotEqual` if `QW1 <> QW2`. It falls through to
    the next instruction if they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot directly use the HLA high-level control structures if you need to
    perform an extended-precision comparison. However, you may use the HLA hybrid
    control structures and bury the appropriate comparison in the boolean expression.
    Doing so may produce easier to read code. For example, the following `if..then..else..endif`
    statement checks to see if `QW1 > QW2` using a 64-bit extended-precision unsigned
    comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to compare objects that are larger than 64 bits, it is very easy
    to generalize the code given above for 64-bit operands. Always start the comparison
    with the H.O. double words of the objects and work your way down to the L.O. double
    words of the objects as long as the corresponding double words are equal. The
    following example compares two 128-bit values to see if the first is less than
    or equal (unsigned) to the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.5 Extended-Precision Multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although an 8×8-bit, 16×16-bit, or 32×32-bit multiplication is usually sufficient,
    there are times when you may want to multiply larger values. You will use the
    x86 single operand `mul` and `imul` instructions for extended-precision multiplication
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not surprisingly (in view of how we achieved extended-precision addition using
    `adc` and `sbb`), you use the same techniques to perform extended-precision multiplication
    on the 80x86 that you employ when manually multiplying two values. Consider a
    simplified form of the way you perform multidigit multiplication by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The 80x86 does extended-precision multiplication in the same manner except that
    it works with bytes, words, and double words rather than digits. [Figure 8-2](ch08.html#extended-precision_multiplication-id1
    "Figure 8-2. Extended-precision multiplication") shows how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '![Extended-precision multiplication](tagoreillycom20100401nostarchimages578045.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. Extended-precision multiplication
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most important thing to remember when performing an extended-precision
    multiplication is that you must also perform a multiple-precision addition at
    the same time. Adding up all the partial products requires several additions that
    will produce the result. [Example 8-1](ch08.html#extended-precision_multiplication-id2
    "Example 8-1. Extended-precision multiplication") demonstrates the proper way
    to multiply two 64-bit values on a 32-bit processor.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1. Extended-precision multiplication
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: One thing you must keep in mind concerning this code is that it works only for
    unsigned operands. To multiply two signed values you must note the signs of the
    operands before the multiplication, take the absolute value of the two operands,
    do an unsigned multiplication, and then adjust the sign of the resulting product
    based on the signs of the original operands. Multiplication of signed operands
    is left as an exercise to the reader (or you could just check out the source code
    in the HLA Standard Library).
  prefs: []
  type: TYPE_NORMAL
- en: The example in [Example 8-1](ch08.html#extended-precision_multiplication-id2
    "Example 8-1. Extended-precision multiplication") was fairly straightforward because
    it was possible to keep the partial products in various registers. If you need
    to multiply larger values together, you will need to maintain the partial products
    in temporary (memory) variables. Other than that, the algorithm that [Example 8-1](ch08.html#extended-precision_multiplication-id2
    "Example 8-1. Extended-precision multiplication") uses generalizes to any number
    of double words.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.6 Extended-Precision Division
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You cannot synthesize a general *n*-bit/*m*-bit division operation using the
    `div` and `idiv` instructions. Extended-precision division requires a sequence
    of shift and subtract instructions and is extremely messy. However, a less-general
    operation, dividing an *n*-bit quantity by a 32-bit quantity, is easily synthesized
    using the `div` instruction. This section presents both methods for extended-precision
    division.
  prefs: []
  type: TYPE_NORMAL
- en: Before we describe how to perform a multiprecision division operation, you should
    note that some operations require an extended-precision division even though they
    may look calculable with a single `div` or `idiv` instruction. Dividing a 64-bit
    quantity by a 32-bit quantity is easy, as long as the resulting quotient fits
    into 32 bits. The `div` and `idiv` instructions will handle this directly. However,
    if the quotient does not fit into 32 bits, then you have to handle this problem
    as an extended-precision division. The trick here is to divide the (zero- or sign-extended)
    H.O. double word of the dividend by the divisor and then repeat the process with
    the remainder and the L.O. dword of the dividend. The following sequence demonstrates
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since it is perfectly legal to divide a value by 1, it is possible that the
    resulting quotient could require as many bits as the dividend. That is why the
    `quotient` variable in this example is the same size (64 bits) as the `dividend`
    variable (note the use of an array of two double words rather than a `qword` type;
    this spares the code from having to coerce the operands to double words). Regardless
    of the size of the dividend and divisor operands, the remainder is always no larger
    than the size of the division operation (32 bits in this case). Hence the `remainder`
    variable in this example is just a double word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before analyzing this code to see how it works, let''s take a brief look at
    why a single 64/32 division will not work for this particular example even though
    the `div` instruction does indeed calculate the result for a 64/32 division. The
    naive approach, assuming that the x86 were capable of this operation, would look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Although this code is syntactically correct and will compile, if you attempt
    to run this code it will raise an `ex.DivideError`^([[112](#ftn.CHP-8-FN-2)])
    exception. The reason is that the quotient must fit into 32 bits. Because the
    quotient turns out to be $2_0000_091A, it will not fit into the EAX register,
    hence the resulting exception.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take another look at the former code that correctly computes the 64/32
    quotient. This code begins by computing the 32/32 quotient of `dividend[4]/divisor`.
    The quotient from this division (2) becomes the H.O. double word of the final
    quotient. The remainder from this division (0) becomes the extension in EDX for
    the second half of the division operation. The second half of the code divides
    `edx:dividend[0]` by `divisor` to produce the L.O. double word of the quotient
    and the remainder from the division. Note that the code does not zero extend EAX
    into EDX prior to the second `div` instruction. EDX already contains valid bits,
    and this code must not disturb them.
  prefs: []
  type: TYPE_NORMAL
- en: The 64/32 division operation above is actually just a special case of the general
    division operation that lets you divide an arbitrary size value by a 32-bit divisor.
    To achieve this, you begin by moving the H.O. double word of the dividend into
    EAX and zero extending this into EDX. Next, you divide this value by the divisor.
    Then, without modifying EDX along the way, you store away the partial quotients,
    load EAX with the next-lower double word in the dividend, and divide it by the
    divisor. You repeat this operation until you've processed all the double words
    in the dividend. At that time the EDX register will contain the remainder. The
    program in [Example 8-2](ch08.html#unsigned_128_solidus_32-bit_extended-pre "Example 8-2. Unsigned
    128/32-bit extended-precision division") demonstrates how to divide a 128-bit
    quantity by a 32-bit divisor, producing a 128-bit quotient and a 32-bit remainder.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2. Unsigned 128/32-bit extended-precision division
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can extend this code to any number of bits by simply adding additional `mov`/`div`/`mov`
    instructions to the sequence. Like the extended-precision multiplication the previous
    section presents, this extended-precision division algorithm works only for unsigned
    operands. If you need to divide two signed quantities, you must note their signs,
    take their absolute values, do the unsigned division, and then set the sign of
    the result based on the signs of the operands.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use a divisor larger than 32 bits, you're going to have to implement
    the division using a shift-and-subtract strategy. Unfortunately, such algorithms
    are very slow. In this section we'll develop two division algorithms that operate
    on an arbitrary number of bits. The first is slow but easier to understand; the
    second is quite a bit faster (in the average case).
  prefs: []
  type: TYPE_NORMAL
- en: As for multiplication, the best way to understand how the computer performs
    division is to study how you were taught to do long division by hand. Consider
    the operation 3,456/12 and the steps you would take to manually perform this operation,
    as shown in [Figure 8-3](ch08.html#manual_digit-by-digit_division_operation "Figure 8-3. Manual
    digit-by-digit division operation").
  prefs: []
  type: TYPE_NORMAL
- en: '![Manual digit-by-digit division operation](tagoreillycom20100401nostarchimages578047.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3. Manual digit-by-digit division operation
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is actually easier in binary because at each step you do not
    have to guess how many times 12 goes into the remainder, nor do you have to multiply
    12 by your guess to obtain the amount to subtract. At each step in the binary
    algorithm the divisor goes into the remainder exactly zero or one times. As an
    example, consider the division of 27 (11011) by 3 (11) that is shown in [Figure 8-4](ch08.html#longhand_division_in_binary
    "Figure 8-4. Longhand division in binary").
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a novel way to implement this binary division algorithm that computes
    the quotient and the remainder at the same time. The algorithm is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Longhand division in binary](tagoreillycom20100401nostarchimages578049.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4. Longhand division in binary
  prefs: []
  type: TYPE_NORMAL
- en: '`NumberBits` is the number of bits in the `Remainder`, `Quotient`, `Divisor`,
    and `Dividend` variables. Note that the `Quotient := Quotient + 1;` statement
    sets the L.O. bit of `Quotient` to 1 because this algorithm previously shifts
    `Quotient` 1 bit to the left. The program in [Example 8-3](ch08.html#extended-precision_division-id1
    "Example 8-3. Extended-precision division") implements this algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3. Extended-precision division
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks simple but there are a few problems with it: It does not check
    for division by 0 (it will produce the value $FFFF_FFFF_FFFF_FFFF if you attempt
    to divide by 0), it handles only unsigned values, and it is very slow. Handling
    division by 0 is very simple; just check the divisor against 0 prior to running
    this code and return an appropriate error code if the divisor is 0 (or raise the
    `ex.DivisionError` exception). Dealing with signed values is the same as the earlier
    division algorithm: Note the signs, take the operands'' absolute values, do the
    unsigned division, and then fix the sign afterward. The performance of this algorithm,
    however, leaves a lot to be desired. It''s around an order of magnitude or two
    worse than the `div`/`idiv` instructions on the 80x86, and they are among the
    slowest instructions on the CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a technique you can use to boost the performance of this division
    by a fair amount: Check to see if the divisor variable uses only 32 bits. Often,
    even though the divisor is a 128-bit variable, the value itself fits just fine
    into 32 bits (that is, the H.O. double words of `Divisor` are 0). In this special
    case, which occurs frequently, you can use the `div` instruction, which is much
    faster. The algorithm is a bit more complex because you have to first compare
    the H.O. double words for 0, but on the average it runs much faster while remaining
    capable of dividing any two pairs of values.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.7 Extended-Precision neg Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although there are several ways to negate an extended-precision value, the
    shortest way for smaller values (96 bits or less) is to use a combination of `neg`
    and `sbb` instructions. This technique uses the fact that `neg` subtracts its
    operand from 0\. In particular, it sets the flags the same way the `sub` instruction
    would if you subtracted the destination value from 0\. This code takes the following
    form (assuming you want to negate the 64-bit value in EDX:EAX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `sbb` instruction decrements EDX if there is a borrow out of the L.O. word
    of the negation operation (which always occurs unless EAX is 0).
  prefs: []
  type: TYPE_NORMAL
- en: Extending this operation to additional bytes, words, or double words is easy;
    all you have to do is start with the H.O. memory location of the object you want
    to negate and work toward the L.O. byte. The following code computes a 128-bit
    negation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this code tends to get really large and slow because you need
    to propagate the carry through all the H.O. words after each negation operation.
    A simpler way to negate larger values is to simply subtract that value from 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.8 Extended-Precision and Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performing an *n*-byte `and` operation is very easy: Simply `and` the corresponding
    bytes between the two operands, saving the result. For example, to perform the
    `and` operation where all operands are 64 bits long, you could use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This technique easily extends to any number of words; all you need to do is
    logically `and` the corresponding bytes, words, or double words together in the
    operands. Note that this sequence sets the flags according to the value of the
    last `and` operation. If you `and` the H.O. double words last, this sets all but
    the zero flag correctly. If you need to test the zero flag after this sequence,
    you will need to logically `or` the two resulting double words together (or otherwise
    compare them both against 0).
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.9 Extended-Precision or Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multibyte logical `or` operations are performed in the same way as multibyte
    `and` operations. You simply `or` the corresponding bytes in the two operands
    together. For example, to logically `or` two 96-bit values, use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As for the previous example, this does not set the zero flag properly for the
    entire operation. If you need to test the zero flag after a multiprecision `or`,
    you must logically `or` all the resulting double words together.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.10 Extended-Precision xor Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extended-precision `xor` operations are performed in a manner identical to
    `and`/`or`—simply `xor` the corresponding bytes in the two operands to obtain
    the extended-precision result. The following code sequence operates on two 64-bit
    operands, computes their exclusive-`or`, and stores the result into a 64-bit variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The comment about the zero flag in the previous two sections applies here.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.11 Extended-Precision not Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `not` instruction inverts all the bits in the specified operand. An extended-precision
    `not` is performed by simply executing the `not` instruction on all the affected
    operands. For example, to perform a 64-bit `not` operation on the value in `(edx:eax)`,
    all you need to do is execute the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that if you execute the `not` instruction twice, you wind up with
    the `or`iginal value. Also note that exclusive-`or`ing a value with all 1s ($FF,
    $FFFF, or $FFFF_FFFF) performs the same operation as the `not` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.12 Extended-Precision Shift Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extended-precision shift operations require a shift and a rotate instruction.
    Consider what must happen to implement a 64-bit `shl` using 32-bit operations
    (see [Figure 8-5](ch08.html#bit_shift-left_operation "Figure 8-5. 64-bit shift-left
    operation")):'
  prefs: []
  type: TYPE_NORMAL
- en: A 0 must be shifted into bit 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bits 0 through 30 are shifted into the next-higher bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bit 31 is shifted into bit 32.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bits 32 through 62 must be shifted into the next-higher bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bit 63 is shifted into the carry flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![64-bit shift-left operation](tagoreillycom20100401nostarchimages578051.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5. 64-bit shift-left operation
  prefs: []
  type: TYPE_NORMAL
- en: 'The two instructions you can use to implement this 64-bit shift are `shl` and
    `rcl`. For example, to shift the 64-bit quantity in (EDX:EAX) one position to
    the left, you''d use the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that using this technique you can shift an extended-precision value only
    1 bit at a time. You cannot shift an extended-precision operand several bits using
    the CL register. Nor can you specify a constant value greater than 1 using this
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this instruction sequence works, consider the operation of
    the individual instructions. The `shl` instruction shifts a 0 into bit 0 of the
    64-bit operand and shifts bit 31 into the carry flag. The `rcl` instruction then
    shifts the carry flag into bit 32 and then shifts bit 63 into the carry flag.
    The result is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a shift left on an operand larger than 64 bits, you simply use additional
    `rcl` instructions. An extended-precision shift-left operation always starts with
    the least-significant double word, and each succeeding `rcl` instruction operates
    on the next-most-significant double word. For example, to perform a 96-bit shift-left
    operation on a memory location, you could use the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to shift your data by 2 or more bits, you can either repeat the
    above sequence the desired number of times (for a constant number of shifts) or
    you can place the instructions in a loop to repeat them some number of times.
    For example, the following code shifts the 96-bit value *`Operand`* to the left
    the number of bits specified in ECX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You implement `shr` and `sar` in a similar way, except you must start at the
    H.O. word of the operand and work your way down to the L.O. word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There is one major difference between the extended-precision shifts described
    here and their 8/16/32-bit counterparts—the extended-precision shifts set the
    flags differently than the single-precision operations. This is because the rotate
    instructions affect the flags differently than the shift instructions. Fortunately,
    the carry flag is the one you'll test most often after a shift operation, and
    the extended-precision shift operations (i.e., rotate instructions) properly set
    this flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shld` and `shrd` instructions let you efficiently implement multiprecision
    shifts of several bits. These instructions have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `shld` instruction works as shown in [Figure 8-6](ch08.html#shld_operation
    "Figure 8-6. shld operation").
  prefs: []
  type: TYPE_NORMAL
- en: '![shld operation](tagoreillycom20100401nostarchimages578053.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6. `shld` operation
  prefs: []
  type: TYPE_NORMAL
- en: '*`Operand1`* must be a 16- or 32-bit register. *`Operand2`* can be a register
    or a memory location. Both operands must be the same size. The immediate operand
    can be a value in the range 0 through *n*−1, where *n* is the number of bits in
    the two operands; this operand specifies the number of bits to shift.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shld` instruction shifts bits in *`Operand2`* to the left. The H.O. bits
    shift into the carry flag, and the H.O. bits of *`Operand1`* shift into the L.O.
    bits of *`Operand2`*. Note that this instruction does not modify the value of
    *`Operand1`*; it uses a temporary copy of *`Operand1`* during the shift. The immediate
    operand specifies the number of bits to shift. If the count is *n*, then `shld`
    shifts bit *n*−1 into the carry flag. It also shifts the H.O. *n* bits of *`Operand1`*
    into the L.O. *n* bits of *`Operand2`*. The `shld` instruction sets the flag bits
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the shift count is 0, the `shld` instruction doesn't affect any flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The carry flag contains the last bit shifted out of the H.O. bit of the *`Operand2`*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the shift count is 1, the overflow flag will contain 1 if the sign bit of
    *`Operand2`* changes during the shift. If the count is not 1, the overflow flag
    is undefined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The zero flag will be 1 if the shift produces a 0 result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sign flag will contain the H.O. bit of the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `shrd` instruction is similar to `shld` except, of course, it shifts its
    bits right rather than left. To get a clear picture of the `shrd` instruction,
    consider [Figure 8-7](ch08.html#shrd_operation "Figure 8-7. shrd operation").
  prefs: []
  type: TYPE_NORMAL
- en: '![shrd operation](tagoreillycom20100401nostarchimages578055.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7. `shrd` operation
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shrd` instruction sets the flag bits as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the shift count is 0, the `shrd` instruction doesn't affect any flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The carry flag contains the last bit shifted out of the L.O. bit of the *`Operand2`*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the shift count is 1, the overflow flag will contain 1 if the H.O. bit of
    *`Operand2`* changes. If the count is not 1, the overflow flag is undefined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The zero flag will be 1 if the shift produces a 0 result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sign flag will contain the H.O. bit of the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first `shld` instruction above shifts the bits from `ShiftMe[4]` into `ShiftMe[8]`
    without affecting the value in `ShiftMe[4]`. The second `shld` instruction shifts
    the bits from `ShiftMe` into `ShiftMe[4]`. Finally, the `shl` instruction shifts
    the L.O. double word the appropriate amount. There are two important things to
    note about this code. First, unlike the other extended-precision shift-left operations,
    this sequence works from the H.O. double word down to the L.O. double word. Second,
    the carry flag does not contain the carry from the H.O. shift operation. If you
    need to preserve the carry flag at that point, you will need to push the flags
    after the first `shld` instruction and pop the flags after the `shl` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: You can do an extended-precision shift-right operation using the `shrd` instruction.
    It works almost the same way as the code sequence above, except you work from
    the L.O. double word to the H.O. double word. The solution is left as an exercise
    for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.13 Extended-Precision Rotate Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `rcl` and `rcr` operations extend in a manner almost identical to `shl`
    and `shr`. For example, to perform 96-bit `rcl` and `rcr` operations, use the
    following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this code and the code for the extended-precision
    shift operations is that the first instruction is a `rcl` or `rcr` rather than
    a `shl` or `shr` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing an extended-precision `rol` or `ror` operation isn''t quite as simple.
    You can use the `bt`, `shld`, and `shrd` instructions to implement an extended-precision
    `rol` or `ror` instruction. The following code shows how to use the `shld` instruction
    to do an extended-precision `rol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: An extended-precision `ror` instruction is similar; just keep in mind that you
    work on the L.O. end of the object first and the H.O. end last.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.14 Extended-Precision I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you can do extended-precision arithmetic, the next problem is how to get
    those extended-precision values into your program and how to display their values
    to the user. HLA's Standard Library provides routines for unsigned decimal, signed
    decimal, and hexadecimal I/O for values that are 8, 16, 32, 64, or 128 bits in
    length. So as long as you're working with values whose size is less than or equal
    to 128 bits in length, you can use the Standard Library code. If you need to input
    or output values that are greater than 128 bits in length, you will need to write
    your own procedures to handle the operation. This section discusses the strategies
    you will need to write such routines.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section work specifically with 128-bit values. The algorithms
    are perfectly general and extend to any number of bits (indeed, the 128-bit algorithms
    in this section are really nothing more than the algorithms the HLA Standard Library
    uses for 128-bit values). Of course, if you need a set of 128-bit unsigned I/O
    routines, you can use the Standard Library code as is. If you need to handle larger
    values, simple modifications to the following code are all that should be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sections that follow use a common set of 128-bit data types in order to
    avoid having to coerce `lword`/`uns128`/`int128` values in each instruction. Here
    are these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.14.1 Extended-Precision Hexadecimal Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Extended-precision hexadecimal output is very easy. All you have to do is output
    each double-word component of the extended-precision value from the H.O. double
    word to the L.O. double word using a call to the `stdout.puth32` routine. The
    following procedure does exactly this to output an `lword` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the HLA Standard Library supplies a `stdout.puth128` procedure that
    directly writes `lword` values, so you can call `stdout.puth128` multiple times
    when outputting larger values (e.g., a 256-bit value). As it turns out, the implementation
    of the HLA `stdlib.puth128` routine is very similar to `puth128`, above.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.14.2 Extended-Precision Unsigned Decimal Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decimal output is a little more complicated than hexadecimal output because
    the H.O. bits of a binary number affect the L.O. digits of the decimal representation
    (this was not true for hexadecimal values, which is why hexadecimal output is
    so easy). Therefore, we will have to create the decimal representation for a binary
    number by extracting one decimal digit at a time from the number.
  prefs: []
  type: TYPE_NORMAL
- en: The most common solution for unsigned decimal output is to successively divide
    the value by 10 until the result becomes 0\. The remainder after the first division
    is a value in the range 0..9, and this value corresponds to the L.O. digit of
    the decimal number. Successive divisions by 10 (and their corresponding remainder)
    extract successive digits from the number.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative solutions to this problem generally allocate storage for a string
    of characters large enough to hold the entire number. Then the code extracts the
    decimal digits in a loop and places them in the string one by one. At the end
    of the conversion process, the routine prints the characters in the string in
    reverse order (remember, the divide algorithm extracts the L.O. digits first and
    the H.O. digits last, the opposite of the way you need to print them).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we employ a recursive solution because it is a little more
    elegant. The recursive solution begins by dividing the value by 10 and saving
    the remainder in a local variable. If the quotient is not 0, the routine recursively
    calls itself to print any leading digits first. On return from the recursive call
    (which prints all the leading digits), the recursive algorithm prints the digit
    associated with the remainder to complete the operation. Here''s how the operation
    works when printing the decimal value 789:'
  prefs: []
  type: TYPE_NORMAL
- en: Divide 789 by 10\. Quotient is 78, and remainder is 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the remainder (9) in a local variable and recursively call the routine
    with the quotient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Recursive entry 1] Divide 78 by 10\. Quotient is 7, and remainder is 8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the remainder (8) in a local variable and recursively call the routine
    with the quotient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Recursive entry 2] Divide 7 by 10\. Quotient is 0, and remainder is 7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the remainder (7) in a local variable. Because the quotient is 0, don't
    call the routine recursively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the remainder value saved in the local variable (7). Return to the caller
    (recursive entry 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Return to recursive entry 1] Output the remainder value saved in the local
    variable in recursive entry 1 (8). Return to the caller (original invocation of
    the procedure).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Original invocation] Output the remainder value saved in the local variable
    in the original call (9). Return to the original caller of the output routine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only operation that requires extended-precision calculation through this
    entire algorithm is the "divide by 10" statement. Everything else is simple and
    straightforwar. We are in luck with this algorithm, because we are dividing an
    extended-precision value by a value that easily fits into a double word, and we
    can use the fast (and easy) extended-precision division algorithm that uses the
    `div` instruction. The program in [Example 8-4](ch08.html#bit_extended-precision_decimal_output_r
    "Example 8-4. 128-bit extended-precision decimal output routine") implements a
    128-bit decimal output routine utilizing this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4. 128-bit extended-precision decimal output routine
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.14.3 Extended-Precision Signed Decimal Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have an extended-precision unsigned decimal output routine, writing
    an extended-precision signed decimal output routine is very easy. The basic algorithm
    takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the sign of the number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is positive, call the unsigned output routine to print it. If the number
    is negative, print a minus sign. Then negate the number and call the unsigned
    output routine to print it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To check the sign of an extended-precision integer, of course, you simply test
    the H.O. bit of the number. To negate a large value, the best solution is probably
    to subtract that value from 0\. Here''s a quick version of `puti128` that uses
    the `putu128` routine from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.14.4 Extended-Precision Formatted Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code in the previous two sections prints signed and unsigned integers using
    the minimum number of necessary print positions. To create nicely formatted tables
    of values you will need the equivalent of a `puti128Size` or `putu128Size` routine.
    Once you have the "unformatted" versions of these routines, implementing the formatted
    versions is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to write `i128Size` and `u128Size` routines that compute the
    minimum number of digits needed to display the value. The algorithm to accomplish
    this is very similar to the numeric output routines. In fact, the only difference
    is that you initialize a counter to 0 upon entry into the routine (for example,
    the nonrecursive shell routine), and you increment this counter rather than outputting
    a digit on each recursive call. (Don't forget to increment the counter inside
    `i128Size` if the number is negative; you must allow for the output of the minus
    sign.) After the calculation is complete, these routines should return the size
    of the operand in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the `i128Size` and `u128Size` routines, writing the formatted
    output routines is easy. Upon initial entry into `puti128Size` or `putu128Size`,
    these routines call the corresponding `size` routine to determine the number of
    print positions for the number to display. If the value that the `size` routine
    returns is greater than the absolute value of the minimum size parameter (passed
    into `puti128Size` or `putu128Size`), all you need to do is call the `put` routine
    to print the value; no other formatting is necessary. If the absolute value of
    the parameter size is greater than the value `i128Size` or `u128Size` returns,
    then the program must compute the difference between these two values and print
    that many spaces (or other filler characters) before printing the number (if the
    parameter size value is positive) or after printing the number (if the parameter
    size value is negative). The actual implementation of these two routines is left
    as an exercise to the reader (or just check out the source code in the HLA Standard
    Library for the `stdout.putiSize128` and `stdout.putuSize128` routines).
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library implements the `i128Size` and `u128Size` by doing a
    set of successive extended-precision comparisons to determine the number of digits
    in the values. Interested readers may want to look at the source code for these
    routines as well as the source code for the `stdout.puti128` and `stdout.putu128`
    procedures (this source code appears on Webster at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.14.5 Extended-Precision Input Routines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a couple of fundamental differences between the extended-precision
    output routines and the extended-precision input routines. First of all, numeric
    output generally occurs without possibility of error;^([[113](#ftn.CHP-8-FN-3)])
    numeric input, on the other hand, must handle the very real possibility of an
    input error such as illegal characters and numeric overflow. Also, HLA's Standard
    Library and runtime system encourage a slightly different approach to input conversion.
    This section discusses those issues that differentiate input conversion from output
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the biggest difference between input and output conversion is the fact
    that output conversion is not bracketed. That is, when converting a numeric value
    to a string of characters for output, the output routine does not concern itself
    with characters preceding the output string, nor is it concerned with the characters
    following the numeric value in the output stream. Numeric output routines convert
    their data to a string and print that string without considering the context (that
    is, the characters before and after the string representation of the numeric value).
    Numeric input routines cannot be so cavalier; the contextual information surrounding
    the numeric string is very important.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical numeric input operation consists of reading a string of characters
    from the user and then translating this string of characters into an internal
    numeric representation. For example, a statement like `stdin.get(i32)`; typically
    reads a line of text from the user and converts a sequence of digits appearing
    at the beginning of that line of text into a 32-bit signed integer (assuming `i32`
    is an `int32` object). Note, however, that the `stdin.get` routine skips over
    certain characters in the string that may appear before the actual numeric characters.
    For example, `stdin.get` automatically skips any leading spaces in the string.
    Likewise, the input string may contain additional data beyond the end of the numeric
    input (for example, it is possible to read two integer values from the same input
    line), and therefore the input conversion routine must somehow determine where
    the numeric data ends in the input stream. Fortunately, HLA provides a simple
    mechanism that lets you easily determine the start and end of the input data:
    the `Delimiters` character set.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Delimiters` character set is a variable, internal to the HLA Standard Library,
    that contains the set of legal characters that may precede or follow a legal numeric
    value. By default, this character set includes the end-of-string marker (a 0 byte),
    a tab character, a line-feed character, a carriage-return character, a space,
    a comma, a colon, and a semicolon. Therefore, HLA's numeric input routines will
    automatically ignore any characters in this set that occur on input before a numeric
    string. Likewise, characters from this set may legally follow a numeric string
    on input (conversely, if any non-delimiter character follows the numeric string,
    HLA will raise an `ex.ConversionError` exception).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Delimiters` character set is a private variable inside the HLA Standard
    Library. Although you do not have direct access to this object, the HLA Standard
    Library does provide two accessor functions, `conv.setDelimiters` and `conv.getDelimiters`,
    that let you access and modify the value of this character set. These two functions
    have the following prototypes (found in the *conv.hhf* header file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `conv.setDelimiters` procedure will copy the value of the `Delims` parameter
    into the internal `Delimiters` character set. Therefore, you can use this procedure
    to change the character set if you want to use a different set of delimiters for
    numeric input. The `conv.getDelimiters` call returns a copy of the internal `Delimiters`
    character set in the variable you pass as a parameter to the `conv.getDelimiters`
    procedure. We will use the value returned by `conv.getDelimiters` to determine
    the end of numeric input when writing our own extended-precision numeric input
    routines.
  prefs: []
  type: TYPE_NORMAL
- en: When reading a numeric value from the user, the first step is to get a copy
    of the `Delimiters` character set. The second step is to read and discard input
    characters from the user as long as those characters are members of the `Delimiters`
    character set. Once a character is found that is not in the `Delimiters` set,
    the input routine must check this character and verify that it is a legal numeric
    character. If not, the program should raise an `ex.IllegalChar` exception if the
    character's value is outside the range $00..$7F, or it should raise the `ex.ConversionError`
    exception if the character is not a legal numeric character. Once the routine
    encounters a numeric character, it should continue reading characters as long
    as they are valid numeric characters; while reading the characters, the conversion
    routine should be translating them to the internal representation of the numeric
    data. If, during conversion, an overflow occurs, the procedure should raise the
    `ex.ValueOutOfRange` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversion to numeric representation should end when the procedure encounters
    the first delimiter character at the end of the string of digits. However, it
    is very important that the procedure does not consume the delimiter character
    that ends the string. That is, the following is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first `while` loop reads a sequence of delimiter characters. When this first
    `while` loop ends, the character in AL is not a delimiter character. The second
    `while` loop processes a sequence of decimal digits. First, it checks the character
    read in the previous `while` loop to see if it is a decimal digit; if so, it processes
    that digit and reads the next character. This process continues until the call
    to `stdin.getc` (at the bottom of the loop) reads a nondigit character. After
    the second `while` loop, the program checks the last character read to ensure
    that it is a legal delimiter character for a numeric input value.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this algorithm is that it consumes the delimiter character
    after the numeric string. For example, the colon symbol is a legal delimiter in
    the default `Delimiters` character set. If the user types the input **`123:456`**
    and executes the code above, this code will properly convert `123` to the numeric
    value 123\. However, the very next character read from the input stream will be
    the character 4, not the colon character (:). While this may be acceptable in
    certain circumstances, most programmers expect numeric input routines to consume
    only leading delimiter characters and the numeric digit characters. They do not
    expect the input routine to consume any trailing delimiter characters (for example,
    many programs will read the next character and expect a colon as input if presented
    with the string `123:456`). Because `stdin.getc` consumes an input character,
    and there is no way to put the character back onto the input stream, some other
    way of reading input characters from the user that doesn't consume those characters
    is needed.^([[114](#ftn.CHP-8-FN-4)])
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLA Standard Library comes to the rescue by providing the `stdin.peekc`
    function. Like `stdin.getc`, the `stdin.peekc` routine reads the next input character
    from HLA''s internal buffer. There are two major differences between `stdin.peekc`
    and `stdin.getc`. First, `stdin.peekc` will not force the input of a new line
    of text from the user if the current input line is empty (or you''ve already read
    all the text from the input line). Instead, `stdin.peekc` simply returns 0 in
    the AL register to indicate that there are no more characters on the input line.
    Because #0 (the NUL character) is (by default) a legal delimiter character for
    numeric values, and the end of line is certainly a legal way to terminate numeric
    input, this works out rather well. The second difference between `stdin.getc`
    and `stdin.peekc` is that `stdin.peekc` does not consume the character read from
    the input buffer. If you call `stdin.peekc` several times in a row, it will always
    return the same character; likewise, if you call `stdin.getc` immediately after
    `stdin.peekc`, the call to `stdin.getc` will generally return the same character
    as returned by `stdin.peekc` (the only exception being the end-of-line condition).
    So, although we cannot put characters back onto the input stream after we''ve
    read them with `stdin.getc`, we can peek ahead at the next character on the input
    stream and base our logic on that character''s value. A corrected version of the
    previous algorithm might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that the call to `stdin.peekc` in the second `while` does not consume the
    delimiter character when the expression evaluates false. Hence, the delimiter
    character will be the next character read after this algorithm finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only remaining comment to make about numeric input is to point out that
    the HLA Standard Library input routines allow arbitrary underscores to appear
    within a numeric string. The input routines ignore these underscore characters.
    This allows the user to input strings like FFFF_F012 and 1_023_596, which are
    a little more readable than FFFFF012 and 1023596\. Allowing underscores (or any
    other symbol you choose) within a numeric input routine is quite simple; just
    modify the second `while` loop above as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 8.1.14.6 Extended-Precision Hexadecimal Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As was the case for numeric output, hexadecimal input is the easiest numeric
    input routine to write. The basic algorithm for hexadecimal-string-to-numeric
    conversion is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the extended-precision value to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each input character that is a valid hexadecimal digit, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the hexadecimal character to a value in the range 0..15 ($0..$F).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the H.O. 4 bits of the extended-precision value are nonzero, raise an exception.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the current extended-precision value by 16 (i.e., shift left 4 bits).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the converted hexadecimal digit value to the accumulator.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the last input character to ensure it is a valid delimiter. Raise an exception
    if it is not.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The program in [Example 8-5](ch08.html#extended-precision_hexadecimal_input-id1
    "Example 8-5. Extended-precision hexadecimal input") implements this extended-precision
    hexadecimal input routine for 128-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5. Extended-precision hexadecimal input
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Extending this code to handle objects that are greater than 128 bits long is
    very easy. There are only three changes necessary: You must zero out the whole
    object at the beginning of the `getb128` routine; when checking for overflow (the
    `test( $F, (type byte LocalValue[15]) );` instruction), you must test the H.O.
    4 bits of the new object you''re processing; and you must modify the code that
    multiplies `LocalValue` by 16 (via `shld`) so that it multiplies your object by
    16 (i.e., shifts it to the left 4 bits).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.14.7 Extended-Precision Unsigned Decimal Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm for extended-precision unsigned decimal input is nearly identical
    to that for hexadecimal input. In fact, the only difference (beyond only accepting
    decimal digits) is that you multiply the extended-precision value by 10 rather
    than 16 for each input character (in general, the algorithm is the same for any
    base; just multiply the accumulating value by the input base). The code in [Example 8-6](ch08.html#extended-precision_unsigned_decimal_-016
    "Example 8-6. Extended-precision unsigned decimal input") demonstrates how to
    write a 128-bit unsigned decimal input routine.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6. Extended-precision unsigned decimal input
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As for hexadecimal input, extending this decimal input to some number of bits
    beyond 128 is fairly easy. All you need do is modify the code that zeros out the
    `LocalValue` variable and the code that multiplies `LocalValue` by 10 (overflow
    checking is done in this same code, so there are only two spots in this code that
    require modification).
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.14.8 Extended-Precision Signed Decimal Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have an unsigned decimal input routine, writing a signed decimal input
    routine is easy. The following algorithm describes how to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: Consume any delimiter characters at the beginning of the input stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the next input character is a minus sign, consume this character and set
    a flag noting that the number is negative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the unsigned decimal input routine to convert the rest of the string to
    an integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the return result to make sure its H.O. bit is clear. Raise the `ex.ValueOutOfRange`
    exception if the H.O. bit of the result is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code encountered a minus sign in step 2, negate the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual code is left as a programming exercise for the reader (or see the
    conversion routines in the HLA Standard Library for concrete examples).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[111](#CHP-8-FN-1)]) Newer C standards also provide for a `long long int`,
    which is usually a 64-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[112](#CHP-8-FN-2)]) Windows may translate this to an `ex.IntoInstr` exception.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[113](#CHP-8-FN-3)]) Technically speaking, this isn't entirely true. It is
    possible for a device error (e.g., disk full) to occur. The likelihood of this
    is so low that we can effectively ignore this possibility.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[114](#CHP-8-FN-4)]) The HLA Standard Library routines actually buffer up
    input lines in a string and process characters out of the string. This makes it
    easy to "peek" ahead one character when looking for a delimiter to end the input
    value. Your code can also do this; however, the code in this chapter uses a different
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Operating on Different-Size Operands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Occasionally you may need to do some computation on a pair of operands that
    are not the same size. For example, you may need to add a word and a double word
    together or subtract a byte value from a word value. The solution is simple: just
    extend the smaller operand to the size of the larger operand and then do the operation
    on two similarly sized operands. For signed operands, you would sign extend the
    smaller operand to the same size as the larger operand; for unsigned values, you
    zero extend the smaller operand. This works for any operation, although the following
    examples demonstrate this for the addition operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To extend the smaller operand to the size of the larger operand, use a sign
    extension or zero extension operation (depending upon whether you''re adding signed
    or unsigned values). Once you''ve extended the smaller value to the size of the
    larger, the addition can proceed. Consider the following code that adds a byte
    value to a word value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the byte variable was loaded into the AL register, extended
    to 16 bits, and then added to the word operand. This code works out really well
    if you can choose the order of the operations (for example, adding the 8-bit value
    to the 16-bit value). Sometimes, you cannot specify the order of the operations.
    Perhaps the 16-bit value is already in the AX register and you want to add an
    8-bit value to it. For unsigned addition, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first `add` instruction in this example adds the byte at `var1` to the L.O.
    byte of the value in the accumulator. The `adc` instruction above adds the carry
    from the addition of the L.O. bytes into the H.O. byte of the accumulator. You
    must take care to ensure that this `adc` instruction is present. If you leave
    it out, you may not get the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an 8-bit signed operand to a 16-bit signed value is a little more difficult.
    Unfortunately, you cannot add an immediate value (as above) to the H.O. word of
    AX. This is because the H.O. extension byte can be either $00 or $FF. If a register
    is available, the best thing to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If an extra register is not available, you might try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative is to store the 16-bit value in the accumulator into a
    memory location and then proceed as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: All the examples above added a byte value to a word value. By zero or sign extending
    the smaller operand to the size of the larger operand, you can easily add any
    two different-size variables together.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last example, consider adding an 8-bit signed value to a quadword (64-bit)
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 8.3 Decimal Arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 80x86 CPUs use the binary numbering system for their native internal representation.
    The binary numbering system is, by far, the most common numbering system in use
    in computer systems today. In the early days, however, there were computer systems
    that were based on the decimal (base 10) numbering system instead of the binary
    numbering system. Consequently, their arithmetic system was decimal based rather
    than binary. Such computer systems were very popular in systems targeted for business/commercial
    systems.^([[115](#ftn.CHP-8-FN-5)]) Although systems designers have discovered
    that binary arithmetic is almost always better than decimal arithmetic for general
    calculations, the myth still persists that decimal arithmetic is better for money
    calculations than binary arithmetic. Therefore, many software systems still specify
    the use of decimal arithmetic in their calculations (not to mention that there
    is lots of legacy code out there whose algorithms are stable only if they use
    decimal arithmetic). Therefore, despite the fact that decimal arithmetic is generally
    inferior to binary arithmetic, the need for decimal arithmetic persists.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the 80x86 is not a decimal computer; therefore, we have to play tricks
    in order to represent decimal numbers using the native binary format. The most
    common technique, even employed by most so-called decimal computers, is to use
    the binary-coded decimal, or BCD, representation. The BCD representation uses
    4 bits to represent the 10 possible decimal digits (see [Table 8-1](ch08s03.html#binary-coded_decimal_open_parenthesis_bc
    "Table 8-1. Binary-Coded Decimal (BCD) Representation")). The binary value of
    those 4 bits is equal to the corresponding decimal value in the range 0..9\. Of
    course, with 4 bits we can actually represent 16 different values; the BCD format
    ignores the remaining six bit combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Because each BCD digit requires 4 bits, we can represent a 2-digit BCD value
    with a single byte. This means that we can represent the decimal values in the
    range 0..99 using a single byte (versus 0..255 if we treat the value as an unsigned
    binary number). Clearly it takes more memory to represent the same value in BCD
    than it does to represent the same value in binary. For example, with a 32-bit
    value you can represent BCD values in the range 0..99,999,999 (eight significant
    digits). However, you can represent values in the range 0..4,294,967,295 (more
    than nine significant digits) by using binary representation.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the BCD format waste memory on a binary computer (because it uses
    more bits to represent a given integer value), decimal arithmetic is also slower.
    For these reasons, you should avoid the use of decimal arithmetic unless it is
    absolutely mandated for a given application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary-coded decimal representation does offer one big advantage over binary
    representation: It is fairly simple to convert between the string representation
    of a decimal number and the BCD representation. This feature is particularly beneficial
    when working with fractional values because fixed and floating-point binary representations
    cannot exactly represent many commonly used values between 0 and 1 (e.g., 1/10).
    Therefore, BCD operations can be efficient when reading from a BCD device, doing
    a simple arithmetic operation (for example, a single addition), and then writing
    the BCD value to some other device.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1. Binary-Coded Decimal (BCD) Representation
  prefs: []
  type: TYPE_NORMAL
- en: '| BCD Representation | Decimal Equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0001 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0010 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0011 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0100 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 0101 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 0110 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 0111 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 1001 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 1010 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1011 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1100 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1101 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1110 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: '| 1111 | Illegal |'
  prefs: []
  type: TYPE_TB
- en: 8.3.1 Literal BCD Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HLA does not provide, nor do you need, a special literal BCD constant. Because
    BCD is just a special form of hexadecimal notation that does not allow the values
    $A..$F, you can easily create BCD constants using HLA''s hexadecimal notation.
    Of course, you must take care not to include the symbols A..F in a BCD constant
    because they are illegal BCD values. As an example, consider the following `mov`
    instruction that copies the BCD value 99 into the AL register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to keep in mind is that you must not use HLA literal decimal
    constants for BCD values. That is, `mov( 95, al );` does not load the BCD representation
    for 95 into the AL register. Instead, it loads $5F into AL, and that's an illegal
    BCD value. Any computations you attempt with illegal BCD values will produce garbage
    results. Always remember that, even though it seems counterintuitive, you use
    hexadecimal literal constants to represent literal BCD values.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 The 80x86 daa and das Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The integer unit on the 80x86 does not directly support BCD arithmetic. Instead,
    the 80x86 requires that you perform the computation using binary arithmetic and
    use some auxiliary instructions to convert the binary result to BCD. To support
    packed BCD addition and subtraction with two digits per byte, the 80x86 provides
    two instructions: decimal adjust after addition (`daa`) and decimal adjust after
    subtraction (`das`). You would execute these two instructions immediately after
    an `add`/`adc` or `sub`/`sbb` instruction to correct the binary result in the
    AL register.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a pair of two-digit (i.e., single-byte) BCD values together, you would
    use the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The first two instructions above add the 2-byte values together using standard
    binary arithmetic. This may not produce a correct BCD result. For example, if
    `bcd_1` contains $9 and `bcd_2` contains $1, then the first two instructions above
    will produce the binary sum $A instead of the correct BCD result $10\. The `daa`
    instruction corrects this invalid result. It checks to see if there was a carry
    out of the low-order BCD digit and adjusts the value (by adding 6 to it) if there
    was an overflow. After adjusting for overflow out of the L.O. digit, the `daa`
    instruction repeats this process for the H.O. digit. `daa` sets the carry flag
    if there was a (decimal) carry out of the H.O. digit of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `daa` instruction operates only on the AL register. It will not adjust
    (properly) for a decimal addition if you attempt to add a value to AX, EAX, or
    any other register. Specifically note that `daa` limits you to adding two decimal
    digits (a single byte) at a time. This means that for the purposes of computing
    decimal sums, you have to treat the 80x86 as though it were an 8-bit processor,
    capable of adding only 8 bits at a time. If you wish to add more than two digits
    together, you must treat this as a multiprecision operation. For example, to add
    four decimal digits together (using `daa`), you must execute a sequence like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Because a binary addition of two words (producing a word result) requires only
    three instructions, you can see that decimal arithmetic is expensive.^([[116](#ftn.CHP-8-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: 'The `das` (decimal adjust after subtraction) instruction adjusts the decimal
    result after a binary `sub` or `sbb` instruction. You use it the same way you
    use the `daa` instruction. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the 80x86 provides support only for addition and subtraction
    of packed BCD values using the `daa` and `das` instructions. It does not support
    multiplication, division, or any other arithmetic operations. Because decimal
    arithmetic using these instructions is so limited, you'll rarely see any programs
    use these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3 The 80x86 aaa, aas, aam, and aad Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the packed decimal instructions (`daa` and `das`), the 80x86
    CPUs support four unpacked decimal adjustment instructions. Unpacked decimal numbers
    store only one digit per 8-bit byte. As you can imagine, this data representation
    scheme wastes a considerable amount of memory. However, the unpacked decimal adjustment
    instructions support the multiplication and division operations, so they are marginally
    more useful.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction mnemonics `aaa`, `aas`, `aam`, and `aad` stand for "ASCII adjust
    for Addition, Subtraction, Multiplication, and Division" (respectively). Despite
    their names, these instructions do not process ASCII characters. Instead, they
    support an unpacked decimal value in AL whose L.O. 4 bits contain the decimal
    digit and the H.O. 4 bits contain 0\. Note, though, that you can easily convert
    an ASCII decimal digit character to an unpacked decimal number by simply `and`ing
    AL with the value $0F.
  prefs: []
  type: TYPE_NORMAL
- en: The `aaa` instruction adjusts the result of a binary addition of two unpacked
    decimal numbers. If the addition of those two values exceeds 10, then `aaa` will
    subtract 10 from AL and increment AH by 1 (as well as set the carry flag). `aaa`
    assumes that the two values you add together are legal unpacked decimal values.
    Other than the fact that `aaa` works with only one decimal digit at a time (rather
    than two), you use it the same way you use the `daa` instruction. Of course, if
    you need to add together a string of decimal digits, using unpacked decimal arithmetic
    will require twice as many operations and, therefore, twice the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: You use the `aas` instruction the same way you use the `das` instruction except,
    of course, it operates on unpacked decimal values rather than packed decimal values.
    As for `aaa`, `aas` will require twice the number of operations to add the same
    number of decimal digits as the `das` instruction. If you're wondering why anyone
    would want to use the `aaa` or `aas` instruction, keep in mind that the unpacked
    format supports multiplication and division, while the packed format does not.
    Since packing and unpacking the data is usually more expensive than working on
    the data a digit at a time, the `aaa` and `aas` instructions are more efficient
    if you have to work with unpacked data (because of the need for multiplication
    and division).
  prefs: []
  type: TYPE_NORMAL
- en: The `aam` instruction modifies the result in the AX register to produce a correct
    unpacked decimal result after multiplying two unpacked decimal digits using the
    `mul` instruction. Because the largest product you may obtain is 81 (9 * 9 produces
    the largest possible product of two single-digit values), the result will fit
    in the AL register. `aam` unpacks the binary result by dividing it by 10, leaving
    the quotient (H.O. digit) in AH and the remainder (L.O. digit) in AL. Note that
    `aam` leaves the quotient and remainder in different registers than a standard
    8-bit `div` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you do not have to use the `aam` instruction for BCD multiplication
    operations. `aam` simply divides AL by 10 and leaves the quotient and remainder
    in AH and AL (respectively). If you have need of this particular operation, you
    may use the `aam` instruction for this purpose (indeed, that's about the only
    use for `aam` in most programs these days).
  prefs: []
  type: TYPE_NORMAL
- en: If you need to multiply more than two unpacked decimal digits together using
    `mul` and `aam`, you will need to devise a multiprecision multiplication that
    uses the manual algorithm from earlier in this chapter. Since that is a lot of
    work, this section will not present that algorithm. If you need a multiprecision
    decimal multiplication, see [8.3.4 Packed Decimal Arithmetic Using the FPU](ch08s03.html#packed_decimal_arithmetic_using_the_fpu
    "8.3.4 Packed Decimal Arithmetic Using the FPU"); it presents a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aad` instruction, as you might expect, adjusts a value for unpacked decimal
    division. The unusual thing about this instruction is that you must execute it
    before a `div` operation. It assumes that AL contains the least-significant digit
    of a two-digit value and AH contains the most-significant digit of a two-digit
    unpacked decimal value. It converts these two numbers to binary so that a standard
    `div` instruction will produce the correct unpacked decimal result. Like `aam`,
    this instruction is nearly useless for its intended purpose because extended-precision
    operations (for example, division of more than one or two digits) are extremely
    inefficient. However, this instruction is actually quite useful in its own right.
    It computes AX = AH * 10 + AL (assuming that AH and AL contain single-digit decimal
    values). You can use this instruction to convert a two-character string containing
    the ASCII representation of a value in the range 0..99 to a binary value. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The decimal and ASCII adjust instructions provide an extremely poor implementation
    of decimal arithmetic. To better support decimal arithmetic on 80x86 systems,
    Intel incorporated decimal operations into the FPU. The next section discusses
    how to use the FPU for this purpose. However, even with FPU support, decimal arithmetic
    is inefficient and less precise than binary arithmetic. Therefore, you should
    consider carefully if you really need to use decimal arithmetic before incorporating
    it into your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4 Packed Decimal Arithmetic Using the FPU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve the performance of applications that rely on decimal arithmetic,
    Intel incorporated support for decimal arithmetic directly into the FPU. Unlike
    the packed and unpacked decimal formats of the previous sections, the FPU easily
    supports values with up to 18 decimal digits of precision, all at FPU speeds.
    Furthermore, all the arithmetic capabilities of the FPU (for example, transcendental
    operations) are available in addition to addition, subtraction, multiplication,
    and division. Assuming you can live with only 18 digits of precision and a few
    other restrictions, decimal arithmetic on the FPU is the right way to go if you
    must use decimal arithmetic in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: The first fact you must note when using the FPU is that it doesn't really support
    decimal arithmetic. Instead, the FPU provides two instructions, `fbld` and `fbstp`,
    that convert between packed decimal and binary floating-point formats when moving
    data to and from the FPU. The `fbld` (float/BCD load) instruction loads an 80-bit
    packed BCD value unto the top of the FPU stack after converting that BCD value
    to the IEEE binary floating-point format. Likewise, the `fbstp` (float/BCD store
    and pop) instruction pops the floating-point value off the top of stack, converts
    it to a packed BCD value, and stores the BCD value into the destination memory
    location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you load a packed BCD value into the FPU, it is no longer BCD. It''s just
    a floating-point value. This presents the first restriction on the use of the
    FPU as a decimal integer processor: Calculations are done using binary arithmetic.
    If you have an algorithm that absolutely positively depends on the use of decimal
    arithmetic, it may fail if you use the FPU to implement it.^([[117](#ftn.CHP-8-FN-7)])'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second limitation is that the FPU supports only one BCD data type: a 10-byte
    18-digit packed decimal value. It will not support smaller values, nor will it
    support larger values. Since 18 digits are usually sufficient and memory is cheap,
    this isn''t a big restriction.'
  prefs: []
  type: TYPE_NORMAL
- en: A third consideration is that the conversion between packed BCD and the floating-point
    format is not a cheap operation. The `fbld` and `fbstp` instructions can be quite
    slow (more than two orders of magnitude slower than `fld` and `fstp`, for example).
    Therefore, these instructions can be costly if you're doing simple additions or
    subtractions; the cost of conversion far outweighs the time spent adding the values
    a byte at a time using the `daa` and `das` instructions (multiplication and division,
    however, are going to be faster on the FPU).
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the FPU's packed decimal format supports only 18 digits.
    After all, with 10 bytes it should be possible to represent 20 BCD digits. As
    it turns out, the FPU's packed decimal format uses the first 9 bytes to hold the
    packed BCD value in a standard packed decimal format (the first byte contains
    the two L.O. digits and the ninth byte holds the two H.O. digits). The H.O. bit
    of the tenth byte holds the sign bit, and the FPU ignores the remaining bits in
    the tenth byte. If you're wondering why Intel didn't squeeze in one more digit
    (that is, use the L.O. 4 bits of the tenth byte to allow for 19 digits of precision),
    just keep in mind that doing so would create some possible BCD values that the
    FPU could not exactly represent in the native floating-point format. Hence, you
    have the limitation of 18 digits.
  prefs: []
  type: TYPE_NORMAL
- en: The FPU uses a one's complement notation for negative BCD values. That is, the
    sign bit contains a 1 if the number is negative or 0 and it contains a 0 if the
    number is positive or 0 (like the binary one's complement format, there are two
    distinct representations for 0).
  prefs: []
  type: TYPE_NORMAL
- en: HLA's `tbyte` type is the standard data type you would use to define packed
    BCD variables. The `fbld` and `fbstp` instructions require a `tbyte` operand (which
    you can initialize with a hexadecimal/BCD value).
  prefs: []
  type: TYPE_NORMAL
- en: Because the FPU converts packed decimal values to the internal floating-point
    format, you can mix packed decimal, floating point, and (binary) integer formats
    in the same calculation. The program in [Example 8-7](ch08s03.html#mixed-mode_fpu_arithmetic
    "Example 8-7. Mixed-mode FPU arithmetic") demonstrates how you might achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7. Mixed-mode FPU arithmetic
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The FPU treats packed decimal values as integer values. Therefore, if your calculations
    produce fractional results, the `fbstp` instruction will round the result according
    to the current FPU rounding mode. If you need to work with fractional values,
    you need to stick with floating-point results.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[115](#CHP-8-FN-5)]) In fact, until the release of the IBM 360 in the mid-1960s,
    most scientific computer systems were binary based, whereas most commercial/business
    systems were decimal based. IBM pushed its system\360 as a single-purpose solution
    for both business and scientific applications. Indeed, the model designation (360)
    was derived from the 360 degrees on a compass so as to suggest that the system\360
    was suitable for computations "at all points of the compass" (i.e., business and
    scientific).
  prefs: []
  type: TYPE_NORMAL
- en: ^([[116](#CHP-8-FN-6)]) You'll also soon see that it's rare to find decimal
    arithmetic done this way. So it hardly matters.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[117](#CHP-8-FN-7)]) An example of such an algorithm might be a multiplication
    by 10 by shifting the number one digit to the left. However, such operations are
    not possible within the FPU itself, so algorithms that misbehave inside the FPU
    are actually quite rare.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *table* has different meanings to different programmers. To most assembly
    language programmers, a table is nothing more than an array that is initialized
    with some data. The assembly language programmer often uses tables to compute
    complex or otherwise slow functions. Many very-high-level languages (for example,
    SNOBOL4 and Icon) directly support a `table` data type. Tables in these languages
    are essentially associative arrays whose elements you can access with a noninteger
    index (for example, `floating point`, `string`, or any other data type). HLA provides
    a `table` module that lets you index an array using a string. However, in this
    chapter we will adopt the assembly language programmer's view of tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'A table is an array containing initialized values that do not change during
    the execution of the program. In assembly language, you can use tables for a variety
    of purposes: computing functions, controlling program flow, or simply looking
    things up. In general, tables provide a fast mechanism for performing some operation
    at the expense of some space in your program (the extra space holds the tabular
    data). In the following sections we''ll explore some of the many possible uses
    of tables in an assembly language program.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that because tables typically contain initialized data that does not change
    during program execution, the `readonly` section is a good place to put your table
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Function Computation via Table Lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tables can do all kinds of things in assembly language. In high-level languages
    like Pascal, it''s easy to create a formula that computes some value. A simple-looking
    high-level-language arithmetic expression can be equivalent to a considerable
    amount of 80x86 assembly language code and, therefore, could be expensive to compute.
    Assembly language programmers often precompute many values and use a table lookup
    of those values to speed up their programs. This has the advantage of being easier,
    and it''s often more efficient as well. Consider the following Pascal statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This Pascal `if` statement converts the `character` variable''s value from
    lowercase to uppercase if *`character`* is in the range `a..z`. The HLA code that
    does the same thing follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that HLA's high-level `if` statement translates into four machine instructions
    in this particular example. Hence, this code requires a total of seven machine
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Had you buried this code in a nested loop, you''d be hard pressed to reduce
    the size of this code without using a table lookup. Using a table lookup, however,
    allows you to reduce this sequence of instructions to just four instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re probably wondering how this code works and asking, "What is this new
    instruction, `xlat`?" The `xlat`, or translate, instruction does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That is, it uses the current value of the AL register as an index into the array
    whose base address is found in EBX. It fetches the byte at that index in the array
    and copies that byte into the AL register. Intel calls this instruction *translate*
    because programmers typically use it to translate characters from one form to
    another using a lookup table. That's exactly how we are using it here.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, `CnvrtLower` is a 256-byte table that contains the
    values 0..$60 at indices 0..$60, $41..$5A at indices $61..$7A, and $7B..$FF at
    indices $7Bh..0FF. Therefore, if AL contains a value in the range $0..$60, the
    `xlat` instruction returns the value $0..$60, effectively leaving AL unchanged.
    However, if AL contains a value in the range $61..$7A (the ASCII codes for a..z),
    then the `xlat` instruction replaces the value in AL with a value in the range
    $41..$5A. The values $41..$5A just happen to be the ASCII codes for A..Z. Therefore,
    if AL originally contains a lowercase character ($61..$7A), the `xlat` instruction
    replaces the value in AL with a corresponding value in the range $61..$7A, effectively
    converting the original lowercase character ($61..$7A) to an uppercase character
    ($41..$5A). The remaining entries in the table, like entries $0..$60, simply contain
    the index into the table of their particular element. Therefore, if AL originally
    contains a value in the range $7A..$FF, the `xlat` instruction will return the
    corresponding table entry that also contains $7A..$FF.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the complexity of the function increases, the performance benefits of the
    table lookup method increase dramatically. While you would almost never use a
    lookup table to convert lowercase to uppercase, consider what happens if you want
    to swap cases, for example, via computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `if` and `elseif` statements generate 4 and 5 actual machine instructions,
    respectively, so this code is equivalent to 13 actual machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table lookup code to compute this same function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when using a table lookup to compute a function, only the table
    changes; the code remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Table lookups suffer from one major problem—functions computed via table lookup
    have a limited domain. The domain of a function is the set of possible input values
    (parameters) it will accept. For example, the uppercase/lowercase conversion functions
    above have the 256-character ASCII character set as their domain.
  prefs: []
  type: TYPE_NORMAL
- en: A function such as `SIN` or `COS` accepts the set of real numbers as possible
    input values. Clearly the domain for `SIN` and `COS` is much larger than for the
    upper/lowercase conversion function. If you are going to do computations via table
    lookup, you must limit the domain of a function to a small set. This is because
    each element in the domain of a function requires an entry in the lookup table.
    You won't find it very practical to implement a function via table lookup whose
    domain is the set of real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Most lookup tables are quite small, usually 10 to 256 entries. Rarely do lookup
    tables grow beyond 1,000 entries. Most programmers don't have the patience to
    create (and verify the correctness) of a 1,000-entry table.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of functions based on lookup tables is that the elements
    in the domain of the function must be fairly contiguous. Table lookups take the
    input value for a function, use this input value as an index into the table, and
    return the value at that entry in the table. If you do not pass a function any
    values other than 0, 100, 1,000, and 10,000, it would seem an ideal candidate
    for implementation via table lookup; its domain consists of only four items. However,
    the table would actually require 10,001 different elements due to the range of
    the input values. Therefore, you cannot efficiently create such a function via
    a table lookup. Throughout this section on tables, we'll assume that the domain
    of the function is a fairly contiguous set of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best functions you can implement via table lookups are those whose domain
    and range are always 0..255 (or some subset of this range). You can efficiently
    implement such functions on the 80x86 via the `xlat` instruction. The uppercase/lowercase
    conversion routines presented earlier are good examples of such a function. Any
    function in this class (those whose domain and range take on the values 0..255)
    can be computed using the same two instructions: `lea( table, ebx );` and `xlat();`.
    The only thing that ever changes is the lookup table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot (conveniently) use the `xlat` instruction to compute a function
    value once the range or domain of the function takes on values outside 0..255\.
    There are three situations to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The domain is outside 0..255 but the range is within 0..255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain is inside 0..255 but the range is outside 0..255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the domain and range of the function take on values outside 0..255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will consider each of these cases separately.
  prefs: []
  type: TYPE_NORMAL
- en: If the domain of a function is outside 0..255, but the range of the function
    falls within this set of values, our lookup table will require more than 256 entries,
    but we can represent each entry with a single byte. Therefore, the lookup table
    can be an array of bytes. Other than those lookups that can use the `xlat` instruction,
    functions falling into this class are the most efficient. The following Pascal
    function invocation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: where `Func` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'is easily converted to the following HLA code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This code loads the function parameter into `ebx`, uses this value (in the range
    0..??) as an index into the `FuncTable` table, fetches the byte at that location,
    and stores the result into `B`. Obviously, the table must contain a valid entry
    for each possible value of `X`. For example, suppose you wanted to map a cursor
    position on the video screen in the range 0..1,999 (there are 2,000 character
    positions on an 80×25 video display) to its `X` or `Y` coordinate on the screen.
    You could easily compute the `X` coordinate via the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: and the `Y` coordinate with the formula
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '(where `Posn` is the cursor position on the screen). This can be easily computed
    using the 80x86 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `div` instruction on the 80x86 is very slow. If you need to do
    this computation for every character you write to the screen, you will seriously
    degrade the speed of your video display code. The following code, which realizes
    these two functions via table lookup, may improve the performance of your code
    considerably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If the domain of a function is within 0..255 but the range is outside this set,
    the lookup table will contain 256 or fewer entries, but each entry will require
    2 or more bytes. If both the range and domains of the function are outside 0..255,
    each entry will require 2 or more bytes and the table will contain more than 256
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from the chapter on arrays that the formula for indexing into a single-dimensional
    array (of which a `table` is a special case) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If elements in the range of the function require 2 bytes, then you must multiply
    the index by 2 before indexing into the table. Likewise, if each entry requires
    3, 4, or more bytes, the index must be multiplied by the size of each table entry
    before being used as an index into the table. For example, suppose you have a
    function, `F(x)`, defined by the following (pseudo) Pascal declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily create this function using the following 80x86 code (and, of
    course, the appropriate table named `F`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Any function whose domain is small and mostly contiguous is a good candidate
    for computation via table lookup. In some cases, noncontiguous domains are acceptable
    as well, as long as the domain can be coerced into an appropriate set of values.
    Such operations are called *conditioning* and are the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.2 Domain Conditioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Domain conditioning is taking a set of values in the domain of a function and
    massaging them so that they are more acceptable as inputs to that function. Consider
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![8.4.2 Domain Conditioning](tagoreillycom20100401nostarchimages578057.png)'
  prefs: []
  type: TYPE_IMG
- en: This says that the (computer) function `sin(x)` is equivalent to the (mathematical)
    function sin *x* where
  prefs: []
  type: TYPE_NORMAL
- en: '![8.4.2 Domain Conditioning](tagoreillycom20100401nostarchimages578059.png)'
  prefs: []
  type: TYPE_IMG
- en: As we all know, sine is a circular function, which will accept any real valued
    input. The formula used to compute sine, however, accepts only a small set of
    these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This range limitation doesn''t present any real problems; by simply computing
    `sin(X mod (2*pi))` we can compute the sine of any input value. Modifying an input
    value so that we can easily compute a function is called *conditioning the input*.
    In the example above we computed `X mod 2*pi` and used the result as the input
    to the `sin` function. This truncates `X` to the domain `sin` needs without affecting
    the result. We can apply input conditioning to table lookups as well. In fact,
    scaling the index to handle word entries is a form of input conditioning. Consider
    the following Pascal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This function computes some value for `x` in the range 0..4 and it returns
    0 if `x` is outside this range. Since `x` can take on 65,536 different values
    (being a 16-bit word), creating a table containing 65,536 words where only the
    first five entries are nonzero seems to be quite wasteful. However, we can still
    compute this function using a table lookup if we use input conditioning. The following
    assembly language code presents this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This code checks to see if `x` is outside the range 0..4\. If so, it manually
    sets `AX` to 0; otherwise it looks up the function value through the `val` table.
    With input conditioning, you can implement several functions that would otherwise
    be impractical to do via table lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.3 Generating Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One big problem with using table lookups is creating the table in the first
    place. This is particularly true if there is a large number of entries in the
    table. Figuring out the data to place in the table, then laboriously entering
    the data, and, finally, checking that data to make sure it is valid is a very
    time-consuming and boring process. For many tables, there is no way around this
    process. For other tables, there is a better way—using the computer to generate
    the table for you. An example is probably the best way to describe this. Consider
    the following modification to the sine function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![8.4.3 Generating Tables](tagoreillycom20100401nostarchimages578061.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This states that *x* is an integer in the range 0..359 and *r* must be an integer.
    The computer can easily compute this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note that integer multiplication and division are not associative. You cannot
    remove the multiplication by 1,000 and the division by 1,000 because they appear
    to cancel one another out. Furthermore, this code must compute this function in
    exactly this order. All that we need to complete this function is a table containing
    360 different values corresponding to the sine of the angle (in degrees) times
    1,000\. Entering such a table into an assembly language program containing such
    values is extremely boring and you'd probably make several mistakes entering and
    verifying this data. However, you can have the program generate this table for
    you. Consider the HLA program in [Example 8-8](ch08s04.html#an_hla_program_that_generates_a_table_of
    "Example 8-8. An HLA program that generates a table of sines").
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8. An HLA program that generates a table of sines
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The program above produces the following output (truncated for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Obviously it's much easier to write the HLA program that generated this data
    than to enter (and verify) this data by hand. Of course, you don't even have to
    write the table-generation program in HLA. If you prefer, you might find it easier
    to write the program in Pascal/Delphi, C/C++, or some other high-level language.
    Because the program will only execute once, the performance of the table-generation
    program is not an issue. If it's easier to write the table-generation program
    in a high-level language, by all means do so. Note also that HLA has a built-in
    interpreter that allows you to easily create tables without having to use an external
    program. For more details, see [Chapter 9](ch09.html "Chapter 9. MACROS AND THE
    HLA COMPILE-TIME LANGUAGE").
  prefs: []
  type: TYPE_NORMAL
- en: Once you run your table-generation program, all that remains to be done is to
    cut and paste the table from the file (*sines.hla* in this example) into the program
    that will actually use the table.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.4 Table Lookup Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days of PCs, table lookups were a preferred way to do high-performance
    computations. However, as the speed of new CPUs vastly outpaces the speed of memory,
    the advantages of lookup tables have been waning. Today, it is not uncommon for
    a CPU to be 10 to 100 times faster than main memory. As a result, using a table
    lookup may not be faster than doing the same calculation with machine instructions.
    So it's worthwhile to briefly discuss when table lookups offer a big advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Although the CPU is much faster than main memory, the on-chip CPU cache memory
    subsystems operate at near CPU speeds. Therefore, table lookups can be cost effective
    if your table resides in cache memory on the CPU. This means that the way to get
    good performance using table lookups is to use small tables (because there's only
    so much room on the cache) and use tables whose entries you reference frequently
    (so the tables stay in the cache). See *Write Great Code, Volume 1* (No Starch
    Press) or the electronic version of *The Art of Assembly Language* at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/) for details concerning
    the operation of cache memory and how you can optimize your use of cache memory.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA Standard Library reference manual contains lots of information about
    the HLA Standard Library's extended-precision arithmetic capabilities. You'll
    also want to check out the source code for several of the HLA Standard Library
    routines to see how to do various extended-precision operations (that properly
    set the flags once the computation is complete). The HLA Standard Library source
    code also covers the extended-precision I/O operations that do not appear in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Donald Knuth''s *The Art of Computer Programming*, *Volume Two: Seminumerical
    Algorithms* contains a lot of useful information about decimal arithmetic and
    extended-precision arithmetic, though that text is generic and doesn''t describe
    how to do this in x86 assembly language.'
  prefs: []
  type: TYPE_NORMAL
