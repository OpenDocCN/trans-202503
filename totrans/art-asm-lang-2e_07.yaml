- en: Chapter 8. ADVANCED ARITHMETIC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 高级算术
- en: '![ADVANCED ARITHMETIC](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![高级算术](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: 'This chapter deals with those arithmetic operations for which assembly language
    is especially well suited. It covers four main topics: extended-precision arithmetic,
    arithmetic on operands whose sizes are different, decimal arithmetic, and computation
    via table lookup.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了汇编语言特别适合的那些算术操作。它涵盖了四个主要主题：扩展精度算术、不同大小操作数的算术、十进制算术以及通过表查找进行计算。
- en: By far, the most extensive subject this chapter covers is multiprecision arithmetic.
    By the conclusion of this chapter you will know how to apply arithmetic and logical
    operations to integer operands of any size. If you need to work with integer values
    outside the range ±2 billion (or with unsigned values beyond 4 billion), no sweat;
    this chapter shows you how to get the job done.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章涉及的最广泛的主题是多精度算术。到本章结束时，你将知道如何对任何大小的整数操作数进行算术和逻辑运算。如果你需要处理超出±20亿范围的整数值（或无符号值超过40亿），不用担心；本章将向你展示如何完成这项工作。
- en: Different-size operands also present some special problems. For example, you
    may want to add a 64-bit unsigned integer to a 128-bit signed integer value. This
    chapter discusses how to convert these two operands to a compatible format.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不同大小的操作数也会带来一些特殊的问题。例如，你可能想要将一个64位无符号整数与一个128位有符号整数相加。本章讨论如何将这两个操作数转换为兼容的格式。
- en: This chapter also discusses decimal arithmetic using the 80x86 BCD (binary-coded
    decimal) instructions and the FPU (floating-point unit). This lets you use decimal
    arithmetic in those few applications that absolutely require base-10 operations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了使用80x86 BCD（十进制编码二进制）指令和FPU（浮点单元）进行十进制算术。这使你能够在那些绝对需要十进制操作的少数应用中使用十进制算术。
- en: Finally, this chapter concludes by discussing how to speed up complex computations
    using table lookups.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章通过讨论如何使用表查找加速复杂计算来结束。
- en: 8.1 Multiprecision Operations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 多精度操作
- en: 'One big advantage of assembly language over high-level languages is that assembly
    language does not limit the size of integer operations. For example, the standard
    C programming language defines three different integer sizes: `short int`, `int`,
    and `long int`.^([[111](#ftn.CHP-8-FN-1)]) On the PC, these are often 16- and
    32-bit integers. Although the 80x86 machine instructions limit you to processing
    8-, 16-, or 32-bit integers with a single instruction, you can always use multiple
    instructions to process integers of any size. If you want to add 256-bit integer
    values together, no problem; it''s relatively easy to accomplish this in assembly
    language. The following sections describe how to extend various arithmetic and
    logical operations from 16 or 32 bits to as many bits as you please.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言相较于高级语言的一个大优势是，它不限制整数操作的大小。例如，标准C编程语言定义了三种不同的整数大小：`short int`、`int`和`long
    int`。^([[111](#ftn.CHP-8-FN-1)]) 在PC上，这些通常是16位和32位整数。尽管80x86机器指令限制你使用单一指令处理8位、16位或32位整数，但你总是可以使用多条指令处理任何大小的整数。如果你想将256位整数相加，没问题；在汇编语言中做到这一点相对容易。接下来的部分将描述如何将各种算术和逻辑操作从16位或32位扩展到任何你想要的位数。
- en: 8.1.1 HLA Standard Library Support for Extended-Precision Operations
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.1 HLA标准库对扩展精度操作的支持
- en: Although it is important for you to understand how to do extended-precision
    arithmetic yourself, you should note that the HLA Standard Library provides a
    full set of 64-bit and 128-bit arithmetic and logical functions that you can use.
    These routines are general purpose and very convenient to use. This section briefly
    describes the HLA Standard Library support for extended-precision arithmetic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解如何自己进行扩展精度算术非常重要，但你应该注意，HLA标准库提供了一整套64位和128位算术和逻辑函数，你可以使用这些函数。这些例程是通用的，且非常方便使用。本节简要介绍了HLA标准库对扩展精度算术的支持。
- en: 'As noted in earlier chapters, the HLA compiler supports several different 64-bit
    and 128-bit data types. These extended data types are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，HLA编译器支持几种不同的64位和128位数据类型。这些扩展的数据类型包括：
- en: '`uns64`: 64-bit unsigned integers'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns64`: 64位无符号整数'
- en: '`int64`: 64-bit signed integers'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int64`: 64位有符号整数'
- en: '`qword`: 64-bit untyped values'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qword`: 64位无类型值'
- en: '`uns128`: 128-bit unsigned integers'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns128`: 128位无符号整数'
- en: '`int128`: 128-bit signed integers'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int128`: 128位有符号整数'
- en: '`lword`: 128-bit untyped values'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lword`: 128位无类型值'
- en: HLA also provides a `tbyte` type, but we will not consider that here (see [8.2
    Operating on Different-Size Operands](ch08s02.html "8.2 Operating on Different-Size
    Operands")).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 还提供了一个`tbyte`类型，但我们在此不予考虑（请参见[8.2 操作不同大小的操作数](ch08s02.html "8.2 Operating
    on Different-Size Operands")）。
- en: 'HLA fully supports 64-bit and 128-bit literal constants and constant arithmetic.
    This allows you to initialize 64- and 128-bit static objects using standard decimal,
    hexadecimal, or binary notation. For example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 完全支持 64 位和 128 位字面常量以及常量运算。这使您可以使用标准的十进制、十六进制或二进制表示法初始化 64 位和 128 位的静态对象。例如：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to easily manipulate 64-bit and 128-bit values, the HLA Standard Library''s
    `math.hhf` module provides a set of functions that handle most of the standard
    arithmetic and logical operations. You use these functions in a manner similar
    to the 32-bit arithmetic and logical instructions. For example, consider the `math.addq`
    (`qword`) and `math.addl` (`lword`) functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于操作 64 位和 128 位的值，HLA 标准库的`math.hhf`模块提供了一组处理大多数标准算术和逻辑操作的函数。您可以像使用 32 位算术和逻辑指令一样使用这些函数。例如，考虑`math.addq`（`qword`）和`math.addl`（`lword`）函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These functions compute the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数计算以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These functions set the 80x86 flags the same way you'd expect after the execution
    of an `add` instruction. Specifically, these functions set the zero flag if the
    (full) result is 0, they set the carry flag if there is a carry from the H.O.
    bit, they set the overflow flag if there is a signed overflow, and they set the
    sign flag if the H.O. bit of the result contains 1.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数设置 80x86 标志的方式与执行 `add` 指令后的预期结果相同。具体来说，这些函数会在（完整的）结果为 0 时设置零标志，如果有进位，则设置进位标志，如果出现符号溢出，则设置溢出标志，如果结果的高位字节（H.O.）包含
    1，则设置符号标志。
- en: 'Most of the remaining arithmetic and logical routines use the same calling
    sequence as `math.addq` and `math.addl`. Briefly, here are those functions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的大多数算术和逻辑例程使用与 `math.addq` 和 `math.addl` 相同的调用序列。简要介绍如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These functions set the flags the same way as the corresponding 32-bit machine
    instructions and, in the case of the division and remainder (modulo) functions,
    raise the same exceptions. Note that the multiplication functions do not produce
    an extended-precision result. The destination value is the same size as the source
    operands. These functions set the overflow and carry flags if the result does
    not fit into the destination operand. All of these functions compute the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数设置标志的方式与相应的 32 位机器指令相同，并且在除法和余数（取模）函数的情况下，会触发相同的异常。请注意，乘法函数不会产生扩展精度的结果。目标值与源操作数的大小相同。如果结果无法适应目标操作数，这些函数会设置溢出和进位标志。所有这些函数计算以下内容：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: where *`op`* represents the specific operation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *`op`* 表示特定的操作。
- en: 'In addition to these functions, the HLA Standard Library''s math module also
    provides a few additional functions whose syntax is slightly different from `math.addq`
    and `math.addl`. These functions include `math.negq`, `math.negl`, `math.notq`,
    `math.notl`, `math.shlq`, `math.shll`, `math.shrq`, and `math.shrl`. Note that
    there are no rotates or arithmetic shift-right functions. However, you''ll soon
    see that these operations are easy to synthesize using standard instructions.
    Here are the prototypes for these additional functions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些函数，HLA 标准库的数学模块还提供了一些额外的函数，其语法与`math.addq`和`math.addl`略有不同。这些函数包括`math.negq`、`math.negl`、`math.notq`、`math.notl`、`math.shlq`、`math.shll`、`math.shrq`和`math.shrl`。请注意，没有旋转或算术右移函数。然而，您很快会发现，使用标准指令可以轻松合成这些操作。以下是这些附加函数的原型：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, all these functions set the flags exactly the same way the corresponding
    machine instructions would set the flags were they to support 64-bit or 128-bit
    operands.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有这些函数设置标志的方式与相应的机器指令在支持 64 位或 128 位操作数时所设置的标志完全相同。
- en: The HLA Standard Library also provides a full complement of I/O and conversion
    routines for 64-bit and 128-bit values. For example, you can use `stdout.put`
    to display 64- and 128-bit values, you may use `stdin.get` to read these values,
    and there is a set of routines in the HLA conversions module that convert between
    these values and their string equivalents. In general, anything you can do with
    a 32-bit value can be done with a 64-bit or 128-bit value as well. See the HLA
    Standard Library documentation for more details.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 标准库还提供了完整的 64 位和 128 位值的输入/输出和转换例程。例如，你可以使用 `stdout.put` 显示 64 位和 128 位的值，也可以使用
    `stdin.get` 读取这些值，HLA 转换模块中还有一组例程可以在这些值和它们的字符串表示之间进行转换。一般来说，任何你可以对 32 位值执行的操作，也可以对
    64 位或 128 位值执行。详细信息请参见 HLA 标准库文档。
- en: 8.1.2 Multiprecision Addition Operations
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.2 多精度加法操作
- en: 'The 80x86 `add` instruction adds two 8-, 16-, or 32- bit numbers. After the
    execution of the `add` instruction, the 80x86 carry flag is set if there is an
    overflow out of the H.O. bit of the sum. You can use this information to do multiprecision
    addition operations. Consider the way you manually perform a multidigit (multiprecision)
    addition operation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 `add` 指令用于将两个 8 位、16 位或 32 位的数字相加。在执行完 `add` 指令后，如果和的高位有溢出，80x86 的进位标志会被设置。你可以使用这些信息进行多精度加法操作。考虑你手动进行多位数（多精度）加法操作的方法：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The 80x86 handles extended-precision arithmetic in an identical fashion, except
    instead of adding the numbers a digit at a time, it adds them together a byte,
    word, or double word at a time. Consider the three double-word (96-bit) addition
    operation in [Figure 8-1](ch08.html#adding_two_96-bit_objects_together "Figure 8-1. Adding
    two 96-bit objects together").
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 以相同的方式处理扩展精度算术，只不过它不是一次加一个数字，而是一次加一个字节、一个字或一个双字。考虑图 8-1 中的三个双字（96 位）加法操作。
- en: '![Adding two 96-bit objects together](tagoreillycom20100401nostarchimages578043.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![将两个 96 位对象相加](tagoreillycom20100401nostarchimages578043.png)'
- en: Figure 8-1. Adding two 96-bit objects together
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1. 将两个 96 位对象相加
- en: As you can see from this figure, the idea is to break up a larger operation
    into a sequence of smaller operations. Since the x86 processor family is capable
    of adding together, at most, 32 bits at a time, the operation must proceed in
    blocks of 32 bits or less. So the first step is to add the two L.O. double words
    together just as you would add the two L.O. digits of a decimal number together
    in the manual algorithm. There is nothing special about this operation; you can
    use the `add` instruction to achieve this.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这张图中看到的，核心思想是将一个较大的操作分解成一系列更小的操作。由于 x86 处理器家族每次最多只能加 32 位数字，所以操作必须分块进行，每块最多
    32 位。因此，第一步是将两个 L.O. 双字加在一起，就像你在手动算法中将两个 L.O. 位加在一起一样。这项操作没有什么特别的；你可以使用 `add`
    指令来完成。
- en: 'The second step involves adding together the second pair of double words in
    the two 96-bit values. Note that in step 2, the calculation must also add in the
    carry out of the previous addition (if any). If there is a carry out of the L.O.
    addition, the `add` instruction sets the carry flag to 1; conversely, if there
    is no carry out of the L.O. addition, the earlier `add` instruction clears the
    carry flag. Therefore, in this second addition, we really need to compute the
    sum of the two double words plus the carry out of the first instruction. Fortunately,
    the x86 CPUs provide an instruction that does exactly this: the `adc` (add with
    carry) instruction. The `adc` instruction uses the same syntax as the `add` instruction
    and performs almost the same operation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将两个 96 位值中的第二对双字加在一起。注意，在步骤 2 中，计算还必须加上前一次加法的进位（如果有的话）。如果 L.O. 加法有进位，`add`
    指令会将进位标志设置为 1；相反，如果 L.O. 加法没有进位，之前的 `add` 指令会清除进位标志。因此，在第二次加法中，我们实际上需要计算两个双字的和，再加上第一次指令的进位。幸运的是，x86
    CPU 提供了一条可以完成此操作的指令：`adc`（带进位加法）指令。`adc` 指令与 `add` 指令使用相同的语法，执行的操作几乎相同：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the only difference between the `add` and `adc` instructions
    is that the `adc` instruction adds in the value of the carry flag along with the
    source and destination operands. It also sets the flags the same way the `add`
    instruction does (including setting the carry flag if there is an unsigned overflow).
    This is exactly what we need to add together the middle two double words of our
    96-bit sum.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`add`和`adc`指令之间的唯一区别是，`adc`指令在源操作数和目标操作数相加的同时，还会将进位标志的值加进来。它还会像`add`指令一样设置标志（包括在发生无符号溢出时设置进位标志）。这正是我们需要将96位和数的中间两个双字加在一起的方式。
- en: In step 3 of [Figure 8-1](ch08.html#adding_two_96-bit_objects_together "Figure 8-1. Adding
    two 96-bit objects together"), the algorithm adds together the H.O. double words
    of the 96-bit value. This addition operation must also incorporate the carry out
    of the sum of the middle two double words; hence the `adc` instruction is needed
    here as well. To sum it up, the `add` instruction adds the L.O. double words together.
    The `adc` (add with carry) instruction adds all other double word pairs together.
    At the end of the extended-precision addition sequence, the carry flag indicates
    unsigned overflow (if set), a set overflow flag indicates signed overflow, and
    the sign flag indicates the sign of the result. The zero flag doesn't have any
    real meaning at the end of the extended-precision addition (it simply means that
    the sum of the two H.O. double words is 0 and does not indicate that the whole
    result is 0). If you want to see how to check for an extended-precision zero result,
    see the source code for the HLA Standard Library `math.addq` or `math.addl` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8-1](ch08.html#adding_two_96-bit_objects_together "图8-1. 将两个96位对象相加")的第3步中，算法将96位值的高位双字相加。这个加法操作还必须将中间两个双字相加的进位考虑进去；因此，这里也需要使用`adc`指令。总的来说，`add`指令将低位双字相加。`adc`（带进位加法）指令将其他双字对相加。在扩展精度加法序列结束时，进位标志指示无符号溢出（如果设置），溢出标志指示有符号溢出，符号标志指示结果的符号。零标志在扩展精度加法结束时没有实际意义（它仅表示两个高位双字的和为0，并不表示整个结果为0）。如果你想查看如何检查扩展精度零结果，请参阅HLA标准库中`math.addq`或`math.addl`函数的源代码。
- en: 'For example, suppose that you have two 64-bit values you wish to add together,
    defined as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有两个64位的值希望相加，它们定义如下：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Suppose also that you want to store the sum in a third variable, `Z`, which
    is also a `qword`. The following 80x86 code will accomplish this task:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你还想将和存储在第三个变量`Z`中，该变量也是`qword`。以下80x86代码将完成此任务：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember, these variables are `qword` objects. Therefore the compiler will not
    accept an instruction of the form `mov( X, eax );` because this instruction would
    attempt to load a 64-bit value into a 32-bit register. This code uses the coercion
    operator to coerce symbols `X`, `Y`, and `Z` to 32 bits. The first three instructions
    add the L.O. double words of `X` and `Y` together and store the result at the
    L.O. double word of `Z`. The last three instructions add the H.O. double words
    of `X` and `Y` together, along with the carry from the L.O. word, and store the
    result in the H.O. double word of `Z`. Remember, address expressions of the form
    `X[4]` access the H.O. double word of a 64-bit entity. This is because the x86
    memory space addresses bytes, and it takes 4 consecutive bytes to form a double
    word.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些变量是`qword`对象。因此，编译器不会接受`mov( X, eax );`这种形式的指令，因为该指令会尝试将64位的值加载到32位寄存器中。此代码使用强制转换操作符将符号`X`、`Y`和`Z`强制转换为32位。前三条指令将`X`和`Y`的低位双字相加，并将结果存储在`Z`的低位双字中。最后三条指令将`X`和`Y`的高位双字相加，并加上低位字的进位，将结果存储在`Z`的高位双字中。记住，形式为`X[4]`的地址表达式访问的是64位实体的高位双字。这是因为x86内存空间按字节寻址，4个连续字节组成一个双字。
- en: 'You can extend this to any number of bits by using the `adc` instruction to
    add in the higher-order values. For example, to add together two 128-bit values,
    you could use code like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`adc`指令加上高位值，将其扩展到任意位数。例如，若要将两个128位值相加，你可以使用如下代码：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 8.1.3 Multiprecision Subtraction Operations
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.3 多精度减法操作
- en: The 80x86 performs multibyte subtraction, just as it does addition, the same
    way you would manually, except it subtracts whole bytes, words, or double words
    at a time rather than decimal digits. The mechanism is similar to that for the
    `add` operation. You use the `sub` instruction on the L.O. byte/word/double word
    and the `sbb` (subtract with borrow) instruction on the high-order values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86执行多字节减法，就像它执行加法一样，方式与手动操作相同，只不过它一次减去的是整个字节、字或双字，而不是十进制数字。这个机制与`add`操作的机制类似。你在低阶字节/字/双字上使用`sub`指令，而在高阶值上使用`sub`（带借位）指令。
- en: 'The following example demonstrates a 64-bit subtraction using the 32-bit registers
    on the 80x86:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用80x86的32位寄存器进行的64位减法：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following example demonstrates a 128-bit subtraction:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一个128位减法：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 8.1.4 Extended-Precision Comparisons
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.4 扩展精度比较
- en: Unfortunately, there isn't a "compare with borrow" instruction that you can
    use to perform extended-precision comparisons. Since the `cmp` and `sub` instructions
    perform the same operation, at least as far as the flags are concerned, you'd
    probably guess that you could use the `sbb` instruction to synthesize an extended-precision
    comparison; however, that approach won't always work. Fortunately, there is a
    better solution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有“带借位比较”指令可以用于执行扩展精度比较。由于`cmp`和`sub`指令执行相同的操作，至少就标志位而言，你可能会猜测可以使用`sub`指令来合成扩展精度比较；然而，这种方法并不总是有效。幸运的是，存在更好的解决方案。
- en: 'Consider the two unsigned values $2157 and $1293\. The L.O. bytes of these
    two values do not affect the outcome of the comparison. Simply comparing the H.O.
    bytes, $21 with $12, tells us that the first value is greater than the second.
    In fact, the only time you ever need to look at both bytes of these values is
    if the H.O. bytes are equal. In all other cases comparing the H.O. bytes tells
    you everything you need to know about the values. Of course, this is true for
    any number of bytes, not just 2\. The following code compares two signed 64-bit
    integers by comparing their H.O. double words first and comparing their L.O. double
    words only if the H.O. double words are equal:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个无符号值$2157和$1293。这两个值的低阶字节不影响比较结果。只需比较高阶字节，$21与$12，就能判断第一个值大于第二个值。事实上，只有在高阶字节相等时，你才需要查看这两个字节。在所有其他情况下，比较高阶字节就能告诉你所有你需要了解的值。当然，这对于任意字节数都是成立的，不仅仅是2个字节。以下代码通过先比较高阶双字，再在高阶双字相等时才比较低阶双字，来比较两个有符号的64位整数：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To compare unsigned values, simply use the `ja` and `jb` instructions in place
    of `jg` and `jl`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较无符号值，只需将`jg`和`jl`指令分别替换为`ja`和`jb`。
- en: 'You can easily synthesize any possible comparison from the preceding sequence.
    The following examples show how to do this. These examples demonstrate signed
    comparisons; just substitute `ja`, `jae`, `jb`, and `jbe` for `jg`, `jge`, `jl`,
    and `jle` (respectively) if you want unsigned comparisons. Each of the following
    examples assumes these declarations:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地从前面的序列中合成任何可能的比较。以下示例展示了如何做到这一点。这些示例演示了有符号比较；如果你需要无符号比较，只需将`jg`、`jge`、`jl`、`jle`分别替换为`ja`、`jae`、`jb`、`jbe`。每个示例假设以下声明：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following code implements a 64-bit test to see if `QW1 < QW2` (signed).
    Control transfers to `IsLess` label if `QW1 < QW2`. Control falls through to the
    next statement if this is not true.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个64位测试，检查`QW1 < QW2`（有符号）。如果`QW1 < QW2`，控制流转移到`IsLess`标签。如果不成立，控制流将继续到下一条语句。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here is a 64-bit test to see if `QW1 <= QW2` (signed). This code jumps to `IsLessEq`
    if the condition is true.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个64位测试，检查`QW1 <= QW2`（有符号）。如果条件成立，这段代码会跳转到`IsLessEq`。
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a 64-bit test to see if `QW1 > QW2` (signed). It jumps to `IsGtr` if
    this condition is true.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个64位测试，检查`QW1 > QW2`（有符号）。如果条件成立，它会跳转到`IsGtr`。
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The following is a 64-bit test to see if `QW1 >= QW2` (signed). This code jumps
    to label `IsGtrEQ` if this is the case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个64位测试，检查`QW1 >= QW2`（有符号）。如果条件成立，这段代码会跳转到标签`IsGtrEQ`。
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here is a 64-bit test to see if `QW1 = QW2` (signed or unsigned). This code
    branches to the label `IsEqual` if `QW1 = QW2`. It falls through to the next instruction
    if they are not equal.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个64位测试，检查`QW1 = QW2`（有符号或无符号）。如果`QW1 = QW2`，这段代码会跳转到`IsEqual`标签。如果不相等，则继续执行下一条指令。
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The following is a 64-bit test to see if `QW1 <> QW2` (signed or unsigned).
    This code branches to the label `NotEqual` if `QW1 <> QW2`. It falls through to
    the next instruction if they are equal.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 64 位测试，用于检查 `QW1 <> QW2`（有符号或无符号）。如果 `QW1 <> QW2`，这段代码会跳转到标签 `NotEqual`。如果它们相等，则会继续执行下一条指令。
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You cannot directly use the HLA high-level control structures if you need to
    perform an extended-precision comparison. However, you may use the HLA hybrid
    control structures and bury the appropriate comparison in the boolean expression.
    Doing so may produce easier to read code. For example, the following `if..then..else..endif`
    statement checks to see if `QW1 > QW2` using a 64-bit extended-precision unsigned
    comparison:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进行扩展精度比较，则无法直接使用 HLA 高级控制结构。然而，你可以使用 HLA 混合控制结构，并将适当的比较嵌入到布尔表达式中。这样做可能会使代码更易于阅读。例如，下面的`if..then..else..endif`语句使用
    64 位扩展精度无符号比较来检查 `QW1 > QW2`：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you need to compare objects that are larger than 64 bits, it is very easy
    to generalize the code given above for 64-bit operands. Always start the comparison
    with the H.O. double words of the objects and work your way down to the L.O. double
    words of the objects as long as the corresponding double words are equal. The
    following example compares two 128-bit values to see if the first is less than
    or equal (unsigned) to the second:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要比较大于 64 位的对象，可以很容易地将上面给出的 64 位操作数的代码进行泛化。总是从对象的高阶双字开始比较，并一直向下比较到对象的低阶双字，只要相应的双字相等。以下示例比较两个
    128 位值，以检查第一个值是否小于或等于（无符号）第二个值：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 8.1.5 Extended-Precision Multiplication
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.5 扩展精度乘法
- en: Although an 8×8-bit, 16×16-bit, or 32×32-bit multiplication is usually sufficient,
    there are times when you may want to multiply larger values. You will use the
    x86 single operand `mul` and `imul` instructions for extended-precision multiplication
    operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 8×8 位、16×16 位或 32×32 位的乘法通常足够，但有时你可能需要乘以更大的值。你将使用 x86 单操作数的 `mul` 和 `imul`
    指令进行扩展精度乘法操作。
- en: 'Not surprisingly (in view of how we achieved extended-precision addition using
    `adc` and `sbb`), you use the same techniques to perform extended-precision multiplication
    on the 80x86 that you employ when manually multiplying two values. Consider a
    simplified form of the way you perform multidigit multiplication by hand:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪（考虑到我们如何通过 `adc` 和 `sbb` 实现扩展精度加法），你使用相同的技术在 80x86 上执行扩展精度乘法，就像手动乘两个值时所采用的方法一样。考虑一种简化形式的手工多位数乘法方式：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The 80x86 does extended-precision multiplication in the same manner except that
    it works with bytes, words, and double words rather than digits. [Figure 8-2](ch08.html#extended-precision_multiplication-id1
    "Figure 8-2. Extended-precision multiplication") shows how this works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 以相同的方式执行扩展精度乘法，唯一不同的是它操作的是字节、字和双字，而不是数字。[图 8-2](ch08.html#extended-precision_multiplication-id1
    "图 8-2. 扩展精度乘法")展示了这种工作方式。
- en: '![Extended-precision multiplication](tagoreillycom20100401nostarchimages578045.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![扩展精度乘法](tagoreillycom20100401nostarchimages578045.png)'
- en: Figure 8-2. Extended-precision multiplication
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2. 扩展精度乘法
- en: Probably the most important thing to remember when performing an extended-precision
    multiplication is that you must also perform a multiple-precision addition at
    the same time. Adding up all the partial products requires several additions that
    will produce the result. [Example 8-1](ch08.html#extended-precision_multiplication-id2
    "Example 8-1. Extended-precision multiplication") demonstrates the proper way
    to multiply two 64-bit values on a 32-bit processor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行扩展精度乘法时，可能最重要的是记住，必须同时执行多重精度加法。将所有部分积相加需要进行几次加法运算，最终产生结果。[示例 8-1](ch08.html#extended-precision_multiplication-id2
    "示例 8-1. 扩展精度乘法")展示了在 32 位处理器上乘以两个 64 位值的正确方法。
- en: Example 8-1. Extended-precision multiplication
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-1. 扩展精度乘法
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: One thing you must keep in mind concerning this code is that it works only for
    unsigned operands. To multiply two signed values you must note the signs of the
    operands before the multiplication, take the absolute value of the two operands,
    do an unsigned multiplication, and then adjust the sign of the resulting product
    based on the signs of the original operands. Multiplication of signed operands
    is left as an exercise to the reader (or you could just check out the source code
    in the HLA Standard Library).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住的一件事是，这段代码仅适用于无符号操作数。要将两个有符号值相乘，必须在乘法之前注意操作数的符号，取两个操作数的绝对值，进行无符号乘法，然后根据原操作数的符号调整结果积的符号。有符号操作数的乘法留给读者自己做（或者你可以查看HLA标准库中的源代码）。
- en: The example in [Example 8-1](ch08.html#extended-precision_multiplication-id2
    "Example 8-1. Extended-precision multiplication") was fairly straightforward because
    it was possible to keep the partial products in various registers. If you need
    to multiply larger values together, you will need to maintain the partial products
    in temporary (memory) variables. Other than that, the algorithm that [Example 8-1](ch08.html#extended-precision_multiplication-id2
    "Example 8-1. Extended-precision multiplication") uses generalizes to any number
    of double words.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-1](ch08.html#extended-precision_multiplication-id2 "示例 8-1. 扩展精度乘法")中的例子相当直接，因为可以将部分积保存在不同的寄存器中。如果你需要将更大的值相乘，就需要将部分积保存在临时（内存）变量中。除此之外，[示例
    8-1](ch08.html#extended-precision_multiplication-id2 "示例 8-1. 扩展精度乘法")使用的算法可以推广到任意数量的双字。'
- en: 8.1.6 Extended-Precision Division
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.6 扩展精度除法
- en: You cannot synthesize a general *n*-bit/*m*-bit division operation using the
    `div` and `idiv` instructions. Extended-precision division requires a sequence
    of shift and subtract instructions and is extremely messy. However, a less-general
    operation, dividing an *n*-bit quantity by a 32-bit quantity, is easily synthesized
    using the `div` instruction. This section presents both methods for extended-precision
    division.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能通过`div`和`idiv`指令合成一个通用的*n*位/*m*位除法操作。扩展精度除法需要一系列的移位和减法指令，过程非常复杂。然而，除去一般的操作，将*n*位数除以32位数是可以通过`div`指令轻松合成的。本节介绍了两种扩展精度除法的方法。
- en: Before we describe how to perform a multiprecision division operation, you should
    note that some operations require an extended-precision division even though they
    may look calculable with a single `div` or `idiv` instruction. Dividing a 64-bit
    quantity by a 32-bit quantity is easy, as long as the resulting quotient fits
    into 32 bits. The `div` and `idiv` instructions will handle this directly. However,
    if the quotient does not fit into 32 bits, then you have to handle this problem
    as an extended-precision division. The trick here is to divide the (zero- or sign-extended)
    H.O. double word of the dividend by the divisor and then repeat the process with
    the remainder and the L.O. dword of the dividend. The following sequence demonstrates
    this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述如何执行多精度除法操作之前，你需要注意，尽管某些操作看起来可以用单一的`div`或`idiv`指令进行计算，但仍然需要扩展精度除法。将一个64位数除以一个32位数很简单，只要结果商可以适应32位。`div`和`idiv`指令会直接处理这个问题。然而，如果商不能适应32位，那么你必须将这个问题作为扩展精度除法来处理。这里的技巧是，将被除数的高字（H.O.）双字（无符号扩展或符号扩展）除以除数，然后用余数和被除数的低字（L.O.）再次进行相同操作。以下的步骤展示了这一过程。
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since it is perfectly legal to divide a value by 1, it is possible that the
    resulting quotient could require as many bits as the dividend. That is why the
    `quotient` variable in this example is the same size (64 bits) as the `dividend`
    variable (note the use of an array of two double words rather than a `qword` type;
    this spares the code from having to coerce the operands to double words). Regardless
    of the size of the dividend and divisor operands, the remainder is always no larger
    than the size of the division operation (32 bits in this case). Hence the `remainder`
    variable in this example is just a double word.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于除以1是完全合法的，因此结果商可能需要与被除数一样多的位数。这就是为什么在这个例子中，`quotient`变量和`dividend`变量的大小相同（64位）（注意使用两个双字数组而非`qword`类型；这样可以避免代码中将操作数强制转换为双字）。无论被除数和除数操作数的大小如何，余数的大小总是不会超过除法操作的大小（此例中为32位）。因此，例子中的`remainder`变量仅为一个双字。
- en: 'Before analyzing this code to see how it works, let''s take a brief look at
    why a single 64/32 division will not work for this particular example even though
    the `div` instruction does indeed calculate the result for a 64/32 division. The
    naive approach, assuming that the x86 were capable of this operation, would look
    something like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析这段代码如何工作之前，让我们简要了解一下为什么单一的64/32除法对于这个特定的例子不起作用，尽管`div`指令确实能够计算64/32除法的结果。假设x86能够执行这种操作的天真方法大致如下：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although this code is syntactically correct and will compile, if you attempt
    to run this code it will raise an `ex.DivideError`^([[112](#ftn.CHP-8-FN-2)])
    exception. The reason is that the quotient must fit into 32 bits. Because the
    quotient turns out to be $2_0000_091A, it will not fit into the EAX register,
    hence the resulting exception.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码在语法上是正确的并且能够编译，但是如果你尝试运行这段代码，它将引发一个`ex.DivideError`^([[112](#ftn.CHP-8-FN-2)])异常。原因是商必须能够适配32位，因为商的值是$2_0000_091A，它无法适配EAX寄存器，因此会引发异常。
- en: Now let's take another look at the former code that correctly computes the 64/32
    quotient. This code begins by computing the 32/32 quotient of `dividend[4]/divisor`.
    The quotient from this division (2) becomes the H.O. double word of the final
    quotient. The remainder from this division (0) becomes the extension in EDX for
    the second half of the division operation. The second half of the code divides
    `edx:dividend[0]` by `divisor` to produce the L.O. double word of the quotient
    and the remainder from the division. Note that the code does not zero extend EAX
    into EDX prior to the second `div` instruction. EDX already contains valid bits,
    and this code must not disturb them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再看一下之前那段能够正确计算64/32商的代码。该代码首先计算`dividend[4]`与除数的32/32商。这个除法的商（2）成为最终商的高位双字。这个除法的余数（0）成为除法操作第二部分的EDX扩展。代码的第二部分将`edx:dividend[0]`除以除数，以产生商的低位双字和除法的余数。注意，代码在第二个`div`指令之前没有将EAX零扩展到EDX。EDX已经包含有效位，这段代码不能打乱这些位。
- en: The 64/32 division operation above is actually just a special case of the general
    division operation that lets you divide an arbitrary size value by a 32-bit divisor.
    To achieve this, you begin by moving the H.O. double word of the dividend into
    EAX and zero extending this into EDX. Next, you divide this value by the divisor.
    Then, without modifying EDX along the way, you store away the partial quotients,
    load EAX with the next-lower double word in the dividend, and divide it by the
    divisor. You repeat this operation until you've processed all the double words
    in the dividend. At that time the EDX register will contain the remainder. The
    program in [Example 8-2](ch08.html#unsigned_128_solidus_32-bit_extended-pre "Example 8-2. Unsigned
    128/32-bit extended-precision division") demonstrates how to divide a 128-bit
    quantity by a 32-bit divisor, producing a 128-bit quotient and a 32-bit remainder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的64/32除法操作实际上只是通用除法操作的一种特殊情况，它允许你将一个任意大小的值除以一个32位的除数。为了实现这一点，你首先将被除数的高位双字移入EAX寄存器，并将其零扩展到EDX寄存器。接着，你将这个值除以除数。然后，在不修改EDX的情况下，存储部分商，将EAX加载为被除数的下一个低位双字，并用除数除以它。你重复这个操作，直到处理完被除数中的所有双字。这时，EDX寄存器将包含余数。[示例
    8-2](ch08.html#unsigned_128_solidus_32-bit_extended-pre "示例 8-2. 无符号128/32位扩展精度除法")中的程序演示了如何将一个128位的数除以一个32位的除数，得到一个128位的商和一个32位的余数。
- en: Example 8-2. Unsigned 128/32-bit extended-precision division
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2. 无符号128/32位扩展精度除法
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can extend this code to any number of bits by simply adding additional `mov`/`div`/`mov`
    instructions to the sequence. Like the extended-precision multiplication the previous
    section presents, this extended-precision division algorithm works only for unsigned
    operands. If you need to divide two signed quantities, you must note their signs,
    take their absolute values, do the unsigned division, and then set the sign of
    the result based on the signs of the operands.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地向指令序列中添加额外的`mov`/`div`/`mov`指令来扩展这段代码，支持任意位数的操作。像上一节所介绍的扩展精度乘法一样，这种扩展精度除法算法仅适用于无符号操作数。如果你需要除以两个有符号数，你必须注意它们的符号，取其绝对值，进行无符号除法，然后根据操作数的符号设置结果的符号。
- en: If you need to use a divisor larger than 32 bits, you're going to have to implement
    the division using a shift-and-subtract strategy. Unfortunately, such algorithms
    are very slow. In this section we'll develop two division algorithms that operate
    on an arbitrary number of bits. The first is slow but easier to understand; the
    second is quite a bit faster (in the average case).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用大于 32 位的除数，你将不得不使用移位和减法策略来实现除法。不幸的是，这种算法非常慢。在本节中，我们将开发两种能在任意位数上进行除法的算法。第一种算法较慢，但更容易理解；第二种算法要快得多（在平均情况下）。
- en: As for multiplication, the best way to understand how the computer performs
    division is to study how you were taught to do long division by hand. Consider
    the operation 3,456/12 and the steps you would take to manually perform this operation,
    as shown in [Figure 8-3](ch08.html#manual_digit-by-digit_division_operation "Figure 8-3. Manual
    digit-by-digit division operation").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像乘法一样，理解计算机如何进行除法的最佳方法是研究你如何被教导手工进行长除法。考虑操作 3,456/12，以及你手动执行此操作时所采取的步骤，如 [图
    8-3](ch08.html#manual_digit-by-digit_division_operation "图 8-3. 手动逐位除法操作") 所示。
- en: '![Manual digit-by-digit division operation](tagoreillycom20100401nostarchimages578047.png.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![手动逐位除法操作](tagoreillycom20100401nostarchimages578047.png.jpg)'
- en: Figure 8-3. Manual digit-by-digit division operation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3. 手动逐位除法操作
- en: This algorithm is actually easier in binary because at each step you do not
    have to guess how many times 12 goes into the remainder, nor do you have to multiply
    12 by your guess to obtain the amount to subtract. At each step in the binary
    algorithm the divisor goes into the remainder exactly zero or one times. As an
    example, consider the division of 27 (11011) by 3 (11) that is shown in [Figure 8-4](ch08.html#longhand_division_in_binary
    "Figure 8-4. Longhand division in binary").
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法在二进制下实际上更容易，因为在每一步中，你不需要猜测 12 能除尽余数多少次，也不需要将 12 乘以你的猜测来获得需要减去的数。在二进制算法的每一步中，除数对余数的除法结果恰好是零次或一次。例如，考虑将
    27 (11011) 除以 3 (11)，如 [图 8-4](ch08.html#longhand_division_in_binary "图 8-4. 二进制手动除法")
    所示。
- en: 'There is a novel way to implement this binary division algorithm that computes
    the quotient and the remainder at the same time. The algorithm is the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种新颖的方法来实现这个二进制除法算法，它可以同时计算商和余数。该算法如下：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Longhand division in binary](tagoreillycom20100401nostarchimages578049.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![二进制手动除法](tagoreillycom20100401nostarchimages578049.png)'
- en: Figure 8-4. Longhand division in binary
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4. 二进制手动除法
- en: '`NumberBits` is the number of bits in the `Remainder`, `Quotient`, `Divisor`,
    and `Dividend` variables. Note that the `Quotient := Quotient + 1;` statement
    sets the L.O. bit of `Quotient` to 1 because this algorithm previously shifts
    `Quotient` 1 bit to the left. The program in [Example 8-3](ch08.html#extended-precision_division-id1
    "Example 8-3. Extended-precision division") implements this algorithm.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberBits` 是 `Remainder`、`Quotient`、`Divisor` 和 `Dividend` 变量的位数。注意，`Quotient
    := Quotient + 1;` 语句将 `Quotient` 的最低有效位设置为 1，因为该算法之前将 `Quotient` 左移了 1 位。[示例 8-3](ch08.html#extended-precision_division-id1
    "示例 8-3. 扩展精度除法") 中的程序实现了这个算法。'
- en: Example 8-3. Extended-precision division
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-3. 扩展精度除法
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code looks simple but there are a few problems with it: It does not check
    for division by 0 (it will produce the value $FFFF_FFFF_FFFF_FFFF if you attempt
    to divide by 0), it handles only unsigned values, and it is very slow. Handling
    division by 0 is very simple; just check the divisor against 0 prior to running
    this code and return an appropriate error code if the divisor is 0 (or raise the
    `ex.DivisionError` exception). Dealing with signed values is the same as the earlier
    division algorithm: Note the signs, take the operands'' absolute values, do the
    unsigned division, and then fix the sign afterward. The performance of this algorithm,
    however, leaves a lot to be desired. It''s around an order of magnitude or two
    worse than the `div`/`idiv` instructions on the 80x86, and they are among the
    slowest instructions on the CPU.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来很简单，但存在一些问题：它没有检查除以 0 的情况（如果你尝试除以 0，它会产生值 $FFFF_FFFF_FFFF_FFFF），它仅处理无符号值，而且非常慢。处理除以
    0 的情况非常简单；只需在运行此代码之前检查除数是否为 0，并在除数为 0 时返回适当的错误代码（或引发 `ex.DivisionError` 异常）。处理有符号值与之前的除法算法相同：注意符号，取操作数的绝对值，进行无符号除法，然后修正符号。然而，这个算法的性能远远不如理想。它的性能大约比
    80x86 上的 `div`/`idiv` 指令慢一个数量级甚至两个，而这些指令本身就是 CPU 上最慢的指令之一。
- en: 'There is a technique you can use to boost the performance of this division
    by a fair amount: Check to see if the divisor variable uses only 32 bits. Often,
    even though the divisor is a 128-bit variable, the value itself fits just fine
    into 32 bits (that is, the H.O. double words of `Divisor` are 0). In this special
    case, which occurs frequently, you can use the `div` instruction, which is much
    faster. The algorithm is a bit more complex because you have to first compare
    the H.O. double words for 0, but on the average it runs much faster while remaining
    capable of dividing any two pairs of values.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种技术可以显著提升除法性能：检查除数变量是否只使用32位。通常，尽管除数是一个128位变量，但其值本身完全可以适应32位（即，`Divisor`的高双字是0）。在这种特殊情况下，这种情况发生得非常频繁，你可以使用`div`指令，它要快得多。算法稍微复杂一些，因为你必须首先比较高双字是否为0，但通常它的执行速度更快，并且能够除以任意两个值的对。
- en: 8.1.7 Extended-Precision neg Operations
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.7 扩展精度取反操作
- en: 'Although there are several ways to negate an extended-precision value, the
    shortest way for smaller values (96 bits or less) is to use a combination of `neg`
    and `sbb` instructions. This technique uses the fact that `neg` subtracts its
    operand from 0\. In particular, it sets the flags the same way the `sub` instruction
    would if you subtracted the destination value from 0\. This code takes the following
    form (assuming you want to negate the 64-bit value in EDX:EAX):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多种方法可以对扩展精度值进行取反，但对于较小的值（96位或更小），最简便的方法是结合使用`neg`和`sbb`指令。这种技术利用了`neg`指令将其操作数从0中减去的事实。特别是，它设置了与`sub`指令相同的标志，如果你从0中减去目标值的话。这段代码的形式如下（假设你要取反EDX:EAX中的64位值）：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `sbb` instruction decrements EDX if there is a borrow out of the L.O. word
    of the negation operation (which always occurs unless EAX is 0).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果取反操作的低字（L.O. word）有借位，`sbb`指令会将EDX递减（除非EAX为0，借位操作总是会发生）。
- en: Extending this operation to additional bytes, words, or double words is easy;
    all you have to do is start with the H.O. memory location of the object you want
    to negate and work toward the L.O. byte. The following code computes a 128-bit
    negation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将此操作扩展到更多字节、字或双字非常简单；你只需从要取反对象的高字节内存位置开始，向低字节方向工作。以下代码计算一个128位的取反操作。
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Unfortunately, this code tends to get really large and slow because you need
    to propagate the carry through all the H.O. words after each negation operation.
    A simpler way to negate larger values is to simply subtract that value from 0:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码往往变得非常庞大且缓慢，因为你需要在每次取反操作后将进位传播到所有高字（H.O. words）。对于较大的值，取反的一个更简单方法是直接将该值从0中减去：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 8.1.8 Extended-Precision and Operations
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.8 扩展精度和操作
- en: 'Performing an *n*-byte `and` operation is very easy: Simply `and` the corresponding
    bytes between the two operands, saving the result. For example, to perform the
    `and` operation where all operands are 64 bits long, you could use the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*n*字节`and`操作非常简单：只需将两个操作数中对应的字节进行`and`操作，保存结果。例如，要执行一个所有操作数为64位长的`and`操作，可以使用以下代码：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This technique easily extends to any number of words; all you need to do is
    logically `and` the corresponding bytes, words, or double words together in the
    operands. Note that this sequence sets the flags according to the value of the
    last `and` operation. If you `and` the H.O. double words last, this sets all but
    the zero flag correctly. If you need to test the zero flag after this sequence,
    you will need to logically `or` the two resulting double words together (or otherwise
    compare them both against 0).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术可以轻松扩展到任意数量的字；你只需要在操作数中按位逻辑`and`相应的字节、字或双字即可。注意，这个序列会根据最后一次`and`操作的结果设置标志。如果最后进行的是高双字（H.O.
    double words）的`and`操作，这将正确设置除了零标志外的所有标志。如果你需要在此序列之后检查零标志，你需要将得到的两个双字按位逻辑`or`（或其他方式比较它们是否为0）。
- en: 8.1.9 Extended-Precision or Operations
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.9 扩展精度或操作
- en: 'Multibyte logical `or` operations are performed in the same way as multibyte
    `and` operations. You simply `or` the corresponding bytes in the two operands
    together. For example, to logically `or` two 96-bit values, use the following
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 多字节逻辑`or`操作与多字节`and`操作的执行方式相同。你只需将两个操作数中对应的字节进行`or`操作。例如，要对两个96位值进行逻辑`or`操作，可以使用以下代码：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As for the previous example, this does not set the zero flag properly for the
    entire operation. If you need to test the zero flag after a multiprecision `or`,
    you must logically `or` all the resulting double words together.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，这样做不能正确设置整个操作的零标志。如果你在执行多精度的`or`后需要测试零标志，必须将所有结果的双字进行逻辑`or`运算。
- en: 8.1.10 Extended-Precision xor Operations
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.10 扩展精度的`xor`操作
- en: 'Extended-precision `xor` operations are performed in a manner identical to
    `and`/`or`—simply `xor` the corresponding bytes in the two operands to obtain
    the extended-precision result. The following code sequence operates on two 64-bit
    operands, computes their exclusive-`or`, and stores the result into a 64-bit variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度的`xor`操作与`and`/`or`操作相同——只需对两个操作数的相应字节执行`xor`，即可得到扩展精度的结果。以下代码序列对两个64位操作数进行`xor`运算，并将结果存储到64位变量中：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The comment about the zero flag in the previous two sections applies here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个部分提到的零标志的评论也适用于这里。
- en: 8.1.11 Extended-Precision not Operations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.11 扩展精度的非操作
- en: 'The `not` instruction inverts all the bits in the specified operand. An extended-precision
    `not` is performed by simply executing the `not` instruction on all the affected
    operands. For example, to perform a 64-bit `not` operation on the value in `(edx:eax)`,
    all you need to do is execute the following instructions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`指令会反转指定操作数中的所有位。扩展精度的`not`操作通过对所有受影响的操作数执行`not`指令来完成。例如，要对(EDX:EAX)中的64位值执行`not`操作，你只需执行以下指令：'
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Keep in mind that if you execute the `not` instruction twice, you wind up with
    the `or`iginal value. Also note that exclusive-`or`ing a value with all 1s ($FF,
    $FFFF, or $FFFF_FFFF) performs the same operation as the `not` instruction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你执行两次`not`指令，最终会得到`or`iginal值。还要注意，与所有1（$FF、$FFFF或$FFFF_FFFF）进行异或运算，与执行`not`指令的效果相同。
- en: 8.1.12 Extended-Precision Shift Operations
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.12 扩展精度移位操作
- en: 'Extended-precision shift operations require a shift and a rotate instruction.
    Consider what must happen to implement a 64-bit `shl` using 32-bit operations
    (see [Figure 8-5](ch08.html#bit_shift-left_operation "Figure 8-5. 64-bit shift-left
    operation")):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度的移位操作需要一个移位指令和一个旋转指令。考虑如何使用32位操作实现64位的`shl`（参见[图8-5](ch08.html#bit_shift-left_operation
    "图8-5. 64位左移操作")）：
- en: A 0 must be shifted into bit 0.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须将0移到位0。
- en: Bits 0 through 30 are shifted into the next-higher bit.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位0到30被移到下一个更高的位。
- en: Bit 31 is shifted into bit 32.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位31被移到位32。
- en: Bits 32 through 62 must be shifted into the next-higher bit.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位32到62必须移到下一个更高的位。
- en: Bit 63 is shifted into the carry flag.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位63被移到进位标志。
- en: '![64-bit shift-left operation](tagoreillycom20100401nostarchimages578051.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![64位左移操作](tagoreillycom20100401nostarchimages578051.png.jpg)'
- en: Figure 8-5. 64-bit shift-left operation
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5. 64位左移操作
- en: 'The two instructions you can use to implement this 64-bit shift are `shl` and
    `rcl`. For example, to shift the 64-bit quantity in (EDX:EAX) one position to
    the left, you''d use the following instructions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的两条指令来实现64位移位是`shl`和`rcl`。例如，要将(EDX:EAX)中的64位数值左移一位，可以使用以下指令：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that using this technique you can shift an extended-precision value only
    1 bit at a time. You cannot shift an extended-precision operand several bits using
    the CL register. Nor can you specify a constant value greater than 1 using this
    technique.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用这种技术，你一次只能移位一个扩展精度的值。不能使用CL寄存器将扩展精度操作数移位多个位。也不能使用这种技术指定大于1的常数值。
- en: To understand how this instruction sequence works, consider the operation of
    the individual instructions. The `shl` instruction shifts a 0 into bit 0 of the
    64-bit operand and shifts bit 31 into the carry flag. The `rcl` instruction then
    shifts the carry flag into bit 32 and then shifts bit 63 into the carry flag.
    The result is exactly what we want.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一指令序列是如何工作的，可以考虑每条指令的操作。`shl`指令将0移到64位操作数的位0，并将位31移到进位标志。然后，`rcl`指令将进位标志移到位32，再将位63移到进位标志。结果正是我们想要的。
- en: 'To perform a shift left on an operand larger than 64 bits, you simply use additional
    `rcl` instructions. An extended-precision shift-left operation always starts with
    the least-significant double word, and each succeeding `rcl` instruction operates
    on the next-most-significant double word. For example, to perform a 96-bit shift-left
    operation on a memory location, you could use the following instructions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要对超过64位的操作数进行左移操作，只需使用额外的`rcl`指令。扩展精度左移操作总是从最低有效双字开始，每个随后的`rcl`指令都作用于下一个更高有效双字。例如，要对一个96位的内存位置进行左移操作，可以使用以下指令：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you need to shift your data by 2 or more bits, you can either repeat the
    above sequence the desired number of times (for a constant number of shifts) or
    you can place the instructions in a loop to repeat them some number of times.
    For example, the following code shifts the 96-bit value *`Operand`* to the left
    the number of bits specified in ECX:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将数据移位2位或更多位，你可以重复上述序列所需的次数（对于固定次数的移位），或者将指令放入循环中，重复执行若干次。例如，以下代码将96位的*`Operand`*值向左移位，移位的位数由ECX指定：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You implement `shr` and `sar` in a similar way, except you must start at the
    H.O. word of the operand and work your way down to the L.O. word:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`shr`和`sar`的方式类似，只不过你必须从操作数的高位字开始，然后逐步移到低位字：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There is one major difference between the extended-precision shifts described
    here and their 8/16/32-bit counterparts—the extended-precision shifts set the
    flags differently than the single-precision operations. This is because the rotate
    instructions affect the flags differently than the shift instructions. Fortunately,
    the carry flag is the one you'll test most often after a shift operation, and
    the extended-precision shift operations (i.e., rotate instructions) properly set
    this flag.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的扩展精度移位操作与它们的8/16/32位对应操作有一个主要的区别——扩展精度移位设置标志位的方式不同于单精度操作。这是因为旋转指令对标志位的影响与移位指令不同。幸运的是，进位标志是你在移位操作后最常测试的标志，而扩展精度移位操作（即旋转指令）会正确地设置该标志。
- en: 'The `shld` and `shrd` instructions let you efficiently implement multiprecision
    shifts of several bits. These instructions have the following syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`shld`和`shrd`指令允许你高效地实现多个比特位的多精度移位。这些指令的语法如下：'
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `shld` instruction works as shown in [Figure 8-6](ch08.html#shld_operation
    "Figure 8-6. shld operation").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`shld`指令的工作方式如[图8-6](ch08.html#shld_operation "图8-6. shld操作")所示。'
- en: '![shld operation](tagoreillycom20100401nostarchimages578053.png.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![shld 操作](tagoreillycom20100401nostarchimages578053.png.jpg)'
- en: Figure 8-6. `shld` operation
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6. `shld`操作
- en: '*`Operand1`* must be a 16- or 32-bit register. *`Operand2`* can be a register
    or a memory location. Both operands must be the same size. The immediate operand
    can be a value in the range 0 through *n*−1, where *n* is the number of bits in
    the two operands; this operand specifies the number of bits to shift.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Operand1`*必须是16位或32位寄存器。*`Operand2`*可以是寄存器或内存位置。两个操作数的大小必须相同。立即数操作数可以是0到*n*−1之间的值，其中*n*是两个操作数的位数；此操作数指定移位的位数。'
- en: 'The `shld` instruction shifts bits in *`Operand2`* to the left. The H.O. bits
    shift into the carry flag, and the H.O. bits of *`Operand1`* shift into the L.O.
    bits of *`Operand2`*. Note that this instruction does not modify the value of
    *`Operand1`*; it uses a temporary copy of *`Operand1`* during the shift. The immediate
    operand specifies the number of bits to shift. If the count is *n*, then `shld`
    shifts bit *n*−1 into the carry flag. It also shifts the H.O. *n* bits of *`Operand1`*
    into the L.O. *n* bits of *`Operand2`*. The `shld` instruction sets the flag bits
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`shld`指令将*`Operand2`*中的位向左移。高位的位移入进位标志，而*`Operand1`*的高位则移入*`Operand2`*的低位。请注意，该指令不会修改*`Operand1`*的值；它在移位过程中使用*`Operand1`*的临时副本。立即数操作数指定移位的位数。如果计数为*n*，则`shld`将第*n*−1位移入进位标志。它还将*`Operand1`*的高位*n*位移入*`Operand2`*的低位*n*位。`shld`指令按如下方式设置标志位：'
- en: If the shift count is 0, the `shld` instruction doesn't affect any flags.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果移位计数为0，`shld`指令不会影响任何标志位。
- en: The carry flag contains the last bit shifted out of the H.O. bit of the *`Operand2`*.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进位标志包含从*`Operand2`*的高位移出的最后一位。
- en: If the shift count is 1, the overflow flag will contain 1 if the sign bit of
    *`Operand2`* changes during the shift. If the count is not 1, the overflow flag
    is undefined.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果移位计数为1，溢出标志将包含1，如果*`Operand2`*的符号位在移位过程中发生变化。如果计数不为1，则溢出标志未定义。
- en: The zero flag will be 1 if the shift produces a 0 result.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果移位操作产生结果为0，零标志将为1。
- en: The sign flag will contain the H.O. bit of the result.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号标志将包含结果的高位（H.O.）位。
- en: The `shrd` instruction is similar to `shld` except, of course, it shifts its
    bits right rather than left. To get a clear picture of the `shrd` instruction,
    consider [Figure 8-7](ch08.html#shrd_operation "Figure 8-7. shrd operation").
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`shrd`指令与`shld`类似，当然，它是将位向右移而不是向左移。为了更清晰地了解`shrd`指令，请参考[图8-7](ch08.html#shrd_operation
    "图8-7. shrd操作")。'
- en: '![shrd operation](tagoreillycom20100401nostarchimages578055.png.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![shrd operation](tagoreillycom20100401nostarchimages578055.png.jpg)'
- en: Figure 8-7. `shrd` operation
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7. `shrd`操作
- en: 'The `shrd` instruction sets the flag bits as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`shrd`指令会按如下方式设置标志位：'
- en: If the shift count is 0, the `shrd` instruction doesn't affect any flags.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果移位计数为0，`shrd`指令不会影响任何标志位。
- en: The carry flag contains the last bit shifted out of the L.O. bit of the *`Operand2`*.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进位标志包含从*`Operand2`*的低位（L.O.）移出最后一位。
- en: If the shift count is 1, the overflow flag will contain 1 if the H.O. bit of
    *`Operand2`* changes. If the count is not 1, the overflow flag is undefined.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果移位计数为1，溢出标志将在`Operand2`的高位（H.O.）位发生变化时为1。如果计数不为1，则溢出标志未定义。
- en: The zero flag will be 1 if the shift produces a 0 result.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果移位操作产生结果为0，零标志将为1。
- en: The sign flag will contain the H.O. bit of the result.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号标志将包含结果的高位（H.O.）位。
- en: 'Consider the following code sequence:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码序列：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first `shld` instruction above shifts the bits from `ShiftMe[4]` into `ShiftMe[8]`
    without affecting the value in `ShiftMe[4]`. The second `shld` instruction shifts
    the bits from `ShiftMe` into `ShiftMe[4]`. Finally, the `shl` instruction shifts
    the L.O. double word the appropriate amount. There are two important things to
    note about this code. First, unlike the other extended-precision shift-left operations,
    this sequence works from the H.O. double word down to the L.O. double word. Second,
    the carry flag does not contain the carry from the H.O. shift operation. If you
    need to preserve the carry flag at that point, you will need to push the flags
    after the first `shld` instruction and pop the flags after the `shl` instruction.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第一个`shld`指令将`ShiftMe[4]`中的位移到`ShiftMe[8]`中，而不会影响`ShiftMe[4]`中的值。第二个`shld`指令将`ShiftMe`中的位移到`ShiftMe[4]`。最后，`shl`指令将低位双字（L.O.）按适当的数量进行移位。关于这段代码，有两点需要注意。首先，与其他扩展精度左移操作不同，这一序列从高位双字（H.O.）向低位双字（L.O.）进行操作。其次，进位标志不包含来自高位移位操作的进位。如果你需要保留此时的进位标志，你需要在第一个`shld`指令后推送标志，并在`shl`指令后弹出标志。
- en: You can do an extended-precision shift-right operation using the `shrd` instruction.
    It works almost the same way as the code sequence above, except you work from
    the L.O. double word to the H.O. double word. The solution is left as an exercise
    for the reader.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`shrd`指令进行扩展精度的右移操作。它的工作方式几乎与上面的代码序列相同，不同之处在于你是从低位双字（L.O.）向高位双字（H.O.）进行操作。这个解答留给读者作为练习。
- en: 8.1.13 Extended-Precision Rotate Operations
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.13 扩展精度旋转操作
- en: 'The `rcl` and `rcr` operations extend in a manner almost identical to `shl`
    and `shr`. For example, to perform 96-bit `rcl` and `rcr` operations, use the
    following instructions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcl`和`rcr`操作的扩展方式几乎与`shl`和`shr`相同。例如，要执行96位的`rcl`和`rcr`操作，可以使用以下指令：'
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The only difference between this code and the code for the extended-precision
    shift operations is that the first instruction is a `rcl` or `rcr` rather than
    a `shl` or `shr` instruction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与扩展精度移位操作的代码唯一的区别是，第一个指令是`rcl`或`rcr`，而不是`shl`或`shr`指令。
- en: 'Performing an extended-precision `rol` or `ror` operation isn''t quite as simple.
    You can use the `bt`, `shld`, and `shrd` instructions to implement an extended-precision
    `rol` or `ror` instruction. The following code shows how to use the `shld` instruction
    to do an extended-precision `rol`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行扩展精度的`rol`或`ror`操作并不像想象的那么简单。你可以使用`bt`、`shld`和`shrd`指令来实现扩展精度的`rol`或`ror`指令。以下代码展示了如何使用`shld`指令执行扩展精度的`rol`操作：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: An extended-precision `ror` instruction is similar; just keep in mind that you
    work on the L.O. end of the object first and the H.O. end last.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度的`ror`指令类似；只需要记住，你首先在对象的低位（L.O.）进行操作，最后在高位（H.O.）进行操作。
- en: 8.1.14 Extended-Precision I/O
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.14 扩展精度输入/输出
- en: Once you can do extended-precision arithmetic, the next problem is how to get
    those extended-precision values into your program and how to display their values
    to the user. HLA's Standard Library provides routines for unsigned decimal, signed
    decimal, and hexadecimal I/O for values that are 8, 16, 32, 64, or 128 bits in
    length. So as long as you're working with values whose size is less than or equal
    to 128 bits in length, you can use the Standard Library code. If you need to input
    or output values that are greater than 128 bits in length, you will need to write
    your own procedures to handle the operation. This section discusses the strategies
    you will need to write such routines.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你可以进行扩展精度运算，下一个问题就是如何将这些扩展精度值引入程序并如何向用户显示它们的值。HLA的标准库提供了处理8、16、32、64或128位长度值的无符号十进制、带符号十进制和十六进制输入/输出例程。因此，只要你处理的值大小不超过128位，你就可以使用标准库的代码。如果需要输入或输出大于128位的值，你需要编写自己的例程来处理这些操作。本节讨论了编写此类例程所需的策略。
- en: The examples in this section work specifically with 128-bit values. The algorithms
    are perfectly general and extend to any number of bits (indeed, the 128-bit algorithms
    in this section are really nothing more than the algorithms the HLA Standard Library
    uses for 128-bit values). Of course, if you need a set of 128-bit unsigned I/O
    routines, you can use the Standard Library code as is. If you need to handle larger
    values, simple modifications to the following code are all that should be necessary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例专门处理128位值。这些算法是完全通用的，适用于任何位数（事实上，本节中的128位算法实际上与HLA标准库用于128位值的算法没有太大区别）。当然，如果你需要一组128位无符号输入/输出例程，你可以直接使用标准库的代码。如果需要处理更大的值，对以下代码进行简单的修改就足够了。
- en: 'The sections that follow use a common set of 128-bit data types in order to
    avoid having to coerce `lword`/`uns128`/`int128` values in each instruction. Here
    are these types:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节使用一组常见的128位数据类型，以避免在每条指令中强制转换`lword`/`uns128`/`int128`值。以下是这些数据类型：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 8.1.14.1 Extended-Precision Hexadecimal Output
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.1 扩展精度十六进制输出
- en: 'Extended-precision hexadecimal output is very easy. All you have to do is output
    each double-word component of the extended-precision value from the H.O. double
    word to the L.O. double word using a call to the `stdout.puth32` routine. The
    following procedure does exactly this to output an `lword` value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度十六进制输出非常简单。你只需要使用调用`stdout.puth32`例程，从高位双字到低位双字输出扩展精度值的每个双字组件。以下过程正是这样做的，用来输出一个`lword`值：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Of course, the HLA Standard Library supplies a `stdout.puth128` procedure that
    directly writes `lword` values, so you can call `stdout.puth128` multiple times
    when outputting larger values (e.g., a 256-bit value). As it turns out, the implementation
    of the HLA `stdlib.puth128` routine is very similar to `puth128`, above.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，HLA标准库提供了一个`stdout.puth128`过程，直接写入`lword`值，因此你可以在输出更大值（例如256位值）时多次调用`stdout.puth128`。事实证明，HLA
    `stdlib.puth128`过程的实现与上述的`puth128`非常相似。
- en: 8.1.14.2 Extended-Precision Unsigned Decimal Output
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.2 扩展精度无符号十进制输出
- en: Decimal output is a little more complicated than hexadecimal output because
    the H.O. bits of a binary number affect the L.O. digits of the decimal representation
    (this was not true for hexadecimal values, which is why hexadecimal output is
    so easy). Therefore, we will have to create the decimal representation for a binary
    number by extracting one decimal digit at a time from the number.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制输出比十六进制输出稍微复杂一些，因为二进制数的高位会影响十进制表示中的低位数字（这对于十六进制值来说并不成立，这也是十六进制输出如此简单的原因）。因此，我们需要通过一次提取一个十进制数字来创建二进制数的十进制表示。
- en: The most common solution for unsigned decimal output is to successively divide
    the value by 10 until the result becomes 0\. The remainder after the first division
    is a value in the range 0..9, and this value corresponds to the L.O. digit of
    the decimal number. Successive divisions by 10 (and their corresponding remainder)
    extract successive digits from the number.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无符号十进制输出，最常见的解决方案是反复将值除以10，直到结果变为0。第一次除法后的余数是0到9之间的一个值，该值对应于十进制数的低位数字。连续的除以10（及其相应的余数）提取数字的各个位。
- en: Iterative solutions to this problem generally allocate storage for a string
    of characters large enough to hold the entire number. Then the code extracts the
    decimal digits in a loop and places them in the string one by one. At the end
    of the conversion process, the routine prints the characters in the string in
    reverse order (remember, the divide algorithm extracts the L.O. digits first and
    the H.O. digits last, the opposite of the way you need to print them).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该问题的迭代方法通常为字符字符串分配足够大的存储空间来容纳整个数字。然后，代码在循环中逐个提取十进制数字，并将它们依次放入字符串中。在转换过程结束时，例程按相反顺序打印字符串中的字符（记住，除法算法先提取最低位数字，最后提取最高位数字，这与需要打印的顺序相反）。
- en: 'In this section, we employ a recursive solution because it is a little more
    elegant. The recursive solution begins by dividing the value by 10 and saving
    the remainder in a local variable. If the quotient is not 0, the routine recursively
    calls itself to print any leading digits first. On return from the recursive call
    (which prints all the leading digits), the recursive algorithm prints the digit
    associated with the remainder to complete the operation. Here''s how the operation
    works when printing the decimal value 789:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们采用递归解法，因为它稍显优雅。递归解法通过将值除以 10 并将余数保存在局部变量中开始。如果商不为 0，程序会递归调用自身，先打印所有前导数字。递归调用返回后（此时所有前导数字已打印），递归算法会打印与余数关联的数字以完成操作。以下是打印十进制值
    789 时操作的工作方式：
- en: Divide 789 by 10\. Quotient is 78, and remainder is 9.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 789 除以 10。商为 78，余数为 9。
- en: Save the remainder (9) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（9）保存在局部变量中，并递归调用该例程，传入商作为参数。
- en: '[Recursive entry 1] Divide 78 by 10\. Quotient is 7, and remainder is 8.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[递归入口 1] 将 78 除以 10。商为 7，余数为 8。'
- en: Save the remainder (8) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（8）保存在局部变量中，并递归调用该例程，传入商作为参数。
- en: '[Recursive entry 2] Divide 7 by 10\. Quotient is 0, and remainder is 7.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[递归入口 2] 将 7 除以 10。商为 0，余数为 7。'
- en: Save the remainder (7) in a local variable. Because the quotient is 0, don't
    call the routine recursively.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将余数（7）保存在局部变量中。由于商为 0，不需要递归调用该例程。
- en: Output the remainder value saved in the local variable (7). Return to the caller
    (recursive entry 1).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出保存在局部变量中的余数值（7）。返回给调用者（递归入口 1）。
- en: '[Return to recursive entry 1] Output the remainder value saved in the local
    variable in recursive entry 1 (8). Return to the caller (original invocation of
    the procedure).'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[返回递归入口 1](https://example.org/return_recursive_entry_1) 输出保存在递归入口 1（8）中的局部变量的余数值。返回给调用者（原始调用过程）。'
- en: '[Original invocation] Output the remainder value saved in the local variable
    in the original call (9). Return to the original caller of the output routine.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[原始调用] 输出保存在局部变量中的余数值（9）。返回给输出例程的原始调用者。'
- en: The only operation that requires extended-precision calculation through this
    entire algorithm is the "divide by 10" statement. Everything else is simple and
    straightforwar. We are in luck with this algorithm, because we are dividing an
    extended-precision value by a value that easily fits into a double word, and we
    can use the fast (and easy) extended-precision division algorithm that uses the
    `div` instruction. The program in [Example 8-4](ch08.html#bit_extended-precision_decimal_output_r
    "Example 8-4. 128-bit extended-precision decimal output routine") implements a
    128-bit decimal output routine utilizing this technique.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 整个算法中唯一需要扩展精度计算的操作是“除以 10”语句。其他的操作都简单直接。幸运的是，我们的算法是将一个扩展精度值除以一个轻松适应双字的值，因此我们可以使用快速（且简单的）扩展精度除法算法，该算法使用
    `div` 指令。示例 [8-4](ch08.html#bit_extended-precision_decimal_output_r "示例 8-4. 128
    位扩展精度十进制输出例程") 中实现了一个利用该技术的 128 位十进制输出例程。
- en: Example 8-4. 128-bit extended-precision decimal output routine
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-4。128 位扩展精度十进制输出例程
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 8.1.14.3 Extended-Precision Signed Decimal Output
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.3 扩展精度有符号十进制输出
- en: 'Once you have an extended-precision unsigned decimal output routine, writing
    an extended-precision signed decimal output routine is very easy. The basic algorithm
    takes the following form:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了扩展精度的无符号十进制输出例程，编写扩展精度的有符号十进制输出例程就非常简单了。基本算法的形式如下：
- en: Check the sign of the number.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查数字的符号。
- en: If it is positive, call the unsigned output routine to print it. If the number
    is negative, print a minus sign. Then negate the number and call the unsigned
    output routine to print it.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是正数，调用无符号输出例程打印它。如果数字是负数，打印负号。然后将数字取反并调用无符号输出例程打印它。
- en: 'To check the sign of an extended-precision integer, of course, you simply test
    the H.O. bit of the number. To negate a large value, the best solution is probably
    to subtract that value from 0\. Here''s a quick version of `puti128` that uses
    the `putu128` routine from the previous section:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查扩展精度整数的符号，当然，你只需测试该数字的最高有效位（H.O.位）。要取反一个大值，最好的解决方法可能是将该值从0中减去。下面是一个快速版本的`puti128`，它使用了前一部分中的`putu128`例程：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 8.1.14.4 Extended-Precision Formatted Output
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.4 扩展精度格式化输出
- en: The code in the previous two sections prints signed and unsigned integers using
    the minimum number of necessary print positions. To create nicely formatted tables
    of values you will need the equivalent of a `puti128Size` or `putu128Size` routine.
    Once you have the "unformatted" versions of these routines, implementing the formatted
    versions is very easy.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前两部分的代码使用最少的打印位置打印有符号和无符号整数。为了创建格式化良好的值表，你将需要等同于`puti128Size`或`putu128Size`例程的内容。一旦你拥有了这些例程的“未格式化”版本，实现格式化版本就非常容易了。
- en: The first step is to write `i128Size` and `u128Size` routines that compute the
    minimum number of digits needed to display the value. The algorithm to accomplish
    this is very similar to the numeric output routines. In fact, the only difference
    is that you initialize a counter to 0 upon entry into the routine (for example,
    the nonrecursive shell routine), and you increment this counter rather than outputting
    a digit on each recursive call. (Don't forget to increment the counter inside
    `i128Size` if the number is negative; you must allow for the output of the minus
    sign.) After the calculation is complete, these routines should return the size
    of the operand in the EAX register.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写`i128Size`和`u128Size`例程，这些例程计算显示该值所需的最小数字位数。实现这一算法的方法与数值输出例程非常相似。事实上，唯一的区别是在进入例程时初始化一个计数器为0（例如，非递归的外壳例程），然后在每次递归调用时递增该计数器，而不是输出一个数字。（如果数字为负，别忘了在`i128Size`中递增计数器；你必须考虑输出负号。）计算完成后，这些例程应返回操作数在EAX寄存器中的大小。
- en: Once you have the `i128Size` and `u128Size` routines, writing the formatted
    output routines is easy. Upon initial entry into `puti128Size` or `putu128Size`,
    these routines call the corresponding `size` routine to determine the number of
    print positions for the number to display. If the value that the `size` routine
    returns is greater than the absolute value of the minimum size parameter (passed
    into `puti128Size` or `putu128Size`), all you need to do is call the `put` routine
    to print the value; no other formatting is necessary. If the absolute value of
    the parameter size is greater than the value `i128Size` or `u128Size` returns,
    then the program must compute the difference between these two values and print
    that many spaces (or other filler characters) before printing the number (if the
    parameter size value is positive) or after printing the number (if the parameter
    size value is negative). The actual implementation of these two routines is left
    as an exercise to the reader (or just check out the source code in the HLA Standard
    Library for the `stdout.putiSize128` and `stdout.putuSize128` routines).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了`i128Size`和`u128Size`例程，编写格式化输出例程就很容易了。在初次进入`puti128Size`或`putu128Size`时，这些例程会调用相应的`size`例程来确定显示数字所需的打印位置数量。如果`size`例程返回的值大于最小大小参数的绝对值（传递给`puti128Size`或`putu128Size`），那么你只需调用`put`例程打印该值；无需其他格式化操作。如果参数大小的绝对值大于`i128Size`或`u128Size`返回的值，则程序必须计算这两个值之间的差异，并在打印数字之前（如果参数大小值为正）或打印数字之后（如果参数大小值为负）打印相应数量的空格（或其他填充字符）。这两个例程的实际实现留给读者自己去完成（或者直接查看HLA标准库中的`stdout.putiSize128`和`stdout.putuSize128`源代码）。
- en: The HLA Standard Library implements the `i128Size` and `u128Size` by doing a
    set of successive extended-precision comparisons to determine the number of digits
    in the values. Interested readers may want to look at the source code for these
    routines as well as the source code for the `stdout.puti128` and `stdout.putu128`
    procedures (this source code appears on Webster at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: HLA标准库通过执行一系列连续的扩展精度比较来实现`i128Size`和`u128Size`，以确定数值中的数字个数。有兴趣的读者可以查看这些例程的源代码，以及`stdout.puti128`和`stdout.putu128`过程的源代码（这些源代码可以在Webster网站上找到：[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    或 [http://www.artofasm.com/](http://www.artofasm.com/)）。
- en: 8.1.14.5 Extended-Precision Input Routines
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.5 扩展精度输入例程
- en: There are a couple of fundamental differences between the extended-precision
    output routines and the extended-precision input routines. First of all, numeric
    output generally occurs without possibility of error;^([[113](#ftn.CHP-8-FN-3)])
    numeric input, on the other hand, must handle the very real possibility of an
    input error such as illegal characters and numeric overflow. Also, HLA's Standard
    Library and runtime system encourage a slightly different approach to input conversion.
    This section discusses those issues that differentiate input conversion from output
    conversion.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度输出例程和扩展精度输入例程之间有几个根本性的区别。首先，数字输出通常不会发生错误；^([[113](#ftn.CHP-8-FN-3)])而数字输入则必须处理非常现实的输入错误可能性，例如非法字符和数字溢出。此外，HLA的标准库和运行时系统鼓励采用稍微不同的输入转换方法。本节讨论了那些将输入转换与输出转换区分开来的问题。
- en: Perhaps the biggest difference between input and output conversion is the fact
    that output conversion is not bracketed. That is, when converting a numeric value
    to a string of characters for output, the output routine does not concern itself
    with characters preceding the output string, nor is it concerned with the characters
    following the numeric value in the output stream. Numeric output routines convert
    their data to a string and print that string without considering the context (that
    is, the characters before and after the string representation of the numeric value).
    Numeric input routines cannot be so cavalier; the contextual information surrounding
    the numeric string is very important.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出转换之间最大的区别之一，可能就是输出转换不被括起来。也就是说，当将一个数字值转换为字符串以进行输出时，输出例程并不关心输出字符串前面的字符，也不关心输出流中数字值后面的字符。数字输出例程将数据转换为字符串，并打印该字符串，而不考虑上下文（即，数字值的字符串表示之前和之后的字符）。而数字输入例程不能如此轻率；数字字符串周围的上下文信息非常重要。
- en: 'A typical numeric input operation consists of reading a string of characters
    from the user and then translating this string of characters into an internal
    numeric representation. For example, a statement like `stdin.get(i32)`; typically
    reads a line of text from the user and converts a sequence of digits appearing
    at the beginning of that line of text into a 32-bit signed integer (assuming `i32`
    is an `int32` object). Note, however, that the `stdin.get` routine skips over
    certain characters in the string that may appear before the actual numeric characters.
    For example, `stdin.get` automatically skips any leading spaces in the string.
    Likewise, the input string may contain additional data beyond the end of the numeric
    input (for example, it is possible to read two integer values from the same input
    line), and therefore the input conversion routine must somehow determine where
    the numeric data ends in the input stream. Fortunately, HLA provides a simple
    mechanism that lets you easily determine the start and end of the input data:
    the `Delimiters` character set.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的数字输入操作包括从用户读取一串字符，然后将这串字符转换为内部的数字表示。例如，像`stdin.get(i32)`这样的语句通常会从用户那里读取一行文本，并将该行文本开头的数字序列转换为一个32位有符号整数（假设`i32`是一个`int32`对象）。然而需要注意的是，`stdin.get`例程会跳过字符串中某些可能出现在实际数字字符之前的字符。例如，`stdin.get`会自动跳过字符串中的任何前导空格。同样，输入字符串可能包含数字输入结束后的额外数据（例如，有可能从同一输入行中读取两个整数值），因此输入转换例程必须以某种方式确定数字数据在输入流中的结束位置。幸运的是，HLA提供了一个简单的机制，让你轻松地确定输入数据的开始和结束：`Delimiters`字符集。
- en: The `Delimiters` character set is a variable, internal to the HLA Standard Library,
    that contains the set of legal characters that may precede or follow a legal numeric
    value. By default, this character set includes the end-of-string marker (a 0 byte),
    a tab character, a line-feed character, a carriage-return character, a space,
    a comma, a colon, and a semicolon. Therefore, HLA's numeric input routines will
    automatically ignore any characters in this set that occur on input before a numeric
    string. Likewise, characters from this set may legally follow a numeric string
    on input (conversely, if any non-delimiter character follows the numeric string,
    HLA will raise an `ex.ConversionError` exception).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delimiters` 字符集是 HLA 标准库内部的一个变量，包含可以出现在合法数值之前或之后的合法字符集。默认情况下，该字符集包括字符串结尾标记（一个
    0 字节）、制表符、换行符、回车符、空格、逗号、冒号和分号。因此，HLA 的数值输入例程会自动忽略输入中的任何该字符集中的字符，这些字符出现在数值字符串之前。同样，该字符集中的字符也可以合法地跟在数值字符串后面（相反，如果任何非分隔符字符跟在数值字符串后面，HLA
    将抛出 `ex.ConversionError` 异常）。'
- en: 'The `Delimiters` character set is a private variable inside the HLA Standard
    Library. Although you do not have direct access to this object, the HLA Standard
    Library does provide two accessor functions, `conv.setDelimiters` and `conv.getDelimiters`,
    that let you access and modify the value of this character set. These two functions
    have the following prototypes (found in the *conv.hhf* header file):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delimiters` 字符集是 HLA 标准库中的一个私有变量。虽然你不能直接访问这个对象，但 HLA 标准库提供了两个访问函数，`conv.setDelimiters`
    和 `conv.getDelimiters`，允许你访问和修改该字符集的值。这两个函数的原型如下（可以在 *conv.hhf* 头文件中找到）：'
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `conv.setDelimiters` procedure will copy the value of the `Delims` parameter
    into the internal `Delimiters` character set. Therefore, you can use this procedure
    to change the character set if you want to use a different set of delimiters for
    numeric input. The `conv.getDelimiters` call returns a copy of the internal `Delimiters`
    character set in the variable you pass as a parameter to the `conv.getDelimiters`
    procedure. We will use the value returned by `conv.getDelimiters` to determine
    the end of numeric input when writing our own extended-precision numeric input
    routines.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`conv.setDelimiters` 程序将 `Delims` 参数的值复制到内部的 `Delimiters` 字符集。因此，你可以使用此程序更改字符集，如果你想为数值输入使用不同的分隔符集。`conv.getDelimiters`
    调用将返回一个你作为参数传递给 `conv.getDelimiters` 程序的变量中的 `Delimiters` 字符集的副本。我们将使用 `conv.getDelimiters`
    返回的值来确定数值输入的结束标志，编写我们自己的扩展精度数值输入例程。'
- en: When reading a numeric value from the user, the first step is to get a copy
    of the `Delimiters` character set. The second step is to read and discard input
    characters from the user as long as those characters are members of the `Delimiters`
    character set. Once a character is found that is not in the `Delimiters` set,
    the input routine must check this character and verify that it is a legal numeric
    character. If not, the program should raise an `ex.IllegalChar` exception if the
    character's value is outside the range $00..$7F, or it should raise the `ex.ConversionError`
    exception if the character is not a legal numeric character. Once the routine
    encounters a numeric character, it should continue reading characters as long
    as they are valid numeric characters; while reading the characters, the conversion
    routine should be translating them to the internal representation of the numeric
    data. If, during conversion, an overflow occurs, the procedure should raise the
    `ex.ValueOutOfRange` exception.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当从用户读取一个数值时，第一步是获取 `Delimiters` 字符集的副本。第二步是读取并丢弃用户输入的字符，只要这些字符属于 `Delimiters`
    字符集中的成员。一旦找到一个不属于 `Delimiters` 集合的字符，输入例程必须检查该字符并验证它是否是合法的数字字符。如果不是，并且该字符的值超出了范围
    $00..$7F，则程序应该抛出 `ex.IllegalChar` 异常；如果该字符不是合法的数字字符，则应该抛出 `ex.ConversionError`
    异常。一旦例程遇到一个数字字符，它应该继续读取字符，只要这些字符是有效的数字字符；在读取字符时，转换例程应将其转换为数值数据的内部表示。如果在转换过程中发生溢出，程序应抛出
    `ex.ValueOutOfRange` 异常。
- en: 'Conversion to numeric representation should end when the procedure encounters
    the first delimiter character at the end of the string of digits. However, it
    is very important that the procedure does not consume the delimiter character
    that ends the string. That is, the following is incorrect:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 数值转换应该在程序遇到字符串末尾的第一个分隔符字符时结束。然而，非常重要的是，程序不能消耗掉结束字符串的分隔符字符。也就是说，下面的做法是错误的：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first `while` loop reads a sequence of delimiter characters. When this first
    `while` loop ends, the character in AL is not a delimiter character. The second
    `while` loop processes a sequence of decimal digits. First, it checks the character
    read in the previous `while` loop to see if it is a decimal digit; if so, it processes
    that digit and reads the next character. This process continues until the call
    to `stdin.getc` (at the bottom of the loop) reads a nondigit character. After
    the second `while` loop, the program checks the last character read to ensure
    that it is a legal delimiter character for a numeric input value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`while`循环读取一串分隔符字符。当第一个`while`循环结束时，AL中的字符不再是分隔符字符。第二个`while`循环处理一串十进制数字。首先，它检查前一个`while`循环中读取的字符，看看它是否是十进制数字；如果是，它会处理该数字并读取下一个字符。这个过程一直持续，直到调用`stdin.getc`（位于循环底部）读取到一个非数字字符。第二个`while`循环结束后，程序会检查最后一个读取的字符，以确保它是一个合法的分隔符字符，用于数值输入。
- en: The problem with this algorithm is that it consumes the delimiter character
    after the numeric string. For example, the colon symbol is a legal delimiter in
    the default `Delimiters` character set. If the user types the input **`123:456`**
    and executes the code above, this code will properly convert `123` to the numeric
    value 123\. However, the very next character read from the input stream will be
    the character 4, not the colon character (:). While this may be acceptable in
    certain circumstances, most programmers expect numeric input routines to consume
    only leading delimiter characters and the numeric digit characters. They do not
    expect the input routine to consume any trailing delimiter characters (for example,
    many programs will read the next character and expect a colon as input if presented
    with the string `123:456`). Because `stdin.getc` consumes an input character,
    and there is no way to put the character back onto the input stream, some other
    way of reading input characters from the user that doesn't consume those characters
    is needed.^([[114](#ftn.CHP-8-FN-4)])
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的问题在于它会消耗掉数字字符串后面的分隔符字符。例如，冒号符号在默认的`Delimiters`字符集中是一个合法的分隔符。如果用户输入**`123:456`**并执行上面的代码，这段代码会正确地将`123`转换为数值123。然而，从输入流中读取的下一个字符将是字符4，而不是冒号字符（:）。虽然在某些情况下这是可以接受的，但大多数程序员期望数字输入例程只消耗前导分隔符字符和数字字符。他们不希望输入例程消耗任何后续的分隔符字符（例如，许多程序会读取下一个字符，并期望看到冒号作为输入，如果输入字符串是`123:456`）。因为`stdin.getc`会消耗一个输入字符，而且没有办法将字符重新放回输入流，所以需要一种不会消耗字符的方式来读取用户输入的字符。^([[114](#ftn.CHP-8-FN-4)])
- en: 'The HLA Standard Library comes to the rescue by providing the `stdin.peekc`
    function. Like `stdin.getc`, the `stdin.peekc` routine reads the next input character
    from HLA''s internal buffer. There are two major differences between `stdin.peekc`
    and `stdin.getc`. First, `stdin.peekc` will not force the input of a new line
    of text from the user if the current input line is empty (or you''ve already read
    all the text from the input line). Instead, `stdin.peekc` simply returns 0 in
    the AL register to indicate that there are no more characters on the input line.
    Because #0 (the NUL character) is (by default) a legal delimiter character for
    numeric values, and the end of line is certainly a legal way to terminate numeric
    input, this works out rather well. The second difference between `stdin.getc`
    and `stdin.peekc` is that `stdin.peekc` does not consume the character read from
    the input buffer. If you call `stdin.peekc` several times in a row, it will always
    return the same character; likewise, if you call `stdin.getc` immediately after
    `stdin.peekc`, the call to `stdin.getc` will generally return the same character
    as returned by `stdin.peekc` (the only exception being the end-of-line condition).
    So, although we cannot put characters back onto the input stream after we''ve
    read them with `stdin.getc`, we can peek ahead at the next character on the input
    stream and base our logic on that character''s value. A corrected version of the
    previous algorithm might be the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'HLA 标准库通过提供 `stdin.peekc` 函数来提供帮助。像 `stdin.getc` 一样，`stdin.peekc` 例程从 HLA 的内部缓冲区读取下一个输入字符。`stdin.peekc`
    和 `stdin.getc` 之间有两个主要区别。首先，如果当前输入行为空（或者你已经读取了输入行中的所有文本），`stdin.peekc` 不会强制用户输入新的一行文本。相反，`stdin.peekc`
    会简单地返回 0 到 AL 寄存器，表示输入行中没有更多的字符。因为 #0（NUL 字符）通常是合法的数字值分隔符字符，并且行尾肯定是合法的数字输入终止方式，所以这种行为相当合适。`stdin.getc`
    和 `stdin.peekc` 的第二个区别是 `stdin.peekc` 不会消耗从输入缓冲区读取的字符。如果你连续调用 `stdin.peekc` 多次，它将始终返回相同的字符；同样，如果在
    `stdin.peekc` 之后立即调用 `stdin.getc`，`stdin.getc` 通常会返回与 `stdin.peekc` 返回的字符相同的字符（唯一的例外是行尾条件）。因此，虽然我们在使用
    `stdin.getc` 读取字符后不能将字符放回输入流，但我们可以查看输入流中的下一个字符，并根据该字符的值调整我们的逻辑。下面是一个修正后的版本：'
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the call to `stdin.peekc` in the second `while` does not consume the
    delimiter character when the expression evaluates false. Hence, the delimiter
    character will be the next character read after this algorithm finishes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二个 `while` 中对 `stdin.peekc` 的调用不会在表达式为假时消耗分隔符字符。因此，分隔符字符将在算法完成后作为下一个字符被读取。
- en: 'The only remaining comment to make about numeric input is to point out that
    the HLA Standard Library input routines allow arbitrary underscores to appear
    within a numeric string. The input routines ignore these underscore characters.
    This allows the user to input strings like FFFF_F012 and 1_023_596, which are
    a little more readable than FFFFF012 and 1023596\. Allowing underscores (or any
    other symbol you choose) within a numeric input routine is quite simple; just
    modify the second `while` loop above as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字输入，唯一需要补充的评论是指出 HLA 标准库的输入例程允许在数字字符串中插入任意下划线。输入例程会忽略这些下划线字符。这使得用户可以输入类似
    `FFFF_F012` 和 `1_023_596` 的字符串，这比 `FFFFF012` 和 `1023596` 更易读。在数字输入例程中允许下划线（或你选择的任何其他符号）是非常简单的；只需像下面这样修改第二个
    `while` 循环：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 8.1.14.6 Extended-Precision Hexadecimal Input
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.6 扩展精度十六进制输入
- en: 'As was the case for numeric output, hexadecimal input is the easiest numeric
    input routine to write. The basic algorithm for hexadecimal-string-to-numeric
    conversion is the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 和数字输出一样，十六进制输入是最简单的数字输入例程。十六进制字符串到数字的基本转换算法如下：
- en: Initialize the extended-precision value to 0.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化扩展精度值为 0。
- en: 'For each input character that is a valid hexadecimal digit, do the following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个有效的十六进制数字输入字符，执行以下操作：
- en: Convert the hexadecimal character to a value in the range 0..15 ($0..$F).
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将十六进制字符转换为 0 到 15 范围内的值（$0..$F）。
- en: If the H.O. 4 bits of the extended-precision value are nonzero, raise an exception.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果扩展精度值的高 4 位非零，则抛出异常。
- en: Multiply the current extended-precision value by 16 (i.e., shift left 4 bits).
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的扩展精度值乘以 16（即左移 4 位）。
- en: Add the converted hexadecimal digit value to the accumulator.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将转换后的十六进制数字值加到累加器中。
- en: Check the last input character to ensure it is a valid delimiter. Raise an exception
    if it is not.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查最后一个输入字符，以确保它是一个有效的分隔符。如果不是，则抛出异常。
- en: The program in [Example 8-5](ch08.html#extended-precision_hexadecimal_input-id1
    "Example 8-5. Extended-precision hexadecimal input") implements this extended-precision
    hexadecimal input routine for 128-bit values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-5](ch08.html#extended-precision_hexadecimal_input-id1 "示例 8-5. 扩展精度十六进制输入")中的程序实现了一个用于
    128 位值的扩展精度十六进制输入例程。'
- en: Example 8-5. Extended-precision hexadecimal input
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-5. 扩展精度十六进制输入
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Extending this code to handle objects that are greater than 128 bits long is
    very easy. There are only three changes necessary: You must zero out the whole
    object at the beginning of the `getb128` routine; when checking for overflow (the
    `test( $F, (type byte LocalValue[15]) );` instruction), you must test the H.O.
    4 bits of the new object you''re processing; and you must modify the code that
    multiplies `LocalValue` by 16 (via `shld`) so that it multiplies your object by
    16 (i.e., shifts it to the left 4 bits).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码扩展到处理大于 128 位的对象非常简单。只需要三个更改：你必须在 `getb128` 例程的开头将整个对象置为零；在检查溢出时（`test(
    $F, (type byte LocalValue[15]) );` 指令），你必须测试你正在处理的新对象的高 4 位；你必须修改乘法代码，该代码通过 `shld`
    将 `LocalValue` 乘以 16，使其乘以你的对象 16（即，将其向左移动 4 位）。
- en: 8.1.14.7 Extended-Precision Unsigned Decimal Input
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.7 扩展精度无符号十进制输入
- en: The algorithm for extended-precision unsigned decimal input is nearly identical
    to that for hexadecimal input. In fact, the only difference (beyond only accepting
    decimal digits) is that you multiply the extended-precision value by 10 rather
    than 16 for each input character (in general, the algorithm is the same for any
    base; just multiply the accumulating value by the input base). The code in [Example 8-6](ch08.html#extended-precision_unsigned_decimal_-016
    "Example 8-6. Extended-precision unsigned decimal input") demonstrates how to
    write a 128-bit unsigned decimal input routine.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度无符号十进制输入的算法与十六进制输入几乎相同。实际上，唯一的区别（除了只接受十进制数字之外）是你将扩展精度值乘以 10 而不是 16，针对每个输入字符（一般来说，任何进制的算法都是相同的；只是将累积值乘以输入的基数）。[示例
    8-6](ch08.html#extended-precision_unsigned_decimal_-016 "示例 8-6. 扩展精度无符号十进制输入")中的代码展示了如何编写一个
    128 位无符号十进制输入例程。
- en: Example 8-6. Extended-precision unsigned decimal input
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6. 扩展精度无符号十进制输入
- en: '[PRE54]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As for hexadecimal input, extending this decimal input to some number of bits
    beyond 128 is fairly easy. All you need do is modify the code that zeros out the
    `LocalValue` variable and the code that multiplies `LocalValue` by 10 (overflow
    checking is done in this same code, so there are only two spots in this code that
    require modification).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与十六进制输入类似，将此十进制输入扩展到超过 128 位的数量也非常简单。你只需要修改将 `LocalValue` 变量置为零的代码和将 `LocalValue`
    乘以 10 的代码（溢出检查已在此代码中完成，因此这段代码中只有两个位置需要修改）。
- en: 8.1.14.8 Extended-Precision Signed Decimal Input
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.14.8 扩展精度有符号十进制输入
- en: 'Once you have an unsigned decimal input routine, writing a signed decimal input
    routine is easy. The following algorithm describes how to accomplish this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个无符号十进制输入例程，编写一个有符号十进制输入例程就变得很容易。以下算法描述了如何实现这一点：
- en: Consume any delimiter characters at the beginning of the input stream.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入流的开头消耗任何分隔符字符。
- en: If the next input character is a minus sign, consume this character and set
    a flag noting that the number is negative.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果下一个输入字符是负号，消耗该字符并设置一个标志，表示该数字为负数。
- en: Call the unsigned decimal input routine to convert the rest of the string to
    an integer.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用无符号十进制输入例程将字符串的其余部分转换为整数。
- en: Check the return result to make sure its H.O. bit is clear. Raise the `ex.ValueOutOfRange`
    exception if the H.O. bit of the result is set.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查返回结果，确保其高位（H.O.）位清除。如果结果的高位（H.O.）位被设置，则抛出 `ex.ValueOutOfRange` 异常。
- en: If the code encountered a minus sign in step 2, negate the result.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码在步骤 2 中遇到了负号，则取结果的负值。
- en: The actual code is left as a programming exercise for the reader (or see the
    conversion routines in the HLA Standard Library for concrete examples).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实际代码留给读者作为编程练习（或者参见 HLA 标准库中的转换例程，查看具体示例）。
- en: '* * *'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[111](#CHP-8-FN-1)]) Newer C standards also provide for a `long long int`,
    which is usually a 64-bit integer.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[111](#CHP-8-FN-1)]) 更新的 C 标准还提供了 `long long int` 类型，通常是一个 64 位的整数。
- en: ^([[112](#CHP-8-FN-2)]) Windows may translate this to an `ex.IntoInstr` exception.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[112](#CHP-8-FN-2)]) Windows 可能会将此转换为 `ex.IntoInstr` 异常。
- en: ^([[113](#CHP-8-FN-3)]) Technically speaking, this isn't entirely true. It is
    possible for a device error (e.g., disk full) to occur. The likelihood of this
    is so low that we can effectively ignore this possibility.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[113](#CHP-8-FN-3)]) 从技术上讲，这并不完全正确。设备错误（例如磁盘已满）是可能发生的。虽然这种可能性非常低，我们可以有效地忽略这种可能性。
- en: ^([[114](#CHP-8-FN-4)]) The HLA Standard Library routines actually buffer up
    input lines in a string and process characters out of the string. This makes it
    easy to "peek" ahead one character when looking for a delimiter to end the input
    value. Your code can also do this; however, the code in this chapter uses a different
    approach.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[114](#CHP-8-FN-4)]) HLA标准库例程实际上会将输入行缓冲在一个字符串中，并从字符串中处理字符。这使得在寻找分隔符以结束输入值时，可以轻松地“预读”一个字符。你的代码也可以这样做；然而，本章中的代码采用了不同的方法。
- en: 8.2 Operating on Different-Size Operands
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 对不同大小操作数的运算
- en: 'Occasionally you may need to do some computation on a pair of operands that
    are not the same size. For example, you may need to add a word and a double word
    together or subtract a byte value from a word value. The solution is simple: just
    extend the smaller operand to the size of the larger operand and then do the operation
    on two similarly sized operands. For signed operands, you would sign extend the
    smaller operand to the same size as the larger operand; for unsigned values, you
    zero extend the smaller operand. This works for any operation, although the following
    examples demonstrate this for the addition operation.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要对一对不同大小的操作数进行运算。例如，你可能需要将一个字和一个双字加在一起，或者从一个字值中减去一个字节值。解决方法很简单：只需将较小的操作数扩展到较大操作数的大小，然后对两个相同大小的操作数进行运算。对于有符号操作数，你将较小的操作数符号扩展到与较大操作数相同的大小；对于无符号值，你将较小的操作数零扩展。这适用于任何操作，尽管以下示例展示了加法操作。
- en: 'To extend the smaller operand to the size of the larger operand, use a sign
    extension or zero extension operation (depending upon whether you''re adding signed
    or unsigned values). Once you''ve extended the smaller value to the size of the
    larger, the addition can proceed. Consider the following code that adds a byte
    value to a word value:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将较小的操作数扩展到较大操作数的大小，可以使用符号扩展或零扩展操作（取决于你是加法有符号值还是无符号值）。一旦将较小的值扩展到较大的大小，运算就可以继续进行。考虑以下将字节值加到字值上的代码：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In both cases, the byte variable was loaded into the AL register, extended
    to 16 bits, and then added to the word operand. This code works out really well
    if you can choose the order of the operations (for example, adding the 8-bit value
    to the 16-bit value). Sometimes, you cannot specify the order of the operations.
    Perhaps the 16-bit value is already in the AX register and you want to add an
    8-bit value to it. For unsigned addition, you could use the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，字节变量被加载到AL寄存器中，扩展到16位，然后加到字操作数上。如果你能选择操作的顺序（例如，将8位值加到16位值上），这段代码会非常有效。有时候，你无法指定操作的顺序。也许16位值已经在AX寄存器中，你想加一个8位值。对于无符号加法，可以使用以下代码：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first `add` instruction in this example adds the byte at `var1` to the L.O.
    byte of the value in the accumulator. The `adc` instruction above adds the carry
    from the addition of the L.O. bytes into the H.O. byte of the accumulator. You
    must take care to ensure that this `adc` instruction is present. If you leave
    it out, you may not get the correct result.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的第一个`add`指令将`var1`中的字节加到累加器中低字节的值上。上面的`adc`指令将低字节相加的进位加到累加器的高字节中。你必须确保这个`adc`指令存在。如果省略它，可能得不到正确的结果。
- en: 'Adding an 8-bit signed operand to a 16-bit signed value is a little more difficult.
    Unfortunately, you cannot add an immediate value (as above) to the H.O. word of
    AX. This is because the H.O. extension byte can be either $00 or $FF. If a register
    is available, the best thing to do is the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将8位有符号操作数加到16位有符号值上稍微复杂一些。不幸的是，你不能将立即数（如上所示）加到AX的高字节。这是因为高字节扩展字节可以是$00或$FF。如果有可用的寄存器，最好的做法是如下：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If an extra register is not available, you might try the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的额外寄存器，你可以尝试以下代码：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Another alternative is to store the 16-bit value in the accumulator into a
    memory location and then proceed as before:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将16位值从累加器存储到内存位置，然后像之前一样继续操作：
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All the examples above added a byte value to a word value. By zero or sign extending
    the smaller operand to the size of the larger operand, you can easily add any
    two different-size variables together.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有例子都将字节值加到了字值上。通过将较小的操作数通过零扩展或符号扩展到较大操作数的大小，您可以轻松地将任何两个不同大小的变量相加。
- en: 'As a last example, consider adding an 8-bit signed value to a quadword (64-bit)
    value:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的一个例子，考虑将一个 8 位带符号值加到一个四字（64 位）值上：
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 8.3 Decimal Arithmetic
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 十进制算术
- en: The 80x86 CPUs use the binary numbering system for their native internal representation.
    The binary numbering system is, by far, the most common numbering system in use
    in computer systems today. In the early days, however, there were computer systems
    that were based on the decimal (base 10) numbering system instead of the binary
    numbering system. Consequently, their arithmetic system was decimal based rather
    than binary. Such computer systems were very popular in systems targeted for business/commercial
    systems.^([[115](#ftn.CHP-8-FN-5)]) Although systems designers have discovered
    that binary arithmetic is almost always better than decimal arithmetic for general
    calculations, the myth still persists that decimal arithmetic is better for money
    calculations than binary arithmetic. Therefore, many software systems still specify
    the use of decimal arithmetic in their calculations (not to mention that there
    is lots of legacy code out there whose algorithms are stable only if they use
    decimal arithmetic). Therefore, despite the fact that decimal arithmetic is generally
    inferior to binary arithmetic, the need for decimal arithmetic persists.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 使用二进制数字系统作为其本地内部表示。二进制数字系统是当今计算机系统中最常见的数字系统。然而，在早期，确实有一些计算机系统是基于十进制（基数
    10）数字系统，而不是二进制数字系统。因此，它们的算术系统是基于十进制的，而不是二进制的。这类计算机系统在面向商业/商业系统的系统中曾非常流行。^([[115](#ftn.CHP-8-FN-5)])
    尽管系统设计师已经发现，二进制算术在一般计算中几乎总是优于十进制算术，但仍然存在这样的误解：十进制算术在货币计算方面比二进制算术更好。因此，许多软件系统仍然在其计算中指定使用十进制算术（更不用说，很多遗留代码的算法只有在使用十进制算术时才稳定）。因此，尽管十进制算术通常不如二进制算术，但对十进制算术的需求依然存在。
- en: Of course, the 80x86 is not a decimal computer; therefore, we have to play tricks
    in order to represent decimal numbers using the native binary format. The most
    common technique, even employed by most so-called decimal computers, is to use
    the binary-coded decimal, or BCD, representation. The BCD representation uses
    4 bits to represent the 10 possible decimal digits (see [Table 8-1](ch08s03.html#binary-coded_decimal_open_parenthesis_bc
    "Table 8-1. Binary-Coded Decimal (BCD) Representation")). The binary value of
    those 4 bits is equal to the corresponding decimal value in the range 0..9\. Of
    course, with 4 bits we can actually represent 16 different values; the BCD format
    ignores the remaining six bit combinations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，80x86 并不是一个十进制计算机；因此，我们必须采用一些技巧来使用本地二进制格式表示十进制数。最常见的技巧，甚至是大多数所谓的十进制计算机所采用的技巧，是使用二进制编码的十进制（BCD）表示法。BCD
    表示法使用 4 位来表示 10 个可能的十进制数字（见 [表 8-1](ch08s03.html#binary-coded_decimal_open_parenthesis_bc
    "表 8-1. 二进制编码十进制（BCD）表示法")）。这 4 位的二进制值等于对应的十进制值，范围是 0 到 9。当然，使用 4 位实际上可以表示 16
    个不同的值；BCD 格式忽略了其余六种位组合。
- en: Because each BCD digit requires 4 bits, we can represent a 2-digit BCD value
    with a single byte. This means that we can represent the decimal values in the
    range 0..99 using a single byte (versus 0..255 if we treat the value as an unsigned
    binary number). Clearly it takes more memory to represent the same value in BCD
    than it does to represent the same value in binary. For example, with a 32-bit
    value you can represent BCD values in the range 0..99,999,999 (eight significant
    digits). However, you can represent values in the range 0..4,294,967,295 (more
    than nine significant digits) by using binary representation.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 BCD 数字需要 4 位，因此我们可以用一个字节表示一个 2 位的 BCD 值。这意味着我们可以用一个字节表示范围在 0 到 99 之间的十进制值（如果将值当作无符号二进制数来处理，则范围是
    0 到 255）。显然，用 BCD 表示相同的值需要比用二进制表示更多的内存。例如，使用 32 位值时，您可以表示范围为 0 到 99,999,999（八位有效数字）的
    BCD 值。然而，使用二进制表示时，您可以表示范围为 0 到 4,294,967,295（超过九位有效数字）的值。
- en: Not only does the BCD format waste memory on a binary computer (because it uses
    more bits to represent a given integer value), decimal arithmetic is also slower.
    For these reasons, you should avoid the use of decimal arithmetic unless it is
    absolutely mandated for a given application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: BCD格式不仅在二进制计算机上浪费内存（因为它使用更多的位来表示给定的整数值），而且十进制算术也较慢。由于这些原因，除非某个特定应用强烈要求，否则你应避免使用十进制算术。
- en: 'Binary-coded decimal representation does offer one big advantage over binary
    representation: It is fairly simple to convert between the string representation
    of a decimal number and the BCD representation. This feature is particularly beneficial
    when working with fractional values because fixed and floating-point binary representations
    cannot exactly represent many commonly used values between 0 and 1 (e.g., 1/10).
    Therefore, BCD operations can be efficient when reading from a BCD device, doing
    a simple arithmetic operation (for example, a single addition), and then writing
    the BCD value to some other device.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制编码的十进制表示法相比二进制表示法有一个很大的优势：它非常简单地将十进制数字的字符串表示转换为BCD表示。这一特性在处理分数值时特别有用，因为定点和浮点二进制表示无法精确表示许多常用的0到1之间的值（例如，1/10）。因此，BCD运算在从BCD设备读取数据、进行简单的算术操作（例如，单次加法）后，再将BCD值写入其他设备时，可以提高效率。
- en: Table 8-1. Binary-Coded Decimal (BCD) Representation
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1. 二进制编码十进制（BCD）表示法
- en: '| BCD Representation | Decimal Equivalent |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| BCD表示 | 十进制等价 |'
- en: '| --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0000 | 0 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 |'
- en: '| 0001 | 1 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 |'
- en: '| 0010 | 2 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 |'
- en: '| 0011 | 3 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 |'
- en: '| 0100 | 4 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 |'
- en: '| 0101 | 5 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 |'
- en: '| 0110 | 6 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 |'
- en: '| 0111 | 7 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 |'
- en: '| 1000 | 8 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8 |'
- en: '| 1001 | 9 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 9 |'
- en: '| 1010 | Illegal |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | 非法 |'
- en: '| 1011 | Illegal |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | 非法 |'
- en: '| 1100 | Illegal |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | 非法 |'
- en: '| 1101 | Illegal |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | 非法 |'
- en: '| 1110 | Illegal |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | 非法 |'
- en: '| 1111 | Illegal |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | 非法 |'
- en: 8.3.1 Literal BCD Constants
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.1 字面BCD常量
- en: 'HLA does not provide, nor do you need, a special literal BCD constant. Because
    BCD is just a special form of hexadecimal notation that does not allow the values
    $A..$F, you can easily create BCD constants using HLA''s hexadecimal notation.
    Of course, you must take care not to include the symbols A..F in a BCD constant
    because they are illegal BCD values. As an example, consider the following `mov`
    instruction that copies the BCD value 99 into the AL register:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: HLA并不提供，也不需要，特殊的字面BCD常量。因为BCD只是十六进制表示的一种特殊形式，它不允许使用$A..$F的值，所以你可以轻松地使用HLA的十六进制表示法来创建BCD常量。当然，你必须注意不要在BCD常量中包含A..F符号，因为它们是非法的BCD值。举个例子，考虑以下`mov`指令，它将BCD值99复制到AL寄存器中：
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The important thing to keep in mind is that you must not use HLA literal decimal
    constants for BCD values. That is, `mov( 95, al );` does not load the BCD representation
    for 95 into the AL register. Instead, it loads $5F into AL, and that's an illegal
    BCD value. Any computations you attempt with illegal BCD values will produce garbage
    results. Always remember that, even though it seems counterintuitive, you use
    hexadecimal literal constants to represent literal BCD values.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的重要一点是，你不能使用HLA字面十进制常量来表示BCD值。也就是说，`mov( 95, al );`并不会将95的BCD表示加载到AL寄存器中。相反，它会将$5F加载到AL中，而这就是一个非法的BCD值。你尝试用非法BCD值进行任何计算都会得到垃圾结果。请始终记住，尽管这似乎违反直觉，但你应该使用十六进制字面常量来表示字面BCD值。
- en: 8.3.2 The 80x86 daa and das Instructions
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.2 80x86的daa和das指令
- en: 'The integer unit on the 80x86 does not directly support BCD arithmetic. Instead,
    the 80x86 requires that you perform the computation using binary arithmetic and
    use some auxiliary instructions to convert the binary result to BCD. To support
    packed BCD addition and subtraction with two digits per byte, the 80x86 provides
    two instructions: decimal adjust after addition (`daa`) and decimal adjust after
    subtraction (`das`). You would execute these two instructions immediately after
    an `add`/`adc` or `sub`/`sbb` instruction to correct the binary result in the
    AL register.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86的整数单元并不直接支持BCD算术。相反，80x86要求你使用二进制算术进行计算，并使用一些辅助指令将二进制结果转换为BCD。为了支持每字节两个数字的压缩BCD加法和减法，80x86提供了两个指令：加法后的十进制调整（`daa`）和减法后的十进制调整（`das`）。你需要在执行完`add`/`adc`或`sub`/`sbb`指令后立即执行这两个指令，以修正AL寄存器中的二进制结果。
- en: 'To add a pair of two-digit (i.e., single-byte) BCD values together, you would
    use the following sequence:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一对两位数（即单字节）BCD值相加，你需要使用以下序列：
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The first two instructions above add the 2-byte values together using standard
    binary arithmetic. This may not produce a correct BCD result. For example, if
    `bcd_1` contains $9 and `bcd_2` contains $1, then the first two instructions above
    will produce the binary sum $A instead of the correct BCD result $10\. The `daa`
    instruction corrects this invalid result. It checks to see if there was a carry
    out of the low-order BCD digit and adjusts the value (by adding 6 to it) if there
    was an overflow. After adjusting for overflow out of the L.O. digit, the `daa`
    instruction repeats this process for the H.O. digit. `daa` sets the carry flag
    if there was a (decimal) carry out of the H.O. digit of the operation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 上述前两条指令通过标准二进制算术将两个字节的值相加。这可能不会产生正确的BCD结果。例如，如果`bcd_1`包含$9而`bcd_2`包含$1，那么上述前两条指令将产生二进制和$A，而不是正确的BCD结果$10。`daa`指令会纠正这个无效的结果。它检查是否有低位BCD数字的进位，如果有溢出，就通过加6来调整值。调整完低位溢出后，`daa`指令会对高位BCD数字重复这个过程。如果高位BCD数字发生了（十进制）进位，`daa`会设置进位标志。
- en: 'The `daa` instruction operates only on the AL register. It will not adjust
    (properly) for a decimal addition if you attempt to add a value to AX, EAX, or
    any other register. Specifically note that `daa` limits you to adding two decimal
    digits (a single byte) at a time. This means that for the purposes of computing
    decimal sums, you have to treat the 80x86 as though it were an 8-bit processor,
    capable of adding only 8 bits at a time. If you wish to add more than two digits
    together, you must treat this as a multiprecision operation. For example, to add
    four decimal digits together (using `daa`), you must execute a sequence like the
    following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`daa`指令仅对AL寄存器操作。如果尝试将值加到AX、EAX或任何其他寄存器，它将不会正确调整十进制加法。特别需要注意的是，`daa`限制你每次只能加两个十进制数字（一字节）。这意味着，在计算十进制和时，你必须将80x86视为8位处理器，每次只能加8位。如果你希望将超过两个数字相加，必须将其视为多精度运算。例如，要将四个十进制数字相加（使用`daa`），你必须执行如下的操作序列：'
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Because a binary addition of two words (producing a word result) requires only
    three instructions, you can see that decimal arithmetic is expensive.^([[116](#ftn.CHP-8-FN-6)])
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个字的二进制加法（产生一个字的结果）只需要三条指令，所以可以看出十进制算术是昂贵的。^([[116](#ftn.CHP-8-FN-6)])
- en: 'The `das` (decimal adjust after subtraction) instruction adjusts the decimal
    result after a binary `sub` or `sbb` instruction. You use it the same way you
    use the `daa` instruction. Here are some examples:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`das`（减法后调整十进制）指令会在执行二进制`sub`或`sbb`指令后调整十进制结果。使用它的方式与使用`daa`指令相同。以下是一些例子：'
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Unfortunately, the 80x86 provides support only for addition and subtraction
    of packed BCD values using the `daa` and `das` instructions. It does not support
    multiplication, division, or any other arithmetic operations. Because decimal
    arithmetic using these instructions is so limited, you'll rarely see any programs
    use these instructions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，80x86仅支持使用`daa`和`das`指令对压缩BCD值进行加法和减法。它不支持乘法、除法或任何其他算术运算。由于使用这些指令进行十进制算术的功能如此有限，因此你很少会看到程序使用这些指令。
- en: 8.3.3 The 80x86 aaa, aas, aam, and aad Instructions
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.3 80x86的aaa、aas、aam和aad指令
- en: In addition to the packed decimal instructions (`daa` and `das`), the 80x86
    CPUs support four unpacked decimal adjustment instructions. Unpacked decimal numbers
    store only one digit per 8-bit byte. As you can imagine, this data representation
    scheme wastes a considerable amount of memory. However, the unpacked decimal adjustment
    instructions support the multiplication and division operations, so they are marginally
    more useful.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 除了压缩十进制指令（`daa`和`das`）外，80x86 CPU还支持四个非压缩十进制调整指令。非压缩十进制数每个8位字节仅存储一个数字。如你所见，这种数据表示方式会浪费相当多的内存。然而，非压缩十进制调整指令支持乘法和除法操作，因此它们稍微更有用一些。
- en: The instruction mnemonics `aaa`, `aas`, `aam`, and `aad` stand for "ASCII adjust
    for Addition, Subtraction, Multiplication, and Division" (respectively). Despite
    their names, these instructions do not process ASCII characters. Instead, they
    support an unpacked decimal value in AL whose L.O. 4 bits contain the decimal
    digit and the H.O. 4 bits contain 0\. Note, though, that you can easily convert
    an ASCII decimal digit character to an unpacked decimal number by simply `and`ing
    AL with the value $0F.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 指令助记符`aaa`、`aas`、`aam`和`aad`分别代表“ASCII加法、减法、乘法和除法调整”（即“ASCII adjust for Addition,
    Subtraction, Multiplication, and Division”）。尽管它们的名字如此，这些指令并不处理ASCII字符。相反，它们支持AL寄存器中的非打包十进制值，其中低4位包含十进制数字，高4位包含0。需要注意的是，你可以通过将AL与$0F进行`and`操作，轻松地将ASCII十进制数字字符转换为非打包十进制数。
- en: The `aaa` instruction adjusts the result of a binary addition of two unpacked
    decimal numbers. If the addition of those two values exceeds 10, then `aaa` will
    subtract 10 from AL and increment AH by 1 (as well as set the carry flag). `aaa`
    assumes that the two values you add together are legal unpacked decimal values.
    Other than the fact that `aaa` works with only one decimal digit at a time (rather
    than two), you use it the same way you use the `daa` instruction. Of course, if
    you need to add together a string of decimal digits, using unpacked decimal arithmetic
    will require twice as many operations and, therefore, twice the execution time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`aaa`指令用于调整两个非打包十进制数字相加后的二进制结果。如果这两个值相加超过了10，`aaa`会将10从AL中减去，并将AH加1（同时设置进位标志）。`aaa`假设你加在一起的两个值是合法的非打包十进制值。除了`aaa`一次只处理一个十进制数字（而不是两个）外，你使用它的方式与使用`daa`指令的方式相同。当然，如果你需要将一串十进制数字相加，使用非打包十进制算术将需要更多的操作次数，从而需要更多的执行时间。'
- en: You use the `aas` instruction the same way you use the `das` instruction except,
    of course, it operates on unpacked decimal values rather than packed decimal values.
    As for `aaa`, `aas` will require twice the number of operations to add the same
    number of decimal digits as the `das` instruction. If you're wondering why anyone
    would want to use the `aaa` or `aas` instruction, keep in mind that the unpacked
    format supports multiplication and division, while the packed format does not.
    Since packing and unpacking the data is usually more expensive than working on
    the data a digit at a time, the `aaa` and `aas` instructions are more efficient
    if you have to work with unpacked data (because of the need for multiplication
    and division).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`aas`指令的方式与使用`das`指令的方式相同，当然，它是作用于非打包十进制值，而不是打包十进制值。与`aaa`一样，`aas`在加相同数量的十进制数字时，将需要两倍的操作次数。如果你在想为什么有人会使用`aaa`或`aas`指令，请记住，非打包格式支持乘法和除法，而打包格式则不支持。由于数据的打包和解包通常比逐个数字操作数据要昂贵，所以如果你需要处理非打包数据（因为需要乘法和除法），`aaa`和`aas`指令将更高效。
- en: The `aam` instruction modifies the result in the AX register to produce a correct
    unpacked decimal result after multiplying two unpacked decimal digits using the
    `mul` instruction. Because the largest product you may obtain is 81 (9 * 9 produces
    the largest possible product of two single-digit values), the result will fit
    in the AL register. `aam` unpacks the binary result by dividing it by 10, leaving
    the quotient (H.O. digit) in AH and the remainder (L.O. digit) in AL. Note that
    `aam` leaves the quotient and remainder in different registers than a standard
    8-bit `div` operation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`aam`指令修改AX寄存器中的结果，以在使用`mul`指令将两个非打包十进制数字相乘后，生成正确的非打包十进制结果。因为你得到的最大乘积是81（9
    * 9是两个单一数字的最大乘积），结果将适合存储在AL寄存器中。`aam`通过将结果除以10来解包二进制结果，将商（高位数字）存放在AH寄存器中，余数（低位数字）存放在AL寄存器中。需要注意的是，`aam`将商和余数存放在不同的寄存器中，而标准的8位`div`操作则不会这样。'
- en: Technically, you do not have to use the `aam` instruction for BCD multiplication
    operations. `aam` simply divides AL by 10 and leaves the quotient and remainder
    in AH and AL (respectively). If you have need of this particular operation, you
    may use the `aam` instruction for this purpose (indeed, that's about the only
    use for `aam` in most programs these days).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，进行BCD乘法操作时，你不一定需要使用`aam`指令。`aam`指令只是将AL寄存器中的值除以10，并将商和余数分别存储在AH和AL中。如果你需要执行这个特定操作，可以使用`aam`指令（事实上，现在大多数程序中，`aam`的用途几乎仅限于此）。
- en: If you need to multiply more than two unpacked decimal digits together using
    `mul` and `aam`, you will need to devise a multiprecision multiplication that
    uses the manual algorithm from earlier in this chapter. Since that is a lot of
    work, this section will not present that algorithm. If you need a multiprecision
    decimal multiplication, see [8.3.4 Packed Decimal Arithmetic Using the FPU](ch08s03.html#packed_decimal_arithmetic_using_the_fpu
    "8.3.4 Packed Decimal Arithmetic Using the FPU"); it presents a better solution.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用`mul`和`aam`将两个以上的解包十进制数字相乘，你需要设计一种多精度乘法，使用本章前面介绍的手动算法。由于这需要大量的工作，本节将不会介绍该算法。如果你需要多精度十进制乘法，请参阅[8.3.4
    使用FPU的打包十进制算术](ch08s03.html#packed_decimal_arithmetic_using_the_fpu "8.3.4 使用FPU的打包十进制算术")；它提供了一个更好的解决方案。
- en: 'The `aad` instruction, as you might expect, adjusts a value for unpacked decimal
    division. The unusual thing about this instruction is that you must execute it
    before a `div` operation. It assumes that AL contains the least-significant digit
    of a two-digit value and AH contains the most-significant digit of a two-digit
    unpacked decimal value. It converts these two numbers to binary so that a standard
    `div` instruction will produce the correct unpacked decimal result. Like `aam`,
    this instruction is nearly useless for its intended purpose because extended-precision
    operations (for example, division of more than one or two digits) are extremely
    inefficient. However, this instruction is actually quite useful in its own right.
    It computes AX = AH * 10 + AL (assuming that AH and AL contain single-digit decimal
    values). You can use this instruction to convert a two-character string containing
    the ASCII representation of a value in the range 0..99 to a binary value. For
    example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`aad` 指令，正如你可能预期的那样，调整解包十进制除法的值。这个指令的不同之处在于，你必须在执行 `div` 操作之前先执行它。它假定 AL 包含一个两位值的最低有效数字，而
    AH 包含一个两位解包十进制值的最高有效数字。它将这两个数字转换为二进制，以便标准的 `div` 指令能够产生正确的解包十进制结果。像 `aam` 一样，这条指令几乎对它的预期用途没什么作用，因为扩展精度操作（例如，超过一位或两位数字的除法）极为低效。然而，这条指令本身实际上非常有用。它计算
    AX = AH * 10 + AL（假设 AH 和 AL 包含单个十进制数字）。你可以使用这条指令将包含值的 ASCII 表示的两字符字符串（范围为 0..99）转换为二进制值。例如：'
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The decimal and ASCII adjust instructions provide an extremely poor implementation
    of decimal arithmetic. To better support decimal arithmetic on 80x86 systems,
    Intel incorporated decimal operations into the FPU. The next section discusses
    how to use the FPU for this purpose. However, even with FPU support, decimal arithmetic
    is inefficient and less precise than binary arithmetic. Therefore, you should
    consider carefully if you really need to use decimal arithmetic before incorporating
    it into your programs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制和 ASCII 调整指令提供的十进制算术实现非常差。为了更好地支持 80x86 系统上的十进制算术，Intel 将十进制操作集成到 FPU 中。下一节将讨论如何使用
    FPU 来实现这一目的。然而，即使有 FPU 支持，十进制算术依然效率低下，且精度不如二进制算术。因此，在将其集成到程序中之前，你应该仔细考虑是否真的需要使用十进制算术。
- en: 8.3.4 Packed Decimal Arithmetic Using the FPU
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.4 使用FPU的打包十进制算术
- en: To improve the performance of applications that rely on decimal arithmetic,
    Intel incorporated support for decimal arithmetic directly into the FPU. Unlike
    the packed and unpacked decimal formats of the previous sections, the FPU easily
    supports values with up to 18 decimal digits of precision, all at FPU speeds.
    Furthermore, all the arithmetic capabilities of the FPU (for example, transcendental
    operations) are available in addition to addition, subtraction, multiplication,
    and division. Assuming you can live with only 18 digits of precision and a few
    other restrictions, decimal arithmetic on the FPU is the right way to go if you
    must use decimal arithmetic in your programs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高依赖十进制算术的应用程序性能，Intel 将十进制算术直接集成到 FPU 中。与前面章节中的打包和解包十进制格式不同，FPU 可以轻松支持最多
    18 位十进制精度的值，且全部以 FPU 的速度进行运算。此外，FPU 的所有算术功能（例如，超越运算）都可以使用，除了加法、减法、乘法和除法之外。假设你能够接受只有
    18 位精度和一些其他限制，FPU 上的十进制算术是你在程序中必须使用十进制算术时的正确选择。
- en: The first fact you must note when using the FPU is that it doesn't really support
    decimal arithmetic. Instead, the FPU provides two instructions, `fbld` and `fbstp`,
    that convert between packed decimal and binary floating-point formats when moving
    data to and from the FPU. The `fbld` (float/BCD load) instruction loads an 80-bit
    packed BCD value unto the top of the FPU stack after converting that BCD value
    to the IEEE binary floating-point format. Likewise, the `fbstp` (float/BCD store
    and pop) instruction pops the floating-point value off the top of stack, converts
    it to a packed BCD value, and stores the BCD value into the destination memory
    location.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you load a packed BCD value into the FPU, it is no longer BCD. It''s just
    a floating-point value. This presents the first restriction on the use of the
    FPU as a decimal integer processor: Calculations are done using binary arithmetic.
    If you have an algorithm that absolutely positively depends on the use of decimal
    arithmetic, it may fail if you use the FPU to implement it.^([[117](#ftn.CHP-8-FN-7)])'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'The second limitation is that the FPU supports only one BCD data type: a 10-byte
    18-digit packed decimal value. It will not support smaller values, nor will it
    support larger values. Since 18 digits are usually sufficient and memory is cheap,
    this isn''t a big restriction.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: A third consideration is that the conversion between packed BCD and the floating-point
    format is not a cheap operation. The `fbld` and `fbstp` instructions can be quite
    slow (more than two orders of magnitude slower than `fld` and `fstp`, for example).
    Therefore, these instructions can be costly if you're doing simple additions or
    subtractions; the cost of conversion far outweighs the time spent adding the values
    a byte at a time using the `daa` and `das` instructions (multiplication and division,
    however, are going to be faster on the FPU).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the FPU's packed decimal format supports only 18 digits.
    After all, with 10 bytes it should be possible to represent 20 BCD digits. As
    it turns out, the FPU's packed decimal format uses the first 9 bytes to hold the
    packed BCD value in a standard packed decimal format (the first byte contains
    the two L.O. digits and the ninth byte holds the two H.O. digits). The H.O. bit
    of the tenth byte holds the sign bit, and the FPU ignores the remaining bits in
    the tenth byte. If you're wondering why Intel didn't squeeze in one more digit
    (that is, use the L.O. 4 bits of the tenth byte to allow for 19 digits of precision),
    just keep in mind that doing so would create some possible BCD values that the
    FPU could not exactly represent in the native floating-point format. Hence, you
    have the limitation of 18 digits.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The FPU uses a one's complement notation for negative BCD values. That is, the
    sign bit contains a 1 if the number is negative or 0 and it contains a 0 if the
    number is positive or 0 (like the binary one's complement format, there are two
    distinct representations for 0).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: HLA's `tbyte` type is the standard data type you would use to define packed
    BCD variables. The `fbld` and `fbstp` instructions require a `tbyte` operand (which
    you can initialize with a hexadecimal/BCD value).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Because the FPU converts packed decimal values to the internal floating-point
    format, you can mix packed decimal, floating point, and (binary) integer formats
    in the same calculation. The program in [Example 8-7](ch08s03.html#mixed-mode_fpu_arithmetic
    "Example 8-7. Mixed-mode FPU arithmetic") demonstrates how you might achieve this.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7. Mixed-mode FPU arithmetic
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The FPU treats packed decimal values as integer values. Therefore, if your calculations
    produce fractional results, the `fbstp` instruction will round the result according
    to the current FPU rounding mode. If you need to work with fractional values,
    you need to stick with floating-point results.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: ^([[115](#CHP-8-FN-5)]) In fact, until the release of the IBM 360 in the mid-1960s,
    most scientific computer systems were binary based, whereas most commercial/business
    systems were decimal based. IBM pushed its system\360 as a single-purpose solution
    for both business and scientific applications. Indeed, the model designation (360)
    was derived from the 360 degrees on a compass so as to suggest that the system\360
    was suitable for computations "at all points of the compass" (i.e., business and
    scientific).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: ^([[116](#CHP-8-FN-6)]) You'll also soon see that it's rare to find decimal
    arithmetic done this way. So it hardly matters.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: ^([[117](#CHP-8-FN-7)]) An example of such an algorithm might be a multiplication
    by 10 by shifting the number one digit to the left. However, such operations are
    not possible within the FPU itself, so algorithms that misbehave inside the FPU
    are actually quite rare.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Tables
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *table* has different meanings to different programmers. To most assembly
    language programmers, a table is nothing more than an array that is initialized
    with some data. The assembly language programmer often uses tables to compute
    complex or otherwise slow functions. Many very-high-level languages (for example,
    SNOBOL4 and Icon) directly support a `table` data type. Tables in these languages
    are essentially associative arrays whose elements you can access with a noninteger
    index (for example, `floating point`, `string`, or any other data type). HLA provides
    a `table` module that lets you index an array using a string. However, in this
    chapter we will adopt the assembly language programmer's view of tables.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'A table is an array containing initialized values that do not change during
    the execution of the program. In assembly language, you can use tables for a variety
    of purposes: computing functions, controlling program flow, or simply looking
    things up. In general, tables provide a fast mechanism for performing some operation
    at the expense of some space in your program (the extra space holds the tabular
    data). In the following sections we''ll explore some of the many possible uses
    of tables in an assembly language program.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Note that because tables typically contain initialized data that does not change
    during program execution, the `readonly` section is a good place to put your table
    objects.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Function Computation via Table Lookup
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tables can do all kinds of things in assembly language. In high-level languages
    like Pascal, it''s easy to create a formula that computes some value. A simple-looking
    high-level-language arithmetic expression can be equivalent to a considerable
    amount of 80x86 assembly language code and, therefore, could be expensive to compute.
    Assembly language programmers often precompute many values and use a table lookup
    of those values to speed up their programs. This has the advantage of being easier,
    and it''s often more efficient as well. Consider the following Pascal statement:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This Pascal `if` statement converts the `character` variable''s value from
    lowercase to uppercase if *`character`* is in the range `a..z`. The HLA code that
    does the same thing follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that HLA's high-level `if` statement translates into four machine instructions
    in this particular example. Hence, this code requires a total of seven machine
    instructions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Had you buried this code in a nested loop, you''d be hard pressed to reduce
    the size of this code without using a table lookup. Using a table lookup, however,
    allows you to reduce this sequence of instructions to just four instructions:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You''re probably wondering how this code works and asking, "What is this new
    instruction, `xlat`?" The `xlat`, or translate, instruction does the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: That is, it uses the current value of the AL register as an index into the array
    whose base address is found in EBX. It fetches the byte at that index in the array
    and copies that byte into the AL register. Intel calls this instruction *translate*
    because programmers typically use it to translate characters from one form to
    another using a lookup table. That's exactly how we are using it here.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, `CnvrtLower` is a 256-byte table that contains the
    values 0..$60 at indices 0..$60, $41..$5A at indices $61..$7A, and $7B..$FF at
    indices $7Bh..0FF. Therefore, if AL contains a value in the range $0..$60, the
    `xlat` instruction returns the value $0..$60, effectively leaving AL unchanged.
    However, if AL contains a value in the range $61..$7A (the ASCII codes for a..z),
    then the `xlat` instruction replaces the value in AL with a value in the range
    $41..$5A. The values $41..$5A just happen to be the ASCII codes for A..Z. Therefore,
    if AL originally contains a lowercase character ($61..$7A), the `xlat` instruction
    replaces the value in AL with a corresponding value in the range $61..$7A, effectively
    converting the original lowercase character ($61..$7A) to an uppercase character
    ($41..$5A). The remaining entries in the table, like entries $0..$60, simply contain
    the index into the table of their particular element. Therefore, if AL originally
    contains a value in the range $7A..$FF, the `xlat` instruction will return the
    corresponding table entry that also contains $7A..$FF.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'As the complexity of the function increases, the performance benefits of the
    table lookup method increase dramatically. While you would almost never use a
    lookup table to convert lowercase to uppercase, consider what happens if you want
    to swap cases, for example, via computation:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `if` and `elseif` statements generate 4 and 5 actual machine instructions,
    respectively, so this code is equivalent to 13 actual machine instructions.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'The table lookup code to compute this same function is:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, when using a table lookup to compute a function, only the table
    changes; the code remains the same.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Table lookups suffer from one major problem—functions computed via table lookup
    have a limited domain. The domain of a function is the set of possible input values
    (parameters) it will accept. For example, the uppercase/lowercase conversion functions
    above have the 256-character ASCII character set as their domain.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: A function such as `SIN` or `COS` accepts the set of real numbers as possible
    input values. Clearly the domain for `SIN` and `COS` is much larger than for the
    upper/lowercase conversion function. If you are going to do computations via table
    lookup, you must limit the domain of a function to a small set. This is because
    each element in the domain of a function requires an entry in the lookup table.
    You won't find it very practical to implement a function via table lookup whose
    domain is the set of real numbers.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Most lookup tables are quite small, usually 10 to 256 entries. Rarely do lookup
    tables grow beyond 1,000 entries. Most programmers don't have the patience to
    create (and verify the correctness) of a 1,000-entry table.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of functions based on lookup tables is that the elements
    in the domain of the function must be fairly contiguous. Table lookups take the
    input value for a function, use this input value as an index into the table, and
    return the value at that entry in the table. If you do not pass a function any
    values other than 0, 100, 1,000, and 10,000, it would seem an ideal candidate
    for implementation via table lookup; its domain consists of only four items. However,
    the table would actually require 10,001 different elements due to the range of
    the input values. Therefore, you cannot efficiently create such a function via
    a table lookup. Throughout this section on tables, we'll assume that the domain
    of the function is a fairly contiguous set of values.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The best functions you can implement via table lookups are those whose domain
    and range are always 0..255 (or some subset of this range). You can efficiently
    implement such functions on the 80x86 via the `xlat` instruction. The uppercase/lowercase
    conversion routines presented earlier are good examples of such a function. Any
    function in this class (those whose domain and range take on the values 0..255)
    can be computed using the same two instructions: `lea( table, ebx );` and `xlat();`.
    The only thing that ever changes is the lookup table.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot (conveniently) use the `xlat` instruction to compute a function
    value once the range or domain of the function takes on values outside 0..255\.
    There are three situations to consider:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The domain is outside 0..255 but the range is within 0..255.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain is inside 0..255 but the range is outside 0..255.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the domain and range of the function take on values outside 0..255.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will consider each of these cases separately.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: If the domain of a function is outside 0..255, but the range of the function
    falls within this set of values, our lookup table will require more than 256 entries,
    but we can represent each entry with a single byte. Therefore, the lookup table
    can be an array of bytes. Other than those lookups that can use the `xlat` instruction,
    functions falling into this class are the most efficient. The following Pascal
    function invocation
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: where `Func` is
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'is easily converted to the following HLA code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This code loads the function parameter into `ebx`, uses this value (in the range
    0..??) as an index into the `FuncTable` table, fetches the byte at that location,
    and stores the result into `B`. Obviously, the table must contain a valid entry
    for each possible value of `X`. For example, suppose you wanted to map a cursor
    position on the video screen in the range 0..1,999 (there are 2,000 character
    positions on an 80×25 video display) to its `X` or `Y` coordinate on the screen.
    You could easily compute the `X` coordinate via the function
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: and the `Y` coordinate with the formula
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '(where `Posn` is the cursor position on the screen). This can be easily computed
    using the 80x86 code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'However, the `div` instruction on the 80x86 is very slow. If you need to do
    this computation for every character you write to the screen, you will seriously
    degrade the speed of your video display code. The following code, which realizes
    these two functions via table lookup, may improve the performance of your code
    considerably:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If the domain of a function is within 0..255 but the range is outside this set,
    the lookup table will contain 256 or fewer entries, but each entry will require
    2 or more bytes. If both the range and domains of the function are outside 0..255,
    each entry will require 2 or more bytes and the table will contain more than 256
    entries.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from the chapter on arrays that the formula for indexing into a single-dimensional
    array (of which a `table` is a special case) is:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If elements in the range of the function require 2 bytes, then you must multiply
    the index by 2 before indexing into the table. Likewise, if each entry requires
    3, 4, or more bytes, the index must be multiplied by the size of each table entry
    before being used as an index into the table. For example, suppose you have a
    function, `F(x)`, defined by the following (pseudo) Pascal declaration:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can easily create this function using the following 80x86 code (and, of
    course, the appropriate table named `F`):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Any function whose domain is small and mostly contiguous is a good candidate
    for computation via table lookup. In some cases, noncontiguous domains are acceptable
    as well, as long as the domain can be coerced into an appropriate set of values.
    Such operations are called *conditioning* and are the subject of the next section.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.2 Domain Conditioning
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Domain conditioning is taking a set of values in the domain of a function and
    massaging them so that they are more acceptable as inputs to that function. Consider
    the following function:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![8.4.2 Domain Conditioning](tagoreillycom20100401nostarchimages578057.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: This says that the (computer) function `sin(x)` is equivalent to the (mathematical)
    function sin *x* where
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![8.4.2 Domain Conditioning](tagoreillycom20100401nostarchimages578059.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
- en: As we all know, sine is a circular function, which will accept any real valued
    input. The formula used to compute sine, however, accepts only a small set of
    these values.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'This range limitation doesn''t present any real problems; by simply computing
    `sin(X mod (2*pi))` we can compute the sine of any input value. Modifying an input
    value so that we can easily compute a function is called *conditioning the input*.
    In the example above we computed `X mod 2*pi` and used the result as the input
    to the `sin` function. This truncates `X` to the domain `sin` needs without affecting
    the result. We can apply input conditioning to table lookups as well. In fact,
    scaling the index to handle word entries is a form of input conditioning. Consider
    the following Pascal function:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This function computes some value for `x` in the range 0..4 and it returns
    0 if `x` is outside this range. Since `x` can take on 65,536 different values
    (being a 16-bit word), creating a table containing 65,536 words where only the
    first five entries are nonzero seems to be quite wasteful. However, we can still
    compute this function using a table lookup if we use input conditioning. The following
    assembly language code presents this principle:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This code checks to see if `x` is outside the range 0..4\. If so, it manually
    sets `AX` to 0; otherwise it looks up the function value through the `val` table.
    With input conditioning, you can implement several functions that would otherwise
    be impractical to do via table lookup.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.3 Generating Tables
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One big problem with using table lookups is creating the table in the first
    place. This is particularly true if there is a large number of entries in the
    table. Figuring out the data to place in the table, then laboriously entering
    the data, and, finally, checking that data to make sure it is valid is a very
    time-consuming and boring process. For many tables, there is no way around this
    process. For other tables, there is a better way—using the computer to generate
    the table for you. An example is probably the best way to describe this. Consider
    the following modification to the sine function:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '![8.4.3 Generating Tables](tagoreillycom20100401nostarchimages578061.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
- en: 'This states that *x* is an integer in the range 0..359 and *r* must be an integer.
    The computer can easily compute this with the following code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note that integer multiplication and division are not associative. You cannot
    remove the multiplication by 1,000 and the division by 1,000 because they appear
    to cancel one another out. Furthermore, this code must compute this function in
    exactly this order. All that we need to complete this function is a table containing
    360 different values corresponding to the sine of the angle (in degrees) times
    1,000\. Entering such a table into an assembly language program containing such
    values is extremely boring and you'd probably make several mistakes entering and
    verifying this data. However, you can have the program generate this table for
    you. Consider the HLA program in [Example 8-8](ch08s04.html#an_hla_program_that_generates_a_table_of
    "Example 8-8. An HLA program that generates a table of sines").
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8. An HLA program that generates a table of sines
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The program above produces the following output (truncated for brevity):'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Obviously it's much easier to write the HLA program that generated this data
    than to enter (and verify) this data by hand. Of course, you don't even have to
    write the table-generation program in HLA. If you prefer, you might find it easier
    to write the program in Pascal/Delphi, C/C++, or some other high-level language.
    Because the program will only execute once, the performance of the table-generation
    program is not an issue. If it's easier to write the table-generation program
    in a high-level language, by all means do so. Note also that HLA has a built-in
    interpreter that allows you to easily create tables without having to use an external
    program. For more details, see [Chapter 9](ch09.html "Chapter 9. MACROS AND THE
    HLA COMPILE-TIME LANGUAGE").
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Once you run your table-generation program, all that remains to be done is to
    cut and paste the table from the file (*sines.hla* in this example) into the program
    that will actually use the table.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.4 Table Lookup Performance
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days of PCs, table lookups were a preferred way to do high-performance
    computations. However, as the speed of new CPUs vastly outpaces the speed of memory,
    the advantages of lookup tables have been waning. Today, it is not uncommon for
    a CPU to be 10 to 100 times faster than main memory. As a result, using a table
    lookup may not be faster than doing the same calculation with machine instructions.
    So it's worthwhile to briefly discuss when table lookups offer a big advantage.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Although the CPU is much faster than main memory, the on-chip CPU cache memory
    subsystems operate at near CPU speeds. Therefore, table lookups can be cost effective
    if your table resides in cache memory on the CPU. This means that the way to get
    good performance using table lookups is to use small tables (because there's only
    so much room on the cache) and use tables whose entries you reference frequently
    (so the tables stay in the cache). See *Write Great Code, Volume 1* (No Starch
    Press) or the electronic version of *The Art of Assembly Language* at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/) for details concerning
    the operation of cache memory and how you can optimize your use of cache memory.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 For More Information
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA Standard Library reference manual contains lots of information about
    the HLA Standard Library's extended-precision arithmetic capabilities. You'll
    also want to check out the source code for several of the HLA Standard Library
    routines to see how to do various extended-precision operations (that properly
    set the flags once the computation is complete). The HLA Standard Library source
    code also covers the extended-precision I/O operations that do not appear in this
    chapter.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Donald Knuth''s *The Art of Computer Programming*, *Volume Two: Seminumerical
    Algorithms* contains a lot of useful information about decimal arithmetic and
    extended-precision arithmetic, though that text is generic and doesn''t describe
    how to do this in x86 assembly language.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
