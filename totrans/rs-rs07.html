<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="101" id="Page_101"/>7</span><br/>
<span class="ChapterTitle">Macros</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<p class="ChapterIntro">Macros are, in essence, a tool for making the compiler write code for you. You give the compiler a formula for generating code given some input parameters, and the compiler replaces every invocation of the macro with the result of running through the formula. You can think of macros as automatic code substitution where you get to define the rules for the substitution.</p>
<p>Rust’s macros come in many different shapes and sizes to make it easy to implement many different forms of code generation. The two primary types are <em>declarative</em> macros and <em>procedural</em> macros, and we will explore both of them in this chapter. We’ll also look at some of the ways macros can come in handy in your everyday coding and some of the pitfalls that arise with more advanced use.  </p>
<p>Programmers coming from C-based languages may be used to the unholy land of C and C++ where you can use <code>#define</code> to change each <code>true</code> to <code>false</code>, or to remove all occurrences of the <code>else</code> keyword. If that’s the case for <span epub:type="pagebreak" title="102" id="Page_102"/>you, you’ll need to disassociate macros from a feeling of doing something “bad.” Macros in Rust are far from the Wild West of C macros. They follow (mostly) well-defined rules and are fairly misuse-resistant.</p>
<h2 id="h1--0001">Declarative Macros</h2>
<p class="BodyFirst">Declarative macros are those defined using the <code>macro_rules!</code> syntax, which lets you conveniently define function-like macros without having to resort to writing a dedicated crate for the purpose (as you do with procedural macros). Once you’ve defined a declarative macro, you can invoke it using the name of the macro followed by an exclamation mark. I like to think of this kind of macro as a sort of compiler-assisted search and replace: it does the job for many regular, well-structured transformation tasks, and for eliminating repetitive boilerplate. In your experience with Rust up until this point, most of the macros you have recognized as macros are likely to have been declarative macros. Note, however, that not all function-like macros are declarative macros; <code>macro_rules!</code> itself is one example of this, and <code>format_args!</code> is another. The <code>!</code> suffix merely indicates to the compiler that the macro invocation will be replaced with different source code at compile time.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Since Rust’s parser specifically recognizes and parses macro invocations annotated with <code>!</code>, you can use them only in places where the parser allows them. They work in most places you’d expect, like in expression position or in an <code>impl</code> block, but not everywhere. For example, you cannot (at the time of writing) invoke a function-like macro where an identifier or match arm is expected.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>It may not be immediately obvious why declarative macros are called declarative. After all, don’t you “declare” everything in your program? In this context, <em>declarative </em>refers to the fact that you don’t say how the macro’s inputs should be translated into the output, just that you want the output to look like A when the input is B. You declare that it shall be so, and the compiler figures out all the parsing rewiring that has to happen to make your declaration reality. This makes declarative macros concise and expressive, though it also has a tendency to make them rather cryptic since you have a limited language with which to express your declarations.</p>
<h3 id="h2--0001">When to Use Them</h3>
<p class="BodyFirst">Declarative macros are primarily useful when you find yourself writing the same code over and over, and you’d like to, well, not do that. They’re best suited for fairly mechanical replacements—if you’re aiming to do fancy code transformations or lots of code generation, procedural macros are likely a better fit.</p>
<p>I most frequently use declarative macros in cases where I find myself writing repetitive and structurally similar code, such as in tests and trait <span epub:type="pagebreak" title="103" id="Page_103"/>implementations. For tests, I often want to run the same test multiple times but with slightly different configurations. I might have something like what is shown in <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>.</p>
<pre><code>fn test_inner&lt;T&gt;(init: T, frobnify: bool) { ... }
#[test]
fn test_1u8_frobnified() {
  test_inner(1u8, true);
}
<span class="LiteralGray">// ...</span>
#[test]
fn test_1i128_not_frobnified() {
  test_inner(1i128, false);
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Repetitive testing code</p>
<p>While this works, it’s too verbose, too repetitive, and too prone to manual error. With macros we can do much better, as shown in <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a>.</p>
<pre><code>macro_rules! test_battery {
  ($($t:ty as $name:ident),*)) =&gt; {
    $(
      mod $name {
        #[test]
        fn frobnified() { test_inner::&lt;$t&gt;(1, true) }
        #[test]
        fn unfrobnified() { test_inner::&lt;$t&gt;(1, false) }
      }
    )*
  }
}
test_battery! {
  u8 as u8_tests,
  <span class="LiteralGray">// ...</span>
  i128 as i128_tests
);</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: Making a macro repeat for you</p>
<p>This macro expands each comma-separated directive into its own module that then contains two tests, one that calls <code>test_inner</code> with <code>true</code>, and one with <code>false</code>. While the macro definition isn’t trivial, it makes adding more tests much easier. Each type is one line in the <code>test_battery!</code> invocation, and the macro will take care of generating tests for both <code>true</code> and <code>false</code> arguments. We could also have it generate tests for different values for <code>init</code>. We’ve now significantly reduced the likelihood that we’ll forget to test a particular configuration!</p>
<p>The story for trait implementations is similar. If you define your own trait, you’ll often want to implement that trait for a number of types in the standard library, even if those implementations are trivial. Let’s imagine you invented the <code>Clone</code> trait and want to implement it for all the <code>Copy</code> types <span epub:type="pagebreak" title="104" id="Page_104"/>in the standard library. Instead of manually writing an implementation for each one, you can use a macro like the one in <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a>.</p>
<pre><code>macro_rules! clone_from_copy {
  ($($t:ty),*) =&gt; {
    $(impl Clone for $t {
      fn clone(&amp;self) -&gt; Self { *self }
    })*
  }
}
clone_from_copy![bool, f32, f64, u8, i8, /* ... */];</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: Using a macro to implement a trait for many similar types in one fell swoop</p>
<p>Here, we generate an implementation of <code>Clone</code> for each provided type whose body just uses <code>*</code> to <code>copy</code> out of <code>&amp;self</code>. You may wonder why we don’t add a blanket implementation of <code>Clone for T where T: Copy</code>. We could do that, but a big reason not to is that it would force types in other crates to also use that same implementation of <code>Clone</code> for their own types that happen to be <code>Copy</code>. An experimental compiler feature called <em>specialization</em> could offer a workaround, but at the time of writing the stabilization of that feature is still some way off. So, for the time being, we’re better off enumerating the types specifically. This pattern also extends beyond simple forwarding implementations: for example, you could easily alter the code in <a href="#listing7-3">Listing 7-3</a> to implement an <code>AddOne</code> trait to all integer types!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	If you ever find yourself wondering if you should use generics or a declarative macro, you should use generics. Generics are generally more ergonomic than macros and integrate much better with other constructs in the language. Consider this rule of thumb: if your code changes based on type, use generics; otherwise, use macros.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2--0002">How They Work</h3>
<p class="BodyFirst">Every programming language has a <em>grammar</em> that dictates how the individual characters that make up the source code can be turned into <em>tokens</em>. Tokens are the lowest-level building blocks of a language, such as numbers, punctuation characters, string and character literals, and identifiers; at this level, there’s no distinction between language keywords and variable names. For example, the text <code>(value + 4)</code> would be represented by the five-token sequence <code>(</code>, <code>value</code>, <code>+</code>, <code>4</code>, <code>)</code> in Rust-like grammar. The process of turning text into tokens also provides a layer of abstraction between the rest of the compiler and the gnarly low-level details of parsing text. For example, in the token representation, there is no notion of whitespace, and <code>/*"foo"*/</code> and <code>"/*foo*/"</code> have distinct representations (the former is no token, and the latter is a string literal token with the content <code>/*foo*/</code>).</p>
<p>Once the source code has been turned into a sequence of tokens, the compiler walks that sequence and assigns syntactic meaning to the tokens. For example, <code>()</code>-delimited tokens make up a group, <code>!</code> tokens denote macro invocations, and so on. This is the process of <em>parsing</em>, which ultimately produces an abstract syntax tree (AST) that describes the structure represented by the <span epub:type="pagebreak" title="105" id="Page_105"/>source code. As an example, consider the expression <code>let x = || 4</code>, which consists of the sequence of tokens <code>let</code> (keyword), <code>x</code> (identifier), <code>=</code> (punctuation), two instances of <code>|</code> (punctuation), and <code>4</code> (literal). When the compiler turns that into a syntax tree, it represents it as a <em>statement</em> whose <em>pattern</em> is the <em>identifier</em> <code>x</code> and whose right-hand <em>expression</em> is a <em>closure</em> that has an empty <em>argument list</em> and a<em> literal expression </em>of the <em>integer literal</em> <code>4</code> as its body. Notice how the syntax tree representation is much richer than the token sequence, since it assigns syntactic meaning to the token combinations following the language’s grammar.</p>
<p>Rust macros dictate the syntax tree that a given sequence of tokens gets turned into—when the compiler encounters a macro invocation during parsing, it has to evaluate the macro to determine the replacement tokens, which will ultimately become the syntax tree for the macro invocation. At this point, however, the compiler is still parsing the tokens and might not be in a position to evaluate a macro yet, since all it has done is parse the tokens of the macro definition. Instead, then, the compiler defers the parsing of anything contained within the delimiters of a macro invocation and remembers the input token sequence. When the compiler is ready to evaluate the indicated macro, it evaluates the macro over the token sequence, parses the tokens it yields, and substitutes the resulting syntax tree into the tree where the macro invocation was.</p>
<p>Technically, the compiler does do a little bit of parsing for the input to a macro. Specifically, it parses out basic things like string literals and delimited groups and so produces a sequence of token <em>trees</em> rather than just tokens. For example, the code <code>x - (a.b + 4)</code> parses as a sequence of three token trees. The first token tree is a single token that is the identifier <code>x</code>, the second is a single token that is the punctuation character <code>-</code>, and the third is a group (using parentheses as the delimiter), which itself consists of a sequence of five token trees: <code>a</code> (an identifier), <code>.</code> (punctuation), <code>b</code> (another identifier), <code>+</code> (another punctuation token), and <code>4</code> (a literal). This means that the input to a macro does not necessarily have to be valid Rust, but it must consist of code that the Rust compiler can parse. For example, you couldn’t write <code>for &lt;- x</code> in Rust outside of a macro invocation, but inside of a macro invocation you can, as long as the macro produces valid syntax. On the other hand, you cannot pass <code>for {</code> to a macro because it doesn’t have a closing brace.</p>
<p>Declarative macros always generate valid Rust as output. You cannot have a macro generate, say, the first half of a function invocation or an <code>if</code> without the block that follows it. A declarative macro must generate an expression (basically anything that you can assign to a variable), a statement such as <code>let x = 1;</code>, an item like a trait definition or <code>impl</code> block, a type, or a <code>match</code> pattern. This makes Rust macros resistant to misuse: you simply cannot write a declarative macro that generates invalid Rust code, because the macro definition itself would not compile!</p>
<p>That’s really all there is to declarative macros at a high level—when the compiler encounters a macro invocation, it passes the tokens contained within the invocation delimiters to the macro, parses the resulting token stream, and replaces the macro invocation with the resulting AST.</p>
<h3 id="h2--0003"><span epub:type="pagebreak" title="106" id="Page_106"/>How to Write Declarative Macros</h3>
<p class="BodyFirst">An exhaustive explanation of all the syntax that declarative macros support is outside the scope of this book. However, we’ll cover the basics as there are some oddities worth pointing out.</p>
<p>Declarative macros consist of two main parts: <em>matchers</em> and <em>transcribers</em>. A given macro can have many matchers, and each matcher has an associated transcriber. When the compiler finds a macro invocation, it walks the macro’s matchers from first to last, and when it finds a matcher that matches the tokens in the invocation, it substitutes the invocation by walking the tokens of the corresponding transcriber. <a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a> shows how the different parts of a declarative macro rule fit together.</p>
<pre><code>macro_rules! /* macro name */ {
  (/* 1st matcher */) =&gt; { /* 1st transcriber */ };
  (/* 2nd matcher */) =&gt; { /* 2nd transcriber */ };
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: Declarative macro definition components</p>
<h4 id="h3--0001">Matchers</h4>
<p class="BodyFirst">You can think of a macro matcher as a token tree that the compiler tries to twist and bend in predefined ways to match the input token tree it was given at the invocation site. As an example, consider a macro with the matcher <code>$a:ident + $b:expr</code>. That matcher will match any identifier (<code>:ident</code>) followed by a plus sign followed by any Rust expression (<code>:expr</code>). If the macro is invoked with <code>x + 3 * 5</code>, the compiler notices that the matcher matches if it sets <code>$a = x</code> and <code>$b = 3 * 5</code>. Even though <code>*</code> never appears in the matcher, the compiler realizes that <code>3 * 5</code> is a valid expression and that it can therefore be matched with <code>$b:expr</code>, which accepts anything that is an expression (the <code>:expr</code> part).</p>
<p>Matchers can get pretty hairy, but they have huge expressive power, much like regular expressions. For a not-too-hairy example, this matcher accepts a sequence (<code>$()</code>) of one or more (<code>+</code>) comma-separated (<code>),</code>) key/value pairs given in <code>key =&gt; value</code> format:</p>
<pre><code>$($key:expr =&gt; $value:expr),+</code></pre>
<p>And, crucially, code that invokes a macro with this matcher can give an arbitrarily complex expression for the key or value—the magic of matchers will make sure that the key and value expressions are partitioned appropriately.</p>
<p>Macro rules support a wide variety of  <em>fragment types</em>; you’ve already seen <code>:ident</code> for identifiers and <code>:expr</code> for expressions, but there is also <code>:ty</code> for types and even <code>:tt</code> for any single token tree! You can find a full list of the fragment types in Chapter 3 of the Rust language reference (<a href="https://doc.rust-lang.org/reference/macros-by-example.html" class="LinkURL">https://doc.rust-lang.org/reference/macros-by-example.html</a>). These, plus the mechanism for matching a pattern repeatedly (<code>$()</code>), enable you to match most straightforward code patterns. If, however, you find that it is difficult to express the pattern you want with a matcher, you may want to try a procedural macro instead, <span epub:type="pagebreak" title="107" id="Page_107"/>where you don’t need to follow the strict syntax that <code>macro_rules!</code> requires. We’ll look at these in more detail later in the chapter.</p>
<h4 id="h3--0002">Transcribers</h4>
<p class="BodyFirst">Once the compiler has matched a declarative macro matcher, it generates code using the matcher’s associated transcriber. The variables defined by a macro matcher are called <em>metavariables</em>, and the compiler substitutes any occurrence of each metavariable in the transcriber (like <code>$key</code> in the example in the previous section) with the input that matches that part of the matcher. If you have repetition in the matcher (like <code>$(),+</code> in that same example), you can use the same syntax in the transcriber and it will be repeated once for each match in the input, with each expansion holding the appropriate substitution for each metavariable for that iteration. For example, for the <code>$key</code> and <code>$value</code> matcher, we could write the following transcriber to generate an <code>insert</code> call into some map for each <code>$key</code>/<code>$value</code> pair that was matched:</p>
<pre><code>$(map.insert($key, $value);)+</code></pre>
<p>Notice that here we want a semicolon for each repetition, not just to delimit the repetition, so we place the semicolon inside the repetition parentheses. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	You must use a metavariable in each repetition in the transcriber so that the compiler knows which repetition in the matcher to use (in case there is more than one).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3--0003">Hygiene</h4>
<p class="BodyFirst">You may have heard that Rust macros are <em>hygienic</em>, and perhaps that being hygienic makes them safer or nicer to work with, without necessarily understanding what that means. When we say Rust macros are hygienic, we mean that a declarative macro (generally) cannot affect variables that aren’t explicitly passed to it. A trivial example is that if you declare a variable with the name <code>foo</code>, and then call a macro that also defines a variable named <code>foo</code>, the macro’s <code>foo</code> is by default not visible at the call site (the place where the macro is called from). Similarly, macros cannot access variables defined at the call site (even <code>self</code>) unless they are explicitly passed in.</p>
<p>You can, most of the time, think of macro identifiers as existing in their own namespace that is separate from that of the code they expand into. For an example, take a look at the code in <a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a>, which has a macro that tries (and fails) to shadow a variable at the call site.</p>
<pre><code>macro_rules! let_foo {
  ($x:expr) =&gt; {
    let foo = $x;
  }
}
let foo = 1;
<span class="LiteralGray">// expands to let foo = 2;</span>
let_foo!(2);
assert_eq!(foo, 1);</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: Macros exist in their own little universes. Mostly.</p>
<p><span epub:type="pagebreak" title="108" id="Page_108"/>After the compiler expands <code>let_foo!(2)</code>, the assert looks like it should fail. However, the <code>foo</code> from the original code and the one generated by the macro exist in different universes and have no relationship to one another beyond that they happen to share a human-readable name. In fact, the compiler will complain that the <code>let foo</code> in the macro is an unused variable. This hygiene is very helpful in making macros easier to debug—you don’t have to worry about accidentally shadowing or overwriting variables in the macro caller just because you happened to choose the same variable names!</p>
<p>This hygienic separation does not apply beyond variable identifiers, however. Declarative macros do share a namespace for types, modules, and functions with the call site. This means your macro can define new functions that can be called in the invoking scope, add new implementations to a type defined elsewhere (and not passed in), introduce a new module that can then be accessed where the macro was invoked, and so on. This is by design—if macros could not affect the broader code like this, it would be much more cumbersome to use them to generate types, trait implementations, and functions, which is where they come in most handy.</p>
<p>The lack of hygiene for types in macros is particularly important when writing a macro you want to export from your crate. For the macro to truly be reusable, you cannot assume anything about what types will be in scope at the caller. Maybe the code that calls your macro has a <code>mod std {}</code> defined or has imported its own <code>Result</code> type. To be on the safe side, make sure you use fully specified types like <code>::core::option::Option</code> or <code>::alloc::boxed::Box</code>. If you specifically need to refer to something in the crate that defines the macro, use the special metavariable <code>$crate</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Avoid using <code>::std</code> paths if you can so that the macro will continue to work in <code>no_std</code> crates. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You can choose to share identifiers between a macro and its caller if you want the macro to affect a specific variable in the caller’s scope. The key is to remember where the identifier originated, because that’s the namespace the identifier will be tied to. If you put <code>let foo = 1;</code> in a macro, the identifier <code>foo</code> originates in the macro and will never be available to the identifier namespace at the caller. If, on the other hand, the macro takes <code>$foo:ident</code> as an argument and then writes <code>let $foo = 1;</code>, when the caller invokes the macro with <code>!(foo)</code>, the identifier will have originated in the caller and will therefore refer to <code>foo</code> in the caller’s scope. </p>
<p>The identifier does not have to be quite so explicitly passed, either; any identifier that appears in code that originates outside the macro will refer to the identifier in the caller’s scope. In the example in <a href="#listing7-6" id="listinganchor7-6">Listing 7-6</a>, the variable identifier appears in an <code>:expr</code> but nonetheless has access to the variable in the caller’s scope.</p>
<pre><code>macro_rules! please_set {
  ($i:ident, $x:expr) =&gt; {
    $i = $x;
  }
<span epub:type="pagebreak" title="109" id="Page_109"/>}
let mut x = 1;
please_set!(x, x + 1);
assert_eq!(x, 2);</code></pre>
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: Giving macros access to identifiers at the call site</p>
<p>We could have used <code>= $i + 1</code> in the macro instead, but we could not have used <code>= x + 1</code> as the name <code>x</code> is not available in the macro’s definition scope.</p>
<p>One last note on declarative macros and scoping: unlike pretty much everything else in Rust, declarative macros exist in the source code only after they are declared. If you try to use a macro that you define further down in the file, this will not work! This applies globally to your project; if you declare a macro in one module and want to use it in another, the module you declare the macro in must appear earlier in the crate, not later. If <code>foo</code> and <code>bar</code> are modules at the root of a crate, and <code>foo</code> declares a macro that <code>bar</code> wants to use, then <code>mod foo</code> must appear before <code>mod bar</code> in<em> lib.rs</em>!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	There is one exception to this odd scoping of macros (formally called <em>textual scoping</em>), and that is if you mark the macro with <code>#[macro_export]</code>. That annotation effectively hoists the macro to the root of the crate and marks it as <code>pub</code> so that it can then be used anywhere in your crate or by your crate’s dependents.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1--0002">Procedural Macros</h2>
<p class="BodyFirst">You can think of a procedural macro as a combination of a parser and code generation, where you write the glue code in between. At a high level, with procedural macros, the compiler gathers the sequence of input tokens to the macro and runs your program to figure out what tokens to replace them with.</p>
<p>Procedural macros are so called because you define <em>how</em> to generate code given some input tokens rather than just writing what code gets generated. There are very few smarts involved on the compiler’s side—as far as it is aware, the procedural macro is more or less a source code preprocessor that may replace code arbitrarily. The requirement that your input can be parsed as a stream of Rust tokens still holds, but that’s about it!</p>
<h3 id="h2--0004">Types of Procedural Macros</h3>
<p class="BodyFirst">Procedural macros come in three different flavors, each specialized to a particular common use case: </p>
<ul>
<li>Function-like macros, like the ones that <code>macro_rules!</code> generates </li>
<li>Attribute macros, like <code>#[test]</code> </li>
<li>Derive macros, like <code>#[derive(Serialize)]</code></li>
</ul>
<p>All three types use the same underlying mechanism: the compiler provides your macro with a sequence of tokens, and it expects you to produce <span epub:type="pagebreak" title="110" id="Page_110"/>a sequence of tokens in return that are (probably) related to the input tree. However, they differ in how the macro is invoked and how its output is handled. We’ll cover each one briefly.</p>
<h4 id="h3--0004">Function-Like Macros</h4>
<p class="BodyFirst">The function-like macro is the simplest form of procedural macro. Like a declarative macro, it simply replaces the macro code at the call site with the code that the procedural macro returns. However, unlike with declarative macros, all the guard rails are off: these macros (like all procedural macros) are not required to be hygienic and will not protect you from interacting with identifiers in the surrounding code at the call site. Instead, your macros are expected to explicitly call out which identifiers should overlap with the surrounding code (using <code>Span::call_site</code>) and which should be treated as private to the macro (using <code>Span::mixed_site</code>, which we’ll discuss later). </p>
<h4 id="h3--0005">Attribute Macros</h4>
<p class="BodyFirst">The attribute macro also replaces the item that the attribute is assigned to wholesale, but this one takes two inputs: the token tree that appears in the attribute (minus the attribute’s name) and the token tree of the entire item it is attached to, including any other attributes that item may have. Attribute macros allow you to easily write a procedural macro that transforms an item, such as by adding a prelude or epilogue to a function definition (like <code>#[test]</code> does) or by modifying the fields of a struct.</p>
<h4 id="h3--0006">Derive Macros</h4>
<p class="BodyFirst">The derive macro is slightly different from the other two in that it adds to, rather than replaces, the target of the macro. Even though this limitation may seem severe, derive macros were one of the original motivating factors behind the creation of procedural macros. Specifically, the <code>serde</code> crate needed derive macros to be able to implement its now-well-known <code>#[derive(Serialize, Deserialize)]</code> magic. </p>
<p>Derive macros are arguably the simplest of the procedural macros, since they have such a rigid form: you can append items only after the annotated item; you can’t replace the annotated item, and you cannot have the derivation take arguments. Derive macros do allow you to define <em>helper attributes</em>—attributes that can be placed inside the annotated type to give clues to the derive macro (like <code>#[serde(skip)]</code>)—but these function mostly like markers and are not independent macros.</p>
<h3 id="h2--0005">The Cost of Procedural Macros</h3>
<p class="BodyFirst">Before we talk about when each of the different procedural macro types is appropriate, it’s worth discussing why you may want to think twice before you reach for a procedural macro—namely, increased compile time.</p>
<p>Procedural macros can significantly increase compile times for two main reasons. The first is that they tend to bring with them some pretty <span epub:type="pagebreak" title="111" id="Page_111"/>heavy dependencies. For example, the <code>syn</code> crate, which provides a parser for Rust token streams that makes the experience of writing procedural macros much easier, can take tens of seconds to compile with all features enabled. You can (and should) mitigate this by disabling features you do not need and compiling your procedural macros in debug mode rather than release mode. Code often compiles several times faster in debug mode, and for most procedural macros, you won’t even notice the difference in execution time.</p>
<p>The second reason why procedural macros increase compile time is that they make it easy for you to generate a lot of code without realizing it. While the macro saves you from having to actually type the generated code, it does not save the compiler from having to parse, compile, and optimize it. As you use more procedural macros, that generated boilerplate adds up, and it can bloat your compile times.</p>
<p>That said, the actual execution time of procedural macros is rarely a factor in overall compile time. While the compiler has to wait for the procedural macro to do its thing before it can continue, in practice, most procedural macros don’t do any heavy computation. That said, if your procedural macro is particularly involved, you may end up with your compiles spending a significant chunk of execution time on your procedural macro code, which is worth keeping an eye out for!</p>
<h3 id="h2--0006">So You Think You Want a Macro</h3>
<p class="BodyFirst">Let’s now look at some good uses for each type of procedural macro. We’ll start with the easy one: derive macros.</p>
<h4 id="h3--0007">When to Use Derive Macros</h4>
<p class="BodyFirst">Derive macros are used for one thing, and one thing only: to automate the implementation of a trait where automation is possible. Not all traits have obvious automated implementations, but many do. In practice, you should consider adding a derive macro for a trait only if the trait is implemented often and if its implementation for any given type is fairly obvious. The first of these conditions may seem like common sense; if your trait is going to be implemented only once or twice, it’s probably not worth writing and maintaining a convoluted derive macro for it. </p>
<p>The second condition may seem stranger, however: what does it mean for the implementation to be “obvious”? Consider a trait like <code>Debug</code>. If you were told what <code>Debug</code> does and were shown a type, you would probably expect an implementation of <code>Debug</code> to output the name of each field alongside the debug representation of its value. And that’s what <code>derive(Debug)</code> does. What about <code>Clone</code>? You’d probably expect it to just clone every field—and again, that’s what <code>derive(Clone)</code> does. With <code>derive(serde::Serialize)</code>, we expect it to serialize every field and its value, and it does just that. In general, you want the derivation of a trait to match the developer’s intuition for what it probably does. If there is no obvious derivation for a trait, or worse yet, if your derivation does not match the obvious implementation, then you’re probably better off not giving it a derive macro.</p>
<h4 id="h3--0008"><span epub:type="pagebreak" title="112" id="Page_112"/>When to Use Function-Like Macros</h4>
<p class="BodyFirst">Function-like macros are harder to give a general rule of thumb for. You might say you should use function-like macros when you want a function-like macro but can’t express it with <code>macro_rules!</code>, but that’s a fairly subjective guideline. You can do a lot with declarative macros if you really put your mind to it, after all! </p>
<p>There are two particularly good reasons to reach for a function-like macro:</p>
<ul>
<li>If you already have a declarative macro, and its definition is becoming so hairy that the macro is hard to maintain. </li>
<li>If you have a pure function that you need to be able to execute at compile time but cannot express it with<code> const fn</code>. An example of this is the <code>phf</code> crate, which generates a hash map or set using a perfect hash function when given a set of keys provided at compile time. Another is <code>hex-literal</code>, which takes a string of hexadecimal characters and replaces it with the corresponding bytes. In general, anything that does not merely transform the input at compile time but actually computes over it is likely to be a good candidate.</li>
</ul>
<p>I do not recommend reaching for a function-like macro just so that you can break hygiene within your macro. Hygiene for function-like macros is a feature that avoids many debugging headaches, and you should think very carefully before you intentionally break it.</p>
<h4 id="h3--0009">When to Use Attribute Macros</h4>
<p class="BodyFirst">That leaves us with attribute macros. Though these are arguably the most general of procedural macros, they are also the hardest to know when to use. Over the years and time and time again, I have seen four ways in which attribute macros add tremendous value.</p>
<p class="ListHead"><b>Test generation</b></p>
<ol class="none">
<li>It is very common to want to run the same test under multiple different configurations, or many similar tests with the same bootstrapping code. While a declarative macro may let you express this, your code is often easier to read and maintain if you have an attribute like <code>#[foo_test]</code> that introduces a setup prelude and postscript in each annotated test, or a repeatable attribute like <code>#[test_case(1)] #[test_case(2)]</code> to mark that a given test should be repeated multiple times, once with each input.</li>
</ol>
<p class="ListHead"><b>Framework annotations</b></p>
<ol class="none">
<li>Libraries like <code>rocket</code> use attribute macros to augment functions and types with additional information that the framework then uses without the user having to do a lot of manual configuration. It’s so much more convenient to be able to write <code>#[get("/&lt;name&gt;")] fn hello(name: String)</code> than to have to set up a configuration struct with function pointers and <span epub:type="pagebreak" title="113" id="Page_113"/>the like. Essentially, the attributes make up a miniature domain-specific language (DSL) that hides a lot of boilerplate that’d otherwise be necessary. Similarly, the asynchronous I/O framework <code>tokio</code> lets you use <code>#[tokio::main] async fn main()</code> to automatically set up a runtime and run your asynchronous code, thereby saving you from writing the same runtime setup in every asynchronous application’s <code>main</code> function.</li>
</ol>
<p class="ListHead"><b>Transparent middleware</b></p>
<ol class="none">
<li>Some libraries want to inject themselves into your application in unobtrusive ways to provide added value that does not change the application’s functionality. For example, tracing and logging libraries like <code>tracing</code> and metric collection libraries like <code>metered</code> allow you to transparently instrument a function by adding an attribute to it, and then every call to that function will run some additional code dictated by the library.</li>
</ol>
<p class="ListHead"><b>Type transformers</b></p>
<ol class="none">
<li>Sometimes you want to go beyond merely deriving traits for a type and actually change the type’s definition in some fundamental way. In these cases, attribute macros are the way to go. The <code>pin_project</code> crate is a great example of this: its primary purpose is not to implement a particular trait but rather to ensure that all pinned access to fields of a given type happens according to the strict rules that are set forth by Rust’s <code>Pin</code> type and the <code>Unpin</code> trait (we’ll talk more about those types in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>). It does this by generating additional helper types, adding methods to the annotated type, and introducing static safety checks to ensure that users don’t accidentally shoot themselves in the foot. While <code>pin_project</code> could have been implemented with a procedural derive macro, that derived trait implementation would likely not have been obvious, which violates one of our rules for when to use procedural macros.</li>
</ol>
<h3 id="h2--0007">How Do They Work?</h3>
<p class="BodyFirst">At the heart of all procedural macros is the <code>TokenStream</code> type, which can be iterated over to get the individual <code>TokenTree</code> items that make up that token stream. A <code>TokenTree</code> is either a single token—like an identifier, punctuation, or a literal—or another <code>TokenStream</code> enclosed in a delimiter like <code>()</code> or <code>{}</code>. By walking a <code>TokenStream</code>, you can parse out whatever syntax you wish as long as the individual tokens are valid Rust tokens. If you want to parse your input specifically as Rust code, you will likely want to use the <code>syn</code> crate, which implements a complete Rust parser and can turn a <code>TokenStream</code> into an easy-to-traverse Rust AST.</p>
<p>With most procedural macros, you want to not only parse a <code>TokenStream</code> but also produce Rust code to be injected into the program that invokes the procedural macro. There are two main ways to do so. The first is to manually construct a <code>TokenStream</code> and extend it one <code>TokenTree</code> at a time. The second is to use <code>TokenStream</code>’s implementation of <code>FromStr</code>, which lets you parse a string that <span epub:type="pagebreak" title="114" id="Page_114"/>contains Rust code into a <code>TokenStream</code> with <code>"".parse::&lt;TokenStream&gt;()</code>. You can also mix and match these; if you want to prepend some code to your macro’s input, just construct a <code>TokenStream</code> for the prologue, and then use the <code>Extend</code> trait to append the original input.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	<code>TokenStream</code> also implements <code>Display</code>, which pretty-prints the tokens in the stream. This comes in super handy for debugging!</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Tokens are very slightly more magical than I’ve described so far in that every token, and indeed every <code>TokenTree</code>, also has a <em>span</em>. Spans are how the compiler ties generated code back to the source code that generated it. Every token’s span marks where that token originated. For example, consider a (declarative) macro like the one in <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a>, which generates a trivial <code>Debug</code> implementation for the provided type.</p>
<pre><code>macro_rules! name_as_debug {
  ($t:ty) =&gt; {
    impl ::core::fmt::Debug for $t {
      fn fmt(&amp;self, f: &amp;mut ::core::fmt::Formatter&lt;'_&gt;) -&gt; ::core::fmt::Result
      { ::core::write!(f, ::core::stringify!($t)) }
} }; }</code></pre>
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: A very simple macro for implementing <code>Debug</code></p>
<p>Now let’s imagine that someone invokes this macro with <code>name_as_debug!(u31)</code>. Technically, the compiler error occurs inside the macro, specifically where we write <code>for $t</code> (the other use of <code>$t</code> can handle an invalid type). But we’d like the compiler to point the user at the <code>u31</code> in their code—and indeed, that’s what spans let us do.</p>
<p>The span of the <code>$t</code> in the generated code is the code mapped to <code>$t</code> in the macro invocation. That information is then carried through the compiler and associated with the eventual compiler error. When that compiler error is eventually printed, the compiler will print the error from inside the macro saying that the type <code>u31</code> does not exist but will highlight the <code>u31</code> argument in the macro invocation, since that’s the error’s associated span!</p>
<p>Spans are quite flexible, and they enable you to write procedural macros that can produce sophisticated error messages if you use the <code>compile_error!</code> macro. As its name implies, <code>compile_error!</code> causes the compiler to emit an error wherever it is placed with the provided string as the message. This may not seem very useful, until you pair it with a span. By setting the span of the <code>TokenTree</code> you generate for the <code>compile_error!</code> invocation to be equal to the span of some subset of the input, you are effectively telling the compiler to emit this compiler error and point the user to this part of the source. Together, these two mechanisms let a macro produce errors that seem to stem from the relevant part of the code, even though the actual compiler error is somewhere in the generated code that the user never even sees!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="115" id="Page_115"/><h2><span class="NoteHead">Note</span></h2>
<p>	If you’ve ever been curious how <code>syn</code>’s error handling works, its <code>Error</code> type implements an <code>Error::to_compile_error</code> method, which turns it into a <code>TokenStream</code> that holds only a <code>compile_error!</code> directive. What’s particularly neat with <code>syn</code>’s <code>Error</code> type is that it internally holds a collection of errors, each of which produces a distinct <code>compile_error!</code> directive with its own span so that you can easily produce multiple independent errors from your procedural macro.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The power of spans doesn’t end there; spans are also how Rust’s macro hygiene is implemented. When you construct an <code>Ident</code> token, you also give the span for that identifier, and that span dictates the scope of that identifier. If you set the identifier’s span to be <code>Span::call_site()</code>, the identifier is resolved where the macro was called from and will thus not be isolated from the surrounding scope. If, on the other hand, you set it to <code>Span::mixed_site()</code> then (variable) identifiers are resolved at the macro definition site, and so will be completely hygienic with respect to similarly named variables at the call site. <code>Span::mixed_site</code> is so called because it matches the rules around identifier hygiene for <code>macro_rules!</code>, which, as we discussed earlier, “mixes” identifier resolution between using the macro definition site for variables and using the call site for types, modules, and everything else.</p>
<h2 id="h1--0003">Summary</h2>
<p class="BodyFirst">In this chapter we covered both declarative and procedural macros, and looked at when you might find each of them useful in your own code. We also took a deeper dive into the mechanisms that underpin each type of macro and some of the features and gotchas to be aware of when you write your own macros. In the next chapter, we’ll start our journey into asynchronous programming and the <code>Future</code> trait. I promise—it’s just on the next page.</p>
</section>
</div></body></html>