<html><head></head><body>
<h2 class="h2a" id="ch08"><span epub:type="pagebreak" id="page_179"/><strong><span class="big">8</span></strong><br/><strong>IMPLEMENTING THE NETWORK PROTOCOL</strong></h2>&#13;
<p class="noindent_first">Analyzing a network protocol can be an end in itself; however, most likely you’ll want to implement the protocol so you can actually test it for security vulnerabilities. In this chapter, you’ll learn ways to implement a protocol for testing purposes. I’ll cover techniques to repurpose as much existing code as possible to reduce the amount of development effort you’ll need to do.</p>&#13;
<p class="indent">This chapter uses my SuperFunkyChat application, which provides testing data and clients and servers to test against. Of course, you can use any protocol you like: the fundamentals should be the same.</p>&#13;
<h3 class="h3" id="ch00lev1sec216"><span epub:type="pagebreak" id="page_180"/><strong>Replaying Existing Captured Network Traffic</strong></h3>&#13;
<p class="noindent">Ideally, we want to do only the minimum necessary to implement a client or server for security testing. One way to reduce the amount of effort required is to capture example network protocol traffic and replay it to real clients or servers. We’ll look at three ways to achieve this goal: using Netcat to send raw binary data, using Python to send UDP packets, and repurposing our analysis code in <a href="../Text/ch05.xhtml#ch05">Chapter 5</a> to implement a client and a server.</p>&#13;
<h4 class="h4" id="ch00lev1sec217"><strong><em>Capturing Traffic with Netcat</em></strong></h4>&#13;
<p class="noindent">Netcat is the simplest way to implement a network client or server. The basic Netcat tool is available on most platforms, although there are multiple versions with different command line options. (Netcat is sometimes called <span class="literal">nc</span> or <span class="literal">netcat</span>.) We’ll use the BSD version of Netcat, which is used on macOS and is the default on most Linux systems. You might need to adapt commands if you’re on a different operating system.</p>&#13;
<p class="indent">The first step when using Netcat is to capture some traffic you want to replay. We’ll use the Tshark command line version of Wireshark to capture traffic generated by SuperFunkyChat. (You may need to install Tshark on your platform.)</p>&#13;
<p class="indent">To limit our capture to packets sent to and received by our ChatServer running on TCP port 12345, we’ll use a <em>Berkeley Packet Filter (BPF)</em> expression to restrict the capture to a very specific set of packets. BPF expressions limit the packets captured, whereas Wireshark’s display filter limits only the display of a much larger set of capture packets.</p>&#13;
<p class="indent">Run the following command at the console to begin capturing port 12345 traffic and writing the output to the file <em>capture.pcap</em>. Replace <span class="literal"><span class="codeitalic">INTNAME</span></span> with the name of the interface you’re capturing from, such as <span class="literal">eth0</span>.</p>&#13;
<p class="programs">$ <span class="codestrong">tshark -i <span class="codeitalic">INTNAME</span> -w capture.pcap tcp port 12345</span></p>&#13;
<p class="indent">Make a client connection to the server to start the packet capture and then stop the capture by pressing <small>CTRL</small>+C in the console running Tshark. Make sure you’ve captured the correct traffic into the output file by running Tshark with the <span class="literal">-r</span> parameter and specifying the <em>capture.pcap</em> file. <a href="../Text/ch08.xhtml#ch8list1">Listing 8-1</a> shows example output from Tshark with the addition of the parameters <span class="literal">-z conv,tcp</span> to print the list of capture conversations.</p>&#13;
<p class="programs">$ <span class="codestrong">tshark -r capture.pcap -z conv,tcp</span><br/> <span class="ent">➊</span> 1 0 192.168.56.1 → 192.168.56.100 TCP 66 26082 → 12345 [SYN]<br/>    2 0.000037695 192.168.56.100 → 192.168.56.1 TCP 66 12345 → 26082 [SYN, ACK]<br/>    3 0.000239814 192.168.56.1 → 192.168.56.100 TCP 60 26082 → 12345 [ACK]<br/>    4 0.007160883 192.168.56.1 → 192.168.56.100 TCP 60 26082 → 12345 [PSH, ACK]<br/>    5 0.007225155 192.168.56.100 → 192.168.56.1 TCP 54 12345 → 26082 [ACK]<br/>--<span class="codeitalic">snip</span>--<br/><span epub:type="pagebreak" id="page_181"/><br/>================================================================================<br/>TCP Conversations<br/>Filter:&lt;No Filter&gt;<br/>                                              |       &lt;-      | |       -&gt;      |<br/>                                              | Frames  Bytes | | Frames  Bytes |<br/>192.168.56.1:26082 &lt;-&gt; 192.168.56.100:12345<span class="ent">➋</span>   17      1020<span class="ent">➌</span>     28      1733<span class="ent">➍</span><br/>================================================================================</p>&#13;
<p class="listing"><a id="ch8list1"/><em>Listing 8-1: Verifying the capture of the chat protocol traffic</em></p>&#13;
<p class="indent">As you can see in <a href="../Text/ch08.xhtml#ch8list1">Listing 8-1</a>, Tshark prints the list of raw packets at <span class="ent">➊</span> and then displays the conversation summary <span class="ent">➋</span>, which shows that we have a connection going from 192.168.56.1 port 26082 to 192.168.56.100 port 12345. The client on 192.168.56.1 has received 17 frames or 1020 bytes of data <span class="ent">➌</span>, and the server received 28 frames or 1733 bytes of data <span class="ent">➍</span>.</p>&#13;
<p class="indent">Now we use Tshark to export just the raw bytes for one direction of the conversation:</p>&#13;
<p class="programs">$ <span class="codestrong">tshark -r capture.pcap -T fields -e data 'tcp.srcport==26082' &gt; outbound.txt</span></p>&#13;
<p class="indent">This command reads the packet capture and outputs the data from each packet; it doesn’t filter out items like duplicate or out-of-order packets. There are a couple of details to note about this command. First, you should use this command only on captures produced on a reliable network, such as via localhost or a local network connection, or you might see erroneous packets in the output. Second, the <span class="literal">data</span> field is only available if the protocol isn’t decoded by a dissector. This is not an issue with the TCP capture, but when we move to UDP, we’ll need to disable dissectors for this command to work correctly.</p>&#13;
<p class="indent">Recall that at <span class="ent">➋</span> in Listing 8-1, the client session was using port 26082. The display filter <span class="literal">tcp.srcport==26082</span> removes all traffic from the output that doesn’t have a TCP source port of 26082. This limits the output to traffic from the client to the server. The result is the data in hex format, similar to Listing 8-2.</p>&#13;
<p class="programs">$ <span class="codestrong">cat outbound.txt</span><br/>42494e58<br/>0000000d<br/>00000347<br/>00<br/>057573657231044f4e595800<br/>--<span class="codeitalic">snip</span>--</p>&#13;
<p class="listing"><a id="ch8list2"/><em>Listing 8-2: Example output from dumping raw traffic</em></p>&#13;
<p class="indent">Next, we convert this hex output to raw binary. The simplest way to do so is with the xxd tool, which is installed by default on most Unix-like systems. Run the <span class="literal">xxd</span> command, as shown in <a href="../Text/ch08.xhtml#ch8list3">Listing 8-3</a>, to convert the hex dump to a binary file. (The <span class="literal">-p</span> parameter converts raw hex dumps rather than the default <span class="literal">xxd</span> format of a numbered hex dump.)</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_182"/><br/>$ <span class="codestrong">xxd -p -r outbound.txt &gt; outbound.bin</span><br/>$ <span class="codestrong">xxd outbound.bin</span><br/>00000000: 4249 4e58 0000 000d 0000 0347 0005 7573  BINX.......G..us<br/>00000010: 6572 3104 4f4e 5958 0000 0000 1c00 0009  er1.ONYX........<br/>00000020: 7b03 0575 7365 7231 1462 6164 6765 7220  {..user1.badger<br/>--<span class="codeitalic">snip</span>--</p>&#13;
<p class="listing"><a id="ch8list3"/><em>Listing 8-3: Converting the hex dump to binary data</em></p>&#13;
<p class="indent">Finally, we can use Netcat with the binary data file. Run the following <span class="literal">netcat</span> command to send the client traffic in <em>outbound.bin</em> to a server at <span class="literal"><span class="codeitalic">HOSTNAME</span></span> port 12345. Any traffic sent from the server back to the client will be captured in <em>inbound.bin</em>.</p>&#13;
<p class="programs">$ <span class="codestrong">netcat <span class="codeitalic">HOSTNAME</span> 12345 &lt; outbound.bin &gt; inbound.bin</span></p>&#13;
<p class="indent">You can edit <em>outbound.bin</em> with a hex editor to change the session data you’re replaying. You can also use the <em>inbound.bin</em> file (or extract it from a PCAP) to send traffic back to a client by pretending to be the server using the following command:</p>&#13;
<p class="programs">$ <span class="codestrong">netcat -l 12345 &lt; inbound.bin &gt; new_outbound.bin</span></p>&#13;
<h4 class="h4" id="ch00lev1sec218"><strong><em>Using Python to Resend Captured UDP Traffic</em></strong></h4>&#13;
<p class="noindent">One limitation of using Netcat is that although it’s easy to replay a streaming protocol such as TCP, it’s not as easy to replay UDP traffic. The reason is that UDP traffic needs to maintain packet boundaries, as you saw when we tried to analyze the Chat Application protocol in <a href="../Text/ch05.xhtml#ch05">Chapter 5</a>. However, Netcat will just try to send as much data as it can when sending data from a file or a shell pipeline.</p>&#13;
<p class="indent">Instead, we’ll write a very simple Python script that will replay the UDP packets to the server and capture any results. First, we need to capture some UDP example chat protocol traffic using the ChatClient’s <span class="literal">--udp</span> command line parameter. Then we’ll use Tshark to save the packets to the file <span class="literal">udp_capture.pcap</span>, as shown here:</p>&#13;
<p class="programs">tshark -i <span class="codeitalic">INTNAME</span> -w udp_capture.pcap udp port 12345</p>&#13;
<p class="indent">Next, we’ll again convert all client-to-server packets to hex strings so we can process them in the Python client:</p>&#13;
<p class="programs">tshark -T fields -e data -r udp_capture.pcap --disable-protocol gvsp/<br/>  "udp.dstport==12345" &gt; udp_outbound.txt</p>&#13;
<p class="indent">One difference in extracting the data from the UDP capture is that Tshark automatically tries to parse the traffic as the GVSP protocol. This results in the <span class="literal">data</span> field not being available. Therefore, we need to disable the GVSP dissector to create the correct output.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_183"/>With a hex dump of the packets, we can finally create a very simple Python script to send the UDP packets and capture the response. Copy Listing 8-4 into <em>udp_client.py</em>.</p>&#13;
<p class="literal"><span class="codeitalic">udp_client.py</span></p>&#13;
<p class="programs">import sys<br/>import binascii<br/>from socket import socket, AF_INET, SOCK_DGRAM<br/><br/>if len(sys.argv) &lt; 3:<br/>    print("Specify destination host and port")<br/>    exit(1)<br/><br/># Create a UDP socket with a 1sec receive timeout<br/>sock = socket(AF_INET, SOCK_DGRAM)<br/>sock.settimeout(1)<br/>addr = (sys.argv[1], int(sys.argv[2]))<br/><br/>for line in sys.stdin:<br/>    msg = binascii.a2b_hex(line.strip())<br/>    sock.sendto(msg, addr)<br/><br/>    try:<br/>        data, server = sock.recvfrom(1024)<br/>        print(binascii.b2a_hex(data))<br/>    except:<br/>        pass</p>&#13;
<p class="listing"><a id="ch8list4"/><em>Listing 8-4: A simple UDP client to send network traffic capture</em></p>&#13;
<p class="indent">Run the Python script using following command line (it should work in Python 2 and 3), replacing <span class="literal"><span class="codeitalic">HOSTNAME</span></span> with the appropriate host:</p>&#13;
<p class="programs">python udp_client.py <span class="codeitalic">HOSTNAME</span> 12345 &lt; udp_outbound.txt</p>&#13;
<p class="indent">The server should receive the packets, and any received packets in the client should be printed to the console as binary strings.</p>&#13;
<h4 class="h4" id="ch00lev1sec219"><strong><em>Repurposing Our Analysis Proxy</em></strong></h4>&#13;
<p class="noindent">In <a href="../Text/ch05.xhtml#ch05">Chapter 5</a>, we implemented a simple proxy for SuperFunkyChat that captured traffic and implemented some basic traffic parsing. We can use the results of that analysis to implement a network client and a network server to replay and modify traffic, allowing us to reuse much of our existing work developing parsers and associated code rather than having to rewrite it for a different framework or language.</p>&#13;
<h5 class="h5" id="ch00lev1sec220"><strong>Capturing Example Traffic</strong></h5>&#13;
<p class="noindent">Before we can implement a client or a server, we need to capture some traffic. We’ll use the <em>parser.csx</em> script we developed in <a href="../Text/ch05.xhtml#ch05">Chapter 5</a> and the code in <a href="../Text/ch08.xhtml#ch8list5">Listing 8-5</a> to create a proxy to capture the traffic from a connection.</p>&#13;
<p class="literal"><span epub:type="pagebreak" id="page_184"/><span class="codeitalic">chapter8_capture</span><br/><span class="codeitalic">_proxy.csx</span></p>&#13;
<p class="programs">   #load "parser.csx"<br/>   using static System.Console;<br/>   using static CANAPE.Cli.ConsoleUtils;<br/><br/>   var template = new FixedProxyTemplate();<br/>   // Local port of 4444, destination 127.0.0.1:12345<br/>   template.LocalPort = 4444;<br/>   template.Host = "127.0.0.1";<br/>   template.Port = 12345;<br/><span class="ent">➊</span> template.AddLayer&lt;Parser&gt;();<br/><br/>   var service = template.Create();<br/>   service.Start();<br/>   WriteLine("Created {0}", service);<br/>   WriteLine("Press Enter to exit...");<br/>   ReadLine();<br/>   service.Stop();<br/><br/>   WriteLine("Writing Outbound Packets to packets.bin");<br/><span class="ent">➋</span> service.Packets.WriteToFile("packets.bin", "Out");</p>&#13;
<p class="listing"><a id="ch8list5"/><em>Listing 8-5: The proxy to capture chat traffic to a file</em></p>&#13;
<p class="indent"><a href="../Text/ch08.xhtml#ch8list5">Listing 8-5</a> sets up a TCP listener on port 4444, forwards new connections to 127.0.0.1 port 12345, and captures the traffic. Notice that we still add our parsing code to the proxy at <span class="ent">➊</span> to ensure that the captured data has the data portion of the packet, not the length or checksum information. Also notice that at <span class="ent">➋</span>, we write the packets to a file, which will include all outbound and inbound packets. We’ll need to filter out a specific direction of traffic later to send the capture over the network.</p>&#13;
<p class="indent">Run a single client connection through this proxy and exercise the client a good bit. Then close the connection in the client and press <small>ENTER</small> in the console to exit the proxy and write the packet data to <em>packets.bin</em>. (Keep a copy of this file; we’ll need it for our client and server.)</p>&#13;
<h5 class="h5" id="ch00lev1sec221"><strong>Implementing a Simple Network Client</strong></h5>&#13;
<p class="noindent">Next, we’ll use the captured traffic to implement a simple network client. To do so, we’ll use the <span class="literal">NetClientTemplate</span> class to establish a new connection to the server and provide us with an interface to read and write network packets. Copy <a href="../Text/ch08.xhtml#ch8list6">Listing 8-6</a> into a file named <em>chapter8_client.csx</em>.</p>&#13;
<p class="literal"><span class="codeitalic">chapter8</span><br/><span class="codeitalic">_client.csx</span></p>&#13;
<p class="programs">   #load "parser.csx"<br/><br/>   using static System.Console;<br/>   using static CANAPE.Cli.ConsoleUtils;<br/><br/><span class="ent">➊</span> if (args.Length &lt; 1) {<br/>       WriteLine("Please Specify a Capture File");<br/>       return;<br/>   }<br/><span epub:type="pagebreak" id="page_185"/><span class="ent">➋</span> var template = new NetClientTemplate();<br/>   template.Port = 12345;<br/>   template.Host = "127.0.0.1";<br/>   template.AddLayer&lt;Parser&gt;();<br/><span class="ent">➌</span> template.InitialData = new byte[] { 0x42, 0x49, 0x4E, 0x58 };<br/><br/><span class="ent">➍</span> var packets = LogPacketCollection.ReadFromFile(args[0]);<br/><br/><span class="ent">➎</span> using(var adapter = template.Connect()) {<br/>       WriteLine("Connected");<br/>       // Write packets to adapter<br/>    <span class="ent">➏</span> foreach(var packet in packets.GetPacketsForTag("Out")) {<br/>           adapter.Write(packet.Frame);<br/>       }<br/><br/>       // Set a 1000ms timeout on read so we disconnect<br/>       adapter.ReadTimeout = 1000;<br/>    <span class="ent">➐</span> DataFrame frame = adapter.Read();<br/>       while(frame != null) {<br/>           WritePacket(frame);<br/>           frame = adapter.Read();<br/>       }<br/>   }</p>&#13;
<p class="listing"><a id="ch8list6"/><em>Listing 8-6: A simple client to replace SuperFunkyChat traffic</em></p>&#13;
<p class="indent">One new bit in this code is that each script gets a list of command line arguments in the <span class="literal">args</span> variable <span class="ent">➊</span>. By using command line arguments, we can specify different packet capture files without having to modify the script.</p>&#13;
<p class="indent">The <span class="literal">NetClientTemplate</span> is configured <span class="ent">➋</span> similarly to our proxy, making connections to 127.0.0.1:12345 but with a few differences to support the client. For example, because we parse the initial network traffic inside the <span class="literal">Parser</span> class, our capture file doesn’t contain the initial magic value that the client sends to the server. We add an <span class="literal">InitialData</span> array to the template with the magic bytes <span class="ent">➌</span> to correctly establish the connection.</p>&#13;
<p class="indent">We then read the packets from the file <span class="ent">➍</span> into a packet collection. When everything is configured, we call <span class="literal">Connect()</span> to establish a new connection to the server <span class="ent">➎</span>. The <span class="literal">Connect()</span> method returns a <span class="literal">Data Adapter</span> that allows us to read and write parsed packets on the connection. Any packet we read will also go through the <span class="literal">Parser</span> and remove the length and checksum fields.</p>&#13;
<p class="indent">Next, we filter the loaded packets to only outbound and write them to the network connection <span class="ent">➏</span>. The <span class="literal">Parser</span> class again ensures that any data packets we write have the appropriate headers attached before being sent to the server. Finally, we read out packets and print them to the console until the connection is closed or the read times out <span class="ent">➐</span>.</p>&#13;
<p class="indent">When you run this script, passing the path to the packets we captured earlier, it should connect to the server and replay your session. For example, any message sent in the original capture should be re-sent.</p>&#13;
<p class="indent">Of course, just replaying the original traffic isn’t necessarily that useful. It would be more useful to modify traffic to test features of the protocol, and now that we have a very simple client, we can modify the traffic by <span epub:type="pagebreak" id="page_186"/>adding some code to our send loop. For example, we might simply change our username in all packets to something else—say from <span class="literal">user1</span> to <span class="literal">bobsmith</span>—by replacing the inner code of the send loop (at <span class="ent">➏</span> in Listing 8-6) with the code shown in Listing 8-7.</p>&#13;
<p class="programs"><span class="ent">➊</span> string data = packet.Frame.ToDataString();<br/><span class="ent">➋</span> data = data.Replace("\u0005user1", "\u0008bobsmith");<br/>   adapter.Write(data.ToDataFrame());</p>&#13;
<p class="listing"><a id="ch8list7"/><em>Listing 8-7: A simple packet editor for the client</em></p>&#13;
<p class="indent">To edit the username, we first convert the packet into a format we can work with easily. In this case, we convert it to a binary string using the <span class="literal">ToDataString()</span> method <span class="ent">➊</span>, which results in a C# string where each byte is converted directly to the same character value. Because the strings in SuperFunkyChat are prefixed with their length, at <span class="ent">➋</span> we use the <span class="literal">\u<span class="codeitalic">XXXX</span></span> escape sequence to replace the byte 5 with 8 for the new length of the username. You can replace any nonprintable binary character in the same way, using the escape sequence for the byte values.</p>&#13;
<p class="indent">When you rerun the client, all instances of <span class="literal">user1</span> should be replaced with <span class="literal">bobsmith</span>. (Of course, you can do far more complicated packet modification at this point, but I’ll leave that for you to experiment with.)</p>&#13;
<h5 class="h5" id="ch00lev1sec222"><strong>Implementing a Simple Server</strong></h5>&#13;
<p class="noindent">We’ve implemented a simple client, but security issues can occur in both the client and server applications. So now we’ll implement a custom server similar to what we’ve done for the client.</p>&#13;
<p class="indent">First, we’ll implement a small class to act as our server code. This class will be created for every new connection. A <span class="literal">Run()</span> method in the class will get a <span class="literal">Data Adapter</span> object, essentially the same as the one we used for the client. Copy <a href="../Text/ch08.xhtml#ch8list8">Listing 8-8</a> into a file called <em>chat_server.csx</em>.</p>&#13;
<p class="literal"><span class="codeitalic">chat_server.csx</span></p>&#13;
<p class="programs">   using CANAPE.Nodes;<br/>   using CANAPE.DataAdapters;<br/>   using CANAPE.Net.Templates;<br/><br/><span class="ent">➊</span> class ChatServerConfig {<br/>       public LogPacketCollection Packets { get; private set; }<br/>       public ChatServerConfig() {<br/>           Packets = new LogPacketCollection();<br/>       }<br/>   }<br/><br/><span class="ent">➋</span> class ChatServer : BaseDataEndpoint&lt;ChatServerConfig&gt; {<br/>       public override void Run(IDataAdapter adapter, ChatServerConfig config) {<br/>           Console.WriteLine("New Connection");<br/>        <span class="ent">➌</span> DataFrame frame = adapter.Read();<br/>           // Wait for the client to send us the first packet<br/>           if (frame != null) {<br/><span epub:type="pagebreak" id="page_187"/><br/>               // Write all packets to client<br/>            <span class="ent">➍</span> foreach(var packet in config.Packets) {<br/>                   adapter.Write(packet.Frame);<br/>               }<br/>           }<br/>           frame = adapter.Read();<br/>       }<br/>   }</p>&#13;
<p class="listing"><a id="ch8list8"/><em>Listing 8-8: A simple server class for chat protocol</em></p>&#13;
<p class="indent">The code at <span class="ent">➊</span> is a configuration class that simply contains a log packet collection. We could have simplified the code by just specifying <span class="literal">LogPacketCollection</span> as the configuration type, but doing so with a distinct class demonstrates how you might add your own configuration more easily.</p>&#13;
<p class="indent">The code at <span class="ent">➋</span> defines the server class. It contains the <span class="literal">Run()</span> function, which takes a data adapter and the server configuration, and allows us to read and write to the data adapter after waiting for the client to send us a packet <span class="ent">➌</span>. Once we’ve received a packet, we immediately send our entire packet list to the client <span class="ent">➍</span>.</p>&#13;
<p class="indent">Note that we don’t filter the packets at <span class="ent">➍</span>, and we don’t specify that we’re using any particular parser for the network traffic. In fact, this entire class is completely agnostic to the SuperFunkyChat protocol. We configure much of the behavior for the network server inside a template, as shown in Listing 8-9.</p>&#13;
<p class="literal"><span class="codeitalic">chapter8</span><br/><span class="codeitalic">_example</span><br/><span class="codeitalic">_server.csx</span></p>&#13;
<p class="programs"><span class="ent">➊</span> #load "chat_server.csx"<br/>   #load "parser.csx"<br/>   using static System.Console;<br/><br/>   if (args.Length &lt; 1) {<br/>       WriteLine("Please Specify a Capture File");<br/>       return;<br/>   }<br/><span class="ent">➋</span> var template = new NetServerTemplate&lt;ChatServer, ChatServerConfig&gt;();<br/>   template.LocalPort = 12345;<br/>   template.AddLayer&lt;Parser&gt;();<br/><span class="ent">➌</span> var packets = LogPacketCollection.ReadFromFile(args[0])<br/>                                    .GetPacketsForTag("In");<br/>   template.ServerFactoryConfig.Packets.AddRange(packets);<br/><br/><span class="ent">➍</span> var service = template.Create();<br/>   service.Start();<br/>   WriteLine("Created {0}", service);<br/>   WriteLine("Press Enter to exit...");<br/>   ReadLine();<br/>   service.Stop();</p>&#13;
<p class="listing"><a id="ch8list9"/><em>Listing 8-9: A simple example ChatServer</em></p>&#13;
<p class="indent"><a href="../Text/ch08.xhtml#ch8list9">Listing 8-9</a> might look familiar because it’s very similar to the script we used for the DNS server in <a href="../Text/ch02.xhtml#ch2list11">Listing 2-11</a>. We begin by loading in the <em>chat_server.csx</em> script to define our ChatServer class <span class="ent">➊</span>. Next, we create a <span epub:type="pagebreak" id="page_188"/>server template at <span class="ent">➋</span> by specifying the type of the server and the configuration type. Then we load the packets from the file passed on the command line, filtering to capture only inbound packets and adding them to the packet collection in the configuration <span class="ent">➌</span>. Finally, we create a service and start it <span class="ent">➍</span>, just as we do proxies. The server is now listening for new connections on TCP port 12345.</p>&#13;
<p class="indent">Try the server with the ChatClient application; the captured traffic should be sent back to the client. After all the data has been sent to the client, the server will automatically close the connection. As long as you observe the message we re-sent, don’t worry if you see an error in the ChatClient’s output. Of course, you can add functionality to the server, such as modifying traffic or generating new packets.</p>&#13;
<h3 class="h3" id="ch00lev1sec223"><strong>Repurposing Existing Executable Code</strong></h3>&#13;
<p class="noindent">In this section, we’ll explore various ways to repurpose existing binary executable code to reduce the amount of work involved in implementing a protocol. Once you’ve determined a protocol’s details by reverse engineering the executable (perhaps using some tips from <a href="../Text/ch06.xhtml#ch06">Chapter 6</a>), you’ll quickly realize that if you can reuse the executable code, you’ll avoid having to implement the protocol.</p>&#13;
<p class="indent">Ideally, you’ll have the source code you’ll need to implement a particular protocol, either because it’s open source or the implementation is in a scripting language like Python. If you do have the source code, you should be able to recompile or directly reuse the code in your own application. However, when the code has been compiled into a binary executable, your options can be more limited. We’ll look at each scenario now.</p>&#13;
<p class="indent">Managed language platforms, such as .NET and Java, are by far the easiest in which to reuse existing executable code, because they have a well-defined metadata structure in compiled code that allows a new application to be compiled against internal classes and methods. In contrast, in many unmanaged platforms, such as C/C++, the compiler will make no guarantees that any component inside a binary executable can be easily called externally.</p>&#13;
<p class="indent">Well-defined metadata also supports <em>reflection</em>, which is the ability of an application to support late binding of executable code to inspect data at runtime and to execute arbitrary methods. Although you can easily decompile many managed languages, it may not always be convenient to do so, especially when dealing with obfuscated applications. This is because the obfuscation can prevent reliable decompilation to usable source code.</p>&#13;
<p class="indent">Of course, the parts of the executable code you’ll need to execute will depend on the application you’re analyzing. In the sections that follow, I’ll detail some coding patterns and techniques to use to call the appropriate parts of the code in .NET and Java applications, the platforms you’re most likely to encounter.</p>&#13;
<h4 class="h4" id="ch00lev1sec224"><span epub:type="pagebreak" id="page_189"/><strong><em>Repurposing Code in .NET Applications</em></strong></h4>&#13;
<p class="noindent">As discussed in <a href="../Text/ch06.xhtml#ch06">Chapter 6</a>, .NET applications are made up of one or more assemblies, which can be either an executable (with an .<em>exe</em> extension) or a library (.<em>dll</em>). When it comes to repurposing existing code, the form of the assembly doesn’t matter because we can call methods in both equally.</p>&#13;
<p class="indent">Whether we can just compile our code against the assembly’s code will depend on the visibility of the types we’re trying to use. The .NET platform supports different visibility scopes for types and members. The three most important forms of visibility scope are public, private, and internal. Public types or members are available to all callers outside the assembly. Private types or members are limited in scope to the current type (for example, you can have a private class inside a public class). Internal visibility scopes the types or members to only callers inside the same assembly, where they act as if they were public (although an external call cannot compile against them). For example, consider the C# code in Listing 8-10.</p>&#13;
<p class="programs"><span class="ent">➊</span> public class PublicClass<br/>   {<br/>     private class PrivateClass<br/>     {<br/>    <span class="ent">➋</span> public PrivatePublicMethod() {}<br/>     }<br/>     internal class InternalClass<br/>     {<br/>    <span class="ent">➌</span> public void InternalPublicMethod() {}<br/>     }<br/>     private void PrivateMethod() {}<br/>     internal void InternalMethod() {}<br/>   <span class="ent">➍</span> public void PublicMethod() {}<br/>   }</p>&#13;
<p class="listing"><a id="ch8list10"/><em>Listing 8-10: Examples of .NET visibility scopes</em></p>&#13;
<p class="indent"><a href="../Text/ch08.xhtml#ch8list10">Listing 8-10</a> defines a total of three classes: one public, one private, and one internal. When you compile against the assembly containing these types, only <span class="literal">PublicClass</span> can be directly accessed along with the class’s <span class="literal">PublicMethod()</span> (indicated by <span class="ent">➊</span> and <span class="ent">➍</span>); attempting to access any other type or member will generate an error in the compiler. But notice at <span class="ent">➋</span> and <span class="ent">➌</span> that public members are defined. Can’t we also access those members? Unfortunately, no, because these members are contained inside the scope of a <span class="literal">PrivateClass</span> or <span class="literal">InternalClass</span>. The class’s scope takes precedence over the members’ visibility.</p>&#13;
<p class="indent">Once you’ve determined whether all the types and members you want to use are public, you can add a reference to the assembly when compiling. If you’re using an IDE, you should find a method that allows you to add this reference to your project. But if you’re compiling on the command line using Mono or the Windows .NET framework, you’ll need to specify the <span class="literal">-reference:&lt;<span class="codeitalic">FILEPATH</span>&gt;</span> option to the appropriate C# compiler, CSC or MCS.</p>&#13;
<h5 class="h5" id="ch00lev1sec225"><span epub:type="pagebreak" id="page_190"/><strong>Using the Reflection APIs</strong></h5>&#13;
<p class="noindent">If all the types and members are not public, you’ll need to use the .NET framework’s Reflection APIs. You’ll find most of these in the <span class="literal">System.Reflection</span> namespace, except for the <span class="literal">Type</span> class, which is under the <span class="literal">System</span> namespace. <a href="../Text/ch08.xhtml#ch8tab1">Table 8-1</a> lists the most important classes with respect to reflection functionality.</p>&#13;
<p class="tabcap"><a id="ch8tab1"/><strong>Table 8-1:</strong> .NET Reflection Types</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Class name</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">System.Type</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a single type in an assembly and allows access to information about its members</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">System.Reflection.Assembly</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Allows access to loading and inspecting an assembly as well as enumerating available types</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">System.Reflection.MethodInfo</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a method in a type</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">System.Reflection.FieldInfo</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a field in a type</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">System.Reflection.PropertyInfo</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a property in a type</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">System.Reflection.ConstructorInfo</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a class’s constructor</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch00lev1sec226"><strong>Loading the Assembly</strong></h5>&#13;
<p class="noindent">Before you can do anything with the types and members, you’ll need to load the assembly using the <span class="literal">Load()</span> or the <span class="literal">LoadFrom()</span> method on the <span class="literal">Assembly</span> class. The <span class="literal">Load()</span> method takes an <em>assembly name</em>, which is an identifier for the assembly that assumes the assembly file can be found in the same location as the calling application. The <span class="literal">LoadFrom()</span> method takes the path to the assembly file.</p>&#13;
<p class="indent">For the sake of simplicity, we’ll use <span class="literal">LoadFrom()</span>, which you can use in most cases. <a href="../Text/ch08.xhtml#ch8list11">Listing 8-11</a> shows a simple example of how you might load an assembly from a file and extract a type by name.</p>&#13;
<p class="programs">Assembly asm = Assembly.LoadFrom(@"c:\path\to\assembly.exe");<br/>Type type = asm.GetType("ChatProgram.Connection");</p>&#13;
<p class="listing"><a id="ch8list11"/><em>Listing 8-11: A simple assembly loading example</em></p>&#13;
<p class="indent">The name of the type is always the fully qualified name including its namespace. For example, in <a href="../Text/ch08.xhtml#ch8list11">Listing 8-11</a>, the name of the type being accessed is <span class="literal">Connection</span> inside the <span class="literal">ChatProgram</span> namespace. Each part of the type name is separated by periods.</p>&#13;
<p class="indent">How do you access classes that are declared inside other classes, such as those shown in <a href="../Text/ch08.xhtml#ch8list10">Listing 8-10</a>? In C#, you access these by specifying the parent class name and the child class name separated by periods. The framework is able to differentiate between <span class="literal">ChatProgram.Connection</span>, where we want the class <span class="literal">Connection</span> in namespace <span class="literal">ChatProgram</span>, and the child class <span class="literal">Connection</span> inside the class <span class="literal">ChatProgram</span> by using a plus (<span class="literal">+</span>) symbol: <span class="literal">ChatProgram+Connection</span> represents a parent/child class relationship.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_191"/><a href="../Text/ch08.xhtml#ch8list12">Listing 8-12</a> shows a simple example of how we might create an instance of an internal class and call methods on it. We’ll assume that the class is already compiled into its own assembly.</p>&#13;
<p class="programs">internal class Connection<br/>{<br/>  internal Connection() {}<br/><br/>  public void Connect(string hostname)<br/>  {<br/>    Connect(hostname, 12345);<br/>  }<br/><br/>  private void Connect(string hostname, int port)<br/>  {<br/>    // Implementation...<br/>  }<br/><br/>  public void Send(byte[] packet)<br/>  {<br/>    // Implementation...<br/>  }<br/><br/>  public void Send(string packet)<br/>  {<br/>    // Implementation...<br/>  }<br/><br/>  public byte[] Receive()<br/>  {<br/>    // Implementation...<br/>  }<br/>}</p>&#13;
<p class="listing"><a id="ch8list12"/><em>Listing 8-12: A simple C# example class</em></p>&#13;
<p class="indent">The first step we need to take is to create an instance of this <span class="literal">Connection</span> class. We could do this by calling <span class="literal">GetConstructor</span> on the type and calling it manually, but sometimes there’s an easier way. One way would be to use the built-in <span class="literal">System.Activator</span> class to handle creating instances of types for us, at least in very simple scenarios. In such a scenario, we call the method <span class="literal">CreateInstance()</span>, which takes an instance of the type to create and a Boolean value that indicates whether the constructor is public or not. Because the constructor is not public (it’s internal), we need to pass <span class="literal">true</span> to get the activator to find the right constructor.</p>&#13;
<p class="indent"><a href="../Text/ch08.xhtml#ch8list13">Listing 8-13</a> shows how to create a new instance, assuming a nonpublic parameterless constructor.</p>&#13;
<p class="programs">Type type = asm.GetType("ChatProgram.Connection");<br/>object conn = Activator.CreateInstance(type, true);</p>&#13;
<p class="listing"><a id="ch8list13"/><em>Listing 8-13: Constructing a new instance of the <span class="literal"><span class="codeitalic">Connection</span></span> object</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_192"/>At this point, we would call the public <span class="literal">Connect()</span> method.</p>&#13;
<p class="indent">In the possible methods of the <span class="literal">Type</span> class, you’ll find the <span class="literal">GetMethod()</span> method, which just takes the name of the method to look up and returns an instance of a <span class="literal">MethodInfo</span> type. If the method cannot be found, null is returned. Listing 8-14 shows how to execute the method by calling the <span class="literal">Invoke()</span> method on <span class="literal">MethodInfo</span>, passing the instance of the object to execute it on and the parameters to pass to the method.</p>&#13;
<p class="programs">MethodInfo connect_method = type.GetMethod("Connect");<br/>connect_method.Invoke(conn, new object[] { "host.badgers.com" });</p>&#13;
<p class="listing"><a id="ch8list14"/><em>Listing 8-14: Executing a method on a <span class="literal"><span class="codeitalic">Connection</span></span> object</em></p>&#13;
<p class="indent">The simplest form of <span class="literal">GetMethod()</span> takes as a parameter the name of the method to find, but it will look for only public methods. If instead you want to call the private <span class="literal">Connect()</span> method to be able to specify an arbitrary TCP port, use one of the various overloads of <span class="literal">GetMethod()</span>. These overloads take a <span class="literal">BindingFlags</span> enumeration value, which is a set of flags you can pass to reflection functions to determine what sort of information you want to look up. <a href="../Text/ch08.xhtml#ch8tab2">Table 8-2</a> shows some important flags.</p>&#13;
<p class="tabcap"><a id="ch8tab2"/><strong>Table 8-2:</strong> Important .NET Reflection Binding Flags</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Flag name</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">BindingFlags.Public</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Look up public members</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">BindingFlags.NonPublic</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Look up nonpublic members (internal or private)</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">BindingFlags.Instance</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Look up members that can only be used on an instance of the class</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">BindingFlags.Static</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Look up members that can be accessed statically without an instance</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">To get a <span class="literal">MethodInfo</span> for the private method, we can use the overload of <span class="literal">GetMethod()</span>, as shown in <a href="../Text/ch08.xhtml#ch8list15">Listing 8-15</a>, which takes a name and the binding flags. We’ll need to specify both <span class="literal">NonPublic</span> and <span class="literal">Instance</span> in the flags because we want a nonpublic method that can be called on instances of the type.</p>&#13;
<p class="programs">MethodInfo connect_method = type.GetMethod("Connect",<br/>                                   BindingFlags.NonPublic | BindingFlags.Instance);<br/>connect_method.Invoke(conn, new object[] { "host.badgers.com", 9999 });</p>&#13;
<p class="listing"><a id="ch8list15"/><em>Listing 8-15: Calling a nonpublic <span class="literal"><span class="codeitalic">Connect()</span></span> method</em></p>&#13;
<p class="indent">So far so good. Now we need to call the <span class="literal">Send()</span> method. Because this method is public, we should be able to call the basic <span class="literal">GetMethod()</span> method. But calling the basic method generates the exception shown in Listing 8-16, indicating an ambiguous match. What’s gone wrong?</p>&#13;
<p class="programs">System.Reflection.AmbiguousMatchException: Ambiguous match found.<br/>   at System.RuntimeType.GetMethodImpl(...)<br/><span epub:type="pagebreak" id="page_193"/><br/>   at System.Type.GetMethod(String name)<br/>   at Program.Main(String[] args)</p>&#13;
<p class="listing"><a id="ch8list16"/><em>Listing 8-16: An exception thrown for the <span class="literal"><span class="codeitalic">Send()</span></span> method</em></p>&#13;
<p class="indent">Notice in <a href="../Text/ch08.xhtml#ch8list12">Listing 8-12</a> the <span class="literal">Connection</span> class has two <span class="literal">Send()</span> methods: one takes an array of bytes and the other takes a string. Because the reflection API doesn’t know which method you want, it doesn’t return a reference to either; instead, it just throws an exception. Contrast this with the <span class="literal">Connect()</span> method, which worked because the binding flags disambiguate the call. If you’re looking up a public method with the name <span class="literal">Connect()</span>, the reflection APIs will not even inspect the nonpublic overload.</p>&#13;
<p class="indent">We can get around this error by using yet another overload of <span class="literal">GetMethod()</span> that specifies exactly the types we want the method to support. We’ll choose the method that takes a string, as shown in <a href="../Text/ch08.xhtml#ch8list17">Listing 8-17</a>.</p>&#13;
<p class="programs">MethodInfo send_method = type.GetMethod("Send", new Type[] { typeof(string) });<br/>send_method.Invoke(conn, new object[] { "data" });</p>&#13;
<p class="listing"><a id="ch8list17"/><em>Listing 8-17: Calling the <span class="literal"><span class="codeitalic">Send(string)</span></span> method</em></p>&#13;
<p class="indent">Finally, we can call the <span class="literal">Receive()</span> method. It’s public, so there are no additional overloads and it should be simple. Because <span class="literal">Receive()</span> takes no parameters, we can either pass an empty array or null to <span class="literal">Invoke()</span>. Because <span class="literal">Invoke()</span> returns an <em>object</em>, we need to cast the return value to a byte array to access the bytes directly. <a href="../Text/ch08.xhtml#ch8list18">Listing 8-18</a> shows the final implementation.</p>&#13;
<p class="programs">MethodInfo recv_method = type.GetMethod("Receive");<br/>byte[] packet = (byte[])recv_method.Invoke(conn, null);</p>&#13;
<p class="listing"><a id="ch8list18"/><em>Listing 8-18: Calling the <span class="literal"><span class="codeitalic">Receive()</span></span> method</em></p>&#13;
<h4 class="h4" id="ch00lev1sec227"><strong><em>Repurposing Code in Java Applications</em></strong></h4>&#13;
<p class="noindent">Java is fairly similar to .NET, so I’ll just focus on the difference between them, which is that Java does not have the concept of an assembly. Instead, each class is represented by a separate <em>.class</em> file. Although you can combine class files into a Java Archive (JAR) file, it is just a convenience feature. For that reason, Java does not have internal classes that can only be accessed by other classes in the same assembly. However, Java does have a somewhat similar feature called <em>package-private</em> scoped classes, which can only be accessed by classes in the same package. (.NET refers to packages as a <em>namespace</em>.)</p>&#13;
<p class="indent">The upshot of this feature is that if you want to access classes marked as package scoped, you can write some Java code that defines itself in the same package, which can then access the package-scoped classes and members at will. For example, <a href="../Text/ch08.xhtml#ch8list19">Listing 8-19</a> shows a package-private class that would be defined in the library you want to call and a simple bridge class you can compile into your own application to create an instance of the class.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_194"/><br/>// Package-private (PackageClass.java)<br/>package com.example;<br/><br/>class PackageClass {<br/>    PackageClass() {<br/>    }<br/><br/>    PackageClass(String arg) {<br/>    }<br/><br/><br/>    @Override<br/>    public String toString() {<br/>        return "In Package";<br/>    }<br/>}<br/><br/>// Bridge class (BridgeClass.java)<br/>package com.example;<br/><br/>public class BridgeClass {<br/>    public static Object create() {<br/>        return new PackageClass();<br/>    }<br/>}</p>&#13;
<p class="listing"><a id="ch8list19"/><em>Listing 8-19: Implementing a bridge class to access a package-private class</em></p>&#13;
<p class="indent">You specify the existing class or JAR files by adding their locations to the Java classpath, typically by specifying the <span class="literal">-classpath</span> parameter to the Java compiler or Java runtime executable.</p>&#13;
<p class="indent">If you need to call Java classes by reflection, the core Java reflection types are very similar to those described in the preceding .NET section: <em>Type</em> in .NET is <em>class</em> in Java, <span class="literal">MethodInfo</span> is <span class="literal">Method</span>, and so on. <a href="../Text/ch08.xhtml#ch8tab3">Table 8-3</a> contains a short list of Java reflection types.</p>&#13;
<p class="tabcap"><a id="ch8tab3"/><strong>Table 8-3:</strong> Java Reflection Types</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Class name</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">java.lang.Class</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a single class and allows access to its members</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">java.lang.reflect.Method</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a method in a type</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">java.lang.reflect.Field</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a field in a type</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">java.lang.reflect.Constructor</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Represents a class’s constructor</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can access a class object by name by calling the <span class="literal">Class.forName()</span> method. For example, <a href="../Text/ch08.xhtml#ch8list20">Listing 8-20</a> shows how we would get the <span class="literal">PackageClass</span>.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_195"/><br/>Class c = Class.forName("com.example.PackageClass");<br/>System.out.println(c);</p>&#13;
<p class="listing"><a id="ch8list20"/><em>Listing 8-20: Getting a class in Java</em></p>&#13;
<p class="indent">If we want to create an instance of a public class with a parameterless constructor, the <span class="literal">Class</span> instance has a <span class="literal">newInstance()</span> method. This won’t work for our package-private class, so instead we’ll get an instance of the <span class="literal">Constructor</span> by calling <span class="literal">getDeclaredConstructor()</span> on the <span class="literal">Class</span> instance. We need to pass a list of <span class="literal">Class</span> objects to <span class="literal">getDeclaredConstructor()</span> to select the correct Constructor based on the types of parameters the constructor accepts. <a href="../Text/ch08.xhtml#ch8list21">Listing 8-21</a> shows how we would choose the constructor, which takes a string, and then create a new instance.</p>&#13;
<p class="programs">   Constructor con = c.getDeclaredConstructor(String.class);<br/><span class="ent">➊</span> con.setAccessible(true);<br/>   Object obj = con.newInstance("Hello");</p>&#13;
<p class="listing"><a id="ch8list21"/><em>Listing 8-21: Creating a new instance from a private constructor</em></p>&#13;
<p class="indent">The code in <a href="../Text/ch08.xhtml#ch8list21">Listing 8-21</a> should be fairly self-explanatory except perhaps for the line at <span class="ent">➊</span>. In Java, any nonpublic member, whether a constructor, field, or method, must be set as accessible before you use it. If you don’t call <span class="literal">setAccessible()</span> with the value <span class="literal">true</span>, then calling <span class="literal">newInstance()</span> will throw an exception.</p>&#13;
<h4 class="h4" id="ch00lev1sec228"><strong><em>Unmanaged Executables</em></strong></h4>&#13;
<p class="noindent">Calling arbitrary code in most unmanaged executables is much more difficult than in managed platforms. Although you can call a pointer to an internal function, there’s a reasonable chance that doing so could crash your application. However, you can reasonably call the unmanaged implementation when it’s explicitly exposed through a dynamic library. This section offers a brief overview of using the built-in Python library ctypes to call an unmanaged library on a Unix-like platform and Microsoft Windows.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There are many complicated scenarios that involve calling into unmanaged code using the Python ctypes library, such as passing string values or calling C++ functions. You can find several detailed resources online, but this section should give you enough basics to interest you in learning more about how to use Python to call unmanaged libraries.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec229"><strong>Calling Dynamic Libraries</strong></h5>&#13;
<p class="noindent">Linux, macOS, and Windows support dynamic libraries. Linux calls them object files (.<em>so</em>), macOS calls them dynamic libraries (.<em>dylib</em>), and Windows calls them dynamic link libraries (.<em>dll</em>). The Python ctypes library provides a mostly generic way to load all of these libraries into memory and a consistent <span epub:type="pagebreak" id="page_196"/>syntax for defining how to call the exported function. Listing 8-22 shows a simple library written in C, which we’ll use as an example throughout the rest of the section.</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>#include &lt;wchar.h&gt;<br/><br/>void say_hello(void) {<br/>  printf("Hello\n");<br/>}<br/><br/>void say_string(const char* str) {<br/>  printf("%s\n", str);<br/>}<br/><br/>void say_unicode_string(const wchar_t* ustr) {<br/>  printf("%ls\n", ustr);<br/>}<br/><br/>const char* get_hello(void) {<br/>  return "Hello from C";<br/>}<br/><br/>int add_numbers(int a, int b) {<br/>  return a + b;<br/>}<br/><br/>long add_longs(long a, long b) {<br/>  return a + b;<br/>}<br/><br/>void add_numbers_result(int a, int b, int* c) {<br/>  *c = a + b;<br/>}<br/><br/>struct SimpleStruct<br/>{<br/>  const char* str;<br/>  int num;<br/>};<br/><br/>void say_struct(const struct SimpleStruct* s) {<br/>  printf("%s %d\n", s-&gt;str, s-&gt;num);<br/>}</p>&#13;
<p class="listing"><a id="ch8list22"/><em>Listing 8-22: The example C library</em> lib.c</p>&#13;
<p class="indent">You can compile the code in <a href="../Text/ch08.xhtml#ch8list22">Listing 8-22</a> into an appropriate dynamic library for the platform you’re testing. For example, on Linux you can compile the library by installing a C compiler, such as GCC, and executing the following command in the shell, which will generate a shared library <em>lib.so</em>:</p>&#13;
<p class="programs">gcc -shared -fPIC -o lib.so lib.c</p>&#13;
<h5 class="h5" id="ch00lev1sec230"><span epub:type="pagebreak" id="page_197"/><strong>Loading a Library with Python</strong></h5>&#13;
<p class="noindent">Moving to Python, we can load our library using the <span class="literal">ctypes.cdll.LoadLibrary()</span> method, which returns an instance of a loaded library with the exported functions attached to the instance as named methods. For example, Listing 8-23 shows how to call the <span class="literal">say_hello()</span> method from the library compiled in Listing 8-22.</p>&#13;
<p class="literal"><span class="codeitalic">listing8-23.py</span></p>&#13;
<p class="programs">from ctypes import *<br/><br/># On Linux<br/>lib = cdll.LoadLibrary("./lib.so")<br/># On macOS<br/>#lib = cdll.LoadLibrary("lib.dylib")<br/># On Windows<br/>#lib = cdll.LoadLibrary("lib.dll")<br/># Or we can do the following on Windows<br/>#lib = cdll.lib<br/><br/>lib.say_hello()<br/>&gt;&gt;&gt; Hello</p>&#13;
<p class="listing"><a id="ch8list23"/><em>Listing 8-23: A simple Python example for calling a dynamic library</em></p>&#13;
<p class="indent">Note that in order to load the library on Linux, you need to specify a path. Linux by default does not include the current directory in the library search order, so loading <em>lib.so</em> would fail. That is not the case on macOS or on Windows. On Windows, you can simply specify the name of the library after <em>cdll</em> and it will automatically add the <em>.dll</em> extension and load the library.</p>&#13;
<p class="indent">Let’s do some exploring. Load <a href="../Text/ch08.xhtml#ch8list23">Listing 8-23</a> into a Python shell, for example, by running <span class="literal">execfile("listing8-23.py")</span>, and you’ll see that <span class="literal">Hello</span> is returned. Keep the interactive session open for the next section.</p>&#13;
<h5 class="h5" id="ch00lev1sec231"><strong>Calling More Complicated Functions</strong></h5>&#13;
<p class="noindent">It’s easy enough to call a simple method, such as <span class="literal">say_hello()</span>, as in Listing 8-23. But in this section, we’ll look at how to call slightly more complicated functions including unmanaged functions, which take multiple different arguments.</p>&#13;
<p class="indent">Wherever possible, ctypes will attempt to determine what parameters are passed to the function automatically based on the parameters you pass in the Python script. Also, the library will always assume that the return type of a method is a C integer. For example, <a href="../Text/ch08.xhtml#ch8list24">Listing 8-24</a> shows how to call the <span class="literal">add_numbers()</span> or <span class="literal">say_string()</span> methods along with the expected output from the interactive session.</p>&#13;
<p class="programs">print lib.add_numbers(1, 2)<br/>&gt;&gt;&gt; 3<br/><span epub:type="pagebreak" id="page_198"/><br/>lib.say_string("Hello from Python");<br/>&gt;&gt;&gt; Hello from Python</p>&#13;
<p class="listing"><a id="ch8list24"/><em>Listing 8-24: Calling simple methods</em></p>&#13;
<p class="indent">More complex methods require the use of ctypes data types to explicitly specify what types we want to use as defined in the ctypes namespace. <a href="../Text/ch08.xhtml#ch8tab4">Table 8-4</a> shows some of the more common data types.</p>&#13;
<p class="tabcap"><a id="ch8tab4"/><strong>Table 8-4:</strong> Python ctypes and Their Native C Type Equivalent</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Python ctypes</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Native C types</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_char</span>, <span class="literal">c_wchar</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">char, wchar_t</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_byte</span>, <span class="literal">c_ubyte</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">char, unsigned char</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_short</span>, <span class="literal">c_ushort</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">short, unsigned short</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_int</span>, <span class="literal">c_uint</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">int, unsigned int</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_long</span>, <span class="literal">c_ulong</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">long, unsigned long</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_longlong</span>, <span class="literal">c_ulonglong</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">long long, unsigned long long (typically 64 bit)</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_float</span>, <span class="literal">c_double</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">float, double</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_char_p</span>, <span class="literal">c_wchar_p</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">char*, wchar_t* (NUL terminated strings)</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><span class="literal">c_void_p</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">void* (generic pointer)</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">To specify the return type, we can assign a data type to the <span class="literal">lib.name.restype</span> property. For example, <a href="../Text/ch08.xhtml#ch8list25">Listing 8-25</a> shows how to call <span class="literal">get_hello()</span>, which returns a pointer to a string.</p>&#13;
<p class="programs"># Before setting return type<br/>print lib.get_hello()<br/>&gt;&gt;&gt; -1686370079<br/><br/># After setting return type<br/>lib.get_hello.restype = c_char_p<br/>print lib.get_hello()<br/>&gt;&gt;&gt; Hello from C</p>&#13;
<p class="listing"><a id="ch8list25"/><em>Listing 8-25: Calling a method that returns a C string</em></p>&#13;
<p class="indent">If instead you want to specify the arguments to be passed to a method, you can set an array of data types to the <span class="literal">argtypes</span> property. For example, <a href="../Text/ch08.xhtml#ch8list26">Listing 8-26</a> shows how to call <span class="literal">add_longs()</span> correctly.</p>&#13;
<p class="programs"># Before argtypes<br/>lib.add_longs.restype = c_long<br/>print lib.add_longs(0x100000000, 1)<br/>&gt;&gt;&gt; 1<br/><br/># After argtypes<br/>lib.add_longs.argtypes = [c_long, c_long]<br/><span epub:type="pagebreak" id="page_199"/><br/>print lib.add_longs(0x100000000, 1)<br/>&gt;&gt;&gt; 4294967297</p>&#13;
<p class="listing"><a id="ch8list26"/><em>Listing 8-26: Specifying <span class="literal"><span class="codeitalic">argtypes</span></span> for a method call</em></p>&#13;
<p class="indent">To pass a parameter via a pointer, use the <span class="literal">byref</span> helper. For example, <span class="literal">add_numbers_result()</span> returns the value as a pointer to an integer, as shown in <a href="../Text/ch08.xhtml#ch8list27">Listing 8-27</a>.</p>&#13;
<p class="programs">i = c_int()<br/>lib.add_numbers_result(1, 2, byref(i))<br/>print i.value<br/>&gt;&gt;&gt; 3</p>&#13;
<p class="listing"><a id="ch8list27"/><em>Listing 8-27: Calling a method with a reference parameter</em></p>&#13;
<h5 class="h5" id="ch00lev1sec232"><strong>Calling a Function with a Structure Parameter</strong></h5>&#13;
<p class="noindent">We can define a structure for ctypes by creating a class derived from the <span class="literal">Structure</span> class and assigning the <span class="literal">_fields_ property</span>, and then pass the structure to the imported method. <a href="../Text/ch08.xhtml#ch8list28">Listing 8-28</a> shows how to do this for the <span class="literal">say_struct()</span> function, which takes a pointer to a structure containing a string and a number.</p>&#13;
<p class="programs">class SimpleStruct(Structure):<br/>  _fields_ = [("str", c_char_p),<br/>              ("num", c_int)]<br/><br/>s = SimpleStruct()<br/>s.str = "Hello from Struct"<br/>s.num = 100<br/>lib.say_struct(byref(s))<br/>&gt;&gt;&gt; Hello from Struct 100</p>&#13;
<p class="listing"><a id="ch8list28"/><em>Listing 8-28: Calling a method taking a structure</em></p>&#13;
<h5 class="h5" id="ch00lev1sec233"><strong>Calling Functions with Python on Microsoft Windows</strong></h5>&#13;
<p class="noindent">In this section, information on calling unmanaged libraries on Windows is specific to 32-bit Windows. As discussed in <a href="../Text/ch06.xhtml#ch06">Chapter 6</a>, Windows API calls can specify a number of different calling conventions, the most common being <em>stdcall</em> and <em>cdecl</em>. By using <em>cdll</em>, all calls assume that the function is <em>cdecl</em>, but the property <em>windll</em> defaults instead to <em>stdcall</em>. If a DLL exports both <em>cdecl</em> and <em>stdcall</em> methods, you can mix calls through <em>cdll</em> and <em>windll</em> as necessary.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll need to consider more calling scenarios using the Python ctypes library, such as how to pass back strings or call C++ functions. You can find many detailed resources online, but this section should have given you enough basics to interest you in learning more about how to use Python to call unmanaged libraries.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec234"><span epub:type="pagebreak" id="page_200"/><strong>Encryption and Dealing with TLS</strong></h3>&#13;
<p class="noindent">Encryption on network protocols can make it difficult for you to perform protocol analysis and reimplement the protocol to test for security issues. Fortunately, most applications don’t roll their own cryptography. Instead, they utilize a version of TLS, as described at the end of <a href="../Text/ch07.xhtml#ch07">Chapter 7</a>. Because TLS is a known quantity, we can often remove it from a protocol or reimplement it using standard tools and libraries.</p>&#13;
<h4 class="h4" id="ch00lev1sec235"><strong><em>Learning About the Encryption In Use</em></strong></h4>&#13;
<p class="noindent">Perhaps unsurprisingly, SuperFunkyChat has support for a TLS endpoint, although you need to configure it by passing the path to a server certificate. The binary distribution of SuperFunkyChat comes with a <em>server.pfx</em> for this purpose. Restart the <span class="literal">ChatServer</span> application with the <span class="literal">--server_cert</span> parameter, as shown in <a href="../Text/ch08.xhtml#ch8list29">Listing 8-29</a>, and observe the output to ensure that TLS has been enabled.</p>&#13;
<p class="programs">$ <span class="codestrong">ChatServer  --server_cert ChatServer/server.pfx</span><br/>ChatServer (c) 2017 James Forshaw<br/>WARNING: Don't use this for a real chat system!!!<br/>Loaded certificate, Subject=CN=ExampleChatServer<span class="ent">➊</span><br/>Running server on port 12345 Global Bind False<br/>Running TLS server on port 12346<span class="ent">➋</span> Global Bind False</p>&#13;
<p class="listing"><a id="ch8list29"/><em>Listing 8-29: Running ChatServer with a TLS certificate</em></p>&#13;
<p class="indent">Two indications in the output of <a href="../Text/ch08.xhtml#ch8list29">Listing 8-29</a> show that TLS has been enabled. First, the subject name of the server certificate is shown at <span class="ent">➊</span>. Second, you can see that TLS server is listening on port 12346 <span class="ent">➋</span>.</p>&#13;
<p class="indent">There’s no need to specify the port number when connecting the client using TLS with the <span class="literal">--tls</span> parameter: the client will automatically increment the port number to match. <a href="../Text/ch08.xhtml#ch8list30">Listing 8-30</a> shows how when you add the <span class="literal">--tls</span> command line parameter to the client, it displays basic information about the connection to the console.</p>&#13;
<p class="programs">   $ <span class="codestrong">ChatClient -–tls user1 127.0.0.1</span><br/>   Connecting to 127.0.0.1:12346<br/><span class="ent">➊</span> TLS Protocol: TLS v1.2<br/><span class="ent">➋</span> TLS KeyEx   : RsaKeyX<br/><span class="ent">➌</span> TLS Cipher  : Aes256<br/><span class="ent">➍</span> TLS Hash    : Sha384<br/><span class="ent">➎</span> Cert Subject: CN=ExampleChatServer<br/><span class="ent">➏</span> Cert Issuer : CN=ExampleChatServer</p>&#13;
<p class="listing"><a id="ch8list30"/><em>Listing 8-30: A normal client connection</em></p>&#13;
<p class="indent">In this output, the TLS protocol in use is shown at <span class="ent">➊</span> as TLS 1.2. We can also see the key exchange <span class="ent">➋</span>, cipher <span class="ent">➌</span>, and hash algorithms <span class="ent">➍</span> negotiated. At <span class="ent">➎</span>, we see some information about the server certificate, including the name of the Cert Subject, which typically represents the certificate owner. The Cert Issuer <span class="ent">➏</span> is the authority that signed the server’s certificate, and it’s <span epub:type="pagebreak" id="page_201"/>the next certificate in the chain, as described in “<a href="../Text/ch07.xhtml#ch00lev1sec205">Public Key Infrastructure</a>” on <a href="../Text/ch07.xhtml#page_169">page 169</a>. In this case, the Cert Subject and Cert Issuer are the same, which typically means the certificate is self-signed.</p>&#13;
<h4 class="h4" id="ch00lev1sec236"><strong><em>Decrypting the TLS Traffic</em></strong></h4>&#13;
<p class="noindent">A common technique to decrypt the TLS traffic is to actively use a man-in-the-middle attack on the network traffic so you can decrypt the TLS from the client and reencrypt it when sending it to the server. Of course, in the middle, you can manipulate and observe the traffic all you like. But aren’t man-in-the-middle attacks exactly what TLS is supposed to protect against? Yes, but as long as we control the client application sufficiently well, we can usually perform this attack for testing purposes.</p>&#13;
<p class="indent">Adding TLS support to a proxy (and therefore to servers and clients, as discussed earlier in this chapter) can be a simple matter of adding a single line or two to the proxy script to add a TLS decryption and encryption layer. <a href="../Text/ch08.xhtml#ch8fig1">Figure 8-1</a> shows a simple example of such a proxy.</p>&#13;
<div class="image"><img alt="image" src="../Images/f08-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch8fig1"/><em>Figure 8-1: An example MITM TLS proxy</em></p>&#13;
<p class="indent">We can implement the attack shown in <a href="../Text/ch08.xhtml#ch8fig1">Figure 8-1</a> by replacing the template initialization in <a href="../Text/ch08.xhtml#ch8list5">Listing 8-5</a> with the code in <a href="../Text/ch08.xhtml#ch8list31">Listing 8-31</a>.</p>&#13;
<p class="programs">   var template = new FixedProxyTemplate();<br/>   // Local port of 4445, destination 127.0.0.1:12346<br/><span class="ent">➊</span> template.LocalPort = 4445;<br/>   template.Host = "127.0.0.1";<br/>   template.Port = 12346;<br/><br/>   var tls = new TlsNetworkLayerFactory();<br/><span class="ent">➋</span> template.AddLayer(tls);<br/>   template.AddLayer&lt;Parser&gt;();</p>&#13;
<p class="listing"><a id="ch8list31"/><em>Listing 8-31: Adding TLS support to capture a proxy</em></p>&#13;
<p class="indent">We make two important changes to the template initialization. At <span class="ent">➊</span>, we increment port numbers because the client automatically adds 1 to the port when trying to connect over TLS. Then at <span class="ent">➋</span>, we add a TLS network <span epub:type="pagebreak" id="page_202"/>layer to the proxy template. (Be sure to add the TLS layer before the parser layer, or the parser layer will try to parse the TLS network traffic, which won’t work so well.)</p>&#13;
<p class="indent">With the proxy in place, let’s repeat our test with the client from Listing 8-31 to see the differences. <a href="../Text/ch08.xhtml#ch8list32">Listing 8-32</a> shows the output.</p>&#13;
<p class="programs">   C:\&gt; <span class="codestrong">ChatClient user1 127.0.0.1 --port 4444 -l</span><br/>   Connecting to 127.0.0.1:4445<br/><span class="ent">➊</span> TLS Protocol: TLS v1.0<br/><span class="ent">➋</span> TLS KeyEx   : ECDH<br/>   TLS Cipher  : Aes256<br/>   TLS Hash    : Sha1<br/>   Cert Subject: CN=ExampleChatServer<br/><span class="ent">➌</span> Cert Issuer : CN=BrokenCA_PleaseFix</p>&#13;
<p class="listing"><a id="ch8list32"/><em>Listing 8-32: ChatClient connecting through a proxy</em></p>&#13;
<p class="indent">Notice some clear changes in <a href="../Text/ch08.xhtml#ch8list32">Listing 8-32</a>. One is that the TLS protocol is now TLS v1.0 <span class="ent">➊</span> instead of TLS v1.2. Another is that the Cipher and Hash algorithms differ from those in <a href="../Text/ch08.xhtml#ch8list30">Listing 8-30</a>, although the key exchange algorithm is using Elliptic Curve Diffie–Hellman (ECDH) for forward secrecy <span class="ent">➋</span>. The final change is shown in the Cert Issuer <span class="ent">➌</span>. The proxy libraries will autogenerate a valid certificate based on the original one from the server, but it will be signed with the library’s Certificate Authority (CA) certificate. If a CA certificate isn’t configured, one will be generated on first use.</p>&#13;
<h5 class="h5" id="ch00lev1sec237"><strong>Forcing TLS 1.2</strong></h5>&#13;
<p class="noindent">The changes to the negotiated encryption settings shown in <a href="../Text/ch08.xhtml#ch8list32">Listing 8-32</a> can interfere with your successfully proxying applications because some applications will check the version of TLS negotiated. If the client will only connect to a TLS 1.2 service, you can force that version by adding this line to the script:</p>&#13;
<p class="programs">tls.Config.ServerProtocol = System.Security.Authentication.SslProtocols.Tls12;</p>&#13;
<h5 class="h5" id="ch00lev1sec238"><strong>Replacing the Certificate with Our Own</strong></h5>&#13;
<p class="noindent">Replacing the certificate chain involves ensuring that the client accepts the certificate that you generate as a valid root CA. Run the script in Listing 8-33 in <em>CANAPE.Cli</em> to generate a new CA certificate, output it and key to a PFX file, and output the public certificate in PEM format.</p>&#13;
<p class="literal"><span class="codeitalic">generate_ca</span><br/><span class="codeitalic">_cert.csx</span></p>&#13;
<p class="programs">using System.IO;<br/><br/>// Generate a 4096 bit RSA key with SHA512 hash<br/>var ca = CertificateUtils.GenerateCACert("CN=MyTestCA",<br/>    4096, CertificateHashAlgorithm.Sha512);<br/>// Export to PFX with no password<br/>File.WriteAllBytes("ca.pfx", ca.ExportToPFX());<br/><span epub:type="pagebreak" id="page_203"/><br/>// Export public certificate to a PEM file<br/>File.WriteAllText("ca.crt", ca.ExportToPEM());</p>&#13;
<p class="listing"><a id="ch8list33"/><em>Listing 8-33: Generating a new root CA certificate for a proxy</em></p>&#13;
<p class="indent">On disk, you should now find a <em>ca.pfx</em> file and a <em>ca.crt</em> file. Copy the <em>ca.pfx</em> file into the same directory where your proxy script files are located, and add the following line before initializing the TLS layer as in <a href="../Text/ch08.xhtml#ch8list31">Listing 8-31</a>.</p>&#13;
<p class="programs">CertificateManager.SetRootCert("ca.pfx");</p>&#13;
<p class="indent">All generated certificates should now use your CA certificate as the root certificate.</p>&#13;
<p class="indent">You can now import <em>ca.crt</em> as a trusted root for your application. The method you use to import the certificate will depend on many factors, for example, the type of device the client application is running on (mobile devices are typically more difficult to compromise). Then there’s the question of where the application’s trusted root is stored. For example, is it in an application binary? I’ll show just one example of importing the certificate on Microsoft Windows.</p>&#13;
<p class="indent">Because it’s common for Windows applications to refer to the system trusted root store to get their root CAs, we can import our own certificate into this store and SuperFunkyChat will trust it. To do so, first run <span class="literal"><span class="codestrong">certmgr.msc</span></span> either from the Run dialog or a command prompt. You should see the application window shown in <a href="../Text/ch08.xhtml#ch8fig2">Figure 8-2</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f08-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch8fig2"/><em>Figure 8-2: The Windows certificate manager</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_204"/>Choose <strong>Trusted Root Certification Authorities</strong> ▸ <strong>Certificates</strong> and then select <strong>Action</strong> ▸ <strong>All Tasks</strong> ▸ <strong>Import</strong>. An import Wizard should appear. Click <strong>Next</strong> and you should see a dialog similar to <a href="../Text/ch08.xhtml#ch8fig3">Figure 8-3</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f08-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch8fig3"/><em>Figure 8-3: Using the Certificate Import Wizard file import</em></p>&#13;
<p class="indent">Enter the path to <em>ca.crt</em> or browse to it and click <strong>Next</strong> again.</p>&#13;
<p class="indent">Next, make sure that Trusted Root Certification Authorities is shown in the Certificate Store box (see <a href="../Text/ch08.xhtml#ch8fig4">Figure 8-4</a>) and click <strong>Next</strong>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f08-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch8fig4"/><em>Figure 8-4: The certificate store location</em></p>&#13;
<p class="indent">On the final screen, click <strong>Finish</strong>; you should see the warning dialog box shown in <a href="../Text/ch08.xhtml#ch8fig5">Figure 8-5</a>. Obviously, heed its warning, but click <strong>Yes</strong> all the same.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_205"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Be very careful when importing arbitrary root CA certificates into your trusted root store. If someone gains access to your private key, even if you were only planning to test a single application, they could man-in-the-middle any TLS connection you make. Never install arbitrary certificates on any device you use or care about.</em></p>&#13;
</div>&#13;
<div class="image"><img alt="image" src="../Images/f08-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch8fig5"/><em>Figure 8-5: A warning about importing a root CA certificate</em></p>&#13;
<p class="indent">As long as your application uses the system root store, your TLS proxy connection will be trusted. We can test this quickly with SuperFunkyChat using <span class="literal">--verify</span> with the ChatClient to enable server certificate verification. Verification is off by default to allow you to use a self-signed certificate for the server. But when you run the client against the proxy server with <span class="literal">--verify</span>, the connection should fail, and you should see the following output:</p>&#13;
<p class="programs">SSL Policy Errors: RemoteCertificateNameMismatch<br/>Error: The remote certificate is invalid according to the validation procedure.</p>&#13;
<p class="indent">The problem is that although we added the CA certificate as a trusted root, the server name, which is in many cases specified as the subject of the certificate, is invalid for the target. As we’re proxying the connection, the server hostname is, for example, 127.0.0.1, but the generated certificate is based on the original server’s certificate.</p>&#13;
<p class="indent">To fix this, add the following lines to specify the subject name for the generated certificate:</p>&#13;
<p class="programs">tls.Config.SpecifyServerCert = true;<br/>tls.Config.ServerCertificateSubject = "CN=127.0.0.1";</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>When you retry the client, it should successfully connect to the proxy and then on to the real server, and all traffic should be unencrypted inside the proxy.</p>&#13;
<p class="indent">We can apply the same code changes to the network client and server code in <a href="../Text/ch08.xhtml#ch8list6">Listing 8-6</a> and <a href="../Text/ch08.xhtml#ch8list8">Listing 8-8</a>. The framework will take care of ensuring that only specific TLS connections are established. (You can even specify TLS client certificates in the configuration for use in performing mutual authentication, but that’s an advanced topic that’s beyond the scope of this book.)</p>&#13;
<p class="indent">You should now have some ideas about how to man-in-the-middle TLS connections. The techniques you’ve learned will enable you to decrypt and encrypt the traffic from many applications to perform analysis and security testing.</p>&#13;
<h3 class="h3" id="ch00lev1sec239"><strong>Final Words</strong></h3>&#13;
<p class="noindent">This chapter demonstrated some approaches you can take to reimplement your application protocol based on the results of either doing on-the-wire inspection or reverse engineering the implementation. I’ve only scratched the surface of this complex topic—many interesting challenges await you as you investigate security issues in network protocols.</p>&#13;
</body></html>