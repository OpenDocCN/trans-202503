- en: '**12**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EXCEPTIONS, TIMINGS, AND VISIBILITY**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve seen how to write your own functions in R, let’s examine some
    common function augmentations and behaviors. In this chapter, you’ll learn how
    to make your functions throw an error or warning when they receive unexpected
    input. You’ll also see some simple ways to measure completion time and check progress
    for computationally expensive functions. Finally, you’ll see how R masks functions
    when two have the same name but reside in different packages.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.1 Exception Handling**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When there’s an unexpected problem during execution of a function, R will notify
    you with either a *warning* or an *error*. In this section, I’ll demonstrate how
    to build these constructs into your own functions where appropriate. I’ll also
    show how to *try* a calculation to check whether it’s possible without an error
    (that is, to see whether it’ll even work).
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.1 Formal Notifications: Errors and Warnings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 11](ch11.xhtml#ch11), you made your functions print a string (for
    example, `"no valid matrices"`) when they couldn’t perform certain operations.
    Warnings and errors are more formal mechanisms designed to convey these types
    of messages and handle subsequent operations. An error forces the function to
    immediately terminate at the point it occurs. A warning is less severe. It indicates
    that the function is being run in an atypical way but tries to work around the
    issue and continue executing. In R, you can issue warnings with the `warning`
    command, and you can throw errors with the `stop` command. The following two functions
    show an example of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Both `warn_test` and `error_test` divide 5 by the argument `x`. They also both
    expect `x` to be positive. In `warn_test`, if `x` is nonpositive, the function
    issues a warning, and `x` is overwritten to be `1`. In `error_test`, on the other
    hand, if `x` is nonpositive, the function throws an error and terminates immediately.
    The two commands `warning` and `stop` are used with a character string argument,
    which becomes the message printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see these notifications by importing and calling the functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `warn_test` has continued to execute and returned the value `5`—the
    result of `5/1` after setting `x` to `1`. The call to `error_test` did not return
    anything because R exited the function at the `stop` command.
  prefs: []
  type: TYPE_NORMAL
- en: Warnings are useful when there’s a natural way for a function to try to save
    itself even when it doesn’t get the input it expects. For example, in [Section
    10.1.3](ch10.xhtml#ch10lev2sec89), R issued a warning when you supplied a logical
    vector of elements to the `if` statement. Remember that the `if` statement expects
    a single logical value, but rather than quit when a logical vector is provided
    instead, it continues execution using just the first entry in the supplied vector.
    That said, sometimes it’s more appropriate to actually throw an error and stop
    execution altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to `myfibrec` from [Section 11.3.3](ch11.xhtml#ch11lev2sec105).
    This function expects a positive integer (the position of the Fibonacci number
    it should return). Suppose you assume that if the user supplies a negative integer,
    the user actually means the positive version of that term. You can add a warning
    to handle this situation. Meanwhile, if the user enters 0, which doesn’t correspond
    to any position in the Fibonacci series, the code will throw an error. Consider
    these modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In `myfibrec2`, you now check whether `n` is negative or zero. If it’s negative,
    the function issues a warning and continues executing after swapping the argument’s
    sign. If `n` is zero, an error halts execution with a corresponding message. Here
    you can see the responses for a few different arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the call to `myfibrec2(-3)` has returned the third Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: Broadly speaking, both errors and warnings signal that something has gone wrong.
    If you’re using a certain function or running chunks of code and you encounter
    these kinds of messages, you should look carefully at what has been run and what
    may have occurred to spark them.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Identifying and repairing erroneous code is referred to as* debugging*, for
    which there are various strategies. One of the most basic strategies involves
    including* `print` *or* `cat` *commands to inspect various quantities as they
    are calculated during live execution. R does have some more sophisticated debugging
    tools; if you’re interested, check out the excellent discussion of them provided
    in [Chapter 13](ch13.xhtml#ch13) of* The Art of R Programming *by Matloff ([2011](ref.xhtml#ref44)).
    A more general discussion can be found in* The Art of Debugging *by Matloff and
    Salzman ([2008](ref.xhtml#ref45)). As you gain more experience in R, understanding
    error messages or locating potential problems in code before they arise becomes
    easier and easier, a benefit you get partly because of R’s interpretative style.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.2 Catching Errors with try Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a function terminates from an error, it also terminates any parent functions.
    For example, if function A calls function B and function B halts because of an
    error, this halts execution of A at the same point. To avoid this severe consequence,
    you can use a `try` statement to attempt a function call and check whether it
    produces an error. You can also use an `if` statement to specify alternative operations,
    rather than allowing all processes to cease.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you call the `myfibrec2` function from earlier and pass it
    0, the function throws an error and terminates. But watch what happens when you
    pass that function call as the first argument to `try`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing seems to happen. What’s happened to the error? In fact, the error has
    still occurred, but `try` has suppressed the printing of an error message to the
    console because you passed it the argument `silent` set to `TRUE`. The error information
    is now stored in the object `attempt1`, which is of class `"try-error"`. To see
    the error, simply print `attempt1` to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You would have seen this printed to the console if you’d left `silent` set to
    `FALSE`. Catching an error this way can be really handy, especially when a function
    produces the error in the body code of another function. Using `try`, you can
    handle the error without terminating that parent function.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, if you pass a function to `try` and it doesn’t throw an error, then
    `try` has no effect, and you simply get the normal return value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you executed `myfibrec2` with a valid argument, `n=6`. Since this call
    doesn’t result in an error, the result passed to `attempt2` is the normal return
    value from `myfibrec2`, in this case `8`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using try in the Body of a Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s see a more complete example of how you could use `try` in a larger function.
    The following `myfibvector` function takes a vector of indexes as the argument
    `nvec` and provides the corresponding terms from the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function uses a `for` loop to work through `nvec` element by element,
    computing the corresponding Fibonacci number with the earlier function, `myfibrec2`.
    As long as all the values in `nvec` are nonzero, `myfibvector` works just fine.
    For example, the following call obtains the first, the second, the tenth, and
    the eighth Fibonacci number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Suppose, however, there’s a mistake and one of the entries in `nvec` ends up
    being zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The internal call to `myfibrec2` has thrown an error when it’s called on `n=0`,
    and this has terminated execution of `myfibvector`. Nothing is returned, and the
    entire call has failed.
  prefs: []
  type: TYPE_NORMAL
- en: You can prevent this outright failure by using `try` within the `for` loop to
    check each call to `myfibrec2` and have it catch any errors. The following function,
    `myfibvectorTRY`, does just that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, within the `for` loop, you use `attempt` to store the result of trying
    each call to `myfibrec2`. Then, you inspect `attempt`. If this object’s class
    is `"try-error"`, that means `myfibrec2` produced an error, and you fill the corresponding
    slot in the `result` vector with `NA`. Otherwise, `attempt` will represent a valid
    return value from `myfibrec2`, so you place it in the corresponding slot of the
    `result` vector. Now if you import and call `myfibvectorTRY` on the same `nvec`,
    you see a complete set of results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The error that would have otherwise terminated everything was silently caught,
    and the alternative response in this situation, `NA`, was inserted into the `result`
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* `try` *command is a simplification of R’s more complex* `tryCatch` *function,
    which is beyond the scope of this book, but it provides more precise control over
    how you test and execute chunks of code. If you’re interested in learning more,
    enter* `?tryCatch` *in the console.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suppressing Warning Messages**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In all the `try` calls I’ve shown so far, I’ve set the `silent` argument to
    `TRUE`, which stops any error messages from being printed. If you leave `silent`
    set to `FALSE` (the default value), the error message will be printed, but the
    error will still be caught without terminating execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that setting `silent=TRUE` only suppresses error messages, not warnings.
    Observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although `silent` was `TRUE`, the warning (for negative values of `n` in this
    example) is still issued and printed. Warnings are treated separately from errors
    in this type of situation, as they should be—they can highlight other unforeseen
    issues with your code during execution. If you are absolutely sure you don’t want
    to see any warnings, you can use `suppressWarnings`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `suppressWarnings` function should be used only if you are certain that
    every warning in a given call can be safely ignored and you want to keep the output
    tidy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 12.1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Exercise 11.3](ch11.xhtml#ch11exc3) (b) on [page 238](ch11.xhtml#page_238),
    your task was to write a recursive R function to compute integer factorials, given
    some supplied non-negative integer `x`. Now, modify your function so that it throws
    an error (with an appropriate message) if `x` is negative. Test your new function
    responses by using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x` as `5`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x` as `8`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x` as `-8`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The idea of *matrix inversion*, briefly discussed in [Section 3.3.6](ch03.xhtml#ch03lev2sec34),
    is possible only for certain square matrices (those with an equal number of columns
    as rows). These inversions can be computed using the `solve` function, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that `solve` throws an error if the supplied matrix cannot be inverted.
    With this in mind, write an R function that attempts to invert each matrix in
    a list, according to the following guidelines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The function should take four arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* The list `x` whose members are to be tested for matrix inversion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* A value `noninv` to fill in results where a given matrix member of `x` cannot
    be inverted, defaulting to `NA`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* A character string `nonmat` to be the result if a given member of `x` is
    not a matrix, defaulting to `"not a matrix"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* A logical value `silent`, defaulting to `TRUE`, to be passed to `try` in
    the body code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – The function should first check whether `x` is in fact a list. If not, it
    should throw an error with an appropriate message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Then, the function should ensure that `x` has at least one member. If not,
    it should throw an error with an appropriate message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Next, the function should check whether `nonmat` is a character string. If
    not, it should try to coerce it to a character string using an appropriate “as-dot”
    function (see [Section 6.2.4](ch06.xhtml#ch06lev2sec62)), and it should issue
    an appropriate warning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – After these checks, a loop should search each member `i` of the list `x`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* If member `i` is a matrix, attempt to invert it with `try`. If it’s invertible
    without error, overwrite member `i` of `x` with the result. If an error is caught,
    then member `i` of `x` should be overwritten with the value of `noninv`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* If member `i` is not a matrix, then member `i` of `x` should be overwritten
    with the value of `nonmat`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: – Finally, the modified list `x` should be returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, test your function using the following argument values to make sure it
    responds as expected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`x` as'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: and all other arguments at default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`x` as in (i), `noninv` as `Inf`, `nonmat` as `666`, `silent` at default.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat (ii), but now with `silent=FALSE`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x` as'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: and `noninv` as `"unsuitable matrix"`; all other values at default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, test the error messages by attempting calls to your function with
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`x` as `"hello"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x` as `list()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**12.2 Progress and Timing**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R is often used for lengthy numeric exercises, such as simulation or random
    variate generation. For these complex, time-consuming operations, it’s often useful
    to keep track of progress or see how long a certain task took to complete. For
    example, you may want to compare the speed of two different programming approaches
    to a given problem. In this section, you’ll look at ways to time code execution
    and show its progress.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.1 Textual Progress Bars: Are We There Yet?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *progress bar* shows how far along R is as it executes a set of operations.
    To show how this works, you need to run code that takes a while to execute, which
    you’ll do by making R *sleep*. The `Sys.sleep` command makes R pause for a specified
    amount of time, in seconds, before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, R will pause for three seconds before you can continue
    using the console. Sleeping will be used in this section as a surrogate for the
    delay caused by computationally expensive operations, which is where progress
    bars are most useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Sys.sleep` in a more common fashion, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sleep_test` function is basic—it takes a positive integer `n` and adds
    `1` to the `result` value for `n` iterations. At each iteration, you also tell
    the loop to sleep for a half second. Because of that sleep command, executing
    the following code takes about four seconds to return a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, say you want to track the progress of this type of function as it executes.
    You can implement a textual progress bar with three steps: initialize the bar
    object with `txtProgressBar`, update the bar with `setTxtProgressBar`, and terminate
    the bar with `close`. The next function, `prog_test`, modifies `sleep_test` to
    include those three commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Before the `for` loop, you create an object named `progbar` by calling `txtProgressBar`
    with four arguments. The `min` and `max` arguments are numeric values that define
    the limits of the bar. In this case, you set `max=n`, which matches the number
    of iterations of the impending `for` loop. The `style` argument (integer, either
    `1`, `2`, or `3`) and the `char` argument (character string, usually a single
    character) govern the appearance of the bar. Setting `style=1` means the bar will
    simply display a line of `char`; with `char="="` it’ll be a series of equal signs.
  prefs: []
  type: TYPE_NORMAL
- en: Once this object is created, you have to instruct the bar to actually progress
    during execution with a call to `setTxtProgressBar`. You pass in the bar object
    to update (`progbar`) and the `value` it should update to (in this case, `i`).
    Once complete (after exiting the loop), the progress bar must be terminated with
    a call to `close`, passing in the bar object of interest. Import and execute `prog_test`,
    and you’ll see the line of `"="` drawn in steps as the loop completes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The width of the bar is, by default, determined by the width of the R console
    pane upon execution of the `txtProgressBar` command. You can customize the bar
    a bit by changing the `style` and `char` arguments. Choosing `style=3`, for example,
    shows the bar as well as a “percent completed” counter. Some packages offer more
    elaborate options too, such as pop-up widgets, but the textual version is the
    simplest and most universally compatible version across different systems.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.2 Measuring Completion Time: How Long Did It Take?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to know how long a computation takes to complete, you can use the
    `Sys.time` command. This command outputs an object that details current date and
    time information based on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can store objects like these before and after some code and then compare
    them to see how much time has passed. Enter this in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now highlight all four lines and execute them in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By executing this entire code block together, you get an easy measure of the
    total completion time in a nicely formatted string printed to the console. Note
    that there’s a small time cost for interpreting and invoking any commands, in
    addition to the three seconds you tell R to sleep. This time will vary between
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more detailed timing reports, there are more sophisticated tools.
    For example, you can use `proc.time()` to receive not just the total elapsed “wall
    clock” time but also computer-related CPU timings (see the definitions in the
    help file `?proc.time`). To time a single expression, you can also use the `system.time`
    function (which uses the same detail of output as `proc.time`). There are also
    *benchmarking* tools (formal or systematic comparisons of different approaches)
    for timing your code; see, for example, the `rbenchmark` package ([Kusnierczyk,
    2012](ref.xhtml#ref38)). However, for everyday use, the time-object differencing
    approach used here is easy to interpret and provides a good indication of the
    computational expense.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 12.2**'
  prefs: []
  type: TYPE_NORMAL
- en: Modify `prog_test` from [Section 12.2.1](ch12.xhtml#ch12lev2sec108) to include
    an ellipsis in its argument list, intended to take values for the additional arguments
    in `txtProgressBar`; name the new function `prog_test_fancy`. Time how long it
    takes a call to `prog_test_fancy` to execute. Set `50` as `n`, instruct the progress
    bar (through the ellipsis) to use `style=3`, and set the bar character to be `"r"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In [Section 12.1.2](ch12.xhtml#ch12lev2sec107), you defined a function named
    `myfibvectorTRY` (which itself calls `myfibrec2` from [Section 12.1.1](ch12.xhtml#ch12lev2sec106))
    to return multiple terms from the Fibonacci sequence based on a supplied “term
    vector” `nvec`. Write a new version of `myfibvectorTRY` that includes a progress
    bar of `style=3` and a character of your choosing that increments at each pass
    of the internal `for` loop. Then, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your new function to reproduce the results from the text where `nvec=c(3,2,7,0,9,13)`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Time how long it takes to use your new function to return the first 35 terms
    of the Fibonacci sequence. What do you notice, and what does this say about your
    recursive Fibonacci functions?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Remain with the Fibonacci sequence. Write a stand-alone `for` loop that can
    compute, and store in a vector, the same first 35 terms as in (b)(ii). Time it.
    Which approach would you prefer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**12.3 Masking**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the plethora of built-in and contributed data and functionality available
    for R, it is virtually inevitable that at some point you will come across objects,
    usually functions, that share the same name in distinctly different loaded packages.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens in those instances? For example, say you define a function
    with the same name as a function in an R package that you have already loaded.
    R responds by *masking* one of the objects—that is, one object or function will
    take precedence over the other and assume the object or function name, while the
    masked function must be called with an additional command. This protects objects
    from overwriting or blocking one another. In this section, you’ll look at the
    two most common masking situations in R.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.3.1 Function and Object Distinction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When two functions or objects in different environments have the same name,
    the object that comes earlier in the search path will mask the later one. That
    is, when the object is sought, R will use the object or function it finds first,
    and you’ll need extra code to access the other, masked version. Remember, you
    can see the current search path by executing `search()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When R searches, the function or object that falls closest to the start of
    the search path (the global environment) is reached first and masks the function
    or object of the same name that occurs somewhere later in the search path. To
    see a simple example of masking, you’ll define a function with the same name as
    a function in the base package: `sum`. Here’s how `sum` works normally, adding
    up all the elements in the vector `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose you were to enter the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This version of `sum` takes in a vector `x` and uses a `for` loop to square
    each element before summing them and returning the result. This can be imported
    into the R console without any problem, but clearly, it doesn’t offer the same
    functionality as the (original) built-in version of `sum`. Now, after importing
    the function, if you make a call to `sum`, your version is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This happens because the user-defined function is stored in the global environment
    (`.GlobalEnv`), which always comes first in the search path. R’s built-in function
    is part of the `base` package, which comes at the end of the search path. In this
    case, the user-defined function is masking the original.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you want R to run the `base` version of `sum`, you have to include the
    name of its package in the call, with a double colon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This tells R to use the version in `base`, even though there’s another version
    of the function in the global environment.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid any confusion, let’s remove the `sum` function from the global environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**When Package Objects Clash**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When you load a package, R will notify you if any objects in the package clash
    with other objects that are accessible in the present session. To illustrate this,
    I’ll make use of two contributed packages: the `car` package (you saw this earlier
    in [Exercise 8.1](ch08.xhtml#ch8exc1) (b) on [page 162](ch08.xhtml#page_162))
    and the `spatstat` package (you’ll use this in [Part V](part05.xhtml#part05)).
    After ensuring these two packages are installed, when I load them in the following
    order, I see this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the two packages each have an object with the same name—`ellipse`.
    R has automatically notified you that this object is being masked. Note that the
    functionality of both `car` and `spatstat` remains completely available; it’s
    just that the `ellipse` objects require some distinction should they be needed.
    Using `ellipse` at the prompt will access `car`’s object since that package was
    loaded more recently. To use `spatstat`’s version, you must type `spatstat::ellipse`.
    These rules also apply to accessing the respective help files.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar notification occurs when you load a package with an object that’s
    masked by a global environment object (a global environment object will always
    take precedence over a package object). To see an example, you can load the `MASS`
    package ([Venables and Ripley, 2002](ref.xhtml#ref69)), which is included with
    R but isn’t automatically loaded. Continuing in the current R session, create
    the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose you need to load `MASS`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Upon loading the package, you’re informed that the `cats` object you’ve just
    created is masking an object of the same name in `MASS`. (As you can see with
    `?MASS::cats`, this object is a data frame with weight measurements of household
    felines.) Furthermore, it appears `MASS` also shares an object name with `spatstat`—`area`.
    The same kind of “package masking” message as shown earlier is also displayed
    for that particular item.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unmounting Packages**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can unmount loaded packages from the search path. With the packages loaded
    in this discussion, my current search path looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, suppose you don’t need `car` anymore. You can remove it with the `detach`
    function as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This removes the elected package from the path, unloading its namespace. Now,
    the functionality of `car` is no longer immediately available, and `spatstat`’s
    `ellipsis` function is no longer masked.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As contributed packages get updated by their maintainers, they may include
    new objects that spark new maskings or remove or rename objects that previously
    caused maskings (when compared with other contributed packages). The specific
    maskings illustrated here among* `car`, `spatstat`*, and* `MASS` *occur at the
    time of writing with the versions available and may change in the future.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***12.3.2 Data Frame Variable Distinction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s one other common situation in which you’ll be explicitly notified of
    masking: when you add a data frame to the search path. Let’s see how this works.
    Continuing in the current workspace, define the following data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The data frame `foo` has three column variables: `person`, `sex`, and `height`.
    To access one of these columns, normally you need to use the `$` operator and
    enter something like `foo$surname`. However, you can *attach* a data frame directly
    to your search path, which makes it easier to access a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now the `surname` variable is directly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This saves you from having to enter `foo$` every time you want to access a variable,
    which can be a handy shortcut if your analysis deals exclusively with one static,
    unchanging data frame. However, if you forget about your attached objects, they
    can cause problems later, especially if you continue to mount more objects onto
    the search path in the same session. For example, say you enter another data frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then add it to the search path too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The notification tells you that the `bar` object now precedes `foo` in the search
    path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As a result, any direct use of either `sex` or `surname` will now access `bar`’s
    contents, not `foo`’s. Meanwhile, the unmasked variable `height` from `foo` is
    still directly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty simple example, but it highlights the potential for confusion
    when data frames, lists, or other objects are added to the search path. Mounting
    objects this way can quickly become difficult to track, especially for large data
    sets with many different variables. For this reason, it’s best to avoid attaching
    objects this way as a general guideline—unless, as stated earlier, you’re working
    exclusively with one data frame.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `detach` can be used to remove objects from the search path, in a
    similar way as you saw with packages. In this case, you can simply enter the object
    name itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Important Code in This Chapter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `warning` | Issue warning | [Section 12.1.1](ch12.xhtml#ch12lev2sec106),
    [p. 242](ch12.xhtml#page_242) |'
  prefs: []
  type: TYPE_TB
- en: '| `stop` | Throw error | [Section 12.1.1](ch12.xhtml#ch12lev2sec106), [p. 242](ch12.xhtml#page_242)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `try` | Attempt error catch | [Section 12.1.2](ch12.xhtml#ch12lev2sec107),
    [p. 244](ch12.xhtml#page_244) |'
  prefs: []
  type: TYPE_TB
- en: '| `Sys.sleep` | Sleep (pause) execution | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  prefs: []
  type: TYPE_TB
- en: '| `txtProgressBar` | Initialize progress bar | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  prefs: []
  type: TYPE_TB
- en: '| `setTxtProgressBar` | Increment progress bar | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | Close progress bar | [Section 12.2.1](ch12.xhtml#ch12lev2sec108),
    [p. 249](ch12.xhtml#page_249) |'
  prefs: []
  type: TYPE_TB
- en: '| `Sys.time` | Get local system time | [Section 12.2.2](ch12.xhtml#ch12lev2sec109),
    [p. 250](ch12.xhtml#page_250) |'
  prefs: []
  type: TYPE_TB
- en: '| `detach` | Remove library/object from path | [Section 12.3.1](ch12.xhtml#ch12lev2sec110),
    [p. 255](ch12.xhtml#page_255) |'
  prefs: []
  type: TYPE_TB
- en: '| `attach` | Attach object to search path | [Section 12.3.2](ch12.xhtml#ch12lev2sec111),
    [p. 256](ch12.xhtml#page_256) |'
  prefs: []
  type: TYPE_TB
