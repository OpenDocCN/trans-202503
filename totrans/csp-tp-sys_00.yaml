- en: <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: According to the C# Language Specification, “C# is intended to be a simple,
    modern, general-purpose, object-oriented programming language.” C# may look simple
    on the surface, but it has hidden depths even in its most fundamental features.
    The type system is a central element of C# and is the foundation upon which all
    C# programs are built. This has been true from the earliest versions of C#, and
    will continue to be relevant as the language evolves. *The C# Type System* isn’t
    a gallery of the latest language features, and we won’t delve into every detail
    of the latest edition, because C# is constantly advancing; instead we’ll focus
    on the language’s rich support for creating your own types and examine how best
    to employ the type system to improve your designs and write clearer, simpler,
    more efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: Many languages allow users to define their own types, but C# is different in
    that it makes a clear distinction between classes, which are reference types,
    and value types. *Classes* are the default choice for implementing a design in
    C# and the general-purpose mechanism for custom types, as they support all the
    object-oriented features that C# has to offer. In contrast, *value types* are
    much more specialized, which is why they’re often misunderstood and dismissed
    as an advanced feature that’s irrelevant for most applications. It’s true that
    value types aren’t suitable for many custom types in an application, and they
    may not be necessary in every design, but they have several advantages that are
    frequently underappreciated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using typical real-world examples, this book will walk you through defining
    and implementing value types effectively and efficiently so that they work successfully
    with all the other types in your applications. Specifically, we’ll explore the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why C# distinguishes between value types and reference types, and what that
    means in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes value types different, both syntactically and semantically, from
    other types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How incorporating value types can improve your code and help you express designs
    more clearly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which characteristics of value types, beyond those defined by the language,
    are most important to their role in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where you can use value types to enhance an application’s performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Who Should Read This Book</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve learned the basics of C# and wish to expand your understanding of
    the language to become a better programmer, this book is for you. Nothing in the
    chapters that follow is particularly advanced, but the content is intended to
    help you understand some of the underlying features, principles, and concepts
    of C# programming. My hope is that this book will allow you to move beyond simply
    writing runnable programs using correct C# syntax to writing idiomatic and efficient
    C# programs that your colleagues can easily understand.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the examples, you’ll need experience with creating your own classes;
    familiarity with constructors, methods, and properties; and a basic understanding
    of how virtual methods can be overridden by derived classes. Some practice with
    exceptions, both in employing them and handling them to manage errors, will also
    be useful. An appreciation of the mechanics of defining generic types and methods,
    although not essential, will also be helpful; in particular, some experience using
    the generic collection classes provided by the Standard Library will give you
    insight into how generics work in C#. *The C# Type System* isn’t a beginner’s
    guide and doesn’t discuss how to compile and run your code, but you aren’t expected
    to know the dark corners of the language. That said, I hope that some parts of
    this book will amuse and perhaps even surprise more advanced users.
  prefs: []
  type: TYPE_NORMAL
- en: When features are fundamental, we sometimes become complacent about them. With
    that in mind, many chapters in this book cover details that experienced C# programmers
    might consider introductory. Those topics are intended to set the scene for some
    less widely understood concepts that depend on them.
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than just a passing familiarity with C# code or experience
    with another object-based language such as Java or C++, I hope that the examples
    and commentary here will help you better understand C# syntax and semantics and
    better appreciate why C# is the language it has become.
  prefs: []
  type: TYPE_NORMAL
- en: The book doesn’t cover all aspects of C# programming; the focus is intentionally
    on the interactions between value types and reference types. In that discussion,
    we’ll venture into C# generics, collections, Language Integrated Query (LINQ),
    and threading, but only superficially. We *won’t* be discussing <samp class="SANS_TheSansMonoCd_W5Regular_11">unsafe</samp>
    code or C# pointers. (Actually, there’s one mention of *managed* pointers. Otherwise,
    we’re solid.)
  prefs: []
  type: TYPE_NORMAL
- en: We won’t cover how to create web services, interact with databases, or write
    distributed programs intended for deployment as cloud or microservice applications,
    but the techniques and underlying principles of C# presented will help improve
    the applications you create for those domains and others.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve asked or been asked when a value type would be a better choice than
    a reference type in a C# program and found yourself unable to give a satisfactory
    response, you should find this book useful.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Organization and Requirements</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The book is organized into eight chapters, each presenting a different aspect
    of value types in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1](chapter1.xhtml): Making the Most of the Type System**   Examines
    the importance of user-defined value types and how introducing even simple types
    in an application can make the code easier to read and understand. It covers the
    importance of accurate names, the benefits of encapsulating application-specific
    behavior, and ways to make your own types intuitive and simple to use.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2](chapter2.xhtml): Value and Reference Types**   Looks at why C#
    has both reference types and value types and compares them in detail. We consider
    how different kinds of objects use memory, what that means for their lifetimes,
    and how the differences between types affect construction, equality, and copying.
    We review nullable value types and compare them with the newer nullable reference
    type feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3](chapter3.xhtml): Reference and Value Parameters**   Examines
    the four types of method parameters and how to pass arguments to them, as well
    as how passing behavior differs between value types and reference types. We distinguish
    between passing a reference type variable and passing an argument *by reference*
    and explore how that relates to mutability and side effects. We also consider
    how to pass value type instances by immutable reference to optimize performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4](chapter4.xhtml): Implicit and Explicit Copying**   Discusses
    how values are copied in a program and how the differences in copy behavior between
    value types and reference types can have unintended consequences in our code.
    In particular, we distinguish between variables and values and explore how making
    value types immutable can help prevent some common copying-related errors. We
    also look at ways to mitigate the potential inefficiencies that copying can introduce.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5](chapter5.xhtml): Types of Equality**   Covers the various ways
    that values can be compared for equality and what happens under the hood during
    these comparisons. Implementing value-based equality comparisons is a common source
    of error, so we’ll walk through how to do so safely and correctly, as well as
    how to take advantage of facilities provided by the compiler for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6](chapter6.xhtml): The Nature of Values**   Outlines the characteristics
    and roles of different types in an application and how a value type’s role is
    more than just being a convenient way to store data. We examine what *value semantics*
    means and what makes an object a good candidate to be a value type. We also consider
    the importance of ordering objects and distinguish between equality and equivalence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7](chapter7.xhtml): Value Types and Polymorphism**   Explores why
    inheritance isn’t an appropriate form of polymorphism for value types, working
    through an example to demonstrate the problems that can arise. We look in detail
    at the difference between subclassing and subtyping, and we discuss how other
    kinds of polymorphism are more suitable for working with values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8](chapter8.xhtml): Performance and Efficiency**   Considers how
    different types affect an application’s performance and how to precisely measure
    performance to make evidence-based decisions. The chapter covers how accepting
    default behavior can adversely affect our code’s performance, while also addressing
    common myths regarding compiler-generated code and efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the code snippets use a simple test to demonstrate a behavior or language
    characteristic. The examples use NUnit fluent-style assertions, which provide
    a commonly understood and compact way to represent the concepts being discussed.
    Several other unit-testing frameworks are available for C#, and you should be
    able to easily translate the NUnit test snippets to other styles.
  prefs: []
  type: TYPE_NORMAL
- en: It won’t take long for you to discover that the code examples, on their own,
    usually don’t compile in the form in which they’re presented. For the sake of
    brevity, some details, such as importing namespaces or defining <samp class="SANS_TheSansMonoCd_W5Regular_11">Main</samp>,
    are omitted. The code examples are intended to focus your attention on a concept
    rather than to show a legal program.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modern Features</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years the language designers have put a great deal of effort into
    enhancing C#’s support for creating efficient, high-performance applications.
    While the central ideas of the language have remained unchanged, new facilities
    have been added, particularly with respect to simple value types, and new features
    incorporated to enable C# programmers to take advantage of value types to maximize
    application performance. This book explores some of those features but in the
    context of *classic* C# programming, not just high-performance computing. Some
    of those features can make your programs clearer for human readers, as well as
    more efficient at run time.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the code examples throughout the book demonstrate concepts that have
    been widely used in C# over several versions, some using features that have been
    part of C# since version 1.0\. For more recently introduced features, the minimum
    compiler version is indicated.
  prefs: []
  type: TYPE_NORMAL
- en: Using value types effectively in your applications requires some additional
    thought on your part, not just about how those types are designed, but also about
    how they’re used. *The C# Type System* describes in detail how value types behave
    in a wide variety of scenarios, allowing you to write C# in a modern, idiomatic,
    and effective manner. Having a deeper understanding of how value types fit into
    the C# type system will help you enrich your designs and write better programs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why Value Types?</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whereas the *class* is the poster child of object-oriented programming and design,
    the humble *value type* is often overlooked. However, judicious use of value types
    can bring many benefits, including better performance. Value type instances aren’t
    individually allocated on the heap or subject to garbage collection. Allocating
    objects on the heap carries a small performance penalty since the garbage collector
    must inspect every object in memory, whether or not it’s in use, to ascertain
    whether it’s eligible for collection.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the heap-based memory of a program is likely to mean the garbage collector
    runs less often and has to do less work when it does run. Reducing heap memory
    pressure is likely to improve the speed of the code you write. Although the garbage-collection
    algorithm has been carefully tuned to minimize its impact on a running program,
    avoiding garbage collection altogether is even more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Making all your objects into value types almost certainly won’t magically improve
    your programs’ performance, but there’s much more to the value type story than
    simply performance, just as there’s more to source code than a program, and more
    to programming than typing. Understanding value semantics can help you determine
    where you might employ value types in a design and how to implement them to best
    achieve your goal. Equally importantly, understanding value semantics will help
    you determine where a value type would *not* be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this book, you’ll learn what value semantics means for C#
    programs, and how to use value types successfully and efficiently. Along the way,
    we’ll look in detail at both how and why value types behave as they do. First,
    though, we’ll explore using simple value types to make our code easier for humans
    to understand. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
