- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EXPLORING
    DATASETS IN THE TERMINAL</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll build on the command line skills you’ve learned so far
    and begin investigating real datasets. You’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to unzip the BlueLeaks files, then search the files to determine which fusion
    centers have the most data and which documents contain the keywords *antifa* and
    *Black Lives Matter*. I’ll also give an overview of the mysterious encrypted data
    in the dataset and describe my hypothesis of how the hacker collected the data.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn to create Linux cloud servers and connect to them securely
    for faster internet and extra disk space. As practice, you’ll use a remote server
    to download and briefly examine hacked data from the Oath Keepers militia, a far-right
    extremist group that participated in the January 6, 2021, US Capitol insurrection.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introducing for Loops</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The BlueLeaks torrent you downloaded in Exercise 2-1 is 269GB and contains 168
    different ZIP files ranging from 49GB to half a kilobyte each. In theory, you
    could manually unzip these 168 files one at a time to access the data. However,
    this slow, tedious process becomes impractical with even larger datasets (imagine
    individually extracting 10,000 ZIP files). In this section, you’ll learn to speed
    up this task by automating it with <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is a type of
    command that runs a piece of code once for every item in a list. Each time the
    code loops, it stores the current item in a *variable*, which you can think of
    as a placeholder for some value. Code variables are similar to those in math,
    where the value of *x* might be different for different problems, but in shell
    scripting, the values can be text or numbers. Even though each loop runs the same
    code, the results may be different, because the value of the variable changes
    with each loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop displays the numbers 1, 2, and 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop starts with
    the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list_of_items</samp>,
    followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>, followed
    by the commands to run for each item in the list, followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp>.
    In this case, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">NUMBER</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list_of_items</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">1 2 3</samp>. The value of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NUMBER</samp> variable will be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> the first time the code loops,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> during the second loop,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> during the third loop.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp> command displays
    something, in this case <samp class="SANS_TheSansMonoCd_W5Regular_11">$NUMBER</samp>,
    to the terminal. The dollar sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>)
    means the code should display the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NUMBER</samp>
    variable, rather than the word <samp class="SANS_TheSansMonoCd_W5Regular_11">NUMBER</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Using all caps is a common convention for variable names, but it’s not required.
    For example, you could call the variable <samp class="mono">number</samp> instead
    of <samp class="mono">NUMBER</samp> and display it with <samp class="mono">echo
    $number</samp> instead of <samp class="mono">echo $NUMBER</samp>. Variable names
    are case sensitive.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop in your terminal, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to loop through the output of another shell command, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The variable name in this code is <samp class="SANS_TheSansMonoCd_W5Regular_11">FILENAME</samp>.
    Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">$(ls *.zip)</samp> tells your
    machine to run the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls *.zip</samp>
    command. This command outputs a list of all of the ZIP files in the current folder,
    producing a list of filenames. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop cycles through that list and runs the code between <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> for each filename.
    In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp> command
    prints the filenames to the terminal in <samp class="SANS_TheSansMonoCd_W5Regular_11">ZIP
    filename:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename</samp>
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s what it looks like when I run this code in the *BlueLeaks*
    folder in my terminal on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each time the code loops, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">FILENAME</samp>
    is the name of one of the ZIP files. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp>
    command runs, it displays those filenames, one after another.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4-1: Unzip the BlueLeaks
    Dataset</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you’ll write a script to unzip all the ZIP files in BlueLeaks
    so you can work with the data they contain. Once unzipped, the files will take
    271GB of additional space on your *datasets* USB.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using macOS or Linux, follow the instructions in “Unzip Files on macOS
    or Linux” next. If you’re using Windows, read that subsection to learn how to
    write <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops in bash since
    you’ll need that skill later in the book, but you won’t need to follow along until
    “Unzip Files on Windows” on page 92.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unzip Files on macOS
    or Linux</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open a terminal and navigate to your *BlueLeaks* folder by running the following
    command, replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">blueleaks_path</samp>
    with your own folder path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On Linux, I’d use this command (your path will be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, I’d use the following (again, your path will vary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp> to see the list of
    files in this folder and <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls -lh</samp>
    to see detailed information about these files, like their sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To unzip single files, you use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, run this command to unzip the first file in BlueLeaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This should extract the 2.6GB *211sfbay.zip* file into the folder called *211sfbay*.
    Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp> again and you should
    see the new folder containing all of the hacked data from one of the BlueLeaks
    sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you want to unzip *all* of the BlueLeaks files. Delete the *211sfbay*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">rm</samp> command on its own
    deletes files; to delete entire folders, you include <samp class="SANS_TheSansMonoCd_W5Regular_11">-r</samp>
    (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--recursive</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-r</samp> option deletes all
    the files in that folder, and all the files in folders in that folder, and so
    on, before finally deleting the target folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to your text editor, create a new folder in your *exercises* folder
    called *chapter-4*, and create a new file in the *chapter-4* folder called *exercise
    -4-1-unzip.sh*. (Storing your script in a separate folder prevents you from polluting
    the dataset with your own files.) In your new file, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since *exercise-4-1-unzip.sh* is a shell script, it begins with the same <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#!/bin/bash</samp> shebang as the script
    in [Chapter 3](chapter3.xhtml). After you define this <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, the script starts it with <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp>
    and ends it with <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp>, running
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">echo "Unzipping $FILENAME…"</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip -o $FILENAME</samp> commands
    over and over. The <samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp> command
    displays the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FILENAME</samp>
    variable, which changes to a new filename with each loop, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp>
    command unzips that file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-o</samp>
    argument tells <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp> to *overwrite*
    files if necessary, meaning that if any file being unzipped already exists, the
    script will replace it with the newer version.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you run this code on BlueLeaks, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">FILENAME</samp>
    during the first loop is <samp class="SANS_TheSansMonoCd_W5Regular_11">211sfbay.zip</samp>.
    The code that runs in this loop is equivalent to the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second time the code loops, it runs the same code with <samp class="SANS_TheSansMonoCd_W5Regular_11">acprlea.zip</samp>
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">FILENAME</samp> value, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to your *BlueLeaks* folder. On my Mac, I do this by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make this shell script executable and run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These commands assume that your *exercises* folder is in the same folder as
    the *BlueLeaks* folder. The relative path to your *exercises* folder is *../exercises*,
    and the relative path to the shell script you just saved is *../exercises/chapter-4/exercise-4-1-unzip.sh*.
  prefs: []
  type: TYPE_NORMAL
- en: After you run these commands, your script should begin unzipping all 168 BlueLeaks
    files. Sit back, relax, and perhaps enjoy a beverage while you wait for it to
    finish, which could take hours.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not using Windows, skip ahead to the “Organize Your Files” section
    on page 93. Otherwise, read on.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unzip Files on Windows</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unzipping files in WSL from a USB disk formatted for Windows might be *very*
    slow, due to WSL performance problems. Fortunately, there’s a much faster way
    to unzip all 168 files in BlueLeaks, using PowerShell and a program called 7-Zip.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Install 7-Zip</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The open source Windows archiving program 7-Zip lets you extract various types
    of compressed files*.* Download and install 7-Zip from [*https://<wbr>www<wbr>.7<wbr>-zip<wbr>.org*](https://www.7-zip.org).
    You’ll receive a warning saying that the program is made by an unknown publisher,
    but it’s safe to install as long as you’ve downloaded it from the official website.
  prefs: []
  type: TYPE_NORMAL
- en: After you install 7-Zip, you can use its *7z.exe* program to extract files directly
    from PowerShell. By default, *7z.exe* should be located in *C:\Program Files\7-Zip\7z.exe*.
    However, to run the program from any directory, add *C:\Program Files\7-Zip* to
    your <samp class="SANS_TheSansMonoCd_W5Regular_11">Path</samp> environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Environment variables* are variables that already exist when you open your
    shell, as opposed to ones that you create in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop or by other methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Path</samp>
    environment variable is a list of folders that contain programs. It contains some
    folders by default, but you can also add your own. When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">7z</samp>,
    PowerShell looks in each folder listed in <samp class="SANS_TheSansMonoCd_W5Regular_11">Path</samp>
    and checks for a file called *7z.exe*, then runs that program for you.'
  prefs: []
  type: TYPE_NORMAL
- en: To add *7z.exe* to <samp class="SANS_TheSansMonoCd_W5Regular_11">Path</samp>,
    click **Start**, search for **environment variables**, and click **Edit the System
    Environment Variables**. In the window that opens, click **Environment Variables**,
    and you should see a window with lists of user variables and system variables.
    Double-click **Path** in the User Variables box, which should show you all of
    the folders stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">Path</samp>.
    Click **New**, add *C:\Program Files\7-Zip*, and click **OK** to save. If you
    have a PowerShell window open, close PowerShell and open it again, forcing the
    shell to use the new changes to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Path</samp>
    environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">7z</samp>
    command to run 7-Zip.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Unzip in PowerShell with 7-Zip</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In a PowerShell terminal, change to the *BlueLeaks* folder on your *datasets*
    USB disk. For example, on my computer, I run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following PowerShell commands (this is the PowerShell version
    of the *exercise-4-1-unzip.sh* shell script in the previous subsection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first line sets the PowerShell variable <samp class="SANS_TheSansMonoCd_W5Regular_11">$ZipFiles</samp>
    to the list of ZIP files it finds in the current folder, represented by the dot
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>). This is followed by
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop, which loops
    through this list, setting the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">$ZipFile</samp>
    to the name of each file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">7z</samp>
    command runs over and over again for each different filename, unzipping each file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run these commands in my PowerShell terminal, I get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Your PowerShell window should likewise begin unzipping all 168 BlueLeaks files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Once you’re finished with this chapter, read [Appendix A](appendixA.xhtml)
    and implement one of the solutions it describes for avoiding WSL performance problems
    to make it easier to work with big datasets like BlueLeaks in Windows going forward.
    You’ll use WSL for the remainder of the book, so you’ll need a plan to resolve
    any issues you encounter.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Organize Your Files</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your *BlueLeaks* folder should now be full of both ZIP files and extracted folders.
    Now you’ll make a separate *BlueLeaks-extracted* folder for the extracted data
    and keep the ZIP files themselves in the *BlueLeaks* folder so that you can continue
    to seed the torrent with them if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal (if you’re in Windows, switch to a WSL Ubuntu terminal again),
    change folders to your *datasets* USB disk, and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">mv</samp> command moves or
    renames files. On the first line, it renames the *BlueLeaks* folder *BlueLeaks-extracted*.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">mkdir</samp> command, which
    you used in [Chapter 3](chapter3.xhtml), creates a new empty folder called *BlueLeaks*.
    The third command moves all of the ZIP files in the *BlueLeaks-extracted* folder
    into the newly created *BlueLeaks* folder.
  prefs: []
  type: TYPE_NORMAL
- en: Your *datasets* USB disk should now contain a folder called *BlueLeaks* with
    250GB of ZIP files, along with another folder called *BlueLeaks-extracted* with
    269GB of extracted hacked police data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How the Hacker Obtained the BlueLeaks
    Data</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t know how the hacker hacked and leaked the BlueLeaks files, but we can
    make an educated guess based on clues from the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that it’s June 6, 2020, less than two weeks after Minneapolis cop Derek
    Chauvin murdered George Floyd by kneeling on his neck for over nine minutes while
    Floyd struggled to breathe, triggering the summer’s Black Lives Matter uprising
    against police violence. Millions of people took to the streets to demand police
    accountability and the end of racist police violence in what was “the largest
    movement in the country’s history,” according to the *New York Times*.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine you’re a hacktivist. In addition to confronting police in the streets,
    you’re confronting them on the internet. Using OSINT, you’ve discovered that hundreds
    of police websites use the same shoddy web application developed by the Texas
    web development firm Netsential. All these sites run on Windows, use Microsoft’s
    Internet Information Services (IIS) web server software, and are programmed using
    Microsoft’s web framework ASP.NET. They’re also all hosted from IP addresses in
    the same data center in Texas.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you spend some time poking around one of these sites, the Arizona High
    Intensity Drug Trafficking Area (AZHIDTA), you find what you were looking for:
    a *remote code execution vulnerability*, a type of bug that lets you run commands
    on a remote server, like the Windows server running the AZHIDTA website. (My guess
    is that the vulnerability started with SQL injection, a technology beyond the
    scope of this book.)'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*I’m about to tell you about a potential URL for a hacking tool left behind
    by the hacker, but don’t actually try loading it in your browser because it might
    be illegal. Attempting to access someone else’s hacking tools is definitely a
    legal gray area.*'
  prefs: []
  type: TYPE_NORMAL
- en: To open a shell on this web server, you use a *web shell*, a web page that,
    when you submit a form with a command in it, runs that command on the web server
    and responds with its output. Using the vulnerability you discovered, you save
    a web shell into a file called *blug.aspx* on the web server’s disk. Loading */blug.aspx*
    on the [*https://<wbr>www<wbr>.azhidta<wbr>.org*](https://www.azhidta.org) website
    in your browser allows you to run whatever commands you want on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The web shell *blug.aspx* is included in the BlueLeaks dataset. In order to
    understand how this web shell works, I set up a Windows virtual machine with an
    IIS server to test it, as shown in [Figure 4-1](#fig4-1). The left side of the
    screenshot is the shell (in which I ran the command <samp class="SANS_TheSansMonoCd_W5Regular_11">dir
    c:\</samp>). The right side let me browse the server’s filesystem and upload new
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '![This screenshot shows the “ASPX Shell” web shell from BlueLeaks, loaded in
    a web browser in Windows.](Images/Figure4-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: Testing the</samp>
    <samp class="SANS_Futura_Std_Book_11">blug.aspx</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">web
    shell in a Windows VM</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'I don’t know for sure if this is how the BlueLeaks hack happened, but I think
    it’s very likely. While researching BlueLeaks, I found the following web shell
    files, all timestamped late on June 6, 2020, making them among the most recently
    created files in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '***azhidta/ntdaddy.aspx*** The Classic ASP web shell NTDaddy, developed around
    2001 by a hacker named obzerve'
  prefs: []
  type: TYPE_NORMAL
- en: '***azhidta/blug.aspx*** The ASP.NET web shell called ASPX Shell, developed
    in 2007 by a hacker named LT'
  prefs: []
  type: TYPE_NORMAL
- en: '***azhidta/pscp64.exe*** A program that comes with PuTTY, a popular Windows
    tool for securely copying files to and from remote servers'
  prefs: []
  type: TYPE_NORMAL
- en: '***icefishx/7z.exe*** A copy of the 7-Zip compression and extraction program'
  prefs: []
  type: TYPE_NORMAL
- en: My guess is that the hacktivist first tried to create a *ntdaddy.aspx* web shell,
    but found that it didn’t work because it was developed using an earlier version
    of ASP called Classic ASP, while the BlueLeaks site used the modern version, ASP.NET.
    They then created the *blug.aspx* web shell instead, used that shell to upload
    *pscp64.exe* and *7z.exe*, used *7z.exe* to compress all of the files for a given
    police website, and uploaded that data to their own server with *pscp64.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: After manually hacking one of the BlueLeaks sites, the hacker likely automated
    the process for the rest of the BlueLeaks sites. Perhaps they created a shell
    script that used cURL instead of a web browser to perform the same steps. They
    could have run that script in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop targeting all 251 websites, uploading hundreds of gigabytes of data to themselves,
    in a single Saturday evening. They then likely forgot to delete the *blug.aspx*,
    *pscp64.exe*, *7z.exe*, and *ntdaddy.aspx* files before submitting the dataset
    to DDoSecrets.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4-2: Explore BlueLeaks on
    the Command Line</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you’ll start exploring the contents of your unzipped BlueLeaks
    files, using commands and advanced shell features that let you quickly measure
    file and folder size and sort and count lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculate How Much
    Disk Space Folders Use</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> command (short for
    “disk usage”) is a powerful tool for assessing a new dataset. Linux and macOS
    come with slightly different versions of <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp>.
    The Linux version, which is part of a software package called GNU coreutils, is
    better and more up to date at the time of writing, so you’ll use it for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Users of Linux and Windows with WSL should already have the correct built-in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp> tool. If you’re using
    macOS, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install coreutils</samp>
    in the terminal to install coreutils. After this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp>
    command will run the macOS version of the tool, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">gdu</samp>
    command will run the coreutils version that you just installed. In the following
    commands, macOS users should replace <samp class="SANS_TheSansMonoCd_W5Regular_11">du</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">gdu</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out how much space the extracted BlueLeaks dataset takes, open your
    terminal and run this command, using the path to the *BlueLeaks-extracted* folder
    on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> argument in this
    command (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--summarize</samp>)
    displays the total disk space of a folder rather than how much space each file
    inside it takes up. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-h</samp>
    argument (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--human-readable</samp>)
    shows file sizes in units like kilobytes, megabytes, or gigabytes, rather than
    in terms of system blocks (a unit that changes depending on how your disk is set
    up). Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">--apparent-size</samp>
    argument shows you how big the files actually are, as opposed to how much space
    they take up on your disk.
  prefs: []
  type: TYPE_NORMAL
- en: The command checks the size of every file in BlueLeaks and adds them all together,
    so it takes a while to run. When it’s done, it should tell you that the *BlueLeaks-extracted*
    folder takes up 269GB.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In addition to using <samp class="mono">-h</samp> to generate human-readable
    units, you can specify which units you want to use. The <samp class="mono">-b</samp>
    argument, short for <samp class="mono">--bytes</samp>, shows file sizes in bytes,
    <samp class="mono">-k</samp> shows them in kilobytes, and <samp class="mono">-m</samp>
    shows them in megabytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll measure the size of an individual folder in BlueLeaks. Change
    to your *BlueLeaks-extracted* folder; for example, I’d run <samp class="SANS_TheSansMonoCd_W5Regular_11">cd
    /media/micah/datasets/BlueLeaks-extracted</samp> on my Linux computer. From there,
    run the following command to measure the size of the *ncric* folder, which contains
    documents from the Northern California Regional Intelligence Center (NCRIC), the
    fusion center I’ve spent the most time researching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The output should tell you that the *ncric* folder takes 19GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the size of each folder in BlueLeaks, you could run the <samp class="SANS_TheSansMonoCd_W5Regular_11">du
    -sh --apparent-size</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">path</samp>
    command for each folder, but it’s quicker to use another <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. Run the following code in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, you can run multiple commands on the same line by separating
    them with semicolons (<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>).
    This one-liner loops through the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>
    command, which, since you’re currently in the *BlueLeaks-extracted* folder, is
    the name of each BlueLeaks folder. The code stores these names in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FOLDER</samp>
    variable and then, inside each iteration of the loop, runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">du
    -sh --apparent-size $FOLDER</samp> command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the first few lines of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This shows you how much disk space each folder uses.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use Pipes and Sort
    Output</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You now know the size of each folder in the BlueLeaks dataset. Next, you’ll
    sort the 168 folders in order of disk space. By determining which folders are
    the largest, you can quickly tell which fusion centers have the most data and
    therefore are probably the biggest or most active.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort this list of folders by the smallest file size to the largest, use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sort</samp> command, which takes
    a list of text lines and, by default, sorts them *alphanumerically*; that is,
    text is sorted alphabetically and numbers are sorted by their first numeral. For
    example, the list <samp class="SANS_TheSansMonoCd_W5Regular_11">file1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">file10</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">file2</samp>,
    …, <samp class="SANS_TheSansMonoCd_W5Regular_11">file9</samp> is sorted alphanumerically:
    since text lines are sorted one character at a time, and since <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">file10</samp>
    comes before <samp class="SANS_TheSansMonoCd_W5Regular_11">file2</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: To sort your BlueLeaks files by file size, modify the command with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-h</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">--human-numeric-sort</samp>)
    argument. This argument pays attention to the *value* of numbers, not just characters,
    so it correctly places smaller numerical values before larger ones. It also takes
    file size units into account, meaning it will place 2MB before 1GB, even though
    2 is numerically greater than 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'In shell scripting, the *pipe* operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>)
    lets you take the output of a command to the left of the operator and pipe it
    into the command on the right. When you pipe input into the <samp class="SANS_TheSansMonoCd_W5Regular_11">sort</samp>
    command, it outputs a sorted version of that input. Run the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop from the previous subsection, this time piping the output into <samp class="SANS_TheSansMonoCd_W5Regular_11">sort</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This line first runs the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop that measures the space each BlueLeaks folder takes up. The output of this
    code is a list of lines of text, where each line starts with the human-readable
    size of a folder. Piping those lines of text as input into the <samp class="SANS_TheSansMonoCd_W5Regular_11">sort
    -h</samp> command sorts those lines numerically while paying attention to the
    file size units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The folders that have the least data should be at the top: *miacxold*, *ncric-history-good*,
    and *ncricSteveBackup* contain only empty subfolders. The *repo* folder, the largest
    folder in BlueLeaks, should appear at the bottom of the list, right after *miacx*,
    the second-largest folder.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create an Inventory
    of Filenames in a Dataset</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re working with an enormous dataset like BlueLeaks, it’s helpful to
    create an inventory of all of the files it contains by listing them in a text
    file. This way you can easily count the number of files in the dataset or search
    for filenames without having to go through the much slower process of looping
    through the dataset itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create this inventory with the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    command, which outputs a list of files and folders in a folder. From within the
    *BlueLeaks-extracted* folder, run the following command to list all of the files
    in BlueLeaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first argument after <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    is the folder whose contents you want to list. This command uses a dot to find
    files in the current folder, but you could use any relative or absolute path.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-type f</samp> arguments filters
    the list so it includes only files. (To include only folders, add the <samp class="SANS_TheSansMonoCd_W5Regular_11">-type
    d</samp> arguments.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this command, the names of the many files in BlueLeaks should
    start rapidly scrolling across your terminal. To make the output more manageable,
    run the command again, this time redirecting the output into the file *../BlueLeaks-filenames.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in [Chapter 3](chapter3.xhtml), redirection tells your shell to
    take the output from the left side of the redirection operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>)
    and save it into the file at the path you specify on the right. In this case,
    the shell sends the list of filenames from the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    command to the *BlueLeaks-filenames.txt* file on your *datasets* USB disk, rather
    than displaying the filenames across your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read through these filenames at your leisure, open *BlueLeaks-filenames.txt*
    in VS Code by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It’s easier to slowly scroll through these files in your text editor, but there
    are too many to count with the naked eye.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Count the Files in
    a Dataset</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> command takes some
    input and tells you how many characters, words, or lines it contains. When used
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">--lines</samp>)
    argument, it counts the number of lines. To count the lines in the *BlueLeaks-filenames.txt*
    file you created, and by extension count the number of files in BlueLeaks, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command outputs
    the contents of a file—in this case, *BlueLeaks-filenames.txt*. Instead of displaying
    it, the command pipes the output into <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>
    to count the number of lines that it contains. It should tell you that there are
    just over *one million* files in BlueLeaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to get the same result is to run the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    command from the previous section again, and pipe its output into <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That command takes longer to run, though, since it searches through the whole
    dataset again (press CTRL-C to cancel this command before it finishes).
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4-3: Find Revelations in
    BlueLeaks with grep</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the summer of 2020, while American society was going through a long-due
    reckoning about the scale of racist police killings, right-wing media (and police)
    instead focused on the dangers of the protesters themselves. They lumped the modern
    civil rights movement into two categories: “Black Lives Matter” and “antifa,”
    the latter a label used by antifascist activists since the 1930s. The modern American
    antifa movement grew in response to the 2016 election of Donald Trump and the
    mainstreaming of white supremacy in the US.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> command will filter
    input for keywords, letting you search the content of datasets for newsworthy
    information. In this exercise, you’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    to find out what police had to say about antifa during the protests.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Documents
    Mentioning Antifa</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll start by grepping your list of filenames to find any that include the
    word *antifa*. From the *BlueLeaks-extracted* folder, search the *BlueLeaks-filenames.txt*
    file that you created in Exercise 4-2 by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This command pipes the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">cat
    ../BlueLeaks-filenames.txt</samp>, which is a list of a million filenames, into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">grep antifa</samp>. This should
    filter the huge list of filenames to show you only those that include the word
    *antifa*. However, it returns no results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> command
    is case sensitive, try again using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">--ignore-case</samp>) argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run this command, I get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command returns 12 results, all files that have the term *antifa* in their
    filenames. The <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> command
    might highlight your search terms in each line of output by coloring them differently;
    I’ve highlighted them here in bold. Open a few of the documents in this list to
    see what they contain.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can run BlueLeaks documents through Dangerzone if you like, but the risks
    are low with this dataset. These documents are now all public, so if any have
    tracking technology that lets the original file owner know someone is looking
    at the document, it doesn’t matter much. Given that these are hacked documents
    from police fusion centers, not attachments on phishing email messages or something
    similar, they’re also unlikely to be malicious.*'
  prefs: []
  type: TYPE_NORMAL
- en: I often combine <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to make lists of filenames
    and filter those lists down, which allows me to locate files on my computer more
    quickly and precisely than with my operating system’s graphical file search tools.
    For example, suppose you’re looking into the *azhidta* folder for the Arizona
    High Intensity Drug Trafficking Area site. To quickly find any documents that
    have the word *marijuana* in their filename, you could run <samp class="SANS_TheSansMonoCd_W5Regular_11">find
    azhidta | grep -i marijuana</samp>. To count the number of files with *marijuana*
    in the filenames, you could pipe all of that into the <samp class="SANS_TheSansMonoCd_W5Regular_11">wc
    -l</samp> command.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Certain
    Types of Files</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to searching for keywords like *antifa* or *marijuana*, <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    can help you filter a list of filenames to include only certain file types. Grep
    for Microsoft Word documents, filenames that end in *.docx*, by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This command uses <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    to display the list of filenames in BlueLeaks, then filters it down for those
    that contain *.docx*. You should see thousands of filenames scroll by. To learn
    exactly how many, run the command again, this time piping the output into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> command should tell
    you that the previous command had 8,861 results.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Use grep with Regular
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you scroll through the *.docx* filenames you just found, you’ll see that
    a few of them aren’t actually Word documents. For example, the filename *./arictexas/files/DDF/2014
    Austin City Limits Festival - APD Threat Overview.docx.pdf* contains *.docx* but
    is actually a PDF.
  prefs: []
  type: TYPE_NORMAL
- en: When you use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>, you
    can pass a regular expression (regex for short) into it as an argument. A *regex*
    is a character or sequence of characters that defines a search pattern. For example,
    the caret character (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>) represents
    the beginning of a line, and the dollar sign character (<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>)
    represents the end of a line. Grepping for <samp class="SANS_TheSansMonoCd_W5Regular_11">something$</samp>
    will show you only results that end with *something*. Grepping for <samp class="SANS_TheSansMonoCd_W5Regular_11">^something</samp>
    will show you only results that begin with *something*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search just for filenames that end with *.docx*, add a dollar sign (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$</samp>) to the end of the text you’re
    grepping for. For example, try running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output should tell you that there are 8,737 results, 124 less than the previous
    command. That means there are 8,737 Word docs in this dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to find out how many Word docs are in the *ncric*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command outputs
    the list of filenames in BlueLeaks, which is then piped into the first <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    command, which in turn filters your output down to files that begin with *./ncric*,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>. Next, that output
    is piped into the second <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    command, which further filters the output to files that end with *.docx*, using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>. Finally, the remaining
    output is piped into the <samp class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp>
    command, which tells you how many lines are left. The output of the full command
    should tell you that there are 600 Word docs in the *ncric* folder.
  prefs: []
  type: TYPE_NORMAL
- en: On your own, try using <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp>
    to find out how many PDFs (*.pdf*) and Excel documents (*.xlsx*) are in the dataset.
    You can also experiment with other file types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Search Files in Bulk
    with grep</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to piping output from other commands into <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>,
    you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to search
    directly within text files by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, Linux comes with a file called */etc/passwd*, which includes a
    list of users on the system. To find just the line about my own user in that file,
    I can use one of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> command opens
    the */etc/passwd* file and then searches it, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>
    command opens that file and then pipes its contents into <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>,
    which searches it. Both of these commands output the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to search
    multiple files, or even folders full of files, for hits all at once. As noted
    earlier, to search a folder, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-r</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">--recursive</samp>) argument
    and specify the name of a folder. To specify multiple files at once, use an asterisk
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) as a wildcard character.
    For example, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">*.txt</samp>
    as the filename to search all text files in your current folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are CSV spreadsheets in every BlueLeaks folder that contain the contents
    of the websites’ databases. Now that you’ve grepped for filenames that contain
    the keyword *antifa*, use the following command to bulk-search the term *Black
    Lives Matter* in the contents of the files, not just in their filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> argument in this
    command makes the search case insensitive. The <samp class="SANS_TheSansMonoCd_W5Regular_11">black
    lives matter</samp> argument is the search term (in quotation marks, because it
    has spaces). The <samp class="SANS_TheSansMonoCd_W5Regular_11">*/*.csv</samp>
    argument is the path to search, which uses two wildcard characters. These arguments
    tell <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to open every folder,
    then each file within those folders that ends in *.csv*, and search for the *black
    lives matter* keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command takes some time to run because it’s searching all 158,232 CSV
    files in BlueLeaks. When it’s finished, it should show you the lines from CSV
    files that mention *black lives matter* and tell you in which files it found those
    lines. For example, here are snippets from a few of the lines of the output from
    that command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The command finds a total of 178 lines in BlueLeaks CSVs that contain the term
    *black lives matter*. Each is a potential lead for further investigative research.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">grep</samp> command
    is a great tool for searching the content of text files, but it doesn’t work with
    binary files, like Microsoft Office documents or PDFs. To search those in bulk,
    you’ll need more sophisticated tools, which you’ll learn about in [Chapter 5](chapter5.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: On your own, try using <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    to filter the list of BlueLeaks filenames for specific words or bulk-search terms
    within the CSV files. If you find any interesting documents, read them to see
    if they’re newsworthy. Consider narrowing your searches once you find a lead by
    looking for other related documents. You might focus on a single fusion center
    or a topic like antifa that spans different centers. Individual documents may
    contain law enforcement lingo you can use as search terms for related documents.
    Take detailed notes on what’s most revealing in each document, then rely on these
    notes if you decide to write about your findings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encrypted Data in the BlueLeaks Dataset</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you dig around in the BlueLeaks dataset, you’ll notice some patterns. Most
    folders contain many CSVs, as well as.*aspx* files, the source code of the hacked
    websites. They also contain *files* subfolders containing the bulk of the files
    and folders uploaded to each site, including PDFs and Microsoft Office documents.
  prefs: []
  type: TYPE_NORMAL
- en: However, one folder, *repo*, contains just a *config* file and *data*, *index*,
    *keys*, *locks*, and *snapshots* subfolders. Inside those subfolders are other
    subfolders and files with apparently random names. There are no documents that
    can be opened—no spreadsheets or similar files. As you discovered in Exercise
    4-2, the *repo* folder is the largest folder in BlueLeaks, at 46GB. Its timestamps
    are from June 8, 2020, although the latest timestamps for most of the rest of
    the dataset are from June 6\. Without more information, it’s not clear what these
    files mean or how to access them.
  prefs: []
  type: TYPE_NORMAL
- en: When I discover a mystery like this in a dataset, I search the internet. In
    this case, I searched for the names of the files and folders within the *repo*
    folder by entering *config data index keys locks snapshots* into a search engine,
    and found documentation for a CLI program called restic. A restic repository,
    according to the documentation I found at [*https://<wbr>restic<wbr>.readthedocs<wbr>.io<wbr>/en<wbr>/latest<wbr>/100<wbr>_references<wbr>.html*](https://restic.readthedocs.io/en/latest/100_references.html),
    is a folder that holds backup data. Restic repositories contain a *config* file
    and folders called *data*, *index*, *keys*, *locks*, and *snapshots*, as shown
    in [Figure 4-2](#fig4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Documentation for the CLI program restic. This describes the “Repository
    Layout” of a restic repository, which has the same folder names as in the repo
    folder.](Images/Figure4-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The layout of a
    restic respository</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This suggests that the *repo* folder in BlueLeaks contains backup data in restic
    format. To find out what’s inside this backup, I installed the <samp class="SANS_TheSansMonoCd_W5Regular_11">restic</samp>
    package. Users of Linux or Windows with WSL can install <samp class="SANS_TheSansMonoCd_W5Regular_11">restic</samp>
    using apt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Mac users can install <samp class="SANS_TheSansMonoCd_W5Regular_11">restic</samp>
    from Homebrew with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'I ran <samp class="SANS_TheSansMonoCd_W5Regular_11">restic --help</samp> and
    found that I could view the snapshots in a repository with the <samp class="SANS_TheSansMonoCd_W5Regular_11">restic
    snapshots</samp> command, which I then used to try to view the snapshots in the
    *repo* folder like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'I was then confronted with a password prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This prompt indicates that the backup is encrypted. The only way to proceed
    is to guess the password, which I haven’t been able to do.
  prefs: []
  type: TYPE_NORMAL
- en: While a 46GB folder full of encrypted data in a public leak is rare, it’s not
    uncommon to stumble upon other encrypted files in datasets like Office documents
    or ZIP files. I can’t help but imagine that the most interesting details in any
    dataset might be the encrypted parts. Password-cracking is outside the scope of
    this book, but if you can figure out the password for *repo*, please let me know.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Data Analysis with Servers in the Cloud</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you’ve used the CLI *locally* on your own computer, but you can also
    use it *remotely* via servers to which you connect through a cloud network. DigitalOcean,
    AWS, Microsoft Azure, and countless other cloud hosting companies rent virtual
    private servers (VPSes) to the public, usually for a few dollars a month or a
    few cents an hour. All the command line skills you’ve learned so far apply to
    remote servers, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many advantages to working with massive datasets in the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of dealing with USB hard disks, you can attach virtual hard disks to
    your virtual servers, increasing their size if you’re running low on disk space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPS bandwidth is generally much better than residential or commercial internet
    service, speeding up large dataset downloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also pay for more powerful VPSes for scripts that require significant
    computational resources, so they no longer take hours or days to finish running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than being forced to wait while a script runs on your local machine,
    you can do whatever you want on your computer, even suspending it or shutting
    it down, while your remote server is crunching data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your source has the required technical skills, you can ask them to upload
    data to a VPS with a large hard disk, as discussed in [Chapter 2](chapter2.xhtml).
    They can even do this anonymously using Tor. You can then download the dataset
    or choose to analyze it remotely on the VPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Avoid working on cloud servers with high- or medium-sensitivity datasets.
    The cloud hosting provider has total access over your VPS and the data on it and
    can even give copies of that data to law enforcement or other parties in response
    to legal requests.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will go into more detail on *SSH (Secure Shell)* software (introduced
    in [Chapter 2](chapter2.xhtml)), which allows you to securely get a shell on a
    VPS, as well as two tools that are essential for working remotely on the command
    line: text-based window managers and CLI text editors. This should prepare you
    to set up a VPS in the next exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSH protocol is a method for securely logging in to another computer remotely.
    You can connect to a VPS remotely by running the <samp class="SANS_TheSansMonoCd_W5Regular_11">ssh</samp>
    command with a username and the IP address or domain name of the server to which
    you want to connect. For example, to log in as the root user to the server with
    the hostname *example.com*, you run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You then need to *authenticate* to the server, or prove that you have permission
    to log in, by typing the user password or using *SSH keys*. Similar to PGP keys
    (discussed in [Chapter 2](chapter2.xhtml)), generating an SSH key on your computer
    gives you two files: a public key and a secret key. Once you put your public key
    on the remote server, only people with your secret key on their computer (hopefully
    just you) can remotely log in to that server using SSH. If someone spies on your
    internet, they can’t see anything you’re doing in your SSH session—they’ll just
    see garbled encrypted data. Every SSH key also has a *fingerprint*, a unique string
    of characters that identifies that specific key. SSH keys are more secure than
    passwords, so cloud providers often require that you use them. Once you SSH into
    a remote server, you’ll be dropped into a shell just like the one on your own
    computer, but running on a computer across the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: A *text-based window manager* is software that lets you open and switch between
    separate shells in the same terminal window, all in the same SSH session. Text-based
    window managers also allow you to keep programs running in the background even
    if you disconnect from SSH, by maintaining an active shell session on your VPS.
    This protects your work if, for example, your laptop dies, you lose internet access,
    or you close your terminal window by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to download BlueLeaks on your VPS and then unzip it
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. If you close
    your terminal window before the loop is done, you’ll quit the remote shell, which
    will close the <samp class="SANS_TheSansMonoCd_W5Regular_11">unzip</samp> program,
    and your remote work will stop. However, if you SSH to your VPS, connect to a
    window manager session, and then start unzipping BlueLeaks files, you can safely
    close the terminal window without stopping your work. If you open a new terminal
    later, SSH back into your server, and open your window manager again, your previous
    session with all your running programs should reappear. In the upcoming exercise,
    you’ll use the Byobu window manager, which comes with Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: When you SSH into a remote server, you don’t have easy access to a graphical
    text editor like VS Code. To edit files—to modify a shell script, for example—you’ll
    need to use a CLI text editor instead. Two popular CLI text editors are nano and
    vim. The nano text editor is relatively easy to use but doesn’t have advanced
    features, while vim is more powerful but has a steeper learning curve. For simplicity’s
    sake, in the following exercise you’ll use nano.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Technically, you can use VS Code to edit files remotely over SSH, but there
    are some limitations. See* [https://<wbr>code<wbr>.visualstudio<wbr>.com<wbr>/docs<wbr>/remote<wbr>/ssh](https://code.visualstudio.com/docs/remote/ssh)
    *for more information on VS Code’s support for editing files over SSH.*'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4-4: Set Up a VPS</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you’ll create an account on a cloud hosting provider, generate
    an SSH key, create a VPS on your cloud provider, SSH into it, start a Byobu session,
    and install updates. To follow along you’ll need to spend a small amount of money.
    I provide detailed instructions for using DigitalOcean in this exercise, but use
    whatever cloud hosting provider you prefer, keeping in mind that the initial steps
    will likely be slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [*https://<wbr>www<wbr>.digitalocean<wbr>.com*](https://www.digitalocean.com)
    and create an account, providing a credit card number while signing up. Use a
    strong password, store it in your password manager, and turn on two-factor authentication.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generate an SSH Key</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To generate an SSH key, open a terminal on your local computer (if you’re using
    Windows, use a WSL terminal) and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ssh-keygen</samp> command
    generates an SSH key, while the options specify the type of encryption key you
    want to generate—in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">ed25519</samp>,
    which uses modern elliptic curve encryption and is the most secure option.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you run this command, the program will ask you a few questions, starting
    with where you want to save your key. For example, I get the following output
    on my Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Press ENTER to use the default location for the key, *~/.ssh/id_ed25519*. Next,
    the program should ask you for a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: I recommend generating a random passphrase in your password manager, saving
    it as *SSH key passphrase*, then copying and pasting the passphrase into your
    terminal. After pressing ENTER, re-enter your passphrase and press ENTER again.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re done, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ssh-keygen</samp>
    command should have created two new files: your SSH secret key in *~/.ssh/id_ed25519*
    and your SSH public key in *~/.ssh/id_ed25519.pub*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re using Windows and prefer to SSH from PowerShell, you can install
    the OpenSSH client directly in Windows. Open a PowerShell window as an administrator
    and run* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">Add-WindowsCapability
    -Online -Name OpenSSH.Client~~~~0.0.1.0</samp> *to enable using the ssh command
    from PowerShell.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Add Your Public Key
    to the Cloud Provider</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, add your public key to your new DigitalOcean account. After logging in
    to the web console, go to the Settings page and switch to the Security tab. Click
    **Add SSH Key**, then copy and paste your SSH public key into the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in your terminal, display the content of your public key by running this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output I get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Your output should look similar, with the last word being your username and
    the hostname of your own computer. Copy this whole string, starting with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ssh-ed25519</samp>, and paste it into
    DigitalOcean, then give it a name, as shown in [Figure 4-3](#fig4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the DigitalOcean console, where you can copy and paste the
    SSH public key to add it to your account.](Images/Figure4-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The form for adding
    a new SSH key to a DigitalOcean account</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Name your SSH keys after the computer on which you generated them, since they’re
    allowing this specific computer to access remote computers. For example, I’ve
    called my key *trapdoor*, the name of my Mac.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create a VPS</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that DigitalOcean has your SSH public key, you can create a new VPS. Click
    **Create** at the top of the DigitalOcean console and follow the instructions
    to create a new *droplet*, DigitalOcean’s term for a VPS. Choose the following
    settings for your VPS:'
  prefs: []
  type: TYPE_NORMAL
- en: For Choose an Image, pick **Ubuntu**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Choose a Plan, pick **Shared CPU**▸**Basic** and choose how much memory,
    CPU power, hard disk space, and internet bandwidth you want. Less powerful machines
    are cheaper; more powerful ones are more expensive. For this exercise, choose
    a relatively cheap option like 1GB of RAM, 1 CPU, 25GB of disk space, and 1TB
    of bandwidth for $7 per month.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Add Block Storage, you can choose to attach an additional hard disk to your
    droplet. You don’t need to do this now, but in the future, to work with a large
    dataset like BlueLeaks, you can add more disk space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Choose a Datacenter Region, choose the host city for your VPS. File transfers
    between your computer and your server will be fastest if you choose a nearby location,
    but feel free to create your VPS anywhere you’d like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Authentication, choose **SSH Keys** and select the SSH key that you just
    added to your DigitalOcean account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Select Additional Options, check the box beside Monitoring to see statistics
    about how much memory and processor power the VPS is using over time from the
    DigitalOcean console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Finalize and Create, choose one droplet and give it the hostname *test-vps*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create Droplet** and wait a minute or two for DigitalOcean to provision
    your new VPS, then find its IP address. [Figure 4-4](#fig4-4) shows the Droplets
    page of my DigitalOcean account with my new server’s IP address, 178.128.22.151.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot from the DigitalOcean console that lists my VPS and its IP address.](Images/Figure4-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: My test-vps IP
    address</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Click the IP address to copy it to your clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SSH into Your Server</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Run the following command to SSH into your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">username</samp>
    is the user you want to connect to on the remote server, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">hostname</samp>
    is either the hostname or IP address of the remote server. With DigitalOcean,
    the username is <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp> and
    the hostname is the IP address of your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it looks like when I SSH into my server for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: A remote server has its own SSH key, a *server key.* This output shows you the
    server key’s fingerprint and asks whether you want to trust it. If you enter <samp
    class="SANS_TheSansMonoCd_W5Regular_11">yes</samp>, your SSH software will store
    this fingerprint in the *~/.ssh/known_hosts* file containing all the fingerprints
    for the SSH servers to which you’ve connected in the past, so that when you SSH
    into your server in the future, it shouldn’t prompt you again. You can also enter
    <samp class="SANS_TheSansMonoCd_W5Regular_11">no</samp> to cancel, or copy and
    paste the fingerprint of the server key that you’re expecting.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you SSH into a server and the fingerprint isn’t what your software expects
    it to be, SSH will show you a warning message, which could mean that the server
    key has changed or that your SSH connection is being attacked. This authentication
    scheme is known as* trust on first use (TOFU)*: you trust the first fingerprint
    you see and deny all other fingerprints for that server in the future.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">yes</samp> and press ENTER
    to continue. You should be dropped into a root shell on your remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Since you provided DigitalOcean with your SSH public key, you don’t need to
    enter a password to log in. If anyone else tries SSHing to your server, they’ll
    get the <samp class="SANS_TheSansMonoCd_W5Regular_11">Permission denied (publickey)</samp>
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look around your new cloud-based system. Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp>
    to list files, <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls -al</samp> to see
    hidden files, and <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cd</samp> to change
    to folders.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Start a Byobu Session</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you used the Ubuntu image to set up your droplet, the Byobu window manager
    should be installed. Run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">byobu</samp>
    command to start a Byobu session. (If you’re using a different operating system,
    or if for some reason Byobu isn’t installed, you’ll get a <samp class="SANS_TheSansMonoCd_W5Regular_11">Command
    'byobu' not found</samp> error message. Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">apt
    update</samp>, followed by <samp class="SANS_TheSansMonoCd_W7Bold_B_11">apt install
    byobu</samp>, to install the program.)
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">byobu</samp> command should
    drop you into a shell inside of your new session. A line at the bottom of your
    terminal shows which window you’ve opened, along with information like the date
    and time. Each Byobu window is like its own separate shell in the same Byobu session,
    and you can open as many windows as you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how Byobu works, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">whoami</samp>
    (which should tell you that you’re the root user) and <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls
    -l /</samp> (which should show you a list of files in your server’s root folder).
    Now press CTRL-A. Byobu will ask you how you want this keyboard command to operate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">1</samp> and press ENTER.
    This allows you to open a new window in Byobu by pressing CTRL-A, followed by
    C (for “create”). Try that now to open a new empty shell. Press CTRL-A followed
    by N (for “next”) to switch back to your first window. To exit a Byobu window,
    you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> command
    in that shell.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*See* [https://<wbr>www<wbr>.byobu<wbr>.org](https://www.byobu.org) *for more
    complete documentation about this program, including a video tutorial.*'
  prefs: []
  type: TYPE_NORMAL
- en: Completely close your terminal window and click through any warnings saying
    that your active programs will close if you do this. Open a new terminal window
    and SSH back into your server using the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ssh</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">username@hostname</samp>
    command. Then run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">byobu</samp> again
    to attach your previous session. Any programs you run inside this Byobu session
    won’t quit when you disconnect from SSH.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Install Updates</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Always install updates when you set up a new server to keep it secure. Run
    the following commands (you don’t need to use <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>,
    since you’re the root user):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions to finish installing updates.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever need to reboot your server (such as after updating the Linux kernel),
    run the <samp class="SANS_TheSansMonoCd_W5Regular_11">reboot</samp> command. You’ll
    get kicked out of your SSH session, but you should be able to SSH back in shortly
    when the reboot completes. You can also reboot your VPS from DigitalOcean’s web
    console—for example, if the entire server crashed and you can’t SSH into it.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 4-5: Explore the Oath Keepers
    Dataset Remotely</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, you’ll use BitTorrent to download the Oath Keepers dataset
    to your cloud server and explore it using the skills you’ve gained in this chapter.
    You’ll also learn to copy data from your remote server to your laptop using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp> command. Finally, you’ll
    delete your VPS to avoid getting charged for time when you’re not using it.
  prefs: []
  type: TYPE_NORMAL
- en: The Oath Keepers dataset contains data from the far-right extremist group that
    participated in the January 6, 2021, US Capitol insurrection. In September 2021,
    a hacktivist broke into the Oath Keepers servers and made off with the group’s
    email messages, chat logs, membership lists, and other data, and then leaked it
    to DDoSecrets. You’ll continue working with this dataset when you learn to analyze
    email dumps in [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This book works only with the publicly available part of the Oath Keepers
    dataset, which contains email messages and chat logs. To access content like the
    Oath Keepers’ donor and membership lists, which contain PII, contact DDoSecrets.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because your home or office internet connection is likely significantly slower
    than a cloud provider’s, it’s inefficient to download a dataset to your laptop
    and then upload it to your remote server. To download the dataset directly to
    your VPS, you’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">transmission-cli</samp>,
    the command line version of the BitTorrent client you used to download BlueLeaks
    in [Chapter 2](chapter2.xhtml). In your VPS, run the following command to install
    <samp class="SANS_TheSansMonoCd_W5Regular_11">transmission-cli</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">transmission-cli</samp>
    command to download files. You must pass in either the path to a *.torrent* file
    or a magnet link as an argument. In this exercise, you’ll use the torrent file
    available at [*https://<wbr>ddosecrets<wbr>.com<wbr>/wiki<wbr>/Oath<wbr>_Keepers*](https://ddosecrets.com/wiki/Oath_Keepers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new folder called *datasets* on your server, then changes to
    it. Download the torrent file from the link on the DDoSecrets page and load it
    into your BitTorrent client with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> command downloads
    files—in this case, *Oath_Keepers.torrent*—and saves them in the current folder.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">transmission-cli</samp> command
    downloads the 3.9GB torrent to your server from the BitTorrent swarm and uploads
    parts of it to other parts of the swarm. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-w
    .</samp> arguments tell <samp class="SANS_TheSansMonoCd_W5Regular_11">transmission-cli</samp>
    to download the torrent into the current working folder. (You could change that
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">-w ~/Downloads</samp>, for example,
    if you wanted to download it into the *~/Downloads* folder instead.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If no torrent file is available for a dataset, you can replace the torrent
    filename with a magnet link in double quotes as an argument in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">transmission-cli</samp>
    command.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve finished downloading the torrent, your server will be a seed until
    you quit the program by pressing CTRL-C. While you’re waiting for the dataset
    to finish downloading, or if you’ve finished but want to continue seeding the
    torrent, you can work on your VPS in a separate Byobu shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check how much free space your server has left, run the following command
    after the download is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">df</samp> command tells you
    how much disk space is free on each connected drive, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-h</samp>
    argument displays these numbers in human-readable units. After downloading the
    Oath Keepers dataset, I got the following output from these commands on my server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As shown in bold, my root partition mounted on <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    has 25GB of space, has used 5.8GB, and has 19GB free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your working directory to *~/datasets/Oath Keepers*, remembering to
    put the filepath in quotes or escape the space in the path. For example, you could
    run this command from the *~/datasets* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to find that the Oath Keepers dataset takes up 3.9GB
    of space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp> command
    to list the files in the *Oath Keepers* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that this folder contains a folder called *Oath Keepers.sbd*,
    a 12MB file called *messages.json*, and a 1.4MB file called *messages_old.json*.
    These JSON files are chat logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the *Oath Keepers.sbd* folder and run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls</samp>
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that this folder contains 100 files, each representing a different
    inbox full of email.
  prefs: []
  type: TYPE_NORMAL
- en: Since you’ll use the Oath Keepers dataset later in the book, next you’ll copy
    it from your VPS to your *datasets* USB disk with the <samp class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp>
    program, which synchronizes local folders and remote folders using SSH.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* *<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">scp</samp> command
    (short for “secure copy”) also copies files and folders from your computer to
    a remote server, or vice versa, over SSH. The BlueLeaks hacker likely used a Windows
    version of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">scp</samp>,*
    pscp64.exe*, to exfiltrate data from the hacked police web servers to a server
    they controlled. For very large folders, however, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">rsync</samp>
    is often a better choice than <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">scp</samp>,
    since if it fails halfway through, you can rerun the command and it will start
    where it left off.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal running locally on your computer (not SSHed to your VPS) and
    run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">which rsync</samp> to check whether
    <samp class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp> is installed. If so,
    the command returns the path to the program, something like */usr/bin/rsync*.
    If not, you’ll see no output. Windows with WSL and Linux users can install <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp> with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'macOS users can install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy a file from a remote server to your local computer, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-av</samp> argument is a combination
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">-a</samp> (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--archive</samp>),
    which preserves the file permissions in the copy you’re making, and <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp>
    (short for - -<samp class="SANS_TheSansMonoCd_W5Regular_11">verbose</samp>), which
    outputs each filename as it copies the files. The <samp class="SANS_TheSansMonoCd_W5Regular_11">--progress</samp>
    argument displays progress bars for each file as it’s copying. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp>
    command will SSH into the server <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">remote_host</samp>
    with the username <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">remote_user</samp>.
    If it authenticates successfully, it will download the file or folder at <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">remote_path</samp> and save it
    on your computer at <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">local_path</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how I’d download the Oath Keepers dataset from my VPS to
    my *datasets* USB disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">root@178.128.22.151:"~/datasets/Oath\
    Keepers"</samp> is the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">remote
    _user</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">remote_host</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">remote_path</samp>
    argument, since the *Oath Keepers* folder is in the *datasets* folder in the root
    user’s home folder on my VPS. I put the remote path in quotes and escape the space
    in the filename, telling my local shell that <samp class="SANS_TheSansMonoCd_W5Regular_11">root@178.128.22.151:"~/datasets/Oath\
    Keepers"</samp> is a single argument. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">local_path</samp>
    argument is the <samp class="SANS_TheSansMonoCd_W5Regular_11">/media/micah/datasets/</samp>
    path to my *datasets* USB disk.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can also use <samp class="mono">rsync</samp> to upload files from your
    computer to a remote server—just put the <samp class="mono">local_path</samp>
    argument first, as the source, and put the <samp class="mono">remote_user@remote_host:remote_path</samp>
    argument second, as the destination.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output I get when I run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp> command copies
    every file, one at a time, from the remote folder to the local folder over SSH,
    displaying a line after each filename that shows the file’s download speed and
    progress. You can press CTRL-C to cancel the command, then rerun that command,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp> should continue
    where it left off. This is especially useful when you need to copy gigabytes or
    terabytes of data spread across millions of files—if the file transfer fails,
    you can pick up where you left off.
  prefs: []
  type: TYPE_NORMAL
- en: Once <samp class="SANS_TheSansMonoCd_W5Regular_11">rsync</samp> finishes running,
    you’ll have downloaded a local copy of the Oath Keepers dataset to your *datasets*
    USB disk. You’ll use this dataset again in [Chapter 6](chapter6.xhtml), when you
    learn techniques for researching email dumps.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">WARNING</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Destroy your VPS from the DigitalOcean web console when you’re done with it.
    Using it for an hour or two should cost you only a few cents, but the bill can
    get expensive if you don’t pay attention.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve put your command line skills to the test, unzipping
    the compressed files in BlueLeaks and learning to quickly search and sort datasets.
    You also worked with servers in the cloud and briefly explored the Oath Keepers
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll continue expanding your command line skills and
    learn two new tools: Docker, which allows you to run Linux software on any operating
    system, and Aleph, which allows you to search datasets by keyword.'
  prefs: []
  type: TYPE_NORMAL
