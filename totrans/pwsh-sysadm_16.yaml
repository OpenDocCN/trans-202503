- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING A SERVER INVENTORY SCRIPT
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far in this book, you’ve focused on learning PowerShell as a language, getting
    familiar with its syntax and commands. But more than a language, PowerShell is
    a tool. Now that you have a grip on the ins and outs of PowerShell, it’s time
    for the fun stuff!
  prefs: []
  type: TYPE_NORMAL
- en: The real power of PowerShell lies in its tool-making abilities. In this context,
    a *tool* refers to a PowerShell script, a module, a function, or something that
    helps you perform a management task. Whether that task is creating a report, gathering
    information about a computer, creating a company user account, or something more
    complex, you’ll learn how to automate it with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll show you how to collect data with PowerShell so you can
    make more-informed decisions. Specifically, you’ll build a server inventory project.
    You’ll learn to create a script with parameters, feed it server names, and discover
    a wealth of information to peruse: operating system specs as well as hardware
    information including storage size, free storage, memory, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you begin this chapter, you need to have a domain-joined Windows computer,
    read permission to Active Directory computer objects, an Active Directory organizational
    unit (OU) of computer accounts, and the Remote Server Administration Toolkit (RSAT)
    software package, which you can download from [*https://www.microsoft.com/en-us/download/details.aspx?id=45520*](https://www.microsoft.com/en-us/download/details.aspx?id=45520).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Project Script(s)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since you’ll be building scripts in this chapter and not just executing code
    at the console, you first need to create a new PowerShell script. Create a script
    called *Get-ServerInformation.ps1*. I’ve put mine in *C:\*. You’ll be adding code
    to this script throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Final Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start coding, it’s good practice to make a “back of the napkin” plan
    of what you want the output to look like when you’re done. This simple sketch
    is a great way to measure progress, especially when building large scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this server inventory script, we’ll say that when the script ends, you’d
    like output to the PowerShell console that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know what you want to see, let’s make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery and Script Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is deciding how to tell your script what to query. You’ll be
    collecting information from multiple servers. As stated in the “Prerequisites”
    section, you’ll use Active Directory to find your server names.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you could query server names from text files, from an array of server
    names stored in a PowerShell script, from the Registry, from a Windows Management
    Instrumentation (WMI) repository, from databases—it doesn’t matter. As long as
    somehow, some way, your script ends up with an array of strings representing server
    names, you’re good to go. For this project, however, you’ll use servers from Active
    Directory.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, all the servers are in a single OU. If you try this on your
    own and you find that they’re not, that’s okay; you’ll just have to loop through
    your OUs and read the computer objects in each. But here, your first task is reading
    all the computer objects in the OU. In this environment, all the servers are in
    the `Servers` OU. Your domain is called `powerlab.local`. To retrieve computer
    objects from AD, use the `Get-ADComputer` command, as shown in [Listing 14-1](ch14.xhtml#ch14list1).
    This command should return all the AD computer objects for the servers you’re
    interested in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: Using `Get-AdComputer` to return server data*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that instead of directly setting the `SearchBase` parameter argument,
    you define a variable. You should get used to doing this. In fact, every time
    you have a specific configuration like this, it’s always a good idea to put it
    into a variable, because you never know when you’ll need to use that value again.
    You also return the output of `Get-ADComputer` to a variable. Since you’ll be
    working with these servers later, you want to have the names to reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Get-ADComputer` command returns the whole AD objects, but you’re looking
    for just the server names. You can narrow this down by using `Select-Object` to
    return only the `Name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a basic idea of how to query an individual server, let’s look
    at how to query all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Each Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To query each server, you need to make a loop that’ll make it possible to query
    every server in your array exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s never a good idea to assume that your code will work immediately (it usually
    doesn’t). Instead, I like to start slow and test each piece as I’m building it.
    In this case, instead of trying to do everything in one go, use `Write-Host` to
    ensure that the script is returning the server names you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By now, you should have a script called *Get-ServerInformation.ps1* that looks
    like [Listing 14-2](ch14.xhtml#ch14list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: Your script so far*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you run the script, you get a few server names. Your output may look different,
    depending on which servers you used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great! You have a loop setup that iterates over each server name in your array.
    Your first task is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking Ahead: Combining Different Types of Information'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the keys to success with PowerShell is good planning and organization.
    Part of this is knowing what to expect. For many beginners, who don’t have much
    experience with the kinds of results PowerShell will give, this is a problem:
    they know what they want to happen (hopefully), but they don’t know what *could*
    happen. As a result, they create scripts that zigzag among data sources, getting
    data from one, and then the other, and then the first, and then the third, linking
    them all together, and doing it all again. There are easier ways to do things,
    and I would be doing you a disservice if I didn’t pause to explain them.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the output in [Listing 14-1](ch14.xhtml#ch14list1), you can see that
    you’ll need a few commands to pull information from various sources (WMI, the
    filesystem, Windows services). Each source will return a different kind of object,
    and you’ll have an absolute mess if you try to combine them thoughtlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jumping ahead a little, let’s get a glimpse of what the output would look like
    if you tried to pull the service name and memory without any formatting or output
    attention. You might get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’re querying a service and trying to get memory from a server at the
    same time. The objects are different, the properties on those objects are different,
    and if you merge all the output and dump it, it looks terrible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to avoid this kind of output. Since you’ll be combining different
    kinds of output, and you need something that fits our exact specifications, you
    have to create your own type of output. Don’t worry, this isn’t as complicated
    as you might think. In [Chapter 2](ch02.xhtml#ch2), you learned how to create
    `PSCustomObject` types. These generic objects in PowerShell allow you to add your
    own properties—perfect for what you’re doing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You know the headers of the output you need (and, as I’m sure you know by now,
    these “headers” will always be object properties). Let’s create a custom object
    with the properties you’d like to see in the output. For obvious reasons, I’ve
    called this object `$output`; you’ll return it after you populate its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that the hashtable keys are surrounded by single quotes. This
    isn’t mandatory if there’s no space in the key. However, because I am using spaces
    in some key names, I decided to standardize on single quotes across all of the
    keys. It’s generally not recommended to use spaces in object property names in
    lieu of using custom formatting, but that is outside the scope of this book. For
    more information on custom formatting, refer to the *about_Format.ps1xml* help
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you copy this to the console, and return it with the formatting cmdlet,
    `Format-Table`, you can see the headers you’re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Format-Table` command is one of a few format commands in PowerShell that
    are meant to be used as the last command in the pipeline. They transform current
    output and display it differently. In this instance, you’re telling PowerShell
    to transform your object output into a table format and autosize the rows based
    on the width of the console.
  prefs: []
  type: TYPE_NORMAL
- en: Once you define your custom output object, you can go back to your loop and
    make sure each server is returned in this format. Since you already know the server
    name, you can set that property right away, as in [Listing 14-3](ch14.xhtml#ch14list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: Putting your `output` object in your loop and setting the server
    name*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you created `output` as a hashtable and cast it as a `PSCustomObject`
    only after you filled it with data. You do this because it’s simpler to keep the
    property values in a hashtable than in a `PSCustomObject`; you care about `output`
    being an object of that type only when it’s being output so that when you bring
    in other sources of information, they will all be the same object type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see all the property names that your `PSCustomObject` has, along with
    the names of the servers you’re querying, with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you have data. It may not seem like much, but you’re well on
    your way!
  prefs: []
  type: TYPE_NORMAL
- en: Querying Remote Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how you’re going to store your data, you just need to get
    it. This means pulling the information you need from each server and returning
    only the properties you care about. Let’s start with the value for `UserProfileSize`
    (MB). To do this, let’s figure out a way to find out how much space is being consumed
    by all these profiles located in the *C:\Users* folder on each server.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way you set up the loop, you need to figure out how to do this
    for only one server. Since you know the folder path is *C:\Users*, let’s first
    see if you can query all the files under all the server’s user profile folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run `Get-ChildItem -Path \\WEBSRV1\c$\Users -Recurse -File` and have
    access to that file share, you can immediately see it’s returning all the files
    and folders in all user profiles, but you don’t see anything related to size.
    Let’s pipe the output to `Select-Object` to return all properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Length` property shows how large the file is in bytes. Knowing this, you’ll
    have to figure out how to add up the `Length` values of each file in the server’s
    *C:\Users* folder. Luckily, PowerShell makes this easy with one of its cmdlets:
    `Measure-Object`. This cmdlet accepts input from the pipeline and automatically
    adds up the values of a specific property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You now have a property (`Sum`) that you can use to represent the total user
    profile size in your output. At this point, it’s just a matter of incorporating
    the code into your loop and setting the appropriate property in your `$output`
    hashtable. Since you need only the `Sum` property from the object returned by
    `Measure-Object`, you’ll enclose the command in parentheses and reference the
    `Sum` property as in [Listing 14-4](ch14.xhtml#ch14list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: Updating your script to store `UserProfilesSize`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the script, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you now have the total size of the user profiles—but it’s not
    in megabytes. You calculated the sum of `Length`, and `Length` is in bytes. PowerShell
    makes conversions like this easy: if you simply divide the number by `1MB`, you’ll
    have your number. You might see the resulting values represented with decimal
    points. You can take a final step and ensure that you have a whole number by casting
    the output to an integer, which will “round” the number to a whole megabyte value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Querying Windows Management Instrumentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have five more values to fill. For four of them, you’ll use a built-in Microsoft
    feature called *Windows Management Instrumentation (WMI)*. Based on the industry
    standard Common Information Model (CIM), WMI is a repository containing real-time
    information about thousands of attributes relating to the operating system and
    the hardware it’s running on. The information is separated into various namespaces,
    classes, and properties. If you’re looking for information about a computer, chances
    are, you’ll be using WMI a lot.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular script, you’ll pull information about hard drive space,
    the operating system version, the server’s IP address, and the amount of memory
    the server contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell has two commands to query WMI: `Get-WmiObject` and `Get-CimInstance`.
    The `Get-WmiObject` command is older and not as flexible as `Get-CimInstance`
    (if you want the technical details: this is mainly because `Get-WmiObject` uses
    only DCOM to connect to remote computers, while `Get-CimInstance`, by default,
    uses WSMAN and can optionally use DCOM as well). As of right now, Microsoft appears
    to be putting all its effort into `Get-CimInstance`, so that’s the command you’ll
    use. For a detailed breakdown of CIM versus WMI, check out this blog post: [*https://blogs.technet.microsoft.com**/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/*](https://blogs.technet.microsoft.com/heyscriptingguy/2016/02/08/should-i-use-cim-or-wmi-with-windows-powershell/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardest part of querying WMI is figuring out where the information you’re
    looking for is hidden. Normally, you’d do this research on your own (and I encourage
    you to try it here), but for time’s sake, let me offer you the answer sheet to
    this script: all storage resource usage is in `Win32_LogicalDisk`, information
    about the operating system is in `Win32_OperatingSystem`, Windows services are
    all represented in `Win32_Service`, any network adapter information is in `Win32_NetworkAdapterConfiguration`,
    and memory information is in `Win32_PhysicalMemory`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to use `Get-CimInstance` to query these WMI classes for the
    properties you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Disk Free Space
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the available hard drive space, found in `Win32_LogicalDisk`.
    As with `UserProfilesSize`, you’ll start with one server and then generalize in
    your loop. Here, you can see that you lucked out; you don’t even need to use `Select-Object`
    to dig into all the properties—`FreeSpace` is right there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing that `Get-CimInstance` returns an object, you can simply access the
    property that you need to get only the amount of free space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You have the value but, like last time, it’s in bytes (this is a common thing
    in WMI). You can do the same conversion trick as before, except now you want gigabytes
    so you’ll divide by `1GB`. When you update the script by dividing the `FreeSpace`
    property by `1GB`, you get output that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t need to see the free space out to 12 digits, so you can do a little
    rounding by using the `Round()` method on the `[Math]` class, making the output
    look much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now the values are much easier to read. Three down, four to go.
  prefs: []
  type: TYPE_NORMAL
- en: Operating System Information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By now you should see the general pattern: query a single server, find the
    appropriate property, and add the query to your `foreach` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, you’ll simply add lines to your `foreach` loop. The process of
    narrowing down the class, class property, and the property value is the same for
    any value you’ll be querying from WMI. Just follow this same general pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Adding the next value gives you a script that looks like [Listing 14-5](ch14.xhtml#ch14list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5: Your script updated to include a query for `OperatingSystem`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You’ve gotten some useful OS information. Let’s take the next step and figure
    out how to query some information on memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Moving onto the next piece of information to gather (`Memory`), you’ll use
    the `Win32_PhysicalMemory` class. Testing your query on a single server again
    gives the information you’re looking for. In this case, the memory information
    you need is stored in `Capacity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each instance under `Win32_PhysicalMemory` represents a *bank* of RAM. You can
    think of a bank as a physical stick of RAM in a server. It just so happens that
    my SQLSRV1 server has only one bank of memory. However, you will undoubtedly find
    servers with many more.
  prefs: []
  type: TYPE_NORMAL
- en: Since you’re looking for total memory in a server, you’ll have to follow the
    same routine you used to get profile size. You’ll have to add up the value of
    `Capacity` across all the instances. Lucky for us, the `Measure-Object` cmdlet
    works across any number of object types. As long as the property is a number,
    it can add them all up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, since `Capacity` was represented in bytes, you’ll convert it to the
    appropriate label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Listing 14-6](ch14.xhtml#ch14list6), your script grows and
    grows!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-6: Your script with the query for `Memory`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the output so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With that, you have only two fields left to fill!
  prefs: []
  type: TYPE_NORMAL
- en: Network Information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final piece of WMI information is the IP address, which you’ll grab from
    `Win32_NetworkAdapterConfiguration`. I saved the task of finding the IP address
    for last because, unlike the other data entries, finding the IP address of the
    server isn’t as cut and dried as finding a value and then adding it to your `$output`
    hashtable. You’ll have to do some filtering to narrow it down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first see what the output looks like using the same method you’ve used
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see right away that the default output doesn’t show the IP address, not
    that that has stopped you before. But, somewhat trickier, here the command doesn’t
    return a single instance. This server has three network adapters on it. How do
    you select the one that has the IP address you’re looking for?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you have to see all the properties by using `Select-Object`. Using `Get-CimInstance
    -ComputerName SQLSRV1 -ClassName Win32_NetworkAdapterConfiguration | Select-Object
    -Property *`, you can scroll through the (substantial) output. Depending on the
    network adapters installed on the server, you may notice fields that don’t have
    anything for the `IPAddress` property. This is common because network adapters
    do not have an IP address. However, when you do find one with an IP address bound
    to it, it should look similar to the following code, where you can see the `IPAddress`
    property ❶ has (in this instance) an IPv4 address of 192.168.0.40 and a couple
    of IPv6 addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The script needs to be dynamic and support lots of network adapter configurations.
    It’s important that the script is able to handle other types of network adapters
    other than the `Microsoft Hyper-V Network Adapter` you’re working with here. You’ll
    need to find a standard criterion to filter on so that it can apply to all servers.
  prefs: []
  type: TYPE_NORMAL
- en: The `IPEnabled` property is the key. When this property is set to `True`, the
    TCP/IP protocol is bound to this network adapter, which is a prerequisite to having
    an IP address. If you can narrow down the NIC that has the `IPEnabled` property
    set to `True`, you’ll have the adapter you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'When filtering WMI instances, it’s always best to use the `Filter` parameter
    on `Get-CimInstance`. There’s a saying in the PowerShell community: *filter left*.
    Basically, it means that if you can, always filter output as far to the left as
    possible—meaning filter as early as possible so that you’re not sending unnecessary
    objects through the pipeline. Don’t use `Where-Object` unless you have to. The
    performance will be much faster instead if the pipeline isn’t clogged with unneeded
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Filter` parameter on `Get-CimInstance` uses *Windows Query Language (WQL)*,
    which is a small subset of *Structured Query Language (SQL)*. The `Filter` parameter
    accepts the same `WHERE` clause syntax that WQL does. Take this example: if, in
    WQL, you want all the `Win32_NetworkAdapterConfiguration` class instances with
    the `IPEnabled` property set to `True`, you could use `SELECT *` `FROM Win32_NetworkAdapterConfiguration
    WHERE IPEnabled = ''True''`. Since you’re already specifying the class name for
    the `ClassName` parameter argument in `Get-CimInstance`, you need to specify `IPEnabled
    = ''True''` for `Filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This should return only network adapters that are `IPEnabled` (meaning they
    have an IP address).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a single WMI instance, and now that you know the property
    you’re looking for (`IPAddress`), let’s see what it looks like when querying a
    single server. You’ll use the same object.property syntax you’ve been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Ouch! Looks like it has IPv4 and IPv6 references in there. You’ll have to filter
    out more elements. Because WQL can’t filter deeper than the property value, you’ll
    need to parse out the IPv4 address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing some investigation, you can see that all the addresses are enclosed with
    curly brackets separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good indication that this property isn’t stored as one big string
    but rather as an array. To confirm that this is an array, you can try using an
    index to see whether you can get only the IPv4 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You’re in luck! The `IPAddress` property *is* an array. At this point, you have
    your value, and you can add your full command to your script, as shown in [Listing
    14-7](ch14.xhtml#ch14list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-7: Updated code that now handles `IPAddress`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have all the WMI information you need, there’s only one thing left
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last piece of data to gather is a list of the services on the server that
    are stopped. You’ll follow our basic algorithm, testing on a single server first.
    To do that, you’ll use the `Get-Service` command on the server, which will return
    all of the services being used. You’ll then pipe that output to a `Where-Object`
    command that will filter only for services that have a status of `Stopped`. All
    in all, the command will look like this: `Get-Service -ComputerName sqlsrv1 |
    Where-Object { $_.Status -eq ''Stopped'' }`.'
  prefs: []
  type: TYPE_NORMAL
- en: This command is returning whole objects with all their properties. But you’re
    just looking for service names, so you’ll use the same technique you’ve been using—referencing
    the property name—and return a list of only service names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Adding this to your script, you get [Listing 14-8](ch14.xhtml#ch14list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-8: Updating and using your script to print the stopped services*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code to test your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As far as stopped services go, everything looks okay—but where did the other
    properties go? At this point, the console window has no room left. Removing the
    `Format-Table` reference allows you to see all the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Looks good!
  prefs: []
  type: TYPE_NORMAL
- en: Script Cleanup and Optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than declare victory and move on, let’s reflect a little. Writing code
    is an iterative process. It’s entirely possible that you start out with a goal,
    accomplish that goal, and still end up with bad code—there’s more to a good program
    than simply doing what needs to be done. The script does exactly what you want
    it to do now, but you could do it in a better way. How?
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the DRY method: *don’t repeat yourself*. You can see a lot of repetition
    in this script. You have lots of `Get-CimInstance` references where you’re using
    the same parameters over and over again. You’re also making a lot of calls to
    WMI for the same server. These look like good places to make the code more efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the CIM cmdlets have a `CimSession` parameter. This parameter
    allows you to create a single CIM session once and then reuse it. Rather than
    creating a temporary session, using it, and tearing it down again, you can create
    a single session, use it all you want, and then tear it down, as shown in [Listing
    14-9](ch14.xhtml#ch14list9). The concept is similar to the `Invoke-Command` command’s
    `Session` parameter that we covered in [Chapter 8](ch08.xhtml#ch8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-9: Updating your code to create, and reuse, a single session*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re reusing a single CIM session rather than multiple ones. But you’re
    still referencing it a lot in different commands’ parameters. To make this even
    better, you can create a hashtable and assign it a key called `CIMSession` and
    a value of the CIM session you just created. Once you have a common set of parameters
    saved in a hashtable, you can reuse it across all `Get-CimInstance` references.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is known as *splatting*, and you can do it by specifying the
    hashtable you just created while calling each of the `Get-CimInstance` references
    via the `@` symbol followed by the hashtable name, as shown in [Listing 14-10](ch14.xhtml#ch14list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-10: Creating the `CIMSession` parameter to reuse*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’re probably used to passing parameters to commands in the
    `dash<`parameter name`>` `<`parameter value`>` format. This works but it becomes
    inefficient, especially if you’re passing the same parameters to commands over
    and over again. Instead, you can use splatting as you’ve done here, by creating
    a hashtable and then simply passing that single hashtable to each command that
    requires the same parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ve eliminated the `$cimSession` variable altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve taken essential information from all the previous chapters
    and applied it to a situation you might find in the real world. A script that
    queries information is one of the first types of scripts I usually recommend creating.
    It teaches you a lot about PowerShell, and there’s little chance of screwing anything
    up!
  prefs: []
  type: TYPE_NORMAL
- en: You moved iteratively through this chapter, going from a goal to a solution
    to an even better solution. This is a process you’ll follow over and over again
    as you work with PowerShell. Define your goal, start small, get your framework
    laid out (a `foreach` loop, in this case), and start adding code piece by piece,
    overcoming one obstacle at a time until it all comes together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you finish your script, keep in mind that you haven’t really finished
    until you review your code: see how to make it more efficient, use fewer resources,
    and get faster. Experience will make optimizing easier. You’ll build the perspective
    you need until optimizing becomes second nature. When you’re finished optimizing,
    sit back, bask in your success, and get ready to start your next project!'
  prefs: []
  type: TYPE_NORMAL
