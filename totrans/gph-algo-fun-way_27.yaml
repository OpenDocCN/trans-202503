- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">C</samp> <samp class="SANS_Dogma_OT_Bold_B_11">UNION-FIND</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Kruskal’s algorithm, randomized maze generation, and single-linkage clustering
    from [Chapter 10](chapter10.xhtml) all use a data structure called <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    to represent the disjoint sets of nodes corresponding to the different connected
    components in a graph. This data structure allows the algorithms to efficiently
    (1) determine whether two nodes are already in the same connected component and
    (2) merge two different components. For completeness, this appendix describes
    and provides the code for this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by providing a very brief overview of union-find data structures, followed
    by just enough code to implement the algorithms in this book. We encourage interested
    readers to explore additional resources. The “Union-Find” chapter of Daniel Zingaro’s
    *Algorithmic Thinking*, 2nd edition (No Starch Press, 2023), provides an accessible
    introduction to these fascinating data structures as well as additional optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Union-Find Data Structure</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *union-find* data structure (also called a *disjoint sets* data structure)
    is commonly viewed as a list of trees (also called a *forest* of trees). Each
    item is represented as a tree node and each set is encoded as a tree. Items are
    considered to be in the same set if and only if they are in the same tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure C-1](#figC-1) shows an example union-find data structure with 11 items
    organized into three sets: {0, 1, 6, 7, 10}, {3, 5, 9}, {2, 4, 8}. As shown in
    the figure, the trees are not restricted to be binary (at most two children per
    node), nor do they enforce an ordering over the elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The left-most tree has root 0 and nodes 0, 1, 6, 7, and 10\. The middle tree
    has root 5 and nodes 5, 3, and 9\. The right-most tree has root 2 and nodes 2,
    4, and 8.](../images/f0c001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure C-1: Three disjoint
    sets represented as trees</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each set in this data structure is uniquely identified by the index number of
    the root node. The trees in [Figure C-1](#figC-1) have labels 0, 5, and 2 from
    left to right. We can easily retrieve the set label for any item by traversing
    from that item’s node to the root of the tree. For example, we could identify
    the set label for item 9 by progressing from node 9 to node 3 to node 5 and then
    returning 5.
  prefs: []
  type: TYPE_NORMAL
- en: We create the union of sets by combining trees. There are a variety of ways
    to append one tree to another. In this appendix, we’ll use the common optimization
    of appending the root node of the tree with fewer nodes to the root node of a
    larger tree. [Figure C-2](#figC-2) shows an example of combining the sets rooted
    at 0 and 2 into a single set. Since the tree rooted at node 2 has fewer nodes,
    we set the parent pointer of node 2 to node 0, effectively adding the subtree
    as a child.
  prefs: []
  type: TYPE_NORMAL
- en: '![The combined tree has root node 0\. Node 2 has a parent pointer into node
    0.](../images/f0c002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure C-2: Combining two trees</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For illustration purposes, in this section we describe a minimalist <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    data structure that uses an explicit forest-of-trees implementation to make the
    tree-based operations clear. More efficient optimizations are possible, such as
    array-based implementations of the data structure and the use of path compression
    to reduce tree height.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">UnionFind</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure
    partitions elements into different (and disjoint) sets such that each element
    belongs to exactly one set. For Kruskal’s algorithm, these sets represent the
    different connected components within the graph. Nodes within the same component
    are part of the same set.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 10](chapter10.xhtml), this data structure is powerful
    because it facilitates performing two operations very quickly. The first operation
    is to determine whether two points are in the same set, which is necessary for
    determining if two nodes are already connected. The second operation is merging
    two sets, which is necessary for connecting components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This appendix provides the code for the following functions that make up the
    union-find interface:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">are_disjoint(i, j)</samp>Determines
    whether two elements <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> are in different sets
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">union_sets(i, j)</samp>Merges the
    set with element <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and the
    set with element <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> into a
    single set
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">find_set(i)</samp>Returns a unique
    label for the set containing element <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UnionFindNode</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we only ever need to travel up the tree (rather than down), each node
    only needs to store two pieces of information: its own index number and the pointer
    to its parent. Nodes do not need to store pointers to their children. We can define
    a minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFindNode</samp> as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We initially set the parent of a node to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    to indicate that it is a root node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UnionFind Class</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our minimal <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    object tracks three pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **A
    list of <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFindNode</samp> objects
    indexed by their label
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">set_sizes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **A
    list that maps the set’s label to its size
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_disjoint_sets</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **The number of disjoint
    sets
  prefs: []
  type: TYPE_NORMAL
- en: We use a list to store the nodes because we only need to support contiguous
    integer labels for the algorithms in this book. However, we could support more
    general labels, such as strings, by using a dictionary to map each label to its
    corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFindNode</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_disjoint_sets</samp> attribute
    could be computed from the other attributes but is explicitly stored for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these attributes, we define a constructor to set up the initial state
    of the union-find data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes the number of items (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_sets</samp>)
    and constructs both the full list of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp>)
    and the list of sizes for each set (<samp class="SANS_TheSansMonoCd_W5Regular_11">set_sizes</samp>).
    Since the items all start in disjoint sets, the constructor initializes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_sets</samp> sizes to 1 for each item.
    Finally, it sets the count of disjoint sets (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_disjoint_sets</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the label of a set corresponds to walking up the tree and returning
    the label of the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_set()</samp> function
    starts by checking the bounds of the label and raising an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>
    if the label is out of bounds. It then starts at the current node ❶ and uses a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to walk up the
    tree to the parent. It returns the label of the parent node as the identifier
    for the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">are_disjoint()</samp> function
    uses two calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">find_set()</samp>
    to extract the set labels for each item and test whether they are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the set labels are the same, the items must share a root node and thus be
    in the same set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the union of two sets consists of appending the trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">union_sets()</samp> function
    starts by finding the label for each set and checking whether they are already
    equal to each other ❶. If so, there is nothing to be done and the function returns.
    If not, the function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_sizes</samp>
    list to determine which tree has fewer nodes ❷ and appends the root node of the
    smaller tree as a child of the larger tree’s root node ❸. Finally, the function
    updates the remaining data by computing the new size of the larger tree, setting
    the size entry of the smaller tree to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    (since it is no longer a disjoint set), and updating the number of disjoint sets.
  prefs: []
  type: TYPE_NORMAL
