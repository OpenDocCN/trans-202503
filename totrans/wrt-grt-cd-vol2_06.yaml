- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CONSTANTS AND HIGH-LEVEL LANGUAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some programmers may not realize it, but many CPUs do not treat constant and
    variable data identically at the machine code level. Most CPUs provide a special
    *immediate addressing mode* that allows a language translator to embed a constant
    value directly into a machine instruction rather than storing it in a memory location
    and accessing it as a variable. However, the CPU’s ability to represent constant
    data efficiently varies by CPU and, in fact, by the type of the data. By understanding
    how a CPU treats constant data at the machine code level, you can choose appropriate
    ways to represent constants in your HLL source code to produce smaller and faster
    executable programs. To that end, this chapter discusses the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use literal constants properly to improve the efficiency of your programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a literal constant and a manifest constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How compilers process compile-time constant expressions to reduce program size
    and avoid runtime calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a compile-time constant and read-only data kept in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How compilers represent noninteger constants, such as enumerated data types,
    Boolean data types, floating-point constants, and string constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How compilers represent composite data type constants, such as array constants
    and record/struct constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the time you finish this chapter, you should have a clear understanding of
    how various constants can affect the efficiency of the machine code your compiler
    produces.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’ve already read* WGC1, *you may just want to skim through this chapter,
    which for the sake of completeness repeats some of the information from [Chapters
    6](ch06.xhtml#ch06) and [7](ch07.xhtml#ch07) of that volume.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.1 Literal Constants and Program Efficiency**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'High-level programming languages and most modern CPUs allow you to specify
    constant values just about anywhere you can legally read the value of a memory
    variable. Consider the following Visual Basic and HLA statements, which assign
    the constant `1000` to the variable `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The 80x86, like most CPUs, actually encodes the constant representation for
    1,000 directly into the machine instruction. This provides a compact and efficient
    way to work with constants at the machine level. Therefore, statements that use
    literal constants in this manner are often more efficient that those that assign
    constant values to a variable and then reference that variable later in the code.
    Consider the following Visual Basic code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the 80x86 assembly code you would probably write for these last
    two statements. For the first statement, we must use two instructions because
    we can’t add the value of one memory location directly to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can add a constant to a memory location, so the second Visual Basic
    statement translates to a single machine instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, using a literal constant, rather than a variable, is more efficient.
    This is not to suggest, however, that every processor operates more efficiently
    using literal constants, or that every CPU operates more efficiently no matter
    the value of the constant. Some very old CPUs don’t provide the ability to embed
    literal constants within a machine instruction at all; and many RISC processors,
    such as the ARM, do so only for smaller 8-, 12-, or 16-bit constants.^([1](footnotes.xhtml#ch6fn1))
    Even those CPUs that allow you to load any integer constant may not support literal
    floating-point constants—the ubiquitous 80x86 processor being one example. Few
    CPUs provide the ability to encode large data structures (such as an array, record,
    or string) as part of a machine instruction. For example, consider the following
    C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Its compilation to PowerPC assembly by the GCC compiler looks like this (edited
    to remove the nonrelevant code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The PowerPC CPU allows only 16-bit immediate constants in a single instruction.
    In order to load a larger value into a register, the program has to first use
    the `lis` instruction to load the higher-order (HO) 16 bits of a 32-bit register
    and then use the `ori` instruction to merge in the lower-order (LO) 16 bits. The
    exact operation of these instructions isn’t too important. What’s notable is that
    the compiler emits three instructions for large constants, and only two for smaller
    constants. Therefore, using 16-bit constant values on the PowerPC produces shorter
    and faster machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compilation of this C code to ARMv7 assembly by the GCC compiler looks
    like this (edited to remove the nonrelevant code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The ARM CPU allows only 16-bit immediate constants in a single instruction.
    In order to load a larger value into a register, the compiler places the constant
    into a memory location and loads the constant from memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though CISC processors like the 80x86 can usually encode any integer constant
    (up to 32 bits) in a single instruction, this doesn’t mean that the program’s
    efficiency is independent of the sizes of the constants you use in your programs.
    CISC processors often use different encodings for machine instructions that have
    large or small immediate operands, allowing the program to use less memory for
    smaller constants. For example, consider the following two 80x86/HLA machine instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On the 80x86 an assembler can encode the first instruction in 3 bytes: 2 bytes
    for the opcode and addressing mode information, and 1 byte to hold the small immediate
    constant `5`. The second instruction, on the other hand, requires 6 bytes to encode:
    2 bytes for the opcode and addressing mode information, and 4 bytes to hold the
    constant `500_000`. Certainly the second instruction is larger, and in some cases
    it may even run a little slower.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.2 Binding Times**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What exactly is a constant? Obviously, from an HLL perspective, a constant
    is some sort of entity whose value doesn’t change (that is, remains constant).
    However, there is more to the definition. For example, consider the following
    Pascal constant declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the code following this declaration,^([2](footnotes.xhtml#ch6fn2)) you can
    use the name someConstant in place of the value `5`. But what about before this
    declaration? How about outside the scope to which this declaration belongs? Clearly
    the value of someConstant can change upon the compiler processing this declaration.
    So the notion that a constant’s “value doesn’t change” doesn’t exactly apply here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real concern here isn’t *where* the program associates a value with someConstant
    but *when*. *Binding* is the technical name for creating associations between
    attributes (such as the name, value, and scope) of some object. For example, the
    earlier Pascal example binds the value `5` to the name someConstant. *Binding
    time*—when the binding (association) occurs—can happen at several different points:'
  prefs: []
  type: TYPE_NORMAL
- en: '*At language definition time.* This refers to when the language designer(s)
    define the language. The constants `true` and `false` in many languages are good
    examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*During compilation.* The Pascal someConstant declaration in this section is
    a good example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*During the linking phase.* An example of this might be a constant that specifies
    the size of the object code (machine instructions) in a program. The program cannot
    compute this size any earlier than during the link phase, when the linker pulls
    in all the object code modules and combines them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*During program loading (into memory).* A good example of load time binding
    would be associating the address of an object in memory (such as a variable or
    machine instruction) with some pointer constant. On many systems, the operating
    system relocates the code when it loads it into memory, so the program can only
    determine absolute memory addresses after loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*During program execution.* Some bindings can occur only while the program
    is running. For example, when you assign the value of some (computed) arithmetic
    expression to a variable, the binding of the value to the variable occurs during
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dynamic bindings* are those that occur during program execution. *Static bindings*
    are those that occur at any other time. [Chapter 7](ch07.xhtml#ch07) will take
    another look at binding (see “What Is a Variable?” on [page 180](ch07.xhtml#page_180)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.3 Literal Constants vs. Manifest Constants**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *manifest constant* is a constant value associated with—that is, bound to—a
    symbolic name. A language translator can directly substitute the value everywhere
    the name appears within the source code, producing easy-to-read and easily maintained
    programs. The proper use of manifest constants is a good indication of professionally
    written code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring manifest constants is simple in many programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: Pascal programmers use the `const` section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HLA programmers can use the `const` or the `val` declaration sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C/C++ programmers can use the `#define` macro facility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This Pascal code fragment demonstrates an appropriate use of manifest constants
    in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code is much easier to read and maintain than code that uses literal constants.
    By changing a single statement in this program (the `maxIndex` constant declaration)
    and recompiling the source file, you can easily set the number of elements and
    the program will continue to function properly.
  prefs: []
  type: TYPE_NORMAL
- en: Because the compiler substitutes the literal numeric constant in place of the
    symbolic name for the manifest constant, there is no performance penalty for using
    manifest constants. Given that they improve the readability of your programs without
    any loss in efficiency, manifest constants are an important component of great
    code. Use them.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.4 Constant Expressions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many compilers support the use of *constant expressions*, which are expressions
    that can be evaluated during compilation. The component values of a constant expression
    are all known at compile time, so the compiler can evaluate the expression and
    substitute its value during compilation rather than computing it at runtime. As
    with manifest constants, constant expressions enable you to write more easily
    readable and maintainable code, without any runtime efficiency loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These two array declarations expand to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The C preprocessor further expands this to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although the C language definition supports constant expressions, this feature
    is not available in every language, so you’ll need to check the language reference
    manual for your particular compiler. The Pascal language definition, for example,
    says nothing about constant expressions. Some Pascal implementations support them,
    but others do not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern optimizing compilers are capable of computing constant subexpressions
    within arithmetic expressions at compile time (known as *constant folding*; see
    “Common Compiler Optimizations” on [page 63](ch04.xhtml#page_63)), thereby saving
    the expense of computing fixed values at runtime. Consider the following Pascal
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Any decent Pascal implementation will recognize that the subexpression `5*2–3`
    is a constant expression, compute the value for this expression (`7`) during compilation,
    and substitute that value at compile time. In other words, a good Pascal compiler
    generally emits machine code that is equivalent to the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If your particular compiler fully supports constant expressions, you can use
    this feature to write better source code. It may seem paradoxical, but writing
    out a full expression at some point in your program can sometimes make that particular
    piece of code easier to read and understand; someone reading your code can see
    exactly how you calculated a value, rather than having to figure out how you arrived
    at some “magic” number. For example, in the context of an invoicing or timesheet
    routine, the expression `5*2–3` might describe the computation “two persons working
    for five hours, minus three person-hours provided for the job” better than the
    literal constant `7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample C code, and the PowerPC output produced by the GCC compiler,
    demonstrates constant expression optimization in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the GCC output (PowerPC assembly language):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, GCC has replaced the constant expression `2*5+1` with the constant
    `11`.
  prefs: []
  type: TYPE_NORMAL
- en: Making your code more readable is definitely a good thing to do and a major
    part of writing great code. Keep in mind, however, that some compilers may not
    support the use of constant expressions, instead emitting code to compute the
    constant value at runtime. Obviously, this will affect the size and execution
    speed of your resulting program. Knowing what your compiler can do will help you
    decide whether to use constant expressions or precompute expressions to increase
    efficiency at the cost of readability.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5 Manifest Constants vs. Read-Only Memory Objects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C/C++ programmers may have noticed that the previous section did not discuss
    the use of the C/C++ `const` declaration. This is because symbolic names (hereafter
    *symbols*) you declare in a C/C++ `const` statement aren’t necessarily manifest
    constants. That is, C/C++ does not always substitute the value for a symbol wherever
    it appears in a source file. Instead, a C/C++ compiler might store that `const`
    value in memory and then reference the `const` object as it would a static (read-only)
    variable. The only difference, then, between that `const` object and a static
    variable is that the C/C++ compiler doesn’t allow you to assign a value to `const`
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ sometimes treats constants you declare in `const` statements as static
    variables for a very good reason—it allows you to create within a function local
    constants whose value can change each time that function executes (although while
    the function is executing, the value remains fixed). This is why you can’t always
    use such a “constant” within a `const` in C/C++ and expect the C/C++ compiler
    to precompute its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most C++ compilers will accept this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'They will not, however, accept this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`arraySize` and `arraySizes` are both constants. Yet the C++ compiler won’t
    allow you to use the `arraySizes` constant, or anything based on it, as an array
    bound. This is because `arraySizes[0]` is actually a runtime memory location and,
    therefore, `arraySize` must also be a runtime memory location. In theory, you’d
    think the compiler would be smart enough to figure out that `arraySize` is computable
    at compile time and just substitute that value (`128`). The C++ language, however,
    doesn’t allow this.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.6 Swift let Statements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Swift programming language, you can create constants using the `let`
    statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: However, the value is bound to the constant’s name at runtime (that is, this
    is a dynamic binding). The expression on the right-hand side of the assignment
    operator (`=`) doesn’t have to be a constant expression; it can be an arbitrary
    expression involving variables and other nonconstant components. Every time the
    program executes this statement (such as in a loop), the program could bind a
    different value to someConstant.
  prefs: []
  type: TYPE_NORMAL
- en: The Swift `let` statement doesn’t truly define constants in the traditional
    sense; rather, it lets you create “write-once” variables. In other words, within
    the scope of the symbol you define using the `let` statement, you can initialize
    the name with a value only once. Note that if you leave and re-enter the name’s
    scope, the value is destroyed (upon exiting the scope) and you can bind a new
    (possibly different) value to the name upon re-entering the scope. Unlike, say,
    the `const int` declaration in C++, `let` statements do not allow you to allocate
    storage for the object in read-only memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.7 Enumerated Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well-written programs often use a set of names to represent real-world quantities
    that don’t have an explicit numeric representation. An example of such a set of
    names might be various display technologies, like `crt`, `lcd`, `led`, and `plasma`.
    Even though the real world doesn’t associate numeric values with these concepts,
    you must encode the values numerically if you’re going to efficiently represent
    them in a computer system. The internal representation for each symbol is generally
    arbitrary, as long as the value we assign is unique. Many computer languages provide
    an *enumerated data type* that automatically associates a unique value with each
    name in a list. By using enumerated data types in your programs, you can assign
    meaningful names to your data rather than using “magic” numbers such as 0, 1,
    2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in early versions of the C language, you would create a sequence
    of identifiers, each with a unique value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By assigning values that are consecutive, you ensure that each is unique. Another
    advantage to this approach is that it orders the values. That is, `crt` < `lcd`
    < `led` < `plasma`. Unfortunately, creating manifest constants this way is laborious
    and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, in most languages enumerated constants can solve this problem.
    To “enumerate” means to number, and this is exactly what the compiler does—it
    numbers each constant, thereby handling the bookkeeping details of assigning values
    to enumerated constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most modern programming languages provide support for declaring enumerated
    types and constants. Here are some examples from C/C++, Pascal, Swift, and HLA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These four examples internally associate 0 with `crt`, 1 with `lcd`, 2 with
    `led`, 3 with `plasma`, and 4 with `oled`. Again, the exact internal representation
    is irrelevant (as long as each value is unique) because the value’s only purpose
    is to differentiate the enumerated objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most languages assign *monotonically increasing* values (that is, each successive
    value is greater than all previous values) to symbols in an enumerated list. Therefore,
    these examples have the following relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t let this give you the impression that all enumerated constants appearing
    in a single program have a unique internal representation, though. Most compilers
    assign a value of `0` to the first item in an enumeration list you create, a value
    of `1` to the second, and so on. For example, consider the following Pascal type
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Most Pascal compilers would use the value `0` as the internal representation
    for both `red` and `bolt`; `1` for `green` and `nut`; and so on. In languages
    (like Pascal and Swift) that enforce type checking, you generally can’t use symbols
    of type `colors` and `fasteners` in the same expression. Therefore, the fact that
    these symbols share the same internal representation isn’t an issue because the
    compiler’s type-checking facilities preclude any possible confusion. Some languages,
    like C/C++ and assembly, do not provide strong type checking, however, and so
    this kind of confusion can occur. In those languages, it is the programmer’s responsibility
    to avoid mixing different types of enumeration constants.
  prefs: []
  type: TYPE_NORMAL
- en: Most compilers allocate the smallest unit of memory the CPU can efficiently
    access in order to represent an enumerated type. Because most enumerated type
    declarations define fewer than 256 symbols, compilers on machines that can efficiently
    access byte data will usually allocate a byte for any variable with an enumerated
    data type. Compilers on many RISC machines can allocate a 32-bit word (or more)
    simply because it’s faster to access such blocks of data. The exact representation
    is language and compiler/implementation dependent, so check your compiler’s reference
    manual for the details.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.8 Boolean Constants**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many high-level programming languages provide *Boolean*, or *logical*, constants
    to represent the values `true` and `false`. Because there are only two possible
    Boolean values, their representation requires only a single bit. However, because
    most CPUs do not allow you to allocate a single bit of storage, most programming
    languages use a whole byte or even a larger object to represent a Boolean value.
    What happens to any leftover bits in a Boolean object? Unfortunately, the answer
    varies by language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many languages treat the Boolean data type as an enumerated type. For example,
    in Pascal, the Boolean type is defined this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration associates the internal value `0` with `false` and `1` with
    `true`. This association has a couple of desirable attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the Boolean functions and operators behave as expected—for example,
    (`true` and `true`) = `true`, (`true` and `false`) = `false`, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you compare the two values, `false` is less than `true`—an intuitive result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, associating `0` with `false` and `1` with `true` isn’t always
    the best solution. Here are some reasons why:'
  prefs: []
  type: TYPE_NORMAL
- en: Certain Boolean operations, applied to a bit string, do not produce expected
    results. For example, you might expect (not `false`) to be equal to `true`. However,
    if you store a Boolean variable in an 8-bit object, then (not `false`) is equal
    to `$FF`, which is not equal to `true` (`1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many CPUs provide instructions that easily test for `0` or nonzero after an
    operation; few CPUs provide an implicit test for `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many languages, such as C, C++, C#, and Java, treat `0` as `false` and anything
    else as `true`. This has a couple of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: CPUs that provide easy checks for `0` and nonzero can easily test a Boolean
    result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `0`/nonzero representation is valid regardless of the size of the object
    holding a Boolean variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, this scheme also has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Many bitwise logical operations produce incorrect results when applied to `0`
    and nonzero Boolean values. For example `$A5` (`true`/nonzero) AND `$5A` (`true`/nonzero)
    is equal to `0` (`false`). Logically ANDing `true` and `true` should not produce
    `false`. Similarly, (NOT `$A5`) produces `$5A`. Generally, you’d expect (NOT `true`)
    to produce `false` rather than `true` (`$5A`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a bit string is treated as a two’s-complement signed-integer value, it’s
    possible for certain values of `true` to be less than zero (for example, the 8-bit
    value `$FF` is equivalent to `-1`). So, in some cases, the intuitive result that
    `false` is less than `true` may not be correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless you are working in assembly language (where you get to define the values
    for `true` and `false`), you’ll have to live with whatever scheme your HLL uses
    to represent Boolean values, as explained in its language reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing how your language represents `true` and `false` can help you write
    high-level source code that produces better machine code. For example, suppose
    you are writing C/C++ code. In these languages, `false` is `0` and `true` is anything
    else. Consider the following statement in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The machine code produced for this assignment statement by many compilers is
    absolutely horrid. It often looks like the following (Visual C++ output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose that you always ensure that you use the values `0` for `false`
    and `1` for `true` (with no possibility of any other value). Under these conditions,
    you could write the previous statement this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code that Visual C++ generates for the preceding statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this code is significantly better. Provided that you always
    use `1` for `true` and `0` for `false`, you can get away with using the bitwise
    AND (`&`) and OR (`|`) operators in place of the logical operators.^([3](footnotes.xhtml#ch6fn3))
    As noted earlier, you can’t get consistent results using the bitwise NOT operator;
    you can, however, do the following to produce correct results for a logical NOT
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This short sequence inverts all the bits in `j` and then clears all bits except
    bit 0.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that you should be intimately aware of how your particular
    compiler represents Boolean constants. If you’re given a choice (such as any nonzero
    value), then you can pick appropriate values for `true` and `false` to help your
    compiler emit better code.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.9 Floating-Point Constants**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Floating-point constants are special cases on most computer architectures.
    Because floating-point representations can consume a large number of bits, few
    CPUs provide an immediate addressing mode to load an arbitrary constant into a
    floating-point register. This is true even for small (32-bit) floating-point constants.
    It is even true on many CISC processors such as the 80x86\. Therefore, compilers
    often have to place floating-point constants in memory and then have the program
    read them from memory, just as though they were variables. Consider, for example,
    the following C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the PowerPC code that GCC generates for this program with the
    `-O2` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the PowerPC processor is a RISC CPU, the code that GCC generates for
    this simple sequence is rather convoluted. For comparison with a CISC equivalent,
    consider the following HLA code for the 80x86; it is a line-by-line translation
    of the C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code is much easier to follow than the PowerPC code (this is one advantage
    of CISC code over RISC code). Note that like the PowerPC, the 80x86 does not support
    an immediate addressing mode for most floating-point operands. Therefore, as on
    the PowerPC, you have to place a copy of the constant `1.0` in some memory location
    and access that memory location whenever you want to work with the value `1.0`.^([4](footnotes.xhtml#ch6fn4))
  prefs: []
  type: TYPE_NORMAL
- en: Because most modern CPUs do not support an immediate addressing mode for all
    floating-point constants, using such constants in your programs is equivalent
    to accessing variables initialized with those constants. Don’t forget that accessing
    memory can be very slow if the locations you’re referencing are not in the data
    cache. Accordingly, using floating-point constants can be very slow compared with
    accessing integer or other constant values that fit within a register.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some CPUs do allow you to encode certain floating-point immediate
    constants as part of the instruction’s opcode. The 80x86, for example, has a special
    “load zero” instruction that loads `0.0` onto the floating-point stack. The ARM
    processor also provides an instruction that allows you to load certain floating-point
    constants into a CPU floating-point register (see “The `vmov` Instructions” in
    Appendix C online).
  prefs: []
  type: TYPE_NORMAL
- en: 'On 32-bit processors, a CPU can often do simple 32-bit floating-point operations
    using integer registers and the immediate addressing mode. For example, you can
    easily assign a 32-bit single-precision floating-point value to a variable by
    loading a 32-bit integer register with the bit pattern for that number and then
    storing the integer register into the floating-point variable. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the PowerPC code that GCC generates for this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The 80x86, being a CISC processor, makes this task trivial in assembly language.
    Here’s the HLA code that does the same job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Simple assignments of single-precision floating-point constants to floating-point
    variables can often use a CPU’s immediate addressing mode, sparing the program
    the expense of accessing memory (whose data might not be in the cache). Unfortunately,
    compilers don’t always take advantage of this trick for assigning a floating-point
    constant to a double-precision variable. GCC on the PowerPC or ARM, for example,
    reverts to keeping a copy of the constant in memory and copying that memory location’s
    value when assigning the constant to a floating-point variable.
  prefs: []
  type: TYPE_NORMAL
- en: Most optimizing compilers are smart enough to maintain a table of constants
    they’ve created in memory. Therefore, if you reference the constant `2.0` (or
    any other floating-point constant) multiple times in your source file, the compiler
    will allocate only one memory object for that constant. Keep in mind, however,
    that this optimization works only within the same source file. If you reference
    the same constant value but in different source files, the compiler will probably
    create multiple copies of that constant.
  prefs: []
  type: TYPE_NORMAL
- en: It’s certainly true that having multiple copies of the data wastes storage,
    but given the amount of memory in most modern systems, that’s a minor concern.
    A bigger problem is that the program usually accesses these constants in a random
    fashion, so they’re rarely sitting in cache and, in fact, they often evict some
    other more frequently used data from cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution to this problem is to manage the floating-point “constants” yourself.
    Because these constants are effectively variables as far as the program is concerned,
    you can take charge of this process and place the floating-point constants you’ll
    need in initialized static variables. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, of course you gain absolutely nothing by treating the floating-point
    constants as static variables. However, in more complex situations where you have
    several floating-point constants, you can analyze your program to determine which
    constants you access often and place the variables for those constants at adjacent
    memory locations. Because of the way most CPUs handle spatial locality of reference
    (see *WGC1*), when you access one of these constant objects, the cache line will
    be filled with the values of the adjacent objects as well. Therefore, when you
    access those other objects within a short period of time, it’s likely that their
    values will be in the cache. Another advantage to managing these constants yourself
    is that you can create a global set of constants that you can reference from different
    compilation units (source files), so the program accesses only a single memory
    object for a given constant rather the multiple memory objects (one for each compilation
    unit). Compilers generally aren’t smart enough to make decisions like this concerning
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.10 String Constants**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like floating-point constants, string constants cannot be processed efficiently
    by most compilers (even if they are literal or manifest constants). Understanding
    when you should use manifest constants and when you should replace them with memory
    references can help you guide the compiler to produce better machine code. For
    example, most CPUs are not capable of encoding a string constant as part of an
    instruction. Using a manifest string constant may actually make your program less
    efficient. Consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler (actually, the C preprocessor) expands the macro `strConst` to
    the string literal `"A string constant"` everywhere the identifier `strConst`
    appears in the source file, so this code is actually equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that the same string constant appears at different
    places throughout the program. In C/C++, the compiler places the string constant
    in memory and substitutes a pointer to the string. A nonoptimizing compiler might
    wind up making three separate copies of the string in memory, which wastes space
    because the data is exactly the same in all three cases. (Remember that we’re
    talking about *constant* strings here.)
  prefs: []
  type: TYPE_NORMAL
- en: Compiler writers discovered this problem a few decades ago and modified their
    compilers to keep track of the strings in a given source file. If a program used
    the same string literal two or more times, the compiler wouldn’t allocate storage
    for a second copy of the string. Instead, it would simply use the address of the
    earlier string. This optimization (constant folding) could reduce the size of
    the code if the same string appeared throughout a source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, constant folding doesn’t always work properly. One problem is
    that many older C programs assign a string literal constant to a character pointer
    variable and then proceed to change the characters in that literal string. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Compilers that reuse the same string constant fail if the user stores data
    into the string object, as this code demonstrates. Although this is bad programming
    practice, it occurred frequently enough in older C programs that compiler vendors
    couldn’t use the same storage for multiple copies of the same string literal.
    Even if the compiler vendor were to place the string literal constant into write-protected
    memory to prevent this problem, there are other semantic issues that this optimization
    raises. Consider the following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Will `s1EQs2` contain `true` (`1`) or `false` (`0`) after executing this instruction
    sequence? In programs written before C compilers had good optimizers available,
    this sequence of statements would leave `false` in `s1EQs2`. This was because
    the compiler created two different copies of the same string data and placed those
    strings at different addresses in memory (so the addresses the program assigns
    to `sptr1` and `sptr2` would be different). In a later compiler that kept only
    a single copy of the string data in memory, this code sequence would leave `true`
    sitting in `s1EQs2` because both `sptr1` and `sptr2` would be pointing at the
    same memory address. This difference exists regardless of whether or not the string
    data appears in write-protected memory.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this dilemma, many compiler vendors provide a compiler option to enable
    programmers to determine whether the compiler should emit a single copy of each
    string or one copy for each occurrence of the string. If you don’t write data
    into string literal constants or compare their addresses, you can select this
    option to reduce the size of your programs. If you have old code that requires
    separate copies of the string data (hopefully, you won’t write new code that requires
    this), you can enable this option.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many programmers are completely unaware of this option, and the
    default condition on some compilers is generally to make multiple copies of the
    string data. If you’re using C/C++ or some other language that manipulates strings
    via pointers to the character data, investigate whether the compiler provides
    an option to merge identical strings and, if so, activate that feature in your
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your C/C++ compiler does not offer this string-merging optimization, you
    can implement it manually. To do so, just create a `char` array variable in your
    program and initialize it with the address of the string. Then use the name of
    that array variable exactly as you would a manifest constant throughout your program.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code will maintain only a single copy of the string literal constant in
    memory, even if the compiler doesn’t directly support the optimization. Actually,
    even if your compiler does directly support this optimization, there are several
    good reasons why you should use this trick rather than relying on your compiler
    to do the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the future you might have to port your code to a different compiler that
    doesn’t support this optimization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By handling the optimization manually, you don’t have to worry about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using a pointer variable rather than a string literal constant, you have
    the option of easily changing the string whose address this pointer contains under
    program control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the future you might want to modify the program to switch (natural) languages
    under program control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily share the string between multiple files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This string optimization discussion assumes that your programming language manipulates
    strings by reference (that is, by using a pointer to the actual string data).
    Although this is certainly true for C/C++ programs, it is not true of all languages.
    Pascal implementations that support strings (such as Free Pascal) typically manipulate
    them by value rather than by reference. Any time you assign a string value to
    a string variable, the compiler makes a copy of the string data and places that
    copy in the storage reserved for the string variable. This copying process can
    be expensive and is unnecessary if your program never changes the data in the
    string variable. Worse still, if the (Pascal) program assigns a string literal
    to a string variable, the program will have two copies of the string floating
    around (the string literal constant in memory and the copy that the program made
    for the string variable). If the program never again changes the string (which
    is not at all uncommon), it will waste memory by maintaining two copies of the
    string when one would suffice. These reasons (space and speed) are probably why
    Borland went to a much more sophisticated string format when they created Delphi
    4.0, abandoning the string format in earlier versions of Delphi.^([5](footnotes.xhtml#ch6fn5))
  prefs: []
  type: TYPE_NORMAL
- en: Swift also treats strings as value objects. This means that, in the worst case,
    it will make a copy of a string literal whenever you assign that string literal
    to a string variable. However, Swift implements an optimization known as *copy-on-write*.
    Whenever you assign one string object to another, Swift just copies a pointer.
    Therefore, if multiple strings have been assigned the same value, Swift will use
    the same string data in memory for all the copies. When you modify some portion
    of the string, Swift will make a copy of the string prior to the modification
    (hence the name “copy-on-write”) so that other string objects referencing the
    original string data are not affected by the change.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.11 Composite Data Type Constants**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many languages support other composite constant types (such as arrays, structures/records,
    and sets) in addition to strings. Usually, the languages use these constants to
    statically initialize variables prior to the program’s execution. For example,
    consider the following C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that `arrayOfInts` is not a constant. Rather, it is the initializer that
    constitutes the array constant—that is, `{1,2,3,4,5,6,7,8}`. In the executable
    file, most C compilers simply overlay the eight integers at the address associated
    with `arrayOfInts` with these eight numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s what GCC emits for this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There is no extra space consumed to hold the constant data, assuming that `arrayOfInts`
    is a static object in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules change, however, if the variable you’re initializing is not a statically
    allocated object. Consider the following short C sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `arrayOfInts` is an *automatic* variable, meaning that the
    program allocates storage on the stack for the variable each time the program
    calls function `f()`. For this reason, the compiler cannot simply initialize the
    array with the constant data when the program loads into memory. The `arrayOfInts`
    object could actually lie at a different address on each activation of the function.
    To obey the semantics of the C programming language, the compiler will have to
    make a copy of the array constant and then physically copy that constant data
    into the `arrayOfInts` variable whenever the program calls the function. Using
    an array constant this way consumes extra space (to hold a copy of the array constant)
    and extra time (to copy the data). Sometimes the semantics of your algorithm requires
    a fresh copy of the data upon each new activation of the function `f()`. However,
    you need to recognize when this is necessary (and when the extra space and time
    are warranted) rather than blowing memory and CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your program doesn’t modify the array’s data, you can use a static object
    that the compiler can initialize once when it loads the program into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The C/C++ languages also support struct constants. The same space and speed
    considerations we’ve seen for arrays when initializing automatic variables also
    apply to struct constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Embarcadero’s Delphi programming language also supports structured constants,
    though the term “constant” is a bit misleading here. Embarcadero calls them *typed
    constants*, and you declare them in the Delphi `const` section like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Although the declaration appears in a Delphi `const` section, Delphi actually
    treats it as a variable declaration. It’s an unfortunate design choice, but for
    a programmer who wants to create structured constants, this mechanism works fine.
    As with the C/C++ examples in this section, it’s important to remember that the
    constant in this example is actually the `(1,2,3,4,5,6,7,8)` object, not the `ary`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Delphi (along with most modern Pascals, such as Free Pascal) supports several
    other composite constant types as well. Set constants are good examples. Whenever
    you create a set of objects, the Pascal compiler generally initializes some memory
    location with a powerset (bitmap) representation of the set’s data. Wherever you
    refer to that set constant in your program, the Pascal compiler generates a memory
    reference to the set’s constant data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift also supports composite data type constants for arrays, tuples, dictionaries,
    structs/classes, and other data types. For example, the following `let` statement
    creates an array constant with eight elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**6.12 Constants Don’t Change**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In theory, values bound to a constant don’t change (Swift’s `let` statement
    being the obvious exception). In modern systems, compilers that place constants
    in memory often put them in write-protected memory regions to force an exception
    if an inadvertent write occurs. Of course, few programs can be written using only
    read-only (or write-once) objects. Most programs require the ability to change
    the values of objects (*variables*) they manipulate. That is the subject of the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.13 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  prefs: []
  type: TYPE_NORMAL
- en: '———. *Write Great Code, Volume 1: Understanding the Machine*. 2nd ed. San Francisco:
    No Starch Press, 2020.'
  prefs: []
  type: TYPE_NORMAL
