- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Exploiting Zero-Configuration Networking
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 利用零配置网络
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: '*Zero-configuration networking* is a set of technologies that automate the
    processes of assigning network addresses, distributing and resolving hostnames,
    and discovering network services without the need for manual configuration or
    servers. These technologies are meant to operate in the local network and usually
    assume that the participants in an environment have agreed to participate in the
    service, a fact that allows attackers on the network to easily exploit them.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*零配置网络* 是一组自动化分配网络地址、分发和解析主机名、发现网络服务的技术，无需手动配置或服务器。这些技术旨在局域网中运行，通常假设环境中的参与者已同意参与该服务，这一事实使得网络上的攻击者可以轻松利用这些技术。'
- en: IoT systems regularly use zero-configuration protocols to give the devices access
    to the network without requiring the user to intervene. In this chapter, we explore
    common vulnerabilities found in three sets of zero-configuration protocols—Universal
    Plug and Play (UPnP), multicast Domain Name System (mDNS)/Domain Name System Service
    Discovery (DNS-SD), and Web Services Dynamic Discovery (WS-Discovery)—and discuss
    how to conduct attacks against IoT systems that rely on them. We’ll bypass a firewall,
    gain access to documents by pretending to be a network printer, fake traffic to
    resemble an IP camera, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: IoT 系统常常使用零配置协议，使设备能够接入网络，而无需用户干预。在本章中，我们探讨了在三组零配置协议中常见的漏洞——通用即插即用（UPnP）、组播域名系统（mDNS）/域名系统服务发现（DNS-SD）和
    Web 服务动态发现（WS-Discovery）——并讨论如何对依赖这些协议的 IoT 系统进行攻击。我们将绕过防火墙，伪装成网络打印机访问文档，伪造流量模拟
    IP 摄像头等。
- en: Exploiting UPnP
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 UPnP
- en: The UPnP set of networking protocols automates the process of adding and configuring
    devices and systems on the network. A device that supports UPnP can dynamically
    join a network, advertise its name and capabilities, and discover other devices
    and their capabilities. People use UPnP applications to easily identify network
    printers, automate port mappings on home routers, and manage video streaming services,
    for example.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: UPnP 网络协议集自动化了在网络中添加和配置设备及系统的过程。支持 UPnP 的设备可以动态加入网络，广播其名称和功能，并发现其他设备及其功能。例如，人们使用
    UPnP 应用程序来轻松识别网络打印机、自动化家庭路由器上的端口映射，以及管理视频流服务等。
- en: But this automation comes at a price, as you’ll learn in this section. We’ll
    first provide an overview of UPnP and then set up a test UPnP server and exploit
    it to open holes in a firewall. We’ll also explain how other attacks against UPnP
    work and how to combine insecure UPnP implementations with other vulnerabilities
    to perform high-impact attacks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种自动化是有代价的，正如你在本节中将要了解的那样。我们将首先概述 UPnP，然后设置一个测试的 UPnP 服务器，并利用它打开防火墙中的漏洞。我们还将解释针对
    UPnP 的其他攻击方式，以及如何结合不安全的 UPnP 实现与其他漏洞进行高影响攻击。
- en: The UPnP Stack
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UPnP 堆栈
- en: 'The UPnP stack consists of six layers: addressing, discovery, description,
    control, eventing, and presentation.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: UPnP 堆栈由六个层次组成：寻址、发现、描述、控制、事件和展示。
- en: In the *addressing* layer, UPnP-enabled systems try to get an IP address through
    DHCP. If that isn’t possible, they’ll self-assign an address from the 169.254.0.0/16
    range (RFC 3927), a process known as *AutoIP*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *寻址* 层，支持 UPnP 的系统会尝试通过 DHCP 获取一个 IP 地址。如果无法获得，它们会从 169.254.0.0/16 范围内自分配一个地址（RFC
    3927），这个过程称为 *AutoIP*。
- en: 'Next is the *discovery* layer, in which the system searches for other devices
    on the network using the Simple Service Discovery Protocol (SSDP). The two ways
    to discover devices are actively and passively. When using the active method,
    UPnP-capable devices send a discovery message (called an *M-SEARCH request*) to
    the multicast address 239.255.255.250 on UDP port 1900\. We call this request
    HTTPU (HTTP over UDP) because it contains a header similar to the HTTP header.
    The M-SEARCH request looks like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 *发现* 层，在该层，系统使用简单服务发现协议（SSDP）搜索网络中的其他设备。发现设备的方式有主动和被动两种。当使用主动方式时，支持 UPnP
    的设备会向 UDP 端口 1900 上的多播地址 239.255.255.250 发送一个发现消息（称为 *M-SEARCH 请求*）。我们称这个请求为 HTTPU（即
    HTTP over UDP），因为它包含一个类似于 HTTP 头部的头信息。M-SEARCH 请求如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: UPnP systems that listen for this request are expected to reply with a UDP unicast
    message that announces the HTTP location of the *description* XML file, which
    lists the device’s supported services. (In Chapter 4, we demonstrated connecting
    to the custom network service of an IP webcam, which returned information similar
    to what would typically be in this kind of description XML file, suggesting the
    device might be UPnP capable.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 监听此请求的UPnP系统应回复一个UDP单播消息，宣布*描述*XML文件的HTTP位置，该文件列出了设备支持的服务。（在第4章中，我们演示了如何连接到IP摄像头的自定义网络服务，该服务返回的信息类似于此类描述XML文件中的内容，暗示该设备可能支持UPnP。）
- en: 'When using the passive method for discovering devices, UPnP-capable devices
    periodically announce their services on the network by sending a NOTIFY message
    to the multicast address 239.255.255.250 on UDP port 1900\. This message, which
    follows, looks like the one sent as a response to the active discovery:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用被动方法发现设备时，UPnP支持的设备通过将NOTIFY消息发送到UDP端口1900上的多播地址239.255.255.250，定期在网络上广播它们的服务。以下是该消息，类似于在主动发现时发送的响应：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any interested participant on the network can listen to these discovery messages
    and send a description query message. In the *description* layer, UPnP participants
    learn more about the device, its capabilities, and how to interact with it. The
    description of every UPnP profile is referenced in either the LOCATION field value
    of the response message received during active discovery or the NOTIFY message
    received during passive discovery. The LOCATION field contains a URL that points
    to a *description XML file* consisting of the URLs used during the control and
    eventing phases (described next).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上任何感兴趣的参与者都可以监听这些发现消息并发送描述查询消息。在*描述*层中，UPnP参与者可以了解更多关于设备的信息，包括其功能以及如何与之交互。每个UPnP配置文件的描述都可以在活动发现过程中接收到的响应消息的LOCATION字段值中找到，或者在被动发现过程中接收到的NOTIFY消息中找到。LOCATION字段包含一个URL，指向一个*描述XML文件*，该文件包含在控制和事件阶段中使用的URL（将在下文描述）。
- en: 'The *control* layer is probably the most important one; it allows clients to
    send commands to the UPnP device using the URLs from the description file. They
    can do this using the *Simple Object Access Protocol* (*SOAP*)*,* a messaging
    protocol that uses XML over HTTP. Devices send SOAP requests to the `controlURL`
    endpoint, described in the `<service>` tag inside the description file. A `<service>`
    tag looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制*层可能是最重要的一层；它允许客户端使用描述文件中的URL向UPnP设备发送命令。客户端可以通过*简单对象访问协议*（*SOAP*）来实现这一点，SOAP是一种使用XML通过HTTP传输的消息协议。设备通过`controlURL`端点发送SOAP请求，该端点在描述文件中的`<service>`标签内进行了描述。`<service>`标签的格式如下：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see the `controlURL`1. The *eventing* layer notifies clients that have
    subscribed to a specific `eventURL` 2, also described in the `service` tag inside
    the description XML file. These event URLs are associated with specific state
    variables (also included in the description XML file) that model the state of
    the service at runtime. We won’t use state variables in this section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`controlURL`。*事件*层通知已订阅特定`eventURL` 2的客户端，该URL也在描述XML文件中的`service`标签内描述。这些事件URL与特定的状态变量相关联（也包含在描述XML文件中），用于建模服务在运行时的状态。在本节中，我们不会使用状态变量。
- en: The *presentation* layer exposes an HTML-based user interface for controlling
    the device and viewing its status—for example, the web interface of a UPnP-capable
    camera or router.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*展示*层提供了一个基于HTML的用户界面，用于控制设备并查看其状态，例如，UPnP支持的摄像头或路由器的Web界面。'
- en: Common UPnP Vulnerabilities
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的UPnP漏洞
- en: UPnP has a long history of buggy implementations and flaws. First of all, because
    UPnP was designed to be used inside LANs, there is no authentication on the protocol,
    which means that anyone on the network can abuse it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: UPnP有着长时间的错误实现和缺陷。首先，由于UPnP设计用于在局域网内部使用，因此该协议没有认证机制，这意味着网络上的任何人都可以滥用它。
- en: UPnP stacks are known for poorly validating input, which leads to flaws such
    as the unvalidated `NewInternalClient` bug. This bug allows you to use any kind
    of IP address, whether internal or external, for the `NewInternalClient` field
    in the device’s port-forwarding rules. This means that an attacker could turn
    a vulnerable router into a proxy. For example, imagine you add a port-forwarding
    rule that sets `NewInternalClient` to the IP address of *sock-raw.org*, `NewInternalPort`
    to TCP port 80, and `NewExternalPort` to 6666\. Then, by probing the router’s
    external IP on port 6666, you’d make the router probe the web server on *sock-raw.org*
    without your IP address showing in the target’s logs. We’ll walk through a variation
    of this attack in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 已知 UPnP 堆栈对输入验证不严，这导致了诸如未经验证的 `NewInternalClient` 错误等漏洞。这个漏洞允许你使用任何类型的 IP 地址，无论是内部的还是外部的，作为设备端口转发规则中的
    `NewInternalClient` 字段。这意味着攻击者可以将一个易受攻击的路由器变成代理。例如，假设你添加了一个端口转发规则，将 `NewInternalClient`
    设置为 *sock-raw.org* 的 IP 地址，将 `NewInternalPort` 设置为 TCP 端口 80，将 `NewExternalPort`
    设置为 6666。然后，通过探测路由器的外部 IP 地址的 6666 端口，你就可以让路由器探测 *sock-raw.org* 上的 Web 服务器，而你的
    IP 地址不会出现在目标日志中。我们将在下一节中介绍这种攻击的变种。
- en: On the same note, UPnP stacks sometimes contain memory corruption bugs, which
    can lead to remote denial of service attacks in the best-case scenario and remote
    code execution in the worst-case one. For instance, attackers have discovered
    devices that use SQL queries to update their in-memory rules while externally
    accepting new rules through UPnP, making them susceptible to SQL injection attacks.
    Also, because UPnP relies on XML, weakly configured XML-parsing engines can fall
    victim to *External Entity* (*XXE*) *attacks*. In these attacks, the engine processes
    potentially malicious input containing references to an external entity, disclosing
    sensitive information or causing other impacts to the system. To make matters
    worse, the specification discourages, but doesn’t outright ban, UPnP on internet-facing
    WAN interfaces. Even if some vendors follow the recommendation, bugs in the implementation
    often allow WAN requests to go through.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，UPnP 堆栈有时包含内存损坏漏洞，这在最好的情况下可能导致远程拒绝服务攻击，而在最坏的情况下可能导致远程代码执行。例如，攻击者发现一些设备使用
    SQL 查询来更新它们的内存规则，同时通过 UPnP 外部接受新规则，使它们容易受到 SQL 注入攻击。此外，由于 UPnP 依赖于 XML，配置不当的 XML
    解析引擎可能会成为 *外部实体*（*XXE*）*攻击*的受害者。在这些攻击中，解析引擎处理包含对外部实体的引用的潜在恶意输入，从而泄露敏感信息或对系统造成其他影响。更糟糕的是，规范不鼓励但并未完全禁止在面向互联网的
    WAN 接口上使用 UPnP。即使一些厂商遵循了这一建议，实施中的漏洞往往仍允许 WAN 请求通过。
- en: Last but not least, devices often don’t log UPnP requests, which means the user
    has no way of knowing if an attacker is actively abusing it. Even if the device
    supports UPnP logging, the log is typically stored client side on the device and
    doesn’t have configurable options through its user interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，设备通常不会记录 UPnP 请求，这意味着用户无法知道攻击者是否在积极利用它。即使设备支持 UPnP 日志记录，日志通常存储在设备的客户端，并且没有通过用户界面配置的选项。
- en: Punching Holes Through Firewalls
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过防火墙打洞
- en: 'Let’s perform what is perhaps the most common attack against UPnP: punching
    unsolicited holes through firewalls. In other words, this attack will add or modify
    a rule in the firewall configuration that exposes an otherwise protected network
    service. By doing so, we’ll walk through the different UPnP layers and gain a
    better understanding of how the protocol works.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一种或许是最常见的 UPnP 攻击：通过防火墙打洞。换句话说，这种攻击将添加或修改防火墙配置中的规则，从而暴露一个本应受到保护的网络服务。通过这样做，我们将了解不同的
    UPnP 层次，并更好地理解协议的工作原理。
- en: How the Attack Works
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 攻击原理
- en: This firewall attack relies on the inherent permissiveness of the *Internet
    Gateway Device* (*IGD*) protocol implemented via UPnP. IGD maps ports in *network
    address translation* (*NAT*) setups.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个防火墙攻击依赖于通过 UPnP 实现的 *Internet Gateway Device*（*IGD*）协议的固有宽容性。IGD 在 *网络地址转换*（*NAT*）设置中映射端口。
- en: 'Almost every home router uses NAT, a system that allows multiple devices to
    share the same external IP address by remapping the IP address to a private network
    address. The external IP is typically the public address your internet service
    provider assigns to your modem or router. The private IP addresses can be any
    of the standard RFC 1918 range: 10.0.0.0–10.255.255.255 (class A), 172.16.0.0–172.31.255.255
    (class B), or 192.168.0.0–192.168.255.255 (class C).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个家庭路由器都使用 NAT，这是一种通过将 IP 地址重新映射到私有网络地址，使多个设备共享相同外部 IP 地址的系统。外部 IP 通常是互联网服务提供商分配给您的调制解调器或路由器的公共地址。私有
    IP 地址可以是任何标准的 RFC 1918 范围：10.0.0.0–10.255.255.255（A 类）、172.16.0.0–172.31.255.255（B
    类）或 192.168.0.0–192.168.255.255（C 类）。
- en: Although NAT is convenient for home solutions and conserves IPv4 address space,
    it does have some flexibility problems. For example, what happens when applications,
    such as BitTorrent clients, need other systems to connect to them on a specific
    public port but are behind a NAT device? Unless that port is exposed on the device’s
    internet-facing network, no peer can connect. One solution is to have the user
    manually configure port forwarding on their router. But that would be inconvenient,
    especially if the port had to change for every connection. Also, if the port was
    statically configured in the router’s port-forwarding settings, any other application
    that needed to use that specific port couldn’t. The reason is that external port
    mapping would already be associated with a specific internal port and IP address
    and, therefore, would have to be reconfigured for every connection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 NAT 对家庭解决方案很方便，并且节省了 IPv4 地址空间，但它确实存在一些灵活性问题。例如，当应用程序（如 BitTorrent 客户端）需要其他系统连接到其特定的公共端口，但又位于
    NAT 设备后面时会发生什么？除非该端口在设备的面向互联网的网络上暴露，否则没有对等方能够连接。一种解决方案是让用户手动配置路由器上的端口转发。但这样会很不方便，尤其是当每个连接都需要更改端口时。此外，如果端口在路由器的端口转发设置中被静态配置，任何其他需要使用该特定端口的应用程序就无法使用。原因是外部端口映射已经与特定的内部端口和
    IP 地址关联，因此必须为每个连接重新配置。
- en: 'This is where IGD comes to the rescue. IGD allows an application to dynamically
    add a temporary port mapping on the router for a certain time period. It solves
    both problems: users don’t need to manually configure port forwarding, and it
    allows the port to change for every connection.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这时 IGD 就派上用场了。IGD 允许应用程序在路由器上动态添加一个临时的端口映射，并在一定时间内有效。它解决了两个问题：用户不需要手动配置端口转发，并且它允许每个连接使用不同的端口。
- en: But attackers can abuse IGD in insecurely configured UPnP setups. Normally,
    systems behind the NAT device should be able to perform port forwarding on their
    own ports only. The problem is that many IoT devices, even nowadays, allow anyone
    on the network to add port mappings for other systems. This allows attackers on
    the network to do malicious things, such as exposing the administration interface
    of a router to the internet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是攻击者可以在配置不安全的 UPnP 设置中滥用 IGD。通常，位于 NAT 设备后面的系统应仅能在自己的端口上执行端口转发。问题在于，许多物联网设备，即使到今天，仍允许网络中的任何人添加其他系统的端口映射。这使得网络中的攻击者可以做出恶意行为，比如将路由器的管理界面暴露到互联网上。
- en: Setting Up a Test UPnP Server
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置测试 UPnP 服务器
- en: We’ll start by setting up MiniUPnP, a lightweight implementation of a UPnP IGD
    server, on an OpenWrt image so we have a UPnP server to attack. OpenWrt is an
    open source, Linux-based operating system targeting embedded devices and is primarily
    used for network routers. You can skip this setup section if you download the
    vulnerable OpenWrt VM from [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 OpenWrt 镜像上设置 MiniUPnP，这是 UPnP IGD 服务器的轻量级实现，这样我们就有了一个可供攻击的 UPnP 服务器。OpenWrt
    是一个基于 Linux 的开源操作系统，专为嵌入式设备设计，主要用于网络路由器。如果您从 [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/)
    下载易受攻击的 OpenWrt 虚拟机，可以跳过此设置部分。
- en: Walking through the OpenWrt setup is beyond the scope of this book, but you
    can find a guide for its setup at [https://openwrt.org/docs/guide-user/virtualization/vmware](https://openwrt.org/docs/guide-user/virtualization/vmware).
    Convert a snapshot of OpenWrt/18.06 to a VMware-compatible image and run it using
    the VMware workstation or player on a local lab network. You can find the x86
    snapshot we used for OpenWrt version 18.06 at [https://downloads.openwrt.org/releases/18.06.4/targets/x86/generic/openwrt-18.06.4-x86-generic-combined-ext4.img.gz](https://downloads.openwrt.org/releases/18.06.4/targets/x86/generic/openwrt-18.06.4-x86-generic-combined-ext4.img.gz)*.*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及 OpenWrt 的安装过程，但你可以在 [https://openwrt.org/docs/guide-user/virtualization/vmware](https://openwrt.org/docs/guide-user/virtualization/vmware)
    上找到相关的设置指南。将 OpenWrt/18.06 的快照转换为 VMware 兼容的镜像，并在本地实验室网络上使用 VMware Workstation
    或 Player 运行它。你可以在 [https://downloads.openwrt.org/releases/18.06.4/targets/x86/generic/openwrt-18.06.4-x86-generic-combined-ext4.img.gz](https://downloads.openwrt.org/releases/18.06.4/targets/x86/generic/openwrt-18.06.4-x86-generic-combined-ext4.img.gz)
    下载我们用于 OpenWrt 版本 18.06 的 x86 快照。
- en: 'Next, set up your network configuration, which is particularly important to
    clearly demonstrate the attack. We configured two network adapters in the virtual
    machine’s settings:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置你的网络配置，这对清晰地演示攻击至关重要。我们在虚拟机的设置中配置了两个网络适配器：
- en: One that is bridged on the local network and corresponds to eth0 (the LAN interface).
    In our case, we statically configured it to have the IP address 192.168.10.254
    corresponding to our local network lab. We configured the IP address by manually
    editing the */etc/network/config* file of our OpenWrt VM. Adjust this to reflect
    your local network configuration.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个是桥接到本地网络并对应于 eth0（LAN 接口）。在我们的案例中，我们静态配置它为 IP 地址 192.168.10.254，对应于我们的本地网络实验室。我们通过手动编辑
    OpenWrt 虚拟机的 */etc/network/config* 文件来配置这个 IP 地址。根据你的本地网络配置调整此设置。
- en: One that is configured as VMware’s NAT interface and corresponds to eth1 (the
    WAN interface). It was automatically assigned the IP address 192.168.92.148 through
    DHCP. This one emulates the external, or PPP, interface of the router that would
    be connected to the internet service provider and have a public IP address.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个被配置为 VMware 的 NAT 接口，并对应于 eth1（WAN 接口）。它通过 DHCP 自动分配了 IP 地址 192.168.92.148。这个接口模拟了路由器的外部接口，或称
    PPP 接口，该接口通常连接到互联网服务提供商，并具有公共 IP 地址。
- en: If you haven’t worked with VMware before, the guide at [https://www.vmware.com/support/ws45/doc/network_configure_ws.html](https://www.vmware.com/support/ws45/doc/network_configure_ws.html)can
    help you set up additional network interfaces for your virtual machine. Although
    it mentions version 4.5, the instructions are applicable for every modern VMware
    implementation. If you’re usingVMware Fusion on macOS, the guide at [https://docs.vmware.com/en/VMware-Fusion/12/com.vmware.fusion.using.doc/GUID-E498672E-19DD-40DF-92D3-FC0078947958.html](https://docs.vmware.com/en/VMware-Fusion/12/com.vmware.fusion.using.doc/GUID-E498672E-19DD-40DF-92D3-FC0078947958.html)
    can help you. In either case, add a second network adapter and change its settings
    to NAT (called “Share with My Mac” on Fusion), and then modify the first network
    adapter to be Bridged (called “Bridged Networking” on Fusion).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没有使用过 VMware，可以参考 [https://www.vmware.com/support/ws45/doc/network_configure_ws.html](https://www.vmware.com/support/ws45/doc/network_configure_ws.html)
    的指南，帮助你为虚拟机设置额外的网络接口。虽然它提到的是 4.5 版本，但该指南适用于所有现代 VMware 实现。如果你在 macOS 上使用 VMware
    Fusion，可以参考 [https://docs.vmware.com/en/VMware-Fusion/12/com.vmware.fusion.using.doc/GUID-E498672E-19DD-40DF-92D3-FC0078947958.html](https://docs.vmware.com/en/VMware-Fusion/12/com.vmware.fusion.using.doc/GUID-E498672E-19DD-40DF-92D3-FC0078947958.html)
    进行设置。在任何一种情况下，添加第二个网络适配器并将其设置为 NAT（在 Fusion 上称为“与我的 Mac 共享”），然后将第一个网络适配器修改为桥接模式（在
    Fusion 上称为“桥接网络”）。
- en: You might want to configure the VMware settings so the bridged mode applies
    only to the adapter that is actually connected to your local network. Because
    you have two adapters, VMware’s auto-bridge feature might try to bridge with the
    one that isn’t connected. It’s typical to have one Ethernet and one Wi-Fi adapter,
    so make sure you check which one is connected to which network.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望配置 VMware 设置，使桥接模式仅应用于实际连接到本地网络的适配器。因为你有两个适配器，VMware 的自动桥接功能可能会尝试桥接到未连接的那个适配器。通常情况下，会有一个以太网适配器和一个
    Wi-Fi 适配器，所以确保检查每个适配器连接的网络。
- en: 'Now the network interfaces part of the OpenWrt VM’s */etc/config/network* file
    should look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，OpenWrt 虚拟机的网络接口部分的*/etc/config/network*文件应如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Make sure your OpenWrt has internet connectivity, and then enter the following
    command in your shell to install the MiniUPnP server and *luci-app-upnp*. The
    `luci-app-upnp` package lets you configure and display UPnP settings through Luci,
    the default web interface for OpenWrt:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 OpenWrt 具有互联网连接，然后在 shell 中输入以下命令安装 MiniUPnP 服务器和 *luci-app-upnp*。`luci-app-upnp`
    包允许您通过 Luci（OpenWrt 的默认 Web 界面）配置和显示 UPnP 设置：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then need to configure MiniUPnPd. Enter the following command to edit the
    file with Vim (or use the text editor of your choice):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要配置 MiniUPnPd。输入以下命令，使用 Vim 编辑该文件（或者使用您选择的文本编辑器）：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Scroll down to where the file mentions `config_load "upnpd"` for the second
    time (in MiniUPnP version 2.1-1, this is at line 134.) Change the settings as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动，直到文件第二次提到 `config_load "upnpd"`（在 MiniUPnP 版本 2.1-1 中，位于第 134 行）。将设置更改为如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The most important change is to disable `secure_mode`*.* Disabling this setting
    allows clients to redirect incoming ports to IP addresses other than themselves.
    This setting is enabled by default, which means the server would forbid an attacker
    from adding port mappings that would redirect to any other IP address.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的更改是禁用 `secure_mode`*.* 禁用此设置允许客户端将传入端口重定向到除自身以外的 IP 地址。默认情况下启用此设置，这意味着服务器会禁止攻击者添加将端口重定向到任何其他
    IP 地址的映射。
- en: 'The `config_load "upnpd"` command also loads additional settings from the */etc/config/upnpd*
    file, which you should change to look as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`config_load "upnpd"` 命令还会从 */etc/config/upnpd* 文件中加载额外的设置，您应该将其更改为如下所示：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, you have to manually add the external interface option 1; otherwise,
    the server won’t allow port redirection to the WAN interface. Second, enable the
    *init* script to launch MiniUPnP 2. Third, allow redirections to all internal
    ports 3, starting from 0\. By default, MiniUPnPd allows redirections to certain
    ports only. We deleted all other *perm_rules.* If you copy the */etc/config/upnpd*file
    as shown here, you should be good to go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要手动添加外部接口选项 1；否则，服务器将不允许端口重定向到 WAN 接口。第二，启用 *init* 脚本以启动 MiniUPnP 2。第三，允许将所有内部端口
    3 的重定向，从 0 开始。默认情况下，MiniUPnPd 只允许将端口重定向到某些端口。我们删除了所有其他的 *perm_rules*。如果您按如下所示复制
    */etc/config/upnpd* 文件，您就可以继续进行操作。
- en: 'After completing the changes, restart the MiniUPnP daemon using the following
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成更改后，使用以下命令重启 MiniUPnP 守护进程：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You’ll also have to restart the OpenWrt firewall after restarting the server.
    The firewall is part of the Linux operating system, and OpenWrt comes with it
    enabled by default. You can easily do so by browsing to the web interface at [http://192.168.10.254/cgi-bin/luci/admin/status/iptables/](http://192.168.10.254/cgi-bin/luci/admin/status/iptables/%20)
    and clicking **Restart Firewall**, or by entering the following command in a terminal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启服务器后，您还需要重启 OpenWrt 防火墙。防火墙是 Linux 操作系统的一部分，OpenWrt 默认启用它。您可以通过浏览 Web 界面
    [http://192.168.10.254/cgi-bin/luci/admin/status/iptables/](http://192.168.10.254/cgi-bin/luci/admin/status/iptables/%20)
    并点击 **Restart Firewall**，或者在终端中输入以下命令来轻松完成：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Current versions of OpenWrt are more secure, and we’re deliberately making this
    server insecure for the purposes of this exercise. Nevertheless, countless available
    IoT products are configured like this by default.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的 OpenWrt 更加安全，而我们故意将这个服务器设置为不安全，以便进行本次练习。然而，许多现有的物联网产品默认配置就是这样。
- en: Punching Holes in the Firewall
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 防火墙打孔
- en: With our test environment set up, let’s try the firewall hole-punching attack
    by abusing IGD. We’ll use IGD’s `WANIPConnection` subprofile, which supports the
    `AddPortMapping` and `DeletePortMapping` actions for adding and removing port
    mappings, correspondingly. We’ll use the `AddPortMapping` command with the UPnP
    testing tool Miranda, which is preinstalled on Kali Linux. If you don't have Miranda
    preinstalled, you can always get it from [https://github.com/0x90/miranda-upnp/](https://github.com/0x90/miranda-upnp/)—note
    that you'll need Python 2 to run it. [Listing 6-1](#listing6-1) uses Miranda to
    punch a hole through the firewall on the vulnerable OpenWrt router.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好我们的测试环境后，接下来我们通过利用 IGD 进行防火墙打孔攻击。我们将使用 IGD 的 `WANIPConnection` 子配置文件，它支持
    `AddPortMapping` 和 `DeletePortMapping` 操作，分别用于添加和删除端口映射。我们将使用 `AddPortMapping`
    命令，并通过 UPnP 测试工具 Miranda 进行测试，该工具在 Kali Linux 上预装。如果您没有预装 Miranda，可以通过 [https://github.com/0x90/miranda-upnp/](https://github.com/0x90/miranda-upnp/)
    获取—请注意，您需要 Python 2 来运行它。[Listing 6-1](#listing6-1) 使用 Miranda 对易受攻击的 OpenWrt
    路由器进行防火墙打孔。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-1: Punching a hole in the OpenWrt router with Miranda'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-1：使用 Miranda 打开 OpenWrt 路由器上的防火墙孔
- en: The `msearch` command sends an M-SEARCH * packet to the multicast address 239.255.255.250
    on UDP port 1900, completing the active discovery stage, as described in “The
    UPnP Stack” on page 119\. You can press CTRL-C at any time to stop waiting for
    more replies, and you should do so when your target responds.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`msearch`命令向UDP端口1900的多播地址239.255.255.250发送一个M-SEARCH *数据包，完成了如“UPnP协议栈”第119页中所描述的主动发现阶段。你可以随时按CTRL-C停止等待更多的回复，当目标响应时你应该这样做。'
- en: The host 192.168.10.254 should now appear on the `host list`, a list of targets
    the tool keeps track of internally, along with an associated index. Pass the index
    as an argument to the `host get` command to fetch the *rootDesc.xml* description
    file. Once you do so, `host details` should display all supported IGD profiles
    and subprofiles. In this case, `WANIPConnection` under `WANConnectionDevice` should
    show up for our target.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 主机192.168.10.254现在应该出现在`主机列表`中，这是工具内部跟踪的目标列表，并附有相关索引。将索引作为参数传递给`host get`命令来获取*rootDesc.xml*描述文件。一旦执行，`host
    details`应显示所有支持的IGD配置文件和子配置文件。在这种情况下，`WANIPConnection`应该在`WANConnectionDevice`下显示出来，作为我们目标的配置。
- en: Finally, we send the `AddPortMapping` command to the host to redirect the external
    port 5555 (randomly chosen) to the web server’s internal port, exposing the web
    administration interface to the internet. When we enter the command, we have to
    then specify its arguments. The `NewPortMappingDescription` is any string value,
    and it’s normally displayed in the router’s UPnP settings for the mapping. The
    `NewLeaseDuration` sets how long the port mapping will be active. The value `0`,
    shown here, means unlimited time. The `NewEnabled` argument can be `0` (meaning
    inactive) or `1` (meaning active). The `NewInternalClient` refers to the IP address
    of the internal host that the mapping is associated with. The `NewRemoteHost`
    is usually empty. Otherwise, it would restrict the port mapping to only that particular
    external host. The `NewProtocol` can be TCP or UDP. The `NewInternalValue` is
    the port of the `NewInternalClient` host that the traffic coming on the `NewExternalPort`
    will be forwarded to.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向主机发送`AddPortMapping`命令，将外部端口5555（随机选择）重定向到Web服务器的内部端口，从而将Web管理界面暴露给互联网。输入命令后，我们必须指定其参数。`NewPortMappingDescription`是一个字符串值，通常会显示在路由器的UPnP设置中用于映射。`NewLeaseDuration`设置端口映射的有效时间，值`0`表示无限时间。`NewEnabled`参数可以是`0`（表示不活跃）或`1`（表示活跃）。`NewInternalClient`是指与映射关联的内部主机的IP地址。`NewRemoteHost`通常为空，否则，它会将端口映射限制为特定的外部主机。`NewProtocol`可以是TCP或UDP。`NewInternalValue`是`NewInternalClient`主机的端口，来自`NewExternalPort`的流量将被转发到该端口。
- en: We should now be able to see the new port mapping by visiting the web interface
    for the OpenWrt router at *192.168.10.254/cgi/bin/luci/admin/services/upnp* ([Figure
    6-1](#figure6-1)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够通过访问OpenWrt路由器的Web界面 *192.168.10.254/cgi/bin/luci/admin/services/upnp*
    来查看新的端口映射（[图6-1](#figure6-1)）。
- en: '![f06001](Images/f06001.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](Images/f06001.png)'
- en: 'Figure 6-1: We should see the new port mapping in the Luci interface.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：我们应该能在Luci界面中看到新的端口映射。
- en: To test whether our attack was successful, let’s visit our router’s external
    IP address 192.168.92.148 on the forwarded port 5555\. Remember that the private
    web interface shouldn’t normally be accessible through the public-facing interface.
    [Figure 6-2](#figure6-2) shows the result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的攻击是否成功，让我们访问路由器的外部IP地址192.168.92.148，端口是转发的5555\. 记住，私有Web界面通常不应该通过面向公众的接口访问。[图6-2](#figure6-2)展示了结果。
- en: '![f06002](Images/f06002.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](Images/f06002.png)'
- en: 'Figure 6-2: The accessible web interface'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：可访问的Web界面
- en: After we sent the `AddPortMapping` command, the private web interface became
    accessible through the external interface on port 5555.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发送`AddPortMapping`命令后，私有Web界面变得可以通过外部接口的5555端口访问。
- en: Abusing UPnP Through WAN interfaces
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过WAN接口滥用UPnP
- en: Next, let’s abuse UPnP remotely through the WAN interface. This tactic could
    allow an external attacker to do some damage, such as forward ports from hosts
    inside the LAN or execute other useful IGD commands, like the self-explanatory
    `GetPassword` or `GetUserName`. You can perform this attack in buggy or insecurely
    configured UPnP implementations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过WAN接口远程滥用UPnP。这种策略可能允许外部攻击者造成一些损害，比如将LAN内部主机的端口转发或执行其他有用的IGD命令，例如自解释的`GetPassword`或`GetUserName`。你可以在有漏洞或配置不当的UPnP实现中执行此攻击。
- en: To perform this attack, we’ll use Umap, a tool written specifically for this
    purpose.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个攻击，我们将使用Umap，这是一个专门为此目的编写的工具。
- en: How the Attack Works
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 攻击如何进行
- en: As a security precaution, most devices don’t normally accept SSDP packets through
    the WAN interface, but some of them can still accept IGD commands through open
    SOAP control points. This means that an attacker can interact with them directly
    from the internet.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为安全预防措施，大多数设备通常不会接受通过WAN接口传输的SSDP数据包，但其中一些仍然可以通过开放的SOAP控制点接受IGD命令。这意味着攻击者可以直接从互联网与它们交互。
- en: For that reason, Umap skips the discovery phase of the UPnP stack (the phase
    in which a device uses SSDP to discover other devices on the network) and tries
    to directly scan for the XML description files. If it finds one, it then moves
    on to UPnP’s control step and tries to interact with the device by sending it
    SOAP requests directed at the URL in the description file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个原因，Umap跳过了UPnP堆栈的发现阶段（即设备通过SSDP发现网络中的其他设备的阶段），并尝试直接扫描XML描述文件。如果找到文件，它就会进入UPnP的控制步骤，并通过发送指向描述文件中URL的SOAP请求与设备交互。
- en: '[Figure 6-3](#figure6-3) shows the flow diagram for Umap’s scan of internal
    networks.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](#figure6-3)展示了Umap扫描内部网络的流程图。'
- en: '![f06003](Images/f06003.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](Images/f06003.png)'
- en: 'Figure 6-3: The Umap flow diagram for scanning hosts'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：Umap扫描主机的流程图
- en: Umap first tries to scan for IGD control points by testing a variety of known
    XML file locations (such as */rootDesc.xml* or */upnp/IGD.xml*). After it finds
    one successfully, Umap tries to guess the internal LAN IP block. Remember that
    you’re scanning the external (internet-facing) IP address, so the IP addresses
    behind the NAT device will be different.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Umap首先通过测试多种已知的XML文件位置（例如*/rootDesc.xml*或*/upnp/IGD.xml*）来尝试扫描IGD控制点。在成功找到一个之后，Umap会尝试猜测内部LAN的IP区块。记住，你正在扫描外部（面向互联网的）IP地址，所以NAT设备后的IP地址会有所不同。
- en: 'Next, Umap sends an IGD port-mapping command for each common port, forwarding
    that port to the WAN. Then it tries to connect to that port. If the port is closed,
    it sends an IGD command to delete the port mapping. Otherwise, it reports that
    the port is open and leaves the port mapping as-is. By default, it scans the following
    common ports (hardcoded in the `commonPorts` variable in *umap.py*):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Umap会为每个常见端口发送一个IGD端口映射命令，将该端口转发到WAN。然后它会尝试连接到该端口。如果端口关闭，它会发送一个IGD命令来删除端口映射。否则，它会报告端口已打开，并保持端口映射不变。默认情况下，它扫描以下常见端口（硬编码在`commonPorts`变量中，位于*umap.py*文件内）：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of course, you can edit the `commonPorts` variable and try to forward other
    ports. You can find a good reference for the most commonly used TCP ports by running
    the following Nmap command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以编辑`commonPorts`变量，并尝试转发其他端口。你可以通过运行以下Nmap命令找到最常用的TCP端口的一个很好的参考：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting and Using Umap
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取和使用Umap
- en: 'Umap was first released at Defcon 19 by Daniel Garcia; you can find the latest
    version of it on the tool author’s website at [https://toor.do/umap-0.8.tar.gz](https://toor.do/umap-0.8.tar.gz).
    After extracting the compressed tarball Umap, you might also need to install SOAPpy
    and iplib:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Umap首次由Daniel Garcia在Defcon 19发布；你可以在工具作者的官方网站上找到它的最新版本：[https://toor.do/umap-0.8.tar.gz](https://toor.do/umap-0.8.tar.gz)。解压缩tarball文件后，你可能还需要安装SOAPpy和iplib：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Umap is written in Python 2, which is no longer officially maintained; so if
    your Linux distribution doesn’t have the Python 2 `pip` package manager available,
    you’ll need to download it manually from [https://pypi.org/project/pip/#files](https://pypi.org/project/pip/#files).
    Download the latest version of the source and run it like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Umap是用Python 2编写的，而Python 2已不再正式维护；因此，如果你的Linux发行版没有提供Python 2的`pip`包管理器，你需要手动从[https://pypi.org/project/pip/#files](https://pypi.org/project/pip/#files)下载它。下载最新版本的源代码，并按以下方式运行：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run Umap with the following command (replacing the IP address with your target’s
    external IP address):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行Umap（将IP地址替换为目标的外部IP地址）：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once you run it, Umap will go through the flow diagram shown in [Figure 6-3](#figure6-3).
    Even if the device doesn’t advertise an IGD command (meaning that the command
    might not be necessarily listed as `controlURL` in the *description* XML file),
    some systems still accept the commands because of buggy UPnP implementations.
    So, you should always try all of them in a proper security test. contains a list
    of IGD commands to test.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行它，Umap将按照[图6-3](#figure6-3)所示的流程图执行。即使设备没有公布IGD命令（意味着该命令不一定会作为`controlURL`出现在*description*
    XML文件中），一些系统仍然会接受这些命令，因为存在BUG的UPnP实现。所以，你应该始终在适当的安全测试中尝试所有这些命令。
- en: 'Table 6-1: A List of Possible IGD Commands'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1：可能的IGD命令列表
- en: '| `SetConnectionType` | Sets up a specific connection type. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `SetConnectionType` | 设置特定的连接类型。 |'
- en: '| `GetConnectionTypeInfo` | Retrieves the values of the current connection
    type and allowable connection types. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `GetConnectionTypeInfo` | 获取当前连接类型及允许的连接类型值。 |'
- en: '| `ConfigureConnection` | Send this command to configure a PPP connection on
    the WAN device and change `ConnectionStatus` to `Disconnected` from `Unconfigured`.
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `ConfigureConnection` | 发送此命令以在WAN设备上配置PPP连接，并将`ConnectionStatus`从`Unconfigured`更改为`Disconnected`。
    |'
- en: '| `RequestConnection` | Initiates a connection on an instance of a connection
    service that has a configuration already defined. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `RequestConnection` | 在已经定义配置的连接服务实例上发起连接。 |'
- en: '| `RequestTermination` | Send this command to any connection instance in `Connected`,
    `Connecting`, or `Authenticating` state to change `ConnectionStatus` to `Disconnected`.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `RequestTermination` | 发送此命令到任何处于`Connected`、`Connecting`或`Authenticating`状态的连接实例，以将`ConnectionStatus`更改为`Disconnected`。
    |'
- en: '| `ForceTermination` | Send this command to any connection instance in `Connected`,
    `Connecting`, `Authenticating`, `PendingDisconnect`, or `Disconnecting` state
    to change `ConnectionStatus` to `Disconnected`. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ForceTermination` | 发送此命令到任何处于`Connected`、`Connecting`、`Authenticating`、`PendingDisconnect`或`Disconnecting`状态的连接实例，以将`ConnectionStatus`更改为`Disconnected`。
    |'
- en: '| `SetAutoDisconnectTime` | Sets the time (in seconds) after which an active
    connection is automatically disconnected. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `SetAutoDisconnectTime` | 设置活动连接在断开前的时间（秒）。 |'
- en: '| `SetIdleDisconnectTime` | Specifies the idle time (in seconds) after which
    a connection can be disconnected. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `SetIdleDisconnectTime` | 指定空闲时间（秒），连接在此时间后可以断开。 |'
- en: '| `SetWarnDisconnectDelay` | Specifies the number of seconds of warning to
    each (potentially) active user of a connection before a connection is terminated.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `SetWarnDisconnectDelay` | 指定在连接终止前，向每个（潜在的）活动用户发出的警告时间（秒）。 |'
- en: '| `GetStatusInfo` | Retrieves the values of state variables pertaining to connection
    status. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `GetStatusInfo` | 获取与连接状态相关的状态变量值。 |'
- en: '| `GetLinkLayerMaxBitRates` | Retrieves the maximum upstream and downstream
    bit rates for the connection. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `GetLinkLayerMaxBitRates` | 获取连接的最大上行和下行比特率。 |'
- en: '| `GetPPPEncryptionProtocol` | Retrieves the link layer (PPP) encryption protocol.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `GetPPPEncryptionProtocol` | 获取链路层（PPP）加密协议。 |'
- en: '| `GetPPPCompressionProtocol` | Retrieves the link layer (PPP) compression
    protocol. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `GetPPPCompressionProtocol` | 获取链路层（PPP）压缩协议。 |'
- en: '| `GetPPPAuthenticationProtocol` | Retrieves the link layer (PPP) authentication
    protocol. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `GetPPPAuthenticationProtocol` | 获取链路层（PPP）认证协议。 |'
- en: '| `GetUserName` | Retrieves the username used for the activation of a connection.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `GetUserName` | 获取用于激活连接的用户名。 |'
- en: '| `GetPassword` | Retrieves the password used for the activation of a connection.
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `GetPassword` | 获取用于激活连接的密码。 |'
- en: '| `GetAutoDisconnectTime` | Retrieves the time (in seconds) after which an
    active connection is automatically disconnected. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `GetAutoDisconnectTime` | 获取在活动连接自动断开后的时间（秒）。 |'
- en: '| `GetIdleDisconnectTime` | Retrieves the idle time (in seconds) after which
    a connection can be disconnected. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `GetIdleDisconnectTime` | 获取空闲时间（秒），连接在此时间后可以断开。 |'
- en: '| `GetWarnDisconnectDelay` | Retrieves the number of seconds of warning to
    each (potentially) active user of a connection before a connection is terminated.
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `GetWarnDisconnectDelay` | 获取在连接终止前，向每个（潜在的）活动用户发出的警告时间（秒）。 |'
- en: '| `GetNATRSIPStatus` | Retrieves the current state of NAT and Realm-Specific
    IP (RSIP) on the gateway for this connection. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `GetNATRSIPStatus` | 获取此连接在网关上当前的NAT和领域特定IP（RSIP）状态。 |'
- en: '| `GetGenericPortMappingEntry` | Retrieves NAT port mappings one entry at a
    time. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `GetGenericPortMappingEntry` | 一次获取一个NAT端口映射条目。 |'
- en: '| `GetSpecificPortMappingEntry` | Reports the Static Port Mapping specified
    by the unique tuple of `RemoteHost`, `ExternalPort`, and `PortMappingProtocol`.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `GetSpecificPortMappingEntry` | 报告由`RemoteHost`、`ExternalPort`和`PortMappingProtocol`的唯一元组指定的静态端口映射。
    |'
- en: '| `AddPortMapping` | Creates a new port mapping or overwrites an existing mapping
    with the same internal client. If the `ExternalPort` and `PortMappingProtocol`
    pair is already mapped to another internal client, an error is returned. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `AddPortMapping` | 创建新的端口映射或用相同的内部客户端覆盖现有映射。如果`ExternalPort`和`PortMappingProtocol`对已经映射到另一个内部客户端，则返回错误。
    |'
- en: '| `DeletePortMapping` | Deletes a previously instantiated port mapping. As
    each entry is deleted, the array is compacted, and the evented variable `PortMappingNumberOfEntries`
    is decremented. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `DeletePortMapping` | 删除先前实例化的端口映射。每删除一项条目，数组会被压缩，事件变量 `PortMappingNumberOfEntries`
    会递减。 |'
- en: '| `GetExternalIPAddress` | Retrieves the value of the external IP address on
    this connection instance. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `GetExternalIPAddress` | 检索此连接实例的外部IP地址值。 |'
- en: Note that the latest public version (0.8) of Umap doesn’t automatically test
    these commands. You can find more detailed information about them at the official
    specification at [http://upnp.org/specs/gw/UPnP-gw-WANPPPConnection-v1-Service.pdf/](http://upnp.org/specs/gw/UPnP-gw-WANPPPConnection-v1-Service.pdf/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Umap的最新公共版本（0.8）不会自动测试这些命令。你可以在官方规范中找到关于它们的更详细信息：[http://upnp.org/specs/gw/UPnP-gw-WANPPPConnection-v1-Service.pdf/](http://upnp.org/specs/gw/UPnP-gw-WANPPPConnection-v1-Service.pdf/)。
- en: 'After Umap identifies an internet-exposed IGD, you can use Miranda to manually
    test these commands. Depending on the command, you should get various replies.
    For example, going back to our vulnerable OpenWrt router and running Miranda against
    it, we can see the output of some of these commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Umap识别出一个暴露于互联网的IGD后，你可以使用Miranda手动测试这些命令。根据命令的不同，你应当收到不同的回复。例如，回到我们脆弱的OpenWrt路由器，并对其运行Miranda，我们可以看到这些命令的部分输出：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But the tool might not always indicate that the command succeeded, so remember
    to have a packet analyzer like Wireshark active at all times to understand what
    happens behind the scenes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但该工具可能并不会始终指示命令是否成功，因此请记得始终保持Wireshark等数据包分析工具处于活动状态，以便了解背后发生了什么。
- en: 'Remember that running `host details` will give you a long list of all the advertised
    commands, but you should still try to test them all. The following output shows
    only the first portion of the list for the OpenWrt system we configured earlier:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，运行 `host details` 会给你一个广告命令的长列表，但你仍然应该尝试测试它们中的所有命令。以下输出仅显示了我们之前配置的OpenWrt系统命令列表的第一部分：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This output contains only a small portion of the long list of advertised UPnP
    commands.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出仅包含长列表中一小部分广告的UPnP命令。
- en: Other UPnP Attacks
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他UPnP攻击
- en: You could try other attacks against UPnP as well. For example, you could exploit
    a pre-authentication XSS vulnerability on a router’s web interface using UPnP’s
    port-forwarding capability. This kind of attack would work remotely, even if the
    router blocks WAN requests. To do so, you would first socially engineer the user
    to visit a website that hosts the malicious JavaScript payload with the XSS. The
    XSS would allow the vulnerable router to enter the same LAN as the user, so you
    could send it commands through its UPnP service. These commands, in the form of
    specially crafted XML requests inside an XMLHttpRequest object, can force the
    router to forward ports from inside the LAN to the internet.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试对UPnP进行其他攻击。例如，你可以利用路由器Web界面上的预认证XSS漏洞，利用UPnP的端口转发功能进行攻击。这种攻击即使路由器阻止WAN请求，也能远程工作。为了做到这一点，你首先需要通过社交工程让用户访问一个托管恶意JavaScript负载的网页，该负载包含XSS。XSS漏洞将使脆弱的路由器与用户处于相同的局域网内，这样你就可以通过UPnP服务向路由器发送命令。这些命令以特制的XML请求的形式，嵌入在一个XMLHttpRequest对象内，可以迫使路由器将LAN内的端口转发到互联网。
- en: Exploiting mDNS and DNS-SD
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用mDNS和DNS-SD
- en: '*Multicast DNS* (*mDNS*) is a zero-configuration protocol that lets you perform
    DNS-like operations on the local network in the absence of a conventional, unicast
    DNS server. The protocol uses the same API, packet formats, and operating semantics
    as DNS, allowing you to resolve domain names on the local network. *DNS Service
    Discovery* (*DNS-SD*) is a protocol that allows clients to discover a list of
    named instances of services (such as *test._ipps._tcp.local*, or *linux._ssh._tcp.local*)
    in a domain using standard DNS queries. DNS-SD is most often used in conjunction
    with mDNS but isn’t dependent on it. They’re both used by many IoT devices, such
    as network printers, Apple TVs, Google Chromecast, Network-Attached Storage (NAS)
    devices, and cameras. Most modern operating systems support them.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*多播DNS* (*mDNS*) 是一种零配置协议，在没有传统单播DNS服务器的情况下，允许你在本地网络上执行类似DNS的操作。该协议使用与DNS相同的API、数据包格式和操作语义，允许你在本地网络上解析域名。*DNS服务发现*
    (*DNS-SD*) 是一种协议，允许客户端通过标准DNS查询在某个域中发现一组命名的服务实例（例如 *test._ipps._tcp.local* 或 *linux._ssh._tcp.local*）。DNS-SD通常与mDNS一起使用，但并不依赖于mDNS。它们被许多物联网设备使用，如网络打印机、Apple
    TV、Google Chromecast、网络附加存储（NAS）设备和摄像头。大多数现代操作系统都支持它们。'
- en: Both protocols operate within the same *broadcast* domain, which means that
    devices share the same *data link layer*, also called the local link or layer
    2 in the computer networking Open Systems Interconnection (OSI) model. This means
    messages won’t pass through routers, which operate at layer 3\. The devices must
    be connected to the same Ethernet repeaters or network switches to listen and
    reply to these multicast messages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两种协议都在同一个*广播*域内操作，这意味着设备共享相同的*数据链路层*，也称为本地链接或计算机网络开放系统互联（OSI）模型中的第二层。这意味着消息不会通过路由器，路由器工作在第三层。设备必须连接到相同的以太网中继器或网络交换机，才能监听并回复这些多播消息。
- en: Local-link protocols can introduce vulnerabilities for two reasons. First, even
    though you’ll normally encounter these protocols in the local link, the local
    network isn’t necessarily a trusted one with cooperating participants. Complex
    network environments often lack proper segmentation, allowing attackers to pivot
    from one part of the network to the other (for example, by compromising the routers).
    In addition, corporate environments often employ Bring Your Own Device (BYOD)
    policies that allow staff to use their personal devices in these networks. This
    situation gets even worse in public networks, such as those in airports or cafes.
    Second, insecure implementations of these services can allow attackers to exploit
    them remotely, completely bypassing the local-link containment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本地链接协议可能引入漏洞，原因有二。首先，尽管你通常会在本地链接中遇到这些协议，但本地网络不一定是一个可信的、合作的参与者网络。复杂的网络环境往往缺乏适当的分段，使得攻击者可以从网络的一部分转移到另一部分（例如，通过攻破路由器）。此外，企业环境中常常采用自带设备（BYOD）政策，允许员工在这些网络中使用个人设备。在公共网络中，情况更糟，例如在机场或咖啡馆的网络中。其次，这些服务的不安全实现可能允许攻击者远程利用它们，完全绕过本地链接的隔离。
- en: In this section, we’ll examine how to abuse these two protocols in IoT ecosystems.
    You can perform reconnaissance, man-in-the-middle attacks, denial of service attacks,
    unicast DNS cache poisoning, and more!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论如何在物联网生态系统中滥用这两种协议。你可以进行侦察、中间人攻击、拒绝服务攻击、单播DNS缓存中毒等攻击！
- en: How mDNS Works
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mDNS的工作原理
- en: Devices use mDNS when the local network lacks a conventional unicast DNS server.
    To resolve a domain name for a local address using mDNS, the device sends a DNS
    query for a domain name ending with *.local* to the multicast address 224.0.0.251
    (for IPv4) or FF02::FB (for IPv6). You can also use mDNS to resolve global domain
    names (non *.local* ones), but mDNS implementations are supposed to disable this
    behavior by default. mDNS requests and responses use UDP and port 5353 as both
    the source and destination port.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 设备在本地网络缺少传统的单播DNS服务器时使用mDNS。为了通过mDNS解析本地地址的域名，设备将一个以*.local*结尾的域名DNS查询发送到多播地址224.0.0.251（对于IPv4）或FF02::FB（对于IPv6）。你也可以使用mDNS解析全局域名（非*.local*的域名），但mDNS实现通常默认禁用此行为。mDNS请求和响应使用UDP，并且端口5353既是源端口也是目标端口。
- en: 'Whenever a change in the connectivity of an mDNS responder occurs, it must
    perform two activities: *Probing* and *Announcing*. During Probing, which happens
    first, the host queries (using the query type `"ANY"`, which corresponds to the
    value 255 in the QTYPE field in the mDNS packet) the local network to check whether
    the records it wants to announce are already in use. If they aren’t in use, the
    host then *Announces* its newly registered records (contained in the packet’s
    Answer section) by sending unsolicited mDNS responses to the network.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每当mDNS响应者的连接性发生变化时，它必须执行两个活动：*探测*和*公告*。在首先进行的探测过程中，主机使用查询类型`"ANY"`（对应mDNS数据包中的QTYPE字段值255）在本地网络上查询，检查它想要发布的记录是否已在使用。如果记录尚未被使用，主机就会通过发送未请求的mDNS响应到网络来*公告*其新注册的记录（这些记录包含在数据包的Answer部分）。
- en: The mDNS replies contain several important flags, including a Time-to-Live (TTL)
    value that signifies how many seconds the record is valid. Sending a reply with
    `TTL=0` means that the corresponding record should be cleared. Another important
    flag is the QU bit, which denotes whether or not the query is a unicast query.
    If the QU bit isn’t set, the packet is a multicast query (QM). Because it’s possible
    to receive unicast queries outside of the local link, secure mDNS implementations
    should always check that the source address in the packet matches the local subnet
    address range.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: mDNS 响应包含多个重要标志，其中包括一个生存时间（TTL）值，表示记录有效的秒数。发送 `TTL=0` 的响应意味着应该清除相应的记录。另一个重要标志是
    QU 位，它表示查询是否为单播查询。如果 QU 位没有被设置，数据包就是多播查询（QM）。因为有可能在本地链路之外接收到单播查询，安全的 mDNS 实现应始终检查数据包中的源地址是否与本地子网地址范围匹配。
- en: How DNS-SD Works
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DNS-SD 的工作原理
- en: DNS-SD allows clients to discover available services on the network. To use
    it, clients send standard DNS queries for pointer records (PTR), which map the
    type of service to a list of names of specific instances of that type of service.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: DNS-SD 允许客户端发现网络上可用的服务。要使用它，客户端发送标准的 DNS 查询请求指针记录（PTR），这些记录将服务类型映射到该类型服务的特定实例名称列表。
- en: 'To request a PTR record, clients use the name form `"<Service>.<Domain>"`.
    The `<Service>` part is a pair of DNS labels: an underscore character, followed
    by the service name (for example, _ipps, _printer, or _ipp) and either `_tcp`
    or `_udp`. The `<Domain>` portion is `".local"`. Responders then return the PTR
    records that point to the accompanying service (SRV) and text (TXT) records. An
    mDNS PTR record contains the name of the service, which is the same as the name
    of the SRV record without the instance name: in other words, it points to the
    SRV record. Here is an example of a PTR record:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求 PTR 记录，客户端使用 `"<Service>.<Domain>"` 的名称格式。`<Service>` 部分是由一对 DNS 标签组成：一个下划线字符，后跟服务名称（例如
    _ipps、_printer 或 _ipp），以及 `_tcp` 或 `_udp`。`<Domain>` 部分是 `".local"`。响应者随后返回指向附带的服务（SRV）和文本（TXT）记录的
    PTR 记录。一个 mDNS PTR 记录包含服务的名称，这与 SRV 记录的名称相同，但不包含实例名称：换句话说，它指向 SRV 记录。以下是一个 PTR
    记录的示例：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The part of the PTR record to the left of the colon is its name, and the part
    on the right is the SRV record to which the PTR record points. The SRV record
    lists the target host and port where the service instance can be reached. For
    example, [Figure 6-4](#figure6-4) shows a `"test._ipps._tcp.local"` SRV record
    in Wireshark.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PTR 记录冒号左边的部分是它的名称，右边的部分是 PTR 记录指向的 SRV 记录。SRV 记录列出了可以访问该服务实例的目标主机和端口。例如，[图
    6-4](#figure6-4) 显示了 Wireshark 中的 `"test._ipps._tcp.local"` SRV 记录。
- en: '![f06004](Images/f06004.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![f06004](Images/f06004.png)'
- en: 'Figure 6-4: An example SRV record for the service `"test._ipps._tcp.local"`.
    The `Target` and `Port` fields contain the hostname and listening port for the
    service.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4：服务 `"test._ipps._tcp.local"` 的 SRV 记录示例。`Target` 和 `Port` 字段包含服务的主机名和监听端口。
- en: 'SRV names have the format `"<Instance>.<Service>.<Domain>"`. The label `<Instance>`
    includes a user-friendly name for the service (`test` in this case). The `<Service>`
    label identifies what the service does and what application protocol it uses to
    do it. It’s composed of a set of DNS labels: an underscore character, followed
    by the service name (for example `_ipps`, `_ipp`, `_http`), followed by the transport
    protocol (`_tcp`, `_udp`, `_sctp`, and so on). The `<Domain>` portion specifies
    the DNS subdomain where these names are registered. For mDNS, it’s *.local*, but
    it can be anything when you’re using unicast DNS. The SRV record also contains
    `Target` and `Port` sections containing the hostname and port where the service
    can be found ([Figure 6-4](#figure6-4)).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SRV 名称的格式是 `"<Instance>.<Service>.<Domain>"`。`<Instance>` 标签包含服务的用户友好名称（在此示例中为
    `test`）。`<Service>` 标签标识服务的功能以及它使用的应用协议。它由一组 DNS 标签组成：一个下划线字符，后跟服务名称（例如 `_ipps`、`_ipp`、`_http`），然后是传输协议（例如
    `_tcp`、`_udp`、`_sctp` 等）。`<Domain>` 部分指定这些名称注册的 DNS 子域。对于 mDNS，它是 `*.local*`，但在使用单播
    DNS 时可以是任何名称。SRV 记录还包含 `Target` 和 `Port` 部分，列出了可以找到该服务的主机名和端口（参见 [图 6-4](#figure6-4)）。
- en: The TXT record, which has the same name as the SRV record, provides additional
    information about this instance in a structured form, using key/value pairs. The
    TXT record contains the information needed when the IP address and port number
    (contained in the SRV record) for a service aren’t sufficient to identify it.
    For example, in the case of the old Unix LPR protocol, the TXT record specifies
    the queue name.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: TXT记录与SRV记录具有相同的名称，提供了关于该实例的额外信息，采用键/值对的结构形式。当服务的IP地址和端口号（包含在SRV记录中）不足以识别该服务时，TXT记录就会提供所需的信息。例如，在旧的Unix
    LPR协议中，TXT记录指定了队列名称。
- en: Conducting Reconnaissance with mDNS and DNS-SD
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用mDNS和DNS-SD进行侦察
- en: You can learn a lot about the local network by simply sending mDNS requests
    and capturing multicast mDNS traffic. For example, you could discover available
    services, query specific instances of a service, enumerate domains, and identify
    a host. For host identification specifically, the `_workstation` special service
    must be enabled on the system you’re trying to identify.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地发送mDNS请求并捕获多播mDNS流量，你可以了解很多有关本地网络的信息。例如，你可以发现可用的服务，查询某个服务的特定实例，列举域名，并识别主机。对于主机识别，必须在你试图识别的系统上启用`_workstation`特殊服务。
- en: 'We’ll perform reconnaissance using a tool called Pholus by Antonios Atlasis.
    Download it from [https://github.com/aatlasis/Pholus/](https://github.com/aatlasis/Pholus/).
    Note that Pholus is written in Python 2, which is no longer officially supported.
    You might have to manually download Python2 pip, like we did with the Umap installation
    in “Getting and Using Umap” on page 128\. Then you’ll need to install Scapy using
    the Python2 version of pip:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Antonios Atlasis开发的工具Pholus进行侦察。你可以从[https://github.com/aatlasis/Pholus/](https://github.com/aatlasis/Pholus/)下载。请注意，Pholus是用Python
    2编写的，而Python 2已不再得到官方支持。你可能需要像我们在《获取和使用Umap》一章中介绍的Umap安装那样，手动下载Python2的pip。然后，你需要使用Python2版本的pip安装Scapy：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Pholus will send mDNS requests (`-rq`) on the local network and capture multicast
    mDNS traffic (for `-stimeout` 10 seconds) to identify a lot of interesting information:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Pholus将发送mDNS请求（`-rq`）到本地网络并捕获多播mDNS流量（设置`-stimeout`为10秒），以识别大量有趣的信息：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Figure 6-5](#figure6-5) shows the Wireshark dump from the Pholus query. Notice
    that the replies are sent back to the multicast address on UDP port 5353\. Because
    anyone can receive the multicast messages, an attacker can easily send the mDNS
    query from a spoofed IP address and still hear the replies on the local network.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](#figure6-5)显示了Pholus查询的Wireshark数据包捕获。请注意，回复是发送回UDP端口5353的多播地址。因为任何人都可以接收多播消息，所以攻击者可以轻松地从伪造的IP地址发送mDNS查询，并仍然能在本地网络上接收到回复。'
- en: Learning more about what services are exposed on the network is one of the first
    steps in any security test. Using this approach, you can find the services with
    potential vulnerabilities and then exploit them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 了解网络上暴露的服务是任何安全测试的第一步。通过这种方法，你可以找到具有潜在漏洞的服务，并进行利用。
- en: Abusing the mDNS Probing Phase
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滥用mDNS探测阶段
- en: In this section, we’ll exploit the mDNS Probing phase. In this phase, which
    occurs whenever an mDNS responder starts up or changes its connectivity, the responder
    asks the local network if there are any resource records with the same name as
    the one it’s planning to announce. To do this, it sends a query of type `"ANY"
    (255)`, as shown in [Figure 6-6](#figure6-6).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用mDNS探测阶段。在此阶段，每当mDNS响应器启动或更改其连接状态时，响应器会向本地网络询问是否有与它计划公告的名称相同的资源记录。为此，它会发送类型为`"ANY"
    (255)`的查询，如[图6-6](#figure6-6)所示。
- en: '![f06005](Images/f06005.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![f06005](Images/f06005.png)'
- en: 'Figure 6-5: Pholus sending mDNS requests and receiving replies on the multicast
    address'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：Pholus发送mDNS请求并在多播地址上接收回复
- en: If the answer contains the record in question, the probing host should choose
    a new name. If 15 conflicts take place within 10 seconds, the host must then wait
    at least five seconds before any additional attempt. Additionally, if one minute
    passes during which the host can’t find an unused name, it reports an error to
    the user.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案包含相关记录，探测主机应选择一个新名称。如果在10秒内发生15次冲突，主机必须至少等待五秒钟才能进行下一次尝试。此外，如果一分钟内主机找不到未使用的名称，它将向用户报告错误。
- en: '![f06006](Images/f06006.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![f06006](Images/f06006.png)'
- en: 'Figure 6-6: An example of an mDNS `"ANY"` query for `"test._ipps._tcp.local"`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：一个关于`"test._ipps._tcp.local"`的mDNS `"ANY"`查询示例
- en: 'The Probing phase lends itself to the following attack: an adversary can monitor
    mDNS traffic for a probing host and then continuously send responses containing
    the record in question, constantly forcing the host to change its name until the
    host quits. This forces a configuration change (for example, that the probing
    host has to select a new name for the service it provides) and, potentially, a
    denial of service attack, if the host is unable to access the resource it’s looking
    for.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 探测阶段为以下攻击提供了便利：攻击者可以监控 mDNS 流量中的探测主机，然后持续发送包含相关记录的响应，迫使主机不断更改其名称，直到主机停止。这强制执行配置更改（例如，探测主机必须为其提供的服务选择一个新名称），并且如果主机无法访问其正在寻找的资源，还可能导致拒绝服务攻击。
- en: 'For a quick demonstration of this attack, use Pholus with the argument `-afre`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速演示此攻击，请使用 Pholus 并带上参数 `-afre`：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Replace the `eth0` argument with your preferred network interface. The `-afre`
    argument makes Pholus send fake mDNS replies for `-stimeout` seconds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `eth0` 参数替换为你首选的网络接口。`-afre` 参数使 Pholus 在 `-stimeout` 秒内发送伪造的 mDNS 回复。
- en: 'This output shows Pholus blocking a new Ubuntu host on the network:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出显示 Pholus 在网络上阻止了一个新的 Ubuntu 主机：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When the Ubuntu host booted up, its mDNS responder tried to query for the local
    name `ubuntu.local`. Because Pholus continuously sent fake replies indicating
    that the attacker owned that name, the Ubuntu host kept iterating over new potential
    names, like `ubuntu-2.local`, `ubuntu-3.local,` and so on without ever being able
    to register. Notice that the host reached up to the naming `ubuntu-133.local`
    without success.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ubuntu 主机启动时，其 mDNS 响应程序尝试查询本地名称 `ubuntu.local`。由于 Pholus 不断发送伪造的回复，表示攻击者拥有该名称，Ubuntu
    主机不断迭代新的潜在名称，如 `ubuntu-2.local`、`ubuntu-3.local` 等，最终都无法注册。注意，主机尝试到 `ubuntu-133.local`
    时依然没有成功。
- en: mDNS and DNS-SD Man-in-the-Middle Attacks
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mDNS 和 DNS-SD 中间人攻击
- en: 'Now let’s try a more advanced attack with a bigger impact: mDNS poisoning attackers
    on the local network place themselves in a privileged, man-in-the-middle position
    between a client and some service by exploiting the lack of authentication in
    mDNS. This allows them to capture and modify potentially sensitive data transmitted
    over the network or simply deny service.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个更具影响力的高级攻击：mDNS 欺骗攻击者通过利用 mDNS 中缺乏身份验证的漏洞，将自己置于客户端和某个服务之间的特权中间人位置。这使他们能够捕获和修改通过网络传输的潜在敏感数据，或干脆拒绝服务。
- en: In this section, we’ll build an mDNS poisoner in Python that pretends to be
    a network printer to capture documents intended for the real printer. Then we’ll
    test the attack in a virtual environment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Python 构建一个 mDNS 欺骗工具，伪装成网络打印机，以捕获本应发送到真实打印机的文档。然后，我们将在虚拟环境中测试该攻击。
- en: Setting Up the Victim Server
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置受害者服务器
- en: 'We’ll start by setting up the victim machine to run an emulated printer using
    *ippserver*. Ippserver is a simple Internet Printing Protocol (IPP) server that
    can act as a very basic print server. We used Ubuntu 18.04.2 LTS (IP address:
    192.168.10.219) in VMware, but the exact specifics of the operating system shouldn’t
    matter as long as you can run a current version of ippserver.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置受害者机器，使用 *ippserver* 模拟一个打印机。Ippserver 是一个简单的互联网打印协议（IPP）服务器，可以充当一个非常基本的打印服务器。我们使用了
    Ubuntu 18.04.2 LTS（IP 地址：192.168.10.219）在 VMware 上，但操作系统的具体细节不重要，只要你能运行当前版本的 ippserver。
- en: 'After installing the operating system, run the print server by entering the
    following command in a terminal:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 安装操作系统后，在终端中输入以下命令启动打印服务器：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command invokes the ippserver with the default configuration settings.
    It should listen on TCP port 8000, announce a service named `test`, and enable
    verbose output. If you have Wireshark open when you start the server, you should
    notice that the server performs the probing phase by sending an mDNS query on
    the local multicast address 224.0.0.251, asking if anyone already has any print
    services with the name `test` ([Figure 6-7](#figure6-7)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令调用默认配置设置下的 ippserver。它应该监听 TCP 8000 端口，宣布一个名为 `test` 的服务，并启用详细输出。如果你在启动服务器时打开了
    Wireshark，你应该注意到服务器通过向本地多播地址 224.0.0.251 发送 mDNS 查询来执行探测阶段，询问是否已经有人拥有名为 `test`
    的打印服务（[图 6-7](#figure6-7)）。
- en: '![f06007](Images/f06007.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![f06007](Images/f06007.png)'
- en: 'Figure 6-7: Ippserver sends an mDNS query asking if the resource records related
    to the printer service named `test` are already in use.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：Ippserver 发送 mDNS 查询，询问是否已经使用了与名为 `test` 的打印机服务相关的资源记录。
- en: This query also contains some *proposed* records in the Authority Section (you
    can see these under `Authoritative nameservers` in [Figure 6-7](#figure6-7)).
    Because this isn’t an mDNS reply, those records don’t count as official responses;
    instead, they’re used for tiebreaking simultaneous probes, a situation that doesn’t
    concern us now.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询还包含了一些在权限部分的*提议*记录（你可以在[图6-7](#figure6-7)中看到这些记录，位于`Authoritative nameservers`下）。因为这不是一个mDNS回复，所以这些记录不算作官方响应；它们用于在同时探测的情况下作为决胜记录，这种情况目前不需要我们关注。
- en: The server will then wait a couple of seconds, and if no one else on the network
    replies, it will move on to the Announcing phase. In this phase, ippserver sends
    an unsolicited mDNS response containing, in the Answer Section, all of its newly
    registered resource records ([Figure 6-8](#figure6-8)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接下来会等待几秒钟，如果网络上没有其他设备回复，它将进入公告阶段。在这个阶段，ippserver会发送一个非请求的mDNS响应，其中的答案部分包含了所有它新注册的资源记录（见[图6-8](#figure6-8)）。
- en: '![f06008](Images/f06008.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![f06008](Images/f06008.png)'
- en: 'Figure 6-8: During the Announcing phase, ippserver sends an unsolicited mDNS
    response containing the newly registered records.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8：在公告阶段，ippserver发送了一个包含新注册记录的非请求mDNS响应。
- en: This response includes a set of PTR, SRV, and TXT records for each service,
    as explained in “How DNS-SD Works” on page 132\. It also includes A records (for
    IPv4) and AAAA records (for IPv6), which are used to resolve the domain name with
    IP addresses. The A record for `ubuntu.local` in this case will contain the IP
    address 192.168.10.219.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该响应包含了一组针对每个服务的PTR、SRV和TXT记录，如《DNS-SD工作原理》一书第132页所解释的内容。它还包括A记录（针对IPv4）和AAAA记录（针对IPv6），这些记录用于通过IP地址解析域名。在这种情况下，`ubuntu.local`的A记录将包含IP地址192.168.10.219。
- en: Setting Up the Victim Client
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置受害客户端
- en: 'For the victim requesting the printing service, you can use any device running
    an operating system that supports mDNS and DNS-SD. In this example, we’ll use
    a MacBook Pro running macOS High Sierra. Apple’s zero-configuration networking
    implementation is called Bonjour, and it’s based on mDNS. Bonjour should be enabled
    by default in macOS. If it isn’t, you can enable it by entering the following
    command in the Terminal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于请求打印服务的受害者，你可以使用任何运行支持mDNS和DNS-SD的操作系统的设备。在这个例子中，我们将使用一台运行macOS High Sierra的MacBook
    Pro。苹果的零配置网络实现被称为Bonjour，它基于mDNS。Bonjour应该在macOS中默认启用。如果没有，你可以通过在终端中输入以下命令来启用它：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Figure 6-9](#figure6-9) shows how `mDNSResponder` (Bonjour’s main engine)
    automatically finds the legitimate Ubuntu print server when we click **System
    Preferences** ▶ **Printers & Scanners** and click the **+** button to add a new
    printer.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-9](#figure6-9)展示了当我们点击**系统偏好设置** ▶ **打印机与扫描仪**并点击**+**按钮添加新打印机时，`mDNSResponder`（Bonjour的主引擎）是如何自动找到合法的Ubuntu打印服务器的。'
- en: To make the attack scenario more realistic, we assume that the MacBook already
    has a preconfigured network printer named `test`. One of the most important aspects
    of automatic service discovery is that it doesn’t matterif our system has already
    discovered the service in the past! This increases flexibility (although it sacrifices
    security). A client needs to be able to communicate with the service, even if
    the hostname and IP address have changed; so whenever the macOS client needs to
    print a document, it will send a new mDNS query asking where the `test` service
    is, even if that service has the same hostname and IP address as it did the last
    time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让攻击场景更具现实感，我们假设MacBook已经预配置了一个名为`test`的网络打印机。自动服务发现的一个最重要方面是，无论我们的系统是否曾经发现过该服务，都会继续工作！这增加了灵活性（尽管牺牲了安全性）。即使主机名和IP地址发生了变化，客户端仍然需要能够与服务通信；因此，每当macOS客户端需要打印文档时，它都会发送一个新的mDNS查询，询问`test`服务的位置，即使该服务的主机名和IP地址与上次一样。
- en: '![f06009](Images/f06009.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![f06009](Images/f06009.png)'
- en: 'Figure 6-9: The legitimate printer automatically discovered by macOS’s built-in
    Bonjour service'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-9：macOS内置的Bonjour服务自动发现的合法打印机
- en: How Typical Client and Server Interactions Work
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见客户端与服务器交互的工作原理
- en: Now let’s look at how the macOS client requests the printer service when things
    are working correctly. As shown in [Figure 6-10](#figure6-10), the client’s mDNS
    query about the `test` service will ask about the SRV and TXT records belonging
    to `test._ipps._tcp.local`. It also asks for similar alternative services, such
    as `test._printer._tcp.local` and `test._ipp._tcp.local`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看macOS客户端在一切正常时如何请求打印机服务。如[图6-10](#figure6-10)所示，客户端对`test`服务的mDNS查询会请求`test._ipps._tcp.local`的SRV和TXT记录。它还会请求类似的替代服务，例如`test._printer._tcp.local`和`test._ipp._tcp.local`。
- en: '![f06010](Images/f06010.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![f06010](Images/f06010.png)'
- en: 'Figure 6-10: The mDNS query the client will initially send to discover local
    network printers asks again about the `test` ipps service, even though it might
    have used it in the past.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10：客户端最初发送的mDNS查询，用于发现本地网络打印机，再次询问`test` ipps服务，尽管它可能曾经使用过该服务。
- en: The Ubuntu system will then reply as it did in the Announcing phase. It will
    send responses that contain PTR, SRV, and TXT records for all the requested services
    that it’s supposed to have authority over (for example, `test._ipps._tcp.local`)
    and A records (as well as AAAA records, if the host has IPv6 enabled). The TXT
    record ([Figure 6-11](#figure6-11)) is particularly important in this case, because
    it contains the exact URL (`adminurl`) for the printer jobs to be posted.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Ubuntu系统将像在宣布阶段一样进行回复。它将发送包含PTR、SRV和TXT记录的响应，这些记录是它应该拥有权限的所有请求服务（例如，`test._ipps._tcp.local`），并且还会包含A记录（如果主机启用了IPv6，还会包含AAAA记录）。在这种情况下，TXT记录（[图6-11](#figure6-11)）尤其重要，因为它包含了提交打印作业的确切URL（`adminurl`）。
- en: '![f06011](Images/f06011.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![f06011](Images/f06011.png)'
- en: 'Figure 6-11: Part of the TXT record, which is included in the ippserver’s mDNS
    response Answer section. The `adminurl` has the exact location of the print queue.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-11：TXT记录的一部分，这部分包含在ippserver的mDNS响应答复部分。`adminurl`包含了打印队列的确切位置。
- en: 'Once the macOS client has this information, it now knows everything it needs
    to send its print job to the Ubuntu ippserver:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦macOS客户端获得了这些信息，它就知道了所有需要的信息来将打印作业发送到Ubuntu的ippserver：
- en: From the PTR record, it knows that there is an `_ipps._tcp.local` with a service
    named `test`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从PTR记录中，可以知道有一个名为`test`的服务，位于`_ipps._tcp.local`。
- en: From the SRV record, it knows that this `test._ipps._tcp.local` service is hosted
    on `ubuntu.local` on TCP port 8000.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从SRV记录中，可以得知该`test._ipps._tcp.local`服务托管在`ubuntu.local`上，TCP端口为8000。
- en: From the A record, it knows that `ubuntu.local` resolves to 192.168.10.219.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从A记录中可以得知，`ubuntu.local`解析为192.168.10.219。
- en: From the TXT record, it knows that the URL to post the print jobs is [https://ubuntu.8000/ipp/print](https://ubuntu.8000/ipp/print).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从TXT记录中，可以得知提交打印作业的URL是[https://ubuntu.8000/ipp/print](https://ubuntu.8000/ipp/print)。
- en: 'The macOS client will then initiate an HTTPS session with ippserver on port
    8000 and transmit the document to be printed:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，macOS客户端将启动与ippserver在8000端口上的HTTPS会话，并传输要打印的文档：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should see output like this from the ippserver.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到来自ippserver的类似输出。
- en: Creating the mDNS Poisoner
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建mDNS中毒器
- en: The mDNS poisoner we’ll write using Python listens for multicast mDNS traffic
    on UDP port 5353 until it finds a client trying to connect to the printer, and
    then sends it replies. [Figure 6-12](#figure6-12) illustrates the steps involved.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用Python编写的mDNS中毒器监听UDP端口5353上的多播mDNS流量，直到它找到一个客户端尝试连接到打印机，然后发送回复。[图6-12](#figure6-12)展示了相关的步骤。
- en: '![f06012](Images/f06012.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![f06012](Images/f06012.png)'
- en: 'Figure 6-12: mDNS poisoning attack steps'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-12：mDNS中毒攻击步骤
- en: First, the attacker listens for multicast mDNS traffic on UDP port 5353\. When
    the macOS client rediscovers the `test` network printer and sends an mDNS query,
    the attacker continuously sends replies to the poison client’s cache. If the attacker
    wins the race against the legitimate printer, the attacker becomes a man in the
    middle, fielding traffic from the client. The client sends a document to the attacker,
    which the attacker can then forward to the printer to avoid detection. If the
    attacker doesn’t forward the document to the printer, the user might get suspicious
    when it isn’t printed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，攻击者监听UDP端口5353上的多播mDNS流量。当macOS客户端重新发现`test`网络打印机并发送mDNS查询时，攻击者会持续向中毒客户端的缓存发送回复。如果攻击者在合法打印机之前赢得了竞赛，攻击者就成为了中间人，处理来自客户端的流量。客户端将文档发送给攻击者，攻击者然后可以将文档转发给打印机，以避免被发现。如果攻击者没有将文档转发给打印机，用户可能会怀疑文档未被打印。
- en: We’ll start by creating a skeleton file ([Listing 6-2](#listing6-2)) and then
    implementing simple network server functionality for listening on the multicast
    mDNS address. Note that the script is written in Python 3.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个框架文件（[Listing 6-2](#listing6-2)）开始，然后实现一个简单的网络服务器功能，用于监听多播mDNS地址。请注意，该脚本是用Python
    3编写的。
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 6-2: The skeleton file for the mDNS poisoner'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-2：mDNS污染器的框架文件
- en: We start with the imports for the Python modules we’ll need. The `socketserver`
    framework simplifies the task of writing network servers. For parsing and crafting
    mDNS packets, we import *dnslib*, a simple library to encode and decode DNS wire-format
    packets. We then define a global variable `MADDR` that holds the mDNS multicast
    address and default port (5353).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从导入我们需要的Python模块开始。`socketserver`框架简化了编写网络服务器的任务。为了解析和构造mDNS数据包，我们导入了*dnslib*，这是一个简单的库，用于编码和解码DNS数据包。然后，我们定义了一个全局变量`MADDR`，它保存了mDNS的多播地址和默认端口（5353）。
- en: We create the `UDP_server` 1``using the `ThreadingMixIn` class, which implements
    parallelism using threads. The server’s constructor will call the `server_bind`
    function to bind the socket to the desired address. We enable `allow_reuse_address`so
    we can reuse the bound IP addressand the `SO_REUSEADDR` socket option, which allows
    the socket to forcibly bind to the same port when we restart the program. We then
    have to join the multicast group (224.0.0.251) with `IP_ADD_MEMBERSHIP`2.``
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`UDP_server`，使用`ThreadingMixIn`类，该类通过线程实现并行性。服务器的构造函数将调用`server_bind`函数，将套接字绑定到所需的地址。我们启用了`allow_reuse_address`，这样就可以重用绑定的IP地址，并且启用了`SO_REUSEADDR`套接字选项，这允许套接字在我们重启程序时强制绑定到相同的端口。然后，我们必须使用`IP_ADD_MEMBERSHIP`加入多播组（224.0.0.251）。
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
