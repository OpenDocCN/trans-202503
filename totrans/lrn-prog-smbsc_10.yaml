- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**SOLVING PROBLEMS WITH SUBROUTINES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用子程序解决问题**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: The programs you’ve written so far are short and easy to understand. But as
    you start dealing with more complex problems, you’ll need to write longer programs.
    Understanding long programs can be a challenge, because you’ll need to keep track
    of many different parts of the program. In this chapter, you’ll learn how to organize
    your programs into smaller pieces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你写的程序都很简短，容易理解。但随着你开始处理更复杂的问题，你将需要编写更长的程序。理解长程序可能会是一个挑战，因为你需要跟踪程序中的许多不同部分。在本章中，你将学习如何将程序组织成更小的部分。
- en: An approach known as *structured programming* started in the mid-1960s to simplify
    the process of writing, understanding, and maintaining computer programs. Instead
    of writing a single, large program, you divide your program into smaller pieces.
    Each piece solves one part of the overall task, and *subroutines* implement these
    smaller pieces as part of a long program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一种名为*结构化编程*的方法始于1960年代中期，目的是简化编写、理解和维护计算机程序的过程。与其编写一个单一的、大型程序，不如将程序分成更小的部分。每个部分解决整个任务的一部分，*子程序*实现这些较小的部分，作为长程序的一部分。
- en: Subroutines are basic building blocks for creating large programs (see [Figure
    10-1](ch10.html#ch10fig1)). In this chapter, you’ll delve into the wild world
    of subroutines, learn how to move data in and out of them, and use them to build
    large programs and fun games!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序是创建大型程序的基本构建块（见[图10-1](ch10.html#ch10fig1)）。在本章中，你将深入了解子程序的奇妙世界，学习如何在它们之间传递数据，并利用它们来构建大型程序和有趣的游戏！
- en: '![image](graphics/f10-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-01.jpg)'
- en: '*Figure 10-1: Subroutines are the building blocks of larger programs*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：子程序是大型程序的构建块*'
- en: '**Why Use Subroutines?**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么使用子程序？**'
- en: 'Let’s say you run a construction company. Your job is to coordinate the work
    among your contractors and build houses. As a manager, you don’t have to know
    all the nitty-gritty details of building a home: the plumber handles the plumbing,
    the roofer shingles the roof, and the electrician runs all the wires. Each contractor
    knows their job and is always ready to work when they receive your call.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你经营一家建筑公司。你的工作是协调承包商的工作并建造房屋。作为经理，你不需要了解建房的所有细节：水管工负责水管工作，屋顶工铺设屋顶瓦片，电工负责布线。每个承包商都知道自己的工作，并且在接到你的电话时，随时准备工作。
- en: That’s very similar to how subroutines work! Each subroutine has its own name,
    like how the plumber’s name is Mario. Each subroutine does something different,
    just like how the plumber and the roofer have different jobs, but all are needed
    to build the house. As the programmer, you’re the manager, and your job is to
    solve problems as you build your program. You call your contractors (that is,
    your subroutines) and let them know when you need them to work (see [Figure 10-2](ch10.html#ch10fig2)).
    You start writing the program by typing statements in the editor. When you need
    to perform a job that a subroutine handles, you just call that subroutine and
    wait. When the subroutine completes its task, you move on to the next step in
    your program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常类似于子程序的工作方式！每个子程序都有自己的名字，就像水管工的名字是马里奥一样。每个子程序执行不同的任务，就像水管工和屋顶工有不同的工作，但所有人都在建造房屋时不可或缺。作为程序员，你是经理，你的工作是在构建程序时解决问题。你调用你的承包商（也就是你的子程序），并告诉他们你何时需要他们工作（见[图10-2](ch10.html#ch10fig2)）。你通过在编辑器中键入语句来开始编写程序。当你需要执行一个子程序处理的任务时，只需调用该子程序并等待。当子程序完成任务后，你就可以继续执行程序中的下一步。
- en: '![image](graphics/f10-02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-02.jpg)'
- en: '*Figure 10-2: The boss (main program) calling the Bob subroutine*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：老板（主程序）调用Bob子程序*'
- en: There’s nothing new about this call-and-wait strategy; you’ve been doing it
    since [Chapter 1](ch01.html#ch01). When you call an object’s method, you’re actually
    giving the work to that object in the Small Basic library. Subroutines are like
    methods, but *you* have to write all the statements in the subroutines. Subroutines
    help you organize your thinking process and make it easier to fix errors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“呼叫与等待”的策略没有什么新鲜的，你从[第1章](ch01.html#ch01)开始就已经在使用它了。当你调用一个对象的方法时，你实际上是在把工作交给那个在Small
    Basic库中的对象。子程序就像方法，但*你*必须编写子程序中的所有语句。子程序帮助你组织思维过程，并使修复错误变得更加容易。
- en: '**Writing Subroutines**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写子程序**'
- en: 'Let’s use a fun example to learn how to write a subroutine: in his travels,
    Gulliver had dinner with the king and queen of Lilliput (the land of tiny people).
    During dinner, the king explained that he was 8.5 glum-gluffs tall. Gulliver later
    learned that 1 glum-gluff is about 0.75 inches. To find out how the sizes of items
    in Lilliput compare to sizes in our land, write the program in [Listing 10-1](ch10.html#ch10ex1),
    which converts glum-gluffs to inches.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个有趣的例子来学习如何编写子程序：在他的旅行中，格列佛曾与小人国的国王和王后共进晚餐。在晚餐时，国王解释说自己有8.5个glum-gluffs高。格列佛后来得知，1个glum-gluff大约等于0.75英寸。为了了解小人国的物品大小与我们这边的物品大小如何比较，编写[清单
    10-1](ch10.html#ch10ex1)中的程序，将glum-gluffs转换为英寸。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Converting measurements*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：转换度量单位*'
- en: This program looks just like the ones you’re already used to! You prompt the
    user to enter the glum-gluff measurement (line 2), read the input into the `glumGluffs`
    variable (line 3), convert the input number to inches (line 5), round the answer
    to two decimal places (line 6), and then display the result (line 7). Run the
    program to figure out how tall the king is in inches; remember that he’s 8.5 glum-gluffs
    tall.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序看起来和你已经习惯的那些程序一样！你提示用户输入glum-gluff的度量值（第2行），将输入值读入`glumGluffs`变量（第3行），将输入的数字转换为英寸（第5行），将结果四舍五入到小数点后两位（第6行），然后显示结果（第7行）。运行程序来计算国王的身高是多少英寸；记住他是8.5个glum-gluffs高。
- en: Next, let’s rewrite this program and put the conversion statements (lines 5–6)
    in a subroutine named `GlumGluffToInch()`. Enter the code in [Listing 10-2](ch10.html#ch10ex2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重写这个程序，并将转换语句（第5–6行）放入一个名为`GlumGluffToInch()`的子程序中。请在[清单 10-2](ch10.html#ch10ex2)中输入代码。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: Calling a subroutine*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：调用子程序*'
- en: This code does the same thing as the code in [Listing 10-1](ch10.html#ch10ex1),
    but it uses a subroutine. A subroutine is a collection of statements that do a
    specific job (just like hiring Mario the plumber to build a fancy toilet). In
    this case, your subroutine converts glum-gluffs to inches. The statements that
    make up the subroutine are sandwiched between the `Sub` and `EndSub` keywords
    (lines 11–14). The subroutine’s name comes after the `Sub` keyword (line 11).
    When you define the subroutine, don’t put parentheses after its name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的功能与[清单 10-1](ch10.html#ch10ex1)中的代码相同，但它使用了一个子程序。子程序是一组完成特定任务的语句（就像雇佣马里奥水管工来建造一个豪华厕所）。在这个例子中，你的子程序将glum-gluffs转换为英寸。构成子程序的语句被`Sub`和`EndSub`关键字包围（第11–14行）。子程序的名称跟在`Sub`关键字后面（第11行）。定义子程序时，不要在其名称后加上圆括号。
- en: But just because you define a subroutine doesn’t mean your program will run
    it. To run a subroutine, you need to *call* (or *invoke*) it! To call a subroutine,
    you type its name followed by parentheses (line 5). The statement on line 5 means
    “run the subroutine named `GlumGluffToInch()`, and then return to the line that
    comes after this subroutine call” (which is line 6 in this example). It’s like
    taking a break from cleaning your room to go watch some TV and then coming back
    to pick up where you left off. [Figure 10-3](ch10.html#ch10fig3) shows how a subroutine
    works in a program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅定义了一个子程序，并不意味着你的程序会自动执行它。要运行一个子程序，你需要*调用*（或*激活*）它！要调用子程序，你需要输入子程序的名称，后面跟上圆括号（第5行）。第5行的语句意味着“运行名为`GlumGluffToInch()`的子程序，然后返回到子程序调用后的下一行”（在这个例子中是第6行）。这就像你在打扫房间时休息去看电视，然后回来继续原来的工作。[图
    10-3](ch10.html#ch10fig3)展示了子程序在程序中的工作原理。
- en: '![image](graphics/f10-03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-03.jpg)'
- en: '*Figure 10-3: Showing how* GlumGuff2.sb *calls the* `GlumGluffToInch()` *subroutine*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：展示* GlumGuff2.sb *如何调用* `GlumGluffToInch()` *子程序*'
- en: 'Here is one example of output from this program:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的输出示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A subroutine can access all the variables in the main program, and the main
    program can access all the variables in a subroutine. The variable `glumGluffs`
    was created and assigned a value in the main program (line 3), but it was used
    by the subroutine to know how many glum-gluffs it needs to convert (line 12).
    And the variable `inches` was created inside the subroutine (line 12), but the
    main program reads it and displays its value to the user (line 6).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序可以访问主程序中的所有变量，主程序也可以访问子程序中的所有变量。变量`glumGluffs`是在主程序中创建并赋值的（第3行），但是它被子程序用来知道需要转换多少个glum-gluffs（第12行）。而变量`inches`是在子程序内部创建的（第12行），但主程序读取它并将其值显示给用户（第6行）。
- en: 'Here are some good reasons to put the unit conversion code into a subroutine:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将单位转换代码放入子程序的一些好理由：
- en: You isolate (or separate) the unit conversion details from the main program.
    The main program now doesn’t have to worry about how the conversion is done. This
    makes your code easier to read and maintain.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将单位转换的细节从主程序中隔离（或分离）出来。现在主程序不必担心转换是如何进行的。这使得你的代码更易于阅读和维护。
- en: If errors occur, you know where to look, which makes debugging much easier to
    do.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现错误，你知道在哪里查找，这使得调试变得更容易。
- en: You don’t have to write the same code over and over again! Without using subroutines,
    if a program needs to run the same set of statements more than once, you have
    to duplicate these statements in your code. But if you put those statements in
    a subroutine, you can call it from any point in your program (*code reuse*). You’ll
    practice this in the next section.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不必一遍遍地写相同的代码！如果不使用子程序，当程序需要多次执行相同的语句时，你必须在代码中重复这些语句。但如果将这些语句放入子程序中，你可以在程序的任何位置调用它（*代码复用*）。你将在下一节中练习这个技巧。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, we’ll start the name of a subroutine with a capital letter.
    We’ll also write all the subroutines at the bottom of every main program. We recommend
    you follow the same practice in your own programs: it’ll help keep you organized!*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，我们会将子程序的名称以大写字母开头。我们还会将所有子程序写在每个主程序的底部。我们建议你在自己的程序中也采用这种做法：它会帮助你保持条理！*'
- en: '**TRY IT OUT 10-1**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试看 10-1**'
- en: When Gulliver asked what a glum-gluff was, he was told it was 1/20 of a mumgluff.
    Write a subroutine named `MumGluffToFoot()` that converts mum-gluffs to feet.
    Write a program that prompts the user for a mum-gluff measurement, calls the subroutine,
    and then displays the result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当格列佛问什么是glum-gluff时，他被告知它是mumgluff的1/20。编写一个名为`MumGluffToFoot()`的子程序，将mum-gluff转换为英尺。编写一个程序，提示用户输入一个mum-gluff的测量值，调用子程序，然后显示结果。
- en: '**Subroutine Input and Output**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**子程序的输入和输出**'
- en: You can think of a subroutine as a small program that provides a service to
    the main program. When the main program needs that service, it prepares the inputs
    that the subroutine needs and then calls the subroutine to start its job. The
    subroutine runs, saves its output(s) in some variables, and returns to the main
    program. When the main program continues, it looks at any new information from
    the subroutine and then uses that data to decide what to do next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将子程序视为一个为主程序提供服务的小程序。当主程序需要该服务时，它准备好子程序所需的输入，然后调用子程序开始工作。子程序运行并将其输出保存在某些变量中，然后返回主程序。当主程序继续时，它查看来自子程序的任何新信息，并根据这些数据决定接下来该做什么。
- en: Small Basic doesn’t let you pass arguments to subroutines between parentheses
    (like you do with an object’s method, such as the `DrawLine()` method of `GraphicsWindow`).
    And it doesn’t define subroutines that directly return a value (like the `Math.Round()`
    method does). So you need to use variables to pass data between the main program
    and your subroutines. Let’s see how that works.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Small Basic不允许你像在对象的方法中那样通过括号向子程序传递参数（例如`GraphicsWindow`的`DrawLine()`方法）。它也没有定义直接返回值的子程序（就像`Math.Round()`方法一样）。所以你需要使用变量在主程序和子程序之间传递数据。让我们看看这是如何工作的。
- en: Great news! You inherited some land ([Figure 10-4](ch10.html#ch10fig4)) from
    Uncle Moneybags. But you need to know the area of the land before you can sell
    it. The figure also shows Heron’s formula, which computes the area of a triangle
    given the lengths of its three sides. Don’t worry if you’re not familiar with
    this formula; you don’t need to fully understand something in order to use it
    (or most people wouldn’t be allowed to use the toilet).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！你继承了一块土地（[图10-4](ch10.html#ch10fig4)）来自钱袋叔叔。但是在你能卖掉这块土地之前，你需要知道这块土地的面积。图中还显示了海伦公式，它可以根据三角形的三条边长计算面积。如果你不熟悉这个公式也不用担心；你不需要完全理解某个东西才能使用它（否则大多数人都不能上厕所了）。
- en: '![image](graphics/f10-04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-04.jpg)'
- en: '*Figure 10-4: Calculating the area of the piece of land you inherited*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：计算你继承的土地面积*'
- en: Because the land is made up of two triangles, you can compute the area of these
    triangles and then add them together. Follow [Listing 10-3](ch10.html#ch10ex3)
    and note how we put the code for calculating the triangle’s area (Heron’s formula)
    in a subroutine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这块土地由两个三角形组成，你可以计算这两个三角形的面积，然后将它们相加。请参阅[清单10-3](ch10.html#ch10ex3)，注意我们如何将计算三角形面积的代码（海伦公式）放入子程序中。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: Calling a subroutine multiple times*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：多次调用子程序*'
- en: 'Here’s the output of this program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此程序的输出：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The main program sets the lengths of the three sides of the first triangle (lines
    3–5) and then calls the `TriangleArea()` subroutine (line 6). The subroutine (lines
    23–26) saves the computed area in a variable named `area`. After the subroutine
    call, the main program stores this first area in the `totalArea` variable (line
    7). Without this, the value stored in `area` will be lost the next time we call
    the `TriangleArea()` subroutine. Then the main program sets the values to compute
    the area of the second triangle (lines 10–12) and calls the subroutine again (line
    13). When the subroutine ends, the main program adds the new area to `totalArea`
    (line 14). The main program then rounds the answer (line 16) and displays it (line
    17).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序设置第一个三角形的三条边的长度（第3-5行），然后调用`TriangleArea()`子程序（第6行）。子程序（第23-26行）将计算出的面积保存在一个名为`area`的变量中。子程序调用之后，主程序将第一个面积存储在`totalArea`变量中（第7行）。如果没有这一步，下一次调用`TriangleArea()`子程序时，存储在`area`中的值会丢失。接着，主程序设置计算第二个三角形面积的值（第10-12行），并再次调用子程序（第13行）。当子程序结束时，主程序将新的面积加到`totalArea`中（第14行）。然后，主程序将结果四舍五入（第16行）并显示出来（第17行）。
- en: The `TriangleArea()` subroutine uses a temporary variable named `s` to store
    the *semiperimeter*, one-half of the perimeter of the current shape (line 24).
    Note how this variable is used to compute the area in line 25\. This variable
    isn’t intended to be used by the main program, which just cares about the `area`
    variable. But the main program knows about it (for example, it can display the
    variable). Because your subroutines can change variables that belong to the main
    program, be sure to name your variables carefully and clearly. For example, if
    the `s` variable seems confusing, rename it to `semiperimeter` so you’ll remember
    what it does.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`TriangleArea()`子程序使用一个名为`s`的临时变量来存储*半周长*，即当前形状周长的一半（第24行）。注意这个变量是如何在第25行用于计算面积的。这个变量并不是为了供主程序使用的，主程序只关心`area`变量。但是主程序知道它的存在（例如，它可以显示该变量）。由于你的子程序可能会改变属于主程序的变量，请确保你的变量命名清晰明确。例如，如果`s`变量容易混淆，可以将它重命名为`semiperimeter`，这样你就能记住它的作用。'
- en: '**TRY IT OUT 10-2**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试这个 10-2**'
- en: Uncle Moneybags left you another piece of land ([Figure 10-5](ch10.html#ch10fig5))!
    Update the program in [Listing 10-3](ch10.html#ch10ex3) to compute its area (all
    dimensions are in meters).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 钱袋叔叔又给你留了一块地（[图10-5](ch10.html#ch10fig5)）！更新[清单10-3](ch10.html#ch10ex3)中的程序来计算它的面积（所有尺寸单位为米）。
- en: '![image](graphics/f10-05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-05.jpg)'
- en: '*Figure 10-5: Your new piece of land*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-5：你的新土地*'
- en: '**Nesting Subroutines**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套子程序**'
- en: If your chore is to clean the house, you might get help by making a deal with
    your sister to clean the windows and asking your dog to clean the floor under
    the table. Similarly, a subroutine might call other subroutines to help it do
    part of a larger job. In [Figure 10-6](ch10.html#ch10fig6), the main program calls
    a subroutine, `SubA()`, which then calls another subroutine, `SubC()`. Subroutines
    called from other subroutines are *nested subroutines*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的任务是打扫房子，你可能会通过和你妹妹商量让她清洁窗户，并让你的狗打扫桌子下的地板来得到帮助。同样，一个子程序可能会调用其他子程序来帮助它完成更大的任务。在[图10-6](ch10.html#ch10fig6)中，主程序调用了一个子程序`SubA()`，然后`SubA()`又调用了另一个子程序`SubC()`。从其他子程序中调用的子程序被称为*嵌套子程序*。
- en: '![image](graphics/f10-06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-06.jpg)'
- en: '*Figure 10-6: Illustrating nested subroutines*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-6：展示嵌套子程序*'
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your program contains many subroutines, you can place these subroutines
    at the end of your program in any order you like. For example, it doesn’t matter
    if you put the code for* `SubA()` *before or after* `SubB()`*. What matters is
    the order in which you call these subroutines, not where you place them in your
    code!*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的程序包含许多子程序，你可以将这些子程序放在程序的末尾，按照你喜欢的顺序排列。例如，`SubA()`的代码放在`SubB()`之前或之后都没关系。重要的是你调用这些子程序的顺序，而不是它们在代码中的位置！*'
- en: To try out this concept, you’ll play Pepper Dare, an exciting game of chance,
    against the computer. When the game starts, the player is handed 10 imaginary
    cards face down. One of those cards has a jalapeño pepper on it; the rest are
    blank. The player picks a card and hopes for a blank one. If the player picks
    the card with the jalapeño, the player has to eat a hot pepper and the computer
    wins! If the player doesn’t get the pepper card, the computer takes a turn. The
    game ends when either the player or computer eats the pepper and runs for a drink
    of water. Enter the main program in [Listing 10-4](ch10.html#ch10ex4) into Small
    Basic. You’ll add the subroutines in a moment.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个概念，你将与计算机一起玩“辣椒敢挑战”，一款刺激的机会游戏。游戏开始时，玩家会拿到10张虚拟卡片，背面朝下。其中一张卡片上有一个哈瓦那辣椒，其他的都是空白的。玩家抽一张卡片，希望是空白卡片。如果玩家抽到带有辣椒的卡片，玩家必须吃下辣椒，计算机获胜！如果玩家没有抽到辣椒卡片，计算机会轮到自己。游戏在玩家或计算机吃到辣椒并急忙去喝水时结束。输入[清单
    10-4](ch10.html#ch10ex4)中的主程序到Small Basic。稍后你将添加子程序。
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-4: Setting up Pepper Dare*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：设置辣椒敢挑战*'
- en: The game starts by setting the `player` variable to 1 to give you the first
    turn (line 2). It then randomly picks 1 of the 10 cards to be the card that has
    the jalapeño pepper (line 3). Then it starts a loop (lines 5–17) to take turns.
    In each round, the game picks one card at random for the player (or the computer)
    by calling the `Pick()` subroutine (line 6). If the picked card has a pepper on
    it (line 7), the game displays the winner’s name (line 9), and the game ends because
    the program moves out of the `If` loop and jumps from line 10 to line 17, bypassing
    the `Goto` loop on line 16.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通过将`player`变量设置为1来开始，赋予你第一回合（第2行）。然后它随机选取10张卡片中的1张作为辣椒卡片（第3行）。接着它开始一个循环（第5–17行）来轮流进行。在每一轮中，游戏通过调用`Pick()`子程序（第6行）随机为玩家（或计算机）选一张卡片。如果选中的卡片上有辣椒（第7行），游戏会显示获胜者的名字（第9行），并结束游戏，因为程序会跳出`If`循环，从第10行跳到第17行，跳过第16行的`Goto`循环。
- en: 'Otherwise, it displays `The card is blank. You put it back in and shuffle the
    deck.` (lines 12–13) to indicate that the player (or the computer) picked a blank
    card. The game then switches to the next player (line 15) and goes back to start
    a new round (line 16). This is how the statement on line 15 works: if `player`
    is 1 (you, the user), then 3 – 1 is 2 (switching to the computer’s turn), and
    if `player` is 2 (the computer), then 3 – 2 is 1 (switching back to the user’s
    turn).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，程序会显示`卡片是空白的。你把它放回去并重新洗牌。`（第12–13行），表示玩家（或计算机）抽到了一张空白卡片。然后游戏会切换到下一个玩家（第15行）并开始新一轮（第16行）。第15行的语句是这样工作的：如果`player`是1（你，用户），则3
    - 1等于2（切换到计算机的回合）；如果`player`是2（计算机），则3 - 2等于1（切换回用户的回合）。
- en: Next, you’ll add the `Pick()` subroutine in [Listing 10-5](ch10.html#ch10ex5)
    to the bottom of your program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将把[清单 10-5](ch10.html#ch10ex5)中的`Pick()`子程序添加到程序的底部。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-5: The* `Pick()` *subroutine for Pepper Dare*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5：辣椒敢挑战的* `Pick()` *子程序*'
- en: The subroutine starts by checking the current player (either you or the computer)
    and then sets the `name` variable (lines 3 and 6). Next, it asks you to press
    any key to have you or the computer pick a card (lines 10–12). Then it randomly
    picks a card (line 14) and calls the nested `Animate()` subroutine to animate
    an arrow in the text window.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序首先检查当前的玩家（你或计算机），然后设置`name`变量（第3行和第6行）。接下来，它要求你按任意键让你或计算机抽一张卡片（第10–12行）。然后它随机抽取一张卡片（第14行），并调用嵌套的`Animate()`子程序在文本窗口中显示一个箭头的动画。
- en: Now add the `Animate()` subroutine in [Listing 10-6](ch10.html#ch10ex6) to the
    bottom of your program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将[清单 10-6](ch10.html#ch10ex6)中的`Animate()`子程序添加到程序的底部。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-6: Subroutine to animate the delay*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：动画延迟的子程序*'
- en: 'Don’t worry about the `For` loop here. You’ll learn about it in depth in [Chapter
    13](ch13.html#ch13). For now, this code just slowly displays a variable-length
    arrow. Here’s a sample run of the completed Pepper Dare program:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心这里的`For`循环。你将在[第13章](ch13.html#ch13)中深入学习它。目前，这段代码只是缓慢地显示一个可变长度的箭头。以下是完成的辣椒敢挑战程序的示例运行：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Not only can a subroutine call other subroutines, but it can also call itself
    (this is called* recursion*)! See the online resources to learn more.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*子程序不仅可以调用其他子程序，还可以调用自身（这称为*递归*）！请查看在线资源了解更多内容。*'
- en: '**TRY IT OUT 10-3**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试 10-3**'
- en: Play the Pepper Dare game several times to understand how it works. Come up
    with some ideas to improve it, and then try to implement those ideas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 多次玩《胡椒敢挑战》游戏，理解它是如何运作的。想出一些改进的想法，然后尝试实现这些想法。
- en: '**Create a Dragon Game**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建龙游戏**'
- en: The previous example showed you how subroutines can add structure and clarity
    to your programs. You break your program into smaller pieces and tackle them one
    at a time. Although every problem is different and there’s no one-size-fits-all
    solution, we recommend a few ways to think through any problem.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例向你展示了子程序如何为你的程序增加结构性和清晰度。你将程序分解成更小的部分，逐一解决它们。尽管每个问题都不同，没有一种通用的解决方案，我们建议你考虑一些方法来思考任何问题。
- en: First, spend some time trying to fully understand the problem. You wouldn’t
    dive into a pool without looking at it first, right?! (What if it was filled with
    pudding?) When you have a good idea of the problem you need to solve, plan a general
    solution. Then divide it into major tasks. As the solution planner, you decide
    what those tasks are. There’s no right or wrong answer; with practice you’ll get
    better at making these choices. But if you start with the general solution and
    break it down into smaller tasks, the logic of your program will be in good shape.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，花些时间彻底理解问题。在跳入泳池之前，你不会先看看水的情况吧？（如果池水里是布丁怎么办？）当你清楚需要解决的问题时，规划一个总体解决方案。然后将其分解为主要任务。作为解决方案的规划者，你决定这些任务是什么。没有对错之分；通过练习，你会在做这些选择时变得更好。但如果你从整体解决方案开始并将其分解成较小的任务，程序的逻辑会更清晰。
- en: To show you this problem-solving strategy, let’s make the dragon game shown
    in [Figure 10-7](ch10.html#ch10fig7).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这个问题解决策略，我们来制作一个如[图10-7](ch10.html#ch10fig7)所示的龙游戏。
- en: '![image](graphics/f10-07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-07.jpg)'
- en: '*Figure 10-7: The dragon game’s user interface*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：龙游戏的用户界面*'
- en: In this game, you control the knight, and it’s your job to slay the dragon.
    On the screen you can see which variables we’ll display to keep score and where
    the player makes a choice of three actions to play.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，你控制骑士，而你的任务是击杀龙。屏幕上你可以看到用于记录分数的变量，并且玩家可以选择三种行动方式来进行游戏。
- en: When the game starts, Good Knight is on the right, some distance from Draggy
    the dragon. Good Knight has a bow and some arrows, and his shield has a certain
    strength level (the program picks these values at random). The knight makes the
    first move. He can move 1 step forward, shoot an arrow at the dragon, or stab
    the dragon with his sword (but only if he’s 1 step away). If the arrow hits the
    dragon, it’ll slay him instantly! With the sword, the knight has a 50-50 chance
    of slaying the dragon (but only when he’s close enough). If Good Knight slays
    Draggy, he’ll become Knight of the Year, win his very own dance party, and get
    his picture on the castle wall.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，勇敢的骑士位于右侧，距离龙龙（Draggy）有一定的距离。勇敢的骑士有一把弓和一些箭矢，他的盾牌有一定的强度（程序会随机选择这些数值）。骑士先行动。他可以向前移动一步、射箭攻击龙，或者用剑刺击龙（但仅当他与龙相距1步时）。如果箭矢击中龙，它会立刻杀死龙！使用剑时，骑士有50%的机会击杀龙（但仅在足够接近时）。如果勇敢的骑士击杀了龙龙，他将成为年度骑士，赢得一场属于自己的舞会，并把自己的画像挂在城堡墙上。
- en: Once Good Knight makes his move, Draggy breathes his flames at the knight. If
    he hits the knight, he’ll weaken the knight’s shield. When the shield loses its
    strength, the knight is defenseless. After this point, if the dragon’s fire hits
    the knight, it’ll burninate him! The entire city will be under the attack of the
    merciless, ferocious dragon. Game over!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦勇敢的骑士行动，龙龙就会向骑士喷火。如果火焰击中骑士，它会削弱骑士的盾牌。当盾牌失去强度时，骑士变得毫无防备。从这一点开始，如果龙的火焰再次击中骑士，它将烧死骑士！整个城市将受到无情、凶猛的龙的攻击。游戏结束！
- en: 'The game uses five images that you can find in this chapter’s folder: the background
    image (your battlefield), two images for the dragon (one image shows the dragon’s
    fire), the knight’s image, and an image of an arrow. Follow steps 1–10 to make
    a fun dragon game!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏使用了五个图像，你可以在本章的文件夹中找到它们：背景图像（你的战场）、两张龙的图像（一张图像显示龙的火焰）、骑士的图像，以及一张箭矢的图像。按照步骤1-10制作一个有趣的龙游戏！
- en: '***Step 1: Open the Startup File***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤1：打开启动文件***'
- en: Open the *Dragon_Incomplete.sb* file from the code folder for this chapter.
    This file contains the code in [Listing 10-7](ch10.html#ch10ex7) and has empty
    placeholders for your subroutines. You’ll add the code for these subroutines one
    step at a time. The program’s folder has all the images you need as well. It also
    has the complete game, *Dragon.sb*, in case you get stuck.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章代码文件夹中的*Dragon_Incomplete.sb*文件。这个文件包含了[示例 10-7](ch10.html#ch10ex7)中的代码，并为你的子例程预留了空白位置。你将一步步添加这些子例程的代码。程序的文件夹中也包含了你所需要的所有图像，还提供了完整的游戏代码*Dragon.sb*，以防你遇到困难。
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-7: High-level structure of the dragon game*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-7：龙游戏的高级结构*'
- en: First, you call the `SetUp()` subroutine (line 2) to draw the background image,
    create text shapes (for displaying the distance, number of arrows, and so on),
    and load the game’s images (dragon, knight, and arrow). Line 4 calls `NewGame()`
    to set the parameters for a new game, including the knight’s arrows, shield strength,
    and distance from the dragon. In line 6, you call `UpdateUserInterface()` to update
    the game’s user interface (UI). Then the code goes into a loop (lines 8–14) to
    manage the game. Each round, you ask the knight for his next move (line 9), process
    his move by calling `ProcessChoice()` on line 11, and then give the dragon a turn
    (line 13). As you’ll see in a moment, these subroutines will keep track of the
    game’s status and end the game when there’s a winner!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你调用`SetUp()`子例程（第2行），绘制背景图像，创建文本形状（用于显示距离、箭的数量等），并加载游戏的图像（龙、骑士和箭）。第4行调用`NewGame()`来设置新游戏的参数，包括骑士的箭数、盾牌强度和与龙的距离。在第6行，你调用`UpdateUserInterface()`来更新游戏的用户界面（UI）。然后，代码进入一个循环（第8–14行）来管理游戏。每轮，你询问骑士的下一步操作（第9行），通过调用`ProcessChoice()`来处理他的选择（第11行），然后轮到龙（第13行）。正如你将看到的，这些子例程会跟踪游戏状态，并在有赢家时结束游戏！
- en: Next, you’ll work on the subroutines one by one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将逐个处理这些子例程。
- en: '***Step 2: Write the SetUp() Subroutine***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：编写 SetUp() 子例程***'
- en: You’ll start by writing the `SetUp()` subroutine, which creates the scenario
    for your game. Add the code in [Listing 10-8](ch10.html#ch10ex8) to your program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从编写`SetUp()`子例程开始，这个子例程为你的游戏创建场景。将[示例 10-8](ch10.html#ch10ex8)中的代码添加到你的程序中。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-8: Setting up the windows and properties*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-8：设置窗口和属性*'
- en: This code contains all the one-time setup for your game; it’s a little long,
    but we’ll talk you through it. You set the titles for the graphics and text windows
    (lines 2–3). These are displayed in the title bars for these windows when the
    game is played (see [Figure 10-7](ch10.html#ch10fig7)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了你游戏的一次性设置；虽然有点长，但我们会一步步讲解。你设置了图形窗口和文本窗口的标题（第2–3行）。这些标题将在游戏运行时显示在这些窗口的标题栏中（见[图
    10-7](ch10.html#ch10fig7)）。
- en: 'Then you set the graphics window’s size (lines 5–7), font size (line 8), and
    position (line 9). Next, you position the text window to appear to the right of
    the graphics window (lines 11–12). After drawing the background image (lines 14–15),
    you create and position the text shapes that you’ll use to show all the numbers
    on the game’s UI (lines 19–26). Then you load and position the images for the
    knight, dragon, and arrow (lines 29–35). Finally, you hide the images for the
    firing dragon and the arrow because they aren’t needed at this time (lines 37–38):
    you’ll show these images when Draggy breathes fire and Good Knight shoots the
    arrow.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你设置图形窗口的大小（第5–7行）、字体大小（第8行）和位置（第9行）。接着，你将文本窗口定位到图形窗口的右侧（第11–12行）。在绘制背景图像（第14–15行）之后，你创建并定位文本形状，用于显示游戏界面上的所有数字（第19–26行）。然后，你加载并定位骑士、龙和箭的图像（第29–35行）。最后，你隐藏龙喷火和箭的图像，因为此时并不需要（第37–38行）：当龙喷火和骑士射箭时，你会显示这些图像。
- en: When we built this program, we figured out where to place the text and images
    (with the numbers we’re using) on the background’s image by using a trial-and-error
    method (we guessed and tweaked it until we got it right). You’ll likely need to
    do that when designing your own UIs for your awesome future games.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这个程序时，我们通过反复试探的方法确定了文本和图像（包括我们使用的数字）在背景图像上的位置（我们猜测并调整，直到找对位置）。你在设计自己未来的游戏UI时，可能也需要采用这种方法。
- en: '***Step 3: Add a Bit of Chance***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：加入一点运气元素***'
- en: Next, you need to add some luck to the game. Each time we run the game, we want
    Good Knight to get a different number of arrows, be a random distance away from
    the dragon, and have a different shield strength. To do this, add the `NewGame()`
    subroutine in [Listing 10-9](ch10.html#ch10ex9) to your program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要为游戏添加一些运气因素。每次运行游戏时，我们希望好骑士能获得不同数量的箭矢，距离龙有不同的远近，盾牌强度也有所不同。为此，在[清单 10-9](ch10.html#ch10ex9)中将
    `NewGame()` 子程序添加到你的程序中。
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-9: Setting up a new game*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-9：设置新游戏*'
- en: In line 2, you add 9 to a random number between 1 and 10, which sets the distance,
    `dist`, between 10 and 19\. This is the number of steps Good Knight has to take
    to get to Draggy. Next, you set the number of arrows as 40 percent of the distance
    (line 3). The farther the knight is from the dragon, the more arrows he’ll have.
    In line 4, you set the strength of the knight’s shield—again, as a fraction of
    his distance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，你将1到10之间的随机数加上9，这样就设置了距离 `dist`，它的值在10到19之间。这是好骑士必须走的步数，才能到达龙的地方。接下来，你将箭矢的数量设置为距离的40%（第3行）。骑士离龙越远，他拥有的箭矢就越多。在第4行，你设置骑士盾牌的强度——同样是基于他与龙的距离来设置。
- en: Let’s think about the `moveStep` line a little. The width of the background
    image is 480 pixels. The width of the dragon is 100 pixels, and the width of the
    knight is 100 pixels. When we place the dragon and the knight on the background,
    the distance from the dragon’s right edge to the knight’s left edge is 280 pixels.
    So every time Good Knight moves forward, we’ll move his image to the left by `280
    / dist` pixels.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微考虑一下 `moveStep` 这一行。背景图片的宽度是480像素。龙的宽度是100像素，骑士的宽度也是100像素。当我们将龙和骑士放置在背景上时，从龙的右边缘到骑士的左边缘的距离是280像素。所以每次好骑士向前移动时，我们将把他的图像向左移动
    `280 / dist` 像素。
- en: '**TIP**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*You can change the fraction in lines 3 and 4 from 0.4 to a different value
    to make the game easier or harder. After you complete the game, try changing the
    fraction and play the game a couple of times!*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以将第3行和第4行中的分数从0.4改为其他值，以使游戏变得更容易或更难。完成游戏后，尝试更改分数并玩几次游戏！*'
- en: '***Step 4: Let the Player Know What’s Going On***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：让玩家知道发生了什么***'
- en: After you set the game’s parameters, you’ll need to show them to the user. Add
    the `UpdateUserInterface()` subroutine in [Listing 10-10](ch10.html#ch10ex10).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好游戏参数后，你需要将这些信息展示给用户。在[清单 10-10](ch10.html#ch10ex10)中添加 `UpdateUserInterface()`
    子程序。
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-10: Subroutine that updates the text*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：更新文本的子程序*'
- en: This subroutine is pretty basic (and small!). You just use the `SetText()` method
    of the `Shapes` object and pass the identifier of the text shape and the number
    you want to display. Recall that we saved these identifiers when we created these
    text shapes in the `SetUp()` subroutine (lines 19–21 in [Listing 10-8](ch10.html#ch10ex8)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子程序非常基础（而且很小！）。你只需要使用 `Shapes` 对象的 `SetText()` 方法，并传入文本形状的标识符以及你要显示的数字。回想一下，我们在
    `SetUp()` 子程序中创建这些文本形状时保存了这些标识符（[清单 10-8](ch10.html#ch10ex8)中的第19到21行）。
- en: '***Step 5: Get the Player in the Game with GetChoice()***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 5：通过 GetChoice() 获取玩家的选择***'
- en: If you run the game now, you should see all the images and numbers in place,
    but nothing will happen yet. You need to start taking the knight’s orders, so
    it’s time to add the `GetChoice()` subroutine in [Listing 10-11](ch10.html#ch10ex11).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你应该能看到所有的图片和数字都已经就位，但还什么都不会发生。你需要开始接受骑士的命令，因此是时候在[清单 10-11](ch10.html#ch10ex11)中添加
    `GetChoice()` 子程序了。
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 10-11: Getting the user’s choice and displaying any errors*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-11：获取用户选择并显示任何错误*'
- en: You start by displaying the options to the user (lines 3–7). You read the user’s
    choice for Good Knight (line 9) and make sure it’s valid. If your user enters
    any number other than 1, 2, or 3, you ask them to enter a number again (lines
    10–12). If the user chooses to shoot an arrow but doesn’t have any arrows, you
    tell them they’re out of arrows and ask them again (lines 14–17). If they want
    to stab the dragon but are too far away, you tell them they’re too far away and
    ask them to choose again (lines 19–22). Otherwise, the choice the user makes is
    acceptable. You clear the message text in line 24, add an empty line to the text
    window in line 25 to prepare for the next prompt, and return to the main program
    (line 26).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先显示选项给用户（第3-7行）。你读取用户对“勇敢骑士”的选择（第9行），并确保它是有效的。如果用户输入的数字不是1、2或3，你会要求他们重新输入（第10-12行）。如果用户选择射箭但没有箭，你会告诉他们箭已用完并再次询问（第14-17行）。如果他们想刺杀龙但距离太远，你会告诉他们距离太远并要求重新选择（第19-22行）。否则，用户做出的选择是可接受的。你清除第24行的消息文本，向文本窗口添加一行空白文本以准备下一个提示（第25行），然后返回主程序（第26行）。
- en: '***Step 6: Process the Player’s Choice***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***第6步：处理玩家的选择***'
- en: Now that the user has made their choice, you need to examine the `choice` variable
    to decide what to do next. Add the `ProcessChoice()` subroutine in [Listing 10-12](ch10.html#ch10ex12)
    to your program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户已做出选择，你需要检查`choice`变量来决定接下来要做什么。将[清单 10-12](ch10.html#ch10ex12)中的`ProcessChoice()`子程序添加到你的程序中。
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-12: Jumping to the choice’s subroutine*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-12：跳转到选择的子程序*'
- en: You use an `If/Else` ladder on the `choice` variable and call a different subroutine
    for each choice. Next, you’ll write these three subroutines!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`choice`变量上使用`If/Else`条件结构，并为每个选择调用不同的子程序。接下来，你将编写这三个子程序！
- en: '***Step 7: Add Motion with MoveKnight()***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***第7步：通过MoveKnight()添加运动效果***'
- en: Add the `MoveKnight()` subroutine in [Listing 10-13](ch10.html#ch10ex13) to
    breathe some life into Good Knight and get him moving.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 10-13](ch10.html#ch10ex13)中的`MoveKnight()`子程序添加进来，让“勇敢骑士”有了生气，并开始移动。
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-13: The subroutine that moves Good Knight*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-13：移动“勇敢骑士”的子程序*'
- en: You start by reducing the knight’s distance from the dragon by 1 step (line
    2), and then you show that new distance on the game’s UI (line 3). You then move
    the knight’s image to the left (line 5).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先通过减少骑士与龙的距离1步（第2行），然后在游戏界面上显示新的距离（第3行）。接着，你将骑士的图像向左移动（第5行）。
- en: To understand how this works, let’s assume that the knight’s initial distance
    from the dragon, `dist`, is 10, which makes `moveStep = 28`, as illustrated in
    [Figure 10-7](ch10.html#ch10fig7). When the knight is 10 steps away from the dragon,
    the upper-left corner of the knight’s image is at (100 + (10 × 28), 250). When
    the knight is 9 steps away from the dragon, the upper-left corner of the knight’s
    image is at (100 + (9 × 28), 250), and when he’s 8 steps away, the image’s upper-left
    corner is at (100 + (8 × 28), 250), and so on. To move the knight, you set the
    image’s horizontal position to 100 plus the current distance, `dist`, times the
    `moveStep`, and you set the image’s vertical position to 250 (see [Figure 10-8](ch10.html#ch10fig8)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个过程，假设骑士与龙的初始距离为`dist`，为10，这使得`moveStep = 28`，如[图 10-7](ch10.html#ch10fig7)所示。当骑士距离龙10步时，骑士图像的左上角位于(100
    + (10 × 28), 250)。当骑士距离龙9步时，骑士图像的左上角位于(100 + (9 × 28), 250)，而当他距离龙8步时，图像的左上角位于(100
    + (8 × 28), 250)，依此类推。为了移动骑士，你将图像的水平位置设置为100加上当前距离`dist`乘以`moveStep`，并将图像的垂直位置设置为250（见[图
    10-8](ch10.html#ch10fig8)）。
- en: '![image](graphics/f10-08.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-08.jpg)'
- en: '*Figure 10-8: Illustrating the knight’s motion*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：展示骑士的运动*'
- en: After moving the knight, you check whether he touched the dragon (line 7). If
    he did, you tell Good Knight how great the dragon thinks he tastes and call the
    `GameOver()` subroutine. This subroutine is in [Listing 10-14](ch10.html#ch10ex14);
    add it to your program now.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 移动骑士后，你检查他是否碰到了龙（第7行）。如果碰到了，你告诉“勇敢骑士”龙觉得他非常美味，并调用`GameOver()`子程序。这个子程序在[清单 10-14](ch10.html#ch10ex14)中；现在将它添加到你的程序中。
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 10-14: Running the* `GameOver()` *subroutine*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-14：运行`GameOver()`子程序*'
- en: This subroutine calls `Pause()` to give your user a chance to read the message
    (line 2). When the user presses any key, the `Pause()` method ends, and you call
    the `End()` method to exit your program (line 3).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子程序调用`Pause()`方法，给用户一个阅读消息的机会（第2行）。当用户按下任意键时，`Pause()`方法结束，你调用`End()`方法退出程序（第3行）。
- en: '***Step 8: Shoot Arrows with ShootArrow()***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add the `ShootArrow()` subroutine in [Listing 10-15](ch10.html#ch10ex15) to
    make the Good Knight a master archer who puts Hawkeye to shame.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 10-15: Shooting the arrow*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: You start by using one arrow (line 2) and show the remaining arrows on the UI
    (line 3). You then set the arrow’s range randomly to a number between 1 and the
    distance to the dragon (line 5). The closer the knight is to the dragon, the better
    his chances are that he’ll hit his target. The next block of code (lines 8–14)
    animates the arrow. The horizontal start position, `pos1X`, is the same as the
    knight’s position (line 8), and the end position, `pos2X`, is based on the selected
    range (line 9). You then move the arrow to its start position (line 10), show
    it (line 11), animate it to its final position (line 12), wait for it to reach
    its target (line 13), and then hide it (line 14). You can change the value `2000`
    in lines 12 and 13 to make the animation shorter or longer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Once the animation is complete, you check whether the arrow hit the dragon (line
    16). If it did, the game is over (lines 17–18) and the dance party is yours! Otherwise,
    you tell Good Knight that his arrow missed (line 20), delay the program for your
    user to read the message (line 21), and return to the `ProcessChoice()` subroutine,
    which returns to the main program to give the dragon his turn.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 9: Swing the Sword with StabDragon()***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, add the last subroutine for the knight in [Listing 10-16](ch10.html#ch10ex16).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-16: Stabbing the dragon*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: You randomly pick the number 1 or 2\. If the number is 1 (line 2), the knight
    hits the dragon and the game ends (lines 3–4). If the knight misses, you tell
    the knight that he missed (line 6), delay the program for your user to read the
    message (line 7), and return to the `ProcessChoice()` subroutine.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 10: Breathe Fire***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the knight didn’t kill Draggy and end the game, the main program calls `DragonFire()`
    to give the dragon a fair fight. Add [Listing 10-17](ch10.html#ch10ex17) to your
    program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-17: The dragon breathing fire on Good Knight*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Lines 3–7 animate the dragon’s fire. You hide the normal dragon image (line
    3) and show the one spitting fire (line 4). You wait 1 second (line 5) and switch
    the images back (lines 6–7). After that, the dragon has a 50-50 chance to hit
    the knight with his fire. You pick a random number that’s either a 1 or a 2\.
    A value of 1 means the dragon has hit the knight (line 9). In this case, you check
    the shield’s strength (line 10); if it’s 0, the game is over (lines 11–12). But
    if it isn’t 0, you reduce the shield’s strength by 1 (line 14), display the new
    value (line 15), tell the knight that he was hit (line 16), and return to the
    main program. If the random number is 2 (line 18), you tell the knight that the
    dragon’s fire missed him (line 19) and return to the main program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Your game is done! Play it several times and enjoy your creation!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT OUT 10-4**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The dragon game is fun, but it isn’t perfect. When you play the game several
    times, you’ll notice some issues that you either don’t like or can improve. It’s
    now your game; make any changes you think will make the game better. You can even
    change the messages and the graphics. Head to *[http://tiny.cc/dragongame/](http://tiny.cc/dragongame/)*
    to share your game in the gallery and see what others did!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Challenges**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The folder for this challenge has images for the head, eyes, mouth, and body
    of an alien creature (see the following figure).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f0147-01.jpg)'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Write a program that prompts a user to enter the number of eyes (2, 4, or 6)
    and the number of mouths (1 or 2) of the alien. Then have your main program call
    `DrawHead()`, `DrawEyes()`, `DrawMouths()`, and `DrawBody()` to draw the alien!
    For example, here’s an alien with six eyes and two mouths:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](graphics/f0148-01.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In this challenge, you’ll develop the game Ghost Hunt (see the following figure).
    Open the file *GhostHunt_Incomplete.sb* from this chapter’s folder (which has
    all the images you need for this game). A ghost is hiding in 1 of the 12 rooms.
    To find the ghost, the user picks a room. If the user finds the ghost in that
    room, they win! Otherwise, the ghost tries to find the user (by selecting a room
    number at random). If the ghost finds the user, the game ends. Otherwise, the
    ghost moves to a different room, and the user tries again.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f0148-02.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
