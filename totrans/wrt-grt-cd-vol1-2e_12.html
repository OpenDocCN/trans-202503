<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_367"/><strong><span class="big">13</span><br/>COMPUTER PERIPHERAL BUSES</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">System buses are not the only buses you’ll find in a computer system. There are many specialized peripheral buses as well. This chapter discusses the SCSI, IDE/ATA, SATA, SAS, FibreChannel, Firewire, and USB buses that connect computers with various peripheral devices.</p>&#13;
<h3 class="h3" id="sec13_1"><strong>13.1 The Small Computer System Interface</strong></h3>&#13;
<p class="noindent">The <em>Small Computer System Interface</em> (<em><a href="gloss01.xhtml#gloss01_226">SCSI</a></em>, pronounced “scuzzy”) is a peripheral interconnection bus used to connect high-speed peripheral devices to personal computer systems. Designed in the early 1980s, the SCSI bus was popularized by its introduction on the Apple Macintosh computer system in the mid 1980s. The original SCSI bus supported an 8-bit bidirectional data bus and was capable of transferring 5MB of data per second, which was considered high performance for hard-disk subsystems of that era. Although its early performance is quite slow by modern standards, SCSI has gone through <span epub:type="pagebreak" id="page_368"/>several revisions over the years and remains a high-performance peripheral interconnection system. At the height of its popularity, these older SCSI devices were capable of transferring 320MBps (megabytes per second).</p>&#13;
<p class="indent">Although the SCSI interconnection system is most commonly used for disk drive subsystems, SCSI was designed to support a whole host of PC peripherals using a cable connection. Indeed, as SCSI became popular during the late 1980s and into the 1990s, you could find printers, scanners, imaging machines, phototypesetters, network and display adapters, and many other devices interfacing with the SCSI bus.</p>&#13;
<p class="indent">However, the prevalence of SCSI as a general-purpose peripheral bus has diminished since the emergence of the USB, FireWire, and Thunderbolt peripheral connection systems. Except for very high-performance disk drive subsystems and some very specialized peripheral devices, few new peripherals use the interface. To understand why SCSI’s popularity waned, let’s look at the problems SCSI users have faced over the years.</p>&#13;
<h4 class="h4" id="sec13_1_1"><strong><em>13.1.1 Limitations</em></strong></h4>&#13;
<p class="noindent">When SCSI was first introduced, the SCSI bus supported concurrent connection of the SCSI adapter card and up to seven actual peripheral devices. To connect multiple devices, you ran a cable from the host controller card to the first peripheral device. To connect a second device, you ran a cable from a second connector on the first device to the second device. To connect a third device, you ran a cable from a separate connector on the second device to the third device, and so on. At the end of this “daisy chain” of devices, you attached a special terminating device to the last connector of the last peripheral device. Without the special “terminator” at the end of the SCSI chain, many SCSI systems would work unreliably, if at all.</p>&#13;
<p class="indent">As a “convenience” to their customers, many peripheral manufacturers built the terminating circuitry into their devices. Unfortunately, connecting multiple terminators in the middle of the SCSI chain was just as bad as not having a terminator at all. Though most manufacturers who designed the terminating circuitry into their peripherals often provided an option to disable the terminator, some did not. Ensuring that those devices with the active terminator circuitry were at the end of the SCSI chain was often cumbersome, and even if a device provided an option to enable or disable the terminator, knowing the appropriate DIP switch settings was challenging if the documentation wasn’t handy. As a result, many computer owners had problems with a chain of SCSI devices not working properly in their system.</p>&#13;
<p class="indent">On the original SCSI bus, the computer system owner had to assign each device one of eight numeric “addresses” from 0 to 7, with address 7 generally reserved for the host controller card. If two devices in the SCSI chain had the same address, they wouldn’t operate properly. This made moving SCSI peripherals from one computer system to another somewhat difficult, because the address of the device being moved was usually already taken by another device on the new system.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_369"/>The original SCSI bus had other limitations as well. First, it supported only seven peripheral devices. When SCSI was first designed, this wasn’t usually a problem because common SCSI peripherals like hard drives and scanners were very expensive, costing thousands of dollars each. Connecting more than seven devices wasn’t something your average computer owner would have done back then. As the price of hard drives and other SCSI peripherals came down, however, the seven-peripheral limit became burdensome.</p>&#13;
<p class="indent">Second, SCSI was not <em>hot-swappable</em>; that is, you couldn’t unplug or connect a peripheral device while the power was on. Doing so could cause electrical damage to the SCSI controller, the peripheral, or even some other peripheral on the SCSI bus. As SCSI peripherals became more affordable and people began connecting multiple devices to their computer systems, the desire to unplug a device from one system and plug it into another grew, but SCSI did not support that capability.</p>&#13;
<h4 class="h4" id="sec13_1_2"><strong><em>13.1.2 Improvements</em></strong></h4>&#13;
<p class="noindent">Despite these drawbacks, SCSI’s popularity grew. To maintain that popularity, SCSI was modified over time to improve its functionality. SCSI-2, the first modification, increased the speed from 5 MHz to 10 MHz, thus doubling the data transfer rate on the bus. This was necessary because the speed of high-performance devices like disk drives improved so much that the original SCSI was actually slowing them down. Next, expanding the size of the bidirectional SCSI data bus from 8 bits to 16 bits not only doubled the data transfer rate from 10MBps to 20MBps, but also increased the number of peripherals you could place on the bus from 7 to 15. Variations of SCSI-2 were known as <em>Fast SCSI</em> (10 MHz), <em>Wide SCSI</em> (16 bits), and <em>Fast and Wide SCSI</em> (16 bits at 10 MHz).</p>&#13;
<p class="indent">It should come as no surprise that SCSI-3 followed SCSI-2. SCSI-3 offers a veritable smorgasbord of different connection options while maintaining compatibility with the older standards. Although SCSI-3 (using names like Ultra, Ultra-Wide, Ultra2, Wide Ultra2, Ultra3, and Ultra320) still operates as a 16-bit bus in the parallel cable mode, and still supports a maximum of 15 peripherals, it vastly increased the operating speed of the bus and the maximum permissible physical distance across which SCSI peripherals could be chained. In short, SCSI-3 operates at speeds of up to 160 MHz, allowing the SCSI bus to transfer data in bursts up to 320MBps (that is, faster than many PCI bus interconnects!).</p>&#13;
<p class="indent">SCSI was originally a parallel interface. Today, it supports four different interconnection standards: SCSI Parallel Interface (SPI), Serial SCSI across FireWire, Fibre Channel Arbitrated Loop, and Serial-Attached SCSI (SAS). The SPI is the original standard that most people associate with SCSI. SCSI parallel cables contain either 8 or 16 data lines, depending on the type of SCSI interface in use. This makes SCSI cables bulky, heavy, and expensive. The parallel SCSI interface also limits the maximum length of the SCSI chain in the system to just a few meters. These concerns, especially <span epub:type="pagebreak" id="page_370"/>the economic ones, are why modern computer systems use SCSI peripherals only when they require extremely high performance.</p>&#13;
<p class="indent">Note that the computer system doesn’t own the SCSI bus and doesn’t necessarily direct the traffic between various peripherals on the bus. SCSI is a true <em>peer-to-peer</em> bus, and any two peripherals on it may communicate with each other. Indeed, it’s possible (though unusual) for two computer systems to share the same SCSI bus.</p>&#13;
<p class="indent">This peer-to-peer operation can improve the performance of the overall system tremendously. To illustrate this point, consider a tape backup system. In practice, most tape backup programs read a block of data from a disk drive into the computer’s memory and then write that block of data from the computer’s memory to the tape drive. On the SCSI bus (in theory, at least), it’s possible to have the tape and disk drives communicate directly with each other. The tape backup software would send two commands, one to the disk drive and one to the tape drive, telling the disk drive to transfer the block of data directly to the tape drive rather than going through the computer system. Not only does this reduce the number of transfers across the SCSI bus by half, speeding up the transfer, but it also frees up the computer’s CPU to do other things. In reality, few tape backup systems work this way, but there are many examples where two peripherals communicate across the SCSI bus without using the computer as an intermediary. Software that programs SCSI peripherals to operate this way (rather than running the data through the computer’s memory) is a prime example of great programming.</p>&#13;
<h4 class="h4" id="sec13_1_3"><strong><em>13.1.3 SCSI Protocol</em></strong></h4>&#13;
<p class="noindent">SCSI is not only an electrical interconnection, but a <em>protocol</em> as well. You don’t communicate with a SCSI peripheral device by writing some data to a couple of registers on the SCSI interface card, sending that data down the SCSI cable to the peripheral device. Instead, you build up a data structure in memory containing a SCSI command, command parameters, any data you want to send to the SCSI peripheral, and possibly a pointer with the memory address where the SCSI controller should store any data the peripheral device returns. Once you construct this data structure, you normally provide the SCSI controller with the data structure’s address, and the SCSI controller then fetches the command from system memory and sends it to the appropriate peripheral device on the SCSI bus.</p>&#13;
<h5 class="h5" id="sec13_1_3_1"><strong>13.1.3.1 SCSI Command Set</strong></h5>&#13;
<p class="noindent">As SCSI hardware has evolved over the years, so has the SCSI protocol—<br/>or the SCSI <em>command set</em>. SCSI was never intended to serve as just a hard-disk interface, and the breadth of peripherals that it supports has steadily increased over time with the advent of new types of computer peripherals. To accommodate these new and unanticipated uses for the SCSI bus, SCSI’s designers created a device-independent command protocol that could be easily extended as new devices were invented. Contrast this with certain <span epub:type="pagebreak" id="page_371"/>device interfaces, such as the original Integrated Disk Electronics (IDE) interface, which was suitable only for disk drives.</p>&#13;
<p class="indent">The SCSI protocol transmits a packet containing the peripheral’s address, the command, and the command’s data. The SCSI-3 standard has roughly grouped these commands into the following classes:</p>&#13;
<p class="uln-indent"><strong>SCSI Controller Commands (SCC)</strong> Controller commands for RAID arrays</p>&#13;
<p class="uln-indent"><strong>SCSI Enclosure Services (SES) Commands</strong> Enclosure services commands</p>&#13;
<p class="uln-indent"><strong>SCSI Graphics Commands (SGC)</strong> Graphics commands for printers</p>&#13;
<p class="uln-indent"><strong>SCSI Block Commands (SBC)</strong> Hard-disk interface commands</p>&#13;
<p class="uln-indent"><strong>Management Server Commands (MSC)</strong> Commands for converting between SCSI protocols</p>&#13;
<p class="uln-indent"><strong>Multimedia Commands (MMC)</strong> Multimedia commands for devices such as DVD drives</p>&#13;
<p class="uln-indent"><strong>Object-based Storage Device (OSD) Commands</strong> Commands for managing how objects are allocated, placed, and accessed</p>&#13;
<p class="uln-indent"><strong>SCSI Primary Commands (SPC)</strong> Primary commands</p>&#13;
<p class="uln-indent"><strong>Reduced Block Commands (RBC)</strong> Commands for simplified hard-drive subsystems</p>&#13;
<p class="uln-indent"><strong>SCSI Stream Commands (SSC)</strong> Stream commands for tape drives</p>&#13;
<p class="indent">Although the SCSI commands themselves are standardized, the actual interface to the SCSI host controller is not. Different host controller manufacturers use different hardware to connect their SCSI controller chips to the host computer system, so how you talk to a SCSI controller chip depends on the particular host controller device. Because SCSI controllers are <em>very</em> complex and difficult to program, and because there is no “standard” SCSI interface chip, programmers are faced with having to write several different variants of their software to control SCSI devices.</p>&#13;
<h5 class="h5" id="sec13_1_3_2"><strong>13.1.3.2 SCSI Device Drivers</strong></h5>&#13;
<p class="noindent">To correct this situation, SCSI host controller manufacturers like Adaptec have created specialized device driver modules that provide a uniform interface to their devices. Rather than writing data directly to a SCSI chip, a programmer creates an in-memory data structure with SCSI commands to be placed on the SCSI bus, calls the device driver software, and lets the device driver transfer the SCSI commands to the SCSI bus. There are several benefits of this approach:</p>&#13;
<ul>&#13;
<li class="noindent">It frees the programmer from having to learn the complexities of each particular host controller.</li>&#13;
<li class="noindent">It allows different manufacturers to provide a compatible interface to their SCSI controller devices.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_372"/>It allows manufacturers to create a single optimized driver that properly supports the capabilities of their device, rather than prompting individual programmers to write (possibly mediocre) code for the device.</li>&#13;
<li class="noindent">It allows manufacturers to change the hardware of future versions of their device without destroying compatibility with existing software.</li>&#13;
</ul>&#13;
<p class="indent">This concept was carried forward into modern OSes. Today, SCSI host controller manufacturers write <em>SCSI miniport drivers</em> for OSes like Windows. These miniport drivers provide a hardware-independent interface to the host controller so that the OS can simply say, “Here is a SCSI command. Put it on the SCSI bus.”</p>&#13;
<h4 class="h4" id="sec13_1_4"><strong><em>13.1.4 SCSI Advantages</em></strong></h4>&#13;
<p class="noindent">One big advantage of the SCSI interface is that it provides parallel processing of SCSI commands. That is, a host system can place several different SCSI commands on the bus, and different peripheral devices can process those commands simultaneously. Some devices, like disk drives, can even accept multiple commands at once and process them in the order that is most efficient. As an example, suppose that a disk drive is currently near block 1,000. If the system sends block read requests for blocks 5,000; 4,560; 3,000; and 8,000; the disk controller can rearrange these requests and satisfy them in the most efficient order (probably 3,000; 4,560; 5,000; and then 8,000) as it moves the read/write head across the surface of the disk. This results in a big performance improvement on multitasking OSes that process requests for disk I/O from several different applications simultaneously.</p>&#13;
<p class="indent">SCSI is also a great interface for RAID systems because SCSI is one of the few disk controller interfaces that supports a large number of drives on the same interface.</p>&#13;
<p class="indent">The original SPI (parallel SCSI) is all but dead. Even SCSI over FireWire is almost gone (as is FireWire). However, today SCSI still lives on in the form of SAS (Serial-Attached SCSI). Very-high-performance hard-disk drives use the SAS command set (rather than the standard SATA command set). The highest-performing RAID systems are still built around SAS drives.</p>&#13;
<p class="indent">The SCSI command set is very powerful, and it is designed for high-performance applications. It is sufficiently large and complex that space limitations prevent its inclusion here. Readers interested in a deeper look at SCSI programming should refer to <em>The Book of SCSI</em>, 2nd ed., by Gary Field, Peter M. Ridge et al. (No Starch Press, 2000). The complete SCSI specifications appear at various sites on the web. A quick search for “SCSI specifications” should turn up several copies.</p>&#13;
<h3 class="h3" id="sec13_2"><strong>13.2 The IDE/ATA Interface</strong></h3>&#13;
<p class="noindent">Although SCSI is very high performance, it is also expensive. A SCSI device requires a sophisticated and fast processor in order to handle all the operations that are possible on the SCSI bus. Furthermore, because SCSI devices can operate on a peer-to-peer basis (that is, one peripheral may talk to <span epub:type="pagebreak" id="page_373"/>another without intervention from a host computer system), each SCSI device must carry around a considerable amount of sophisticated software in ROM on the device’s controller board. Adding all the extra functionality needed to support full SCSI when all you want to do is to attach a single hard disk to a personal computer system is overkill. The <em>Integrated Drive Electronics (IDE)</em> interface was an effort to provide a bare-bones, low-cost mass storage option.</p>&#13;
<p class="indent">The idea behind the IDE interface was to lower the cost of the disk drive by using the host computer’s CPU to do the processing (SCSI used embedded CPUs to handle a lot of the work). Because the PC’s CPU was usually idle (during SCSI transfers) anyway, this seemed like a good use of resources. IDE drives, because they were often hundreds of dollars less than SCSI drives, became incredibly popular on PC systems. The much lower cost of the IDE interface and of IDE drives ensured its popularity.</p>&#13;
<p class="indent">Because the original IDE specification was geared specifically to hard-disk drives and was not particularly well suited for other types of storage devices, the committee that designed the IDE interface went back to work and developed the <em>Advanced Technology Attachment with Packet Interface (ATAPI)</em>, which is usually shortened to <em><a href="gloss01.xhtml#gloss01_20">ATA</a></em>. Like SCSI, the ATA standard has gone through several revisions and improvements over the years. The ATAPI specification (in its eighth version as of 2013) extends IDE to support a wide range of mass storage devices, including tape drives, zip drives, CD-ROMs, DVDs, removable cartridge drives, and more. In order to extend the IDE interface to support all these different storage devices, ATAPI’s designers adopted a packet command format that is very similar to—in some cases, identical to—the SCSI packet command format.</p>&#13;
<p class="indent">In modern protected-mode OSes like Windows or Linux, however, an application programmer is never allowed to talk directly to the hardware. In theory, it would be possible to write a miniport driver for IDE to simulate how SCSI works. In practice, though, the OS vendor generally supplies a software library that provides an <em>application programming interface (API)</em> to the IDE/ATAPI devices. The application programmer can then make function calls to the API, passing appropriate parameters, and the underlying library routines take care of the remaining tasks associated with actually talking to the hardware.</p>&#13;
<p class="indent">Programming ATAPI devices in a modern system is quite similar to programming SCSI devices. You load up a memory-based data structure with a command code and a set of parameters, and then pass the memory structure to a driver library function that passes the data across ATAPI to the target storage device. If such a low-level library is not available, and your OS allows it, you can program the ATAPI device to grab this data (generally using DMA on modern systems).</p>&#13;
<p class="indent">The full ATAPI specification is almost 500 pages long, so we don’t have sufficient space to cover it here. If you’re interested in a more detailed look at IDE/ATAPI, search for “ATAPI specifications” online.</p>&#13;
<p class="indent">Modern machines use a serial ATA (SATA) controller. This is a high-performance serial version of the venerable IDE/ATAPI parallel interface. However, to the programmer, it looks exactly like ATAPI.</p>&#13;
<h4 class="h4" id="sec13_2_1"><span epub:type="pagebreak" id="page_374"/><strong><em>13.2.1 The SATA Interface</em></strong></h4>&#13;
<p class="noindent">As time passed, hard drives became sufficiently fast that the IDE/ATA interface was reducing drive performance. <em>Serial AT Attachment (SATA)</em> and, later, SATA-II and SATA-III, provided several advantages over the parallel IDE/ATA (often shortened to <em><a href="gloss01.xhtml#gloss01_191">PATA</a></em>, for “Parallel ATA”). Whereas PATA was capable of running at 133MBps, SATA-I, II, and III were capable of transferring data at 1.5Gbps (gigabits per second; 150MBps), 3.0Gbps (300MBps), and 6.0Gbps (600MBps), respectively, though few (RAID) systems even come close to achieving these data transfer rates. SATA also offered other advantages over PATA, including smaller cables (7 conductors rather than 40 or 80) and hot swapping. Today, most hard-disk drives connecting to PCs use the SATA interface (and most of the others use SAS, which is effectively SCSI over SATA, or Fibre Channel interfaces).</p>&#13;
<h4 class="h4" id="sec13_2_2"><strong><em>13.2.2 Fibre Channel</em></strong></h4>&#13;
<p class="noindent">Fibre Channel is a very high-performance transport mechanism (up to 128Gbps). While it is a generic network protocol for large mainframe computers, one of its predominant uses is to connect very high-performance disk arrays to computer system (usually servers). For disk drive use, Fibre Channel transports SCSI commands across the Fibre Channel cabling. So, the 1980s SCSI interface lives on today in Fibre Channel, still the highest-performance disk interface protocol.</p>&#13;
<h3 class="h3" id="sec13_3"><strong>13.3 The Universal Serial Bus</strong></h3>&#13;
<p class="noindent">The <em>Universal Serial Bus (USB)</em> is a mechanism that allows you to use a single interface to connect a wide variety of peripheral devices to a PC, similar to SCSI. The USB supports <em>hot-pluggable devices</em>, meaning you can plug and unplug devices without shutting down the power or rebooting your machine, and it supports <em>plug-and-play devices</em>, meaning the OS will automatically load a device driver, if available, once you plug in a device. This flexibility comes at a cost, however. Programming devices on the USB is considerably more complex than programming a serial or parallel port. You cannot communicate with USB peripherals by reading or writing a few device registers.</p>&#13;
<h4 class="h4" id="sec13_3_1"><strong><em>13.3.1 USB Design</em></strong></h4>&#13;
<p class="noindent">To understand the motivation behind USB, consider the situation PC users faced when Windows 95 first arrived, nearly 14 years after the introduction of the IBM PC. IBM designed its PC with a variety of peripheral interconnects that were common on PCs and minicomputers in the late 1970s. However, the IBM designers didn’t anticipate (or allow for) the wide variety of peripheral devices that people would invent to attach to PCs in the following decades. They also did not count on any individual PC owners connecting more than a few different peripheral devices to their machines. <span epub:type="pagebreak" id="page_375"/>Certainly, three parallel ports, four serial ports, and a single hard-disk drive should have been sufficient!</p>&#13;
<p class="indent">By the time Windows 95 was introduced, people were connecting their PCs to all kinds of devices, including sound cards, video digitizers, digital cameras, advanced gaming devices, scanners, telephones, mice, digitizing tablets, SCSI devices, and literally hundreds of other devices the original PC’s designers hadn’t dreamed of. The creators of these devices interfaced their hardware to the PC using peripheral I/O port addresses, interrupts, and DMA channels that were originally intended for other devices. The problem with this approach was that there were a limited number of port addresses, interrupts, and DMA channels, and a large number of devices competing for them. As a workaround, the device manufacturers added “jumpers” to their cards that would allow the purchaser to select from a small set of different port addresses, interrupts, and DMA channels, to alleviate conflicts with other devices.</p>&#13;
<p class="indent">Creating a conflict-free system was a complex process, though, and it was impossible to achieve with some combinations of peripherals. In fact, one of the big selling points of the Apple Macintosh during this period was that you could easily connect multiple peripheral devices without worrying about device conflicts. What was needed was a new peripheral connection system that supported a large number of devices without conflicts. USB was the answer.</p>&#13;
<p class="indent">USB allows the connection of up to 127 devices simultaneously by using a 7-bit address. USB reserves the 128th slot, address 0, for autoconfiguration purposes. In real life, it’s doubtful that you’d ever successfully connect so many devices to a single PC, but it’s good to know that USB has a fair amount of potential for growth, unlike the original PC.</p>&#13;
<p class="indent">Despite the name, USB isn’t a true “bus” in the sense of allowing several devices to communicate with one another. Instead, the USB is a controller/peripheral connection, with the PC always acting as controller. This means, for example, that a digital camera can’t talk directly to a printer across the USB. To transmit information from the camera to the printer, both of which are connected to a PC, the camera must first send its data to the PC before the PC can pass the data along to the printer. The PCIe, ISA, FireWire (IEEE 1394), and Thunderbolt buses allow two devices to communicate peer-to-peer (that is, independent of the host’s CPU), but USB wasn’t designed to support this method of communication (to keep down the cost of peripherals and the USB interface chips they contain).<sup><a href="footnotes.xhtml#fn13_1a" id="fn13_1">1</a></sup></p>&#13;
<p class="indent">USB also keeps peripheral costs down by moving as much complexity as possible to the host (PC) side of the connection. The thinking here is that the PC’s CPU will offer much higher performance than the low-cost microcontrollers found in most USB peripheral devices. This means that writing software to be embedded in a USB peripheral isn’t much more work than <span epub:type="pagebreak" id="page_376"/>using another interface. On the other hand, writing USB software on the host side is very complex—so complex, in fact, that it isn’t realistic to expect programmers to do so.</p>&#13;
<p class="indent">Instead, the OS supplier must provide a USB host controller <em>stack</em> that enables communication with USB devices, and most application programmers talk to those devices using the OS’s device driver interface. Even programmers who need to write custom USB device drivers for their particular device don’t talk directly to the USB hardware. Instead, they make OS calls to the USB host controller stack with requests for their particular device. Because a typical USB host controller stack is generally around 20,000 to 50,000 lines of C code and requires several years of development, there’s little chance of programming USB devices on a system that doesn’t provide a native USB stack (such as MS-DOS).</p>&#13;
<h4 class="h4" id="sec13_3_2"><strong><em>13.3.2 USB Performance</em></strong></h4>&#13;
<p class="noindent">The initial USB design supported two different types of peripherals—<br/>slow and fast—to support devices with different price points. Slow devices could transfer up to 1.5Mbps (megabits per second) across the USB, while fast devices were capable of transferring up to 12Mbps (1.5MBps). Cost-sensitive devices could be built inexpensively as low-speed devices. Non-cost-sensitive devices could use the 12Mbps data rate.</p>&#13;
<p class="indent">The USB 2.0 specifications added a high-speed mode supporting up to 480Mbps data transfer rates (60MBps), at considerable extra complexity and cost. USB 3.0 upped the performance to 635MBps (super-speed). Finally, the USB 3.1 and USB-C (Thunderbolt 3) interfaces bumped the speed up to 5GBps (gigabytes per second; SuperSpeed), 10GBps (SuperSpeed+), and 40GBps, respectively. USB 4.0 is expected to be capable of up to 80GBps.</p>&#13;
<p class="indent">USB does not dedicate the entire available bandwidth to one peripheral. Instead, the host controller stack <em>multiplexes</em> the data on the USB, effectively giving each peripheral a “time slice” of the bus. The USB operates with a 1-millisecond clock. At the start of each millisecond period, the USB host controller begins a new USB <em>frame</em>, and during a frame, each peripheral may transmit or receive a packet of data. Packets vary in size, depending on the speed of the device and the transmission time, but typically contain between 4 and 64 bytes of data. If you’re transferring data between four peripherals at an equal rate, you’d typically expect the USB stack to transmit one packet of data between the host and each peripheral in a <em>round-robin</em> fashion, taking care of the first peripheral first, the second peripheral second, and so on. Like time slicing in a multitasking OS, this data transfer mechanism gives the appearance of transferring data concurrently between the host and every USB peripheral, even though there can be only one transmission on the USB at a time.</p>&#13;
<p class="indent">Although USB provides a very flexible and expandable system, because the bandwidth on the bus is shared between all attached peripherals, it can slow devices down. For example, if you connect two disk drives to the USB and access both drives simultaneously, the two drives must share <span epub:type="pagebreak" id="page_377"/>the available bandwidth on the USB. For USB 1.<em>x</em> devices, this produces a noticeable speed degradation. For USB 2.<em>x</em> devices, the available bandwidth is sufficiently high (typically higher than what two disk drives can sustain) that you won’t notice the performance degradation. For USB 3.<em>x</em> (and later) and USB-C, the performance is as high as many native bus controllers. (For example, Thunderbolt-3/USB-C provides a transport mechanism for the PCI bus and SCSI.) Theoretically, you could use multiple host controllers to provide multiple USB buses in a system (with full bandwidth available on each bus), but this addresses only part of the performance problem.</p>&#13;
<p class="indent">Another performance consideration is the overhead of the USB host controller stack. Although the USB 1.<em>x</em> hardware may be capable of 12Mbps bandwidth, there is some dead time—that is, time during which no transmission takes place on the USB—because the host controller stack takes a while to set up data transfers. In some USB systems, you can achieve at most <em>half</em> the theoretical USB bandwidth, because the host controller stack uses so much of the available CPU time setting up the transfer and moving data around. On some embedded systems using slower processors (such as 486, StrongArm, or MIPS) running an embedded USB 1.<em>x</em> host controller device, this can be a real problem.</p>&#13;
<p class="indent">If a particular host controller stack is incapable of maintaining the full USB bandwidth, it usually means that the CPU can’t process USB information as fast as the USB produces it, because the CPU’s processing capabilities are saturated—and no time is available for other computations, either. Remember, USB leaves all the complex computations for the host controller on the USB, and executing code in the USB stack on the host requires CPU cycles. It’s quite possible for the host controller to get so involved processing USB traffic that overall system performance for non-USB traffic suffers.</p>&#13;
<p class="indent">Fortunately, on PCs with USB 2.<em>x</em> controllers, the host controller consumes only a small percentage of the USB bandwidth. When USB-3 and USB-C came along, USB hardware began supporting other transmission protocols, such as SCSI and PCI, eliminating many of the performance issues associated with USB.</p>&#13;
<h4 class="h4" id="sec13_3_3"><strong><em>13.3.3 Types of USB Transmissions</em></strong></h4>&#13;
<p class="noindent">The USB protocol supports four different types of data transmissions: control, bulk, interrupt, and isochronous. The peripheral manufacturer, not the application programmer, determines the data transfer mechanism between the host and a given peripheral device. That is, if a device uses the isochronous data transfer mode to communicate with the host PC, a programmer can’t decide to use bulk transfers instead. The application program may not even be aware of the underlying transmission scheme, as long as the software can handle the rate at which the device produces or consumes the data.</p>&#13;
<p class="indent">USB generally uses <em>control</em> transmissions to initialize a peripheral device by reading and writing data from and to a peripheral’s registers. For example, if you have a USB-to-serial converter device, you would typically use control transfers to set the baud rate, number of data bits, parity, number of stop bits, and so on, just as you would store data into the 8250 SCC’s <span epub:type="pagebreak" id="page_378"/>register set.<sup><a href="footnotes.xhtml#fn13_2a" id="fn13_2">2</a></sup> USB guarantees correct delivery of control transmissions and also guarantees that at least 10 percent of the USB bandwidth is available for control transmissions to prevent <em>starvation</em>, a situation where a particular transmission never occurs because some higher-priority transmission is always taking place.</p>&#13;
<p class="indent">USB <em>bulk</em> transmissions are used to transmit large blocks of data between the host and a peripheral device. Bulk transmissions are available only on full-speed (12Mbps), high-speed (480Mbps), and super-speed (USB 3/USB-C) devices, not on low-speed ones. On full-speed devices, a bulk transmission generally carries between 4 and 64 bytes of data per packet; on high- and super-speed devices, you can transmit up to 1,023 bytes per packet. USB guarantees correct delivery of a bulk packet between the host and the peripheral device, but it does not guarantee timely delivery. If the USB is handling a large number of other transmissions, it may take a while for a bulk transmission to complete. In theory, a bulk transmission might never occur if the USB is sufficiently busy with the right combination of isochronous, interrupt, and control transmissions. In practice, however, most USB stacks do set aside a small amount of guaranteed bandwidth for bulk transmissions (generally about 2 to 2.5 percent) to prevent starvation.</p>&#13;
<p class="indent">USB intends bulk transmissions to be used by devices that need to transmit a fair amount of data correctly, but not necessarily quickly. For example, when you’re transferring data to a printer or between a computer and a disk drive, correct transfer is far more important than timely transfer. Sure, it may be annoying to wait what seems like forever to save a file to a USB disk drive, but operating slowly is much better than writing incorrect data to the disk file.</p>&#13;
<p class="indent">For devices that require both correct data transmission and timely delivery, USB uses <em>interrupt</em> transfers. Despite their name, interrupt transfers do not involve interrupts on the computer system. Instead, the USB protocol marks interrupt transfers as high-priority events. The host polls all devices on the USB, but the devices do not interrupt the host when they have data available. A peripheral device using the interrupt transfer type may request how often the host polls it, choosing an interval from 1 to 255 milliseconds.<sup><a href="footnotes.xhtml#fn13_3a" id="fn13_3">3</a></sup></p>&#13;
<p class="indent">In order to guarantee correct and timely delivery of interrupt transmissions between a host and a peripheral device, the USB host controller stack must reserve a portion of the USB bandwidth whenever an application opens a device for interrupt transmission. For example, if a particular device wants to be serviced every millisecond and needs to transmit 16 bytes per packet, the USB host controller stack must reserve a little bit more than 128Kbps (kilobits per second) of bandwidth (16 bytes × 8 bits per byte × 1,000 packets per second) from the total bandwidth available. You need to reserve a little bit more than this, because there’s some protocol overhead on the bus as well—at least 10 to 20 percent, but it could be more depending upon how the USB stack is written.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_379"/>Because there’s a limited amount of bandwidth available on the USB, and because interrupt transmissions consume a fixed amount of that bandwidth whenever you open a device for use, you can’t have an arbitrary number of interrupt transmissions active at any one time. Once the USB bandwidth (minus the 10 percent that USB reserves for control transmissions) is consumed, the stack refuses to activate any new interrupt transmissions.</p>&#13;
<p class="indent">Interrupt transmission packets are between 4 and 64 bytes long, though most of the time they fall into the low end of this range. Larger packets would prevent the system from guaranteeing the desired polling frequency.</p>&#13;
<p class="indent">Many devices use interrupt transmissions to notify the host CPU that some data is available, and then the host uses a bulk transmission to actually read the data from the device. If the amount of data to transmit between the host and the peripheral is small enough, the peripheral may transmit the data as part of the interrupt’s data payload to avoid a second transmission. Keyboards, mice, joysticks, and similar devices typically transmit their data this way. Disk drives, scanners, and other such devices use interrupt transmissions to notify the host that data is available and then use bulk transfers to move the data around.</p>&#13;
<p class="indent"><em>Isochronous</em> (or <em>iso</em>) transfers are the fourth transfer type that USB supports. Like interrupt transfers, iso transfers require a timely delivery. Like bulk transfers, they generally involve larger data packets. However, unlike the other three transfer types, they do not guarantee correct delivery between the host and the peripheral device. Timely delivery is so important for iso transfers that if a packet arrives late, it might as well not arrive at all. Peripheral devices such as audio input (microphones) and output (speakers) and video cameras use iso transmissions. If you lose a packet, or if a packet is transmitted incorrectly between the peripheral and host, you’ll get a momentary glitch on the video display or in the audio signal, but such problems are not disastrous as long as they don’t occur too frequently.</p>&#13;
<p class="indent">Like interrupt transfers, iso transfers consume USB bandwidth. Whenever you open a connection to an iso USB peripheral device, that device requests a certain amount of bandwidth. If the bandwidth is available, the USB host controller stack reserves it for the device until the application is finished with the device. If sufficient bandwidth is not available, the USB stack notifies the application that it cannot use the desired device until the user stops using other iso and interrupt devices to free up some bandwidth.</p>&#13;
<h4 class="h4" id="sec13_3_4"><strong><em>13.3.4 USB-C</em></strong></h4>&#13;
<p class="noindent">USB originally competed with FireWire for mindshare among peripheral developers. Early on, FireWire was a much higher-performing interface and protocol. However, with the advent of USB-2 and, especially, USB-3, FireWire became less attractive. During this time, Apple worked with Intel to create a new external peripheral bus protocol—Thunderbolt. Thunderbolt totally smoked USB on performance. The race was on again, this time between USB and Thunderbolt. However, Intel (which promoted both USB and Thunderbolt) decided to merge the two standards into one: USB-C. USB-C is actually a Thunderbolt 3 hardware interface that happens to carry USB, PCI, <span epub:type="pagebreak" id="page_380"/>SCSI, and other protocols over the serial bus. Now, you don’t really have to decide—USB-C (or Thunderbolt-3) is the interface of choice.</p>&#13;
<h4 class="h4" id="sec13_3_5"><strong><em>13.3.5 USB Device Drivers</em></strong></h4>&#13;
<p class="noindent">Most OSes that provide a USB stack support dynamic loading and unloading of USB device drivers, known as <em>client drivers</em> in USB terminology. Whenever you attach a USB device to the USB, the host system gets a signal telling it that the <em>bus topology</em> has changed (that is, there’s a new device on the USB). The host controller scans for the new device, a process known as <em>enumeration</em>, and then reads some configuration information from the peripheral. Among other things, this configuration information tells the USB stack the type of the device, the manufacturer, and model information. The USB host stack uses this information to determine which device driver to load into memory. If the USB stack can’t find a suitable driver, it generally opens up a dialog box requesting help from the user; if the user can’t provide the path to an appropriate driver, the system simply ignores the new device. Similarly, when the user unplugs a device, the USB stack unloads the appropriate device driver from memory if it’s not also being used for some other device.</p>&#13;
<p class="indent">To simplify device driver implementation for many common devices, such as keyboards, disk drives, mice, and joysticks, the USB standard defines certain device classes. Peripheral manufacturers who create devices that adhere to one of these standardized device classes don’t have to supply a device driver with their equipment. Instead, the class drivers that come with the USB host controller stack provide the only interface necessary. Examples of class drivers include HID (Human Interface Devices, such as keyboards, mice, and joysticks), STORAGE (disk, CD, and tape drives), COMMUNICATIONS (modems and serial converters), AUDIO (speakers, microphones, and telephony equipment), and PRINTERS. Peripheral manufacturers can always opt to supply their own specialized features that add bells and whistles to their product, but a customer will often get basic functionality from some existing class driver by simply plugging in the device without installing a device driver specifically for it.</p>&#13;
<h3 class="h3" id="sec13_4"><strong>13.4 For More Information</strong></h3>&#13;
<p class="ref">Axelson, Jan. <em>USB Complete: The Developer’s Guide</em>. 4th ed. Madison, WI: Lakeview Publishing, 2009.</p>&#13;
<p class="ref">Field, Gary, Peter M. Ridge et al. <em>The Book of SCSI</em>. 2nd ed. San Francisco: No Starch Press, 2000.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For the USB, FireWire, and TCP/IP (network) protocol stacks, you’ll find considerable information online. For example,</em> <a href="http://www.usb.org/">http://www.usb.org/</a> <em>contains all the technical specifications for the USB protocol as well as programming information for various common USB host controller chip sets. You’ll also find plenty of online code resources, such as complete source code from Linux for TCP/IP and USB host controller stacks.</em></p>&#13;
</div>&#13;
</body></html>