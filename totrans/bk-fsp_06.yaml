- en: Chapter 6. Going to Collections
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章：走进集合
- en: Programming tasks often require working with collections of data. The .NET Framework
    has always supported this scenario with constructs such as *arrays*and the `ArrayList`
    class, but it wasn’t until generics were introduced in .NET 2.0 that collection
    support really matured.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程任务通常需要处理数据集合。 .NET 框架一直通过如*数组*和`ArrayList`类等构造来支持这一场景，但直到 .NET 2.0 引入泛型后，集合支持才真正成熟。
- en: F# builds upon .NET’s legacy by not only supporting all of the existing collection
    types but also bringing a few of its own to the party. In this chapter, we’ll
    see the role a few of the classic collection types play in F# and then explore
    the F#-specific types. Along the way, we’ll see how the built-in collection modules
    add some functional flair and make working with both the traditional and F#-specific
    types a breeze.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: F# 在 .NET 的基础上进行扩展，不仅支持所有现有的集合类型，还带来了一些自己的集合类型。在本章中，我们将看到一些经典集合类型在 F# 中的作用，接着我们将探索
    F# 特有的集合类型。在此过程中，我们将看到内建的集合模块如何为传统类型和 F# 特有类型增添一些函数式的特色，使得处理这些类型变得轻松自如。
- en: Sequences
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列
- en: In .NET, *sequence* is an all-encompassing term for a collection of values that
    share a common type. More specifically, a sequence is any type that implements
    `IEnumerable<'T>`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，*序列*是指一类具有共同类型的值的集合。更具体地说，序列是实现了`IEnumerable<'T>`接口的任何类型。
- en: Nearly all of the major collection types in .NET are sequences. For instance,
    the generic collection types (like `Dictionary<'TKey, 'TValue>` and`List<'T>`)
    and even some types (like `String`) that aren’t typically thought of as collections
    implement `IEnumerable<'T>`. Conversely, the legacy collection types (like `ArrayList`
    and `Hashtable`) predate generics, so they implement only the nongeneric `IEnumerable`
    interface. Accordingly, they don’t enforce a single, common type, and they’re
    generally regarded as enumerable collections rather than sequences.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有 .NET 中的主要集合类型都是序列。例如，泛型集合类型（如 `Dictionary<'TKey, 'TValue>` 和 `List<'T>`），甚至一些通常不被视为集合的类型（如
    `String`）也实现了 `IEnumerable<'T>`。相反，遗留集合类型（如 `ArrayList` 和 `Hashtable`）早于泛型推出，因此它们只实现了非泛型的
    `IEnumerable` 接口。因此，它们并不强制执行单一的公共类型，通常被视为可枚举集合，而非序列。
- en: 'In F#, `IEnumerable<''T>` is often expressed as `seq<''T>` or `''T seq`. Type
    annotations like `values : ''A seq` compile to `IEnumerable<''A>`, and any type
    that implements `IEnumerable<''T>` can be used wherever a sequence is expected.
    Because `I Enumerable<''T>` defines only the overloaded `GetEnumerator` method,
    sequences are inherently immutable. Be careful when using the specific collection
    types directly, however, because underlying implementations may be mutable.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '在 F# 中，`IEnumerable<''T>`通常表示为`seq<''T>`或`''T seq`。像`values : ''A seq`这样的类型注解会被编译成`IEnumerable<''A>`，任何实现了`IEnumerable<''T>`的类型都可以在预期序列的地方使用。不过要小心直接使用具体的集合类型，因为底层实现可能是可变的。'
- en: Creating Sequences
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建序列
- en: Today’s .NET developers take working with sequences for granted, but before
    LINQ’s introduction, programming directly against `IEnumerable<'T>` was relatively
    rare. Instead, developers typically coded against specific collection types. LINQ’s
    `IEnumerable<'T>` extension methods brought the abstraction to the forefront,
    though, and taught developers that they didn’t always need to know anything about
    a collection other than that it implements the `GetEnumerator` method. Even with
    all of the goodness that LINQ gives us, it provides only a framework for working
    with `IEnumerable<'T>`; creating arbitrary sequences in LINQ still requires a
    method to create an instance of a specific sequence type.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的 .NET 开发人员已经习惯了与序列打交道，但在 LINQ 引入之前，直接对 `IEnumerable<'T>` 进行编程相对较为罕见。开发人员通常会针对特定的集合类型编写代码。尽管如此，LINQ
    的 `IEnumerable<'T>` 扩展方法将这一抽象推到了前台，教会了开发人员，他们并不总是需要知道集合的任何信息，除了它实现了 `GetEnumerator`
    方法。即便 LINQ 带来了所有的便利，它也仅仅是为操作 `IEnumerable<'T>` 提供了一个框架；在 LINQ 中创建任意序列仍然需要一个方法来实例化特定的序列类型。
- en: F# takes the abstraction even further than LINQ by codifying sequence creation
    into the language through concepts like sequence and range expressions. While
    each sequence is ultimately still an implementation of `IEnumerable<'T>`, the
    compiler is free to provide its own implementations. The `Seq` module also includes
    several functions for creating new sequences.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: F#通过像序列和范围表达式这样的概念，进一步将序列创建的抽象化，超越了LINQ的范畴。尽管每个序列最终仍然是`IEnumerable<'T>`的实现，编译器可以自由地提供自己的实现。`Seq`模块还包括多个函数，用于创建新的序列。
- en: Sequence Expressions
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 序列表达式
- en: '*Sequence expressions* allow you to create new sequences by iteratively applying
    other F# expressions and *yielding* (returning) the results into a new sequence.
    In some situations, particularly when you are working with large or computationally
    expensive collections, the sequence types used internally by sequence expressions
    are preferable to other collection types because they create values only as needed.
    These sequence types typically also hold only one value in memory at a time, making
    them ideal for large data sets.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列表达式*允许你通过反复应用其他F#表达式并*生成*（返回）结果到一个新序列中，从而创建新的序列。在某些情况下，特别是当你处理大型或计算开销大的集合时，序列表达式内部使用的序列类型比其他集合类型更为合适，因为它们只在需要时才会创建值。这些序列类型通常也一次只在内存中存储一个值，因此它们非常适合处理大型数据集。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Sequence expressions are technically a built-in workflow called a* computation
    expression*. We’ll cover these constructs in detail in [Chapter 12](ch12.html
    "Chapter 12. Computation Expressions").*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列表达式从技术上讲是一种内置的工作流，称为*计算表达式*。我们将在[第12章](ch12.html "第12章：计算表达式")中详细介绍这些构造。*'
- en: 'You create a sequence expression by enclosing one or more expressions within
    a sequence builder and using a `do` binding in conjunction with the `yield` keyword.
    For example, say you have a file named *ArnoldMovies.txt* that contains the following
    data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将一个或多个表达式封装在序列构建器内，并使用`do`绑定配合`yield`关键字来创建一个序列表达式。例如，假设你有一个名为*ArnoldMovies.txt*的文件，其中包含以下数据：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can read each line of the text file into a sequence with a sequence expression
    like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用如下的序列表达式将文本文件中的每一行读入一个序列：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, a `while` loop is used to iteratively read lines from a `StreamReader`,
    yielding a line for each iteration. (In some simpler sequence expressions—such
    as those using an enumerable `for` loop—`do yield` can be replaced with the `->`
    operator, but for consistency I usually stick with `do yield`.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，使用`while`循环反复从`StreamReader`读取每一行，并在每次迭代时返回一行。（在某些简单的序列表达式中，例如使用可枚举的`for`循环时，`do
    yield`可以用`->`运算符替代，但为了保持一致性，我通常使用`do yield`。）
- en: 'If you wanted to write this sequence to the console, you could send it to the
    `printfn` function and use the default formatter (via the `%A` token), but only
    the first four values are included in the output, as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将这个序列写入控制台，你可以将它传递给`printfn`函数并使用默认格式化器（通过`%A`标记），但只会输出前四个值，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To print every value in the sequence, you need to force enumeration over the
    entire construct.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印序列中的每个值，你需要强制对整个构造进行枚举。
- en: Range Expressions
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围表达式
- en: 'Although *range expressions* resemble the slice expressions you learned about
    in [Chapter 4](ch04.html "Chapter 4. Staying Objective") in that they use the
    `..` operator, they’re actually specialized sequence expressions that allow you
    to create sequences over a range of values. Range expressions are similar to the
    `Enumerable.Range` method but are a bit more powerful because they’re not restricted
    to integers. For instance, you can easily create a sequence containing the integers
    0 through 10 like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*范围表达式*在形式上类似于你在[第4章](ch04.html "第4章：保持目标导向")中学到的切片表达式，因为它们使用`..`运算符，但它们实际上是专门的序列表达式，允许你在一个值的范围内创建序列。范围表达式类似于`Enumerable.Range`方法，但它们更强大，因为它们不限于整数。例如，你可以像这样轻松创建一个包含从0到10的整数的序列：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or you could create a sequence containing 0 through 10 as floats this way:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过以下方式创建一个包含从0到10的浮点数的序列：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Likewise, you could create a sequence containing the characters *a* through
    *z* like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以像这样创建一个包含字符*a*到*z*的序列：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In most cases, you can also include a value that identifies how many items
    to skip between values when generating the sequence. Creating a sequence containing
    the integral multiples of 10 from 0 through 100 is easy with the following expression:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您还可以包括一个值，用于标识生成序列时要跳过多少个值。例如，使用以下表达式创建一个包含从0到100的10的倍数的序列是很容易的：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This range expression form works only with numeric types, so you can’t use it
    with character data. For example, the following expression results in an error.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种范围表达式形式仅适用于数值类型，因此不能与字符数据一起使用。例如，以下表达式会导致错误。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, you can create sequences with declining values by using a negative
    step value like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过使用负步长值来创建一个值递减的序列，如下所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Empty Sequences
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空序列
- en: 'When you need a sequence without any elements, you can turn to the `Seq`module’s
    generic `empty` function to create one for you. For instance, to create an empty
    string sequence, you could call `Seq.empty` like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个没有任何元素的序列时，可以使用`Seq`模块的通用`empty`函数来创建。例如，创建一个空字符串序列，你可以像这样调用`Seq.empty`：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, if you don’t need any particular type, you can let the compiler
    automatically generalize the sequence by omitting the type argument:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不需要特定的类型，可以通过省略类型参数，让编译器自动推断序列类型：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Initializing a Sequence
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化序列
- en: 'Another module function, `Seq.init`, creates a sequence with up to a specified
    number of elements. For example, to create a sequence containing 10 random numbers,
    you could write:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个模块函数，`Seq.init`，可以创建一个包含最多指定数量元素的序列。例如，要创建一个包含10个随机数的序列，你可以这样写：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Working with Sequences
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作序列
- en: The `Seq` module provides a number of functions for working with any sequence.
    The list of functions covered next is a sampling of the most useful functions
    in the `Seq` module, but it is by no means comprehensive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq`模块提供了许多用于操作任何序列的函数。接下来将介绍的函数列表是`Seq`模块中最有用的一些函数，但并不全面。'
- en: While each of the functions discussed in the coming sections belongs to the
    `Seq` module, many have specialized counterparts in the other collection modules.
    In the interest of space, I’ll cover the common functions only once, but I strongly
    encourage you to explore the other modules and discover the right tools for your
    task.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然接下来讨论的每个函数都属于`Seq`模块，但许多函数在其他集合模块中也有专门的对应函数。为了节省篇幅，我只会讲解常见的函数，但我强烈鼓励你探索其他模块，并发现适合你任务的工具。
- en: When is a Function Not a Function?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候函数不是一个函数？
- en: You may have noticed in both of the empty sequence examples that `Seq.empty`
    was invoked without any arguments. `Seq.empty` differs from every function we’ve
    encountered so far in that it behaves more like a basic value binding than a function.
    In fact, if you were to call `Seq.empty` with an argument, you’d get a compiler
    error telling you that the value (`Seq.empty`) is not a function and cannot be
    applied.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在两个空序列示例中，`Seq.empty`都没有传入任何参数。`Seq.empty`与我们迄今为止遇到的每个函数不同，它更像是一个基本的值绑定，而不是一个函数。事实上，如果你传入一个参数调用`Seq.empty`，你会得到一个编译器错误，提示你该值（`Seq.empty`）不是一个函数，不能被应用。
- en: Why is `Seq.empty` called a function when the compiler claims otherwise? Because
    it, along with some other functions (such as `Operators.typeof` and `Operators.typedefof`),
    is a special-case value called a *type function*. Type functions are generally
    reserved for pure functions that compute values based on their type arguments,
    and therefore—despite being represented as methods in the compiled assemblies—they
    are treated as values within F# code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`Seq.empty`被称为一个函数，而编译器却声称不是？因为它与一些其他函数（如`Operators.typeof`和`Operators.typedefof`）一起，是一个特殊情况值，称为*类型函数*。类型函数通常保留给那些根据其类型参数计算值的纯函数，因此——尽管它们在编译后的程序集里表现为方法——它们在F#代码中仍然被视为值。
- en: Finding Sequence Length
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找序列长度
- en: 'You use `Seq.length` to determine how many elements a sequence contains like
    this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用`Seq.length`来确定序列包含多少个元素：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Be careful with `Seq.length`, though, because, depending on the underlying
    collection type, it can force enumeration of the entire sequence or otherwise
    impair performance. Consider the following code, which checks if a sequence is
    empty using `Seq.length = 0`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不过要小心使用`Seq.length`，因为根据底层集合类型，它可能会强制枚举整个序列，或者以其他方式影响性能。考虑以下代码，它使用`Seq.length
    = 0`检查序列是否为空：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To determine the sequence’s length, the system must iterate over the sequence
    by calling the enumerator’s `MoveNext` method until it returns `false`. Each invocation
    of `MoveNext` involves doing whatever work is necessary to obtain the next value.
    In this case, getting the next value involves writing a string to the console,
    as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定序列的长度，系统必须通过调用枚举器的 `MoveNext` 方法来遍历序列，直到它返回 `false`。每次调用 `MoveNext` 都涉及执行获取下一个值所需的任何工作。在这个例子中，获取下一个值涉及将字符串写入控制台，如下所示：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Writing some text to the console is trivial, but even so, it is unnecessary
    work since the result isn’t actually being used for anything. Going beyond this
    simple example, you can easily imagine each call to `MoveNext` triggering an expensive
    computation or database call. If you just need to determine whether the sequence
    has any elements, you should use the `Seq.isEmpty` function instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 向控制台写入一些文本是微不足道的，但即便如此，这仍然是多余的工作，因为结果实际上并没有被用于任何地方。如果超出这个简单的例子，你可以很容易地想象每次调用
    `MoveNext` 都会触发一个昂贵的计算或数据库调用。如果你只需要确定序列是否有元素，你应该使用 `Seq.isEmpty` 函数。
- en: '`Seq.isEmpty` checks whether a sequence contains any elements without forcing
    enumeration of the entire sequence. Consider the following code, which replaces
    `Seq.length = 0` with `Seq.isEmpty`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.isEmpty` 检查一个序列是否包含任何元素，而不需要强制遍历整个序列。考虑以下代码，它将 `Seq.length = 0` 替换为 `Seq.isEmpty`：'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because `Seq.isEmpty` returns `false` as soon as it finds an element, `MoveNext`
    is called only once, resulting in:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Seq.isEmpty` 一旦找到元素就会返回 `false`，所以 `MoveNext` 只会被调用一次，结果是：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, although the sequence expression defines 10 elements, only the
    first one was printed because evaluation stopped as soon as the function found
    a value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管序列表达式定义了 10 个元素，但只有第一个被打印，因为一旦函数找到一个值，评估就停止了。
- en: Iterating over Sequences
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历序列
- en: 'The `Seq.iter` function is the functional equivalent of the enumerable `for`
    loop in that it iterates over a sequence, applying a function to each element.
    For example, to print each element of a sequence containing the values 0 through
    99, you could write:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.iter` 函数是功能等价于可枚举 `for` 循环的函数，它遍历一个序列，并对每个元素应用一个函数。例如，要打印一个包含从 0 到 99
    的值的序列中的每个元素，你可以这样写：'
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Transforming Sequences
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转换序列
- en: '`Seq.map` is similar to `Seq.iter` in that it applies a function to every element
    in a sequence, but unlike `Seq.iter`, it builds a new sequence with the results.
    For instance, to create a new sequence containing the squares of elements from
    a sequence, you could write:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.map` 类似于 `Seq.iter`，它将一个函数应用于序列中的每个元素，但与 `Seq.iter` 不同的是，它会用结果构建一个新的序列。例如，要创建一个新的序列，其中包含来自序列的元素的平方，你可以这样写：'
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Sorting Sequences
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序序列
- en: The `Seq` module defines several functions for sorting sequences. Each sorting
    function creates a new sequence, leaving the original unchanged.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq` 模块定义了几个排序序列的函数。每个排序函数都会创建一个新的序列，原始序列保持不变。'
- en: 'The simplest sorting function, `Seq.sort`, orders the elements using a default
    comparison based on the `IComparable<''T>` interface. For instance, you can apply
    `Seq.sort` to a sequence of random integer values like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的排序函数 `Seq.sort` 使用基于 `IComparable<'T>` 接口的默认比较方式对元素进行排序。例如，你可以将 `Seq.sort`
    应用于一组随机整数序列，如下所示：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For more complex sorting needs, you can use the `Seq.sortBy` function. In addition
    to the sequence to be sorted, it accepts a function that returns the value to
    sort upon for each element in the sequence.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的排序需求，你可以使用 `Seq.sortBy` 函数。除了需要排序的序列外，它还接受一个函数，该函数返回用于排序的每个元素的值。
- en: 'For example, each movie listed in *ArnoldMovies.txt* in [Sequence Expressions](ch06.html#sequence_expressions
    "Sequence Expressions") included the release year. If you wanted to sort the movies
    by their release years, you could revise the sequence expression to isolate the
    individual values as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*ArnoldMovies.txt* 中列出的每部电影在 [序列表达式](ch06.html#sequence_expressions "Sequence
    Expressions") 中都包含上映年份。如果你想按上映年份排序这些电影，你可以修改序列表达式，提取出各个值，如下所示：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At ① the sequence expression now yields *tuples* containing each movie title
    and release year. We can send the sequence to `Seq.sortBy` along with the `snd`
    function (to get the year) like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ① 处，序列表达式现在返回包含每部电影标题和上映年份的*元组*。我们可以将序列与 `snd` 函数（获取年份）一起发送到 `Seq.sortBy`，如下所示：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Alternatively, to sort the movies by title, you can replace `snd` with `fst`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了按标题排序电影，你可以将 `snd` 替换为 `fst`。
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Filtering Sequences
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤序列
- en: 'When you want to work only with elements that meet certain criteria, you can
    use the `Seq.filter` function to create a new sequence containing only those elements.
    For example, continuing with the movie theme, you can get the movies released
    prior to 1984 like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只希望处理符合特定条件的元素时，可以使用 `Seq.filter` 函数来创建一个只包含符合条件的元素的新序列。例如，继续使用电影主题，你可以像这样获取
    1984 年之前上映的电影：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Aggregating Sequences
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚合序列
- en: 'The `Seq` module provides a number of functions for aggregating the elements
    in a sequence. The most flexible (and complex) of the aggregation functions is
    `Seq.fold`, which iterates over a sequence, applying a function to each element
    and returning the result as an accumulator value. For example, `Seq.fold` makes
    it easy to compute the sum of a sequence’s elements:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq` 模块提供了多个函数，用于聚合序列中的元素。最灵活（也是最复杂）的聚合函数是 `Seq.fold`，它遍历序列，对每个元素应用一个函数，并将结果作为累加器值返回。例如，`Seq.fold`
    使得计算序列元素之和变得非常简单：'
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This example shows just one way to add the values 1 through 10\. The function
    that `Seq.fold` uses for aggregation ① accepts two values: an aggregation value
    (essentially a running total), and the current element. We also need to give the
    `fold` function an initial aggregation value ②, which we do with `0`. As `fold`
    executes, it applies the aggregation function to each element in the sequence
    and returns the new aggregation value for use in the next iteration.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何以一种方式将 1 到 10 的值相加。`Seq.fold` 用于聚合的函数①接受两个值：一个聚合值（本质上是一个累加总和），以及当前元素。我们还需要给
    `fold` 函数提供一个初始聚合值②，通常用 `0` 来表示。随着 `fold` 的执行，它会将聚合函数应用到序列中的每个元素，并返回新的聚合值以供下一次迭代使用。
- en: 'Because the addition operator function itself satisfies the requirements for
    the aggregation function, we can simplify the previous expression like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加法运算符本身满足聚合函数的要求，我们可以像这样简化之前的表达式：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A slightly more specialized aggregation function is `Seq.reduce`. The `reduce`
    function is very much like the `fold` function except that the aggregation value
    that’s passed through the computation is always the same type as the sequence’s
    elements, whereas `fold` can transform the data to another type. The `reduce`
    function also differs from `fold` in that it doesn’t accept an initial aggregation
    value. Instead, `reduce` initializes the aggregation value to the first value
    in the sequence. To see `Seq.reduce` in action, we can rewrite the previous expression
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更为专门的聚合函数是 `Seq.reduce`。`reduce` 函数与 `fold` 函数非常相似，不同之处在于传递给计算的聚合值始终与序列的元素类型相同，而
    `fold` 可以将数据转换为其他类型。`reduce` 函数与 `fold` 的另一个区别是，它不接受初始聚合值。相反，`reduce` 会将聚合值初始化为序列中的第一个值。为了看到
    `Seq.reduce` 的实际效果，我们可以将之前的表达式改写如下：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As expected, the result of adding the items in the sequence is the same regardless
    of whether we use `Seq.fold` or `Seq.reduce`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，不论是使用 `Seq.fold` 还是 `Seq.reduce`，序列中元素相加的结果是相同的。
- en: '`Seq.fold` and `Seq.reduce` aren’t the only ways to calculate aggregate values
    from a sequence; some common aggregations like summations and averages have functions
    of their own. For example, rather than using `Seq.reduce` to calculate the sum
    of the elements like we did previously, we can use `Seq.sum`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.fold` 和 `Seq.reduce` 并不是计算序列聚合值的唯一方法；一些常见的聚合操作，如求和和平均数，已经有了专门的函数。例如，我们可以使用
    `Seq.sum` 来计算元素的总和，而不必像之前那样使用 `Seq.reduce`：'
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, to compute the average, you can use `Seq.average` like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，要计算平均数，可以像这样使用 `Seq.average`：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One thing to note about `Seq.average` is that it works only with types that
    support division by an integer. If you try to use it with a sequence of integers,
    you’ll receive the following error:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`Seq.average` 只适用于支持整数除法的类型。如果你尝试用一个整数序列来使用它，你会遇到如下错误：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Like `Seq.sort`, the `Seq.sum` and `Seq.average` functions have the `Seq.sumBy`
    and `Seq.averageBy` counterparts that accept a function that lets you identify
    which value should be used in the calculation. The syntax for these functions
    is the same as `Seq.sortBy`, so I’ll leave it to you to experiment a bit more
    with the `Seq` module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `Seq.sort` 类似，`Seq.sum` 和 `Seq.average` 函数也有对应的 `Seq.sumBy` 和 `Seq.averageBy`
    函数，它们接受一个函数，让你指定应使用哪个值来进行计算。这些函数的语法与 `Seq.sortBy` 相同，因此我会留给你自己去多做一些关于 `Seq` 模块的实验。
- en: Arrays
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: F# arrays are the same construct as traditional .NET arrays. They contain a
    fixed number of values (each of the same type) and are zero-based. Although an
    array binding itself is immutable, individual array elements are mutable, so you
    need to be careful that you don’t introduce unwanted side effects. That said,
    the mutable nature of arrays makes them more desirable in some situations than
    other collection constructs because no further allocations are required to change
    element values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: F#数组和传统的.NET数组是相同的结构。它们包含固定数量的值（每个值的类型相同），并且是零索引的。尽管数组绑定本身是不可变的，但单个数组元素是可变的，因此你需要小心不要引入不必要的副作用。也就是说，数组的可变性在某些情况下使得它们比其他集合构造更具吸引力，因为改变元素值不需要进一步的内存分配。
- en: Creating Arrays
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数组
- en: F# provides a number of ways to create new arrays and control each element’s
    initial value, using both native syntax and module functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: F#提供了多种方式来创建新的数组，并控制每个元素的初始值，既可以使用原生语法，也可以使用模块函数。
- en: Array Expressions
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组表达式
- en: 'One of the most common ways to create an array is with an *array expression*.
    Array expressions consist of a semicolon-delimited list of values enclosed between
    the `[|` and `|]` tokens. For instance, you can create an array of strings like
    this (if you place each value on a separate line, you can omit the semicolons):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的最常见方式之一是使用*数组表达式*。数组表达式由一个以分号分隔的值列表组成，这些值被`[|`和`|]`标记包围。例如，你可以像这样创建一个字符串数组（如果每个值单独写在一行上，你可以省略分号）：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, you can generate an array by enclosing a sequence expression between
    `[|` and `|]`. Unlike with the sequence builder, however, the array will be fully
    constructed when the array expression is evaluated. Compare this example with
    the corresponding one from the sequence expression discussion:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过将一个序列表达式包含在`[|`和`|]`之间来生成一个数组。然而，与序列构造器不同的是，当数组表达式被求值时，数组将完全构造出来。将这个例子与序列表达式讨论中的对应例子进行比较：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the default array print formatter prints every element (it caps
    the output at 100 elements) rather than printing only the first four.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，默认的数组打印格式化器会打印每个元素（它将输出限制在100个元素），而不是仅打印前四个元素。
- en: Empty Arrays
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空数组
- en: 'Should you need to create an empty array, you can use an empty pair of square
    brackets:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个空数组，可以使用一对空的方括号：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The downside of this approach is that, depending on context, you may need to
    include a type annotation to ensure that the compiler doesn’t automatically generalize
    the array. Such a definition would look something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，根据上下文的不同，你可能需要添加类型注解，以确保编译器不会自动将数组泛化。这样的定义看起来可能是这样的：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, the type annotation, `int array`, is an English-like
    syntax. If you prefer a more traditional form, you could use `int[]` instead.
    Without the type annotation, the compiler would define the array as `'a []`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，类型注解`int array`是一种类似英语的语法。如果你更喜欢传统的形式，你也可以使用`int[]`。如果没有类型注解，编译器将把数组定义为`'a
    []`。
- en: 'Another way to create an empty array is with the `Array.empty` function. Just
    like its counterpart in the `Seq` module, `Array.empty` is a type function, so
    you invoke it without any arguments to create a zero-length array. To create an
    empty string array with this function, you simply write:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建空数组的另一种方式是使用`Array.empty`函数。和`Seq`模块中的对应函数一样，`Array.empty`是一个类型函数，因此你可以不带任何参数调用它来创建一个零长度的数组。要使用这个函数创建一个空的字符串数组，只需写：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you prefer to let the compiler infer the underlying type or automatically
    generalize it, you can omit the type parameter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意让编译器推断底层类型或自动泛化它，你可以省略类型参数。
- en: Initializing Arrays
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化数组
- en: 'To quickly create an array where all elements are initialized to the underlying
    type’s default value, you can use `Array.zeroCreate`. Suppose you know that you
    need an array of five strings, but you don’t yet know what values will be stored
    in each element. You could create the array like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想快速创建一个所有元素都初始化为基础类型默认值的数组，可以使用`Array.zeroCreate`。假设你知道需要一个包含五个字符串的数组，但还不知道每个元素中将存储什么值。你可以像这样创建这个数组：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because `Array.zeroCreate` uses the underlying type’s default value, it’s possible
    that the elements will be initialized to `null` like they were here. If `null`
    is valid for the type and you’re creating arrays like this, you’ll need to code
    against `NullReferenceException`s.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Array.zeroCreate`使用底层类型的默认值，因此可能会将元素初始化为`null`，就像这里一样。如果`null`对该类型有效，并且你正在像这样创建数组，那么你需要编写代码以防止`NullReferenceException`。
- en: 'Alternatively, `Array.init` lets you initialize each element to a specific
    value. `Array.init` is the array-specific equivalent of `Seq.init`. Its syntax
    is the same, but it creates and returns an array instead. For instance, to create
    a new array where the elements are initialized to the empty string, you could
    write:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`Array.init`允许你将每个元素初始化为特定值。`Array.init`是`Seq.init`的数组专用等价物。它的语法相同，但它创建并返回一个数组。例如，要创建一个新数组，其中的元素被初始化为空字符串，你可以这样写：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, the supplied function only returns the empty string, but your initialization
    function could easily have more complicated logic, allowing you to compute a different
    value for each element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，提供的函数仅返回空字符串，但你的初始化函数可以轻松地包含更复杂的逻辑，允许你为每个元素计算不同的值。
- en: Working with Arrays
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组
- en: Working with arrays in F# is similar to working with them in other .NET languages,
    but F# extends their usefulness with constructs like slice expressions and the
    `Array` module.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中使用数组与在其他.NET语言中使用它们类似，但F#通过诸如切片表达式和`Array`模块等构造扩展了数组的用途。
- en: Accessing Elements
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问元素
- en: 'Individual array elements are accessible through an indexed property. For instance,
    to retrieve the fourth element from the `lines` array defined previously, you’d
    write:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引属性可以访问单个数组元素。例如，要从之前定义的`lines`数组中检索第四个元素，你可以这样写：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can combine the indexer syntax with the assignment operator to change individual
    elements of an array. For instance, to replace *Last Action Hero*, you could write:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将索引器语法与赋值运算符结合，来改变数组的单个元素。例如，要替换*Last Action Hero*，你可以这样写：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you prefer a more functional approach to retrieving and mutating array elements,
    the `Array` module has you covered with the `get` and `set` functions. In the
    following example we’ll create an array, change the second element’s value, retrieve
    the new value, and write it to the console.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢以一种更函数式的方法来检索和修改数组元素，`Array`模块通过`get`和`set`函数提供了支持。在下面的示例中，我们将创建一个数组，改变第二个元素的值，检索新值，并将其输出到控制台。
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, arrays also support slice expressions. As noted in [Chapter 4](ch04.html
    "Chapter 4. Staying Objective"), slice expressions let you easily retrieve a range
    of values from a collection like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数组还支持切片表达式。如[第4章](ch04.html "第4章. 保持客观")中所述，切片表达式可以让你轻松地从集合中检索一系列值，像这样：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Copying Arrays
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制数组
- en: You can easily copy the elements from one array to a new array with `Array.copy`.
    Here, we create an array containing the numbers 1 through 10 and immediately copy
    them to another.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`Array.copy`轻松地将一个数组的元素复制到新数组中。在这里，我们创建一个包含数字1到10的数组，并立即将它们复制到另一个数组中。
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Behind the scenes, `Array.copy` is a wrapper around the CLR’s `Array.Clone`
    method, which creates a shallow copy of the source array. `Array.copy` offers
    the added benefit of automatically downcasting the object instance returned by
    `Clone` to the appropriate array type; that is, passing an integer array directly
    to `Array.Clone` will give you an `obj` instance, whereas passing that same array
    to `Array.copy` will give you an instance of `int array`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，`Array.copy`是对CLR的`Array.Clone`方法的封装，该方法创建源数组的浅拷贝。`Array.copy`提供了额外的好处，即自动将`Clone`返回的对象实例强制转换为适当的数组类型；也就是说，将一个整数数组直接传递给`Array.Clone`会得到一个`obj`实例，而将该数组传递给`Array.copy`则会得到一个`int
    array`实例。
- en: Sorting Arrays
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序数组
- en: Arrays can be sorted like any other sequence, but the `Array` module provides
    a few specialized sorting functions to take advantage of the fact that individual
    array elements are mutable. Unfortunately, each of these functions returns `unit`
    instead of the sorted array, so they’re not particularly effective in pipelining
    or composition chains.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以像其他序列一样进行排序，但`Array`模块提供了一些专门的排序函数，以利用单个数组元素是可变这一事实。不幸的是，这些函数中的每一个都会返回`unit`而不是排序后的数组，因此它们在管道或组合链中并不特别有效。
- en: The first in-place sorting function, `sortInPlace`, sorts an array with the
    default comparison mechanism. The following snippet shows how to sort an array
    of random integers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个就地排序函数`sortInPlace`使用默认比较机制对数组进行排序。下面的代码片段演示了如何对一组随机整数进行排序。
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you need more control over how sorting is performed, you can turn to the
    `sortInPlaceBy` or `sortInPlaceWith` functions. The `sortInPlaceBy` function lets
    you provide a transformation function that’s used in the sorting process. The
    `sortInPlaceWith` function accepts a comparison function that returns an integer
    where less than zero means the first value is greater than the second, greater
    than zero means that the first value is less than the second value, and zero means
    the first and second values are equal.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多的排序控制，您可以使用`sortInPlaceBy`或`sortInPlaceWith`函数。`sortInPlaceBy`函数让您提供一个转换函数，这个函数将在排序过程中使用。`sortInPlaceWith`函数接受一个比较函数，该函数返回一个整数，若小于零表示第一个值大于第二个值，若大于零表示第一个值小于第二个值，若等于零表示第一个和第二个值相等。
- en: To better understand both approaches, consider the following array containing
    some movies and their release years as tuples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这两种方法，考虑下面这个包含一些电影及其上映年份的元组数组。
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The easiest way to sort by year is to just project the year value via `sortInPlaceBy`
    like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 排序年份的最简单方法是通过`sortInPlaceBy`投影年份值，像这样：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, we can directly compare two elements with `sortInPlaceWith`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以直接使用`sortInPlaceWith`来比较两个元素：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, `sortInPlaceBy` allows you to sort according to the default
    equality semantics for a particular element’s underlying type, whereas `sortInPlaceWith`
    allows you to essentially define your own equality semantics for each element
    in the array.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`sortInPlaceBy`允许您根据特定元素底层类型的默认相等语义进行排序，而`sortInPlaceWith`则允许您为数组中的每个元素定义自己的相等语义。
- en: Multidimensional Arrays
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多维数组
- en: All of the arrays we’ve looked at so far have been one-dimensional. While it’s
    also possible to create multidimensional arrays, it’s a bit more complicated because
    there’s no direct syntactic support. For two-dimensional arrays, you can pass
    a sequence of sequences (typically either arrays or lists) to the `array2D` operator.
    To create arrays with more than two dimensions, you need to use either the `Array3D.init`
    or `Array4D.init` functions. Multidimensional arrays have modules (like `Array2D`
    and `Array3D`) that contain specialized subsets of those defined in the `Array`
    module.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有数组都是一维数组。虽然也可以创建多维数组，但由于没有直接的语法支持，这稍微复杂一些。对于二维数组，您可以将一个序列的序列（通常是数组或列表）传递给`array2D`运算符。要创建超过二维的数组，您需要使用`Array3D.init`或`Array4D.init`函数。多维数组有模块（如`Array2D`和`Array3D`），这些模块包含`Array`模块中定义的专门子集。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The maximum number of dimensions F# supports is four.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*F#支持的最大维度数是四。*'
- en: 'Suppose you wanted to represent the movies from the previous sections as a
    two-dimensional array instead of as an array of tuples. You could write something
    like the following, which passes an array of arrays to the `array2D` operator:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想将前面章节中的电影表示为一个二维数组，而不是元组数组。您可以写类似以下的代码，将一个数组的数组传递给`array2D`运算符：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can access any value in the two-dimensional array with the familiar indexer
    syntax. For instance, to get *Commando*’s release year you’d write **`movies.[2,
    1]`**, which would return `1985`. Much more interesting, though, is what you can
    do with slice expressions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用熟悉的索引器语法访问二维数组中的任何值。例如，要获取*Commando*的上映年份，您可以写**`movies.[2, 1]`**，这将返回`1985`。然而，更有趣的是，您可以通过切片表达式进行更多操作。
- en: 'Slice expressions make it easy to create new arrays containing subsets of data
    from the source. For instance, you can slice the `movies` array vertically to
    create new arrays containing only the movie titles or release years like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 切片表达式使得从源数组中创建包含子集的新数组变得非常容易。例如，您可以垂直切片`movies`数组，创建只包含电影名称或上映年份的新数组，像这样：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can also slice arrays horizontally to create new arrays containing only
    a few rows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以水平切片数组，创建只包含几行的新数组：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Multidimensional arrays are useful when the data has a nice, rectangular shape,
    but they don’t work when even a single row has a different number of items. Consider
    what happens if we try to include a director name in the two-dimensional `movies`
    array (for brevity, we’ll just work with three titles here).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组在数据具有良好的矩形形状时非常有用，但当哪怕只有一行的元素数量不同，它们就不适用了。考虑一下如果我们试图在二维`movies`数组中包含导演名会发生什么（为了简洁起见，这里我们只使用三个标题）。
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Of course, one possible solution would be to provide an empty string as the
    third element in the row that’s missing the director name. Alternatively, you
    can use a jagged array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一种可能的解决方案是为缺少导演名的行提供一个空字符串作为第三个元素。或者，你可以使用一个锯齿数组。
- en: Jagged Arrays
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锯齿数组
- en: '*Jagged arrays* are arrays of arrays. Unlike multidimensional arrays, jagged
    arrays don’t require a rectangular structure. To convert the preceding failing
    example, we just need to remove the call to the `array2D` function.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*锯齿数组*是数组的数组。与多维数组不同，锯齿数组不要求具有矩形结构。要转换前面的失败示例，我们只需要移除对`array2D`函数的调用。'
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you might expect, since `movies` is now a jagged array, you need to use
    a different syntax to access each element. You also need to code a bit more defensively
    when using jagged arrays because there’s no guarantee that a particular index
    will be valid for any given row. That said, you can get the director name from
    the second row like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预料到的，既然`movies`现在是一个锯齿数组，你需要使用不同的语法来访问每个元素。在使用锯齿数组时，你还需要编写更多的防御性代码，因为无法保证某个特定索引在任何给定的行中都是有效的。也就是说，你可以像这样从第二行获取导演的名字：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Any Way You Slice it
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你怎么切片
- en: F# 3.1 features a few extensions to array slicing that aren’t covered here but
    do prove useful. Array slicing in F# 3.0 requires slices to have the same dimensions
    as the source array. Under F# 3.1 this restriction has been removed, so you can
    create a one-dimensional slice from a two-dimensional array, and so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: F# 3.1版本新增了一些数组切片的扩展功能，这些功能在这里没有涉及，但确实很有用。在F# 3.0中，数组切片要求切片的维度与源数组相同。而在F# 3.1中，这一限制已被取消，因此你可以从一个二维数组中创建一维切片，依此类推。
- en: Lists
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: '*Lists* are used extensively in F# development. When .NET developers discuss
    lists, they typically mean the generic `List<''T>` class. Although it’s possible
    (and sometimes even desirable) to use the generic list in F#, the language defines
    another immutable construct based on singly linked lists. In F#, lists created
    with the list syntax compile to instances of the `FSharpList<''T>` class found
    in the `Microsoft.FSharp.Collections` namespace, and that’s the kind of list we’ll
    be covering in this section.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表*在F#开发中广泛使用。当.NET开发人员讨论列表时，他们通常指的是泛型`List<''T>`类。尽管在F#中使用泛型列表是可能的（有时甚至是可取的），但该语言定义了另一个基于单链表的不可变构造。在F#中，使用列表语法创建的列表会编译为`Microsoft.FSharp.Collections`命名空间中的`FSharpList<''T>`类的实例，这也是我们在本节中将要讨论的列表类型。'
- en: Aside from both `List<'T>` and `FSharpList<'T>` being generic sequence types
    (they both implement `IEnumerable<'T>)`, they have little in common and cannot
    be used interchangeably. You need to be careful to not mix list types when working
    in multilanguage solutions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`List<'T>`和`FSharpList<'T>`都是泛型序列类型（它们都实现了`IEnumerable<'T>`接口）外，它们几乎没有什么共同点，不能互换使用。在多语言解决方案中工作时，你需要小心不要混用这两种列表类型。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can use the generic `List<''T>` class directly by opening the `System.Collections.Generic`
    namespace or through the built-in `ResizeArray<''T>` type abbreviation.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过打开`System.Collections.Generic`命名空间或通过内置的`ResizeArray<''T>`类型缩写，直接使用泛型`List<''T>`类。*'
- en: Creating Lists
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建列表
- en: 'Creating lists in F# is so similar to creating arrays that I won’t spend much
    time explaining the various forms here. The only notable syntactic difference
    between creating arrays and lists is the brace style. To create a new list, you
    enclose semicolon-delimited values, range expressions, or list sequence expressions
    between square brackets (`[]`) like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中创建列表与创建数组非常相似，因此我不会花太多时间解释各种形式。创建数组和列表的唯一语法区别是括号样式。要创建一个新列表，你需要将分号分隔的值、范围表达式或列表序列表达式放在方括号（`[]`）中，像这样：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To create an empty list, you can use either `List.empty` or a pair of empty
    brackets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空列表，你可以使用`List.empty`或一对空的括号。
- en: Working with Lists
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表
- en: Although there are some similarities between working with F# lists and `List<'T>`,
    they’re mostly syntactic and deal with accessing individual known elements. Beyond
    that, F# lists are quite unique, especially because of their head and tail structure,
    which lends itself well to functional programming and to recursive techniques
    in particular.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在操作F#列表和`List<'T>`时有一些相似之处，但它们主要是语法上的，涉及访问单个已知元素。除此之外，F#列表非常独特，特别是它们的头尾结构，非常适合函数式编程，尤其是递归技术。
- en: Accessing Elements
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问元素
- en: 'When you want to get the element at a particular position, you can use the
    familiar indexer syntax just like you would with an array. Alternatively, you
    can use `List.nth` to get the same result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想获取某个特定位置的元素时，你可以使用熟悉的索引语法，就像操作数组一样。或者，你也可以使用`List.nth`来获得相同的结果：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'What’s more interesting (and often more useful) than accessing a particular
    element by index is a list’s *head* and *tail*. A list’s head is simply its first
    element, whereas its tail is all elements except the head. You can get a list’s
    head and tail through the `Head` or `Tail` properties or the `List.head` or `List.tail`
    module functions. Here’s an example using the module functions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 比通过索引访问特定元素更有趣（且通常更有用）的是列表的*头*和*尾*。列表的头是它的第一个元素，而它的尾是除了头以外的所有元素。你可以通过`Head`或`Tail`属性，或`List.head`和`List.tail`模块函数获取列表的头和尾。以下是使用模块函数的示例：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Pattern matching is another way to get the head and tail, but we’ll save that
    discussion for [Chapter 7](ch07.html "Chapter 7. Patterns, Patterns, Everywhere").*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式匹配是获取头部和尾部的另一种方式，但我们将把这个讨论留到[第7章](ch07.html "第7章。模式，无处不在")。*'
- en: Why would you want to get only the first element or everything else? Recursion.
    If you had to iterate over a list using indexes, you’d need to track both the
    list and the current position. By separating a list into head and tail components,
    you’re free to operate against the head and then iterate with the tail.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你只想获取第一个元素或其他所有元素？递归。如果你必须使用索引遍历列表，你需要同时跟踪列表和当前位置。通过将列表分成头和尾部分，你可以在操作头部分后继续递归遍历尾部分。
- en: Consider this function, which returns a Boolean value indicating whether a list
    contains a particular value (much like the `List.exists` module function).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数，它返回一个布尔值，指示一个列表是否包含特定的值（类似于`List.exists`模块函数）。
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `contains` function accepts both a function for testing the elements and
    a list to scan. The first thing `contains` does is check whether the supplied
    list is empty. If the list is empty, `contains` immediately returns `false`; otherwise,
    it tests the list’s head with the provided function or recursively calls `contains`
    with both the function and the list’s tail.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains`函数接受一个用于测试元素的函数和一个要扫描的列表。`contains`首先检查提供的列表是否为空。如果列表为空，`contains`会立即返回`false`；否则，它会使用提供的函数测试列表的头部，或者递归地调用`contains`，传入该函数和列表的尾部。'
- en: 'Now let’s test for a few values, starting with an empty list:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从一个空列表开始测试几个值：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can see that `contains` correctly returns `false` when the list is empty,
    but what about a populated list?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当列表为空时，`contains`正确地返回了`false`，但对于一个有元素的列表呢？
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `contains` function recursively walked the list, examining each element
    with the supplied function and passing the tail to `contains` if the element didn’t
    match.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains`函数递归地遍历列表，使用提供的函数检查每个元素，如果元素不匹配，就将尾部传递给`contains`。'
- en: Combining Lists
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并列表
- en: 'Even though F# lists are immutable, we can still construct new lists from existing
    ones. F# provides two primary mechanisms: the `cons` operator (`::`) and list
    concatenation with the `@` operator.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然F#列表是不可变的，但我们仍然可以从现有列表构造新列表。F#提供了两种主要机制：`cons`运算符（`::`）和通过`@`运算符进行的列表连接。
- en: 'The `cons` operator (so named because it *cons*tructs a new list) essentially
    prepends an item to an existing list like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`cons`运算符（之所以命名为`cons`，是因为它*构造*了一个新列表）本质上是将一个元素添加到现有列表的前面，如下所示：'
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `cons` operator doesn’t make any changes to the existing list. Instead,
    it simply creates a new list with its head set to the new value and tail set to
    the existing list. The `cons` operator can add only a single item to the list,
    but since it’s at the beginning of the list it’s a quick operation. If you want
    to combine two lists, you’ll need to turn to list concatenation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`cons` 操作符不会对现有列表进行任何更改。相反，它只是创建一个新的列表，头部设置为新值，尾部设置为现有列表。`cons` 操作符只能将单个项添加到列表中，但由于它位于列表的开头，因此是一个快速操作。如果你想合并两个列表，你需要使用列表连接。'
- en: 'To concatenate two lists, you can use either the list concatenation operator
    (`@`) or the `List.append` module function, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接两个列表，你可以使用列表连接操作符（`@`）或 `List.append` 模块函数，如下所示：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There’s no difference between the list created with the concatenation operator
    and the list created by `List.append`. Internally, `List.append` wraps the append
    operator so they’re functionally equivalent.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接操作符创建的列表与使用 `List.append` 创建的列表没有区别。从内部实现来看，`List.append` 封装了追加操作符，因此它们在功能上是等效的。
- en: 'To combine more than two lists at once, you can pass a sequence of lists to
    `List.concat` like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时合并多个列表，你可以像这样将一系列列表传递给 `List.concat`：
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, what started as three independent lists was combined into a single list
    containing each item.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最初的三个独立列表已经合并成一个包含每个项的单一列表。
- en: Sets
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: In F#, a *set* is an immutable collection of unique values whose order is not
    preserved. F# sets closely correlate to mathematical sets (think Venn diagrams)
    and provide a number of operations useful for comparing sets.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，*集合* 是一个不可变的唯一值集合，其顺序不被保留。F# 的集合与数学集合密切相关（可以参考维恩图），并提供许多有助于比较集合的操作。
- en: Creating Sets
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建集合
- en: 'There are no syntactic niceties like special bracket formats for creating sets,
    so if you want to use one, you’ll need to rely on either the type constructor
    or some of the `Set` module functions (like `Set.ofList`, which creates a set
    from an F# list). For instance, to create a set containing the letters of the
    alphabet, you could write:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集合时没有像特殊括号格式这样的语法糖，因此，如果你想使用集合，你需要依赖类型构造器或一些 `Set` 模块函数（如 `Set.ofList`，它可以从
    F# 列表创建集合）。例如，要创建一个包含字母表字母的集合，你可以这样写：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `Set<''T>` class defines methods to add and remove values from a set, but
    because F# sets are immutable, both of these methods return new sets and leave
    the original intact. The `Add` method can be useful for populating a new set from
    an empty one, like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set<''T>` 类定义了添加和移除集合中值的方法，但由于 F# 集合是不可变的，这两个方法都会返回新的集合，并保持原集合不变。`Add` 方法对于从空集合填充新集合非常有用，例如：'
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Of course, creating sets in this manner is a more object-oriented approach than
    is typical in F#.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，以这种方式创建集合比 F# 中典型的做法更加面向对象。
- en: Working with Sets
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合操作
- en: Because sets are so closely related to mathematical sets, the `Set` module provides
    several functions for performing a variety of set operations like finding unions,
    intersections, and differences, and even determining if two sets are related as
    subsets or supersets.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因为集合与数学中的集合关系密切，`Set` 模块提供了多个函数，用于执行各种集合操作，如查找并集、交集和差集，甚至可以确定两个集合是否作为子集或超集相关联。
- en: Unions
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 并集
- en: 'To find the union of two sets—that is, those elements contained within either
    the first or second set—you use the `Set.union` function as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到两个集合的并集——即包含在第一个或第二个集合中的那些元素——你可以使用如下的 `Set.union` 函数：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, `set1` contains the integers one through five, while `set2` contains the
    integers three through seven. Because the union of two sets contains each distinct
    value found in either set, the union of `set1` and `set2` is the range of integers
    from one through seven.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`set1` 包含整数一到五，而 `set2` 包含整数三到七。由于两个集合的并集包含在任一集合中找到的每个不同的值，`set1` 和 `set2`
    的并集是从一到七的整数范围。
- en: 'The `Set<''T>` class also defines a custom `+` operator you can use to find
    the union of two sets:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set<''T>` 类还定义了一个自定义的 `+` 操作符，可以用来找到两个集合的并集：'
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Intersections
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交集
- en: 'The `Set.intersect` function returns a new set containing only the elements
    found in both sets. For example, if you have a set containing the values one through
    five, and another set containing the values three through seven, you’d find the
    intersection like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set.intersect` 函数返回一个新集合，仅包含在两个集合中都存在的元素。例如，如果你有一个包含从一到五的元素的集合，另一个集合包含从三到七的元素，你可以这样找到交集：'
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The resulting intersection set contains only the three values common to both
    `set1` and `set2`—in this case, 3, 4, and 5.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 结果交集集合只包含`set1`和`set2`中共有的三个值——在本例中为3、4和5。
- en: Differences
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区别
- en: While the intersection contains all elements common to both sets, the difference
    contains those elements found only in the first set. You can find the difference
    between two sets with the `Set.difference` function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然交集包含两个集合共有的所有元素，但差集包含仅在第一个集合中找到的元素。你可以使用`Set.difference`函数来找到两个集合之间的差异。
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, the first set contains two elements not found in the second, `1` and `2`;
    therefore, the difference set contains only those values.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个集合包含第二个集合中没有的两个元素，`1`和`2`；因此，差集只包含这些值。
- en: Just as with intersections, the `Set<'T>` class defines a custom `–` operator
    that returns a set containing the difference between two sets.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就像交集一样，`Set<'T>`类定义了一个自定义的`–`运算符，该运算符返回一个包含两个集合差异的集合。
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Subsets and Supersets
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子集和超集
- en: 'The `Set` module makes it easy to determine whether two sets are related as
    subsets or supersets through four functions: `isSubset`, `isProperSubset`, `isSuperset`,
    and `isProperSuperset`. The difference between basic subset/superset and proper
    subset/supersets is that proper subsets/supersets require at least one additional
    element not present in the opposite set. The following sets illustrate:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`模块通过四个函数使我们容易判断两个集合是否存在子集或超集关系：`isSubset`、`isProperSubset`、`isSuperset`和`isProperSuperset`。基本子集/超集与真正子集/超集之间的区别在于，真正的子集/超集需要至少有一个在对方集合中不存在的额外元素。以下集合可以说明这一点：'
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Because both `set1` and `set2` contain the same values, `set1` can be considered
    a superset of `set2`. Conversely, `set2` can be considered a subset of `set1`.
    For the same reason, however, `set2` cannot be a proper subset of `set1`, as shown
    in the following snippet.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`set1`和`set2`包含相同的值，所以可以认为`set1`是`set2`的超集。相反，`set2`可以被认为是`set1`的子集。然而，基于同样的原因，`set2`不能是`set1`的真正子集，正如以下代码片段所示。
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: To make `set2` a proper subset of `set1`, we need to redefine `set1` to include
    at least one more value.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`set2`成为`set1`的一个真正子集，我们需要重新定义`set1`，使其至少包含一个额外的值。
- en: '[PRE70]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, if we test for subsets and supersets again, we should see that `set2` is
    both a subset and proper subset of `set1`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次测试子集和超集，我们应该会看到`set2`既是`set1`的子集，也是其真正子集。
- en: '[PRE71]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Maps
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: The `Map` type represents an unordered, immutable dictionary (a map of keys
    to values) and provides many of the same capabilities as the generic `Dictionary<'TKey,
    'TValue>` class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`类型表示一个无序的不可变字典（键到值的映射），并提供了与通用`Dictionary<''TKey, ''TValue>`类相同的许多功能。'
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Although the `Map<''Key`, `''Value>` class and the associated `Map` module
    provide methods for adding and removing entries, as an immutable construct, maps
    make sense only when the underlying entries won’t change. Adding and removing
    entries from a map requires creating a new map instance and copying the data from
    the source instance, so it is significantly slower than modifying a mutable dictionary.*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管`Map<''Key`, `''Value>`类和相关的`Map`模块提供了添加和移除条目的方法，但作为不可变构造体，只有在底层条目不会改变时，映射才有意义。从映射中添加和删除条目需要创建一个新的映射实例，并将数据从源实例复制过来，因此比修改可变字典要慢得多。*'
- en: Creating Maps
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建映射
- en: 'As with sets, F# doesn’t provide any direct syntactic support for creating
    maps, so the type constructor or `Map` module functions are required to create
    them, too. Regardless of the approach you choose, maps are always based on a sequence
    of tuples consisting of both the key and the mapped value. Here, a list of states
    and their respective capitals is passed to the type’s constructor:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合一样，F#不提供直接的语法支持来创建映射，因此也需要使用类型构造器或`Map`模块函数来创建它们。无论你选择哪种方式，映射总是基于一系列包含键和值的元组。在这里，我们将一个包含各州及其相应首府的列表传递给类型构造器：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Working with Maps
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用映射
- en: Because maps are like immutable dictionaries, interacting with them is similar
    to `Dictionary<'TKey, 'TValue>`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于映射类似于不可变字典，与它们交互的方式类似于`Dictionary<'TKey, 'TValue>`。
- en: Finding Values
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找值
- en: 'Like the generic dictionary, the `Map` type provides an indexed property for
    accessing a value via a known key. For instance, using the `stateCapitals` map,
    we can find Indiana’s capital like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用字典类似，`Map`类型提供了一个索引属性，通过已知键访问值。例如，使用`stateCapitals`映射，我们可以这样查找印第安纳州的首府：
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `Map.find` function lets us do the same thing functionally.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map.find`函数让我们通过函数式的方式做同样的事情。'
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The biggest problem with both of the preceding approaches is that they’ll throw
    a `KeyNotFoundException` when the key isn’t present in the map. To avoid the exception,
    you can see if the map contains a particular key with the `Map.containsKey` function.
    If you wanted to test whether `stateCapitals` included Washington, you could write
    this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前面两种方法的最大问题是，当映射中没有该键时，它们会抛出`KeyNotFoundException`。为了避免这种异常，你可以使用`Map.containsKey`函数来检查映射中是否包含某个特定键。如果你想测试`stateCapitals`是否包含华盛顿，可以写出如下代码：
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, if you prefer to test for the key and get the mapped value in a single
    operation you can turn to the `Map.tryFind` function, which returns an `option`
    indicating whether the key was found and the associated value, as shown here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你更倾向于通过单次操作来测试键并获取映射的值，你可以使用`Map.tryFind`函数，它返回一个`option`，指示是否找到键以及相关的值，如下所示：
- en: '[PRE76]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Finding Keys
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找键
- en: 'Occasionally, you may need to find a key based on its mapped value. The `Map`
    module provides two functions for this: `findKey` and `tryFindKey`. Like their
    value-finding counterparts, the difference between `findKey` and `tryFindKey`
    is that `findKey` throws `KeyNotFoundException` when it can’t find a value that
    satisfies the criteria, whereas `tryFindKey` does not.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要根据映射的值查找键。`Map`模块提供了两个函数来实现这一点：`findKey`和`tryFindKey`。就像它们的值查找对应函数一样，`findKey`和`tryFindKey`的区别在于，当无法找到符合条件的值时，`findKey`会抛出`KeyNotFoundException`，而`tryFindKey`则不会。
- en: 'To look up a key, you pass a function that accepts both the key and its mapped
    value and returns a Boolean indicating whether the value matches your criteria.
    For instance, to find a state by its capital using `Map.tryFindKey`, you could
    write:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找键，你需要传递一个接受键及其映射值的函数，并返回一个布尔值，指示值是否符合你的标准。例如，要通过首都查找一个州，可以使用`Map.tryFindKey`，你可以写出如下代码：
- en: '[PRE77]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see, `tryFindKey` returns an option, so you’ll need to test for `Some`
    and `None` accordingly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`tryFindKey`返回一个`option`，因此你需要根据`Some`和`None`进行相应的测试。
- en: Converting Between Collection Types
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在集合类型之间进行转换
- en: Sometimes you’ll have an instance of one collection type but you really need
    a different one. For instance, you might be working with an F# list but want to
    apply a function that works only with arrays. Each of the collection modules includes
    several functions that make converting between many of the other collection types
    easy.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会有一个集合类型的实例，但你实际上需要一个不同的类型。例如，你可能正在处理一个F#列表，但想要应用一个仅适用于数组的函数。每个集合模块都包含几个函数，可以轻松地在许多其他集合类型之间进行转换。
- en: 'In each module, the conversion functions are named according to the conversion
    direction and target type. For instance, to convert a sequence to an array, you
    could pass the sequence to either `Seq.toArray` or `Array.ofSeq` like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个模块中，转换函数的命名是根据转换方向和目标类型来命名的。例如，要将一个序列转换为数组，你可以将序列传递给`Seq.toArray`或`Array.ofSeq`，像这样：
- en: '[PRE78]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Similarly, to convert from a list to a sequence, you could pass the list to
    either `List.toSeq` or `Seq.ofList`. The `Set` and `Map` modules let you convert
    to and from sequences, arrays, and maps according to the same conventions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要将一个列表转换为序列，你可以将列表传递给`List.toSeq`或`Seq.ofList`。`Set`和`Map`模块也允许你根据相同的约定，在序列、数组和映射之间进行转换。
- en: 'Although most of the conversion functions create a new collection, some of
    them work by casting. For example, `Seq.ofList` simply casts the source list to
    `seq<''t>` (remember, `FSharpList<''T>` implements `IEnumerable<''T>`, so it’s
    a valid conversion), whereas `List.ofArray` creates a new array and populates
    it with the list’s values. If there’s ever a question as to whether the resulting
    collection is a type conversion or a new object, you can inspect them with the
    static `obj.ReferenceEquals` method as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数转换函数会创建一个新的集合，但其中一些通过类型转换工作。例如，`Seq.ofList`只是将源列表转换为`seq<'t>`（记住，`FSharpList<'T>`实现了`IEnumerable<'T>`，所以这是一个有效的转换），而`List.ofArray`则创建一个新的数组，并用列表的值填充它。如果有任何问题关于结果集合是类型转换还是新对象，你可以使用静态方法`obj.ReferenceEquals`来检查，如下所示：
- en: '[PRE79]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding snippet shows the result of calling both `Seq.ofList` and `List.ofArray`.
    You can see that ① `Seq.ofList` returns the same object, whereas `List.ofArray`
    ② returns a new object.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段展示了调用`Seq.ofList`和`List.ofArray`的结果。你可以看到，① `Seq.ofList`返回相同的对象，而`List.ofArray`②返回一个新的对象。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Working with data collections is something virtually every nontrivial application
    must do. F# lets you work with all of the traditional .NET collections like arrays
    and generic lists but also adds several other types like the F# list, sets, and
    maps, which are more suitable for functional programming.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据集合是几乎每个复杂应用程序都必须做的事情。F#让你能够使用所有传统的.NET集合，如数组和泛型列表，同时还添加了其他几种类型，比如F#列表、集合和映射，这些更适合函数式编程。
- en: In many regards, working with data collections in F# is more streamlined than
    in traditional .NET development because language features like sequence expressions,
    range expressions, and slice expressions make it easier to not only create collections,
    but also get at individual elements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，使用F#处理数据集合比传统.NET开发更加简化，因为像序列表达式、范围表达式和切片表达式这样的语言特性使得创建集合变得更容易，同时也能更方便地访问单个元素。
- en: Finally, the various collection modules like `Seq`, `Array`, and `List` provide
    an easy mechanism for performing many common tasks with their respective collection
    types.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像`Seq`、`Array`和`List`这样的各种集合模块提供了一种便捷的机制，可以在各自的集合类型上执行许多常见任务。
