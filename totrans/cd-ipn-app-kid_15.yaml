- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: '**GETTING BIRTHDAY NOTIFICATIONS**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**获取生日通知**'
- en: '![](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00001.jpg)'
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加*本地通知*来完善BirthdayTracker应用。本地通知是一种从应用程序发送到你手机的提醒，即使应用程序没有运行。BirthdayTracker应用将使用本地通知来提醒用户何时祝朋友生日快乐。
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户通知框架**'
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你使用苹果的Core Data框架将生日信息保存在手机的数据库中一样，你将使用苹果的用户通知框架向用户发送通知。使用这个框架非常简单！你只需要在处理用户通知的任何类的顶部添加一条import语句，如下所示：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用这个框架——*AddBirthdayViewController.swift，AppDelegate.swift*，和*BirthdaysTableViewController.swift*——因此请在每个文件中添加import
    UserNotifications语句，放在其他import语句下面。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让你的应用在某人生日时向用户请求发送通知的权限。如果没有通知权限，通知将不会发送。你可以通过让应用在应用委托中请求通知授权来获取权限。这需要在应用启动时进行，也就是应用完成启动时。幸运的是，AppDelegate类中有一个叫做application(_:didFinishLaunchingWithOptions:)的方法，我们可以利用它来完成这一操作。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在*AppDelegate.swift*文件的顶部添加了import UserNotifications语句。接下来，在application(_:didFinishLaunchingWithOptions:)方法中添加以下代码行，以请求权限发送本地通知。
- en: '*AppDelegate.swift*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第➊行获取当前的UNUserNotificationCenter并将其存储在一个名为center的常量中。*通知中心*用于安排和管理从应用程序发送的通知。在本章中，我们将使用UNUserNotificationCenter类中的三种方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:)用于请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:)请求添加一个新的通知以发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:)用于移除已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋处使用这些方法中的第一个，向用户请求授权让应用程序发送通知。我们将在本章后面使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 有两个参数：options 和 completionHandler。在
    options 参数中，你传入一个 UNAuthorizationOptions 数组，表示你希望在通知中使用的选项。你可以为通知使用四种 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项会在应用图标上添加一个徽标，方便用户快速看到应用中是否有新内容。通常这是一个数字，表示应用中有多少个新的或待处理的通知。sound
    选项会在通知发送到手机时播放声音。alert 选项会将通知显示为屏幕中央弹出的警报或从屏幕顶部滑下的横幅。作为应用开发者，你无法决定通知的显示方式或用户是否会为通知开启声音。这是用户在设置应用中控制的。第四个选项
    carPlay，允许在支持 CarPlay 的设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警报并在每个通知到来时播放声音，因此我们传入[.alert, .sound]作为我们的选项 ➌。completionHandler
    参数是一个闭包，在用户授予或拒绝允许应用发送通知后会被调用。completionHandler 闭包有两个参数，granted 和 error ➍。granted
    参数是一个布尔值，用来告诉你是否授予了权限（在这种情况下为 true）或拒绝了权限（false）。如果用户拒绝让我们发送通知，我们不会改变应用的行为，但我们会在控制台打印一条语句
    ➎，这样你就可以看到在测试应用时权限是否被授予或拒绝。第二个参数 error 是 Error 类类型，用来告诉你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知授权，用户第一次运行应用时，系统会显示一个警告对话框，询问他们是否允许应用发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用会向用户请求发送通知的权限。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在此选择“不允许”选项，他们将不会收到任何关于生日的通知。如果他们选择“允许”，则会收到通知。用户只会在首次安装应用后运行时被询问此问题。但他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到底部列出了 BirthdayTracker 应用，标签为*Birthdays*（[图 13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这个。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 深入查看BirthdayTracker应用的设置将引导用户进入通知设置屏幕（[图13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：在设置应用中，用户可以深入选择他们应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个界面上，用户可以指定是否希望看到应用的通知，以及他们希望看到什么类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，都希望安排一个通知，每年在生日人的生日当天发送。为了实现这一点，我们将在`AddBirthdayViewController`类的`saveTapped(_:)`方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，首先我们需要创建一个消息字符串，用于发送通知。我们的消息将是一个字符串，内容为：“祝firstName lastName今天生日快乐！”在生日保存后，在`saveTapped(_:)`方法中，在*AddBirthdayViewController.swift*文件中添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息内容，接下来需要创建并安排一条通知，这条通知将在用户朋友的生日时发送到用户的设备。首先，确保在文件顶部导入了UserNotifications。然后，在你刚写的消息常量下方添加以下代码：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码创建了一个`UNMutableNotificationContent`，并将其存储到一个名为`content`的常量中。`UNMutableNotificationContent`包含了用户通知的数据，比如消息或声音。➋处，我们将`content.body`属性设置为生日提醒消息`message`。然后在➌处，我们将`content.sound`设置为默认的通知声音，这个声音与接收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了通知内容之后，我们需要创建通知的*触发器*。触发器属于`UNCalendarNotificationTrigger`类，用于告诉应用何时以及多频繁地发送通知。我们将安排在每年生日时早上8点发送生日通知。Swift允许我们使用`Calendar`和`DateComponents`类获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，在设置content.sound之后创建一个触发器：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先我们通过使用Calendar方法`dateComponents(_:from:)`从birthDate中获取月份和日期的DateComponents。我们传入的是[.month,
    .day]作为组件➊，而不是年份。这是因为我们希望触发器每年都触发，而不仅仅是触发在那个人出生的年份——毕竟这个年份已经过去了，所以根本不可能触发！我们希望在早上8点发送生日通知，所以接下来我们将`dateComponents.hour`设置为8➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用初始化器创建 UNCalendarNotificationTrigger。这个初始化器有两个参数：日期组件和一个布尔值，表示是否希望触发器重复。我们希望触发器每年重复一次，因此传入
    true。Swift 会智能地处理触发器的重复频率。例如，如果你传入的 DateComponents 只有小时和分钟，它会在每天的相同小时和分钟触发通知。因为我们传入了月份和日期，触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和 DateComponents 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 日历和 DateComponents 类使创建日期和时间变得非常简单。DateComponents 具有可以设置的整数属性，用于日期和时间的年份、月份、日期、小时、分钟和秒，或者时间间隔。Calendar
    类有方法可以将 DateComponents 转换为 Date，或者将 Date 转换为 DateComponents。要尝试创建一个日期，请打开你的 Swift
    playground。我们将创建一个日期和时间，表示 1971 年 5 月 10 日，上午 8:23：
- en: '![](Image00264.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个变量叫做 myDateComponents ➊ ，它将用于创建我们的日期。在创建 myDateComponents 后，我们可以为其各种属性设置整数值。一年的月份都用数字表示，从1表示一月到12表示十二月。对于五月，我们将
    myDateComponents.month 设置为 5 ➋ 。对于上午8点，我们将 myDateComponents.hour 设置为 8 ➌ 。myDateComponents
    的属性使用24小时制，因此一天中的每个小时都按数字顺序标记，从0表示午夜开始。所以中午之前的小时数和12小时制相同，但对于下午2点，我们会在中午过后加上两小时，将
    myDateComponents 设置为 14。另一个例子，晚上11点应该是 23 。最后，我们可以通过在 Calendar 类中使用 date(from:)
    方法从 myDateComponents 创建一个日期 ➍ 。使用此方法之前，我们需要一个 Calendar 实例。我们使用 Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这是公历（格里高利历），它有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Date 获取 DateComponents，我们使用 Calendar 方法 myDateComponents(_:from:)。此方法有两个参数：第一个是你想从
    Date 中提取的 DateComponents 数组，第二个是 Date 本身。如果你想创建一个新的 Date 对象，例如表示今天8 AM 的日期，该方法非常有用。
- en: 'Write the following in your playground:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 playground 中编写以下代码：
- en: '![](Image00266.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其分配给一个名为 today 的常量。接下来，我们从 today ➋ 中获取用于表示月份、日期和年份的 myDateComponents。注意，我们只传入了我们关心的
    DateComponents 属性。例如，我们不需要小时、分钟或秒。我们将 myDateComponents 设置为变量而不是常量，因为我们将设置小时属性，这一操作发生在
    ➌ 处。最后，我们使用 myDateComponents 创建了一个新的日期，名为 todayEightAm ➍。你应该会看到，新的日期与 today 相同，只是时间是早上
    8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，我们几乎准备好创建一个 UNNotificationRequest 对象来调度通知了。但要创建 UNNotificationRequest，首先我们需要一个标识符。这个标识符是一个字符串，可以用来标识通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符来移除已经调度的通知，如果我们从应用中删除了一个生日。毕竟，你不想收到已删除的生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 12 章](text00023.html#ch12)中，我们为 Birthday 添加了一个 birthdayId 属性，因此我们将使用 birthdayId
    作为通知的标识符。首先，我们需要解包可选的 birthdayId 属性，并将其存储在一个名为 identifier 的常量中。然后，我们可以使用 identifier
    和 trigger 创建一个通知请求。将以下代码添加到创建 trigger 后：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用 identifier、content 和 trigger 创建了 UNNotificationRequest。创建 request
    后，它必须被添加到 UNUserNotificationCenter 中。为此，我们创建了一个名为 center 的常量 ➋，它表示应用的当前 UNUserNotificationCenter。接着，我们使用方法
    add(_:withCompletionHandler:) 将请求添加到我们调度的通知 ➌ 中。这个方法有两个参数，一个是 UNNotificationRequest，另一个是一个闭包作为
    completionHandler，用于在通知添加后执行某些操作。我们将 request 作为第一个参数传入，由于我们不需要在请求添加后做任何操作，我们将
    nil 传给 completionHandler。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写调度通知的方法！现在，如果你运行你的应用并创建生日对象，当有人的生日时，你将收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的通知，你需要为第二天添加一个生日，并等待直到早上 8 点才能看到通知出现。但等待一天来测试你的代码太长了！为了立即测试你的代码，修改它使得通知更早触发。将
    myDateComponents 的小时和分钟设置为当前时间的 10 分钟后。所以如果现在是下午 1:35，修改你刚才写的代码如下：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，添加一个今天日期的生日，通过点击停止按钮关闭应用（但保持模拟的 iPhone 窗口打开），然后等待 10 分钟。你应该会看到像[图 13-4](text00024.html#ch13fig4)中那样的通知出现。测试完成后，别忘了将代码改回原样，以便通知在早上第一时间弹出！
- en: '![](Image00267.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：一个横幅样式的生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中删除生日时，我们还希望取消其对应的通知，这可以通过在 BirthdaysTableViewController 中添加一些代码来实现。一个好地方是在用户选择要删除的生日后，`tableView(_:commitEditingStyle:forRowAtIndexPath:)`
    方法内。向该方法添加以下几行代码：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除生日的通知，首先我们解包 birthdayId 以便用它作为标识符 ➊ 。接下来，我们获取 UNUserNotificationCenter ➋
    并移除通知 ➌ 。remove 方法接受一个标识符数组，这样你可以一次移除多个通知，但由于我们只想移除一个，我们传入 [identifier]，这是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在已经完成！记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载，因此你可以将你的项目与其对比，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们向你展示了如何使用用户通知框架，向用户发送他们朋友生日的提醒。你学习了如何添加一个通知，它会在每年的特定时间发送，还学习了如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 部分](text00025.html#part03)中，你将构建另一个令人兴奋的应用——一个名为 Schoolhouse Skateboarder
    的游戏，它包含图形、声音等更多功能！
- en: '![](Image00268.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: '**GETTING BIRTHDAY NOTIFICATIONS**'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**获取生日通知**'
- en: '![](Image00001.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00001.jpg)'
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加*本地通知*来完成 BirthdayTracker。本地通知是从应用发送到手机的提醒，即使应用没有在运行。BirthdayTracker
    应用将使用本地通知来提醒用户何时祝朋友生日快乐。
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户通知框架**'
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你使用 Apple 的 Core Data 框架在手机上保存生日信息一样，你将使用 Apple 的 User Notifications 框架来向用户发送通知。使用这个框架很简单！你只需在任何处理用户通知的类的顶部添加一个导入语句，如下所示：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用该框架——*AddBirthdayViewController.swift, AppDelegate.swift,* 和 *BirthdaysTableViewController.swift*
    ——所以要在它们每个文件中添加 `import UserNotifications`，并放在其他导入语句下面。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让应用请求用户的权限，以便在有人过生日时发送通知。如果没有权限，通知将无法发送。你可以通过让应用在应用委托中请求通知授权来获得权限。这需要在应用启动时尽早完成，也就是在应用完成启动的时刻。幸运的是，AppDelegate
    类中有一个叫做 application(_:didFinishLaunchingWithOptions:) 的方法，我们可以用来实现这一点。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在 *AppDelegate.swift* 文件的顶部添加了 import UserNotifications。接着，在 application(_:didFinishLaunchingWithOptions:)
    中添加以下代码来请求发送本地通知的权限。
- en: '*AppDelegate.swift*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码获取当前的 UNUserNotificationCenter 并将其存储在一个名为 center 的常量中。*通知中心* 用来调度和管理你从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 会请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求将新的通知添加到用户设备中。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 用于移除已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➋ 处使用第一个方法请求用户授权应用发送通知。我们将在本章后面使用另外两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 方法有两个参数：options 和 completionHandler。在
    options 参数中，你传入一个包含你希望在通知中可用的 UNAuthorizationOptions 的数组。你可以为通知使用四种 UNAuthorizationOptions
    类型：badge、sound、alert 和 carPlay。badge 选项会在应用图标上添加一个徽章，用户可以快速看到应用中是否有新内容。通常这是一个数字，表示应用中有多少新的或待处理的通知。sound
    选项会在发送通知时播放一个声音。alert 选项会显示一个通知，可以是一个弹出的警告框，或者一个从屏幕顶部滑入的横幅。作为开发者，你无法决定通知如何显示，或者用户是否会开启通知声音。这个控制权在用户的设置应用中。第四个选项
    carPlay 允许在支持 CarPlay 的设备中显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知作为提醒显示给用户，并在每次收到通知时播放声音，因此我们将[.alert, .sound]作为选项传入➌。completionHandler参数是一个闭包，传入并在用户授予或拒绝应用发送通知的权限后被调用。completionHandler闭包有两个参数：granted和error
    ➍。granted参数是一个布尔值，告诉你是否已获得授权（如果是，则为true），如果被拒绝，则为false。我们不会更改应用程序的行为，如果用户拒绝允许我们发送通知，但我们会在控制台打印一条信息➎，这样你可以在测试应用时查看是否获得了授权。第二个参数error是Error类类型，告知你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知授权，当用户第一次运行应用时，它会显示一个提醒对话框，询问用户是否允许它发送通知，如[图13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：应用将请求用户授权发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”，他们将不会收到生日通知。如果选择“允许”，他们将收到通知。用户只会在应用首次运行（安装后首次启动时）时被询问此问题。然而，他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用部分时，他们会在列表底部看到名为*Birthdays*的BirthdayTracker应用（见[图13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 深入BirthdayTracker应用设置将引导用户进入通知设置界面（见[图13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：从设置应用中，用户可以深入设置应用的通知选项。*'
- en: '![](Image00262.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个界面上，用户可以指定是否希望看到应用的通知以及他们希望收到哪种类型的通知（横幅或提醒）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，我们希望安排每年在该生日人物的生日那天向我们发送通知。为此，我们将在AddBirthdayViewController类中的saveTapped(_:)方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，首先我们需要创建一个要发送的通知消息字符串。我们的消息将是一个字符串，内容为：“祝firstName lastName今天生日快乐！”在*AddBirthdayViewController.swift*中的saveTapped(_:)方法保存生日后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息，接下来需要创建并安排通知，以便在朋友的生日当天发送到用户的设备。首先，确保在文件的顶部导入了 UserNotifications。然后，在你刚刚写的
    message 常量下方添加以下代码：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处的代码创建了一个 UNMutableNotificationContent，并将其存储到名为 content 的常量中。UNMutableNotificationContent
    包含用户通知的数据，如消息或声音。在 ➋ 处，我们将 content.body 属性设置为名为 message 的生日提醒消息。然后，在 ➌ 处，我们将 content.sound
    设置为默认的通知声音，这与接收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建通知内容后，需要创建通知的 *触发器*。触发器属于 UNCalendarNotificationTrigger 类，告诉应用程序何时以及多频繁地发送通知。我们将安排生日通知在每年的个人生日早上
    8 点发送。Swift 让我们通过使用 Calendar 和 DateComponents 类，只获取触发日期的月和日。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 content.sound 后，添加以下代码来创建触发器：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先我们通过使用 Calendar 方法 `dateComponents(_:from:)` 从 birthDate 获取月和日的 DateComponents。我们只传入
    [.month, .day] 作为组件 ➊ ，而不包括年份。这是因为我们希望触发器每年都能触发，而不是只在个人出生的那一年触发——那已经是过去的事情，所以根本不会发生！我们希望在早上
    8 点发送生日通知，所以接下来我们将 dateComponents .hour 设置为 8 ➋ 。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用其初始化器创建了 UNCalendarNotificationTrigger。这个初始化器需要两个参数：dateComponents
    和一个布尔值，表示是否希望触发器重复。我们希望触发器每年都重复，所以传入了 true。Swift 会智能地处理触发器的重复频率。例如，如果你传入的 DateComponents
    只包含小时和分钟，它会每天在该小时和分钟触发通知。因为我们传入的是月份和日期，所以触发器每年都会重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**CALENDAR 和 DATECOMPONENTS 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar 和 DateComponents 类使得创建日期和时间变得非常容易。DateComponents 拥有可设置年份、月份、日期、小时、分钟和秒等整数属性，表示日期和时间，或者表示时间间隔。Calendar
    类有方法将 DateComponents 转换为 Date 或反之亦然。要尝试创建一个日期，可以打开你的 Swift Playground。我们将创建一个
    1971 年 5 月 10 日，早上 8:23 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 myDateComponents 的变量 ➊，它将用于创建我们的日期。创建 myDateComponents 后，我们可以为其各个属性设置整数。每年的月份都用整数表示，按数字顺序排列，从
    1 代表一月到 12 代表十二月。对于五月，我们将 myDateComponents.month 设置为 5 ➋。对于早上8点，我们将 myDateComponents.hour
    设置为 8 ➌。myDateComponents 的属性使用的是 24 小时制，因此每个小时都按数字顺序标记，午夜为 0。所以，所有中午之前的时间与 12
    小时制相同，但对于下午2点，我们将设置 myDateComponents 为 14，因为它是中午后的第二个小时。举个例子，晚上11点是 23。最后，我们可以通过使用
    Calendar 类的 date(from:) 方法从 myDateComponents 创建一个日期 ➍。为了使用这个方法，我们首先需要一个 Calendar
    实例。我们使用 Calendar.current，它返回设备当前使用的日历类型。在大多数西方国家，使用的是公历，它有 12 个月和 7 天一周。
- en: '![](Image00265.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个 Date 中获取 DateComponents，我们使用 Calendar 方法 myDateComponents(_:from:)。该方法接受两个参数：第一个是你想从
    Date 中提取的 DateComponents 数组，第二个是 Date 本身。如果你想创建一个新的 Date 对象，表示今天的日期但时间为早上8点，例如，myDateComponents(_:from:)
    方法会非常有用。
- en: 'Write the following in your playground:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 playground 中写下以下代码：
- en: '![](Image00266.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其赋值给一个名为 today 的常量。接下来，我们从 today 中提取出月、日和年的 myDateComponents
    ➋。注意，我们只传入我们关心的 DateComponents 属性。例如，我们不需要小时、分钟或秒。我们将 myDateComponents 设置为变量而不是常量，因为我们接下来会设置小时属性，这个操作发生在
    ➌ 处。最后，我们使用 myDateComponents 创建一个名为 todayEightAm 的新日期 ➍。你应该看到，新的 Date 与今天相同，只不过时间是早上
    8 点。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了通知内容和触发器，差不多可以创建一个 UNNotificationRequest 对象来安排通知了。但是，要创建 UNNotificationRequest，首先我们需要一个标识符。这是一个字符串，用来标识这个通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符，在我们从应用程序中删除生日时，移除已安排的通知。毕竟，你肯定不想为已经删除的生日接收到通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 12 章](text00023.html#ch12) 中，我们为 Birthday 添加了一个 birthdayId 属性，所以我们将使用 birthdayId
    作为通知的标识符。首先，我们需要解包可选的 birthdayId 属性，并将其存储在一个名为 identifier 的常量中。然后，我们可以使用 identifier
    和 trigger 来创建通知请求。创建 trigger 后，立即添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用标识符、内容和触发器来创建 UNNotificationRequest。创建请求后，它必须添加到 UNUserNotificationCenter
    中。为此，我们创建一个名为 center ➋ 的常量，它是应用程序当前的 UNUserNotificationCenter。然后，我们使用方法 add(_:withCompletionHandler:)
    将请求添加到我们计划的通知 ➌ 中。这个方法接受两个参数，一个是 UNNotificationRequest，另一个是一个闭包作为 completionHandler，它会在通知添加后执行某些操作。我们将请求作为第一个参数传入，由于我们不需要在请求添加后执行任何操作，所以将
    nil 作为 completionHandler 传入。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写调度通知的方法！现在，如果你运行应用并创建生日对象，当是某人的生日时，你就会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日，并等待到早上 8 点才能看到通知。然而，等待整整一天来测试代码太长了！为了立刻测试代码，可以调整代码使得通知更早触发。将
    myDateComponents 的小时和分钟设置为当前时间后的 10 分钟。所以，如果现在是下午 1:35，将你刚写的代码修改如下：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天的生日，点击停止按钮关闭应用（但保持模拟的 iPhone 窗口开启），等待 10 分钟。你应该会看到像 [图 13-4](text00024.html#ch13fig4)
    中的通知出现在屏幕上。测试完成后，别忘了将代码改回去，以确保通知在早上第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：生日通知的横幅样式*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中删除一个生日时，我们也希望取消其相应的通知，这可以在 BirthdaysTableViewController 中通过添加一些代码来实现。一个合适的位置是在用户选择删除生日后，在
    tableView(_:commitEditingStyle:forRowAtIndexPath:) 中。向该方法添加以下几行代码：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除生日通知，首先我们解包 birthdayId 并将其用作标识符 ➊。接下来，我们获取 UNUserNotificationCenter ➋ 并删除通知
    ➌。remove 方法接受一个标识符数组，因此你可以一次删除多个通知，但由于我们只想删除一个通知，所以我们传入 [identifier]，它是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在已经完成！记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取，因此你可以与自己的文件进行对比，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向你展示了如何使用用户通知框架，在用户朋友的生日时提醒他们。你学会了如何添加一个将在每年特定时间发送的通知，并且如果用户从应用中删除生日信息时，如何删除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 部分](text00025.html#part03)中，你将构建另一个令人兴奋的应用——一款名为 *Schoolhouse Skateboarder*
    的游戏，具有图形、声音等多种功能！
- en: '![](Image00268.jpg)![](Image00001.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)![](Image00001.jpg)'
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过添加*本地通知*来完成 BirthdayTracker。一个本地通知是从应用程序发送到你手机的提醒，即使应用程序没有运行。BirthdayTracker
    应用将使用本地通知来提醒用户何时给朋友送上生日祝福。
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户通知框架**'
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你使用 Apple 的 Core Data 框架在手机上保存生日信息一样，你将使用 Apple 的 User Notifications 框架来向用户发送通知。使用这个框架非常简单！你只需要在任何涉及用户通知的类的顶部添加一个导入语句，如下所示：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用该框架——*AddBirthdayViewController.swift、AppDelegate.swift* 和 *BirthdaysTableViewController.swift*——因此在每个文件中，需在其他导入语句下方添加
    `import UserNotifications`。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让你的应用请求用户授权，在别人生日时发送通知。如果没有获得通知权限，通知将不会发送。你可以通过在应用程序代理中请求通知授权来获取权限。这需要在应用启动时完成，也就是应用启动完成时。幸运的是，在
    AppDelegate 类中有一个方法叫做 `application(_:didFinishLaunchingWithOptions:)`，我们可以使用它来实现这一点。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在 *AppDelegate.swift* 文件的顶部添加了 `import UserNotifications` 语句。接着，在 `application(_:didFinishLaunchingWithOptions:)`
    方法中添加以下代码，以请求授权发送本地通知。
- en: '*AppDelegate.swift*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行获取当前的 `UNUserNotificationCenter` 并将其存储在一个名为 `center` 的常量中。*通知中心* 用于调度和管理你从应用中发送的通知。在本章中，我们将使用
    `UNUserNotificationCenter` 类的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAuthorization(options:completionHandler:)` 请求用户授权发送通知。'
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`add(_:withCompletionHandler:)` 请求向用户发送一个新的通知。'
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`removePendingNotificationRequests(withIdentifiers:)`用于移除已存在的通知。'
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋使用了这些方法中的第一个，要求用户授予应用发送通知的权限。我们将在本章后面使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`requestAuthorization(options:completionHandler:)`接受两个参数：options和completionHandler。在options参数中，您传入一个UNAuthorizationOptions数组，用于指定希望在通知中使用的选项。您可以为通知使用四种UNAuthorizationOptions：badge、sound、alert和carPlay。badge选项会在应用图标上添加一个徽章，用户可以快速看到应用中是否有新内容。通常这是一个数字，表示应用中有多少条新的或待处理的通知。sound选项会在发送通知到手机时播放声音。alert选项会将通知以警告的形式弹出在屏幕中央或以横幅的形式从屏幕顶部滑入。作为应用开发者，您无法决定通知的显示方式或用户是否开启通知声音，这些设置由用户在“设置”应用中控制。第四个选项carPlay允许在支持CarPlay的车载设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警告并在每次通知到来时播放声音，因此我们为options传入了[.alert, .sound] ➌。completionHandler参数是一个闭包，在用户授予或拒绝应用发送通知的权限后调用。completionHandler闭包有两个参数，granted和error
    ➍。granted参数是一个布尔值，指示是否授予了权限（如果为true，则表示授权；如果为false，则表示拒绝）。如果用户拒绝了通知权限，我们不会改变应用的行为，但我们会在控制台中打印一条信息
    ➎，以便在测试应用时查看权限是否被授予或拒绝。第二个参数error是Error类类型，指示是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经请求了通知授权，当用户第一次运行应用程序时，它会显示一个提示对话框，询问用户是否允许应用发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用将请求用户允许发送通知的权限。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择了“拒绝”选项，他们将不会收到关于人们生日的任何通知。如果选择“允许”，他们将收到通知。用户只会在应用程序第一次安装并运行时被问到这个问题。然而，他们可以随时在“设置”应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到一个名为*Birthdays*的生日追踪器应用程序列表项，位于列表底部（[图13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这个。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到`BirthdayTracker`应用设置后，用户将进入通知设置界面（[图13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：在设置应用中，用户可以逐步设置他们的应用通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：我们的应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个界面上，用户可以指定是否希望查看应用的通知，以及他们希望收到什么类型的通知（横幅或提醒）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**调度通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，都希望安排一个通知，每年在生日人的生日当天发送通知。为此，我们将在`AddBirthdayViewController`类的`saveTapped(_:)`方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，首先我们需要创建一个要发送到通知中的消息字符串。我们的消息将是一个字符串：“今天祝firstName lastName生日快乐！”在`saveTapped(_:)`方法中，保存生日后，紧接着添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息，接下来需要创建并安排一个通知，发送到用户设备上，在他们朋友的生日当天。首先，确保在文件顶部已经导入了`UserNotifications`。然后，在你刚写的消息常量下面添加以下代码：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第➊行创建了一个`UNMutableNotificationContent`，并将其存储到一个名为content的常量中。`UNMutableNotificationContent`包含用户通知的数据，例如消息或声音。在➋行，我们将content.body属性设置为名为message的生日提醒消息。然后，在➌行，我们将content.sound设置为默认通知声音，这与接收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知内容后，我们需要创建通知的*触发器*。触发器属于`UNCalendarNotificationTrigger`类，能够让应用知道何时以及多频繁地发送通知。我们将把生日通知安排为每年在生日当天的早上8点发送。Swift允许我们通过使用`Calendar`和`DateComponents`类，仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`content.sound`后，添加以下代码来创建一个触发器：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用日历方法 `dateComponents(_:from:)` 从 `birthDate` 获取月和日的 `DateComponents`。我们只传入
    [.month, .day] 作为组件 ➊ ，而不包括年份。这是因为我们希望每年都触发，而不仅仅是触发在那个人出生的年份——因为那是过去的年份，反正也不会发生！我们希望在早上8点发送生日通知，所以接下来我们将
    `dateComponents.hour` 设置为8 ➋ 。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ ，我们使用 `UNCalendarNotificationTrigger` 的初始化方法创建触发器。这个初始化方法接受两个参数：`dateComponents`
    和一个布尔值，表示是否希望触发器重复。我们希望触发器每年都重复，因此我们传入 `true`。Swift 会智能处理触发器的重复频率。如果你传入的只是小时和分钟的
    `DateComponents`，例如，它会在每天的那个小时和分钟触发通知。因为我们传入了月份和日期，所以触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**CALENDAR 和 DATECOMPONENTS 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar` 和 `DateComponents` 类使得创建日期和时间变得非常简单。`DateComponents` 有整数类型的属性，你可以为日期和时间的年份、月份、日期、小时、分钟和秒数设置这些属性，或者设置时间间隔。`Calendar`
    类有方法将 `DateComponents` 转换为 `Date`，或者反之亦然。要尝试创建一个日期，可以打开你的 Swift Playground。我们将创建一个
    1971年5月10日，早上8:23 的日期和时间：'
- en: '![](Image00264.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `myDateComponents` 的变量 ➊ ，我们将用它来创建日期。在创建了 `myDateComponents` 后，我们可以为其各种属性设置整数值。一年的月份都用按数字顺序排列的整数表示，从
    1 表示1月到 12 表示12月。对于 5 月，我们将 `myDateComponents.month` 设置为 5 ➋ 。对于早上8点，我们将 `myDateComponents.hour`
    设置为 8 ➌ 。`myDateComponents` 的属性使用24小时制，因此一天24小时的每个小时都按数字顺序标记，从午夜0点开始。所以中午之前的小时和12小时制一样，但对于下午2点，这是中午之后的两个小时，我们将其计为
    14 。再比如，晚上11点会是 23 。最后，我们可以使用 `Calendar` 类的 `date(from:)` 方法根据 `myDateComponents`
    创建一个日期 ➍ 。要使用这个方法，我们首先需要一个 `Calendar` 实例。我们使用 `Calendar.current`，它返回设备当前使用的日历类型。在大多数西方国家，使用的是公历（格里历），它有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Date中获取DateComponents，我们使用Calendar方法myDateComponents(_:from:)。此方法接受两个参数：第一个是你希望从Date中提取的DateComponents数组，第二个是Date本身。myDateComponents(_:from:)方法非常有用，如果你想创建一个新的Date对象，它表示今天的日期，但例如是在早上8点。
- en: 'Write the following in your playground:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的playground中写下以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码创建了当前的日期和时间，并将其分配给名为today的常量。接下来，我们从today中获取月份、日期和年份的myDateComponents➋。注意，我们只传入了我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒。我们将myDateComponents设置为变量而不是常量，因为我们将设置小时属性，这在➌处完成。最后，我们使用myDateComponents创建了一个新的日期对象todayEightAm
    ➍。你应该看到，新的Date与今天相同，唯一不同的是时间是早上8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通知内容和触发器，我们几乎准备好创建一个UNNotificationRequest对象来调度通知了。但是在创建UNNotificationRequest之前，我们首先需要一个标识符。这是一个可以用来标识通知的字符串。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从应用中删除生日，我们还将使用这个标识符来移除已调度的通知。毕竟，你不想收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们向Birthday添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包可选的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger创建一个通知请求。在trigger创建后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们使用identifier、content和trigger创建UNNotificationRequest。创建request后，它必须添加到UNUserNotificationCenter中。为此，我们创建一个名为center的常量➋，它是应用程序的当前UNUserNotificationCenter。然后，我们使用方法add(_:withCompletionHandler:)将请求添加到我们的已调度通知中➌。此方法接受两个参数，一个是UNNotificationRequest，另一个是一个闭包作为completionHandler，在通知添加后执行某些操作。我们将request作为第一个参数传入，既然我们在通知添加后不需要执行任何操作，我们将completionHandler传入nil。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写调度通知的方法！现在，如果你运行应用并创建Birthday对象，当某人过生日时，你会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的通知，你需要为第二天添加一个生日，并等到早上 8 点，等待通知出现。但等待整整一天来测试代码太长了！为了立刻测试代码，可以调整代码，让通知尽早弹出。将
    `myDateComponents` 的小时和分钟设置为距离当前时间 10 分钟。如果现在是下午 1:35，就将你刚才写的代码改为如下：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天的生日，点击停止按钮关闭应用（但保持模拟 iPhone 窗口开启），并等待 10 分钟。你应该会看到一个像 [图 13-4](text00024.html#ch13fig4)
    中的通知出现。测试完后，别忘了将代码改回，以便通知在早晨第一时间弹出！
- en: '![](Image00267.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：横幅式生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中移除一个生日时，我们也想取消其对应的通知，这可以通过在 BirthdaysTableViewController 中添加一些代码来实现。一个合适的地方是在用户选择删除生日后，即在
    `tableView(_:commitEditingStyle:forRowAtIndexPath:)` 方法中。将以下代码添加到该方法中：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除生日的通知，首先我们解包 `birthdayId` 以将其作为标识符 ➊。接着，我们获取 UNUserNotificationCenter ➋ 并移除该通知
    ➌。`remove` 方法接受一个标识符数组，这样你可以一次性移除多个通知，但由于我们只想移除一个，所以传入 `[identifier]`，这是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在已经完成！记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载，你可以与自己的项目进行对比，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向你展示了如何使用用户通知框架来提醒用户朋友的生日。你学会了如何添加一个每年特定时间发送的通知，也学会了如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 部分](text00025.html#part03) 中，你将构建另一个令人兴奋的应用——一款名为 Schoolhouse Skateboarder
    的游戏，其中包含图形、声音等更多内容！
- en: '![](Image00268.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们完成 BirthdayTracker，通过添加 *本地通知*。本地通知是一种由应用发送到手机的提醒，即使应用没有在运行。BirthdayTracker
    应用将使用本地通知来提醒用户何时祝朋友生日快乐。
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户通知框架**'
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你使用苹果的 Core Data 框架将生日数据保存在手机的数据库中一样，你将使用苹果的 User Notifications 框架发送通知给用户。使用这个框架非常简单！你只需要在处理用户通知的任何类的顶部添加一个
    import 语句，像这样：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用这个框架——*AddBirthdayViewController.swift, AppDelegate.swift,* 和 *BirthdaysTableViewController.swift*
    ——所以在每个文件的其他 import 语句下面添加 `import UserNotifications`。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让你的应用在有人过生日时请求用户许可发送通知。如果没有获得通知权限，通知将不会被发送。你可以通过在应用程序委托中请求授权来获得通知权限。这个操作需要在应用启动时进行，也就是应用完成启动后。幸运的是，AppDelegate
    类中有一个方法叫做 application(_:didFinishLaunchingWithOptions:) 我们可以用它来完成这个操作。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在 *AppDelegate.swift* 文件的顶部添加了 `import UserNotifications`。接下来，在 application(_:didFinishLaunchingWithOptions:)
    中添加以下几行代码，请求发送本地通知的权限。
- en: '*AppDelegate.swift*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码获取当前的 UNUserNotificationCenter，并将其存储在名为 center 的常量中。*通知中心* 用于安排和管理你从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类中的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一个新的通知，发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除一个已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➋ 处使用第一个方法，请求用户授权应用发送通知。我们将在本章稍后使用另外两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 方法requestAuthorization(options:completionHandler:)有两个参数：options和completionHandler。在options参数中，您传入一个包含所需通知选项的UNAuthorizationOptions数组。您可以为通知使用四种类型的UNAuthorizationOptions：badge、sound、alert和carPlay。badge选项会在应用图标上添加一个徽章，用户可以快速看到应用中是否有新内容。通常这是一个数字，表示应用中有多少个新的或等待的通知。sound选项会在通知发送到手机时播放声音。alert选项会以弹出警告的形式，或者以横幅的形式显示通知。作为应用开发者，您无法决定通知如何显示或用户是否打开通知的声音。这个由用户在“设置”应用中控制。第四个选项carPlay允许在支持CarPlay的设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警告，并在每个通知到达时播放声音，因此我们为我们的选项传递[.alert, .sound]➌。completionHandler参数是一个闭包，传入后会在用户授予或拒绝应用发送通知的权限时被调用。completionHandler闭包有两个参数，granted和error
    ➍。granted参数是一个布尔值，表示权限是否被授予（如果为true）或拒绝（如果为false）。如果用户拒绝让我们发送通知，我们不会改变应用的行为，但我们会在控制台打印一条语句➎，这样在测试应用时，您可以看到权限是否被授予或拒绝。第二个参数error是错误类类型，用于表示是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经请求了通知授权，用户首次运行应用时，它会显示一个弹出对话框，询问是否允许应用发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用会请求用户授权以发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在此处选择“不允许”选项，他们将不会收到关于他人生日的任何通知。如果他们选择“允许”，则会收到通知。用户仅在应用首次安装并运行时被询问此问题。然而，他们可以随时在“设置”应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开“设置”应用并滚动到应用部分时，他们会看到列表底部有一个名为*Birthdays*的BirthdayTracker应用条目（参见[图 13-2](text00024.html#ch13fig2)）。您也可以在模拟器中看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 BirthdayTracker 应用的设置会将用户引导到通知设置屏幕（[图 13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在“设置”应用中，用户可以深入设置应用的通知选项。*'
- en: '![](Image00262.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们的应用通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上，用户可以指定他们是否希望查看该应用的通知以及他们想要的通知类型（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建生日时，我们都希望每年在生日人的生日当天安排一个通知发送给我们。为此，我们将在 *AddBirthdayViewController* 类中的
    saveTapped(_:) 方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，首先我们需要创建一个消息字符串，将在通知中发送。我们的消息将是一个字符串：“祝 firstName lastName 今天生日快乐！”在 *AddBirthdayViewController.swift*
    的 saveTapped(_:) 方法中，生日保存后，立即添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息，需要创建并安排通知，在朋友的生日那天发送到用户的设备。首先，确保在文件顶部导入 UserNotifications。然后，在刚才写的消息常量下方添加以下代码：
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码创建了一个 UNMutableNotificationContent，并将其存储到名为 content 的常量中。UNMutableNotificationContent
    包含用户通知的数据，例如消息或声音。在 ➋ 处，我们将 content.body 属性设置为名为 message 的生日提醒消息。然后，在 ➌ 处，我们将
    content.sound 设置为默认通知声音，这与接收短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知内容之后，我们需要创建通知的*触发器*。触发器属于 UNCalendarNotificationTrigger 类，能够告诉应用程序何时以及多久发送一次通知。我们将安排每年在生日人生日当天早上8点发送生日通知。Swift
    让我们通过使用 Calendar 和 DateComponents 类获取触发日期的月和日。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码以在设置 content.sound 后创建触发器：
- en: '[PRE28]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们使用 Calendar 方法 dateComponents(_:from:) 从 birthDate 获取月和日的 DateComponents。我们仅传入
    [.month, .day] 作为组件 ➊，而不包括年份。因为我们希望触发器每年都生效，而不仅仅是触发年份——那已经是过去的年份了，不管怎样也不会触发！我们希望在早上8点发送生日通知，所以接下来我们将
    dateComponents.hour 设置为 8 ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用其初始化器创建 UNCalendarNotificationTrigger。此初始化器接受两个参数：dateComponents 和一个布尔值，用于说明您是否希望重复触发器。我们希望每年重复触发器，因此我们传入
    true。Swift 在您希望重复触发器的频率方面非常智能。例如，如果您传入的 DateComponents 只是一个小时和一个分钟，它将每天在该小时和分钟触发通知。因为我们传入了一个月和一天，所以触发器将每年重复。
- en: '![](Image00263.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和日期组件类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar 和 DateComponents 类使得创建日期和时间变得非常容易。DateComponents 具有整数属性，您可以为日期和时间的年、月、日、小时、分钟和秒或时间间隔设置这些属性。Calendar
    类具有将 DateComponents 转换为 Date 或反之的方法。要尝试创建日期，请打开您的 Swift playground。我们将创建一个 1971
    年 5 月 10 日上午 8:23 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 myDateComponents ➊ 的变量，我们将使用它来创建我们的日期。创建 myDateComponents 后，我们可以为其各种属性设置整数。一年中的月份都用数字顺序的整数表示，从
    1 月的 1 到 12 月的 12。对于 5 月，我们将 myDateComponents.month 设置为 5 ➋。对于上午 8 点，我们对 myDateComponents.hour
    使用 8 ➌。myDateComponents 属性使用 24 小时制时钟，以便 24 小时中的每个小时都按数字顺序标记，午夜从 0 开始。因此，中午之前的所有小时都与
    12 小时制时钟上的小时相同，但对于下午 2 点（中午后两小时），我们将计算超过 12 小时的两小时，并将 myDateComponents 设置为 14。再举一个例子，晚上
    11 点将是 23。最后，我们可以通过在 Calendar 类 ➍ 上使用 date(from:) 方法从 myDateComponents 创建一个日期。要使用此方法，我们首先需要一个
    Calendar 实例。我们使用 Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这是公历，它有 12 个月和 7 天的星期。
- en: '![](Image00265.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Date 中获取 DateComponents，我们使用 Calendar 方法 myDateComponents(_:from:)。此方法接受两个参数：第一个是您想要从
    Date 中获取的 DateComponents 数组，第二个是 Date 本身。如果您想创建一个新的 Date 对象，该对象是今天的日期，但例如在上午 8
    点，myDateComponents(_:from:) 方法非常有用。
- en: 'Write the following in your playground:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 playground 中编写以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其赋值给名为 `today` 的常量。接着，我们从 `today` 中获取 `myDateComponents`
    的月、日和年份 ➋。请注意，我们只传入了我们关心的 `DateComponents` 属性。例如，我们不需要小时、分钟或秒数。我们将 `myDateComponents`
    声明为变量，而不是常量，因为我们需要设置小时属性，操作发生在 ➌ 处。最后，我们使用 `myDateComponents` 创建了一个新的日期，命名为 `todayEightAm`
    ➍。你应该能看到，新的日期与今天相同，唯一不同的是时间为早上 8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知的内容和触发器，几乎可以创建一个 UNNotificationRequest 对象来计划通知了。但在创建 UNNotificationRequest
    之前，我们首先需要一个标识符。这个标识符是一个字符串，用于标识该通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用此标识符来删除已删除的生日记录所对应的计划通知。毕竟，你不希望在删除生日后还收到相关的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第12章](text00023.html#ch12) 中，我们为 Birthday 类添加了一个 `birthdayId` 属性，因此我们将使用
    `birthdayId` 作为通知的标识符。首先，我们需要解包可选的 `birthdayId` 属性，并将其存储在名为 `identifier` 的常量中。然后，我们可以使用标识符和触发器来创建通知请求。请在触发器创建后立即添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用标识符、内容和触发器创建 UNNotificationRequest。请求创建后，必须将其添加到 UNUserNotificationCenter
    中。为此，我们创建了一个常量 `center` ➋，它是应用程序当前的 UNUserNotificationCenter。然后，我们使用方法 `add(_:withCompletionHandler:)`
    来添加我们计划的通知请求 ➌。此方法需要两个参数，一个是 UNNotificationRequest，另一个是作为 completionHandler 的闭包，在通知添加后执行某些操作。我们将请求作为第一个参数传入，由于我们在请求添加后不需要做任何事情，所以将
    nil 作为 completionHandler 传入。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写调度通知的方法！现在，如果你运行你的应用并创建 Birthday 对象，你将在生日时收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日，并等待到早上 8 点，才能看到通知。但等待整整一天来测试代码太长了！为了现在就测试代码，可以调整代码使得通知更早触发。将
    `myDateComponents` 的小时和分钟设置为从当前时间起 10 分钟。假设现在是下午 1:35，将你刚刚写的代码改成以下内容：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天的生日，点击停止按钮关闭应用（但保持模拟的iPhone窗口打开），等待10分钟。您应该会看到一个像[图13-4](text00024.html#ch13fig4)那样的通知出现。测试完毕后，别忘了把代码改回来，这样通知就会在早晨第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：横幅样式的生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中删除一个生日时，我们还需要取消其对应的通知，这可以通过在`BirthdaysTableViewController`中添加一些代码来完成。一个合适的地方是在用户选择删除生日后，在`tableView(_:commitEditingStyle:forRowAtIndexPath:)`方法中。将以下代码添加到该方法中：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除某个生日的通知，首先我们解包`birthdayId`来用作标识符 ➊。接着，我们获取`UNUserNotificationCenter` ➋并删除该通知
    ➌。`remove`方法接受一个标识符数组，这样您可以一次删除多个通知，但由于我们只想删除一个，所以传入`[identifier]`，这虽然是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker应用现在已经完成！请记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取，您可以将自己的项目与其进行对比，确保一切都放在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用用户通知框架在朋友生日时向用户发送提醒。您学会了如何添加一个在每年特定时间发送的通知，并且也学会了如何在用户从应用中删除生日时删除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](text00025.html#part03)，您将构建另一个激动人心的应用——一款名为“Schoolhouse Skateboarder”的游戏，具有图形、声音等功能！
- en: '![](Image00268.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户通知框架**'
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您使用Apple的Core Data框架将生日保存在手机的数据库中一样，您将使用Apple的用户通知框架向用户发送通知。使用这个框架非常简单！您只需要在任何处理用户通知的类顶部添加一个`import`语句，如下所示：
- en: '[PRE32]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用框架——*AddBirthdayViewController.swift, AppDelegate.swift* 和 *BirthdaysTableViewController.swift*
    ——因此，在每个文件中添加 `import UserNotifications`，放在其他 `import` 语句的下面。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让应用在某人过生日时请求用户授权发送通知。如果没有通知权限，就无法发送通知。你可以通过在应用委托中请求通知授权来获取权限。这需要在应用启动时完成，也就是在应用完成启动时。幸运的是，AppDelegate类中有一个名为application(_:didFinishLaunchingWithOptions:)的方法可以用来完成这项工作。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在*AppDelegate.swift*文件的顶部添加了这一行`import UserNotifications`。接下来，在application(_:didFinishLaunchingWithOptions:)方法中添加以下代码行，以请求发送本地通知的权限。
- en: '*AppDelegate.swift*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE33]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ➊这一行代码获取当前的UNUserNotificationCenter并将其存储在一个常量center中。*通知中心*用于调度和管理从你的应用发送的通知。在本章中，我们将使用UNUserNotificationCenter类中的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:)方法向用户请求授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:)请求将一个新的通知添加到发送给用户的通知队列中。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:)移除已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋使用这些方法中的第一个，向用户请求授权让应用程序发送通知。接下来，我们会在本章中使用另外两种方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:)方法有两个参数：options和completionHandler。在options参数中，你需要传递一个包含所需通知选项的UNAuthorizationOptions数组。你可以为通知选择四种类型的UNAuthorizationOptions：badge、sound、alert和carPlay。badge选项在你的应用图标上添加一个徽章，以便用户快速查看应用中是否有新内容。这通常是一个数字，表示应用中有多少个新通知或等待中的通知。sound选项在发送通知到手机时会播放声音。alert选项会以弹窗或横幅的形式显示通知，弹窗会出现在屏幕中央，横幅则会从屏幕顶部滑入。作为开发者，你不能决定通知如何显示，也不能决定用户是否打开通知的声音设置。这个设置是由用户在其设置应用中控制的。第四个选项，carPlay，允许在支持CarPlay的设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知作为警报显示给用户，并在每次收到通知时播放声音，因此我们传入[.alert, .sound]作为选项 ➌。completionHandler参数是一个闭包，它在用户授予或拒绝应用程序发送通知权限后被调用。completionHandler闭包有两个参数：granted和error
    ➍。granted参数是一个布尔值，告诉你权限是否被授予（如果是true）或拒绝（false）。如果用户拒绝让我们发送通知，我们不会改变应用程序的行为，但我们会在控制台打印一条语句
    ➎，以便在测试应用程序时查看权限是被授予还是拒绝。第二个参数error是Error类类型，告知你是否出现了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然你已经请求了通知授权，用户第一次运行应用程序时，它将显示一个提示框，询问是否允许应用程序发送通知，如[图13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：应用程序会请求用户授权发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在此选择“不允许”，他们将不会收到任何生日通知。如果他们选择“允许”，则会收到通知。用户只会在应用程序首次安装后运行时被询问一次这个问题。然而，他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到一个名为*Birthdays* 的BirthdayTracker应用程序条目，位于列表底部（[图13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到BirthdayTracker应用的设置中，将引导用户到通知设置界面（[图13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：在设置应用中，用户可以深入指定他们的应用程序通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：我们应用程序的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在此界面上，用户可以指定是否希望查看应用程序的通知，以及希望看到何种类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建生日时，我们都希望安排一个通知，在每年生日当天向我们发送提醒。为此，我们将在AddBirthdayViewController类的saveTapped(_:)方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先需要创建一个消息字符串，作为通知发送。我们的消息将是一个字符串：“祝firstName lastName今天生日快乐！” 在*AddBirthdayViewController.swift*
    的saveTapped(_:)方法中，生日保存后添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE34]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息，我们需要创建并安排将在朋友生日时发送到用户设备的通知。首先，确保在文件顶部有import UserNotifications。然后在你刚写的message常量下面添加以下内容：
- en: '[PRE35]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ➊这一行创建了一个存储在常量content中的UNMutableNotificationContent。UNMutableNotificationContent包含用户通知的数据，比如消息或声音。在➋处，我们将content.body属性设置为名为message的生日提醒消息。然后在➌处，我们将content.sound设置为默认的通知声音，这与收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建通知内容后，我们需要创建通知的*触发器*。触发器是UNCalendarNotificationTrigger类的一部分，让应用程序知道何时以及多久发送一次通知。我们将安排在每年某人的生日的早上8点发送生日通知。Swift允许我们通过使用Calendar和DateComponents类，仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码来创建在设置content.sound后触发的触发器：
- en: '[PRE36]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用Calendar方法dateComponents(_:from:)从birthDate中获取月份和日期的DateComponents。我们只传递[.month,
    .day]作为组件 ➊，而不传递年份。这是因为我们希望触发器每年都触发，而不是仅在某人出生的那一年触发——那已经是过去的事了，所以根本不可能发生！我们希望在生日的早上8点发送生日通知，因此接下来我们将dateComponents.hour设置为8
    ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们使用其初始化器创建UNCalendarNotificationTrigger。这个初始化器有两个参数：dateComponents和一个布尔值，表示是否希望触发器重复。我们希望触发器每年都重复，因此我们传入true。Swift智能地处理你希望触发器重复的频率。例如，如果你只传入了小时和分钟的DateComponents，它将每天在该小时和分钟触发通知。因为我们传入的是月份和日期，触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**Calendar和DateComponents类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar和DateComponents类使得创建日期和时间变得非常简单。DateComponents具有可以为日期和时间或时间间隔设置的整数属性，包括年份、月份、日期、小时、分钟和秒。Calendar类具有将DateComponents转换为Date或反向转换的方法。要尝试创建日期，请打开你的Swift
    Playground。我们将创建一个日期和时间：1971年5月10日，上午8:23：
- en: '![](Image00264.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为myDateComponents ➊ 的变量，用于创建我们的日期。创建了myDateComponents后，我们可以为它的各个属性设置整数。每年的月份都用数字顺序表示，从1表示一月到12表示十二月。对于五月，我们将myDateComponents.month设置为5
    ➋ 。对于早上8点，我们将myDateComponents.hour设置为8 ➌ 。myDateComponents的属性使用24小时制，所以一天中的每个小时都按数字顺序标记，从0表示午夜开始。因此，所有中午之前的小时与12小时制相同，但对于下午2点，它是在中午之后两小时，所以我们将myDateComponents设置为14。再比如，晚上11点则是23。最后，我们可以通过在Calendar类上使用date(from:)方法来从myDateComponents创建一个日期
    ➍ 。使用这个方法之前，我们需要一个Calendar实例。我们使用Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这通常是公历，具有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Date中获取DateComponents，我们使用Calendar的myDateComponents(_:from:)方法。这个方法需要两个参数：第一个是你想从Date中提取的DateComponents数组，第二个是Date本身。如果你想创建一个新的Date对象，表示今天的日期，但时间是早上8点，例如，这个方法非常有用。
- en: 'Write the following in your playground:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游乐场中写下以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其分配给一个名为today的常量。接下来，我们从today中提取myDateComponents的月、日和年 ➋
    。注意，我们只传入我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒数。我们将myDateComponents设为变量，而不是常量，因为我们要设置小时属性，这个操作在➌处完成。最后，我们使用myDateComponents创建一个新的日期，命名为todayEightAm
    ➍ 。你应该能看到，新的Date与今天相同，唯一的不同是时间是早上8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发器，我们几乎准备好创建一个UNNotificationRequest对象来调度通知了。但是，在创建UNNotificationRequest之前，我们首先需要一个标识符。这个标识符是一个字符串，用于标识这个通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符来删除一个计划的通知，如果我们从应用程序中删除一个生日。毕竟，你可不想收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们为Birthday添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包optional类型的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用标识符和触发器来创建通知请求。在创建trigger后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们使用标识符、内容和触发器创建UNNotificationRequest。创建请求后，它必须添加到UNUserNotificationCenter。为此，我们创建一个常量center
    ➋，它是应用程序当前的UNUserNotificationCenter。然后，我们使用方法add(_:withCompletionHandler:)将请求添加到我们预定的通知中
    ➌。该方法需要两个参数，一个是UNNotificationRequest，另一个是作为completionHandler的闭包，用于在通知添加后执行某些操作。我们传入请求作为第一个参数，由于我们不需要在请求添加后执行任何操作，因此将completionHandler设置为nil。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写计划通知的方法！现在如果你运行应用程序并创建Birthday对象，当有人的生日时，你会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日，并等待到早上8点查看通知的出现。但是等待一天来测试代码太长了！为了立即测试代码，可以调整代码使通知更早触发。将myDateComponents的小时和分钟设置为距离当前时间10分钟。如果现在是下午1:35，修改你刚才写的代码，改成如下：
- en: '[PRE38]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序，添加一个今天的生日，点击停止按钮关闭应用程序（但保持模拟器的iPhone窗口打开），并等待10分钟。你应该会看到像[图13-4](text00024.html#ch13fig4)中的通知一样弹出。测试后，别忘了把代码改回去，这样通知会在早晨第一时间弹出！
- en: '![](Image00267.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：横幅样式的生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用程序中移除一个生日时，我们还需要取消其对应的通知，这可以通过在BirthdaysTableViewController中添加一些代码来实现。一个好的位置是在用户选择删除生日后，在tableView(_:commitEditingStyle:forRowAtIndexPath:)方法中。向该方法添加以下行：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE39]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除一个生日的通知，首先我们解包birthdayId并将其用作标识符 ➊。接下来，我们获取UNUserNotificationCenter ➋并移除通知
    ➌。remove方法接受一个标识符数组，允许你一次移除多个通知，但由于我们只想移除一个，所以传入[identifier]，这是一个包含一个值的数组。
- en: '**NOTE**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**BirthdayTracker 应用现已完成！记住，最终的项目文件可以从** [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    **下载，因此您可以与您的文件进行对比，确保一切都在正确的位置。**'
- en: '**WHAT YOU LEARNED**'
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**您学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何使用用户通知框架，在朋友的生日时提醒您的用户。您学会了如何添加一个每年在特定时间发送的通知，并且也学会了如何在用户从应用中删除生日时删除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](text00025.html#part03)，您将构建另一个令人兴奋的应用——一个名为 *Schoolhouse Skateboarder*
    的游戏，游戏中包含图形、声音等内容！
- en: '![](Image00268.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您使用苹果的 Core Data 框架将生日保存在手机的数据库中一样，您将使用苹果的 User Notifications 框架向用户发送通知。使用这个框架很简单！您只需在任何涉及用户通知的类顶部添加一行
    import 语句，像这样：
- en: '[PRE40]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用该框架——*AddBirthdayViewController.swift、AppDelegate.swift* 和 *BirthdaysTableViewController.swift*——因此请在每个文件的其他
    import 语句下方添加 import UserNotifications。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要让您的应用在某人生日时请求用户授权发送通知。如果没有通知权限，就无法发送通知。您可以通过让应用请求通知权限来获得授权，授权请求应该在应用启动时（即应用完成启动后）进行。幸运的是，AppDelegate
    类中有一个名为 application(_:didFinishLaunchingWithOptions:) 的方法，我们可以利用它来实现这一点。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您在 *AppDelegate.swift* 文件的顶部添加了 import UserNotifications 这一行。接下来，在 application(_:didFinishLaunchingWithOptions:)
    中添加以下行，以请求授权发送本地通知。
- en: '*AppDelegate.swift*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE41]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行获取当前的 UNUserNotificationCenter，并将其存储在名为 center 的常量中。*通知中心* 用于调度和管理您从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类中的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一个新的通知以发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 删除一个已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋使用第一种方法，要求用户授予应用发送通知的权限。我们将在本章稍后使用其他两种方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 方法requestAuthorization(options:completionHandler:)接受两个参数：options和completionHandler。在options参数中，你传入一个UNAuthorizationOptions数组，表示你希望在通知中使用的选项。有四种UNAuthorizationOptions可以用于通知：badge、sound、alert和carPlay。badge选项会在你的应用图标上添加一个徽章，用户可以快速查看应用中是否有新内容。这通常是一个数字，表示应用中有多少条新的或等待的通知。sound选项会在通知发送到手机时播放声音。alert选项会以警报形式显示通知，警报会弹出在屏幕中间，或者以横幅的形式出现在屏幕顶部。作为应用开发者，你无法决定通知如何显示，或是否开启通知声音。这些都由用户在“设置”应用中控制。第四个选项carPlay允许在支持CarPlay的设备上接收通知。
- en: '![](Image00259.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知以警报的形式展示给用户，并且在每次通知到来时播放声音，因此我们传入了[.alert, .sound]作为我们的选项 ➌。completionHandler参数是一个闭包，在用户授权或拒绝授权应用发送通知后被调用。completionHandler闭包有两个参数，granted和error
    ➍。granted参数是一个布尔值，表示是否授权（如果授权则为true，否则为false）。如果用户拒绝允许我们发送通知，我们不会改变应用的行为，但会在控制台中打印一条语句
    ➎，这样你就可以在测试应用时看到是否授予了通知权限。第二个参数error是Error类类型，表示是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知授权，用户首次运行应用时，它会显示一个提示对话框，询问是否允许发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用会请求用户授权发送通知的权限。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在此选择“不允许”选项，他们将不会收到任何关于他人生日的通知。如果选择“允许”，他们将会收到通知。用户只会在应用程序首次安装并运行后被询问此问题。然而，他们可以随时在“设置”应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开“设置”应用并滚动到应用程序部分时，他们会看到列表底部有一个名为*Birthdays*的BirthdayTracker应用项（见[图 13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这个。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到BirthdayTracker应用的设置将引导用户到通知设置界面（[图 13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：用户可以通过设置应用进入详细界面来指定其应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个界面上，用户可以指定是否希望看到应用的通知，以及他们希望接收什么类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个生日时，我们都希望安排一个通知，在每年的生日当天发送给我们。为此，我们将在AddBirthdayViewController类中的saveTapped(_:)方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，首先我们需要创建一个消息字符串，以便在通知中发送。我们的消息将是一个字符串，内容为：“祝firstName lastName今天生日快乐！”在*AddBirthdayViewController.swift*的saveTapped(_:)方法中，保存生日之后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE42]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息内容，我们需要创建并安排将在用户朋友生日时发送到其设备上的通知。首先，确保在文件顶部导入了UserNotifications。然后，在你刚写的消息常量下方添加以下内容：
- en: '[PRE43]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了一个UNMutableNotificationContent，并将其存储在一个名为content的常量中。UNMutableNotificationContent包含用户通知的数据，例如消息或声音。在➋，我们将content.body属性设置为名为message的生日提醒消息。然后，在➌，我们将content.sound设置为默认通知声音，这与收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了通知的内容后，我们需要创建通知的*触发器*。触发器属于UNCalendarNotificationTrigger类，它告诉应用何时以及多频繁地发送通知。我们将安排生日通知每年在某人生日的早上8点发送。Swift通过使用Calendar和DateComponents类，允许我们仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置content.sound之后，添加以下代码以创建一个触发器：
- en: '[PRE44]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用Calendar方法dateComponents(_:from:)从birthDate获取月份和日期的DateComponents。我们只传入[.month,
    .day]作为组件 ➊，而不传入年份。因为我们希望触发器每年都能触发，而不是仅在某人出生的年份触发——那是过去的年份，所以它反正永远也不会触发！我们希望在早上8点发送生日通知，因此接下来我们将dateComponents.hour设置为8
    ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用其初始化器创建 UNCalendarNotificationTrigger。这个初始化器接受两个参数：dateComponents
    和一个布尔值，表示是否希望触发器重复执行。我们希望触发器每年重复一次，因此传入 true。Swift 会智能地判断你希望触发器重复的频率。例如，如果你传入的只是一个小时和分钟，它会在每天的同一时间触发通知。因为我们传入了月份和日期，所以触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和日期组件类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 日历和日期组件类让创建日期和时间变得非常简单。DateComponents 拥有可以设置日期和时间或时间间隔的整数属性，分别对应年、月、日、小时、分钟和秒。Calendar
    类有方法可以将 DateComponents 转换为 Date，或反之亦然。为了尝试创建一个日期，打开你的 Swift Playground。我们将创建一个
    1971 年 5 月 10 日，上午 8:23 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 myDateComponents ➊ 的变量，用于创建我们的日期。在创建 myDateComponents 后，我们可以为它的各个属性设置整数值。每年的月份都用数字顺序表示，从
    1 代表一月到 12 代表十二月。对于五月，我们将 myDateComponents.month 设置为 5 ➋。对于上午 8 点，我们将 myDateComponents.hour
    设置为 8 ➌。myDateComponents 的属性使用 24 小时制，因此一天中的每一小时都按数字顺序标记，从 0 代表午夜开始。所以，所有中午之前的小时数和
    12 小时制一样，但对于下午 2 点，它是中午后两个小时，我们会将 myDateComponents 设置为 14。另一个例子是，晚上 11 点是 23。最后，我们可以通过在
    Calendar 类上使用 date(from:) 方法来从 myDateComponents 创建一个日期 ➍。要使用这个方法，我们首先需要一个 Calendar
    实例。我们使用 Calendar.current，它返回设备所使用的日历类型。在大多数西方国家，这是公历，包含 12 个月和 7 天一周。
- en: '![](Image00265.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个 Date 中获取 DateComponents，我们使用 Calendar 方法 myDateComponents(_:from:)。这个方法接受两个参数：第一个是你想从
    Date 中提取的 DateComponents 数组，第二个是 Date 本身。myDateComponents(_:from:) 方法非常有用，比如你想创建一个新的
    Date 对象，它是今天的日期，但时间是上午 8 点。
- en: 'Write the following in your playground:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Playground 中写入以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 行创建了当前的日期和时间，并将其赋值给名为 today 的常量。接下来，我们从 today 中提取出 myDateComponents 的月、日和年
    ➋。请注意，我们只传入了我们关心的 DateComponents 属性。例如，我们不需要小时、分钟或秒。我们将 myDateComponents 设为变量而非常量，因为我们要设置小时属性，这个操作在
    ➌ 处完成。最后，我们使用 myDateComponents 创建一个新的日期，命名为 todayEightAm ➍。你会看到新日期与 today 相同，唯一不同的是时间是早上8点。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，我们几乎可以创建一个 UNNotificationRequest 对象来安排通知了。但是在创建 UNNotificationRequest
    之前，我们首先需要一个标识符。这是一个字符串，可以用来标识该通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从应用中删除生日，我们还会使用这个标识符来移除已安排的通知。毕竟，你可不想收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们为 Birthday 添加了一个 birthdayId 属性，因此我们将使用 birthdayId
    作为通知的标识符。首先，我们需要解包可选的 birthdayId 属性，并将其存储在一个名为 identifier 的常量中。然后，我们可以使用 identifier
    和 trigger 创建通知请求。在 trigger 创建之后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE45]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用 identifier、content 和 trigger 创建了 UNNotificationRequest。在 request
    创建后，必须将其添加到 UNUserNotificationCenter。为此，我们创建了一个名为 center 的常量 ➋，它是应用当前的 UNUserNotificationCenter。接着，我们使用
    add(_:withCompletionHandler:) 方法将通知请求添加到已安排的通知中 ➌。这个方法接受两个参数，一个是 UNNotificationRequest，另一个是
    closure 类型的 completionHandler，它在通知添加后执行某些操作。我们将请求作为第一个参数传入，由于我们不需要在请求添加后执行任何操作，因此我们将
    nil 传入 completionHandler。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写安排通知的方法！现在，如果你运行你的应用并创建生日对象，当有人过生日时，你就会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的通知，你需要为第二天添加一个生日，并等待直到早上8点才会看到通知。但是，等待整整一天来测试你的代码太长了！为了现在就能测试你的代码，调整代码让通知提前触发。将
    myDateComponents 的小时和分钟设置为比当前时间晚10分钟。所以，如果现在是下午1:35，将你刚刚写的代码改成如下：
- en: '[PRE46]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序，添加今天的生日日期，点击停止按钮关闭应用（但保持模拟的 iPhone 窗口打开），等待 10 分钟。您应该会看到一个通知出现，类似于[图
    13-4](text00024.html#ch13fig4) 中的样式。测试完成后，别忘了将代码改回来，让通知在早晨第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：横幅风格的生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用程序中移除一个生日时，我们还需要取消其对应的通知。这可以在 `BirthdaysTableViewController` 中通过添加一些代码来完成。一个合适的地方是在用户选择删除生日之后，方法
    `tableView(_:commitEditingStyle:forRowAtIndexPath:)` 中。将以下代码添加到该方法中：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE47]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除生日通知，首先我们需要解包 `birthdayId`，将其作为标识符 ➊。接下来，我们获取 `UNUserNotificationCenter`
    ➋ 并移除通知 ➌。`remove` 方法接受一个标识符数组，这样您可以一次移除多个通知，但由于我们只想移除一个，所以传递给它 `[identifier]`，这虽然是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用程序现已完成！请记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取，您可以对比一下，确保一切都放在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何使用用户通知框架，在朋友的生日时提醒您的用户。您学习了如何添加一个每年特定时间发送的通知，以及如果用户从应用中移除生日时，如何移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 部分](text00025.html#part03)，您将构建另一个令人兴奋的应用程序——一个名为《Schoolhouse Skateboarder》的游戏，里面包含图形、声音等内容！
- en: '![](Image00268.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: '[PRE48]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用该框架——*AddBirthdayViewController.swift，AppDelegate.swift* 和 *BirthdaysTableViewController.swift*
    ——因此，请在每个文件中，在其他 `import` 语句下添加 `import UserNotifications`。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要让应用程序请求用户允许在他人生日时发送通知。如果没有获得通知权限，则通知将无法发送。您可以通过在应用程序委托中请求授权来获得通知权限。此操作需要在应用程序启动时完成，也就是在应用程序启动结束时。幸运的是，`AppDelegate`
    类中有一个名为 `application(_:didFinishLaunchingWithOptions:)` 的方法可以用来完成这个操作。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保在你的 *AppDelegate.swift* 文件顶部添加了 import UserNotifications 这一行。接着，在 application(_:didFinishLaunchingWithOptions:)
    中添加以下几行代码，请求发送本地通知的权限。
- en: '*AppDelegate.swift*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE49]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行获取当前的 UNUserNotificationCenter 并将其存储在一个名为 center 的常量中。*通知中心*用于安排和管理你从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类的三种方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求向用户发送新的通知。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➋ 使用了这些方法中的第一个，请求用户授予应用发送通知的权限。我们将在本章后面使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 接受两个参数：options 和 completionHandler。在
    options 参数中，你传入一个包含你希望在通知中可用的 UNAuthorizationOptions 的数组。你可以为通知使用四种类型的 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项会在你的应用图标上添加一个徽章，用户可以快速查看应用中是否有新内容。通常这是一个数字，表示应用中有多少个新的或待处理的通知。sound
    选项会在通知发送到手机时播放声音。alert 选项会将通知显示为警报，通常是弹出在屏幕中间，或者是从屏幕顶部滑入的横幅。作为应用开发者，你无法决定通知如何显示，或者用户是否会开启通知的声音。这是用户在设置应用中控制的。第四个选项，carPlay，允许在启用
    CarPlay 的设备上接收通知。
- en: '![](Image00259.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警报，并在每个通知到达时播放声音，因此我们传入[.alert, .sound]作为我们的选项 ➌。completionHandler
    参数是一个闭包，它会在用户授予或拒绝应用发送通知的权限后被调用。completionHandler 闭包有两个参数，granted 和 error ➍。granted
    参数是一个布尔值，告诉你权限是否被授予（在这种情况下为 true）或被拒绝（false）。如果用户拒绝让我们发送通知，我们不会改变应用的行为，但会在控制台中打印一条语句
    ➎，这样你就可以在测试应用时查看权限是被授予还是被拒绝。第二个参数 error 是 Error 类类型，告诉你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知授权，第一次运行应用时，系统会显示一个提示框，询问是否允许应用发送通知，如 [图 13-1](text00024.html#ch13fig1)
    所示。
- en: '![](Image00260.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用将请求用户授权发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在此选择“不允许”选项，他们将无法收到关于他人生日的任何通知。如果选择“允许”，他们将收到通知。此提示仅在应用程序安装后第一次运行时显示一次，用户可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到列出名为 *Birthdays* 的 BirthdayTracker 应用，位于列表底部 ([图 13-2](text00024.html#ch13fig2))。你也可以在模拟器中看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 BirthdayTracker 应用的设置后，用户将看到通知设置屏幕 ([图 13-3](text00024.html#ch13fig3))。
- en: '![](Image00261.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：从设置应用中，用户可以深入指定应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上，用户可以指定是否希望看到该应用的通知，以及他们希望收到何种类型的通知（横幅或提醒）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个生日时，我们都希望在每年生日时向我们发送一条通知。为此，我们将在 `AddBirthdayViewController` 类的 `saveTapped(_:)`
    方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先需要创建一个消息字符串，该字符串将通过通知发送。我们的消息是一个字符串，内容为“祝 firstName lastName 今天生日快乐！”在
    *AddBirthdayViewController.swift* 文件的 saveTapped(_:) 方法中保存生日后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE50]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息内容，需要创建并安排通知，确保它在朋友的生日当天发送到用户的设备。首先，确保在文件顶部导入 `UserNotifications`。然后在刚刚写的消息常量下方添加以下代码：
- en: '[PRE51]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码创建了一个 `UNMutableNotificationContent`，并将其存储在一个名为 `content` 的常量中。`UNMutableNotificationContent`
    包含用户通知的数据，例如消息或声音。在 ➋ 处，我们将 `content.body` 属性设置为名为 `message` 的生日提醒消息。然后，在 ➌ 处，我们将
    `content.sound` 设置为默认的通知声音，这与收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知内容后，我们需要创建通知的*触发器*。触发器属于UNCalendarNotificationTrigger类，它让应用知道何时以及多久发送一次通知。我们将安排在每年的生日早上8点发送生日通知。Swift通过使用Calendar和DateComponents类，让我们能够仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，以在设置content.sound后创建触发器：
- en: '[PRE52]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用Calendar方法`dateComponents(_:from:)`从birthDate中获取月份和日期的DateComponents。我们仅传入[.month,
    .day]作为组件➊，而不传入年份。这是因为我们希望触发器每年都触发，而不仅仅是在那个人出生的年份——那个年份已经过去，所以无论如何都不会触发！我们希望在早上8点发送生日通知，因此接下来我们将dateComponents.hour设置为8➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们通过其初始化器创建UNCalendarNotificationTrigger。该初始化器有两个参数：dateComponents和一个布尔值，用于表示是否希望触发器重复。我们希望触发器每年重复，因此传入true。Swift很聪明，它会根据你希望触发器重复的频率来处理。例如，如果你传入的DateComponents只有小时和分钟，它会每天在该小时和分钟触发通知。因为我们传入了月份和日期，触发器会每年重复。
- en: '![](Image00263.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和DateComponents类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 日历和DateComponents类使得创建日期和时间变得非常简单。DateComponents具有整数属性，你可以设置日期和时间的年份、月份、日期、小时、分钟和秒，或者设置时间间隔。Calendar类具有方法，可以将DateComponents转换为Date，反之亦然。为了尝试创建日期，可以打开你的Swift
    playground。我们将创建一个1971年5月10日早上8:23的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为myDateComponents的变量 ➊，我们将用它来创建日期。创建myDateComponents后，我们可以为它的各种属性设置整数。年度的月份都是按数字顺序表示的，从1表示1月，到12表示12月。对于5月，我们将myDateComponents.month设置为5
    ➋。对于早上8点，我们将myDateComponents.hour设置为8 ➌。myDateComponents的属性使用24小时制，因此每个24小时的小时数都按数字顺序标记，从0表示午夜开始。所以中午之前的小时与12小时制一样，但下午2点（即中午后的两个小时）我们将myDateComponents设置为14。再举个例子，晚上11点就是23。最后，我们可以通过使用Calendar类的date(from:)方法从myDateComponents创建一个日期
    ➍。为了使用这个方法，我们首先需要一个Calendar实例。我们使用Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这通常是格里历日历，它有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Date中获取DateComponents，我们使用Calendar方法myDateComponents(_:from:)。这个方法有两个参数：第一个是你想从Date中提取的DateComponents数组，第二个是Date本身。如果你想创建一个新的日期对象，比如今天的日期，但时间为早上8点，myDateComponents(_:from:)方法会非常有用。
- en: 'Write the following in your playground:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Playground中写入以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ➊行创建了当前的日期和时间，并将其赋值给一个名为today的常量。接下来，我们从today中获取myDateComponents，以提取月份、日期和年份
    ➋。请注意，我们只传入了我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒。我们将myDateComponents定义为变量，而不是常量，因为我们将设置小时属性，这在➌处完成。最后，我们使用myDateComponents创建一个新的日期，命名为todayEightAm
    ➍。你应该会看到这个新的日期与今天相同，唯一不同的是时间是早上8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，我们几乎可以创建一个UNNotificationRequest对象来安排通知了。但是在创建UNNotificationRequest之前，我们首先需要一个标识符。这是一个字符串，用于标识通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符，在我们从应用程序中删除生日时，删除已安排的通知。毕竟，你肯定不希望收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们为Birthday添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包optional的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger创建一个通知请求。在trigger创建后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE53]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用identifier、content和trigger创建UNNotificationRequest。在创建request后，必须将其添加到UNUserNotificationCenter。为此，我们创建一个名为center的常量
    ➋，它是应用当前的UNUserNotificationCenter。然后，我们使用add(_:withCompletionHandler:)方法将请求添加到我们调度的通知中
    ➌。此方法接受两个参数，一个是UNNotificationRequest，另一个是一个closure作为completionHandler，在通知添加后执行某些操作。我们将我们的request作为第一个参数传递，既然我们不需要在请求添加后执行任何操作，所以我们为completionHandler传递nil。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们刚刚完成了写入调度通知的方法！现在如果你运行你的应用并创建生日对象，当某人过生日时，你将收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的通知，你需要为第二天添加一个生日，并等到早上8点让通知出现。但等待整整一天来测试代码太长了！要立刻测试代码，可以调整代码，让通知更早地触发。将myDateComponents的小时和分钟设置为当前时间的10分钟后。所以，如果现在是下午1:35，可以将你刚才写的代码改成以下内容：
- en: '[PRE54]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天的生日，点击停止按钮关闭应用（但保持模拟的iPhone窗口打开），等待10分钟。你应该会看到像[图13-4](text00024.html#ch13fig4)中那样的通知。测试后，别忘了将代码改回，让通知在早晨一开始就触发！
- en: '![](Image00267.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：横幅式生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中移除一个生日时，我们也想取消它对应的通知，我们可以通过在BirthdaysTableViewController中添加一些代码来实现。一个合适的位置是在用户选择删除某个生日后，即在tableView(_:commitEditingStyle:forRowAtIndexPath:)方法中。将以下代码添加到该方法中：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE55]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除生日通知，首先我们解包birthdayId以将其用作标识符 ➊。接下来，我们获取UNUserNotificationCenter ➋并移除通知 ➌。remove方法接受一个标识符数组，以便一次移除多个通知，但由于我们只想移除一个通知，所以我们传递[identifier]，它是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在已经完成！记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载，方便你对照检查，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向你展示了如何使用用户通知框架，在朋友过生日时提醒用户。你学会了如何添加一条会在每年某个特定时间发送的通知，也学会了如何在用户删除应用中的生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](text00025.html#part03)，你将构建另一个令人兴奋的应用程序——一款名为 Schoolhouse Skateboarder
    的游戏，游戏包含图形、声音等内容！
- en: '![](Image00268.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个文件中使用这个框架——*AddBirthdayViewController.swift, AppDelegate.swift,* 和 *BirthdaysTableViewController.swift*——因此，在每个文件的其他
    import 语句下，添加 import UserNotifications。
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**本地通知注册**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让你的应用在别人过生日时请求用户许可发送通知。如果没有获得通知权限，通知将无法发送。你可以通过在应用委托中请求授权来获得通知权限。这需要在应用启动时完成，即应用完成启动后。幸运的是，AppDelegate
    类中有一个名为 application(_:didFinishLaunchingWithOptions:) 的方法，我们可以用它来实现这个功能。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保在你的*AppDelegate.swift*文件顶部添加了import UserNotifications。接下来，在 application(_:didFinishLaunchingWithOptions:)
    中添加以下代码行，申请发送本地通知的权限。
- en: '*AppDelegate.swift*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE56]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码获取当前的 UNUserNotificationCenter，并将其存储在一个名为 center 的常量中。*通知中心* 用于安排和管理你从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类中的三种方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户允许发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一条新通知以发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除一个已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋使用了第一个方法，向用户请求授权，让应用能够发送通知。我们将在本章稍后使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 接受两个参数：options 和 completionHandler。在
    options 参数中，您传入一个数组，包含您希望在通知中可用的 UNAuthorizationOptions。有四种类型的 UNAuthorizationOptions
    可供您用于通知：badge、sound、alert 和 carPlay。badge 选项会在您的应用图标上添加一个徽章，用户可以快速看到应用中是否有新内容。通常这是一个数字，表示应用中有多少新通知或待处理通知。sound
    选项会在发送通知到手机时播放声音。alert 选项会以警报或横幅的形式显示通知，警报会在屏幕中央弹出，横幅则会从屏幕顶部滑入。作为开发者，您无法决定通知的显示方式或用户是否启用通知声音。这是用户在设置应用中控制的内容。第四个选项
    carPlay 允许在支持 CarPlay 的汽车设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知作为警报显示给用户，并在每个通知到达时播放声音，因此我们在选项中传入[.alert, .sound] ➌。completionHandler
    参数是一个闭包，传入并在用户允许或拒绝应用发送通知权限后调用。completionHandler 闭包有两个参数，granted 和 error ➍。granted
    参数是一个布尔值，用来告知您权限是否已授予（如果是，则为 true）或被拒绝（false）。如果用户拒绝我们发送通知，我们不会改变应用的行为，但会在控制台打印一条语句
    ➎，这样您在测试应用时就能看到权限是被授予还是被拒绝。第二个参数 error 是 Error 类类型，告诉您是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经请求了通知授权，当用户第一次运行应用时，应用将显示一个警报对话框，询问他们是否希望允许应用发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用将请求用户授权以发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”选项，他们将不会收到任何关于生日的通知。如果选择“允许”，他们将收到通知。用户仅会在首次安装应用后第一次运行时看到这个提示。不过，他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到一个名为 *Birthdays* 的 BirthdayTracker 应用条目，位于列表底部（[图
    13-2](text00024.html#ch13fig2)）。您也可以在模拟器中看到这个。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到 BirthdayTracker 应用设置中，用户将进入通知设置屏幕（[图 13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在设置应用中，用户可以深入指定他们应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，用户可以指定是否希望看到应用的通知，以及他们希望看到何种类型的通知（横幅通知或警告通知）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**调度通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，我们都需要安排一个通知，每年在生日人的生日当天发送给我们。为了实现这一点，我们将在 AddBirthdayViewController
    类的 saveTapped(_:) 方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，首先我们需要创建一个消息字符串，该消息将发送到通知中。我们的消息内容是：“祝 firstName lastName 今天生日快乐！”在 *AddBirthdayViewController.swift*
    中的 saveTapped(_:) 方法保存生日后，立即添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE57]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息内容，接下来需要创建并调度通知，以便在朋友的生日那天发送到用户的设备上。首先，确保在文件顶部导入 UserNotifications。然后，在刚才写的
    message 常量下方添加以下代码：
- en: '[PRE58]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码创建了一个 UNMutableNotificationContent，并将其存储在名为 content 的常量中。UNMutableNotificationContent
    包含用户通知的数据，如消息或声音。➋ 处，我们将 content.body 属性设置为生日提醒消息 message。接着，➌ 处，我们将 content.sound
    设置为默认通知声音，也就是接收到短信时的声音。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知内容之后，我们需要创建通知的*触发器*。触发器属于 UNCalendarNotificationTrigger 类，告诉应用程序何时以及多久发送一次通知。我们将安排在每年生日的当天早上
    8 点发送生日通知。Swift 允许我们使用 Calendar 和 DateComponents 类仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 content.sound 后，添加以下代码以创建一个触发器：
- en: '[PRE59]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先我们通过使用 Calendar 方法 dateComponents(_:from:) 从 birthDate 获取月份和日期的 DateComponents。我们仅传入
    [.month, .day] 作为组件 ➊，而不传入年份。原因是我们希望每年都触发，而不仅仅是在出生的年份——毕竟出生年份已经过去了，所以它根本不会再发生！我们希望在早上
    8 点发送生日通知，因此接下来我们将 dateComponents.hour 设置为 8 ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用其初始化器创建 UNCalendarNotificationTrigger。该初始化器有两个参数：dateComponents 和一个布尔值，表示你是否希望触发器重复。我们希望触发器每年都重复一次，所以传入
    true。Swift 会智能地处理你希望触发器多久重复一次。如果你传入的 DateComponents 只有小时和分钟，它将会每天在那个小时和分钟触发通知。因为我们传入了月份和日期，触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和 DateComponents 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar 和 DateComponents 类使得创建日期和时间变得非常简单。DateComponents 有可以设置年份、月份、日期、小时、分钟和秒数等属性，用来表示日期和时间，或者时间间隔。Calendar
    类有方法可以将 DateComponents 转换为 Date，或者反向操作。为了尝试创建一个日期，打开你的 Swift playground。我们将创建一个
    1971 年 5 月 10 日上午 8:23 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 myDateComponents ➊ 的变量，我们将用它来创建日期。创建 myDateComponents 后，我们可以为其各种属性设置整数值。一年的月份都用按数字顺序排列的整数表示，从
    1 代表 1 月到 12 代表 12 月。对于 5 月，我们将 myDateComponents.month 设置为 5 ➋。对于上午 8 点，我们使用 8
    为 myDateComponents.hour ➌。myDateComponents 属性使用 24 小时制，因此一天中的每个小时都会按数字顺序标记，从 0
    代表午夜开始。因此，所有中午之前的时间与 12 小时制的时间相同，但对于下午 2 点，它是中午之后的两小时，我们需要把 12 点之后的两个小时算作 14。所以，晚上
    11 点会是 23。最后，我们可以通过 Calendar 类的 date(from:) 方法来创建日期 ➍。为了使用此方法，我们首先需要一个 Calendar
    实例。我们使用 Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这通常是公历，它有 12 个月和 7 天一周。
- en: '![](Image00265.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个日期中获取 DateComponents，我们使用日历方法 myDateComponents(_:from:)。该方法有两个参数：第一个是你希望从日期中提取的
    DateComponents 数组，第二个是日期本身。myDateComponents(_:from:) 方法非常有用，假如你想创建一个新的日期对象，例如今天的日期，但设置为上午
    8 点。
- en: 'Write the following in your playground:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 playground 中编写以下代码：
- en: '![](Image00266.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: ➊行代码创建了当前的日期和时间，并将其赋值给一个名为today的常量。接下来，我们从today中提取出myDateComponents，以获得月份、日期和年份
    ➋。注意，我们只传递我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒。我们将myDateComponents设为变量而不是常量，因为我们接下来会设置小时属性，这一步在➌完成。最后，我们使用myDateComponents创建了一个名为todayEightAm的新日期
    ➍。你会看到，新创建的日期与今天相同，唯一的不同是时间是早上8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，离创建UNNotificationRequest对象来安排通知已经差不多了。但在创建UNNotificationRequest之前，我们首先需要一个identifier。这个identifier是一个字符串，用于标识通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个identifier来删除已安排的通知，如果我们从应用中删除了生日。毕竟，你可不希望收到已经删除的生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们向Birthday添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包可选的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger创建通知请求。在trigger创建后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE60]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们创建了UNNotificationRequest，使用了identifier、content和trigger。当request创建完成后，必须将其添加到UNUserNotificationCenter中。为此，我们创建了一个名为center的常量
    ➋，它代表当前应用的UNUserNotificationCenter。接着，我们使用方法add(_:withCompletionHandler:)将请求添加到我们计划的通知中
    ➌。该方法有两个参数，一个是UNNotificationRequest，另一个是作为completionHandler的闭包，用于在通知被添加后执行一些操作。我们将请求作为第一个参数传入，因为我们不需要在请求添加后做任何事情，所以将completionHandler传入nil。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，终于完成了安排通知的方法！现在，如果你运行应用并创建生日对象，当有人的生日时，你会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日，并等到早上8点才会看到通知出现。但是，等待一天来测试代码太长了！要立即测试代码，可以调整它让通知提前触发。将myDateComponents的小时和分钟设置为距离当前时间10分钟。如果现在是下午1:35，修改你刚写的代码如下：
- en: '[PRE61]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天日期的生日，点击停止按钮关闭应用（但保持模拟iPhone的窗口开启），等待10分钟。你应该会看到一个类似于[图13-4](text00024.html#ch13fig4)中的通知弹出。测试后，别忘了把代码改回，让通知在早上第一时间发送！
- en: '![](Image00267.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：生日通知横幅*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中移除一个生日时，我们还需要取消对应的通知，这可以通过在BirthdaysTableViewController中添加一些代码来完成。一个合适的位置是在用户选择删除生日后，即在tableView(_:commitEditingStyle:forRowAtIndexPath:)方法中。向该方法中添加以下代码：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE62]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除一个生日的通知，首先我们解包birthdayId，作为标识符使用➊。接着，获取UNUserNotificationCenter ➋并移除通知 ➌。remove方法接受一个标识符数组，这样你可以一次移除多个通知，但由于我们只想移除一个通知，所以传入[identifier]，这是一个数组，里面只有一个值。
- en: '**NOTE**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker应用已经完成！记得最终项目文件可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *上下载，你可以对照一下，确保你的代码一切正确。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用User Notifications框架，在朋友生日时提醒用户。你学会了如何添加一个在每年特定时间发送的通知，以及如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](text00025.html#part03)，你将构建另一个令人兴奋的应用——一款名为Schoolhouse Skateboarder的游戏，它包含了图形、声音等元素！
- en: '![](Image00268.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**注册本地通知**'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让应用请求用户授权，在朋友的生日时发送通知。如果没有通知权限，就无法发送通知。你可以通过在应用委托中请求通知授权来获取权限。这个请求需要在应用启动时立即完成，也就是在应用启动完成后。幸运的是，AppDelegate类中有一个方法叫做application(_:didFinishLaunchingWithOptions:)，我们可以利用它来完成这个操作。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在*AppDelegate.swift*文件的顶部添加了import UserNotifications语句。接下来，在application(_:didFinishLaunchingWithOptions:)方法中添加以下代码，来请求发送本地通知的权限。
- en: '*AppDelegate.swift*'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE63]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➊ 行获取当前的 UNUserNotificationCenter 并将其存储在一个名为 center 的常量中。*通知中心* 用于安排和管理从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一条新的通知以发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除已存在的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➋ 使用第一个方法请求用户授权应用发送通知。我们将在本章稍后使用另外两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 接受两个参数：options 和 completionHandler。在
    options 参数中，你传入一个包含所需通知选项的 UNAuthorizationOptions 数组。你可以为通知使用四种类型的 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项会在应用图标上添加一个徽章，用户可以快速看到应用中是否有新内容。通常这是一个数字，表示应用中有多少条新通知或等待通知。sound
    选项会在发送通知时播放声音。alert 选项会以弹出警报或顶部横幅的形式显示通知。作为开发者，你无法决定通知的显示方式或用户是否开启通知声音。这是用户在设置应用中控制的内容。第四个选项
    carPlay 允许在支持 CarPlay 的汽车设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警报，并在每次通知到达时播放声音，因此我们传入[.alert, .sound]作为我们的选项 ➌。completionHandler
    参数是一个闭包，在用户授权或拒绝应用发送通知后被调用。completionHandler 闭包有两个参数，granted 和 error ➍。granted
    参数是一个布尔值，告诉你是否获得授权（如果是 true）或被拒绝（如果是 false）。如果用户拒绝我们发送通知，我们不会改变应用的行为，但我们会在控制台中打印一条语句
    ➎，这样你可以在测试应用时查看是否获得了授权。第二个参数 error 是 Error 类类型，它告诉你是否出现了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知授权，当用户第一次运行应用时，它会显示一个提示框，询问是否允许发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：应用将请求用户允许发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”选项，他们将不会收到任何生日通知。如果选择“允许”，则会收到通知。用户只会在应用首次安装后启动时被询问此问题，之后他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用部分时，他们将看到BirthdayTracker应用的列表项，标记为*Birthdays*，并位于列表底部（[图13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到BirthdayTracker应用的设置将引导用户进入通知设置屏幕（[图13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：用户可以从设置应用中深入指定应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上，用户可以指定是否希望查看应用的通知以及他们希望看到的通知类型（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建生日时，我们都希望安排一个通知，在每年的生日那天发送给我们。为此，我们将在*AddBirthdayViewController* 类中的saveTapped(_:)方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，首先我们需要创建一个消息字符串，用于发送通知。我们的消息将是一个字符串：“祝firstName lastName今天生日快乐！” 在*AddBirthdayViewController.swift*
    中保存生日后，紧接着添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE64]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息内容，我们需要创建并安排将在朋友生日时发送到用户设备的通知。首先，确保在文件顶部导入了UserNotifications。然后，在你刚写的消息常量下方添加以下代码：
- en: '[PRE65]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: ➊行创建了一个UNMutableNotificationContent，并将其存储到名为content的常量中。UNMutableNotificationContent包含用户通知的数据，例如消息或声音。➋行中，我们将content.body属性设置为名为message的生日提醒消息。然后，在➌行中，我们将content.sound设置为默认的通知声音，即当收到短信时的相同声音。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知内容后，我们需要创建通知的*触发器*。触发器属于UNCalendarNotificationTrigger类，它让应用知道何时以及多频繁地发送通知。我们将安排在每年生日的早上8点发送生日通知。Swift
    通过使用Calendar和DateComponents类，允许我们仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置content.sound后，添加以下代码以创建触发器：
- en: '[PRE66]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用Calendar方法dateComponents(_:from:)从birthDate中获取月份和日期的DateComponents。我们传入仅包含[.month,
    .day]的组件➊，而不传入年份。这是因为我们希望触发器每年都触发，而不是仅在某人出生的年份（已经过去的年份，反正也不会发生！）。我们希望在早上8点发送生日通知，所以接下来我们将dateComponents.hour设置为8➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们使用其初始化方法创建UNCalendarNotificationTrigger。该初始化方法有两个参数：dateComponents和一个布尔值，表示是否希望触发器重复。我们希望触发器每年都重复，因此我们传入true。Swift会智能地处理触发器的重复频率。例如，如果你传入仅包含小时和分钟的DateComponents，它将每天在该小时和分钟触发通知。因为我们传入了月份和日期，所以触发器将每年重复。
- en: '![](Image00263.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和DateComponents类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar和DateComponents类使得创建日期和时间变得非常简单。DateComponents具有整数属性，可以设置日期和时间的年份、月份、日期、小时、分钟和秒钟，或者时间间隔。Calendar类有方法将DateComponents转换为Date或反之。要尝试创建日期，请打开你的Swift
    playground。我们将创建一个1971年5月10日早上8:23的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为myDateComponents的变量➊，用于创建我们的日期。在创建myDateComponents之后，我们可以为它的各种属性设置整数值。一年的月份都用数字按顺序表示，从1表示一月到12表示十二月。对于五月，我们将myDateComponents.month设置为5➋。对于早上8点，我们将myDateComponents.hour设置为8➌。myDateComponents的属性使用24小时制，因此每个24小时制的小时数都是按数字顺序标记的，从0表示午夜开始。所以中午之前的小时数与12小时制的小时数相同，但对于下午2点，这是中午后的两个小时，我们将myDateComponents设置为14。再举一个例子，晚上11点将是23。最后，我们可以通过使用Calendar类的date(from:)方法来从myDateComponents创建日期➍。要使用此方法，我们首先需要一个Calendar实例。我们使用Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这是公历，它有12个月和一个7天的星期。
- en: '![](Image00265.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Date中获取DateComponents，我们使用Calendar方法myDateComponents(_:from:)。该方法接受两个参数：第一个是你想从Date中提取的DateComponents数组，第二个是Date本身。myDateComponents(_:from:)方法在你想创建一个新的Date对象，例如今天的日期，但设置为上午8点时非常有用。
- en: 'Write the following in your playground:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 playground 中写入以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: ➊行创建了当前的日期和时间，并将其赋值给一个名为today的常量。接下来，我们从today中获取月份、日期和年份的myDateComponents ➋。注意，我们只传入了我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒。我们将myDateComponents设置为变量而不是常量，因为我们将设置小时属性，这在➌行完成。最后，我们使用myDateComponents创建了一个名为todayEightAm的新日期
    ➍。你应该会看到新的Date与今天相同，唯一不同的是时间是上午8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发器，我们几乎准备好创建一个UNNotificationRequest对象来调度通知了。但在创建UNNotificationRequest之前，我们首先需要一个标识符。这是一个字符串，可以用来标识通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符来删除已调度的通知，如果我们从应用中删除一个生日。毕竟，你不希望收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们向Birthday类添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包可选的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger创建一个通知请求。请在创建trigger后添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE67]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊行，我们使用identifier、content和trigger创建了UNNotificationRequest。创建请求后，它必须添加到UNUserNotificationCenter中。为此，我们创建了一个名为center的常量
    ➋，它是应用程序当前的UNUserNotificationCenter。然后，我们使用add(_:withCompletionHandler:)方法来添加我们已调度通知的请求
    ➌。该方法接受两个参数，一个是UNNotificationRequest，另一个是一个闭包作为completionHandler，在通知添加后执行一些操作。我们将我们的请求传递给第一个参数，由于我们不需要在请求添加后做任何事，我们将nil传递给completionHandler。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写调度通知的方法！现在，如果你运行你的应用并创建Birthday对象，当有人过生日时，你将收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试通知，你需要为第二天添加一个生日，并等待直到早上 8 点，才能看到通知出现。但是，等一天来测试代码太长了！要立即测试代码，可以调整它，让通知提前很短的时间就触发。将
    myDateComponents 的小时和分钟设置为距离当前时间 10 分钟。因此，如果现在是下午 1:35，修改你刚才写的代码如下：
- en: '[PRE68]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天的生日，点击停止按钮关闭应用（但保持模拟 iPhone 窗口打开），并等待 10 分钟。你应该会看到一个类似 [图 13-4](text00024.html#ch13fig4)
    中的通知。测试后，别忘了将代码改回去，以确保通知在早上第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：横幅式生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中删除一个生日时，我们也希望取消其对应的通知，我们可以通过在 BirthdaysTableViewController 中添加一些代码来实现这一点。一个好的位置是在用户选择要删除的生日后，在
    tableView(_:commitEditingStyle:forRowAtIndexPath:) 中添加以下代码：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE69]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除生日通知，首先我们解包 birthdayId 以将其用作标识符 ➊。接下来，我们获取 UNUserNotificationCenter ➋ 并删除该通知
    ➌。remove 方法接受一个标识符数组，以便你可以一次删除多个通知，但由于我们只想删除一个，所以传入 [identifier]，它是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在完成了！记得，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载，因此你可以对照自己的代码，确保一切就位。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向你展示了如何使用用户通知框架，在用户朋友的生日时提醒他们。你学会了如何添加一个每年特定时间发送的通知，以及如何在用户从应用中移除生日时，删除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第3部分](text00025.html#part03) 中，你将构建另一个令人兴奋的应用——一款名为 Schoolhouse Skateboarder
    的游戏，具有图形、声音等功能！
- en: '![](Image00268.jpg)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让应用在某人生日时请求用户授权发送通知。如果没有通知权限，通知将无法发送。你可以通过在应用委托中请求通知授权来获取权限。这个操作需要在应用启动时进行，也就是在应用完成启动时。幸运的是，AppDelegate
    类中有一个叫做 application(_:didFinishLaunchingWithOptions:) 的方法，我们可以用它来完成这项操作。
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在*AppDelegate.swift*文件的顶部添加了import UserNotifications。接下来，在application(_:didFinishLaunchingWithOptions:)方法中添加以下代码来请求授权发送本地通知。
- en: '*AppDelegate.swift*'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE70]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 第➊行获取当前的UNUserNotificationCenter并将其存储在一个名为center的常量中。*通知中心*用于安排和管理你从应用程序发送的通知。在本章中，我们将使用UNUserNotificationCenter类中的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:)方法请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:)方法请求添加一个新的通知来发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:)方法移除现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第➋行使用了第一个方法来请求用户授权应用程序发送通知。我们将在本章后面使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:)方法接受两个参数：options和completionHandler。在options参数中，你传递一个包含希望在通知中使用的UNAuthorizationOptions的数组。你可以为通知使用四种类型的UNAuthorizationOptions：badge、sound、alert和carPlay。badge选项会在应用图标上添加一个徽章，以便用户可以快速看到应用中是否有新的内容。通常，这是一个表示有多少新通知或等待通知的数字。sound选项会在通知发送到手机时播放声音。alert选项将通知显示为屏幕中间弹出的警报或从屏幕顶部出现的横幅。你，作为应用开发者，无法决定通知的显示方式，或者用户是否会开启通知声音。这个设置由用户在其“设置”应用中控制。第四个选项carPlay允许在支持CarPlay的设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警报，并在每个通知到来时播放声音，因此我们将[.alert, .sound]作为选项传递给➌。completionHandler参数是一个闭包，它在用户授予或拒绝应用程序发送通知的权限后被调用。completionHandler闭包有两个参数，granted和error
    ➍。granted参数是一个布尔值，指示是否授予了权限（如果授予则为true），否则为拒绝（false）。如果用户拒绝让我们发送通知，我们不会改变应用程序的行为，但我们会在控制台中打印一条语句➎，这样你在测试应用时就能看到是否已授予或拒绝权限。第二个参数error是Error类类型，表示是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已请求通知授权，当用户首次运行应用时，将弹出一个提示框询问是否允许应用发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用将请求用户允许发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”，他们将不会在朋友的生日时收到任何通知。如果他们选择“允许”，则会收到通知。用户仅会在首次安装应用并运行时被询问此问题。然而，他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开“设置”应用并滚动到应用部分时，他们会看到列表底部有一个标记为 *Birthdays* 的 BirthdayTracker 应用（[图 13-2](text00024.html#ch13fig2)）。您也可以在模拟器中看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解 BirthdayTracker 应用的设置将引导用户进入通知设置界面（[图 13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在“设置”应用中，用户可以深入指定其应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个界面上，用户可以指定是否希望接收应用的通知，以及他们希望收到什么类型的通知（横幅通知或提示通知）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建生日时，我们都希望安排一个通知，在每年生日当天发送到我们设备上。为此，我们将在 AddBirthdayViewController 类中的 saveTapped(_:)
    方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，我们首先需要创建一个要在通知中发送的消息字符串。我们的消息将是“祝 firstName lastName 今天生日快乐！”。在 *AddBirthdayViewController.swift*
    的 saveTapped(_:) 方法中，生日保存后添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE71]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了消息内容，接下来需要创建并安排在朋友生日当天发送给用户设备的通知。首先，确保在文件顶部导入 UserNotifications。然后在你刚写的消息常量下方添加以下内容：
- en: '[PRE72]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了一个 UNMutableNotificationContent，并将其存储在名为 content 的常量中。UNMutableNotificationContent
    包含用户通知的数据，如消息或声音。➋ 在这里，我们将 content.body 属性设置为生日提醒消息，即之前的 message。然后，在 ➌ 处，我们将
    content.sound 设置为默认通知声音，这与收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知内容后，我们需要创建通知的*触发器*。触发器属于 UNCalendarNotificationTrigger 类，它让应用知道何时以及多久发送一次通知。我们将设置在每年某人的生日当天上午
    8 点发送生日通知。Swift 允许我们使用 Calendar 和 DateComponents 类只获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，在设置 content.sound 后创建一个触发器：
- en: '[PRE73]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，首先我们通过 Calendar 方法 dateComponents(_:from:) 从 birthDate 获取月份和日期的 DateComponents。我们仅传入
    [.month, .day] 作为组件 ➊，而不传入年份。这是因为我们希望触发器每年都触发，而不是仅在某人出生的年份（已经是过去的年份，所以无论如何都不会发生！）。我们希望在上午
    8 点发送生日通知，因此接下来我们将 dateComponents.hour 设置为 8 ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌，我们通过初始化器创建 UNCalendarNotificationTrigger。这个初始化器接受两个参数：一个是 dateComponents，另一个是布尔值，表示你是否希望触发器重复。我们希望触发器每年重复一次，所以我们传入
    true。Swift 会智能地处理触发器重复的频率。例如，如果你传入的 DateComponents 只有小时和分钟，它将每天在那个时间触发通知。因为我们传入了月份和日期，所以触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-701
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和 DateComponents 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 日历和 DateComponents 类使得创建日期和时间变得非常容易。DateComponents 有整数属性，可以设置日期和时间的年份、月份、日期、小时、分钟和秒数，或者时间间隔。Calendar
    类有方法可以将 DateComponents 转换为 Date，反之亦然。为了尝试创建日期，打开你的 Swift playground。我们将创建一个 1971
    年 5 月 10 日 8:23 AM 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 myDateComponents 的变量 ➊，它将用来创建我们的日期。创建 myDateComponents 后，我们可以为它的各个属性设置整数。年度中的月份都用数字表示，从
    1（代表 1 月）到 12（代表 12 月）。例如，对于 5 月，我们将 myDateComponents.month 设置为 5 ➋。对于早上 8 点，我们将
    myDateComponents.hour 设置为 8 ➌。myDateComponents 的属性使用 24 小时制，因此一天中的每个小时都以数字顺序标记，从午夜
    0 点开始。例如，中午之前的所有小时和 12 小时制相同，但对于下午 2 点，它比中午多了两小时，因此我们将 myDateComponents 设置为 14。另一个例子是，晚上
    11 点将是 23。最后，我们可以通过在 Calendar 类上使用 date(from:) 方法，使用 myDateComponents 创建一个日期 ➍。为了使用这个方法，我们首先需要一个
    Calendar 实例。我们使用 Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这是公历，它有 12 个月和一个 7 天的周。
- en: '![](Image00265.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个 Date 中获取 DateComponents，我们使用 Calendar 方法 myDateComponents(_:from:)。此方法接受两个参数：第一个是你想从
    Date 中获取的 DateComponents 数组，第二个是 Date 本身。如果你想创建一个新的 Date 对象，它表示今天的日期，但例如是早上 8
    点，myDateComponents(_:from:) 方法非常有用。
- en: 'Write the following in your playground:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 playground 中写入以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其赋值给一个名为 today 的常量。接下来，我们从 today 中获取月份、日期和年份的 myDateComponents
    ➋。请注意，我们只传入我们关心的 DateComponents 属性。例如，我们不需要小时、分钟或秒数。我们将 myDateComponents 设为变量，而不是常量，因为我们要设置小时属性，这一操作在
    ➌ 处进行。最后，我们使用 myDateComponents ➍ 创建了一个名为 todayEightAm 的新日期。你应该能看到这个新日期与今天相同，唯一不同的是时间是早上
    8 点。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，我们几乎准备好创建一个 UNNotificationRequest 对象来安排通知了。但是，要创建 UNNotificationRequest，首先我们需要一个标识符。这个标识符是一个字符串，可以用来标识该通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从应用中删除一个生日，我们还将使用这个标识符来删除已安排的通知。毕竟，你不会希望收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 12 章](text00023.html#ch12)中，我们为生日对象添加了一个 birthdayId 属性，所以我们将使用 birthdayId
    作为通知的标识符。首先，我们需要解包可选的 birthdayId 属性，并将其存储在名为 identifier 的常量中。然后，我们可以使用 identifier
    和 trigger 创建一个通知请求。在创建 trigger 后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE74]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用 identifier、content 和 trigger 创建 UNNotificationRequest。请求创建后，必须将其添加到
    UNUserNotificationCenter 中。为此，我们创建一个名为 center 的常量 ➋，它是当前应用程序的 UNUserNotificationCenter。然后，我们使用方法
    add(_:withCompletionHandler:) 来添加我们调度的通知请求 ➌。该方法需要两个参数，一个是 UNNotificationRequest，另一个是一个闭包作为
    completionHandler，在通知被添加后执行一些操作。我们将请求作为第一个参数传入，由于我们在请求添加后不需要做任何操作，因此传入 nil 作为
    completionHandler。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写调度通知的方法！现在，如果你运行应用程序并创建生日对象，当某人过生日时，你就会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日，并等到早上 8 点通知才会出现。但是等待整整一天来测试代码太长了！为了立即测试代码，将其调整为让通知更快触发。将
    myDateComponents 的小时和分钟设置为从当前时间起 10 分钟后。如果现在是下午 1:35，将刚才写的代码更改为以下内容：
- en: '[PRE75]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序，添加一个今天日期的生日，点击停止按钮关闭应用程序（但保持模拟 iPhone 窗口打开），然后等待 10 分钟。你应该会看到一个像[图
    13-4](text00024.html#ch13fig4)中的通知出现。测试后，别忘了将代码改回去，这样通知就会在早晨一开始时触发！
- en: '![](Image00267.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：一种横幅样式的生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中删除一个生日时，我们还需要取消其对应的通知，这可以通过在 BirthdaysTableViewController 中添加一些代码来实现。一个合适的位置是在用户选择要删除的生日后，放在
    tableView(_:commitEditingStyle:forRowAtIndexPath:) 方法中。向该方法添加以下几行代码：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE76]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除某个生日的通知，首先我们解包 birthdayId 以便将其用作标识符 ➊。接下来，我们获取 UNUserNotificationCenter ➋，并移除通知
    ➌。remove 方法接受一个标识符数组，这样你可以一次移除多个通知，但由于我们只想移除一个，所以传入 [identifier]，它是一个包含一个值的数组。
- en: '**NOTE**'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用程序现在已经完成！请记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取，因此你可以将你的项目与其进行对比，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向你展示了如何使用用户通知框架，在朋友的生日时提醒用户。你学习了如何添加一个每年在特定时间发送的通知，以及如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](text00025.html#part03)，你将构建另一个令人兴奋的应用——一个名为“Schoolhouse Skateboarder”的游戏，游戏中包含图形、声音等元素！
- en: '![](Image00268.jpg)'
  id: totrans-733
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在 *AppDelegate.swift* 文件的顶部添加了 `import UserNotifications` 这一行。接下来，在 application(_:didFinishLaunchingWithOptions:)
    中添加以下代码行，以请求发送本地通知的权限。
- en: '*AppDelegate.swift*'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE77]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码获取当前的 UNUserNotificationCenter，并将其存储在一个名为 center 的常量中。*通知中心* 用于调度和管理你从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类中的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权以发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一个新的通知以发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋处使用这些方法中的第一个，要求用户授予应用发送通知的权限。我们将在本章后续部分使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 有两个参数：options 和 completionHandler。在
    options 参数中，你传入一个 UNAuthorizationOptions 数组，用于指定你希望在通知中可用的选项。你可以为通知使用四种类型的 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项会在应用图标上添加一个徽章，方便用户快速查看是否有新的通知或待处理的通知。通常，这个徽章会显示一个数字，表示应用中有多少新的或待处理的通知。sound
    选项会在通知发送到手机时播放一个声音。alert 选项会以弹出警告框或顶部横幅的形式显示通知。作为应用开发者，你无法决定通知如何显示或用户是否开启通知声音。这些设置由用户在其设置应用中控制。第四个选项
    carPlay 允许在支持 CarPlay 的汽车设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警报，并在每个通知到来时播放声音，因此我们传入[.alert, .sound]作为我们的选项➌。completionHandler参数是一个闭包，它在用户授权或拒绝应用发送通知后被调用。completionHandler闭包有两个参数，granted和error
    ➍。granted参数是一个布尔值，表示是否授予了权限（如果是，则为true；如果否，则为false）。如果用户拒绝允许我们发送通知，我们不会更改应用的行为，但我们会在控制台打印一条语句➎，以便在测试应用时查看权限是否被授予或拒绝。第二个参数error是Error类类型，表示是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经请求了通知权限，用户第一次运行应用时，会显示一个警报对话框，询问是否允许应用发送通知，如[图13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-746
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：应用会询问用户是否允许发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”，他们将不会收到任何关于生日的通知。如果选择“允许”，他们将会收到通知。用户只会在应用首次安装并运行时被询问此权限。但他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们将在列表底部看到一个名为*Birthdays*的BirthdayTracker应用条目([图13-2](text00024.html#ch13fig2))。在模拟器中也可以看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到BirthdayTracker应用的设置中，将引导用户到通知设置屏幕([图13-3](text00024.html#ch13fig3))。
- en: '![](Image00261.jpg)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：在设置应用中，用户可以深入设置各个应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：我们的应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上，用户可以指定是否希望接收应用的通知，以及他们希望接收哪种类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，都希望安排一个通知，在每年生日那天发送提醒。为此，我们将在AddBirthdayViewController类的saveTapped(_:)方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，首先我们需要创建一个消息字符串，以便在通知中发送。我们的消息将是一个字符串，内容是：“祝firstName lastName今天生日快乐！”
    在*AddBirthdayViewController.swift*文件的saveTapped(_:)方法中，保存生日信息后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE78]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息内容，我们需要创建并安排通知，以便在朋友的生日那天将通知发送到用户的设备。首先，确保在文件顶部导入了 UserNotifications。然后，在刚刚写好的
    message 常量下面添加以下内容：
- en: '[PRE79]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处的代码创建了一个 UNMutableNotificationContent，并将其存储在一个名为 content 的常量中。UNMutableNotificationContent
    包含用户通知的数据，如消息或声音。在 ➋ 处，我们将 content.body 属性设置为生日提醒消息，消息的名称为 message。然后，在 ➌ 处，我们将
    content.sound 设置为默认的通知声音，即你收到短信时播放的声音。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通知的内容后，我们需要创建通知的 *触发器*。触发器属于 UNCalendarNotificationTrigger 类，它让应用程序知道何时以及多频繁地发送通知。我们将安排每年在那个人的生日的
    8 点发送生日通知。Swift 让我们通过使用 Calendar 和 DateComponents 类仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码来设置 content.sound 后创建触发器：
- en: '[PRE80]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，首先我们通过使用 Calendar 方法 dateComponents(_:from:) 从 birthDate 获取月份和日期的 DateComponents。我们传入
    [.month, .day] 作为组件 ➊，而不传入年份。这是因为我们希望每年都触发这个通知，而不仅仅是在那个人出生的年份——而那已经是过去的事情，所以无论如何都不会发生！我们希望在早上
    8 点发送生日通知，所以接下来我们将 dateComponents 的 .hour 设置为 8 ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用其初始化器创建 UNCalendarNotificationTrigger。该初始化器接受两个参数：dateComponents 和一个布尔值，表示你是否希望触发器重复。我们希望触发器每年重复一次，因此传入
    true。Swift 很聪明，知道你希望触发器多长时间重复一次。例如，如果你传入的只是小时和分钟的 DateComponents，它会在每天的那个小时和分钟触发通知。因为我们传入的是月份和日期，触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '**Calendar 和 DateComponents 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar 和 DateComponents 类使得创建日期和时间变得非常简单。DateComponents 具有整数属性，可以设置日期和时间的年份、月份、日期、小时、分钟和秒数，或者设置时间间隔。Calendar
    类有方法可以将 DateComponents 转换为 Date，反之亦然。为了尝试创建一个日期，请打开你的 Swift playground。我们将创建一个
    1971 年 5 月 10 日 8:23 AM 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-772
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为myDateComponents的变量 ➊ ，我们将用它来创建我们的日期。创建myDateComponents后，我们可以为它的各个属性设置整数。每年的月份都由数字表示，从1代表1月到12代表12月。对于5月，我们将myDateComponents.month设置为5
    ➋ 。对于上午8点，我们将myDateComponents.hour设置为8 ➌ 。myDateComponents的属性使用24小时制，因此每小时都按照数字顺序标记，一天中的每小时从午夜0点开始计算。所以，中午之前的所有小时与12小时制一样，但对于下午2点，它是在中午后两小时，我们将myDateComponents设置为14。另一个例子是，晚上11点就是23。最后，我们可以使用Calendar类的date(from:)方法
    ➍ 来从myDateComponents生成日期。要使用这个方法，我们首先需要一个Calendar实例。我们使用Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这是公历，它有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Date中获取DateComponents，我们使用Calendar方法myDateComponents(_:from:)。这个方法有两个参数：第一个是你想从Date中提取的DateComponents数组，第二个是Date本身。myDateComponents(_:from:)方法很有用，如果你想创建一个新的Date对象，表示今天的日期，但比如说是上午8点。
- en: 'Write the following in your playground:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的playground中写下以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-777
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 第➊行创建了当前的日期和时间，并将其赋值给一个名为today的常量。接下来，我们从today中获取myDateComponents的月份、日期和年份 ➋
    。请注意，我们只传入我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒。我们将myDateComponents设为变量而不是常量，因为我们将设置小时属性，这将在➌处进行。最后，我们使用myDateComponents创建一个新的日期，命名为todayEightAm
    ➍ 。你应该会看到，这个新的Date与今天相同，唯一不同的是时间是上午8点。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，我们几乎可以创建一个UNNotificationRequest对象来安排通知了。但要创建UNNotificationRequest，首先我们需要一个标识符。这个标识符是一个字符串，用于标识该通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符，在从应用中删除生日时，移除已安排的通知。毕竟，你可不想收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们为Birthday添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包可选的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger来创建一个通知请求。在创建trigger之后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE81]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们使用identifier、content和trigger创建UNNotificationRequest。创建请求后，必须将其添加到UNUserNotificationCenter中。为此，我们创建一个常量叫做center
    ➋，它是当前应用的UNUserNotificationCenter。然后，我们使用add(_:withCompletionHandler:)方法将请求添加到已调度的通知中
    ➌。此方法需要两个参数，一个是UNNotificationRequest，另一个是一个闭包作为completionHandler，用于在通知添加后执行某些操作。我们将请求传递给第一个参数，因为我们在通知添加后不需要执行任何操作，所以将completionHandler传递为nil。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，终于完成了编写调度通知的方法！现在，如果你运行应用并创建生日对象，当有人的生日时，你会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日，并等到早上8点，才能看到通知。但是等待整整一天来测试代码太长了！为了立即测试你的代码，稍微修改它，让通知更早触发。将myDateComponents的小时和分钟设置为当前时间的10分钟后。所以，如果现在是下午1:35，修改你刚刚写的代码如下：
- en: '[PRE82]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天的生日，点击停止按钮关闭应用（但保持模拟的iPhone窗口打开），等待10分钟。你应该会看到类似[图13-4](text00024.html#ch13fig4)中的通知出现。测试完成后，别忘了将代码改回去，使通知在早晨第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：横幅样式的生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中删除一个生日时，我们还需要取消其相应的通知，我们可以在BirthdaysTableViewController中添加一些代码来实现。一个合适的位置是在用户选择要删除的生日之后，在tableView(_:commitEditingStyle:forRowAtIndexPath:)方法中。向该方法中添加以下几行：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE83]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除生日通知，首先我们解包birthdayId以将其用作标识符 ➊。接着，我们获取UNUserNotificationCenter ➋并删除通知 ➌。remove方法接受一个标识符数组，这样你就可以一次删除多个通知，但由于我们只想删除一个，因此我们传递[identifier]，它是一个只有一个值的数组。
- en: '**NOTE**'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在已经完成！记得最终的项目文件可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *上找到，所以你可以对照检查，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们向你展示了如何使用用户通知框架在朋友的生日时提醒用户。你学会了如何添加一个每年特定时间发送的通知，以及如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三部分](text00025.html#part03)中，你将构建另一个令人兴奋的应用——一个名为 Schoolhouse Skateboarder
    的游戏，里面有图形、声音等内容！
- en: '![](Image00268.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: '*AppDelegate.swift*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '*AppDelegate.swift*'
- en: '[PRE84]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊的那行代码中，获取当前的 UNUserNotificationCenter 并将其存储在名为 center 的常量中。*通知中心* 用于安排和管理你从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类的三种方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一条新的通知发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除一个现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋使用这些方法中的第一个，要求用户授权允许应用发送通知。我们将在本章后面使用另外两种方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 方法接受两个参数：options 和 completionHandler。在
    options 参数中，你传入一个 UNAuthorizationOptions 数组，表示你希望在通知中使用的选项。你可以为通知使用四种 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项在你的应用图标上添加一个徽标，让用户能快速看到应用内是否有新内容。通常这是一个数字，表示应用中有多少新通知或待处理通知。sound
    选项在发送通知时播放声音。alert 选项将通知以弹窗或横幅的形式展示，弹窗会出现在屏幕中央，横幅会从屏幕顶部滑入。作为应用开发者，你无法决定通知的显示方式或是否启用通知声音，这些由用户在设置应用中控制。第四个选项
    carPlay 允许在启用 CarPlay 的汽车设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-810
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警告，并且每当通知到来时播放声音，因此我们传入 [.alert, .sound] 作为我们的选项 ➌ 。completionHandler
    参数是一个闭包，它会在用户授予或拒绝应用发送通知的权限后被调用。completionHandler 闭包有两个参数，granted 和 error ➍ 。granted
    参数是一个布尔值，表示是否授予了权限（如果为 true 表示允许，false 表示拒绝）。如果用户拒绝我们发送通知，我们不会更改应用的行为，但我们会在控制台打印一条语句
    ➎ ，这样你就可以在测试应用时查看是否已授予或拒绝权限。第二个参数 error 是 Error 类类型，用于通知你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知权限，当用户第一次运行应用时，它将显示一个提示框，询问是否允许应用发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用将请求用户允许发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”选项，他们将不会在他人的生日时收到任何通知。如果他们选择“允许”，他们将会收到通知。此设置仅会在应用首次安装后运行时询问用户一次，但他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到名为*Birthdays*的 BirthdayTracker 应用程序设置，位于列表底部（[图 13-2](text00024.html#ch13fig2)）。在模拟器中也可以看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深入进入 BirthdayTracker 应用的设置，用户将看到通知设置界面（[图 13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在设置应用中，用户可以深入设置各个应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-820
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们的应用通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，用户可以指定他们是否希望看到应用的通知以及他们希望接收哪种类型的通知（横幅或警告）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，我们都希望安排一个通知，在生日那个人的出生日期每年提醒我们。为此，我们将在 AddBirthdayViewController
    类中的 saveTapped(_:) 方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先需要创建一条消息字符串，作为通知发送。我们的消息将是一个字符串，内容是：“祝愿 firstName lastName 今天生日快乐！”将以下代码添加到
    saveTapped(_:) 方法中，紧跟在保存生日操作之后，在 *AddBirthdayViewController.swift* 文件中：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE85]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息，我们需要创建并安排一个通知，在朋友的生日那天发送到用户的设备。首先，确保在文件顶部导入了 UserNotifications。然后在刚才写的
    message 常量下面添加以下内容：
- en: '[PRE86]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个 UNMutableNotificationContent，并将其存储在一个名为 content 的常量中。UNMutableNotificationContent
    包含用户通知的数据，例如消息或声音。在 ➋ 处，我们将 content.body 属性设置为名为 message 的生日提醒消息。然后，在 ➌ 处，我们将
    content.sound 设置为默认的通知声音，这与接收到短信时的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建完通知内容后，我们需要创建通知的 *触发器*。触发器属于 UNCalendarNotificationTrigger 类，它让应用知道何时以及多频繁地发送通知。我们将安排每年在朋友生日的早上
    8 点发送生日通知。Swift 让我们通过使用 Calendar 和 DateComponents 类来获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，在设置 content.sound 后创建一个触发器：
- en: '[PRE87]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用 Calendar 方法 dateComponents(_:from:) 从 birthDate 获取月份和日期的 DateComponents。我们仅传入
    [.month, .day] 作为组件 ➊，而不传入年份。这是因为我们希望触发器每年都能触发，而不仅仅是在出生年份（那已经是过去的年份了，根本不会发生！）。我们希望在早上
    8 点发送生日通知，因此接下来我们将 dateComponents.hour 设置为 8 ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用其初始化器创建 UNCalendarNotificationTrigger。这个初始化器接受两个参数：dateComponents
    和一个布尔值，表示是否希望触发器重复。我们希望触发器每年重复，因此传入 true。Swift 会根据你希望触发器重复的频率进行智能处理。例如，如果你传入的只是小时和分钟的
    DateComponents，它会每天在那个时间触发通知。由于我们传入了月份和日期，触发器将每年重复。
- en: '![](Image00263.jpg)'
  id: totrans-836
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和 DateComponents 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar 和 DateComponents 类使得创建日期和时间变得非常简单。DateComponents 具有整数属性，可以设置日期和时间的年份、月份、日期、小时、分钟和秒，或时间间隔。Calendar
    类具有将 DateComponents 转换为 Date 或反之的功能。要尝试创建一个日期，请打开你的 Swift Playground。我们将创建一个 1971
    年 5 月 10 日早上 8:23 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-839
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个叫做myDateComponents的变量 ➊，用来创建我们的日期。创建完myDateComponents后，我们可以为它的各个属性设置整数值。每个月份都用整数来表示，按数字顺序排列，从1代表一月到12代表十二月。例如，五月我们将myDateComponents.month设为5
    ➋。对于早上8点，我们将myDateComponents.hour设为8 ➌。myDateComponents的属性使用24小时制，因此每个24小时制的小时数都用数字表示，从0表示午夜开始。所以中午之前的时间和12小时制的一样，但例如下午2点（即中午之后的两小时），我们会将myDateComponents的小时数设置为14。再举个例子，晚上11点会是23。最后，我们可以通过在Calendar类上使用date(from:)方法来根据myDateComponents创建一个日期
    ➍。使用这个方法之前，我们首先需要一个Calendar实例。我们使用Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这是公历，它有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-841
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个日期（Date）中提取DateComponents，我们使用日历方法myDateComponents(_:from:)。这个方法接受两个参数：第一个是你希望从日期中提取的DateComponents数组，第二个是日期本身。如果你想创建一个新的日期对象，表示今天的日期，但比如在早上8点钟，这个myDateComponents(_:from:)方法就非常有用。
- en: 'Write the following in your playground:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Playground中编写以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 第➊行创建了当前的日期和时间，并将其赋值给一个常量叫做today。接下来，我们从today中获取myDateComponents，包括月份、日期和年份
    ➋。注意，我们只传入了我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒。我们将myDateComponents设为变量，而不是常量，因为我们将设置小时属性，这在第➌行进行。最后，我们使用myDateComponents创建一个新的日期，叫做todayEightAm
    ➍。你会发现，新的日期与today相同，唯一的区别是时间是早上8点。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，几乎准备好创建一个UNNotificationRequest对象来安排通知了。但在创建UNNotificationRequest之前，我们首先需要一个标识符。这个标识符是一个字符串，用于标识这个通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符来移除已安排的通知，如果我们从应用中删除了一个生日。毕竟，你不会希望收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们为Birthday添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包可选的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger创建一个通知请求。请在创建trigger之后立即添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE88]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们使用identifier、content和trigger创建了UNNotificationRequest。创建完request后，必须将其添加到UNUserNotificationCenter。为此，我们创建一个名为center的常量➋，它是应用程序当前的UNUserNotificationCenter。然后我们使用add(_:withCompletionHandler:)方法将请求添加到我们计划的通知中➌。该方法接受两个参数，一个是UNNotificationRequest，另一个是一个闭包作为completionHandler，在通知添加后执行某些操作。我们将我们的请求作为第一个参数传入，由于我们不需要在请求添加后执行任何操作，所以我们将nil传入completionHandler。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写计划通知的方法！现在，如果你运行你的应用程序并创建Birthday对象，当某人过生日时，你将收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要添加一个第二天的生日，并等到早上8点才能看到通知。但等一天才能测试代码太久了！为了立即测试你的代码，可以调整它让通知更早触发。将myDateComponents的小时和分钟设置为当前时间的10分钟后。因此，如果现在是下午1:35，修改你刚才写的代码如下：
- en: '[PRE89]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序，添加今天的生日，点击停止按钮关闭应用程序（但保持模拟的iPhone窗口打开），并等待10分钟。你应该能看到像[图13-4](text00024.html#ch13fig4)中的通知那样的通知出现。测试完成后，不要忘记将代码改回，以便通知在早晨第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：生日通知的横幅样式*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用程序中删除一个生日时，我们还需要取消其对应的通知，我们可以通过在BirthdaysTableViewController中添加一些代码来实现。一个合适的位置是在用户选择删除生日后，tableView(_:commitEditingStyle:forRowAtIndexPath:)方法内。将以下代码行添加到该方法中：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE90]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除生日的通知，首先我们解包birthdayId作为标识符➊。接下来，我们获取UNUserNotificationCenter➋并移除通知➌。remove方法接受一个标识符数组，这样你可以一次删除多个通知，但由于我们只想删除一个，所以我们传入[identifier]，这是一个包含单个值的数组。
- en: '**NOTE**'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在已经完成！请记得最终的项目文件可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载，您可以对比您的文件，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-865
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用用户通知框架，在朋友生日时提醒用户。您学习了如何添加一个每年在特定时间发送的通知，以及如果用户删除了某个生日，如何移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Part 3](text00025.html#part03) 中，您将构建另一个令人兴奋的应用——一款名为 Schoolhouse Skateboarder
    的游戏，包含图形、声音等内容！
- en: '![](Image00268.jpg)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: '[PRE91]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码获取当前的 UNUserNotificationCenter 并将其存储在一个名为 center 的常量中。*通知中心* 用于调度和管理从您的应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类的三个方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求向用户添加一个新通知。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除一个现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋处使用了第一个方法，要求用户授权应用发送通知。我们将在本章后面使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 接受两个参数：options 和 completionHandler。在
    options 参数中，您传入一个 UNAuthorizationOptions 数组，指定您希望在通知中使用的选项。您可以使用四种类型的 UNAuthorizationOptions
    来配置通知：badge、sound、alert 和 carPlay。badge 选项会在应用图标上添加一个徽标，用户可以快速看到应用中是否有新内容。通常情况下，这个徽标是一个数字，表示应用中有多少个新通知或等待通知。sound
    选项会在发送通知时播放一个声音。alert 选项会在屏幕中间弹出一个通知或在屏幕顶部显示一个横幅通知。作为应用开发者，您无法决定通知的显示方式，也无法决定用户是否启用通知声音。这是用户在其设置应用中控制的内容。第四个选项，carPlay，允许在支持
    CarPlay 的设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-876
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警报，并在每次收到通知时播放声音，因此我们将[.alert, .sound]作为我们的选项传入 ➌。completionHandler
    参数是一个闭包，传入并在用户授权或拒绝应用发送通知后被调用。completionHandler 闭包有两个参数，granted 和 error ➍。granted
    参数是一个布尔值，告诉你是否获得了许可（如果获得许可，则为 true；如果拒绝，则为 false）。如果用户拒绝让我们发送通知，我们不会改变应用的行为，但我们会在控制台打印一条语句
    ➎，这样你可以在测试应用时看到权限是被授予还是拒绝的。第二个参数，error，是 Error 类类型，告诉你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知授权，当用户首次运行应用时，应用将显示一个提示框，询问是否允许发送通知，如[图 13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-879
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用将请求用户授权以发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”选项，他们将不会收到任何关于生日人的通知。如果他们选择“允许”，他们将收到通知。用户只会在应用首次安装后第一次运行时被询问这个问题。然而，他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用部分时，他们会在列表底部看到一个名为*Birthdays*的 BirthdayTracker 应用列表项（见[图 13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这个设置。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到 BirthdayTracker 应用的设置将引导用户到通知设置界面（见[图 13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-884
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在设置应用中，用户可以深入指定各个应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-886
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们的应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个界面上，用户可以指定是否希望看到应用的通知，以及他们希望看到什么类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建生日时，我们都希望安排每年在生日当天向我们发送通知。为此，我们将在 *AddBirthdayViewController* 类的 saveTapped(_:)
    方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，首先我们需要创建一个消息字符串，将其发送到通知中。我们的消息将是一个字符串，内容为：“祝 firstName lastName 今天生日快乐！”在
    *AddBirthdayViewController.swift* 中的 saveTapped(_:) 方法中，生日保存后立即添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE92]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息内容，接下来需要创建并安排通知，以便在朋友的生日时发送给用户的设备。首先，确保文件顶部导入了 `UserNotifications`。然后在你刚刚写的
    message 常量下面添加以下内容：
- en: '[PRE93]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码创建了一个 `UNMutableNotificationContent`，并将其存储到一个名为 content 的常量中。`UNMutableNotificationContent`
    包含用户通知的数据，如消息或声音。➋ 处，我们将 content.body 属性设置为名为 message 的生日提醒信息。然后，➌ 处，我们将 content.sound
    设置为默认通知声音，这与接收到短信时发出的声音相同。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好通知的内容后，我们需要创建通知的 *触发器*。触发器属于 `UNCalendarNotificationTrigger` 类，它让应用知道何时以及多长时间发送一次通知。我们将安排生日通知每年在朋友的生日当天早上
    8 点发送。Swift 让我们通过使用 `Calendar` 和 `DateComponents` 类获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完 content.sound 后，添加以下代码来创建触发器：
- en: '[PRE94]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用 Calendar 方法 `dateComponents(_:from:)` 从 birthDate 获取月份和日期的 `DateComponents`。我们仅传入
    [.month, .day] 作为组件 ➊，而不包含年份。这是因为我们希望触发器每年都触发，而不是仅在出生年份（即已经过去的年份）触发！我们希望在早上 8
    点发送生日通知，所以接下来我们将 `dateComponents.hour` 设置为 8 ➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处，我们使用其初始化方法创建了 `UNCalendarNotificationTrigger`。这个初始化方法接受两个参数：`dateComponents`
    和一个布尔值，用于指定是否希望触发器重复触发。我们希望触发器每年重复一次，所以传入 `true`。Swift 在你指定触发器重复频率时非常智能。例如，如果你传入的是仅包含小时和分钟的
    `DateComponents`，它会每天在这个小时和分钟触发通知。因为我们传入的是月份和日期，所以触发器会每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历（CALENDAR）和日期组件（DATECOMPONENTS）类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 日历（Calendar）和日期组件（DateComponents）类使得创建日期和时间变得非常简单。`DateComponents` 有可以设置的整数属性，表示日期和时间的年份、月份、日期、小时、分钟和秒，或时间间隔。`Calendar`
    类有方法可以将 `DateComponents` 转换为 `Date`，反之亦然。为了尝试创建一个日期，打开你的 Swift playground。我们将创建一个
    1971 年 5 月 10 日，早上 8:23 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-905
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 myDateComponents ➊ 的变量，用于创建我们的日期。创建完 myDateComponents 后，我们可以为它的各个属性设置整数值。每年的月份都用按数字顺序排列的整数表示，从
    1 代表一月到 12 代表十二月。对于五月，我们将 myDateComponents.month 设置为 5 ➋。对于早上 8 点，我们将 myDateComponents.hour
    设置为 8 ➌。myDateComponents 的属性使用 24 小时制，这样一天的每个小时都会按数字顺序标注，从午夜的 0 开始。所以，所有中午之前的小时数与
    12 小时制一样，但对于下午 2 点，它比中午晚了两小时，我们将 myDateComponents 设置为 14。再比如，晚上 11 点应该是 23。最后，我们可以通过在
    Calendar 类上使用 date(from:) 方法来从 myDateComponents 创建一个日期 ➍。要使用这个方法，我们首先需要一个 Calendar
    实例。我们使用 Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这是公历，它有 12 个月和 7 天的一周。
- en: '![](Image00265.jpg)'
  id: totrans-907
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个 Date 中获取 DateComponents，我们使用 Calendar 方法 myDateComponents(_:from:)。这个方法接受两个参数：第一个是你想从
    Date 中提取的 DateComponents 数组，第二个是 Date 本身。如果你想创建一个新的 Date 对象，例如今天的日期，但设置为早上 8 点，myDateComponents(_:from:)
    方法会非常有用。
- en: 'Write the following in your playground:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 playground 中写下以下代码：
- en: '![](Image00266.jpg)'
  id: totrans-910
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其赋值给一个名为 today 的常量。接下来，我们从 today 中提取出 month、day 和 year 的
    myDateComponents ➋。注意，我们只传入了我们关心的 DateComponents 属性。比如，我们不需要小时、分钟或秒。我们将 myDateComponents
    设置为变量而非常量，因为我们要设置 hour 属性，这在 ➌ 处进行。最后，我们使用 myDateComponents 创建了一个名为 todayEightAm
    的新日期 ➍。你应该会看到新创建的日期与今天相同，只不过时间是早上 8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知的内容和触发条件，我们几乎可以准备好创建一个 UNNotificationRequest 对象来安排通知。但在创建 UNNotificationRequest
    之前，我们首先需要一个标识符。这个标识符是一个字符串，可以用来标识该通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会使用这个标识符来删除如果我们从应用中删除生日时已安排的通知。毕竟，你肯定不希望收到已删除生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们向Birthday添加了一个birthdayId属性，因此我们将使用birthdayId作为通知的标识符。首先，我们需要解包可选的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger创建一个通知请求。在创建trigger之后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE95]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们使用identifier、content和trigger创建UNNotificationRequest。请求创建后，必须将其添加到UNUserNotificationCenter中。为此，我们创建一个名为center的常量➋，它是当前应用程序的UNUserNotificationCenter。然后，我们使用add(_:withCompletionHandler:)方法将请求添加到我们计划的通知中➌。该方法接受两个参数，一个是UNNotificationRequest，另一个是闭包completionHandler，用于在通知添加后执行某些操作。我们将请求作为第一个参数传入，由于我们不需要在请求添加后执行任何操作，因此我们将completionHandler设置为nil。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了编写调度通知的方法！现在，如果你运行应用并创建Birthday对象，当某人的生日到来时，你将会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日并等到早上8点，等待你的通知出现。但等待一天来测试代码实在太长了！为了立即测试代码，调整它，让通知更早触发。将myDateComponents的小时和分钟设置为当前时间后的10分钟。因此，如果现在是下午1:35，修改你刚写的代码如下：
- en: '[PRE96]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序，添加一个今天的生日，点击停止按钮关闭应用程序（但保持模拟的iPhone窗口打开），并等待10分钟。你应该能看到一个像[图13-4](text00024.html#ch13fig4)中的通知一样的内容出现。测试完后，别忘了将代码改回去，以便通知在早晨第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-922
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：生日通知的横幅样式*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-924
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用程序中移除生日时，我们还需要取消其对应的通知，这可以通过在BirthdaysTableViewController中添加一些代码来实现。一个合适的位置是在用户选择要删除的生日后，即在tableView(_:commitEditingStyle:forRowAtIndexPath:)方法中。将以下代码添加到该方法中：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE97]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除生日的通知，首先我们解包birthdayId并将其作为标识符使用➊。接下来，我们获取UNUserNotificationCenter➋并移除通知➌。remove方法接受一个标识符数组，这样你可以一次性移除多个通知，但由于我们只需要移除一个通知，我们传入[identifier]，这是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用现在已经完成！记得，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取，因此你可以与自己的文件进行对比，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-931
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用用户通知框架，在用户朋友的生日时提醒他们。你学会了如何添加一个每年在特定时间发送的通知，以及如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第三部分](text00025.html#part03) 中，你将构建另一个激动人心的应用——一款名为 Schoolhouse Skateboarder
    的游戏，包含图形、声音等元素！
- en: '![](Image00268.jpg)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码获取当前的 UNUserNotificationCenter，并将其存储在一个名为 center 的常量中。*通知中心* 用于调度和管理你从应用发送的通知。在本章中，我们将使用
    UNUserNotificationCenter 类中的三种方法：
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一个新的通知以发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 用于移除现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋处使用了第一个方法，向用户请求允许应用发送通知。我们将在本章后续部分使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 需要两个参数：options 和 completionHandler。在
    options 参数中，你需要传入一个 UNAuthorizationOptions 数组，表示你希望在通知中使用的选项。你可以为通知选择四种类型的 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项会在你的应用图标上添加一个徽章，用户可以快速看到应用中是否有新内容。这通常是一个数字，表示有多少新通知或待处理通知。sound
    选项会在发送通知时播放声音。alert 选项会将通知以弹窗或横幅的形式展示在屏幕中间或顶部。作为应用开发者，你无法决定通知的显示方式或用户是否开启通知声音，这由用户在设置应用中控制。第四个选项，carPlay，允许在支持
    CarPlay 的汽车设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-941
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知显示为警报，并在每次通知到达时播放声音，因此我们为我们的选项传入[.alert, .sound] ➌。completionHandler参数是一个闭包，当用户授予或拒绝应用发送通知的权限后，它会被调用。completionHandler闭包有两个参数，granted和error
    ➍。granted参数是一个布尔值，表示是否获得权限（如果是true，则表示已授权；如果是false，则表示已拒绝）。如果用户拒绝我们发送通知，我们不会改变应用行为，但会在控制台打印一条语句
    ➎，以便你在测试应用时查看权限是否被授予或拒绝。第二个参数error是Error类类型，它告诉你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知权限，第一次用户运行应用时，系统会弹出一个对话框询问是否允许发送通知，如[图13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用会请求用户授权发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在此处选择“不允许”选项，他们将不会收到任何生日通知。如果他们选择“允许”，他们将会收到通知。用户仅会在应用第一次运行且进行全新安装后被询问此问题，但他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到列出了BirthdayTracker应用，并标注为*Birthdays*，位于列表的底部（[图13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这个。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 进入BirthdayTracker应用的设置页面会引导用户进入通知设置屏幕（[图13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-949
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在设置应用中，用户可以进一步设置他们的应用通知选项。*'
- en: '![](Image00262.jpg)'
  id: totrans-951
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，用户可以指定是否希望接收应用的通知，以及他们希望接收什么类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**安排通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，我们都希望安排一个通知，在每年的生日当天向我们发送通知。为此，我们将在AddBirthdayViewController类的saveTapped(_:)方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，首先我们需要创建一个消息字符串，用于发送通知。我们的消息字符串内容是：“祝firstName lastName今天生日快乐！” 在*AddBirthdayViewController.swift*的saveTapped(_:)方法中，生日保存后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE98]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息内容，我们需要创建并安排一个将在朋友生日当天发送到用户设备的通知。首先，确保在文件顶部导入 UserNotifications。然后在你刚写的消息常量下面添加以下内容：
- en: '[PRE99]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了一个 UNMutableNotificationContent，并将其存储在名为 content 的常量中。UNMutableNotificationContent
    包含用户通知的数据，例如消息或声音。在 ➋ 处，我们将 content.body 属性设置为名为 message 的生日提醒消息。然后在 ➌ 处，我们将 content.sound
    设置为默认的通知声音，即收到短信时发出的声音。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完通知的内容后，我们需要创建通知的 *触发器*。触发器属于 UNCalendarNotificationTrigger 类，并让应用知道何时以及多久发送一次通知。我们将安排每年在某人生日当天早上
    8 点发送生日通知。Swift 让我们通过使用 Calendar 和 DateComponents 类仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完 content.sound 后，添加以下代码来创建一个触发器：
- en: '[PRE100]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用 Calendar 方法 dateComponents(_:from:) 从 birthDate 获取月份和日期的 DateComponents。我们仅传入
    [.month, .day] 作为组件 ➊ ，而不传入年份。这是因为我们希望触发器每年都触发，而不仅仅是在那个人出生的年份——那是过去的年份，反正也不会发生！我们希望在早上
    8 点发送生日通知，所以接下来我们将 dateComponents 的 .hour 设置为 8 ➋ 。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们使用初始化器创建 UNCalendarNotificationTrigger。这个初始化器接受两个参数：dateComponents 和一个布尔值，表示是否希望触发器重复执行。我们希望触发器每年重复，所以我们传入
    true。Swift 会根据你希望触发器多久重复一次做出智能判断。例如，如果你只传入了小时和分钟的 DateComponents，它会每天在那个小时和分钟触发通知。因为我们传入了月份和日期，触发器会每年重复执行。
- en: '![](Image00263.jpg)'
  id: totrans-967
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**Calendar 和 DateComponents 类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar 和 DateComponents 类让创建日期和时间变得非常简单。DateComponents 拥有整数属性，可以设置日期和时间的年份、月份、日期、小时、分钟和秒，或者时间间隔。Calendar
    类有方法将 DateComponents 转换为 Date，反之亦然。要尝试创建一个日期，请打开你的 Swift playground。我们将创建一个 1971
    年 5 月 10 日，上午 8:23 的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-970
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为 myDateComponents 的变量 ➊，我们将用它来创建日期。在创建 myDateComponents 之后，我们可以为其不同的属性设置整数值。每年的月份都由整数按数字顺序表示，从
    1（代表一月）到 12（代表十二月）。对于五月，我们将 myDateComponents.month 设置为 5 ➋。对于早上 8 点，我们将 myDateComponents.hour
    设置为 8 ➌。myDateComponents 属性使用 24 小时制，因此每个 24 小时制的一天中的小时都会按数字顺序标记，从午夜的 0 点开始。因此，所有中午之前的小时数与
    12 小时制相同，但对于下午 2 点（即中午后的两个小时），我们会将时间设置为 14。再举个例子，晚上 11 点会是 23。最后，我们可以通过使用 Calendar
    类的 date(from:) 方法来根据 myDateComponents 创建日期 ➍。要使用此方法，我们首先需要一个 Calendar 实例。我们使用
    Calendar.current，它返回设备正在使用的日历类型。在大多数西方国家，这就是公历，它有 12 个月和 7 天一周。
- en: '![](Image00265.jpg)'
  id: totrans-972
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Date 中获取 DateComponents，我们使用 Calendar 方法 myDateComponents(_:from:)。该方法需要两个参数：第一个是你希望从
    Date 中获取的 DateComponents 数组，第二个是 Date 本身。myDateComponents(_:from:) 方法在你想要创建一个新的日期对象（例如今天的日期，但在早上
    8 点）时非常有用。
- en: 'Write the following in your playground:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 playground 中写下以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-975
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其赋值给一个名为 today 的常量。接下来，我们从 today 中提取出月份、日期和年份的 myDateComponents
    ➋。请注意，我们只传入了我们关心的 DateComponents 属性。例如，我们不需要小时、分钟或秒数。我们将 myDateComponents 设置为变量而不是常量，因为我们将要设置小时属性，这一步在
    ➌ 进行。最后，我们使用 myDateComponents 创建了一个新的日期，名为 todayEightAm ➍。你应该能看到，新的日期与今天相同，唯一的不同是时间是早上
    8:00。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发条件，我们几乎准备好创建一个 UNNotificationRequest 对象来调度通知了。但是，在创建 UNNotificationRequest
    之前，我们首先需要一个标识符。这个标识符是一个字符串，可以用来识别通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符来删除一个已调度的通知，如果我们从应用中删除一个生日的话。毕竟，你可不想收到已经删除的生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们为Birthday添加了一个birthdayId属性，所以我们将使用birthdayId作为通知的标识符。首先，我们需要解包可选的birthdayId属性，并将其存储在一个名为identifier的常量中。然后，我们可以使用identifier和trigger创建一个通知请求。在trigger创建之后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE101]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用identifier、content和trigger创建UNNotificationRequest。创建request后，必须将其添加到UNUserNotificationCenter中。为此，我们创建一个名为center的常量
    ➋，它是应用当前的UNUserNotificationCenter。然后我们使用方法add(_:withCompletionHandler:)将我们的通知请求添加到已安排的通知中
    ➌。此方法接受两个参数，一个UNNotificationRequest和一个闭包作为completionHandler，当通知被添加后执行某些操作。我们将请求作为第一个参数传入，由于我们不需要在请求添加后执行任何操作，所以将nil传给completionHandler。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了写定时通知的方法！现在，如果你运行应用并创建生日对象，当某人过生日时，你会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的通知，你需要为第二天添加一个生日，并等到早上8点通知才会出现。但等一天测试代码实在太长了！为了现在就能测试你的代码，可以调整代码让通知更早出现。将myDateComponents的小时和分钟设置为当前时间的10分钟后。所以如果现在是下午1:35，修改你刚刚写的代码如下：
- en: '[PRE102]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用，添加一个今天日期的生日，点击停止按钮关闭应用（但保持模拟iPhone的窗口打开），等待10分钟。你应该能看到像[图13-4](text00024.html#ch13fig4)一样的通知出现。测试完成后，别忘了把代码改回，让通知在早晨第一时间触发！
- en: '![](Image00267.jpg)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：一种横幅式生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-989
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中删除生日时，我们还需要取消其相应的通知，可以通过在BirthdaysTableViewController中添加一些代码来实现。在用户选择要删除的生日后，表格视图方法tableView(_:commitEditingStyle:forRowAtIndexPath:)是个合适的地方。向该方法添加以下几行代码：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE103]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除生日的通知，首先我们解包birthdayId并将其作为标识符 ➊。接着，我们获取UNUserNotificationCenter ➋并移除通知 ➌。remove方法接受一个标识符数组，这样你可以一次删除多个通知，但因为我们只想删除一个，所以传入[identifier]，它是一个数组，但只有一个值。
- en: '**NOTE**'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用程序现在已经完成！请记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取，因此您可以对比自己的文件，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**您学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您展示了如何使用 User Notifications 框架在朋友的生日时提醒用户。您学会了如何添加一个每年特定时间发送的通知，并且还学会了如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Part 3](text00025.html#part03) 中，您将构建另一个令人兴奋的应用——一款名为 Schoolhouse Skateboarder
    的游戏，其中包含图形、音效等元素！
- en: '![](Image00268.jpg)'
  id: totrans-999
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: requestAuthorization(options:completionHandler:) 请求用户授权发送通知。
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一个新的通知以发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 删除现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋处使用了这些方法中的第一种，要求用户授权应用程序发送通知。我们将在本章后续部分使用其他两种方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 接受两个参数：options 和 completionHandler。在
    options 参数中，您需要传入一个 UNAuthorizationOptions 数组，指定希望在通知中启用的选项。UNAuthorizationOptions
    有四种类型，您可以为通知使用：badge、sound、alert 和 carPlay。badge 选项会在应用图标上添加一个徽章，以便用户快速查看应用中是否有新内容。通常，这个徽章是一个数字，表示应用中有多少条新的或待处理的通知。sound
    选项会在发送通知到手机时播放一个声音。alert 选项会以弹出警告的形式显示通知，或以横幅的形式出现在屏幕顶部。作为应用开发者，您无法决定通知的显示方式或是否启用通知声音，这是用户在设置应用中控制的。第四个选项
    carPlay 允许在支持 CarPlay 的设备上接收通知。
- en: '![](Image00259.jpg)'
  id: totrans-1005
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知作为警报显示给用户，并在每个通知到来时播放声音，因此我们传入了[.alert, .sound]作为我们的选项 ➌。completionHandler
    参数是一个闭包，它在用户授予或拒绝应用发送通知的权限后被传入并调用。completionHandler 闭包有两个参数，granted 和 error ➍。granted
    参数是一个布尔值，用来告诉你是否授予了权限（如果是，则为 true），否则为拒绝（false）。如果用户拒绝让我们发送通知，我们不会改变应用的行为，但我们会在控制台打印一条语句
    ➎，这样你就可以在测试应用时看到是否授予了权限或被拒绝。第二个参数 error 是 Error 类类型，它告诉你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经请求了通知授权，当用户第一次运行应用时，它会显示一个警报对话框，询问他们是否希望允许应用发送通知，如 [图 13-1](text00024.html#ch13fig1)
    所示。
- en: '![](Image00260.jpg)'
  id: totrans-1008
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：应用会询问用户是否允许其发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在此选择“不允许”选项，他们将无法接收到关于生日的任何通知。如果选择“允许”，他们将接收到通知。用户仅在首次运行应用（新安装后）时被询问此权限。然而，他们可以随时在设置应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开设置应用并滚动到应用程序部分时，他们会看到底部列出了 BirthdayTracker 应用，标注为 *Birthdays*（如 [图 13-2](text00024.html#ch13fig2)
    所示）。你也可以在模拟器中看到这一点。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到 BirthdayTracker 应用设置将引导用户到通知设置屏幕（如 [图 13-3](text00024.html#ch13fig3) 所示）。
- en: '![](Image00261.jpg)'
  id: totrans-1013
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：在设置应用中，用户可以深入指定他们应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-1015
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上，用户可以指定是否希望看到该应用的通知以及他们想要什么类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1018
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**调度通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，我们希望安排一个通知，在每年生日当天向我们发送通知。为此，我们将在 AddBirthdayViewController 类的 saveTapped(_:)
    方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，首先我们需要创建一条将要发送的通知消息字符串。我们的消息将是一个字符串，内容为：“今天祝 firstName lastName 生日快乐！”
    在 *AddBirthdayViewController.swift* 的 saveTapped(_:) 方法中生日保存后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE104]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息内容，我们需要创建并安排一个通知，以便在朋友的生日时发送到用户的设备。首先，确保在文件顶部导入UserNotifications。然后在刚才写的message常量下面添加以下代码：
- en: '[PRE105]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 第➊行创建了一个UNMutableNotificationContent并将其存储到一个名为content的常量中。UNMutableNotificationContent包含用户通知的数据，例如消息或声音。在第➋行，我们将content.body属性设置为名为message的生日提醒消息。然后，在第➌行，我们将content.sound设置为默认通知声音，也就是收到短信时的相同声音。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建完通知内容后，我们需要创建通知的*触发器*。触发器属于UNCalendarNotificationTrigger类，告诉应用何时以及多频繁地发送通知。我们将安排每年在朋友的生日早上8点发送生日通知。Swift让我们通过使用Calendar和DateComponents类，仅获取触发日期的月份和日期。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置content.sound之后，添加以下代码来创建触发器：
- en: '[PRE106]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先我们通过使用Calendar方法dateComponents(_:from:)从birthDate中获取月和日的DateComponents。我们只传入[.month,
    .day]作为组件➊，而不传入年份。这是因为我们希望触发器每年都触发，而不仅仅是生日的年份——那是在过去的年份，所以根本不会触发！我们希望在早上8点发送生日通知，所以接下来我们将dateComponents.hour设置为8➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 在第➌行，我们使用UNCalendarNotificationTrigger的初始化器创建触发器。该初始化器接受两个参数：dateComponents和一个布尔值，用于指示是否希望触发器重复。我们希望触发器每年重复，所以我们传入true。Swift会智能地处理你希望触发器重复的频率。例如，如果你传入的DateComponents只有小时和分钟，它会每天在那个小时和分钟触发通知。因为我们传入了月和日，触发器会每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-1031
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和DateComponents类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 日历和DateComponents类使得创建日期和时间变得非常简单。DateComponents具有整数属性，可以设置日期和时间的年份、月份、日期、小时、分钟和秒，或者时间间隔。Calendar类具有将DateComponents转换为Date的方法，反之亦然。为了尝试创建日期，打开你的Swift
    Playground。我们将创建一个1971年5月10日早上8:23的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-1034
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为myDateComponents ➊ 的变量，用于创建我们的日期。创建myDateComponents 后，我们可以为它的各种属性设置整数值。一年中的月份都用数字按顺序表示，从1表示一月到12表示十二月。对于五月，我们将myDateComponents.month
    设置为5 ➋ 。对于早上8点，我们使用8赋值给myDateComponents.hour ➌ 。myDateComponents 的属性使用24小时制，因此一天24小时中的每个小时按数字顺序标记，从0表示午夜开始。所以中午之前的每个小时与12小时制相同，但对于下午2点，即中午过后的两小时，我们会在12的基础上加上2并将myDateComponents
    设置为14。再举个例子，晚上11点会是23。最后，我们可以通过使用Calendar类的date(from:)方法从myDateComponents 创建一个日期
    ➍ 。要使用这个方法，我们首先需要一个Calendar实例。我们使用Calendar.current，它返回设备使用的日历类型。在大多数西方国家，这是公历，它有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-1036
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Date中获取DateComponents，我们使用Calendar方法myDateComponents(_:from:)。这个方法有两个参数：第一个是你想从Date中获取的DateComponents数组，第二个是Date本身。myDateComponents(_:from:)方法在你想创建一个新的Date对象，表示今天的日期但时间是早上8点时非常有用。
- en: 'Write the following in your playground:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的playground中编写以下内容：
- en: '![](Image00266.jpg)'
  id: totrans-1039
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其赋值给一个名为today的常量。接下来，我们从today中获取myDateComponents 的月份、日期和年份
    ➋ 。请注意，我们仅传递我们关心的DateComponents属性。例如，我们不需要小时、分钟或秒数。我们将myDateComponents 定义为一个变量，而不是常量，因为我们要设置小时属性，这个操作在➌
    进行。最后，我们使用myDateComponents 创建一个新的日期，命名为todayEightAm ➍ 。你应该看到，新的日期与today相同，唯一不同的是时间是早上8点。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发器，我们几乎准备好创建一个UNNotificationRequest对象来调度通知了。但是在创建UNNotificationRequest之前，我们首先需要一个标识符。这个标识符是一个字符串，用于标识通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符来移除已调度的通知，如果我们从应用程序中删除了生日。毕竟，你可不希望收到已经删除的生日的通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](text00023.html#ch12)中，我们向`Birthday`添加了一个`birthdayId`属性，所以我们将使用`birthdayId`作为通知的标识符。首先，我们需要解包可选的`birthdayId`属性，并将其存储在一个常量`identifier`中。接下来，我们可以使用`identifier`和`trigger`创建一个通知请求。创建完`trigger`后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE107]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用`identifier`、`content`和`trigger`创建`UNNotificationRequest`。创建完请求后，必须将其添加到`UNUserNotificationCenter`。为此，我们创建一个常量`center`
    ➋ ，它是应用当前的`UNUserNotificationCenter`。然后，我们使用`add(_:withCompletionHandler:)`方法来添加我们的已调度通知请求
    ➌ 。该方法有两个参数，第一个是`UNNotificationRequest`，第二个是一个闭包`completionHandler`，它在通知被添加后执行某些操作。我们将请求传入第一个参数，由于我们不需要在请求添加后执行任何操作，因此将`nil`传入`completionHandler`。
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们刚刚完成了调度通知的方法！现在，如果你运行应用并创建生日对象，当有人过生日时，你就会收到通知！
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的通知，你需要为第二天添加一个生日，并等到早上8点让通知出现。但等待整整一天来测试代码实在是太久了！为了现在就能测试代码，可以调整它，使通知尽早触发。将`myDateComponents`的小时和分钟设置为距离当前时间10分钟。如果现在是下午1:35，就将你刚写的代码改为如下：
- en: '[PRE108]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行应用程序，添加一个今天的生日，点击停止按钮关闭应用（但保持模拟的iPhone窗口打开），并等待10分钟。你应该会看到像[图13-4](text00024.html#ch13fig4)中的通知一样出现。测试后，别忘了把代码改回去，以便通知能在早晨第一时间弹出！
- en: '![](Image00267.jpg)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00267.jpg)'
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：一种横幅样式的生日通知*'
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1053
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移除通知**'
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从应用中移除一个生日时，我们也想要取消其对应的通知，可以通过在`BirthdaysTableViewController`中添加一些代码来实现。一个好地方是当用户选择删除某个生日时，在`tableView(_:commitEditingStyle:forRowAtIndexPath:)`方法中。向该方法添加以下代码：
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdaysTableViewController.swift*'
- en: '[PRE109]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除生日通知，首先我们解包`birthdayId`并将其作为标识符 ➊ 。接下来，我们获取`UNUserNotificationCenter` ➋ 并移除通知
    ➌ 。`remove`方法接受一个标识符数组，这样你可以一次性移除多个通知，但由于我们只想移除一个通知，我们传入的是[identifier]，这是一个包含单个值的数组。
- en: '**NOTE**'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用程序现在已经完成！记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得，所以你可以将自己的版本与其进行比较，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1060
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用用户通知框架，在用户朋友的生日时提醒他们。你学会了如何添加一个每年在特定时间发送的通知，并且如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 部分](text00025.html#part03)中，你将构建另一个令人兴奋的应用程序——一个名为 Schoolhouse Skateboarder
    的游戏，包含图形、声音等功能！
- en: '![](Image00268.jpg)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: add(_:withCompletionHandler:) 请求添加一个新的通知，发送给用户。
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 移除现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ➋ 处使用了这些方法中的第一个，请求用户授权应用发送通知。我们将在本章稍后使用其他两个方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 接受两个参数：options 和 completionHandler。在
    options 参数中，你传入一个 UNAuthorizationOptions 数组，表示你希望在通知中使用的选项。你可以使用四种类型的 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项在应用程序图标上添加一个徽章，用户可以快速查看应用中是否有新内容。这通常是一个数字，表示应用中有多少新通知或等待通知。sound
    选项在通知发送到手机时播放一个声音。alert 选项以弹出警报或顶部横幅的形式显示通知。你作为开发者不能决定通知的显示方式，也不能控制用户是否启用通知的声音。这由用户在设置应用中控制。第四个选项，carPlay，允许在支持
    CarPlay 的车载设备上接收通知。
- en: '![](Image00259.jpg)'
  id: totrans-1068
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将通知作为警报显示给用户，并在每次通知到达时播放声音，因此我们传入[.alert, .sound]作为我们的选项 ➌。completionHandler参数是一个闭包，会在用户授予或拒绝允许应用发送通知后调用。completionHandler闭包有两个参数，granted和error
    ➍。granted参数是一个布尔值，告诉你是否授权（如果是授权，则为true；如果是拒绝，则为false）。如果用户拒绝允许我们发送通知，我们不会改变应用的行为，但我们会在控制台打印一条语句
    ➎，这样你在测试应用时可以看到是否授权。第二个参数error是Error类类型，告诉你是否发生了某种错误。
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已请求授权接收通知，当用户第一次运行应用时，它会显示一个弹窗，询问是否允许应用发送通知，如[图13-1](text00024.html#ch13fig1)所示。
- en: '![](Image00260.jpg)'
  id: totrans-1071
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00260.jpg)'
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：应用会请求用户授权发送通知。*'
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在这里选择“不允许”，他们将不会接收到关于生日人物的任何通知。如果选择“允许”，他们将接收到通知。用户仅在应用首次安装并运行时被询问此问题。然而，他们可以随时在“设置”应用中更改通知设置。
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户打开“设置”应用并滚动到应用程序部分时，他们会在列表底部看到一个名为*Birthdays*的BirthdayTracker应用列表项（见[图13-2](text00024.html#ch13fig2)）。你也可以在模拟器中看到这个设置。
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 深入到BirthdayTracker应用的设置将引导用户到通知设置屏幕（见[图13-3](text00024.html#ch13fig3)）。
- en: '![](Image00261.jpg)'
  id: totrans-1076
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00261.jpg)'
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：在“设置”应用中，用户可以深入指定他们应用的通知设置。*'
- en: '![](Image00262.jpg)'
  id: totrans-1078
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00262.jpg)'
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：我们应用的通知设置*'
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，用户可以指定是否希望接收应用的通知，以及希望接收哪种类型的通知（横幅或警报）。
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1081
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**调度通知**'
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个生日时，我们都希望在每年该人生日的当天发送通知。为此，我们将在AddBirthdayViewController类的saveTapped(_:)方法中添加一些代码。
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，首先我们需要创建一个将要发送的通知消息字符串。我们的消息将是一个字符串，内容为：“祝firstName lastName今天生日快乐！”在*AddBirthdayViewController.swift*中的saveTapped(_:)方法保存生日后，添加以下代码：
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '*AddBirthdayViewController.swift*'
- en: '[PRE110]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了消息，需要创建并安排通知，以便在朋友的生日那天将通知发送到用户的设备。首先，确保在文件顶部导入了UserNotifications。然后，在你刚刚编写的message常量下方添加以下内容：
- en: '[PRE111]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 第➊行创建了一个UNMutableNotificationContent，并将其存储到一个名为content的常量中。UNMutableNotificationContent包含了用户通知的数据，例如消息或声音。在➋行，我们将content.body属性设置为名为message的生日提醒消息。接着，在➌行，我们将content.sound设置为默认的通知声音，也就是你收到短信时的声音。
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建完通知的内容后，我们需要创建通知的*触发器*。触发器属于UNCalendarNotificationTrigger类，并让应用知道何时以及多频繁地发送通知。我们将安排生日通知在每年朋友生日的早上8点发送。Swift允许我们通过使用Calendar和DateComponents类仅获取触发日期的月和日。
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完content.sound之后，添加以下代码来创建触发器：
- en: '[PRE112]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先我们通过使用Calendar方法dateComponents(_:from:)从birthDate中获取月和日的DateComponents。我们只传入[.month,
    .day]作为components➊，而不包括年份。这是因为我们希望触发器每年都生效，而不是仅仅在这个人出生的年份（那已经是过去的事情，所以不可能发生！）。我们希望在每年生日的早上8点发送生日通知，因此接下来我们将dateComponents.hour设置为8➋。
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌行，我们使用其初始化器创建UNCalendarNotificationTrigger。这个初始化器有两个参数：dateComponents和一个布尔值，表示是否希望触发器重复。我们希望触发器每年都重复一次，因此传入true。Swift会智能地处理触发器的重复频率。例如，如果你传入的是只包含小时和分钟的DateComponents，它会每天在那个小时和分钟触发通知。因为我们传入的是月和日，触发器将每年重复一次。
- en: '![](Image00263.jpg)'
  id: totrans-1094
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00263.jpg)'
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '**日历和DateComponents类**'
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 日历（Calendar）和DateComponents类使得创建日期和时间变得非常简单。DateComponents具有可以设置日期和时间的年份、月份、日期、小时、分钟和秒数的整数属性，或者设置时间间隔。Calendar类有方法可以将DateComponents转换为Date，或者反之。要尝试创建一个日期，请打开你的Swift
    Playground。我们将创建一个1971年5月10日，上午8:23的日期和时间：
- en: '![](Image00264.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00264.jpg)'
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为myDateComponents ➊ 的变量，用来生成我们的日期。在创建myDateComponents 后，我们可以为其各种属性设置整数值。年度的月份都用数字表示，按顺序排列，从1表示1月到12表示12月。对于5月，我们将myDateComponents.month设置为5
    ➋ 。对于上午8点，我们将myDateComponents.hour设置为8 ➌ 。myDateComponents 使用24小时制，因此一天中的每个小时都按数字顺序标记，从午夜的0点开始。所以，正午之前的所有小时与12小时制时钟相同，但对于下午2点，这是正午之后的两个小时，我们将其设置为14。另一个例子是，晚上11点应该是23。最后，我们可以使用Calendar类的date(from:)方法通过myDateComponents
    创建一个日期 ➍ 。要使用此方法，我们首先需要一个Calendar实例。我们使用Calendar.current，它返回设备当前使用的日历类型。在大多数西方国家，这是公历（格里高利历），它有12个月和7天一周。
- en: '![](Image00265.jpg)'
  id: totrans-1099
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00265.jpg)'
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Date 中获取DateComponents ，我们使用Calendar方法myDateComponents(_:from:) 。该方法需要两个参数：第一个是你想从Date
    中提取的DateComponents 数组，第二个是Date 本身。如果你想创建一个新的Date对象，比如今天的日期，但时间设为上午8点，这个myDateComponents(_:from:)方法就很有用。
- en: 'Write the following in your playground:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的playground中写下以下代码：
- en: '![](Image00266.jpg)'
  id: totrans-1102
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00266.jpg)'
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 这一行创建了当前的日期和时间，并将其赋值给一个名为today 的常量。接下来，我们从today 中获取myDateComponents 的月份、日期和年份
    ➋ 。注意，我们只传入我们关心的DateComponents 属性。例如，我们不需要小时、分钟或秒。我们将myDateComponents 设置为变量而不是常量，因为我们将要设置小时属性，这一操作发生在
    ➌ 。最后，我们使用myDateComponents 创建一个新的日期对象，命名为todayEightAm ➍ 。你应该会看到这个新的日期和today 相同，唯一不同的是时间是早上8点。
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知内容和触发器，我们几乎准备好创建一个UNNotificationRequest对象来安排通知了。但在创建UNNotificationRequest
    之前，我们首先需要一个标识符。这是一个字符串，用于标识该通知。
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用这个标识符来删除一个已安排的通知，如果我们从应用程序中删除了一个生日通知。毕竟，你不会希望收到已删除的生日通知！
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1114
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '*BirthdayTracker 应用程序现已完成！请记住，最终的项目文件可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取，因此你可以将自己的项目与其对比，确保一切都在正确的位置。*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-1123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用用户通知框架来提醒用户朋友的生日。你学会了如何添加每年在特定时间发送的通知，也学会了如何在用户从应用中删除生日时移除该通知。
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](text00025.html#part03)中，你将构建另一个令人兴奋的应用程序——一款名为 Schoolhouse Skateboarder
    的游戏，包含图形、声音等更多内容！
- en: '![](Image00268.jpg)'
  id: totrans-1126
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00268.jpg)'
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: removePendingNotificationRequests(withIdentifiers:) 用于移除现有的通知。
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋处使用这些方法中的第一个来请求用户授予应用程序发送通知的权限。我们将在本章后面使用另外两种方法。
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 requestAuthorization(options:completionHandler:) 接受两个参数：options 和 completionHandler。在
    options 参数中，你传入一个包含所需通知权限的 UNAuthorizationOptions 数组。你可以为通知使用四种类型的 UNAuthorizationOptions：badge、sound、alert
    和 carPlay。badge 选项会在应用图标上添加一个徽章，用户可以快速查看应用中是否有新内容。通常，这个徽章是一个数字，表示应用中有多少个新的或等待的通知。sound
    选项会在发送通知时播放声音。alert 选项会以警告框的形式在屏幕中央弹出通知，或者以横幅的形式从屏幕顶部出现。作为应用开发者，你不能决定通知的展示方式，也不能决定用户是否会开启通知声音。这些都是用户在其设置应用中控制的内容。第四个选项
    carPlay 允许在支持 CarPlay 的汽车设备上显示通知。
- en: '![](Image00259.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00259.jpg)'
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1138
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1140
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1156
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1159
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1161
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1164
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1176
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1188
  prefs: []
  type: TYPE_IMG
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  id: totrans-1191
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  id: totrans-1194
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1199
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1220
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1222
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1225
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1237
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1249
  prefs: []
  type: TYPE_IMG
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  id: totrans-1251
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  id: totrans-1254
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1259
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1261
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1277
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1280
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1282
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1285
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1297
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00259.jpg)'
  id: totrans-1309
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  id: totrans-1312
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1317
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1319
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-1332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1335
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1338
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1340
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1343
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1355
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1367
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  id: totrans-1370
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1375
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-1390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1393
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1396
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1398
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1401
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1413
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1425
  prefs: []
  type: TYPE_IMG
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  id: totrans-1427
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1432
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1434
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-1447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1450
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1453
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1455
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1458
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1470
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00260.jpg)'
  id: totrans-1482
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1487
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1489
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1505
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1508
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1510
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1513
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1525
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1537
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1542
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1544
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1560
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1563
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1565
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1568
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1580
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1592
  prefs: []
  type: TYPE_IMG
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1596
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1598
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1614
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1617
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1619
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1622
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1634
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1636
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1646
  prefs: []
  type: TYPE_IMG
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1649
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1651
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1667
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1670
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1672
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1675
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1687
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1699
  prefs: []
  type: TYPE_IMG
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  id: totrans-1701
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1703
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1719
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1722
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1724
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1727
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1739
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00261.jpg)'
  id: totrans-1751
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1753
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1769
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1772
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1774
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1777
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1789
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1801
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  id: totrans-1803
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1806
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1819
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1822
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1824
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1827
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1839
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1841
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00262.jpg)'
  id: totrans-1851
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1867
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1870
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1872
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1875
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-1881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1887
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-1892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1896
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1899
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1902
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1915
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1918
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1920
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1923
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1935
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1937
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1947
  prefs: []
  type: TYPE_IMG
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-1962
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-1965
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-1967
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-1970
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-1982
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-1984
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-1991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-1994
  prefs: []
  type: TYPE_IMG
- en: '**SCHEDULING A NOTIFICATION**'
  id: totrans-1995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-2005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2008
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2011
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2013
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2016
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-2022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-2026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2028
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2030
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-2033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2040
  prefs: []
  type: TYPE_IMG
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-2044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-2046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-2050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2053
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2056
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2058
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2061
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-2067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-2071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2073
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2075
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-2078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2082
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2085
  prefs: []
  type: TYPE_IMG
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-2088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-2090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-2094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2097
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2100
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2102
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2105
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-2111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-2115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2117
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-2122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2129
  prefs: []
  type: TYPE_IMG
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-2131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-2133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-2137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2140
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2143
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2145
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2148
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-2154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-2158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2160
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-2165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2172
  prefs: []
  type: TYPE_IMG
- en: '[PRE236]'
  id: totrans-2173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-2175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-2179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2182
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2185
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2187
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2190
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-2196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-2200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2202
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-2207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2214
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-2216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-2220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2223
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2226
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2228
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2231
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-2237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-2241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2243
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-2248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2255
  prefs: []
  type: TYPE_IMG
- en: '[PRE247]'
  id: totrans-2256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-2260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2263
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2266
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2268
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2271
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-2277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-2281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2283
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-2288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2295
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-2299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2302
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2305
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2307
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2310
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-2316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-2320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2322
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-2327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2334
  prefs: []
  type: TYPE_IMG
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-2337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2340
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2343
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2345
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2348
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-2354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-2358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2360
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-2365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2372
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to create a trigger after setting content.sound :'
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-2374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2377
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2380
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2382
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2385
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-2391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-2395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2397
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-2402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2409
  prefs: []
  type: TYPE_IMG
- en: '[PRE264]'
  id: totrans-2410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2413
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2416
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2418
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2421
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-2427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-2431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2433
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-2438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2445
  prefs: []
  type: TYPE_IMG
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2448
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2451
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2453
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2456
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-2462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-2466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2468
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2480
  prefs: []
  type: TYPE_IMG
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  id: totrans-2482
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2485
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2487
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2490
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-2496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-2500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2502
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-2507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00263.jpg)'
  id: totrans-2514
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2517
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2519
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2522
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-2528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-2532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2534
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-2539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2546
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  id: totrans-2549
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  id: totrans-2551
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  id: totrans-2554
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-2560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-2564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2566
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-2571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2578
  prefs: []
  type: TYPE_IMG
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-2583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-2587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2589
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-2594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2601
  prefs: []
  type: TYPE_IMG
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-2605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-2609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2611
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-2616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2623
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-2626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-2630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2632
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-2637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2644
  prefs: []
  type: TYPE_IMG
- en: '*AddBirthdayViewController.swift*'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-2646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-2650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2652
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-2657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2664
  prefs: []
  type: TYPE_IMG
- en: '[PRE292]'
  id: totrans-2665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-2669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2671
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-2676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2683
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-2687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2689
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-2694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2701
  prefs: []
  type: TYPE_IMG
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-2704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2706
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-2711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2718
  prefs: []
  type: TYPE_IMG
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-2720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2722
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-2727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2734
  prefs: []
  type: TYPE_IMG
- en: '[PRE301]'
  id: totrans-2735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2737
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2739
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-2742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2749
  prefs: []
  type: TYPE_IMG
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  id: totrans-2751
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-2756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00267.jpg)'
  id: totrans-2763
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-2768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2775
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2777
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-2780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2784
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2787
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING A NOTIFICATION**'
  id: totrans-2788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-2791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2795
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2798
  prefs: []
  type: TYPE_IMG
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-2801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2808
  prefs: []
  type: TYPE_IMG
- en: '*BirthdaysTableViewController.swift*'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-2810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2814
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2817
  prefs: []
  type: TYPE_IMG
- en: '[PRE309]'
  id: totrans-2818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2825
  prefs: []
  type: TYPE_IMG
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2832
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-2835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2838
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  id: totrans-2839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2842
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  id: totrans-2845
  prefs: []
  type: TYPE_IMG
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00268.jpg)'
  id: totrans-2847
  prefs: []
  type: TYPE_IMG
