- en: '13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GETTING BIRTHDAY NOTIFICATIONS**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**GETTING BIRTHDAY NOTIFICATIONS**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s finish BirthdayTracker by adding *local notifications* . A local notification
    is an alert that is sent to your phone from an app, even when the app isn’t running.
    The BirthdayTracker app will use a local notification to alert the user when they
    should wish a friend a happy birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE USER NOTIFICATIONS FRAMEWORK**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just as you used Apple’s Core Data framework to save birthdays on your phone
    in a database, you’ll use Apple’s User Notifications framework to send notifications
    to the user. Using this framework is easy! You just need to add an import statement
    at the top of any class that deals with user notifications, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll use the framework in three files—*AddBirthdayViewController.swift, AppDelegate.swift,*
    and *BirthdaysTableViewController.swift* —so add import UserNotifications to each
    of them, below the other import statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REGISTERING FOR LOCAL NOTIFICATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, you need to have your app ask the user for permission to send notifications
    when it’s someone’s birthday. If you don’t have permission for notifications,
    they won’t be sent. You can get permission by having your app request authorization
    for notifications in your application delegate. This needs to be done as soon
    as the app starts, which is when it finishes launching. Luckily, there is a method
    in the AppDelegate class called application(_:didFinishLaunchingWithOptions:)
    that we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, make sure that you added the line import UserNotifications at the top
    of your *AppDelegate.swift* file. Next, add the following lines in application(_:didFinishLaunchingWithOptions:)
    to request permission to send local notifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*AppDelegate.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➊ gets the current UNUserNotificationCenter and stores it in a
    constant called center . The *notification center* is used to schedule and manage
    the notifications that you send from your app. In this chapter, we’ll use three
    methods from the UNUserNotificationCenter class:'
  prefs: []
  type: TYPE_NORMAL
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: requestAuthorization(options:completionHandler:) asks the user for permission
    to send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: add(_:withCompletionHandler:) requests to add a new notification to send to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: removePendingNotificationRequests(withIdentifiers:) removes an existing notification.
  prefs: []
  type: TYPE_NORMAL
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We use the first of these methods at ➋ to ask the user to grant permission for
    the app to send notifications. We’ll use the other two methods later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The method requestAuthorization(options:completionHandler:) takes two parameters:
    options and completionHandler . In the options parameter, you pass in an array
    of the UNAuthorizationOptions that you want to be available on your notifications.
    There are four types of UNAuthorizationOptions that you can use for your notifications:
    badge , sound , alert , and carPlay . The badge option adds a badge on your app
    icon so the user can quickly see when there’s something new in your app. This
    is typically a number indicating how many new or waiting notifications are in
    the app. The sound option adds a sound to be played when your notification is
    sent to the phone. The alert option displays a notification as either an alert
    that pops up in the middle of the screen or a banner that comes in at the top
    of the screen. You, the app developer, don’t get to decide how the notification
    will appear or if the user will turn on the sound for their notifications. This
    is something that the user controls in their Settings app. The fourth option,
    carPlay , allows notifications on a CarPlay-enabled device in a car.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want to display the notifications as alerts for the user and play a sound
    when each notification comes in, so we pass in [.alert, .sound] for our options
    ➌ . The completionHandler parameter is a closure that is passed in and called
    after the user either grants or denies permission for the app to send notifications.
    The completionHandler closure has two parameters, granted and error ➍ . The granted
    parameter is a Boolean value that lets you know if permission was granted (in
    which case it would be true ) or denied (false ). We’re not going to change the
    behavior of our app if the user refuses to let us send notifications, but we’ll
    print a statement in the console ➎ so you can see if permission was granted or
    denied when you test the app. The second parameter, error , is the Error class
    type and lets you know if there was an error of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have requested authorization for notifications, the first time
    the user runs the app, it will display an alert dialog asking if they want to
    allow it to send notifications, as shown in [Figure 13-1](text00024.html#ch13fig1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The app will ask permission from the user to deliver notifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the user selects the Don’t Allow option here, they won’t receive any notifications
    on people’s birthdays. If they select Allow, they will receive notifications.
    The user will only be asked this the first time the app is run after a fresh installation.
    However, they can change the notifications settings at any time in the Settings
    app.
  prefs: []
  type: TYPE_NORMAL
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the user opens the Settings app and scrolls to the apps section, they’ll
    see a listing for the BirthdayTracker app, labeled *Birthdays* , at the bottom
    of the list ([Figure 13-2](text00024.html#ch13fig2) ). You can also see this in
    the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drilling down into the BirthdayTracker app settings will lead the user to the
    Notifications settings screen ([Figure 13-3](text00024.html#ch13fig3) ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: From the Settings app, the user can drill down to specify notification
    settings for their apps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Notification settings for our app*'
  prefs: []
  type: TYPE_NORMAL
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this screen, the user can specify whether they want to see notifications
    for the app and what kind of notifications they want (banner or alert).
  prefs: []
  type: TYPE_NORMAL
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SCHEDULING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each time we create a birthday, we’ll want to schedule a notification to be
    sent to us every year on the birthday person’s birthdate. To do this, we’ll add
    some code to the saveTapped(_:) method in the AddBirthdayViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In that method, first we need to create a message string to be sent in the
    notification. Our message will be a string that says, "Wish firstName lastName
    a Happy Birthday today!" Add the following code right after a birthday is saved
    in the saveTapped(_:) method in *AddBirthdayViewController.swift* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our message, we need to create and schedule the notification
    that will be sent to the user’s device on their friend’s birthday. First, make
    sure that import UserNotifications is at the top of the file. Then add the following
    right under the message constant you just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates a UNMutableNotificationContent that is stored into a constant
    called content . A UNMutableNotificationContent contains data for a user notification,
    such as a message or sound. At ➋ , we set the content.body property to the birthday
    reminder message called message . Then, at ➌ , we set content.sound to be the
    default notification sound, which is the same sound that occurs when you receive
    a text message.
  prefs: []
  type: TYPE_NORMAL
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After we create the content of the notification, we need to create the notification’s
    *trigger* . Triggers are of the UNCalendarNotificationTrigger class and let the
    app know when and how often to send the notification. We’ll schedule the birthday
    notification to be sent at 8 AM every year on the person’s birthday. Swift lets
    us get just the month and day of the triggerDate by using the Calendar and DateComponents
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to create a trigger after setting content.sound :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To do this, first we get the month and the day DateComponents from birthDate
    by using the Calendar method dateComponents(_:from:) . We pass in just [.month,
    .day] for the components ➊ , and not the year. This is because we want the trigger
    to go off every year, not just on the year the person was born—which is in the
    past, so it would never happen anyway! We want to send the birthdate notification
    at 8 AM , so next we set dateComponents .hour to 8 ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➌ , we create the UNCalendarNotificationTrigger with its initializer. This
    initializer takes two parameters: the dateComponents and a Boolean that says whether
    you want the trigger to be repeated or not. We want the trigger to be repeated
    every year, so we pass in true . Swift is smart about how often you want a trigger
    to be repeated. If you passed in DateComponents that were just an hour and a minute,
    for example, it would fire the notification every day at that hour and minute.
    Because we passed in a month and a day, the trigger will repeat every year.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE CALENDAR AND DATECOMPONENTS CLASSES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calendar and DateComponents classes make it super easy to create dates
    and times. DateComponents has integer properties that you can set for the year,
    month, day, hour, minute, and second of a date and time, or a time interval. The
    Calendar class has methods to convert DateComponents into a Date or vice versa.
    To try creating a date, open your Swift playground. We’ll create a date and time
    of May 10, 1971, at 8:23 AM :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, we create a variable called myDateComponents ➊ , which we’ll use to create
    our date. After creating myDateComponents , we can set integers for its various
    properties. The months of the year are all represented by integers in numeric
    order, from 1 for January to 12 for December. For May, we set myDateComponents.month
    to 5 ➋ . For 8 AM , we use 8 for myDateComponents.hour ➌ . The myDateComponents
    properties use a 24-hour clock so that each hour of a 24-hour day is labeled in
    numeric order, starting with 0 for midnight. So all the hours before noon would
    be the same as on a 12-hour clock, but for 2 PM , which is two hours after noon,
    we would count two hours past 12 and set myDateComponents to 14 . For another
    example, 11 PM would be 23 . Finally, we can make a date from myDateComponents
    by using the date(from:) method on the Calendar class ➍ . To use this method,
    we first need a Calendar instance. We use Calendar.current , which returns the
    type of calendar being used by the device. In most Western countries, this is
    the Gregorian calendar, which has 12 months and a 7-day week.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get DateComponents out of a Date , we use the Calendar method myDateComponents(_:from:)
    . This method takes two parameters: the first is an array of the DateComponents
    that you want out of the Date , and the second is the Date itself. The myDateComponents(_:from:)
    method is useful if you want to create a new Date object that is today’s date,
    but at 8 AM , for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➊ creates the current date and time and assigns it to a constant
    called today . Next, we get the myDateComponents for the month, day, and year
    out of today ➋ . Note that we pass in only the DateComponents properties that
    we care about. We don’t need the hour, minutes, or seconds, for example. We make
    myDateComponents a variable instead of a constant because we are going to set
    the hour property, which we do at ➌ . Finally, we create a new date called todayEightAm
    using myDateComponents ➍ . You should see that the new Date is the same as today,
    except the time is 8:00 AM .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our notification content and trigger, we are almost ready to
    create a UNNotificationRequest object to schedule the notification. But to create
    a UNNotificationRequest , first we need an identifier. This is a string that can
    be used to identify the notification.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll also use this identifier to remove a scheduled notification if we delete
    a birthday from the app. After all, you wouldn’t want to be getting notifications
    for birthdays that you deleted!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 12](text00023.html#ch12) , we added a birthdayId property to Birthday
    , so we’ll use birthdayId as the identifier of our notification. First, we need
    to unwrap the optional birthdayId property and store it in a constant called identifier
    . Then, we can create a notification request using the identifier and the trigger
    . Add the following code right after trigger is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we create the UNNotificationRequest using the identifier , content ,
    and trigger . After request is created, it must be added to the UNUserNotificationCenter
    . To do this, we create a constant called center ➋ , which is the current UNUserNotificationCenter
    of the app. Then we use the method add(_:withCompletionHandler:) to add the request
    for our scheduled notification ➌ . This method takes two parameters, a UNNotificationRequest
    and a closure as a completionHandler that performs some action after the notification
    has been added. We pass in our request for the first parameter, and since we don’t
    need to do anything when the request has been added, we pass in nil for the completionHandler
    .
  prefs: []
  type: TYPE_NORMAL
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whew! We’ve just finished writing the method to schedule a notification! Now
    if you run your app and create Birthday objects, you’ll receive a notification
    when it’s someone’s birthday!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To test your notifications, you’d need to add a birthday for the next day and
    wait until 8 AM for your notification to appear. But waiting a whole day to test
    your code is too long! To test your code right now, tweak it to make the notification
    go off much sooner. Set the hour and minute of myDateComponents to be 10 minutes
    from the present time. So if it’s 1:35 PM , change the code that you just wrote
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then run the app, add a birthday with today’s date, turn off the app by clicking
    the stop button (but keep the simulated iPhone’s window open), and wait 10 minutes.
    You should see a notification appear like the one in [Figure 13-4](text00024.html#ch13fig4)
    . After testing, don’t forget to change your code back so that the notifications
    go off first thing in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: A banner-style birthday notification*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING A NOTIFICATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we remove a birthday from the app, we’ll also want to cancel its corresponding
    notification, which we can do in the BirthdaysTableViewController by adding some
    code. A good place to do this is right after the user selects a birthday to delete,
    in tableView(_:commitEditingStyle:forRowAtIndexPath:) . Add the following lines
    to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To remove the notification for a birthday, first we unwrap the birthdayId to
    use it as an identifier ➊ . Next, we get the UNUserNotificationCenter ➋ and remove
    the notification ➌ . The remove method takes an array of identifiers so that you
    can remove more than one notification at a time, but since we want to remove only
    one, we pass it [identifier] , which is an array but has only one value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The BirthdayTracker app is now complete! Remember that the final project files
    are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *, so you can compare yours to double-check that everything is in the right place.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we showed you how to use the User Notifications framework to
    ping your users on their friends’ birthdays. You learned how to add a notification
    that will be sent at a specific time every year and also how to remove that notification
    if the user removes a birthday from the app.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Part 3](text00025.html#part03) , you’ll build another exciting app—a game
    called Schoolhouse Skateboarder, which features graphics, sounds, and more!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00268.jpg)![](Image00268.jpg)'
  prefs: []
  type: TYPE_IMG
