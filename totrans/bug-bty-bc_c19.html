<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<title>Chapter 19: Same-Origin Policy Vulnerabilities</title>
		<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:f533d35e-262b-449b-a78e-85650cfe86cd" name="Adept.expected.resource"/>
	</head>
	<body epub:type="bodymatter chapter">
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_295" title="295"/>19</span><br/><span class="ChapterTitle">Same-Origin Policy Vulnerabilities</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro"><span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> introduced the same-origin policy (SOP), one of the fundamental defenses deployed in modern web applications. The SOP restricts how a script originating from one site can interact with the resources of a different site, and it’s critical in preventing many common web vulnerabilities.</p>
			<p>But websites often loosen the SOP in order to have more flexibility. These controlled and intended SOP bypasses can have adverse effects, as attackers can sometimes exploit misconfigurations in these techniques to bypass the SOP. These exploits can cause private information leaks and often lead to more vulnerabilities, such as authentication bypass, account takeover, and large data breaches. In this chapter, we’ll discuss how applications relax or work around the SOP and how attackers can exploit these features to endanger the application.</p>
			<h2 id="h1-501546c19-0001"><span epub:type="pagebreak" id="Page_296" title="296"/>Mechanisms</h2>
			<p>
				Here’s a quick review of how the SOP works. Because of the SOP, a script from page A can access data from page B only if the pages are of the same origin. Two URLs are said to have the <em>same origin</em> if they share the same protocol, hostname, and port number. Modern web applications often base their authentication on HTTP cookies, and servers take action based on the cookies included automatically by the browser. This makes the SOP especially important. When the SOP is implemented, malicious web pages won’t be able to take advantage of the cookies stored in your browser to access your private information. You can read more about the details of the SOP in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</p>
			<p>Practically, the SOP is often too restrictive for modern web applications. For example, multiple subdomains or multiple domains of the same organization wouldn’t be able to share information if they followed the policy. Since the SOP is inflexible, most websites find ways to relax it. This is often where things go wrong.</p>
			<p>
				For instance, imagine that you are an attacker trying to smuggle information out of a banking site, <em>a.example.com</em>, and find a user’s account number. You know that a user’s banking details are located at <em>a.example.com/user_info</em>. Your victim is logged into the banking site at <em>a.example.com</em> and is also visiting your site, <em>attacker.com</em>, in the same browser.</p>
			<p>
				Your site issues a GET request to <em>a.example.com/user_info</em> to retrieve the victim’s personal information. Since your victim is logged into the bank, their browser automatically includes their cookies in every request it sends to <em>a.example.com</em>, even if the request is generated by a script on your malicious site. Unfortunately, because of the SOP, the victim’s browser won’t allow your site to read data returned from <em>a.example.com</em>.</p>
			<p>
				But now, say you realize that <em>a.example.com</em> passes information to <em>b.example.com</em> via SOP bypass techniques. If you can find out the technique used and exploit it, you might be able to steal the victim’s private information on the banking site.</p>
			<p>
				The simplest way for websites to work around the SOP is to change the origin of a page via JavaScript. Setting the origin of two pages to the same domain using <code>document.domain</code> in the pages’ JavaScript will enable the pages to share resources. For example, you can set the domain of both <em>a.example.com</em> and <em>b.example.com</em> to <em>example.com</em> so that they can interact:</p>
			<pre><code>document.domain = "example.com"</code></pre>
			<p>
				However, this approach has its limitations. First, you can only set the <em>document.domain</em> of a page to a superdomain; for example, you can set the origin of <em>a.example.com</em> to <em>example.com</em>, but not to <em>example2.com</em>. Therefore, this method will work only if you want to share resources with superdomains or sibling subdomains.</p>
			<h3 id="h2-501546c19-0001"><span epub:type="pagebreak" id="Page_297" title="297"/>Exploiting Cross-Origin Resource Sharing</h3>
			<p>
				Because of these limitations, most sites use Cross-Origin Resource Sharing (CORS) to relax the SOP instead. CORS is a mechanism that protects the data of the server. It allows servers to explicitly specify a list of origins that are allowed to access its resources via the HTTP response header <code>Access-Control-Allow-Origin</code>.</p>
			<p>
				For example, let’s say we’re trying to send the following JSON blob located at <em>a.example.com/user_info</em> to <em>b.example.com</em>:</p>
			<pre><code>{"username": "vickieli", "account_number": "12345"}</code></pre>
			<p>
				Under the SOP, <em>b.example.com</em> won’t be able to access the JSON file, because <em>a.example.com</em> and <em>b.example.com</em> are of different origins. But using CORS, the user’s browser will send an <code>Origin</code> header on behalf of <em>b.example.com</em>:</p>
			<pre><code>Origin: https://b.example.com</code></pre>
			<p>
				If <em>b.example.com</em> is part of an allowlist of URLs with permission to access resources on <em>a.example.com</em>, <em>a.example.com</em> will send the browser the requested resource along with an <code>Access-Control-Allow-Origin</code> header. This header will indicate to the browser that a specific origin is allowed to access the resource:</p>
			<pre><code>Access-Control-Allow-Origin: b.example.com</code></pre>
			<p>
				The application can also return the <code>Access-Control-Allow-Origin</code> header with a wildcard character (<code>*</code>) to indicate that the resource on that page can be accessed by any domain:</p>
			<pre><code>Access-Control-Allow-Origin: *</code></pre>
			<p>On the other hand, if the origin of the requesting page isn’t allowed to access the resource, the user’s browser will block the requesting page from reading the data.</p>
			<p>CORS is a great way to implement cross-origin communication. However, CORS is safe only when the list of allowed origins is properly defined. If CORS is misconfigured, attackers can exploit the misconfiguration and access the protected resources.</p>
			<p>
				The most basic misconfiguration of CORS involves allowing the <code>null</code> origin. If the server sets <code>Access-Control-Allow-Origin</code> to <code>null</code>, the browser will allow any site with a <code>null</code> origin header to access the resource. This isn’t safe because any origin can create a request with a <code>null</code> origin. For instance, cross-site requests generated from a document using the <code>data:</code> URL scheme will have a <code>null</code> origin.</p>
			<p>
				Another misconfiguration is to set the <code>Access-Control-Allow-Origin</code> header to the origin of the requesting page without validating the requestor’s origin. If the server doesn’t validate the origin and returns an <code>Access-Control-Allow-Origin</code> for any origin, the header will completely bypass the SOP, removing all limitations on cross-origin communication.</p>
			<p><span epub:type="pagebreak" id="Page_298" title="298"/>In summary, if the server sets the <code>Access-Control-Allow-Origin</code> header to <code>null</code> or to arbitrary origins of the requesting page, it allows attackers to smuggle information offsite:</p>
			<pre><code>Access-Control-Allow-Origin: null
Access-Control-Allow-Origin: https://attacker.com</code></pre>
			<p>
				Another exploitable misconfiguration occurs when a site uses weak regexes to validate origins. For example, if the policy checks only if an origin URL starts with <em>www.example.com</em>, the policy can be bypassed using an origin like <em>www.example.com.attacker.com</em>.</p>
			<pre><code>Access-Control-Allow-Origin: https://www.example.com.attacker.com</code></pre>
			<p>
				An interesting configuration that isn’t exploitable is setting the allowed origins to the wildcard (<code>*</code>). This isn’t exploitable because CORS doesn’t allow credentials, including cookies, authentication headers, or client-side certificates, to be sent with requests to these pages. Since credentials cannot be sent in requests to these pages, no private information can be accessed:</p>
			<pre><code>Access-Control-Allow-Origin: *</code></pre>
			<p>
				Developers can prevent CORS misconfigurations by creating a well-defined CORS policy with a strict allowlist and robust URL validation. For pages containing sensitive information, the server should return the requesting page’s origin in the <code>Access-Control-Allow-Origin</code> header only if that origin is in the allowlist. For public information, the server can simply use the wildcard <code>*</code> designation for <code>Access-Control-Allow-Origin</code>.</p>
			<h3 id="h2-501546c19-0002">Exploiting postMessage()</h3>
			<p>
				Some sites work around SOP by using <code>postMessage()</code>. This method is a web API that uses JavaScript syntax. You can use it to send text-based messages to another window:</p>
			<pre><code>RECIPIENT_WINDOW.postMessage(MESSAGE_TO_SEND, TARGET_ORIGIN);</code></pre>
			<p>The receiving window would then handle the message by using an event handler that will be triggered when the receiving window receives a message:</p>
			<pre><code>window.addEventListener("message",EVENT_HANDLER_FUNCTION);</code></pre>
			<p>
				Since using <code>postMessage()</code> requires the sender to obtain a reference to the receiver’s window, messages can be sent only between a window and its iframes or pop-ups. That’s because only windows that open each other will have a way to reference each other. For example, a window can use <code>window.open</code> to refer to a new window it opened. Alternatively, it can use <code>window.opener</code> to reference the <span epub:type="pagebreak" id="Page_299" title="299"/>window that spawned the current window. It can use <code>window.frames</code> to reference embedded iframes, and <code>window.parent</code> to reference the parent window of the current iframe.</p>
			<p>
				For example, say we’re trying to pass the following JSON blob located at <em>a.example.com/user_info</em> to <em>b.example.com</em>:</p>
			<pre><code>{'username': 'vickieli', 'account_number': '12345'}</code></pre>
			<p><em>a.example.com</em> can open <em>b.example.com</em> and send a message to its window. The <code>window.open()</code> function opens the window of a particular URL and returns a reference to it:</p>
			<pre><code>var recipient_window = window.open("https://b.example.com", b_domain)
recipient_window.postMessage("{'username': 'vickieli', 'account_number': '12345'}", "*");</code></pre>
			<p>
				At the same time, <em>b.example.com</em> would set up an event listener to process the data it receives:</p>
			<pre><code>function parse_data(event) { // Parse the data
}
window.addEventListener("message", parse_data);</code></pre>
			<p>
				As you can see, <code>postMessage()</code> does not bypass SOP directly but provides a way for pages of different origins to send data to each other.</p>
			<p>
				The <code>postMessage()</code> method can be a reliable way to implement cross-origin communication. However, when using it, both the sender and the receiver of the message should verify the origin of the other side. Vulnerabilities happen when pages enforce weak origin checks or lack origin checks altogether.</p>
			<p>
				First, the <code>postMessage()</code> method allows the sender to specify the receiver’s origin as a parameter. If the sender page doesn’t specify a target origin and uses a wildcard target origin instead, it becomes possible to leak information to other sites:</p>
			<pre><code>RECIPIENT_WINDOW.postMessage(MESSAGE_TO_SEND, *);</code></pre>
			<p>
				In this case, an attacker can create a malicious HTML page that listens for events coming from the sender page. They can then trick users into triggering the <code>postMessage()</code> by using a malicious link or fake image and make the victim page send data to the attacker’s page.</p>
			<p>
				To prevent this issue, developers should always set the <code>TARGET_ORIGIN</code> parameter to the target site’s URL instead of using a wildcard origin:</p>
			<pre><code>recipient_window.postMessage(
"{'username': 'vickieli', 'account_number': '12345'}", <b>"https://b.example.com"</b>);</code></pre>
			<p>
				On the other hand, if the message receiver doesn’t validate the page where the <code>postMessage()</code> is coming from, it becomes possible for attackers to <span epub:type="pagebreak" id="Page_300" title="300"/>send arbitrary data to the website and trigger unwanted actions on the victim’s behalf. For example, let’s say that <em>b.example.com</em> allows <em>a.example.com</em> to trigger a password change based on a <code>postMessage()</code>, like this:</p>
			<pre><code>recipient_window.postMessage(
"{'action': 'password_change', 'username': 'vickieli', 'new_password': 'password'}", 
"https://b.example.com");</code></pre>
			<p>
				The page <em>b.example.com</em> would then receive the message and process the request:</p>
			<pre><code>function parse_data(event) { // If "action" is "password_change", change the user's password
}
window.addEventListener("message", parse_data);</code></pre>
			<p>
				Notice here that any window can send messages to <em>b.example.com</em>, so any page can initiate a password change on <em>b.example.com</em>! To exploit this behavior, the attacker can embed or open the victim page to obtain its window reference. Then they’re free to send arbitrary messages to that window.</p>
			<p>To prevent this issue, pages should verify the origin of the sender of a message before processing it:</p>
			<pre><code>function parse_data(event) {<span aria-label="annotation1" class="CodeAnnotationCode">1</span> if (event.origin == "https://a.example.com"){ // If "action" is "password_change", change the user's password }
}
window.addEventListener("message", parse_data);</code></pre>
			<p>
				This line <span aria-label="annotation1" class="CodeAnnotation">1</span> verifies the origin of the sender by checking it against an acceptable origin.</p>
			<h3 id="h2-501546c19-0003">Exploiting JSON with Padding</h3>
			<p><em>JSON with Padding (</em><em>JSONP)</em> is another technique that works around the SOP. It allows the sender to send JSON data as JavaScript code. A page of a different origin can read the JSON data by processing the JavaScript.</p>
			<p>
				To see how this works, let’s continue with our previous example, where we’re trying to pass the following JSON blob located at <em>a.example.com/user_info</em> to <em>b.example.com</em>:</p>
			<pre><code>{"username": "vickieli", "account_number": "12345"}</code></pre>
			<p>
				The SOP allows the HTML <code>&lt;script&gt;</code> tag to load scripts across origins, so an easy way for <em>b.example.com </em>to retrieve data across origins is to load the data as a script in a <code>&lt;script&gt;</code> tag:</p>
			<pre><code>&lt;script src="https://a.example.com/user_info"&gt;&lt;/script&gt;</code></pre>
			<p><span epub:type="pagebreak" id="Page_301" title="301"/>This way, <em>b.example.com </em>would essentially be including the JSON data block in a script tag. But this would cause a syntax error because JSON data is not valid JavaScript:</p>
			<pre><code>&lt;script&gt; {"username": "vickieli", "account_number": "12345"}
&lt;/script&gt;</code></pre>
			<p>JSONP works around this issue by wrapping the data in a JavaScript function, and sending the data as JavaScript code instead of a JSON file.</p>
			<p>
				The requesting page includes the resource as a script and specifies a callback function, typically in a URL parameter named <code>callback</code> or <code>jsonp</code>. This callback function is a predefined function on the receiving page ready to process the data:</p>
			<pre><code>&lt;script src="https://a.example.com/user_info?callback=parseinfo"&gt;&lt;/script&gt;</code></pre>
			<p>
				The page at <em>a.example.com</em> will return the data wrapped in the specified callback function:</p>
			<pre><code>parseinfo({"username": "vickieli", "account_number": "12345"})</code></pre>
			<p>The receiving page would essentially be including this script, which is valid JavaScript code:</p>
			<pre><code>&lt;script&gt; parseinfo({"username": "vickieli", "account_number": "12345"})
&lt;/script&gt;</code></pre>
			<p>
				The receiving page can then extract the data by running the JavaScript code and processing the <code>parseinfo()</code> function. By sending data as scripts instead of JSON data, JSONP allows resources to be read across origins. Here’s a summary of what happens during a JSONP workflow:</p>
			<ol class="decimal">
				<li value="1">The data requestor includes the data’s URL in a script tag, along with the name of a callback function.</li>
				<li value="2">The data provider returns the JSON data wrapped within the specified callback function.</li>
				<li value="3">The data requestor receives the function and processes the data by running the returned JavaScript code.</li>
			</ol>
			<p>
				You can usually find out if a site uses JSONP by looking for script tags that include URLs with the terms <em>jsonp</em> or <em>callback</em>.</p>
			<p>But JSONP comes with risks. When JSONP is enabled on an endpoint, an attacker can simply embed the same script tag on their site and request the data wrapped in the JSONP payload, like this:</p>
			<pre><code>&lt;script src="https://a.example.com/user_info?callback=parseinfo"&gt;&lt;/script&gt;</code></pre>
			<p><span epub:type="pagebreak" id="Page_302" title="302"/>If a user is browsing the attacker’s site while logged into <em>a.example.com</em> at the same time, the user’s browser will include their credentials in this request and allow attackers to extract confidential data belonging to the victim.</p>
			<p>This is why JSONP is suitable for transmitting only public data. While JSONP can be hardened by using CSRF tokens or maintaining an allowlist of referer headers for JSONP requests, these protections can often be bypassed.</p>
			<p>
				Another issue with JSONP is that site <em>b.example.com</em> would have to trust site <em>a.example.com</em> completely, because it’s running arbitrary JavaScript from <em>a.example.com</em>. If <em>a.example.com</em> is compromised, the attacker could run whatever JavaScript they wanted on <em>b.example.com</em>, because <em>b.example.com</em> is including the file from <em>a.example.com</em> in a <code>&lt;script&gt;</code> tag. This is equivalent to an XSS attack.</p>
			<p>Now that CORS is a reliable option for cross-origin communication, sites no longer use JSONP as often.</p>
			<h3 id="h2-501546c19-0004">Bypassing SOP by Using XSS</h3>
			<p>Finally, XSS is essentially a full SOP bypass, because any JavaScript that runs on a page operates under the security context of that page. If an attacker can get a malicious script executed on the victim page, the script can access the victim page’s resources and data. Therefore, remember that if you can find an XSS, you’ve essentially bypassed the SOP protecting that page.</p>
			<h2 id="h1-501546c19-0002">Hunting for SOP Bypasses</h2>
			<p>Let’s start hunting for SOP bypass vulnerabilities by using what you’ve learned! SOP bypass vulnerabilities are caused by the faulty implementation of SOP relaxation techniques. So the first thing you need to do is to determine whether the target application relaxes the SOP in any way.</p>
			<h3 id="h2-501546c19-0005">Step 1: Determine If SOP Relaxation Techniques Are Used</h3>
			<p>
				You can determine whether the target is using an SOP-relaxation technique by looking for the signatures of each SOP-relaxation technique. When you’re browsing a web application, open your proxy and look for any signs of cross-origin communication. For example, CORS sites will often return HTTP responses that contain an <code>Access-Control-Allow-Origin</code> header. A site could be using <code>postMessage()</code> if you inspect a page (for example, by right-clicking it in Chrome and choosing <b>Inspect</b>, then navigating to <b>Event Listeners</b>) and find a <code>message</code> event listener (<a href="#figure19-1" id="figureanchor19-1">Figure 19-1</a>).</p>
			<p>
				And a site could be using JSONP if you see a URL being loaded in a <code>&lt;script&gt;</code> tag with a callback function:</p>
			<pre><code>&lt;script src="https://a.example.com/user_info?callback=parseinfo"&gt;&lt;/script&gt;
&lt;script src="https://a.example.com/user_info?jsonp=parseinfo"&gt;&lt;/script&gt;</code></pre>
			<p><span epub:type="pagebreak" id="Page_303" title="303"/>If you see clues of cross-origin communication, try the techniques mentioned in this chapter to see if you can bypass the SOP and steal sensitive info from the site!</p>
			<figure>
				<img alt="f19001" class="keyline" src="image_fi/501546c19/f19001.png"/>
				<figcaption>
					<p><a id="figure19-1">Figure 19-1</a>: Finding the event listeners of a page in the Chrome browser</p>
				</figcaption>
			</figure>
			<h3 id="h2-501546c19-0006">Step 2: Find CORS Misconfiguration</h3>
			<p>
				If the site is using CORS, check whether the <code>Access-Control-Allow-Origin</code> response header is set to <code>null</code>.</p>
			<pre><code>Origin: null</code></pre>
			<p><span epub:type="pagebreak" id="Page_304" title="304"/>If not, send a request to the site with the origin header <code>attacker.com</code>, and see if the <code>Access-Control-Allow-Origin </code>in the response is set to <code>attacker.com</code>. (You can add an Origin header by intercepting the request and editing it in a proxy.)</p>
			<pre><code>Origin: attacker.com</code></pre>
			<p>
				Finally, test whether the site properly validates the origin URL by submitting an Origin header that contains an allowed site, such as <em>www.example.com.attacker.com</em>. See if the <code>Access-Control-Allow-Origin</code> header returns the origin of the attacker’s domain.</p>
			<pre><code>Origin: www.example.com.attacker.com</code></pre>
			<p>
				If one of these <code>Access-Control-Allow-Origin</code> header values is returned, you have found a CORS misconfiguration. Attackers will be able to bypass the SOP and smuggle information offsite (<a href="#figure19-2" id="figureanchor19-2">Figure 19-2</a>).</p>
			<figure>
				<img alt="f19002" class="" src="image_fi/501546c19/f19002.png"/>
				<figcaption>
					<p><a id="figure19-2">Figure 19-2</a>: Is the site vulnerable to a CORS misconfiguration vulnerability?</p>
				</figcaption>
			</figure>
			<h3 id="h2-501546c19-0007">Step 3: Find postMessage Bugs</h3>
			<p>
				If the site is using <code>postMessage</code>, see if you can send or receive messages as an untrusted site. Create an HTML page with an iframe that frames the targeted page accepting messages. Try to send messages to that page that <span epub:type="pagebreak" id="Page_305" title="305"/>trigger a state-changing behavior. If the target cannot be framed, open it as a new window instead:</p>
			<pre><code>var recipient_window = window.open("https://TARGET_URL", target_domain)
recipient_window.postMessage("RANDOM MESSAGE", "*");</code></pre>
			<p>You can also create an HTML page that listens for events coming from the target page, and trigger the postMessage from the target site. See if you can receive sensitive data from the target page.</p>
			<pre><code>var sender_window = window.open("https://TARGET_URL", target_domain)
function parse_data(event) { // Run some code if we receive data from the target }
window.addEventListener("message", parse_data);</code></pre>
			<h3 id="h2-501546c19-0008">Step 4: Find JSONP Issues</h3>
			<p>Finally, if the site is using JSONP, see if you can embed a script tag on your site and request the sensitive data wrapped in the JSONP payload:</p>
			<pre><code>&lt;script src="https://TARGET_URL?callback=parseinfo"&gt;&lt;/script&gt;</code></pre>
			<h3 id="h2-501546c19-0009">Step 5: Consider Mitigating Factors</h3>
			<p>When the target site does not rely on cookies for authentication, these SOP bypass misconfigurations might not be exploitable. For instance, when the site uses custom headers or secret request parameters to authenticate requests, you might need to find a way to forge those to exfiltrate sensitive data.</p>
			<h2 id="h1-501546c19-0003">Escalating the Attack</h2>
			<p>An SOP-bypass bug often means that attackers can read private information or execute action as other users. This means that these vulnerabilities are often of high severity before any escalation attempts. But you can still escalate SOP-bypass issues by automation or by pivoting the attack using the information you’ve found. Can you harvest large amounts of user data by automating the exploitation of the SOP bypass? Can you use the information you’ve found to cause more damage? For example, if you can extract the security questions of a victim, can you use that information to completely take over the user’s account?</p>
			<p>
				Many researchers will simply report CORS misconfigurations without showing the impact of the vulnerability. Consider the impact of the issue before sending the report. For instance, if a publicly readable page is served with a null <code>Access-Control-Allow-Origin</code> header, it would not cause damage <span epub:type="pagebreak" id="Page_306" title="306"/>to the application since that page does not contain any sensitive info. A good SOP-bypass report will include potential attack scenarios and indicate how attackers can exploit the vulnerability. For instance, what data can the attacker steal, and how easy would it be?</p>
			<h2 id="h1-501546c19-0004">Finding Your First SOP Bypass Vulnerability!</h2>
			<p>Go ahead and start looking for your first SOP bypass. To find SOP-bypass vulnerabilities, you will need to understand the SOP relaxation techniques the target is using. You may also want to become familiar with JavaScript in order to craft effective POCs.</p>
			<ol class="decimal">
				<li value="1">Find out if the application uses any SOP relaxation techniques. Is the application using CORS, <code>postMessage</code>, or JSONP?</li>
				<li value="2">If the site is using CORS, test the strength of the CORS allowlist by submitting test <code>Origin</code> headers.</li>
				<li value="3">If the site is using <code>postMessage</code>, see if you can send or receive messages as an untrusted site.</li>
				<li value="4">If the site is using JSONP, try to embed a script tag on your site and request the sensitive data wrapped in the JSONP payload.</li>
				<li value="5">Determine the sensitivity of the information you can steal using the vulnerability, and see if you can do something more.</li>
				<li value="6">Submit your bug report to the program!</li>
			</ol>
		</section>
	</body>
</html>