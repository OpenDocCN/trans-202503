["```\nPS> $cred = Import-CliXml -Path C:\\PowerLab\\VMCredential.xml \nPS> Invoke-Command -VMName 'LABDC' -Credential $cred -ScriptBlock \n{ Install-windowsfeature -Name AD-Domain-Services }\nPSComputerName : LABDC RunspaceId : 33d41d5e-50f3-475e-a624-4cc407858715\nSuccess : True RestartNeeded : No FeatureResult : {Active Directory Domain\nServices, Remote Server Administration Tools, Active Directory module for\nWindows PowerShell, AD DS and AD LDS Tools...} ExitCode : Success ```", "```\n\nAfter providing a credential to connect to the server, you use `Invoke-Command` to remotely run the `Install-WindowsFeature` commands on the remote server.\n\nOnce the feature is installed, you can create the forest by using the `Install-ADDSForest` command. This command is part of the `ActiveDirectory` PowerShell module, which was installed on LABDC as part of the feature installation.\n\nThe `Install-ADDSForest` command is the only command you need to create a forest. It takes a few parameters, which you’ll fill in using code but are usually filled in using a GUI. This forest will be called `powerlab.local`. Since the domain controller is Windows Server 2016, you’ll set the domain mode and forest mode both to `WinThreshold`. For a full breakdown of all the available `DomainMode` and `ForestMode` values, refer to the *Install-ADDSForest* Microsoft documentation page (*[http://bit.ly/2rrgUi6](http://bit.ly/2rrgUi6)*).\n\n#### Saving Secure Strings to Disk\n\nIn [Chapter 16](ch16.xhtml#ch16), when you needed credentials, you saved `PSCredential` objects and reused them in your commands. This time around, you don’t need a `PSCredential` object. Instead, you need only a single encrypted string.\n\nIn this section, you’ll see that you need to pass a safe mode administrator password to a command. As with any piece of sensitive information, you want to use encryption. As you did in the preceding chapter, you’ll use `Export-CliXml` and `Import-CliXml` to save and retrieve PowerShell objects from the filesystem. Here, though, instead of calling `Get-Credential`, you’ll create a secure string by using `ConvertTo-SecureString` and then save that object to a file.\n\nTo save an encrypted password to a file, you pass the plaintext password to `ConvertTo-SecureString` and then export that secure string object to `Export-CliXml`, creating a file you can reference later:\n\n```", "```\n\nAs you can see, after you have the safe mode administrator password saved to disk, you can read it with `Import-CliXml` and pass in all the other parameters that `Install-ADDSForest` needs to run. You do this with the following code:\n\n```", "```\n\nHere, you’re creating a forest and domain called *powerlab.local* ❶ running at a Windows Server 2016 functional level (`WinThreshold`) ❷, bypassing all confirmations ❸, passing your safe mode administrator password ❹, and ignoring the irrelevant warning messages that typically come up ❺.\n\n#### Automating Forest Creation\n\nNow that you’ve done it manually, let’s build a function in your PowerLab module that will handle AD forest creation for you. Once you have a function, you’ll be able to use it across numerous environments.\n\nIn the PowerLab module included with this chapter’s resources, you’ll see a function called `New-PowerLabActiveDirectoryForest`, as shown in [Listing 17-1](ch17.xhtml#ch17list1).\n\n```", "```\n\n*Listing 17-1: The New-PowerLabActiveDirectoryForest function*\n\nAs in the preceding chapter, you simply define several parameters you’ll use to pass to the `ActiveDirectory` module’s `Install-ADDSForest` command. Notice that you define two `Mandatory` parameters for the credentials and password. As its name suggests, these are parameters the user needs to pass in (because the other parameters have default values, the user does not necessarily need to pass them in). You’ll use this function by reading in your saved administrator password and credential, and then passing the two into the function:\n\n```", "```\n\nAfter running this code, you’ll have a fully working Active Domain forest! Well, you should, anyway—let’s figure out a way to confirm that the forest is up and running. A good test is to query all the default user accounts in the domain. To do so, however, you need to create another `PSCredential` object stored on disk; because LABDC is a domain controller now, you need a domain user account (not a local user account). You’ll create and save a credential with the username of `powerlab.local\\administrator` and a password of `P@$$w0rd12` to the *C:\\PowerLab\\DomainCredential.xml* file. Remember that you need to do this only once. Then, you can use the new domain credential to connect to LABDC:\n\n```", "```\n\nOnce the domain credential is created, you’ll create another function in your PowerLab module called `Test-PowerLabActiveDirectoryForest`. Right now, this function just gathers all the users in a domain, but because you have this functionality wrapped in a function, you can customize this test to your liking:\n\n```", "```\n\nTry executing the `Test-PowerLabActiveDirectoryForest` function by using the domain credential and a `VMName` of `LABDC`. If you’re shown a few user accounts, congrats! You’re done! You’ve now successfully set up a domain controller and stored credentials for connecting to VMs in a workgroup (and any future domain-joined VMs).\n\n#### Populating the Domain\n\nIn the preceding section, you set up a domain controller in your PowerLab. Now let’s create some test objects. Since this is a test lab, you want to create various objects (OUs, users, groups, and so on) so that you cover all your bases. You could run the required command to create each individual object, but because you have so many objects to create, that wouldn’t be practical. It’ll be a much better use of your time to define everything in one file, read in each object, and create them all in one go.\n\n##### Handling Your Object Spreadsheet\n\nHere, you’ll use an Excel spreadsheet as your input file to define everything you need as input. This Excel spreadsheet is available via the chapter’s downloadable resources. When you open it, you’ll see it has two worksheets: Users ([Figure 17-1](ch17.xhtml#ch17fig1)) and Groups ([Figure 17-2](ch17.xhtml#ch17fig2)).\n\n![Image](../images/17fig01.jpg)\n\n*Figure 17-1: The Users spreadsheet*\n\n![Image](../images/17fig02.jpg)\n\n*Figure 17-2: The Groups spreadsheet*\n\nEach row of these worksheets corresponds to a user or group that needs to be created, containing information you’ll read into PowerShell. As you saw in [Chapter 10](ch10.xhtml#ch10), native PowerShell cannot handle Excel spreadsheets without significant work. With the help of a popular community module, however, you can make this much easier. Using the `ImportExcel` module, you can read Excel spreadsheets just as easily as you can natively read CSV files. To get `ImportExcel`, you can download it from the PowerShell Gallery by using Install-Module -Name ImportExcel. After a few security prompts, you should have the module downloaded and ready to use.\n\nNow let’s use the `Import-Excel` command to parse in the rows from the worksheet:\n\n```", "```\n\nUsing the `Path` and `WorksheetName` parameters, you can easily pull out the data you need. Notice that here, you’re using the `Format-Table` command. This is a useful command that forces PowerShell to display the output in a table format. The `AutoSize` parameter tells PowerShell to try to squeeze each row into one line in the console.\n\n##### Creating a Plan\n\nYou now have a way to read the data from the Excel spreadsheet. The next step is figuring out what to do with it. You’ll build a function in your PowerLab module that reads each row and performs the action it requires. All code covered here is available via the `New-PowerLabActiveDirectoryTestObject` function in the associated PowerLab module.\n\nThis function is a little more complicated than our previous scripts, so let’s break it down in an informal way—this way, you have something to refer back to. This step may not sound important, but as you make bigger functions, you’ll find that planning them out at the start will save you a lot of work in the long run. In this function, you need to do the following:\n\n1.  Read both worksheets in an Excel spreadsheet and retrieve all user and group rows.\n\n2.  Read each row in both worksheets and first confirm whether the OU that the user or group is supposed to be a part of exists.\n\n3.  If the OU does not exist, create the OU.\n\n4.  If the user/group does not exist, create the user or group.\n\n5.  For users only: add the user as a member of the specified group.\n\nNow that you have this informal outline, let’s get down to coding.\n\n##### Creating the AD Objects\n\nFor the first pass through, you want to keep it simple: let’s focus on handling a single object. No need to complicate things now by worrying about all of them. You installed the `AD-Domain-Services` Windows feature on LABDC earlier, so now you have the `ActiveDirectory` module installed. This module provides a large set of useful commands (as you saw in [Chapter 11](ch11.xhtml#ch11)). Recall that many of the commands follow the same naming convention of `Get/Set/New-AD`.\n\nLet’s open a blank *.ps1* script and get to work. Start by writing out all the commands you need ([Listing 17-2](ch17.xhtml#ch17list2)) based on the previous outline:\n\n```", "```\n\n*Listing 17-2: Figuring out code to check for and create new users and groups*\n\nRecall from our plan that you first need to check whether an OU exists ❶, and then create one if it doesn’t ❷. You do the same thing with each group: check whether it exists ❸ and create one if it doesn’t ❹. And do the same thing for each user: check ❺ and create ❻. Lastly, for your users, check whether they are a member of the group specified in the spreadsheet ❼, and add them to it if they are not ❽.\n\nAll you’re missing here is the conditional structure, which you add in [Listing 17-3](ch17.xhtml#ch17list3).\n\n```", "```\n\n*Listing 17-3: Creating users and groups only if they don’t already exist*\n\nNow that you have the code to do what you want for an individual user or group, you need to figure out how to do it for all of them. First, though, you need to read in the worksheets. You’ve already seen which commands to use; now you need to store all those rows in variables. This isn’t technically required, but it keeps your code more explicit and self-documenting. You’ll use `foreach` loops to read all users and groups, as shown in [Listing 17-4](ch17.xhtml#ch17list4).\n\n```", "```\n\n*Listing 17-4: Building the code structure to iterate over each Excel worksheet row*\n\nNow that you have a structure to loop through every row, let’s use our individual code to handle the rows, as shown in [Listing 17-5](ch17.xhtml#ch17list5).\n\n```", "```\n\n*Listing 17-5: Performing tasks on all users and groups*\n\nYou’re almost done! The script is all ready to go, but now you need to run it on the LABDC server. Since you’re not running this code directly on the LABDC VM itself yet, you have to wrap all this up into a scriptblock and have `Invoke-Command` run it remotely on LABDC for you. Since you want to create and populate the forest in one go, you’ll take all your “scratch” code and move it into your `New-PowerLabActiveDirectoryTestObject` function. You can download a copy of this fully created function in the chapter’s resources.\n\n### Building and Running Pester Tests\n\nYou have all the code you need to create a new AD forest and populate it. Now you’ll build some Pester tests to confirm that everything is working as planned. You have quite a bit to test, so the Pester tests are going to be more complicated than before. Just as you did before creating the *New-PowerLabActiveDirectoryTestObject.ps1* script, first create a Pester test script, and then start thinking of test cases. If you need a refresher about Pester, check out [Chapter 9](ch09.xhtml#ch9). I’ve also included all Pester tests for this chapter in the book’s resources.\n\nWhat do you need to test? In this chapter, you did the following:\n\n*   Created a new AD forest\n\n*   Created a new AD domain\n\n*   Created AD users\n\n*   Created AD groups\n\n*   Created AD organizational units\n\nAfter determining that they exist, you need to make sure that your objects have the correct attributes (the attributes you passed in as parameters to the commands that created them). These are the attributes you’re looking for:\n\n**Table 17-1:** AD Attributes\n\n| **Object** | **Attributes** |\n| AD forest | `DomainName`, `DomainMode`, `ForestMode`, safe mode administrator password |\n| AD user | OU path, name, group member |\n| AD group | OU path, name |\n| AD organizational unit | Name |\n\nWith that, you have a good back-of-the-napkin plan for what you’re looking for with your Pester tests. If you take a look at the *Creating an Active Directory Forest.Tests.ps1* script, you’ll see that I’ve chosen to break down each of these entities into contexts and test all the associated attributes inside as individual tests.\n\nTo give you an idea of how these tests are created, [Listing 17-6](ch17.xhtml#ch17list6) has a snippet of the test code.\n\n```", "```\n\n*Listing 17-6: Some of the Pester test code*\n\nFor this context, you want to make sure that the AD domain and forest are created properly. So you first create the domain and forest ❶; then you verify that the domain and forest have the attributes you expect ❷.\n\nRunning the whole test should give you something like this:\n\n```"]