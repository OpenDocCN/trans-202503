- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16'
- en: UEFI FIRMWARE VULNERABILITIES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 固件漏洞
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Security products nowadays tend to focus on threats that operate at the high
    levels of the software stack, and they achieve reasonably good results. However,
    this leaves them unable to see what’s going on in the dark waters of firmware.
    If an attacker has already gained privileged access to the system and installed
    a firmware implant, these products are useless.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的安全产品倾向于专注于操作软件堆栈高层的威胁，并取得了相当不错的成果。然而，这使得它们无法看到固件中的黑暗水域。如果攻击者已经获得系统的特权访问权限并安装了固件植入物，那么这些产品将毫无作用。
- en: Very few security products examine firmware, and those that do only do so from
    the operating system level, detecting the presence of implants only after they’ve
    successfully installed and compromised the system. More complex implants can also
    use their privileged position in the system to avoid detection and subvert OS-level
    security products.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有安全产品检查固件，而且那些做检查的产品也仅限于操作系统级别，它们只能在植入物成功安装并破坏系统后，才能检测到其存在。更复杂的植入物还可以利用其在系统中的特权位置，避免被检测，并破坏操作系统级别的安全产品。
- en: For these reasons, firmware rootkits and implants are one of the most dangerous
    threats to PCs, and they pose an even bigger threat they pose to modern cloud
    platforms, where a single misconfigured or compromised guest operating system
    endangers all other guests, exposing their memory to malicious manipulation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，固件 rootkit 和植入物是对个人电脑最危险的威胁之一，它们对现代云平台构成了更大的威胁，因为一个配置错误或被攻破的客户操作系统就会危及所有其他客户，暴露其内存并受到恶意操控。
- en: Detecting firmware anomalies is a difficult technical challenge for many reasons.
    The UEFI firmware codebases provided by various vendors are all different, and
    the existing methods of detecting anomalies aren’t effective in every case. Attackers
    can also use both the false positives and false negatives of a detection scheme
    to their advantage, and they can even take over the interfaces that OS-level detection
    algorithms use to access and examine the firmware.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 检测固件异常是一个技术挑战，原因有很多。不同厂商提供的 UEFI 固件代码库各不相同，现有的检测异常方法在每种情况下都不有效。攻击者还可以利用检测方案的误报和漏报来他们的优势，甚至可能接管操作系统级别的检测算法用来访问和检查固件的接口。
- en: The only viable way to protect against firmware rootkits is to prevent their
    installation. Detection and other mitigations don’t work; instead, we have to
    block the possible infection vectors. Solutions for detecting or preventing firmware
    threats work only when the developer has full control over both the software and
    hardware stacks, like Apple or Microsoft does. Third-party solutions will always
    have blind spots.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 保护免受固件 rootkit 攻击的唯一可行方法是防止其安装。检测和其他缓解措施无效；相反，我们必须阻止可能的感染途径。检测或防止固件威胁的解决方案仅在开发者完全控制软件和硬件堆栈时有效，就像苹果或微软那样。第三方解决方案总是会有盲点。
- en: In this chapter, we’ll outline most of the known vulnerabilities and exploitation
    vectors used for infecting UEFI firmware. We’ll first examine the vulnerable firmware,
    classify types of firmware weaknesses and vulnerabilities, and analyze existing
    firmware security measures. We will then describe vulnerabilities in Intel Boot
    Guard, SMM modules, the S3 Boot Script, and the Intel Management Engine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述用于感染 UEFI 固件的大多数已知漏洞和利用途径。我们将首先检查易受攻击的固件，分类固件弱点和漏洞，并分析现有的固件安全措施。然后，我们将描述
    Intel Boot Guard、SMM 模块、S3 启动脚本和 Intel 管理引擎中的漏洞。
- en: '**What Makes Firmware Vulnerable?**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**是什么使固件容易受到攻击？**'
- en: We’ll begin by going over the specific firmware that attackers could target
    with a malicious update. Updates are the most effective method of infection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从攻击者可能通过恶意更新攻击的固件开始讲解。更新是最有效的感染方法。
- en: Vendors will typically describe UEFI firmware updates broadly as *BIOS updates*,
    because the BIOS is the main firmware included, but a typical update also delivers
    many other kinds of embedded firmware to the various hardware units inside the
    motherboard, or even the CPU.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 厂商通常将 UEFI 固件更新广义地描述为 *BIOS 更新*，因为 BIOS 是主要的固件，但典型的更新还会为主板内部的各种硬件单元，甚至 CPU 提供许多其他类型的嵌入式固件。
- en: A compromised BIOS update destroys the integrity guarantees for all other firmware
    updates managed by the BIOS (some of these updates, like Intel microcode, have
    additional authentication methods and don’t rely solely on the BIOS), so any vulnerability
    that bypasses authentication for a BIOS update image also opens the door for the
    delivery of malicious rootkits or implants to any of these units.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 被篡改的BIOS更新会破坏由BIOS管理的所有其他固件更新的完整性保证（其中一些更新，如英特尔微码，具有额外的认证方法，不仅仅依赖BIOS），因此，任何绕过BIOS更新镜像认证的漏洞，也为恶意根工具或植入物的传送打开了大门，可能影响这些设备中的任何一个。
- en: '[Figure 16-1](ch16.xhtml#ch16fig01) shows the typical firmware units managed
    by the BIOS, all of which are susceptible to malicious BIOS updates.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.xhtml#ch16fig01)展示了BIOS管理的典型固件单元，所有这些都容易受到恶意BIOS更新的影响。'
- en: '![image](../images/16fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig01.jpg)'
- en: '*Figure 16-1: Overview of different firmware in modern x86-based computers*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：现代基于x86计算机中不同固件的概述*'
- en: 'Here are brief descriptions of each type of firmware:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每种固件类型的简要描述：
- en: '**Power Management Unit (PMU)** A microcontroller that controls the power functions
    and transitions of a PC between different power states, such as sleep and hibernate.
    It contains its own firmware and a low-power processor.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**电源管理单元（PMU）** 一种微控制器，负责控制PC在不同电源状态之间的电源功能和过渡，例如睡眠和休眠。它包含自己的固件和低功耗处理器。'
- en: '**Intel Embedded Controller (EC)** A microcontroller that is always on. It
    supports multiple features, such as turning the computer on and off, processing
    signals from the keyboard, calculating thermal measurements, and controlling the
    fan. It communicates with the main CPU over ACPI, SMBus, or shared memory. The
    EC, along with the Intel Management Engine described shortly, can function as
    a security root of trust when the System Management Mode is compromised. The Intel
    BIOS Guard technology (vendor-specific implementations), for example, uses the
    EC to control the read/write access to SPI flash.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔嵌入式控制器（EC）** 一种始终开启的微控制器，支持多种功能，例如开关计算机、处理键盘信号、计算热量测量和控制风扇。它通过ACPI、SMBus或共享内存与主CPU通信。EC与随后描述的英特尔管理引擎一起，可以在系统管理模式被破坏时充当安全信任根。例如，英特尔BIOS保护技术（厂商特定的实现）使用EC控制对SPI闪存的读/写访问。'
- en: '**Intel Integrated Sensor Hub (ISH)** A microcontroller responsible for sensors,
    such as device rotation detectors and automatic backlight adjustors. It can also
    be responsible for some low-power sleep states for those sensors.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔集成传感器集线器（ISH）** 一种微控制器，负责传感器，例如设备旋转检测器和自动背光调节器。它还可以负责这些传感器的一些低功耗睡眠状态。'
- en: '**Graphics Processing Unit (GPU)** An integrated graphics processor (iGPU)
    that is part of the Platform Controller Hub (PCH) design in most modern Intel
    x86-based computers. GPUs have their own advanced firmware and computing units
    focused on generating graphics, such as shaders.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形处理单元（GPU）** 一种集成图形处理器（iGPU），它是大多数现代英特尔x86计算机中平台控制器集线器（PCH）设计的一部分。GPU具有自己的先进固件和计算单元，专注于生成图形，如着色器。'
- en: '**Intel Gigabit Network** Intel-integrated ethernet network cards for x86-based
    computers are represented as PCIe devices connected to PCH and contain their own
    firmware, delivered via BIOS update images.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔千兆网络** 集成以太网卡用于基于x86的计算机，表现为连接到PCH的PCIe设备，并包含其固件，通过BIOS更新镜像提供。'
- en: '**Intel CPU Microcode** The CPU’s internal firmware, which is the interpretive
    layer that interprets the ISA. The programmer-visible *instruction set architecture
    (ISA)* is a part of microcode, but some instructions can be more deeply integrated
    on the hardware level. Intel microcode is a layer of hardware-level instructions
    that implement higher-level machine code instructions and the internal state machine
    sequencing in many digital processing elements.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔CPU微码** CPU的内部固件，是解释ISA的解释层。程序员可见的*指令集架构（ISA）* 是微码的一部分，但有些指令可以在硬件层面上更深入地集成。英特尔微码是硬件级指令的一层，实现更高层次的机器码指令和许多数字处理元素中的内部状态机序列。'
- en: '**Authenticated Code Module (ACM)** A signed binary blob executed in cache
    memory. Intel microcode loads and executes within protected internal CPU memory,
    which is called *Authenticated Code RAM (ACRAM)*, or *Cache-as-RAM (CAR)*. This
    fast memory is initialized early in the boot process. It functions as regular
    RAM before the main RAM is activated and before the reset-vector code for early
    boot ACM code (Intel Boot Guard) runs; it can also be loaded later in the boot
    process. Later, it is repurposed for general-purpose caching. The ACM is signed
    by an RSA binary blob with a header that defines its entry point. Modern Intel
    computers can have multiple ACMs for different purposes, but they are mostly used
    to support additional platform security features.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证代码模块 (ACM)** 是一种签名的二进制文件，在缓存内存中执行。英特尔微代码在受保护的内部 CPU 内存中加载并执行，这块内存被称为*认证代码
    RAM (ACRAM)*，或*缓存作为 RAM (CAR)*。这块高速内存会在启动过程中较早初始化。在主内存被激活并且早期启动 ACM 代码（英特尔启动保护）的复位向量代码运行之前，它作为常规
    RAM 使用；也可以在启动过程稍后加载。之后，它会被重新用于一般用途的缓存。ACM 由一个带有定义入口点的 RSA 二进制文件签名。现代的英特尔计算机可能有多个
    ACM，用于不同的目的，但它们大多数用于支持额外的安全平台功能。'
- en: '**Intel Management Engine (ME)** A microcontroller that provides the root-of-trust
    functionality for multiple security features developed by Intel, including the
    software interface to the *firmware Trusted Platform Module*, or *fTPM* (usually
    the TPM is a specialized chip on an endpoint device for hardware-based authentication
    that also contains separate firmware of its own). Since the sixth generation of
    the Intel CPU, the Intel ME is an x86-based microcontroller.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔管理引擎 (ME)** 是一款微控制器，为英特尔开发的多项安全功能提供根信任功能，包括与*固件受信平台模块*（*fTPM*）的软硬件接口（通常，TPM
    是端点设备上的专用芯片，用于硬件认证，并且通常包含独立的固件）。自英特尔第六代 CPU 起，英特尔 ME 是一款基于 x86 架构的微控制器。'
- en: '**Intel Active Management Technology (AMT)** The hardware and firmware platform
    used for managing personal computers and servers remotely. It provides remote
    access to monitors, keyboards, and other devices. It comprises Intel’s chipset-based
    Baseboard Management Controller technology for client-oriented platforms (discussed
    next), integrated into Intel’s ME.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔主动管理技术 (AMT)** 是用于远程管理个人计算机和服务器的硬件和固件平台。它提供对显示器、键盘和其他设备的远程访问。它包括英特尔基于芯片组的基础板管理控制器技术，专为客户平台设计（稍后讨论），并集成在英特尔的
    ME 中。'
- en: '**Baseboard Management Controller (BMC)** A set of computer interface specifications
    for an autonomous computer subsystem that provides management and monitoring capabilities
    independently of the host system’s CPU, UEFI firmware, and real-time operating
    system. The BMC is usually implemented on a separate chip with its own ethernet
    network interface and firmware.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础板管理控制器 (BMC)** 是一套计算机接口规范，用于管理和监控计算机子系统，该子系统独立于主机系统的 CPU、UEFI 固件和实时操作系统运行。BMC
    通常在一个独立的芯片上实现，具有自己的以太网网络接口和固件。'
- en: '**System Management Controller (SMC)** A microcontroller on the logic board
    that controls the power functions and sensors. It’s most commonly found in computers
    produced by Apple.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统管理控制器 (SMC)** 是一款位于主板上的微控制器，用于控制电源功能和传感器。它通常出现在苹果生产的计算机中。'
- en: Every firmware unit is an opportunity for an attacker to store and execute code,
    and all units depend on one another to maintain their integrity. As an example,
    Alex Matrosov identified an issue in recent Gigabyte hardware wherein the ME allowed
    its memory regions to be written to and read from the BIOS. When combined with
    a weak Intel Boot Guard configuration, this issue allowed us to bypass the hardware’s
    Boot Guard implementation completely. (See CVE-2017–11313 and CVE-2017–11314 for
    more information about this vulnerability, which the vendor has since confirmed
    and patched.) We’ll discuss implementations of Boot Guard and possible ways to
    bypass them later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个固件单元都可能成为攻击者存储和执行代码的机会，而所有单元又相互依赖以保持完整性。例如，Alex Matrosov 发现了近期某些技嘉硬件中的一个问题，ME
    允许其内存区域被写入并从 BIOS 中读取。结合弱配置的英特尔启动保护，这个问题使我们能够完全绕过硬件的启动保护实现。（更多关于此漏洞的信息，请参考 CVE-2017–11313
    和 CVE-2017–11314，供应商已确认并修复了此问题。）我们将在本章稍后讨论启动保护的实现及绕过方法。
- en: The primary objective of a BIOS rootkit is to maintain a persistent and stealthy
    infection, just like the kernel-mode rootkits and MBR/VBR bootkits described in
    the book so far. However, a BIOS rootkit may have additional interesting goals.
    It might, for instance, try to temporarily gain control of the System Management
    Mode (SMM) or nonprivileged Driver Execution Environment (DXE; executed outside
    of SMM) to conduct hidden operations with memory or the filesystem. Even a nonpersistent
    attack executed from the SMM can bypass security boundaries in modern Windows
    systems, including virtualization-based security (VBS) and instances of virtual
    machine guests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS rootkit 的主要目标是保持持续且隐蔽的感染，就像书中描述的内核模式 rootkit 和 MBR/VBR 启动根kit一样。然而，BIOS
    rootkit 可能有额外的有趣目标。例如，它可能尝试临时控制系统管理模式（SMM）或非特权驱动程序执行环境（DXE；在 SMM 之外执行），以进行内存或文件系统的隐藏操作。即使是从
    SMM 执行的非持久性攻击，也能够绕过现代 Windows 系统中的安全边界，包括基于虚拟化的安全（VBS）和虚拟机来宾实例。
- en: '**Classifying UEFI Firmware Vulnerabilities**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分类 UEFI 固件漏洞**'
- en: Before digging into the vulnerabilities, let’s classify the kinds of security
    flaws a BIOS implant installation might target. All the classes of vulnerabilities
    shown in [Figure 16-2](ch16.xhtml#ch16fig02) can help an attacker violate security
    boundaries and install persistent implants.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究漏洞之前，让我们先分类 BIOS 植入安装可能针对的安全缺陷类型。[图 16-2](ch16.xhtml#ch16fig02) 中展示的所有漏洞类别都可以帮助攻击者突破安全边界并安装持久性植入物。
- en: Intel researchers first attempted to classify UEFI firmware vulnerabilities
    according to the potential impact of an attack on that vulnerability. They presented
    their classifications at Black Hat USA 2017 in Las Vegas in their talk “Firmware
    Is the New Black—Analyzing Past Three Years of BIOS/UEFI Security Vulnerabilities”
    (*[https://www.youtube.com/watch?v=SeZO5AYsBCw](https://www.youtube.com/watch?v=SeZO5AYsBCw)*),
    which covered different classes of security issues as well as some mitigations.
    One of its most important contributions is the statistics on the growth in the
    total number of security issues processed by Intel PSIRT.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔研究人员首次尝试根据攻击对漏洞潜在影响的不同，来对 UEFI 固件漏洞进行分类。他们在 2017 年的 Black Hat USA 大会上，展示了他们的分类方法，主题为“固件是新的黑色——分析过去三年
    BIOS/UEFI 安全漏洞”（* [https://www.youtube.com/watch?v=SeZO5AYsBCw](https://www.youtube.com/watch?v=SeZO5AYsBCw)*），该演讲涵盖了不同类别的安全问题以及一些缓解措施。它的一个重要贡献是提供了英特尔
    PSIRT 处理的安全问题总数增长的统计数据。
- en: We have a different classification of security issues related to UEFI firmware
    that focuses on the impact of firmware rootkits, shown in [Figure 16-2](ch16.xhtml#ch16fig02).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一种不同的安全问题分类方法，专注于固件 rootkit 的影响，如 [图 16-2](ch16.xhtml#ch16fig02) 所示。
- en: '**NOTE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The threat model represented in [Figure 16-2](ch16.xhtml#ch16fig02) covers
    only flows related to UEFI firmware, but the scope of security issues for Intel
    ME and AMT is increasing significantly. Additionally, in the past few years, the
    BMC has emerged as a very important security asset for remote management server
    platforms and is getting a lot of attention from researchers.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 16-2](ch16.xhtml#ch16fig02) 中表示的威胁模型仅涵盖与 UEFI 固件相关的流量，但英特尔 ME 和 AMT 的安全问题范围正在显著增加。此外，近年来，BMC
    已成为远程管理服务器平台非常重要的安全资产，并且受到了研究人员的高度关注。*'
- en: '![image](../images/16fig02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig02.jpg)'
- en: '*Figure 16-2: A classification of BIOS vulnerabilities useful for installing
    BIOS implants*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-2：适用于安装 BIOS 植入物的 BIOS 漏洞分类*'
- en: 'We can categorize the vulnerability classes proposed in [Figure 16-2](ch16.xhtml#ch16fig02)
    by how they are used, giving us two major groups: *post-exploitation* and *compromised
    supply chain*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据漏洞的使用方式对 [图 16-2](ch16.xhtml#ch16fig02) 中提出的漏洞类别进行分类，分为两大类：*后期利用* 和 *受损供应链*。
- en: '***Post-Exploitation Vulnerabilities***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***后期利用漏洞***'
- en: Post-exploitation vulnerabilities are usually used as the second stage in delivering
    malicious payloads (this exploitation scheme is explained in [Chapter 15](ch15.xhtml#ch15)).
    This is the main category of vulnerabilities that attackers take advantage of
    to install both persistent and non-persistent implants after they’ve successfully
    exploited previous stages of attack. The following are the classes for the main
    implants, exploits, and vulnerabilities in this category.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 后渗透漏洞通常被用作传递恶意载荷的第二阶段（该利用方案在[第15章](ch15.xhtml#ch15)中有详细解释）。这是攻击者利用的主要漏洞类别，在成功利用先前攻击阶段后安装持久和非持久植入物的过程中被利用。以下是此类别中主要植入物、利用和漏洞的类别。
- en: '**Secure Boot bypass** Attackers focus on compromising the Secure Boot process
    over exploiting root of trust (that is, full compromise) or another vulnerability
    in one of the boot stages. Secure Boot bypasses can occur at different boot stages
    and can be leveraged by the attacker against all the subsequent layers and their
    trust mechanisms.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全启动绕过** 攻击者专注于绕过安全启动过程，而不是利用信任根（即完全妥协）或引导阶段中的其他漏洞。安全启动绕过可以发生在不同的引导阶段，并且可以被攻击者用来针对所有后续层和它们的信任机制。'
- en: '**SMM privilege escalation** SMM has a lot of power on x86 hardware, as almost
    all privilege escalation issues for SMM end up as code execution issues. Privilege
    escalation to SMM is often one of the final stages of a BIOS implant installation.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**SMM特权升级** SMM在x86硬件上具有很强的功能，因为几乎所有的SMM特权升级问题最终都会成为代码执行问题。提升到SMM的特权往往是BIOS植入物安装的最后阶段之一。'
- en: '**UEFI firmware implant** A UEFI firmware implant is the final stage of a persistent
    BIOS implant installation. The attacker can install the implant on various levels
    of the UEFI firmware, either as a modified legitimate module or a stand-alone
    driver like DXE or PEI, which we’ll discuss later.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**UEFI固件植入物** UEFI固件植入物是持久BIOS植入物安装的最终阶段。攻击者可以将植入物安装在UEFI固件的各个级别上，可以是修改后的合法模块，也可以是后续将讨论的DXE或PEI等独立驱动程序。'
- en: '**Persistent implant** A persistent implant is one that can survive full reboot
    and shutdown cycles. In some cases, in order to survive the post-update process,
    it can modify BIOS update images before those updates are installed.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久植入物** 持久植入物是可以在完全重启和关机周期中存活的植入物。在某些情况下，为了在后续更新过程中存活，它可以修改BIOS更新映像。'
- en: '**Non-persistent implant** A non-persistent implant is one that doesn’t survive
    full reboot and shutdown cycles. These implants might provide privilege escalation
    and code execution inside the OS with protected hardware virtualization (such
    as Intel VT-x) and layers of trusted execution (such as MS VBS). They can also
    be used as covert channels to deliver malicious payloads to the kernel mode of
    the operating system.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**非持久植入物** 非持久植入物是不能在完全重启和关机周期中存活的植入物。这些植入物可能会提供特权升级，并在具有受保护硬件虚拟化（如Intel VT-x）和受信任执行层（如MS
    VBS）的操作系统中提供代码执行。它们还可以用作向操作系统内核模式传递恶意载荷的隐蔽通道。'
- en: '***Compromised Supply Chain Vulnerabilities***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***受损供应链漏洞***'
- en: '*Compromised supply chain attacks* take advantage of mistakes made by the BIOS
    development team or the OEM hardware vendor, or they involve deliberate misconfigurations
    of the target software that provide attackers with a deniable bypass of the platform’s
    security features.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*受损供应链攻击* 利用BIOS开发团队或OEM硬件供应商的错误，或涉及目标软件的故意配置错误，从而提供给攻击者对平台安全特性的可否认绕过。'
- en: In supply chain attacks, an attacker gets access to the hardware during its
    production and manufacturing processes and injects malicious modifications to
    the firmware or installs malicious peripheral devices before the hardware ever
    gets to the consumer. Supply chain attacks can also happen remotely, as when an
    attacker gains access to the firmware developer’s internal network (or sometimes
    a vendor website) and delivers malicious modifications directly into the source
    code repository or build server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在供应链攻击中，攻击者在硬件生产和制造过程中获取硬件访问权限，并在硬件到达消费者之前向固件注入恶意修改或安装恶意外围设备。供应链攻击也可以远程发生，例如当攻击者获取固件开发者内部网络（有时是供应商网站）的访问权限，并直接将恶意修改传递到源代码存储库或构建服务器中。
- en: Supply chain attacks with physical access involve covertly meddling with the
    target platform, and they sometimes have similarities with *evil maid attacks*,
    when attackers have physical access for a limited time during which they exploit
    a supply chain vulnerability. These attacks take advantage of situations in which
    the hardware’s owner can’t monitor physical access to the hardware—such as when
    the owner leaves a laptop in a checked bag, surrenders it for a foreign customs
    inspection, or simply forgets it in a hotel room. An attacker can use these opportunities
    to misconfigure hardware and firmware to deliver BIOS implants or just physically
    flash malicious firmware to the SPI flash chip.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 具有物理访问权限的供应链攻击涉及悄悄干扰目标平台，它们有时与*邪恶女仆攻击*相似，攻击者在有限的时间内拥有物理访问权限，并利用供应链漏洞进行攻击。这些攻击利用了硬件所有者无法监控物理访问的情况——例如，当所有者将笔记本电脑放入托运行李中，交给外方海关检查，或者仅仅忘记在酒店房间里。攻击者可以利用这些机会重新配置硬件和固件，植入BIOS或直接将恶意固件写入SPI闪存芯片。
- en: Most of the following issues apply to supply chain and evil maid attack scenarios.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下大多数问题适用于供应链和邪恶女仆攻击场景。
- en: '**Misconfigured protections** By attacking the hardware or firmware during
    the development process or post-production stage, an attacker can misconfigure
    technology protections to allow them to be bypassed easily later.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置错误的保护措施** 通过在开发过程或生产后阶段攻击硬件或固件，攻击者可以错误配置技术保护措施，以便在后续轻松绕过它们。'
- en: '**Nonsecure root of trust** This vulnerability involves compromising the root
    of trust from the operating system via its communication interfaces with firmware
    (SMM, for example).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**不安全的信任根** 该漏洞涉及通过操作系统与固件（例如SMM）的通信接口来破坏信任根。'
- en: '**Malicious peripheral devices** This kind of attack involves implanting peripheral
    devices during the production or delivery stages. Malicious devices can be used
    in multiple ways, such as for *Direct Memory Access (DMA)* attacks.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意外设** 这种攻击涉及在生产或交付阶段植入恶意外设。恶意设备可以以多种方式被使用，例如进行*直接内存访问（DMA）*攻击。'
- en: '**Implanted BIOS updates** An attacker may compromise a vendor website or another
    remote update mechanism and use it to deliver an infected BIOS update. The points
    of compromise can include the vendor’s build servers, developer systems, or stolen
    digital certificates with the vendor’s private keys.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**植入的BIOS更新** 攻击者可能会破坏供应商网站或其他远程更新机制，利用它来传送感染了的BIOS更新。攻击的突破点可能包括供应商的构建服务器、开发者系统或被窃取的数字证书与供应商的私钥。'
- en: '**Unauthenticated BIOS update process** Vendors may break the authentication
    process for BIOS updates, whether intentionally or not, allowing attackers to
    apply any modifications they want to the update images.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**未经认证的BIOS更新过程** 供应商可能会破坏BIOS更新的认证过程，无论是有意还是无意，从而允许攻击者对更新镜像进行任何他们想要的修改。'
- en: '**Outdated BIOS with known security issues** BIOS developers might continue
    to use older, vulnerable code versions of BIOS firmware, even after the underlying
    codebase has been patched, which makes the firmware vulnerable to attack. An outdated
    version of the BIOS originally delivered by the hardware vendor is likely to persist,
    without updates, on the users’ PCs or data center servers. This is one of the
    most common security failures involving BIOS firmware.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**具有已知安全问题的过时BIOS** BIOS开发人员可能会继续使用较旧的、存在漏洞的BIOS固件版本，即使基础代码库已经修补，这使得固件容易受到攻击。硬件供应商最初交付的过时BIOS版本可能会在用户的个人电脑或数据中心服务器上长期存在而没有更新。这是BIOS固件中最常见的安全问题之一。'
- en: '***Supply Chain Vulnerability Mitigation***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***供应链漏洞缓解***'
- en: It’s very hard to mitigate risks related to supply chains without making radical
    changes to the development and production lifecycles. The typical production client
    or server platform includes a lot of third-party components, in both software
    and hardware. Most companies that don’t own their full production cycle don’t
    care too much about security, nor can they really afford to.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在不对开发和生产生命周期进行根本性改变的情况下，很难减轻与供应链相关的风险。典型的生产客户端或服务器平台包括许多第三方组件，包括软件和硬件。大多数没有完全拥有生产周期的公司对安全性不太关注，也确实负担不起。
- en: The situation is exacerbated by the general lack of information and resources
    related to BIOS security configuration and to chipset configuration. The NIST
    800-147 (“BIOS Protection Guidelines”) and NIST 800-147B (“BIOS Protection Guidelines
    for Servers”) publications serve as a useful starting point but are quickly becoming
    outdated since their initial release in 2011 and update for servers in 2014.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况由于缺乏与 BIOS 安全配置和芯片组配置相关的信息和资源而进一步加剧。NIST 800-147（“BIOS 保护指南”）和 NIST 800-147B（“服务器
    BIOS 保护指南”）出版物作为一个有用的起点，但自 2011 年首次发布以及 2014 年针对服务器更新以来，它们很快就变得过时了。
- en: Let’s dive into the details of some UEFI firmware attacks to fill some of these
    gaps in widespread knowledge.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一些 UEFI 固件攻击，以填补这些普遍知识的空白。
- en: '**A History of UEFI Firmware Protections**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UEFI 固件保护的历史**'
- en: In this section, we’ll go over some classes of vulnerabilities that allow an
    attacker to bypass Secure Boot; we’ll discuss specific Secure Boot implementation
    details in the next chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些允许攻击者绕过安全启动的漏洞类别；我们将在下一章讨论具体的安全启动实施细节。
- en: 'Previously, any security issue that allowed the attacker to execute code in
    the SMM environment could bypass Secure Boot. Though some modern hardware platforms,
    even with recent hardware updates, are still vulnerable to SMM-based Secure Boot
    attacks, most enterprise vendors have shifted to using the newest Intel security
    features, which make these attacks harder. Today’s Intel technologies, such as
    Intel Boot Guard and BIOS Guard (both of which will be discussed later in this
    chapter), move the boot process’s root of trust from SMM to a more secure environment:
    the Intel ME firmware/hardware.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，任何允许攻击者在 SMM 环境中执行代码的安全问题都可以绕过安全启动。尽管一些现代硬件平台，即使经过了最近的硬件更新，仍然容易受到基于 SMM 的安全启动攻击，但大多数企业供应商已经转向使用最新的英特尔安全功能，这使得这些攻击变得更加困难。今天的英特尔技术，如英特尔启动保护（Intel
    Boot Guard）和 BIOS 保护（BIOS Guard，稍后将在本章中讨论），将启动过程的信任根从 SMM 转移到一个更安全的环境：英特尔 ME 固件/硬件。
- en: '**ROOT OF TRUST**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**信任根**'
- en: The root of trust is a proven cryptographic key represented as the anchor for
    Secure Boot. Secure Boot establishes a hardware-validated boot process to ensure
    the platform can be started only with trusted code that has been verified successfully
    with the root of trust. Modern platform designs lock their root of trust in hardware-based
    protected storage, such as one-time programmable fuses or a separate chip with
    persistent storage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 信任根是一个经过验证的加密密钥，作为安全启动的锚点。安全启动通过建立一个硬件验证的启动过程，确保平台只能使用已经通过信任根验证的受信任代码启动。现代平台设计将其信任根锁定在基于硬件的受保护存储中，例如一次性可编程熔丝或带有持久存储的独立芯片。
- en: The first version of UEFI Secure Boot was introduced in 2012\. Its main components
    included a root of trust implemented in the DXE boot phase (one of the latest
    stages in UEFI firmware boot, just before the OS receives control). That meant
    this early implementation of Secure Boot only really ensured the integrity of
    the OS bootloaders, not the BIOS itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 安全启动的第一个版本在 2012 年推出。它的主要组成部分包括在 DXE 启动阶段（UEFI 固件启动的最新阶段之一，操作系统接管控制之前）实现的信任根。这意味着这个早期的安全启动实现只真正确保了操作系统引导程序的完整性，而不是
    BIOS 本身。
- en: Soon the weaknesses of this design became clear, and in the next implementation,
    the root of trust was moved to PEI, an early platform initialization stage, where
    it was locked before DXE. That security boundary also proved weak. Since 2013,
    with the release of the Intel Boot Guard technology, the root of trust has been
    locked into hardware by way of the TPM chip (or equivalent functionality implemented
    in ME firmware to reduce the cost of support). Field-programmable fuses (FPFs)
    are located in the motherboard chipset (the PCH component, programmable via ME
    firmware).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，这一设计的弱点变得显而易见，在下一个实施中，信任根被移至 PEI，这是平台初始化的早期阶段，在 DXE 之前就将其锁定。然而，这个安全边界也证明是脆弱的。自
    2013 年起，随着英特尔启动保护技术的发布，信任根通过 TPM 芯片（或在 ME 固件中实现的等效功能，以降低支持成本）锁定在硬件中。现场可编程熔丝（FPF）位于主板芯片组（PCH
    组件，通过 ME 固件可编程）。
- en: Before we dig into the history of the relevant exploitations that motivated
    these redesigns, let’s discuss how basic BIOS protection technologies work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨促使这些重新设计的相关漏洞历史之前，让我们先讨论一下基本的 BIOS 保护技术如何工作。
- en: '***How BIOS Protections Work***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***BIOS 保护如何工作***'
- en: '[Figure 16-3](ch16.xhtml#ch16fig03) shows a high-level view of the technologies
    used to protect persistent SPI flash storage. The SMM was originally allowed both
    read and write access to SPI flash storage as a means of implementing routine
    BIOS updates. This meant the integrity of the BIOS was dependent on the code quality
    of *any* code running in the SMM, as any such code would be able to modify the
    BIOS in the SPI storage. The security boundary was therefore as weak as the weakest
    code ever run in SMM that had access to the memory region outside of it. As a
    result, platform developers took steps to separate BIOS updates from the rest
    of the SMM functionality, introducing a series of additional security controls,
    such as Intel BIOS Guard.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-3](ch16.xhtml#ch16fig03)显示了用于保护持久 SPI 闪存存储的技术的高级视图。SMM 最初允许对 SPI 闪存存储进行读写访问，以便实现常规的
    BIOS 更新。这意味着 BIOS 的完整性依赖于 *任何* 在 SMM 中运行的代码的质量，因为任何此类代码都可以修改 SPI 存储中的 BIOS。因此，安全边界的强度仅与运行在
    SMM 中的最弱代码的强度相同，而这些代码又有权限访问 SMM 之外的内存区域。因此，平台开发者采取措施将 BIOS 更新与 SMM 的其他功能分开，引入了一系列附加的安全控制措施，例如英特尔
    BIOS Guard。'
- en: '![image](../images/16fig03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig03.jpg)'
- en: '*Figure 16-3: High-level representation of BIOS security technologies*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-3：BIOS 安全技术的高级表示*'
- en: '***SPI Flash Protections and Their Vulnerabilities***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SPI 闪存保护及其漏洞***'
- en: 'We discussed some of the controls shown in [Figure 16-3](ch16.xhtml#ch16fig03)
    in “[(In)Effectiveness of Memory Protection Bits](ch15.xhtml#ch15lev2sec5)” on
    [page 263](ch15.xhtml#page_263): the BIOS Control Bit Protection (BIOS_CNTL),
    the Flash Configuration Lock-Down (FLOCKDN), and the SPI flash Write Protection
    (PRx). However, the BIOS_CNTL protections are effective only against an attacker
    attempting to modify the BIOS from the OS, and they can be bypassed by any code
    execution vulnerability from SMM (SMI handlers accessible from outside), as SMM
    code can freely change these protection bits. Basically, BIOS_CNTL only creates
    an illusion of security.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“[(内存保护位的(无)效力](ch15.xhtml#ch15lev2sec5)”第[263页](ch15.xhtml#page_263)中讨论了[图
    16-3](ch16.xhtml#ch16fig03)中显示的一些控制：BIOS 控制位保护（BIOS_CNTL）、闪存配置锁定（FLOCKDN）和 SPI
    闪存写保护（PRx）。然而，BIOS_CNTL 保护仅对尝试从操作系统修改 BIOS 的攻击者有效，并且它可以通过任何来自 SMM 的代码执行漏洞绕过（SMI
    处理程序可以从外部访问），因为 SMM 代码可以自由修改这些保护位。基本上，BIOS_CNTL 仅创建了一种安全的假象。
- en: Originally, the SMM had both read and write access to SPI Flash storage so it
    could implement routine BIOS updates. This made the integrity of the BIOS dependent
    on the quality of *any* code running in the SMM with calls to outside memory regions,
    as any such code was able to modify the BIOS in the SPI storage. This security
    boundary proved rather weak—as weak as the weakest code ever running in SMM.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，SMM 对 SPI 闪存存储既有读访问权限也有写访问权限，因此可以实现常规的 BIOS 更新。这使得 BIOS 的完整性依赖于 *任何* 在 SMM
    中运行的代码的质量，因为任何此类代码都能够修改 SPI 存储中的 BIOS。这个安全边界证明是相当脆弱的——脆弱程度与 SMM 中运行的最弱代码相当。
- en: As a result, platform developers took steps to separate BIOS updates from the
    rest of SMM functionality. Many of these controls themselves were rather weak.
    An example is the BIOS Control Bit Protection (BIOS_CNTL), which is effective
    only against an attacker attempting to modify the BIOS from the operating system;
    it can be bypassed by any code execution vulnerability from SMM, since SMM code
    can freely change these protection bits.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，平台开发者采取措施将 BIOS 更新与 SMM 的其他功能分离。这些控制本身往往较弱。例如，BIOS 控制位保护（BIOS_CNTL）仅对尝试从操作系统修改
    BIOS 的攻击者有效；任何来自 SMM 的代码执行漏洞都可以绕过该保护，因为 SMM 代码可以自由修改这些保护位。
- en: The PRx control is more effective because its policies can’t be changed from
    the SMM. However, as we’ll discuss shortly, many vendors don’t use PRx protections—including
    Apple and, surprisingly, Intel, the inventor of this protection technology.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PRx 控制更有效，因为其政策无法从 SMM 中更改。然而，正如我们稍后将讨论的那样，许多厂商并未使用 PRx 保护——包括 Apple 和令人惊讶的
    Intel，尽管它是这种保护技术的发明者。
- en: '[Table 16-1](ch16.xhtml#ch16tab01) summarizes the state of active protection
    technologies based on security lock bits on x86-based hardware used by popular
    vendors as of January 2018\. Here, RP indicates *read protections* and WP *write
    protections*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-1](ch16.xhtml#ch16tab01)总结了截至 2018 年 1 月，流行厂商基于安全锁位的 x86 硬件的活动保护技术状态。在此，RP
    表示 *读取保护*，WP 表示 *写入保护*。'
- en: '**Table 16-1:** Security Level of Popular Hardware Vendors'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-1：** 常见硬件厂商的安全级别'
- en: '| **Vendor name** | **BLE** | **SMM_BWP** | **PRx** | **Authenticated update**
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| **ASUS** | Active | Active | Not active | Not active |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| **MSI** | Not active | Not active | Not active | Not active |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| **Gigabyte** | Active | Active | Not active | Not active |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| **Dell** | Active | Active | RP/WP | Active |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| **Lenovo** | Active | Active | RP | Active |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| **HP** | Active | Active | RP/WP | Active |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| **Intel** | Active | Active | Not active | Active |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| **Apple** | Not active | Not active | WP | Active |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: As you can see, vendors differ wildly in their approaches to BIOS security.
    Some of these vendors don’t even authenticate BIOS updates, thereby creating a
    serious security concern because it is far easier to install implants (unless
    the vendor enforces Intel Boot Guard policies).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, PRx protections must be configured correctly to be effective. [Listing
    16-1](ch16.xhtml#ch16list01) shows an example of poorly configured flash regions
    with all PRx segment definitions set to zero, rendering them useless.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 16-1: Poorly configured PRx access policies (dumped by Chipsec tool)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also seen some vendors configure policies for read protection only, which
    still allows the attacker to modify SPI flash. Furthermore, PRx doesn’t guarantee
    any type of integrity measurements on the actual contents of SPI, as it only implements
    bit-based locking of direct read/write access in the very early PEI stage of the
    boot process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The reason vendors like Apple and Intel tend to disable PRx protections is that
    these protections require an immediate reboot, making updating the BIOS less convenient.
    Without PRx protections, a vendor’s BIOS update tool can write the new BIOS image
    into a free region of physical memory using OS APIs, then call an SMI interrupt,
    so that some helper code residing in the SMM can take the image from that region
    and write it into SPI flash. The updated SPI flash image takes control on the
    next reboot, but that reboot can occur in the future at the user’s convenience.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: When PRx is enabled and configured correctly to protect the appropriate regions
    of the SPI from modifications made by SMM code, the BIOS updater tool no longer
    can use the SMM to modify the BIOS. Instead, it must store the update image in
    dynamic random access memory (DRAM) and trigger an immediate reboot. The helper
    code to install the update must be part of a special early boot-stage driver,
    which runs before PRx protections are activated and transfers the update image
    from DRAM to SPI. This method of update sometimes requires a reboot (or a call
    to the SMI handler directly without reboot) right when the tool runs, which is
    a lot less convenient for the user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: No matter which route the BIOS updater takes, it’s critical that the helper
    code authenticate the update image before installing it. Otherwise, PRx or no
    PRx, reboot or no reboot, the helper code will happily install an altered BIOS
    image with an implant, so long as the attacker manages to modify it at some point
    before the helper runs. As [Table 16-1](ch16.xhtml#ch16tab01) shows, some hardware
    vendors don’t authenticate firmware updates, making the attacker’s job as easy
    as tampering with the update image.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**FIRST PUBLICLY KNOWN ATTACK ON THE BIOS UPDATE PROCESS**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that even if you correctly configure PRx and authenticate the BIOS
    updates’ cryptographic signatures, you could still be susceptible to attacks.
    The first publicly known attack against an authenticated and signed BIOS update
    process armed with active SPI flash protection bits was presented in “Attacking
    Intel BIOS” by Rafal Wojtczuk and Alex Tereshkin at Black Hat Vegas in 2009\.
    The authors demonstrated a memory corruption vulnerability inside the parser for
    the BIOS update image file that led to arbitrary code execution and bypassed authentication
    of the update file’s signature.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '***Risks Posed by an Unauthenticated BIOS Update***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In September 2018, the antivirus company ESET released a research report about
    LOJAX, a rootkit that attacked UEFI firmware from the OS.^([1](footnotes.xhtml#ch16fn1))
    All of the techniques used by the LOJAX rootkit were well-known at the time of
    the attack, having been used in other discovered malware over the previous five
    years. LOJAX used tactics similar to those of the Hacking Team’s UEFI rootkit:
    it abused the unauthenticated Computrace components stored in the NTFS, as we
    discussed in [Chapter 15](ch15.xhtml#ch15). Thus, the LOJAX rootkit doesn’t use
    any new vulnerabilities; its only novelty is in how it infects the targets—it
    checks the systems for unauthenticated access to the SPI flash and, finding it,
    delivers a modified BIOS update file.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Loose approaches to BIOS security present plenty of opportunities for attacks.
    An attacker can scan a system at runtime to find the right vulnerable targets
    and the right infection vector, both of which are plentiful. The LOJAX rootkit
    infector checked for several protections, including the BIOS Lock Bit (BLE) and
    the SMM BIOS Write Protection Bit (SMM_BWP). If the firmware hadn’t been authenticated,
    or if it hadn’t checked the integrity of a BIOS update image before transferring
    it to SPI storage, the attacker could deliver modified updates directly from the
    OS. LOJAX used the Speed Racer vulnerability (VU#766164, originally discovered
    by Corey Kallenberg in 2014) to bypass SPI flash protection bits via a race condition.
    You can detect this vulnerability and other weaknesses related to BIOS lock protection
    bits with the `chipsec_main -m common.bios_wp` command.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: This example shows that a security boundary is only as strong as its weakest
    component. No matter what other protections the platform may have, Computrace’s
    loose handling of code authentication undermined them, reenabling the OS-side
    attack vector that the other protections sought to eliminate. It only takes one
    breach of a sea wall to flood the plains.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '***BIOS Protection with Secure Boot***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How does Secure Boot change this threat landscape? The short answer is, it depends
    on its implementation. Older versions, implemented before 2016 without Intel Boot
    Guard and BIOS Guard technologies, will be in danger, because in these old implementations,
    the root of trust is in the SPI flash and can be overwritten.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: When the first version of UEFI Secure Boot was introduced in 2012, its main
    components included a root of trust implemented in the *DXE boot phase*, which
    is one of the latest stages in UEFI firmware boot, occurring just before the OS
    receives control. Because the root of trust came so late in the boot process,
    this early Secure Boot implementation really assured only the integrity of the
    OS bootloaders, rather than the integrity of the BIOS itself. The weakness of
    this design soon became clear, and in the next implementation, the root of trust
    was moved to *PEI*, an early platform initialization stage, to lock the root of
    trust before DXE. That security boundary also proved weak.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Boot Guard and BIOS Guard, more recent additions to Secure Boot, address this
    weakness: Boot Guard moved the root of trust from SPI into hardware, and BIOS
    Guard moved the task of updating the contents of the SPI flash from SMM to a separate
    chip (the Intel Embedded Controller, or EC) and removed the permissions that allowed
    the SMM to write to the SPI flash.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration for moving the root of trust earlier in the boot process,
    and into hardware, is minimizing the boot time of a trusted platform. You could
    imagine a boot protection scheme that would verify digital signatures over dozens
    of individual available EFI images rather than a single image that includes all
    the drivers. However, this would be too slow for today’s world, in which platform
    vendors look to shave milliseconds off the bootup time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you might be asking: with so many moving parts involved in the
    Secure Boot process, how can we avoid situations in which a trivial bug destroys
    all of its security guarantees? (We’ll cover the full process of Secure Boot in
    [Chapter 17](ch17.xhtml#ch17).) The best answer, to date, is to have tools that
    make sure every component plays its appointed role and that every stage of the
    boot process takes place in the exact intended order. That is to say, we need
    a formal model of the process that automated code analysis tools can validate—and
    that means that the simpler the model, the more confidence we have that it will
    be checked correctly.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Secure Boot relies on a chain of trust: the intended execution path begins
    with the root of trust locked into the hardware or SPI flash storage and moves
    through the stages of the Secure Boot process, which can proceed only in a particular
    order and only if all of the conditions and policies at every stage are satisfied.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Formally speaking, we call this model a *finite state machine*, where different
    states represent different stages of the system boot process. If any of the stages
    has nondeterministic behavior—for example, if a stage can switch the boot process
    into a different mode or have multiple exits—our Secure Boot process becomes a
    nondeterministic finite state machine. This makes the task of automatically verifying
    the Secure Boot process significantly harder, because it exponentially increases
    the number of execution paths we must verify. In our opinion, nondeterministic
    behavior in Secure Boot should be regarded as a design mistake that is likely
    to lead to costly vulnerabilities, as in the case of the S3 Boot Script vulnerability
    discussed later in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Intel Boot Guard**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll discuss how Intel Boot Guard technology works, then explore
    some of its vulnerabilities. Although Intel has no publicly available official
    documentation about Boot Guard, our research and that of others allow us to paint
    a coherent picture of this remarkable technology.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '***Intel Boot Guard Technology***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Boot Guard divides Secure Boot into two phases: in the first phase, Boot Guard
    authenticates everything located in the BIOS section of the SPI storage, and in
    the second stage, Secure Boot handles the rest of the boot process, including
    authentication of the OS bootloader ([Figure 16-4](ch16.xhtml#ch16fig04)).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/16fig04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-4: The boot process with active Intel Boot Guard technology*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The Intel Boot Guard technology spans several levels of the CPU architecture
    and the related abstractions. One benefit is that it doesn’t need to trust the
    SPI storage, so it’s able to avoid the vulnerabilities we discussed earlier in
    this chapter. Boot Guard separates integrity checking of the BIOS stored in the
    SPI flash from the BIOS itself by using the Authenticated Code Module (ACM), which
    is signed by Intel, to verify the integrity of the BIOS image before allowing
    it to execute. With Boot Guard activated on a platform, the root of trust moves
    inside the Intel microarchitecture, wherein the CPU’s microcode parses the ACM
    contents and checks the digital signature verification routines implemented in
    the ACM, which in turn will check the BIOS signature.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the original UEFI Secure Boot root of trust resided in the UEFI
    DXE phase, almost the last one before control is passed to the OS bootloader—which
    is, as we’ve mentioned before, very late in the game. If UEFI firmware is compromised
    at the DXE stage, an attacker can completely bypass or disable Secure Boot. Without
    hardware-assisted verification, there is no way to guarantee the integrity of
    the boot process stages that take place before the DXE phase (PEI implementation
    also has confirmed weaknesses), including the integrity of the DXE drivers themselves.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Boot Guard addresses this problem by moving the root of trust for Secure Boot
    from the UEFI firmware to the hardware itself. For example, Verified Boot—a recent
    variant of Boot Guard that Intel introduced in 2013, which we’ll discuss in more
    detail in the next chapter—locks the hash of an OEM public key within the field
    programmable fuse (FPF) store. The FPF can be programmed only one time, and the
    hardware vendor locks the configuration by the end of the manufacturing process
    (in some cases this can be revoked, but because these are edge cases, we won’t
    discuss them here).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '***Vulnerabilities in Boot Guard***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Boot Guard’s efficacy depends on all of its components working together, with
    no layer containing any vulnerabilities for the attacker to execute code or to
    elevate privileges in order to interfere with other components of the multilayer
    Secure Boot scheme. Alex Matrosov’s “Betraying the BIOS: Where the Guardians of
    the BIOS Are Failing” (*[https://www.youtube.com/watch?v=Dfl2JI2eLc8](https://www.youtube.com/watch?v=Dfl2JI2eLc8)*),
    presented at Black Hat USA 2017, revealed that an attacker could successfully
    target the scheme by interfering with the bit flags set by the lower levels to
    pass the information about their state of integrity to the upper levels.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: As has been demonstrated, firmware cannot be trusted because most SMM attacks
    can compromise it. Even the Measured Boot scheme, which relies on the TPM as its
    root of trust, can be compromised, because the measuring code itself runs in SMM
    and can in many cases be modified from the SMM, even though the key stored in
    the TPM hardware cannot be changed by SMM. Although some attacks on the TPM chip
    are possible, the SMM privilege–wielding attackers do not need them, as they would
    simply attack the firmware’s interfaces to the TPM. In 2013 Intel introduced Verified
    Boot, which we just mentioned, to address this Measured Boot weakness.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The Boot Guard ACM verification logic measures the *initial boot block (IBB)*
    and checks its integrity before passing control to the IBB entry point. If IBB
    verification fails, the boot process will generally be interrupted depending on
    the policy. The IBB part of the UEFI firmware (BIOS) executes on a normal CPU
    (not isolated or authenticated). Next, IBB continues the boot process, following
    the Boot Guard policies in the verified or measured mode to the platform initialization
    phase. The PEI driver verifies the integrity of the DXE drivers and transitions
    the chain of trust to the DXE phase. The DXE phase then continues the chain of
    trust to the operating system bootloader. [Table 16-2](ch16.xhtml#ch16tab02) presents
    research data about the state of security in each of these stages across various
    hardware vendors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-2:** How Different Hardware Vendors Configure Security (as of January
    2018)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '| **Vendor name** | **ME access** | **EC access** | **CPU debugging (DCI)**
    | **Boot Guard** | **Forced Boot Guard ACM** | **Boot Guard FPF** | **BIOS Guard**
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| **ASUS VivoMini** | Disabled | Disabled | Enabled | Disabled | Disabled |
    Disabled | Disabled |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| **MSI Cubi2** | Disabled | Disabled | Enabled | Disabled | Disabled | Disabled
    | Disabled |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| **Gigabyte Brix** | Read/write enabled | Read/write enabled | Enabled | Measured
    verified | Enabled (FPF not set) | Not set | Disabled |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| **Dell** | Disabled | Disabled | Enabled | Measured verified | Enabled |
    Enabled | Enabled |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| **Lenovo ThinkCenter** | Disabled | Disabled | Enabled | Disabled | Disabled
    | Disabled | Disabled |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| **HP Elitedesk** | Disabled | Disabled | Enabled | Disabled | Disabled |
    Disabled | Disabled |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| **Intel NUC** | Disabled | Disabled | Enabled | Disabled | Disabled | Disabled
    | Disabled |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| **Apple** | Read enabled | Disabled | Disabled | Not supported | Not supported
    | Not supported | Not supported |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: As you can see, catastrophic misconfigurations of these security options are
    not merely theoretical. For example, some vendors have not written their hashes
    in the FPF, or did so but didn’t subsequently disable the manufacturing mode that
    allows such a write. As a result, the attackers can write FPF keys of their own
    and then lock the system, tying it forever to their own root and chain of trust
    (though if the hardware manufacturer has developed a revocation process, a fuse
    overwrite for revocation exists). More precisely, the FPF can be written by the
    ME as its memory regions when the ME is still in the manufacturing mode; the ME
    in that mode, in turn, can be accessed from the OS for both reads and writes.
    In this way, the attacker really gets the keys to the kingdom.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, most of the researched Intel-based hardware had CPU debugging
    enabled, so all the doors were open to attackers with physical access to the CPU.
    Some of the platforms included support for the Intel BIOS Guard technology, but
    it was disabled in the manufacturing process to simplify BIOS updates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Thus, [Table 16-2](ch16.xhtml#ch16tab02) provides multiple excellent examples
    of supply chain security problems, wherein the vendors trying to simplify supporting
    hardware have created critical security holes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities in the SMM Modules**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now look at another vector for exploiting UEFI firmware from the OS:
    leveraging mistakes in the SMM modules.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding SMM***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve discussed SMM and SMI handlers in previous chapters, but we’ll review
    both concepts now as a refresher.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: SMM is a highly privileged execution mode of x86 processors. It was designed
    to implement platform-specific management functions independently of the OS. These
    functions include advanced power management, secure firmware updates, and configuration
    of UEFI Secure Boot variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The key design feature of SMM is that it provides a separate execution environment,
    invisible to the OS. The code and data used in SMM are stored in a hardware-protected
    memory region, called *SMRAM*, that is accessible only to code running within
    SMM. To enter SMM, the CPU generates a System Management Interrupt (SMI), a special
    interrupt intended to be raised by the OS software.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '*SMI handlers* are the platform firmware’s privileged services and functions.
    The SMI serves as a bridge between the OS and these SMI handlers. Once all the
    necessary code and data have been loaded in SMRAM, the firmware locks the memory
    region so that it can be accessed only by code running in SMM, preventing the
    OS from accessing it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploiting SMI Handlers***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given SMM’s high privilege level, SMI handlers present a very interesting target
    for implants and rootkits. Any vulnerability in these handlers may present an
    opportunity for the attacker to elevate privileges to that of the SMM, the so-called
    Ring –2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: As with other multilayer models, such as the kernel-userland separation, the
    best way to attack the privileged code is to target any data that can be consumed
    from outside the isolated privileged memory region. For SMM, this is any memory
    outside the SMRAM. For SMM’s security model, the attacker is the OS or privileged
    software (such as BIOS update tools); thus, any location in the OS that is outside
    the SMRAM is suspect because it can at times be manipulated by an attacker (potentially
    even after it has been somehow checked). Potential targets include function pointers
    consumed by the SMM code that can point execution to areas outside SMRAM or any
    buffers with data that SMM code reads/parses.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, UEFI firmware developers try to reduce this attack surface by minimizing
    the number of SMI handlers communicating directly with the outside world (Ring
    0—the kernel mode of the operating system), as well as by finding new ways to
    structure and check these interactions. But this work has only just started, and
    security problems with SMI handlers will likely persist for quite some time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the code in SMM can receive some data from the OS to be useful. However,
    in order to remain secure, just as with other multilayer models, the SMM code
    must never act on the outside data unless it’s been copied and checked inside
    the SMRAM. Any data that’s been checked but left outside the SMRAM can’t be trusted,
    as the attacker could potentially race to change it between the point of check
    and the point of use. Moreover, any data that has been copied in shouldn’t reference
    any unchecked and uncopied outside data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: This sounds simple, but languages like C don’t natively help track the regions
    to which pointers point, and thus the all-important security distinction between
    the “inside” SMRAM memory locations and the “outside,” attacker-controlled, OS
    memory is not necessarily evident in the code. So the programmers are mostly on
    their own. (If you’re wondering how much of this problem can be solved with static
    analysis tools, read on—as it turns out, the SMI calling convention we discuss
    next makes it quite a challenge.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: To understand how attackers can exploit SMI handlers, you need to understand
    their calling convention. Although, as [Listing 16-2](ch16.xhtml#ch16list02) shows,
    calls to the SMI handler from the Python side of the Chipsec framework look like
    regular function calls, the actual binary calling convention, shown in [Listing
    16-3](ch16.xhtml#ch16list03), is different.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 16-2: How to call an SMI handler from Python with the Chipsec framework*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 16-2](ch16.xhtml#ch16list02) calls the SMI handler with
    all the parameters zeroed out except for 0x25, the number of the called handler.
    Such a call may indeed pass no parameters, but it’s also possible that the SMI
    handler retrieves these parameters indirectly—via ACPI or UEFI variables, for
    example—once it gets control. When the operating system triggers SMI (for instance,
    as a software interrupt via I/O port 0xB2), it passes arguments to the SMI handler
    via general-purpose registers. In [Listing 16-3](ch16.xhtml#ch16list03), you can
    see what an actual call to the SMI handler looks like in assembly and how the
    parameters are passed. The Chipsec framework, of course, implements this calling
    convention under the hood.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 16-3: An SMI handler call in assembly language*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**SMI Callout Issues and Arbitrary Code Execution**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Most common SMI handler vulnerabilities of interest for BIOS implants fall
    into two major groups: SMI callout issues and arbitrary code execution (which,
    in many cases, is preceded by SMI callout issues). In SMI callout issues, SMM
    code unwittingly uses a function pointer, controlled by the attacker, that points
    at an implant payload outside the SMM. In arbitrary code execution, SMM code consumes
    some data from outside SMRAM that is capable of affecting the control flow and
    can be leveraged for more control. Such addresses are typically below the first
    megabyte of physical memory, as SMI handlers expect to use that memory range,
    which is unused by the OS. In SMI callout issues, when an attacker can overwrite
    the address of an indirect jump or a function pointer that is called from SMM,
    then arbitrary code under the attacker’s control will be executed outside of SMM,
    but with the privileges of SMM (a good example of such an attack is VU#631788).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In the newer versions of the BIOS from major enterprise vendors, such vulnerabilities
    are harder to find, but issues with accessing pointers outside the SMRAM range
    remain, despite the introduction of the standard function `SmmIsBufferOutsideSmmValid()`
    to check whether a pointer to a memory buffer is in that range. The implementation
    of this generic check was introduced in the Intel EDK2 repository on GitHub (*[https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c](https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c)*),
    and its declaration is shown in [Listing 16-4](ch16.xhtml#ch16list04).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 16-4: Prototype of the function `SmmIsBufferOutsideSmmValid()` from
    Intel EDK2*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SmmIsBufferOutsideSmmValid()` function accurately detects pointers to
    memory buffers outside the SMRAM range, with one exception: it’s possible for
    the `Buffer` argument to be a structure and for one of the fields of this structure
    to be a pointer to another buffer outside SMRAM. If the security check happens
    only for the address of the structure itself, SMM code may still be vulnerable,
    despite a check with `SmmIsBufferOutsideSmmValid()`. Thus, SMI handlers have to
    validate each address or pointer—including offsets!—that they receive from the
    OS prior to reading from or writing to such memory locations. Importantly, this
    includes returning status and error codes. Any type of arithmetic calculation
    that happens inside SMM should validate any parameters coming from outside of
    SMM or less privileged modes.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**SMI Handler Exploitation Case Studies**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we’ve discussed the perils of SMI handlers taking data from the OS,
    it’s time to dig into a real case of SMI handler exploitation. We’ll look at the
    common workflow of a UEFI firmware update process used by Windows 10, among other
    operating systems. In this situation, the firmware is validated and authenticated
    inside SMM with weak DXE runtime drivers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-5](ch16.xhtml#ch16fig05) shows a high-level picture of the BIOS
    update process in this scenario.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/16fig05.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-5: High-level representation of the BIOS update process from the
    OS*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the userland BIOS update tool (Update App) communicates with
    its kernel-mode driver (Update Driver), which usually has direct access to the
    physical memory device over the Ring 0 API function `MmMapIoSpace()`. This access
    allows potential attackers to modify or map malicious data to the memory regions
    used to communicate with the SMI handler BIOS (SmiFlash or SecSmiFlash) update
    parsers. Usually, the parsing flow is complex enough to leave room for vulnerabilities,
    especially when the parsers are written in C, as they typically are. The attacker
    crafts a malicious data buffer and calls a vulnerable SMI handler by its number,
    as shown in [Listing 16-3](ch16.xhtml#ch16list03), using `__outbyte()` intrinsic
    functions available in the MS Visual C++ compiler.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The DXE drivers shown in [Figure 16-5](ch16.xhtml#ch16fig05), SmiFlash and SecSmiFlash,
    are found across many SMM codebases. SmiFlash flashes a BIOS image without any
    authentication. Using an update tool based on this driver, the attacker can simply
    flash a maliciously modified BIOS update image without further ado (a good example
    of this type of vulnerability is VU#507496, found by Alex Matrosov). SecSmiFlash,
    by contrast, can authenticate the update by checking its digital signature, blocking
    this kind of attack.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities in the S3 Boot Script**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll give you an overview of vulnerabilities in the S3 Boot
    Script, the script that the BIOS uses to wake from sleep mode. Although the S3
    Boot Script speeds up the waking process, incorrect implementations of it can
    have serious security impacts, as we’ll explore here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding the S3 Boot Script***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The power transition states of modern hardware—such as working mode and sleep
    mode—are very complex and involve multiple DRAM manipulation stages. During sleep
    mode, or S3, DRAM is kept powered, although the CPU is not. When the system wakes
    from the sleep state, the BIOS restores the platform configuration, including
    the contents of the DRAM, and then transfers control to the operating system.
    You can find a good summary of these states in *[https://docs.microsoft.com/en-us/windows/desktop/power/system-power-states/](https://docs.microsoft.com/en-us/windows/desktop/power/system-power-states/).*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The S3 boot script is stored in DRAM, preserved across the S3 state, and executed
    when resuming full function from S3\. Although called a “script,” it is really
    a series of opcodes interpreted by the Boot Script Executor firmware module (*[https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/BootScriptExecute.c](https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/BootScriptExecute.c)*).
    The Boot Script Executor replays every operation defined by these opcodes at the
    end of the PEI phase to restore the configuration of the platform hardware and
    the entire preboot state for the OS. After executing the S3 boot script, the BIOS
    locates and executes the OS waking vector to restore its software execution to
    the state it was in when it left off. This means the S3 boot script allows the
    platform to skip the DXE phase and reduces the time it takes to wake from the
    S3 sleep state. Yet this optimization comes with some risks, as we’ll discuss
    next.^([2](footnotes.xhtml#ch16fn2))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '***Targeting Weaknesses of the S3 Boot Script***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An S3 boot script is just another kind of program code stored in memory. An
    attacker who can gain access to it and alter the code can either add surreptitious
    actions to the boot script itself (staying within the S3 programming model so
    as not to ring alarm bells) or, if this doesn’t suffice, exploit the boot script’s
    interpreter by going beyond the opcodes’ intended functionality.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The S3 boot script has access to input/output (I/O) ports for read and write,
    PCI configuration read and write, direct access to the physical memory with read
    and write privileges, and other data that is critical for the platform’s security.
    Notably, an S3 boot script can attack a hypervisor to disclose otherwise isolated
    memory regions. All of this means that a rogue S3 script will have an impact similar
    to a code execution vulnerability inside the SMM, discussed earlier in this chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: As S3 scripts are executed early in the wake process, before various security
    measures are activated, the attacker can use them to bypass some security hardware
    configurations that would normally take effect during the boot process. Indeed,
    by design, most of the S3 boot script opcodes cause the system firmware to restore
    the contents of various hardware configuration registers. For the most part, this
    process isn’t any different from writing to these registers during the operating
    system runtime, except that write access is allowed for the S3 script but disallowed
    for the operating system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Attackers can target the S3 boot script by altering a data structure called
    the *UEFI boot script table*, which saves the platform state during the Advanced
    Configuration and Power Interface (ACPI) specification’s S3 sleep stage, when
    most of the platform’s components are powered off. UEFI code constructs a boot
    script table during normal boot and interprets its entries during an S3 resumption,
    when the platform is waking up from sleep. Attackers able to modify the current
    boot script table’s contents from the OS kernel mode and then trigger an S3 suspend-resume
    cycle can achieve arbitrary code execution at the early platform wake stage, when
    some of security features are not yet initialized or locked in the memory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**DISCOVERY OF THE S3 BOOT SCRIPT VULNERABILITY**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The first researchers to publicly describe the malicious behavior of an S3 boot
    script were Rafal Wojtczuk and Corey Kallenberg. In their December 2014 presentation
    “Attacks on UEFI Security, Inspired by Darth Venamis’s Misery and *Speed Racer*”
    (*[https://bit.ly/2ucc2vU](https://bit.ly/2ucc2vU)*) at the 31st Chaos Communication
    Congress (31C3), they revealed the S3-related vulnerability CVE-2014-8274 (VU#976132).
    A few weeks later, security researcher Dmytro Oleksiuk (also known as Cr4sh) released
    the first proof-of-concept exploit for this vulnerability. The PoC’s release triggered
    multiple discoveries by other researchers. A few months later, Pedro Vilaca found
    multiple related problems in Apple products based on UEFI firmware. Researchers
    at the Intel Advanced Threat Research group also highlighted several potential
    S3 attacks in virtualization security in their talk “Attacking Hypervisors via
    Firmware and Hardware” (*[https://www.youtube.com/watch?v=nyW3eTobXAI](https://www.youtube.com/watch?v=nyW3eTobXAI)*),
    presented at Black Hat Vegas in 2015\. If you want to know more about the S3 boot
    script vulnerabilities, we recommend looking at some of these presentations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploiting the S3 Boot Script Vulnerability***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The impact of an S3 boot script exploit is clearly huge. But how exactly does
    the attack work? First, the attacker must already have code execution in the kernel
    mode (Ring 0) of the operating system, as [Figure 16-6](ch16.xhtml#ch16fig06)
    shows.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/16fig06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-6: Step-by-step exploitation of an S3 boot script*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig into each step of this exploit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial reconnaissance.** During the reconnaissance phase, an attacker must
    get the S3 boot script pointer (address) from the UEFI variable `AcpiGlobalVariable`,
    which points to the boot script location in unprotected DRAM memory. Then they
    must copy the original boot script into a memory location so they can restore
    the original state after exploitation. Finally, they must make sure the system
    is actually affected by the S3 boot script vulnerability by using the modification
    dispatch code `EFI_BOOT_SCRIPT_DISPATCH_OPCODE`, which adds a record into the
    specified boot script table to execute arbitrary code, as shown in [Listing 16-5](ch16.xhtml#ch16list05).
    If the modification of a single S3 opcode is successful, the system is most likely
    vulnerable.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**S3 boot script modification.** To modify the boot script, the attacker inserts
    a malicious dispatch opcode record at the top of the copied boot script to place
    as the first boot script opcode command. They then overwrite the boot script address
    location by setting the `AcpiGlobalVariable` to a pointer to the modified malicious
    version of the boot script.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Payload delivery.** The S3 boot script dispatch code (`EFI_BOOT_SCRIPT_DISPATCH_OPCODE`)
    should now point to the malicious shellcode. The content of the payload depends
    on the attacker’s target. It could serve multiple purposes, including bypassing
    SMM memory protection or executing additional shellcode stages mapped separately
    elsewhere in memory.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Vulnerability trigger.** The malicious boot script is executed right after
    the attacked machine returns from sleep mode. To trigger an exploit, either the
    user or additional malicious code inside the OS would have to activate S3 sleep
    mode. After the boot script starts execution, it jumps to the entry point address
    defined by the dispatch code—where the malicious shellcode receives control.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 16-5](ch16.xhtml#ch16list05) lists all S3 boot script opcodes documented
    by Intel, including the highlighted `EFI_BOOT_SCRIPT_DISPATCH_OPCODE`, which executes
    the malicious shellcode.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 16-5: S3 Boot Script dispatch opcodes*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: You can find a reference implementation of the S3 boot script developed by Intel
    in the EDKII repository on GitHub (*[https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/](https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/)*).
    This code is useful for understanding both the internals of the S3 boot script
    behavior on x86 systems and the mitigations implemented to prevent the vulnerability
    we just discussed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: To check whether a system is affected by the S3 boot script vulnerability, you
    can use Chipsec’s S3 Boot Script tool (*chipsec/modules/common/uefi/s3bootscript.py*).
    You can’t use this tool to exploit the vulnerability, however.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You could, however, use Dmytro Oleksiuk’s PoC of the exploit published on GitHub
    (*[https://github.com/Cr4sh/UEFI_boot_script_expl/](https://github.com/Cr4sh/UEFI_boot_script_expl/)*)
    to deliver a payload. [Listing 16-6](ch16.xhtml#ch16list06) shows the successful
    result of this PoC exploitation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 16-6: The result of successful S3 boot script exploitation*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'This vulnerability and its exploit are also useful for disabling some of the
    BIOS protection bits, such as BIOS Lock Enabled, BIOS Write Protection, and some
    others configured in the FLOCKDN (Flash Lock-Down) register. Importantly, an S3
    exploit can also disable the protected ranges of PRx registers by modifying their
    configuration. Also, as we mentioned before, you can use the S3 vulnerability
    to bypass virtualization memory isolation technologies, such as Intel VT-x. In
    fact, the following S3 opcodes can make direct memory accesses during recovery
    from sleep state:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Those opcodes can write some value to a specified memory location on behalf
    of the UEFI firmware, which makes it possible to attack a guest VM. Even when
    the architecture includes a hypervisor more privileged than the host system, the
    host system can attack it via S3 and, through it, all the guests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***Fixing the S3 Boot Script Vulnerability***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The S3 boot script vulnerability was one of the most impactful security vulnerabilities
    in UEFI firmware. It was easy to exploit and hard to mitigate, since an actual
    fix required multiple firmware architectural changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Mitigating the S3 boot script issue required integrity protection from Ring
    0 modifications. One way to achieve this was to move the S3 boot script to the
    SMRAM (SMM memory range). But there’s another way: in a technique introduced in
    EDKII (*edk2/MdeModulePkg/Library/SmmLockBoxLib*), Intel architects designed a
    LockBox mechanism to protect the S3 boot script from any modifications outside
    of SMM.^([3](footnotes.xhtml#ch16fn3))'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerabilities in the Intel Management Engine**'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Intel Management Engine is interesting for an attacker. This technology
    has tantalized hardware security researchers ever since its inception, because
    it’s both virtually undocumented and extremely powerful. Today, the ME uses a
    separate x86-based CPU (in the past, it used the boutique ARC CPU) and serves
    as the foundation for the Intel hardware root of trust and multiple security technologies
    such as Intel Boot Guard, Intel BIOS Guard, and, partially, Intel Software Guard
    Extension (SGX). Thus, compromising ME provides a way to bypass Secure Boot.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Control of ME is a highly coveted goal for attackers, since ME has all the power
    of SMM but can also execute an embedded real-time OS on a separate 32-bit microcontroller
    that operates totally independently of the main CPU. Let’s look at some of its
    vulnerabilities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '***A History of ME Vulnerabilities***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2009, security researchers Alexander Tereshkin and Rafal Wojtczuk from Invisible
    Things Lab presented their research on abusing ME in their talk, “Introducing
    Ring –3 Rootkits,” presented at the Black Hat USA conference in Las Vegas.^([4](footnotes.xhtml#ch16fn4))
    They shared their discoveries about Intel ME internals and discussed ways of injecting
    code into the Intel AMT execution context—by co-opting ME into a rootkit, for
    example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The next advance in understanding ME vulnerabilities came an entire eight years
    later. Researchers Maxim Goryachy and Mark Ermolov from Positive Technologies
    discovered code execution vulnerabilities in the newer version of ME, present
    in Intel’s sixth, seventh, and eighth generations of CPUs. These vulnerabilities—CVE-2017-5705,
    CVE-2017-5706, and CVE-2017-5707, respectively—allowed an attacker to execute
    arbitrary code inside ME’s operating system context, resulting in a complete compromise
    of the respective platforms at the highest level of privilege. Goryachy and Ermolov
    presented these discoveries in “How to Hack a Turned-Off Computer, or Running
    Unsigned Code in Intel Management Engine” at Black Hat Europe 2017,^([5](footnotes.xhtml#ch16fn5))
    where the researchers showed how rootkit code could bypass or disable multiple
    security features, including Intel’s Boot Guard and BIOS Guard technologies, by
    compromising their root of trust. Whether any security technologies are resilient
    to a compromised ME remains an open research question. Among other capabilities,
    rootkit code that executes in the Intel ME context allows the attacker to modify
    the BIOS image (and, partially, the root of trust of Boot Guard) directly inside
    the SPI flash chip and thus to bypass most security features.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '***ME Code Attacks***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though ME code executes on its own chip, it communicates with other layers
    of the OS and can be attacked via these communications. As always, the communication
    boundary is a part of any computational environment’s attack surface, no matter
    how isolated the environment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Intel created a special interface, called the *Host-Embedded Controller Interface
    (HECI)*, so ME applications could communicate with the operating system kernel.
    This interface could be used, for example, to remotely manage a system via a network
    connection terminating at the ME but capable of capturing the operating system
    GUI (via VNC, for example) or for operating system–aided configuration of the
    platform during the manufacturing process. It could also be used to implement
    Intel vPro enterprise management services, including AMT (which we discuss in
    the next section).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Typically, UEFI firmware initializes HECI via a proxy SMM driver, `HeciInitDxe`,
    located inside the BIOS. This SMM driver passes messages between ME and the host
    OS vendor-specific driver over the PCH bridge, which connects the CPU and the
    ME chip.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Applications running inside the ME can register HECI handlers to accept communication
    from the host operating system (the ME should not trust any input from the OS).
    If the OS kernel is taken over by an attacker, these interfaces become a part
    of the ME’s attack surface; for example, an overly trusting parser inside an ME
    application that does not fully validate messages coming from the OS side could
    be compromised by a crafted message, just as weak network servers are. This is
    why it’s important to reduce the attack surface for ME applications by minimizing
    the number of HECI handlers. Indeed, Apple platforms permanently disable the HECI
    interfaces and minimize the number of their ME applications as a deliberate security
    policy decision. However, one compromised ME application doesn’t mean the entire
    ME is compromised.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '***Case Studies: Attacks on Intel AMT and BMC***'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s now consider vulnerabilities in two technologies that use the ME. To manage
    large data centers, as well as massive enterprise workstation inventories that
    must be centrally managed, organizations often use technologies that embed the
    management endpoint and logic into a platform’s main board. This allows them to
    control the platform remotely, even when the platform’s main CPU isn’t running.
    These technologies, which include Intel’s AMT and various baseboard management
    controller (BMC) chips, have inevitably become a part of their platforms’ attack
    surface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: A full discussion of attacks on AMT and BMCs is outside the scope of this chapter.
    However, we still want to provide some pointers, since exploitation of these technologies
    is directly tied to UEFI vulnerabilities and has gotten a lot of attention lately,
    due to high-impact Intel AMT and BMC vulnerabilities revealed in 2017 and 2018\.
    We’ll discuss these vulnerabilities next.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**AMT Vulnerabilities**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Intel’s AMT platform is implemented as an ME application and so directly relates
    to the Intel ME execution environment. AMT leverages the ME’s ability to communicate
    with a platform over a network even when the main CPU is not active or is completely
    powered down. It also uses the ME to read and write DRAM at runtime, independently
    of the main CPU. AMT is an archetypical example of an ME firmware application
    that is intended to be updated via the BIOS update mechanism. For this purpose,
    Intel AMT runs its own web server, used as the main entry point for an enterprise
    remote management console.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In 2017, after nearly two decades of having a clean public security record,
    AMT had its first vulnerability reported—but it was a shocking one, and, given
    its nature, hardly the last one we’ll see! Researchers from Embedi (a private
    security company) alerted Intel about the critical issue CVE-2017-5689 (INTEL-SA-00075),
    which allowed for remote access and authentication bypass. All Intel systems produced
    since 2008 and that support the ME are affected. (This excludes the sizable Intel
    Atom population, which itself did not include the ME, although all of its server
    and workstation products were likely vulnerable if they included vulnerable components
    of the ME. Officially, only Intel vPro systems have AMT.) The scope of this vulnerability
    is pretty interesting, as it mostly affected systems designed to be accessed via
    a remote AMT management console even when turned off—meaning that the system could
    also be *attacked* when turned off.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Typically, AMT was marketed as a part of the Intel vPro technology, but in the
    same presentation, Embedi researchers demonstrated that AMT could be enabled for
    non-vPro systems. They released the AMTactivator tool, which an operating system
    administrator could run to activate AMT even when it was not officially a part
    of the platform. The researchers showed that AMT was a part of all current Intel
    CPUs powered by the ME, no matter whether they were marketed as vPro-enabled or
    not; in the latter case, AMT was still present and could be activated, for good
    or bad. More details about this vulnerability can be found at *[https://www.blackhat.com/docs/us-17/thursday/us-17-Evdokimov-Intel-AMT-Stealth-Breakthrough-wp.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Evdokimov-Intel-AMT-Stealth-Breakthrough-wp.pdf)*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Intel has deliberately disclosed very little information regarding AMT, creating
    considerable difficulties for anyone outside of Intel attempting to research the
    security failings of this technology. However, advanced attackers took the challenge
    and made significant progress in analyzing AMT’s hidden possibilities. Further
    nasty surprises for defenders may follow.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**THE PLATINUM APT ROOTKIT**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Not directly related to Intel AMT firmware but also interesting is the fact
    that the so-called *PLATINUM APT* actor used AMT’s Serial-over-LAN (SOL) channel
    for network communications. This rootkit was discovered by Microsoft’s Windows
    Defender Research group in the summer of 2017\. AMT SOL’s communications worked
    independently of the operating system and so were invisible to the OS-level firewall
    and network monitoring applications running on the host device. Until this incident,
    no malware had been known to abuse the AMT SOL feature as a covert communication
    channel. For additional details, check out the original paper and blog post released
    by Microsoft (*[https://cloudblogs.microsoft.com/microsoftsecure/2017/06/07/platinum-continues-to-evolve-find-ways-to-maintain-invisibility/](https://cloudblogs.microsoft.com/microsoftsecure/2017/06/07/platinum-continues-to-evolve-find-ways-to-maintain-invisibility/)*).
    The existence of this channel was discovered by LegbaCore researchers, who disclosed
    it before it was discovered in the wild (*[http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full.pdf](http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full.pdf)*).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**BMC Chip Vulnerabilities**'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At the same time that Intel was developing vPro offerings powered by the AMT
    platform’s ME execution environments, other vendors were busy developing competing
    centralized remote management solutions for servers: BMC chips integrated into
    the servers. As products of this parallel evolution, BMC designs have a lot of
    the same weaknesses as AMT.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Commonly found in server hardware, BMC deployments are ubiquitous in data centers.
    Major hardware vendors like Intel, Dell, and HP have their own BMC implementations,
    based primarily on ARM microcontrollers with integrated network interfaces and
    flash storage. This dedicated flash storage contains a real-time OS (RTOS) that
    powers a number of applications, such as a web server listening on the BMC chip’s
    network interface (a separate network management interface).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve been reading attentively, this should scream “attack surface!” Indeed,
    a BMC’s embedded web server is typically written in C (including CGI) and is thus
    a prime target for attackers in the market for input-handling vulnerabilities.
    A good example of such a vulnerability is HP iLO BMC’s CVE-2017-12542, which allowed
    an authentication bypass and remote code execution in the respective BMC’s web
    server. This security issue was discovered by Airbus researchers Fabien Périgaud,
    Alexandre Gazet, and Joffrey Czarny. We highly recommend their detailed whitepaper
    “Subverting Your Server Through Its BMC: The HPE iLO4 Case” (*[https://bit.ly/2HxeCUS](https://bit.ly/2HxeCUS)*).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: BMC vulnerabilities underscore the fact that, no matter what hardware separation
    techniques you employ, the overall measure of a platform’s attack surface is its
    communication boundary. The more functionality you expose at this boundary, the
    greater the risk to the platform’s overall security. A platform may feature a
    separate CPU with a separate firmware running on it, but if this firmware includes
    a rich target, such as a web server, the attacker can leverage the platform’s
    weaknesses to install an implant. For example, a BMC-based firmware update process
    that does not authenticate over-the-network update images is just as vulnerable
    as any security-through-obscurity software installation scheme.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trustworthiness of UEFI firmware and other system firmware for x86-based
    platforms is a hot topic today, worthy of an entire book of its own. In a sense,
    UEFI was meant to reinvent the BIOS, but it did so with all the failings of security-by-obscurity
    approaches of the legacy BIOS, plus a lot more.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We made some hard decisions about which vulnerabilities to include here and
    which to give more detailed coverage to in order to illustrate the larger architectural
    failings. In the end, we hope that this chapter has covered just enough background
    to give you a deeper understanding of the current state of UEFI firmware security
    through the prism of common design flaws, rather than merely regaling you with
    a hodgepodge of infamous vulnerabilities.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays UEFI firmware is the cornerstone of platform security, despite being
    universally neglected by vendors a few years ago. The collaborative effort of
    the security research community made this change possible—and we hope that our
    book gives it its due and helps further its progress.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
