<html><head></head><body>
<section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<span aria-label="167" epub:type="pagebreak" id="pg_167" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch8">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">INPUT/OUTPUT</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">This chapter will teach you how to perform input/output (I/O) operations to read data from, or write data to, terminals and filesystems. Information can enter a program via command line arguments or the environment and exit it via its return status. However, most information typically enters or exits a program through I/O operations. We’ll cover techniques that use C standard streams and POSIX file descriptors. We’ll start by discussing C standard text and binary streams. We’ll then cover different ways of opening and closing files using C standard library and POSIX functions.</p>
<p class="TX">Next, we’ll discuss reading and writing characters and lines, reading and writing formatted text, and reading from and writing to binary <span aria-label="168" epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/>streams. We’ll also cover stream buffering, stream orientation, and file positioning.</p>
<p class="TX">Many other devices and I/O interfaces (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ioctl</samp>) are available but are beyond the scope of this book.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-67"/><samp class="SANS_Futura_Std_Bold_B_11">Standard I/O Streams</samp></h2>
<p class="TNI">C provides streams to communicate with files stored on supported, structured storage devices and terminals. A <i>stream</i> is a uniform abstraction for communicating with files and devices that consume or produce sequential data such as sockets, keyboards, Universal Serial Bus (USB) ports, and printers.</p>
<p class="TX">C uses the opaque <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> data type to represent streams. A <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> object holds the internal state information for the connection to the associated file, including the file position indicator, buffering information, an error indicator, and an end-of-file indicator. You should never allocate a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> object yourself. C standard library functions operate on objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE *</samp> (that is, a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> type). As a result, streams are frequently referred to as <i>file pointers</i>.</p>
<p class="TX">C provides an extensive application programming interface (API), found in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp>, for operating on streams; we’ll explore this API later in this chapter. However, because these I/O functions need to work with a wide variety of devices and filesystems across many platforms, they’re highly abstracted, which makes them unsuitable for anything beyond the simplest applications.</p>
<p class="TX">For example, the C standard has no concept of directories, because it must be able to work with nonhierarchical filesystems. The C standard makes few references to filesystem-specific details, like file permissions or locking. However, function specifications frequently state that certain behaviors happen “to the extent that the underlying system supports it,” meaning that they will occur only if they’re supported by your implementation.</p>
<p class="TX">As a result, you’ll generally need to use the less portable APIs provided by POSIX, Windows, and other platforms to perform I/O in real-world applications. Frequently, applications will define their own APIs that, in turn, rely on platform-specific APIs to provide safe, secure, and portable I/O operations.</p>
<section aria-labelledby="sec2" epub:type="division">

<h3 class="H2" id="sec2"><span id="h2-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Error and End-of-File Indicators</samp></h3>
<p class="TNI">As just mentioned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> object holds the internal state information for the connection to the associated file, including an error indicator that records whether a read/write error has occurred and an end-of-file indicator that records whether the end of the file has been reached. When opened, the error and end-of-file indicators for the stream are cleared. The following C standard library functions all set the error indicator for the stream when an error occurs: the byte input functions (<samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>), byte output functions (<samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>), <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>. Input <span aria-label="169" epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/>functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> will also set the end-of-file indicator for the stream if the stream is at end-of-file. Certain functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">freopen</samp> clear the error indicator for the stream, and functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">freopen</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ungetc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> clear the end-of-file indicator for the stream. The wide character I/O functions behave similarly.</p>
<p class="TX">These indicators may be tested and cleared explicitly:</p>
<ul class="ul">
<li class="ListBullet">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ferror</samp> function tests the error indicator for the specified stream and returns nonzero if and only if the error indicator is set for the specified stream.</li>
<li class="ListBullet">The <samp class="SANS_TheSansMonoCd_W5Regular_11">feof</samp> function tests the end-of-file indicator for the specified stream and returns nonzero if and only if the end-of-file indicator is set for the specified stream.</li>
<li class="ListBullet">The <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp> function clears the end-of-file and error indicators for the specified stream.</li>
</ul>
<p class="TX">The following short program illustrates the interaction between these functions and the two indicators:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int main() {
  FILE* tmp = tmpfile();
  fputs("Effective C\n", tmp);
  rewind(tmp);
  for (int c; (c = fgetc(tmp)) != EOF; putchar(c)) {}
  printf("%s", "End-of-file indicator ");
  puts(feof(tmp) ? "set" : "clear");
  printf("%s", "Error indicator ");
  puts(ferror(tmp) ? "set" : "clear");
  clearerr(tmp); // clear both indicators
  printf("%s", "End-of-file indicator ");
  puts(feof(tmp) ? "set" : "clear");
}</code></pre>
<p class="TX">This program produces the following output on <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>:</p>

<pre><code>Effective C
End-of-file indicator set
Error indicator clear
End-of-file indicator clear</code></pre>
<p class="TX">The loop terminates by end-of-file, after which the end-of-file indicator is set. Both indicators are cleared by the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp> function.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2" id="sec3"><span id="h2-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stream Buffering</samp></h3>
<p class="TNI"><i>Buffering</i> is the process of temporarily storing data in memory that’s passing between a process and a device or file. Buffering improves the throughput of I/O operations, which often have high latencies per individual I/O <span aria-label="170" epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>operation with the system. Similarly, when a program requests to write to block-oriented devices like disks, the driver can cache the data in memory until it has accumulated enough data for one or more device blocks, at which point it writes the data all at once to the disk, improving throughput. This strategy is called <i>flushing</i> the output buffer.</p>
<p class="TX">A stream can be in one of three states:</p>
<p class="RunInPara1"><b>Unbuffered</b> Characters are intended to appear from the source or at the destination as soon as possible. Streams where more than one program may be accessing the data concurrently are often best unbuffered. Streams used for error reporting or logging might be unbuffered.</p>
<p class="RunInPara"><b>Fully buffered</b> Characters are intended to be transmitted to or from the host environment as a block when a buffer is filled. Streams used for file I/O are normally fully buffered to optimize throughput.</p>
<p class="RunInPara2"><b>Line buffered</b> Characters are intended to be transmitted to or from the host environment as a block when a newline character is encountered. Streams connected to interactive devices such as terminals are line-buffered when you open them.</p>
<p class="TX">In the next section, we’ll introduce predefined streams and describe how they’re buffered.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h3 class="H2" id="sec4"><span id="h2-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Predefined Streams</samp></h3>
<p class="TNI">A C program has three <i>predefined text streams</i> open and available for use on startup. These predefined streams are declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp>:</p>

<pre><code>extern FILE * stdin;  // standard input stream
extern FILE * stdout; // standard output stream
extern FILE * stderr; // standard error stream</code></pre>
<p class="TX">The <i>standard output stream</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>) is the conventional output destination from the program. This stream is usually associated with the terminal that initiated the program but can be redirected to a file or other stream. You can enter the following commands in a Linux or Unix shell:</p>

<pre><code>$ <b>echo fred</b>
fred
$ <b>echo fred &gt; tempfile</b>
$ <b>cat tempfile</b>
fred</code></pre>
<p class="TX">Here, the output from the <samp class="SANS_TheSansMonoCd_W5Regular_11">echo</samp> command is redirected to <i>tempfile</i>.</p>
<p class="TX">The <i>standard input stream</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>) is the conventional input source for the program. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> is associated with the keyboard but may be redirected to input from a file, for example, with the following commands:</p>

<pre><code>$ <b>echo "one two three four five six seven" &gt; tempfile</b>
$ <b>wc &lt; tempfile</b>
1 7 34</code></pre>
<p class="TX"><span aria-label="171" epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/>The contents of the file <i>tempfile</i> are redirected to the <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> command, which outputs the newline (1), word (7), and byte (34) counts from <i>tempfile.</i> The <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> streams are fully buffered if and only if the stream doesn’t refer to an interactive device.</p>
<p class="TX">The <i>standard error stream</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>) is for writing diagnostic output. The <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp> stream isn’t fully buffered so that error messages can be viewed as soon as possible.</p>
<p class="TX"><a href="chapter8.xhtml#fig8-1">Figure 8-1</a> shows the predefined streams <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp> attached to the keyboard and display of the user’s terminal.</p>
<figure class="IMG"><img alt="" class="img7" id="fig8-1" src="../images/f08001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Standard streams attached to I/O communication channels</samp></p></figcaption>
</figure>
<p class="TX">The output stream of one program can be redirected to be another application’s input stream by using POSIX pipes:</p>

<pre><code>$ <b>echo "Hello Robert" | sed "s/Hello/Hi/" | sed "s/Robert/robot/"</b>
Hi robot</code></pre>
<p class="TX">The stream editor <samp class="SANS_TheSansMonoCd_W5Regular_11">sed</samp> is a Unix utility used for filtering and transforming text. The vertical bar character (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>) is available on many platforms to chain commands.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">

<h3 class="H2" id="sec5"><span id="h2-98"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stream Orientation</samp></h3>
<p class="TNI">Each stream has an <i>orientation</i> that indicates whether the stream contains narrow or wide characters. After a stream is associated with an external file, but before any operations are performed on it, the stream doesn’t have an orientation. Once a wide-character I/O function has been applied to a stream without orientation, the stream becomes a <i>wide-oriented stream</i>. Similarly, once a byte I/O function has been applied to a stream without orientation, the stream becomes a <i>byte-oriented stream</i>. Multibyte character sequences or narrow characters that can be represented as an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> (which are required by the C standard to be 1 byte) can be written to a byte-oriented stream.</p>
<p class="TX">You can reset the orientation of a stream by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">fwide</samp> function or by closing and then reopening the file. Applying a byte I/O function to a wide-oriented stream or a wide-character I/O function to a byte-oriented stream results in undefined behavior. Never mix narrow-character data, wide-character data, and binary data in the same file.</p>
<p class="TX">All three predefined streams (<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>) are unoriented at program startup.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="172" epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>
<h3 class="H2" id="sec6"><span id="h2-99"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Text and Binary Streams</samp></h3>
<p class="TNI">The C standard supports both text streams and binary streams. A <i>text stream</i> is an ordered sequence of characters composed into lines, each of which consists of zero or more characters plus a terminating newline character sequence. You can denote a single line break on a Unix-like system by using a line feed (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>). Most Microsoft Windows programs use a carriage return (<samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>) followed by a line feed (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>).</p>
<p class="TX">The different newline conventions can cause text files that have been transferred between systems with different conventions to display or parse incorrectly, though this is increasingly uncommon on recent systems that now understand foreign newline conventions.</p>
<p class="TX">A <i>binary stream</i> is an ordered sequence of arbitrary binary data. Data read in from a binary stream will be the same as data written out earlier to that same stream, under the same implementation. On non-POSIX systems, streams may have an implementation-defined number of null bytes appended to the end of the stream.</p>
<p class="TX">Binary streams are always more capable and more predictable than text streams. However, the easiest way to read or write an ordinary text file that can work with other text-oriented programs is through a text stream.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">

<h2 class="H1" id="sec7"><span id="h1-68"/><samp class="SANS_Futura_Std_Bold_B_11">Opening and Creating Files</samp></h2>
<p class="TNI">When you open or create a file, it’s associated with a stream. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp> and the POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> functions open or create a file.</p>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">fopen</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp> function opens the file whose name is given as a string and pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> and then associates a stream with it:</p>

<pre><code>FILE *fopen(
  const char * restrict filename,
  const char * restrict mode
);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument points to one of the strings shown in <a href="chapter8.xhtml#tab8-1">Table 8-1</a> to determine how to open the file.</p>
<p class="TT" id="tab8-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Valid File Mode Strings</samp></p>
<p class="Anchor"><span aria-label="173" epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Mode string</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Open existing text file for reading</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Truncate to zero length or create text file for writing</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Append, open, or create text file for writing at end-of-file</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">rb</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Open existing binary file for reading</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Truncate file to zero length or create binary file for writing</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ab</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Append, open, or create binary file for writing at end-of-file</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">r+</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Open existing text file for reading and writing</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">w+</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Truncate to zero length or create text file for reading and writing</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a+</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Append, open, or create text file for update, writing at current end-of-file</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">r+b</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">rb+</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Open existing binary file for reading and writing</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">w+b</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">wb+</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Truncate to zero length or create binary file for reading and writing</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a+b</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ab+</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Append, open, or create binary file for update, writing at current end-of-file</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Opening a file with read mode (by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> as the first character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument) fails if the file doesn’t exist or cannot be read.</p>
<p class="TX">Opening a file with append mode (by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> as the first character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument) causes all subsequent writes to the file to occur at the current end-of-file at the point of buffer flush or actual write, regardless of intervening calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> functions. Incrementing the current end-of-file by the amount of data written is atomic with respect to other threads writing to the same file provided the file was also opened in append mode. If the implementation is incapable of incrementing the current end-of-file atomically, it will fail instead of performing nonatomic end-of-file writes. In some implementations, opening a binary file with append mode (by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> as the second or third character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument) may initially set the file position indicator for the stream beyond the last data written because of null character padding.</p>
<p class="TX">You can open a file in update mode by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> as the second or third character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument, allowing both read and write operations to be performed on the associated stream. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations. On POSIX systems, text and binary streams have the exact same behavior.</p>
<p class="TX">The C11 standard added the <i>exclusive mode</i> for reading and writing binary and text files, as shown in <a href="chapter8.xhtml#tab8-2">Table 8-2</a>.</p>
<p class="TT" id="tab8-2"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-2:</samp> <samp class="SANS_Futura_Std_Book_11">Valid File Mode Strings Added by C11</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Mode string</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wx</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Create exclusive text file for writing</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wbx</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Create exclusive binary file for writing</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">w+x</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Create exclusive text file for reading and writing</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">w+bx</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">wb+x</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Create exclusive binary file for reading and writing</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Opening a file with exclusive mode (by passing <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> as the last character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> argument) fails if the file already exists or cannot be created. The <span aria-label="174" epub:type="pagebreak" id="pg_174" role="doc-pagebreak"/>check for the existence of the file and the creation of the file if it doesn’t exist are atomic with respect to other threads and concurrent program executions. If the implementation is incapable of performing the check for the existence of the file and the creation of the file atomically, it fails rather than perform a nonatomic check and creation.</p>
<p class="TX">As a final note, make sure that you never copy a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> object. The following program, for example, can fail because a by-value copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> is being used in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  FILE my_stdout = *stdout;
  if (fputs("Hello, World!\n", &amp;my_stdout) == EOF) {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}</code></pre>
<p class="TX">This program has undefined behavior and typically crashes when run.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h3 class="H2" id="sec9"><span id="h2-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">open</samp></h3>
<p class="TNI">On POSIX systems, the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function (IEEE Std 1003.1:2018) establishes the connection between a file identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> and a value called a <i>file descriptor</i>:</p>

<pre><code>int open(const char *path, int oflag, ...);</code></pre>
<p class="TX">The <i>file descriptor</i> is a nonnegative integer that refers to the structure representing the file (called the <i>open file description</i>). The file descriptor returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function is the lowest numbered unused file descriptor and is unique to the calling process. The file descriptor is used by other I/O functions to refer to that file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function sets the file offset used to mark the current position within the file to the beginning of the file. For a file descriptor underlying a stream, this file offset is separate from the stream’s file position indicator.</p>
<p class="TX">The value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> parameter sets the open file description’s <i>file access modes</i>, which specify whether the file is being opened for reading, writing, or both. Values for <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> are constructed by a bitwise-inclusive OR of a file access mode and any combination of access flags. Applications must specify exactly one of the following file access modes in the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp>:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_EXEC </samp> Open for execute only (nondirectory files)</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_RDONLY </samp>Open for reading only</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_RDWR </samp>Open for reading and writing</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_SEARCH</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11"> </samp>Open directory for search only</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_WRONLY </samp>Open for writing only</p>
<p class="TX"><span aria-label="175" epub:type="pagebreak" id="pg_175" role="doc-pagebreak"/>The value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> parameter also sets the <i>file status flags</i>, which control the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function and affect how file operations are performed. These flags include the following:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_APPEND</samp> Sets the file offset to the end-of-file prior to each write</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_TRUNC</samp> Truncates the length to 0</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_CREAT</samp> Creates a file</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">O_EXCL</samp> Causes the open to fail if <samp class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</samp> is also set and the file exists</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function takes a variable number of arguments. The value of the argument following the <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp> argument specifies the file-mode bits (the file permissions when you create a new file) and is of type <samp class="SANS_TheSansMonoCd_W5Regular_11">mode_t</samp>.</p>
<p class="TX"><a href="chapter8.xhtml#Lis8-1">Listing 8-1</a> shows an example of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function to open a file for writing.</p>
<span id="Lis8-1"/>
<pre><code>#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  int fd;
  int flags = O_WRONLY | O_CREAT | O_TRUNC;
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
  const char *pathname = "/tmp/file";
  if ((fd = open(pathname, flags, mode) <span aria-label="annotation2" class="code_CodeAnnotation">❷</span>) == -1) {
    err(EXIT_FAILURE, "Can't open %s", pathname);
  }
  // <var>--snip--</var>
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: Opening a file as write-only</samp></p>
<p class="TX">The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span> takes multiple arguments, including the pathname of the file, the <samp class="SANS_TheSansMonoCd_W5Regular_11">oflag</samp>, and the mode. We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">mode</samp> flag <span aria-label="annotation1" class="CodeAnnotation">❶</span> that is a bitwise-inclusive OR of the following mode bits for access permission:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IRUSR </samp>Read permission bit for the owner of the file</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IWUSR </samp>Write permission bit for the owner of the file</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IRGRP </samp>Read permission bit for the group owner of the file</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">S_IROTH </samp>Read permission bit for other users</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function sets these permissions only if it creates the file. If the file already exists, its current permissions are kept. The file access mode is <samp class="SANS_TheSansMonoCd_W5Regular_11">O_WRONLY</samp>, which means the file is opened for writing only. The <samp class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</samp> file status flag informs <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> to create the file; the <samp class="SANS_TheSansMonoCd_W5Regular_11">O_TRUNC</samp> file status flag informs <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> that if the file exists and is successfully opened, it should discard the previous contents of the file.</p>
<p class="TX">If the file was successfully opened, the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> function returns a nonnegative integer representing the file descriptor. Otherwise, <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> returns −1 and <span aria-label="176" epub:type="pagebreak" id="pg_176" role="doc-pagebreak"/>sets <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp> to indicate the error. <a href="chapter8.xhtml#Lis8-1">Listing 8-1</a> checks for a value of −1, writes a diagnostic message to the predefined <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp> stream if an error occurred, and then exits.</p>
<p class="TX">In addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>, POSIX has other useful functions for working with file descriptors, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">fileno</samp> function to get the file descriptor associated with an existing file pointer and the <samp class="SANS_TheSansMonoCd_W5Regular_11">fdopen</samp> function to create a new stream file pointer from an existing file descriptor. POSIX APIs available through the file descriptor allow access to features of POSIX filesystems that aren’t normally exposed through the file pointer interfaces such as directories (<samp class="SANS_TheSansMonoCd_W5Regular_11">posix_getdents</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fdopendir</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">readdir</samp>), file permissions (<samp class="SANS_TheSansMonoCd_W5Regular_11">fchmod</samp>), and file locks (<samp class="SANS_TheSansMonoCd_W5Regular_11">fcntl</samp>).</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h2 class="H1" id="sec10"><span id="h1-69"/><samp class="SANS_Futura_Std_Bold_B_11">Closing Files</samp></h2>
<p class="TNI">Opening a file allocates resources. If you continually open files without closing them, you’ll eventually run out of file descriptors or handles available for your process, and attempting to open more files will fail. Consequently, it’s important to close files after you’ve finished using them.</p>
<section aria-labelledby="sec11" epub:type="division">

<h3 class="H2" id="sec11"><span id="h2-102"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">fclose</samp></h3>
<p class="TNI">The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> function closes the file:</p>

<pre><code>int fclose(FILE *stream);</code></pre>
<p class="TX">Any unwritten buffered data for the stream is delivered to the host environment to be written to the file. Any unread buffered data is discarded.</p>
<p class="TX">It’s possible for the <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> function to fail. When <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> writes the remaining buffered output, for example, it might return an error because the disk is full. Even if you know the buffer is empty, errors can still occur when closing a file if you’re using the Network File System (NFS) protocol. Despite the possibility of failure, recovery is often impossible, so programmers commonly ignore errors returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp>. When closing the file fails, a common practice is to abort the process or to truncate the file so its contents are meaningful when next read.</p>
<p class="TX">To ensure your code is robust, make sure you check for errors. File I/O can fail for any number of reasons. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if any errors were detected:</p>

<pre><code>if (fclose(fp) == EOF) {
  err(EXIT_FAILURE, "Failed to close file\n");
}</code></pre>
<p class="TX">You need to explicitly call <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> on any buffered stream the program has written to, instead of letting <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> (or a return from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>) flush it, to perform the error checking.</p>
<p class="TX"><span aria-label="177" epub:type="pagebreak" id="pg_177" role="doc-pagebreak"/>The value of a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE</samp> object is indeterminate after the associated file is closed. Whether a file of zero length (in which an output stream hasn’t written any data) exists is implementation defined.</p>
<p class="TX">You can reopen a closed file in the same program or another one, and its contents can be reclaimed or modified. If the initial call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function returns or if the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> function is called, all open files close (and all output streams are flushed) before program termination.</p>
<p class="TX">Other paths to program termination, such as calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function, may not close all files properly, which means that buffered data not yet written to a disk might be lost.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h3 class="H2" id="sec12"><span id="h2-103"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">close</samp></h3>
<p class="TNI">On POSIX systems, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp> function to deallocate the file descriptor specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">fd</samp>:</p>

<pre><code>int close(int fd);</code></pre>
<p class="TX">If an I/O error occurred while reading from or writing to the filesystem during <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp>, it may return −1 with <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp> set to the cause of failure. If an error is returned, the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">fd</samp> is unspecified, meaning you can no longer read or write data to the descriptor or attempt to close it again—effectively leaking the file descriptor. The <samp class="SANS_TheSansMonoCd_W5Regular_11">posix_close</samp> function is being added to The Open Group Base Specifications Issue 8 to address this problem.</p>
<p class="TX">Once a file is successfully closed, the file descriptor no longer exists, because the integer corresponding to it no longer refers to a file. Files are also closed when the process owning that file descriptor terminates.</p>
<p class="TX">Except in rare circumstances, an application that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp> to open a file will use <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> to close it; an application that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> to open a file will use <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp> to close it (unless it passed the descriptor to <samp class="SANS_TheSansMonoCd_W5Regular_11">fdopen</samp>, in which case it must close by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose)</samp>.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">

<h2 class="H1" id="sec13"><span id="h1-70"/><samp class="SANS_Futura_Std_Bold_B_11">Reading and Writing Characters and Lines</samp></h2>
<p class="TNI">The C standard defines functions for reading and writing specific characters or lines.</p>
<p class="TX">Most byte stream functions have counterparts that take a wide character (<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>) or wide-character string instead of a narrow character (<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>) or string, respectively (see <a href="chapter8.xhtml#tab8-3">Table 8-3</a>). Byte-stream functions are declared in the header file <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdio.h&gt;</samp>, and the wide-stream functions are declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;wchar.h&gt;</samp>. The wide-character functions operate on the same streams (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>).</p>
<p class="TT" id="tab8-3"><span aria-label="178" epub:type="pagebreak" id="pg_178" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</samp> <samp class="SANS_Futura_Std_Book_11">Narrow- and Wide-String I/O Functions</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fgetwc</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Reads a character from a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">getwc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Reads a character from a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">getwchar</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Reads a character from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fgets</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fgetws</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Reads a line from a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fputwc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Writes a character to a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">putwc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Writes a character to a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fputws</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Writes a string to a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">putwchar</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Writes a character to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Writes a string to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ungetc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ungetwc</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Returns a character to a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">scanf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wscanf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Reads formatted character input from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fwscanf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Reads formatted character input from a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">sscanf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">swscanf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Reads formatted character input from a buffer.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">wprintf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Prints formatted character output to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fprintf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">fwprintf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Prints formatted character output to a stream.</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">swprintf</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Prints formatted character output to a buffer.</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">snprintf</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">N/A</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">This is the same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp> <samp class="SANS_Futura_Std_Book_11">with truncation. The</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">swprintf</samp> <samp class="SANS_Futura_Std_Book_11">function also takes a length argument but behaves</samp> <samp class="SANS_Futura_Std_Book_11">differently from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">snprintf</samp> <samp class="SANS_Futura_Std_Book_11">in the way it interprets it.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">In this chapter, we’ll discuss the byte-stream functions only. You may want to avoid wide-character function variants altogether and work exclusively with UTF-8 character encodings, if possible, as these functions are less prone to programmer error and security vulnerabilities.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> function converts the character <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> to the type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and writes it to <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>:</p>

<pre><code>int fputc(int c, FILE *stream);</code></pre>
<p class="TX">It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if a write error occurs; otherwise, it returns the character it has written.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp> function is just like <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp>, except that most libraries implement it as a macro:</p>

<pre><code>int putc(int c, FILE *stream);</code></pre>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp> is implemented as a macro, it may evaluate its <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp> argument more than once. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> is generally safer. See CERT C rule FIO41-C, “Do not call <samp class="SANS_TheSansMonoCd_W5Regular_11">getc()</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">putc()</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">getwc()</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">putwc()</samp> with a stream argument that has side effects,” for more information.</p>
<p class="TX"><span aria-label="179" epub:type="pagebreak" id="pg_179" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp> function is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">putc</samp> function, except that it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> as the value of the stream argument.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp> function writes the string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to the stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>:</p>

<pre><code>int fputs(const char * restrict s, FILE * restrict stream);</code></pre>
<p class="TX">This function doesn’t write the null character from the string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>—nor does it write a newline character—but outputs only the characters in the string. If a write error occurs, <samp class="SANS_TheSansMonoCd_W5Regular_11">fputs</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>. Otherwise, it returns a nonnegative value. For example, the following statements output the text <samp class="SANS_TheSansMonoCd_W5Regular_11">I am Groot</samp>, followed by a newline:</p>

<pre><code>fputs("I ", stdout);
fputs("am ", stdout);
fputs("Groot\n", stdout);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function writes the string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to the stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> followed by a newline:</p>

<pre><code>int puts(const char *s);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is the most convenient function for printing simple messages because it takes only a single argument. Here’s an example:</p>

<pre><code>puts("This is a message.");</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> function reads the next character as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> from a stream and returns its value, converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:</p>

<pre><code>int fgetc(FILE *stream);</code></pre>
<p class="TX">If an end-of-file condition or read error occurs, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp> function is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>, except that if it’s implemented as a macro, it may evaluate its stream argument more than once. Consequently, this argument should never be an expression with side effects. Analogous to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> function, using <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> is generally safer and should be preferred to <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> function is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp> function, except that it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> as the value of the stream argument.</p>
<p class="TX">You may recall that the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function reads characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> and writes them into a character array until a newline or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> is reached. The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function is inherently insecure. It was deprecated in C99 and removed from C11 and <i>should never be used</i>. If you need to read a string from <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>, consider using the <samp class="SANS_TheSansMonoCd_W5Regular_11">fgets</samp> function instead. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fgets</samp> function reads at most one less than <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters from a stream into a character array pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>:</p>

<pre><code>char *fgets(char * restrict s, int n, FILE * restrict stream);</code></pre>
<p class="TX"><span aria-label="180" epub:type="pagebreak" id="pg_180" role="doc-pagebreak"/>No additional characters are read after a (retained) newline character or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>. A null character is written immediately following the last character read into the array.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">

<h2 class="H1" id="sec14"><span id="h1-71"/><samp class="SANS_Futura_Std_Bold_B_11">Stream Flushing</samp></h2>
<p class="TNI">As described earlier in this chapter, streams can be fully or partially buffered, meaning that data you thought you wrote may not yet be delivered to the host environment. This can be a problem when the program terminates abruptly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp> function delivers any unwritten data for a specified stream to the host environment to be written to the file:</p>

<pre><code>int fflush(FILE *stream);</code></pre>
<p class="TX">The behavior is undefined if the last operation on the stream was input. If the stream is a null pointer, the <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp> function performs this flushing action on all streams. Make sure that your file pointer isn’t null before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp> if this isn’t your intent.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h2 class="H1" id="sec15"><span id="h1-72"/><samp class="SANS_Futura_Std_Bold_B_11">Setting the Position in a File</samp></h2>
<p class="TNI">Random-access files (which include a disk file, for example, but not a terminal) maintain a file position indicator associated with the stream. The <i>file position indicator</i> describes where in the file the stream is currently reading or writing.</p>
<p class="TX">When you open a file, the indicator is positioned at the file’s start (unless you open it in append mode). You can position the indicator wherever you want to read or write any portion of the file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> function obtains the current value of the file position indicator, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> function sets the file position indicator. These functions use the <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> type to represent offsets (positions) in a file and are therefore limited to offsets that can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>. <a href="chapter8.xhtml#Lis8-2">Listing 8-2</a> demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> functions.</p>
<span id="Lis8-2"/>
<pre><code>#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

long int get_file_size(FILE *fp) {
  if (fseek(fp, 0, SEEK_END) != 0) {
    err(EXIT_FAILURE, "Seek to end-of-file failed");
  }
  long int fpi = ftell(fp);
  if (fpi == -1L) {
    err(EXIT_FAILURE, "ftell failed");
  }
  return fpi;
}

<span aria-label="181" epub:type="pagebreak" id="pg_181" role="doc-pagebreak"/>int main() {
  FILE *fp = fopen("fred.txt", "rb");
  if (fp  == nullptr) {
    err(EXIT_FAILURE, "Cannot open fred.txt file");
  }
  printf("file size: %ld\n", get_file_size(fp));
  if (fclose(fp) == EOF) {
    err(EXIT_FAILURE, "Failed to close file");
  }
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Using the</samp> <samp class="I">ftell</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="I">fseek</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp></p>
<p class="TX">This program opens a file called <i>fred.txt</i> and calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_file_size</samp> function to find the file size. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_file_size</samp> function calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> to set the file position indicator to the end of the file (indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">SEEK_END</samp>) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> function to retrieve the current value of the file position indicator for the stream as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>. This value is returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_file_size</samp> function and is printed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function. Finally, we close the file referenced by the <samp class="SANS_TheSansMonoCd_W5Regular_11">fp</samp> file pointer.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> function has different constraints for text and binary files. The offset must be either zero or a value previously returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> for a text file, whereas you can use calculated offsets for a binary file.</p>
<p class="TX">To ensure your code is robust, make sure you check for errors. File I/O can fail for any number of reasons. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fopen</samp> function returns a null pointer when it fails. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> function returns nonzero only for a request that cannot be satisfied. On failure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">−1L</samp> and stores an implementation-defined value in <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp>. If the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">−1L</samp>, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">err</samp> function to print the last component of the program name, a colon character, a space followed by an appropriate error message corresponding to the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp>, and finally, a newline character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if any errors were detected. One of the unfortunate aspects of the C standard library demonstrated by this short program is that each function tends to report errors in its own unique way, so you normally need to refer to your documentation to see how to test for errors.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> functions use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp> type to represent offsets. This type can represent arbitrarily large offsets, meaning you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> with arbitrarily large files. A wide-oriented stream has an associated <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstate_t</samp> object that stores the stream’s current parse state. A successful call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> stores this multibyte state information as part of the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp> object. A later successful call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> using the same stored <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp> value restores the parse state as well as the position within the controlled stream. It’s not possible to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">fpos_t</samp> object to an integer byte or character offset within the stream except indirectly by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp>. The short program shown in <a href="chapter8.xhtml#Lis8-3">Listing 8-3</a> demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> functions.</p>
<span id="Lis8-3"/>
<pre><code><span aria-label="182" epub:type="pagebreak" id="pg_182" role="doc-pagebreak"/>#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  FILE *fp = fopen("fred.txt", "w+");
  if (fp == nullptr) {
    err(EXIT_FAILURE, "Cannot open fred.txt file");
  }
  fpos_t pos;
  if (fgetpos(fp, &amp;pos) != 0) {
    err(EXIT_FAILURE, "get position");
  }
  if (fputs("abcdefghijklmnopqrstuvwxyz", fp) == EOF) {
      fputs("Cannot write to fred.txt file\n", stderr);
  }
  if (fsetpos(fp, &amp;pos) != 0) {
    err(EXIT_FAILURE, "set position");
  }
  long int fpi = ftell(fp);
  if (fpi == -1L) {
    err(EXIT_FAILURE, "ftell");
  }
  printf("file position = %ld\n", fpi);
  if (fputs("0123456789", fp) == EOF) {
    fputs("Cannot write to fred.txt file\n", stderr);
  }
  if (fclose(fp) == EOF) {
    err(EXIT_FAILURE, "Failed to close file\n");
  }
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Using the</samp> <samp class="I">fgetpos</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="I">fsetpos</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">functions</samp></p>
<p class="TX">This program opens the <i>fred.txt</i> file for writing and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetpos</samp> to get the current file position within the file, which is stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">pos</samp>. We then write some text to the file before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp> to restore the file position indicator to the position stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">pos</samp>. At this point, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ftell</samp> function to retrieve and print the file position, which should be 0. After running this program, <i>fred.txt</i> contains the following text:</p>

<pre><code>0123456789klmnopqrstuvwxyz</code></pre>
<p class="TX">You cannot write to a stream and then read from it again without an intervening call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fflush</samp> function to write any unwritten data or to a file positioning function (<samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fsetpos</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp>). You also cannot read from a stream and then write to it without an intervening call to a file positioning function.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> function sets the file position indicator to the beginning of the file:</p>

<pre><code><span aria-label="183" epub:type="pagebreak" id="pg_183" role="doc-pagebreak"/>void rewind(FILE *stream);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> function is equivalent to invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">clearerr</samp> to clear the error indicator for the stream:</p>

<pre><code>fseek(stream, 0L, SEEK_SET);
clearerr(stream);</code></pre>
<p class="TX">Because there is no way to determine if <samp class="SANS_TheSansMonoCd_W5Regular_11">rewind</samp> failed, you should use <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> so that you can check for errors.</p>
<p class="TX">You shouldn’t attempt to use file positions in files opened in append mode, because many systems don’t modify the current file position indicator for append or will forcefully reset to the end of the file when writing. If using APIs that use file positions, the file position indicator is maintained by subsequent reads, writes, and positioning requests. Both POSIX and Windows have APIs that never use the file position indicator; for those, you always need to specify the offset into the file at which to perform the I/O. POSIX defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">lseek</samp> function, which behaves similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> but operates on an open file description (IEEE Std 1003.1:2018).</p>
</section>
<section aria-labelledby="sec16" epub:type="division">

<h2 class="H1" id="sec16"><span id="h1-73"/><samp class="SANS_Futura_Std_Bold_B_11">Removing and Renaming Files</samp></h2>
<p class="TNI">The C standard library provides a <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp> function to delete a file and a <samp class="SANS_TheSansMonoCd_W5Regular_11">rename</samp> function to move or rename it:</p>

<pre><code>int remove(const char *filename);
int rename(const char *old, const char *new);</code></pre>
<p class="TX">In POSIX, the file deletion function is <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp>, and the directory removal function is <samp class="SANS_TheSansMonoCd_W5Regular_11">rmdir</samp>:</p>

<pre><code>int unlink(const char *path);
int rmdir(const char *path);</code></pre>
<p class="TX">POSIX also uses <samp class="SANS_TheSansMonoCd_W5Regular_11">rename</samp> for renaming. One obvious difference between the C standard and POSIX is that C does not have a concept of directories, while POSIX does. Consequently, no specific semantics are defined in the C standard for dealing with directories.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp> function has better-defined semantics than the <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp> function because it’s specific to POSIX filesystems. In POSIX and Windows, we can have any number of links to a file, including hard links and open file descriptors. The <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp> function always removes the directory entry for the file but deletes the file only when there are no more links or open file descriptors referencing it. Even after deletion, the contents of the file may remain in permanent storage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rmdir</samp> function removes a directory whose name is given by <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> only if it is an empty directory.</p>
<p class="TX">In POSIX, the <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp> function is required to behave the same as the <samp class="SANS_TheSansMonoCd_W5Regular_11">unlink</samp> function when the argument is not a directory and to behave the <span aria-label="184" epub:type="pagebreak" id="pg_184" role="doc-pagebreak"/>same as the <samp class="SANS_TheSansMonoCd_W5Regular_11">rmdir</samp> function when the argument is a directory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp> function may behave differently on other operating systems.</p>
<p class="TX">The filesystem is shared with other programs running concurrently to yours. These other programs will modify the filesystem while your program runs. This means that a file entry can disappear or be replaced by a different file entry, which can be a source of security exploits and unexpected data loss. POSIX provides functions that let you unlink and rename files referred to by an open file descriptor or handle. These can be used to prevent security exploits and possible unexpected data loss in a shared public filesystem.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">

<h2 class="H1" id="sec17"><span id="h1-74"/><samp class="SANS_Futura_Std_Bold_B_11">Using Temporary Files</samp></h2>
<p class="TNI">We frequently use <i>temporary files</i> as an interprocess communication mechanism or for temporarily storing information out to disk to free up random-access memory (RAM). For example, one process might write to a temporary file that another process reads from. These files are normally created in a temporary directory by using functions such as the C standard library’s <samp class="SANS_TheSansMonoCd_W5Regular_11">tmpfile</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmpnam</samp> or POSIX’s <samp class="SANS_TheSansMonoCd_W5Regular_11">mkstemp</samp>.</p>
<p class="TX">Temporary directories can be either global or user specific. In Unix and Linux, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TMPDIR</samp> environment variable is used to specify the location of the global temporary directories, which are typically <i>/tmp</i> and <i>/var/tmp</i>. Systems running Wayland or the X11 window system usually have user-specific temporary directories defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">$XDG_RUNTIME_DIR</samp> environment variable, which is typically set to <i>/run/user/$uid</i>. In Windows, you can find user-specific temporary directories in the <i>AppData</i> section of the User Profile, typically <i>C:\Users\User Name\AppData\Local\Temp</i> (<i>%USERPROFILE%\AppData\Local\Temp</i>). On Windows, the global temporary directory is specified by either the <samp class="SANS_TheSansMonoCd_W5Regular_11">TMP</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">TEMP</samp> environment variable. The <i>C:\Windows\Temp</i> directory is a system folder used by Windows to store temporary files.</p>
<p class="TX">For security reasons, it’s best for each user to have their own temporary directory, because the use of global temporary directories frequently results in security vulnerabilities. The most secure function for creating temporary files is the POSIX <samp class="SANS_TheSansMonoCd_W5Regular_11">mkstemp</samp> function. However, because accessing files in shared directories may be difficult or impossible to implement securely, we recommended that you not use any of the available functions and instead perform the interprocess communication by using sockets, shared memory, or other mechanisms designed for this purpose.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">

<h2 class="H1" id="sec18"><span id="h1-75"/><samp class="SANS_Futura_Std_Bold_B_11">Reading Formatted Text Streams</samp></h2>
<p class="TNI">In this section, we’ll demonstrate the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function to read formatted input. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function is the corresponding input version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fprintf</samp> function that we introduced all the way back in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> and has the following signature:</p>

<pre><code>int fscanf(FILE * restrict stream, const char * restrict format, ...);</code></pre>
<p class="TX"><span aria-label="185" epub:type="pagebreak" id="pg_185" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function reads input from the stream pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>, under control of the <samp class="SANS_TheSansMonoCd_W5Regular_11">format</samp> string that tells the function how many arguments to expect, their type, and how to convert them for assignment. Subsequent arguments are pointers to the objects receiving the converted input. The result is undefined if there are insufficient arguments for the <samp class="SANS_TheSansMonoCd_W5Regular_11">format</samp> string. If you provide more arguments than conversion specifiers, the excess arguments are evaluated but otherwise ignored. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function has lots of functionality that we’ll only touch upon here. For more information, refer to the C standard.</p>
<p class="TX">To demonstrate the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp>, as well as some other I/O functions, we’ll implement a program that reads in the <i>signals.txt</i> file shown in <a href="chapter8.xhtml#Lis8-4">Listing 8-4</a> and prints each line.</p>
<span id="Lis8-4"/>
<pre><code>1 HUP Hangup
2 INT Interrupt
3 QUIT Quit
4 ILL Illegal instruction
5 TRAP Trace trap
6 ABRT Abort
7 EMT EMT trap
8 FPE Floating-point exception</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: The</samp> <samp class="SANS_Futura_Std_Book_11">signals.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp></p>
<p class="TX">Each line of this file contains the following: a signal number (a small positive-integer value), the signal ID (a small string of up to six alphanumeric characters), and a short string with a description of the signal. Fields are whitespace delimited except for the description field, which is delimited by one or more space or tab characters at the beginning and by a newline at the end.</p>
<p class="TX"><a href="chapter8.xhtml#Lis8-5">Listing 8-5</a> shows the signals program, which reads this file and prints out each line.</p>
<span id="Lis8-5"/>
<pre><code>#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define TO_STR_HELPER(x) #x
#define TO_STR(x) TO_STR_HELPER(x)

#define DESC_MAX_LEN 99

int main() {
  int status = EXIT_SUCCESS;
  FILE *in;

  struct sigrecord {
    int signum;
    char signame[10];
    char sigdesc[DESC_MAX_LEN + 1];
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span>} rec;

<span aria-label="186" epub:type="pagebreak" id="pg_186" role="doc-pagebreak"/>  if ((in = fopen("signals.txt", "r")) == nullptr) {
    err(EXIT_FAILURE, "Cannot open signals.txt file");
  }

<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> while (true) {
  <span aria-label="annotation3" class="code_CodeAnnotation">❸</span> int n = fscanf(in, "%d%9s%*[\t]%" TO_STR(DESC_MAX_LEN) "[^\n]",
      &amp;rec.signum, rec.signame, rec.sigdesc
    );
    if (n == 3) {
      printf(
        "Signal\n  number = %d\n  name = %s\n  description = %s\n\n",
        rec.signum, rec.signame, rec.sigdesc
      );
    }
    else if (ferror(in)) {
      perror("Error indicated");
      status = EXIT_FAILURE;
      break;
    }
    else if (n == EOF) {
      // normal end-of-file
      break;
    }
    else if (feof(in)) {
      fputs("Premature end-of-file detected\n", stderr);
      status = EXIT_FAILURE;
      break;
    }
    else {
      fputs("Failed to match signum, signame, or sigdesc\n\n", stderr);
      int c;
      while ((c = getc(in)) != '\n' &amp;&amp; c != EOF);
      status = EXIT_FAILURE;
    }
  }

<span aria-label="annotation4" class="code_CodeAnnotation">❹</span> if (fclose(in) == EOF) {
    err(EXIT_FAILURE, "Failed to close file\n");
  }

  return status;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: The signals program</samp></p>
<p class="TX">We define several variables in the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">rec</samp> structure <span aria-label="annotation1" class="CodeAnnotation">❶</span>, which we use to store the signal information found on each line of the file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rec</samp> structure contains three members: a <samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp> member of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> that will hold the signal number; a <samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp> member that’s an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and will hold the signal ID; and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp> member, an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> that will hold the description of the signal. Both arrays have fixed sizes that we determined were adequately sized for the strings being read from the file. If the strings read from the file are too long to fit in these arrays, the program will treat it as an error.</p>
<p class="TX"><span aria-label="187" epub:type="pagebreak" id="pg_187" role="doc-pagebreak"/>The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span> reads each line of input from the file. It appears inside of an infinite <samp class="SANS_TheSansMonoCd_W5Regular_11">while (true)</samp> loop <span aria-label="annotation2" class="CodeAnnotation">❷</span> that we must break out of for the program to terminate. We assign the return value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function to a local variable <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> if an input failure occurs before the first conversion has completed. Otherwise, the function returns the number of input items assigned, which can be fewer than provided for, or even zero, in the event of an early matching failure. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> assigns three input items, so we print the signal description only when <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is equal to 3. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ferror(in)</samp> to determine if the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> set the error indicator. If it did, we print <samp class="SANS_TheSansMonoCd_W5Regular_11">errno</samp> with a call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">perror</samp> function and then set the status to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp>. Next, if <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> equals <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, we break out of the loop because we have successfully processed all the input. The final possibility is that <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> returned a value that is not the expected number of input items, nor is it <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> indicating an early matching failure. In this case, we treat the condition as a nonfatal error:</p>

<pre><code>fputs("Failed to match signum, signame, or sigdesc\n\n", stderr);
int c;
while ((c = getc(in)) != '\n' &amp;&amp; c != EOF);
status = EXIT_FAILURE;</code></pre>
<p class="TX">We print a message to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp> to let the user know that there is a problem with one of the signal descriptions in the file, but we continue to process the remaining entries. The loop discards the defective line and <samp class="SANS_TheSansMonoCd_W5Regular_11">status</samp> is assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp> to indicate to the calling program that an error occurred. You’ll notice that proper error handling in this program makes up the bulk of the code.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">fscanf</samp> function uses a <i>format string</i> that determines how the input text is assigned to each argument. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">"%d%9s%*[\t]%99[^\n]"</samp> format string contains four <i>conversion specifiers</i>, which specify how the input read from the stream is converted into values stored in the objects referenced by the format string’s arguments. We introduce each conversion specification with the percent character (<samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>). After the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>, the following may appear, in sequence:</p>
<ul class="ul">
<li class="ListBullet">An optional character <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> that discards the input without assigning it to an argument</li>
<li class="ListBullet">An optional integer greater than zero that specifies the maximum field width (in characters)</li>
<li class="ListBullet">An optional length modifier that specifies the size of the object</li>
<li class="ListBullet">A conversion specifier character that specifies the type of conversion to be applied</li>
</ul>
<p class="TX">The first conversion specifier in the format string is <samp class="SANS_TheSansMonoCd_W5Regular_11">%d</samp>. This conversion specifier matches the first optionally signed decimal integer, which should correspond to the signal number in the file, and stores the value in the third argument referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.signum</samp>. Without an optional length modifier, the length of the input depends on the conversion specifier’s default type. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> conversion specifier, the argument must point to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>.</p>
<p class="TX"><span aria-label="188" epub:type="pagebreak" id="pg_188" role="doc-pagebreak"/>The second conversion specifier in this format string is <samp class="SANS_TheSansMonoCd_W5Regular_11">%9s</samp>, which matches the next sequence of non-whitespace characters from the input stream—corresponding to the signal name—and stores these characters as a string in the fourth argument referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.signame</samp>. The length modifier prevents more than nine characters from being input and then writes a null character in <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.signame</samp> after the matched characters. A conversion specifier of <samp class="SANS_TheSansMonoCd_W5Regular_11">%10s</samp> in this example would allow a buffer overflow to occur. A conversion specifier of <samp class="SANS_TheSansMonoCd_W5Regular_11">%9s</samp> can still fail to read the entire string, resulting in a matching error. When reading data into a fixed-size buffer as we are doing, you should test inputs that exactly match or slightly exceed the fixed buffer length to ensure buffer overflow does not occur and that the string is properly null terminated.</p>
<p class="TX">We’re going to skip the third conversion specifier for a moment and talk about the fourth one: <samp class="SANS_TheSansMonoCd_W5Regular_11">%99[^\n]</samp>. This fancy conversion specifier will match the signal description field in the file. The brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>) contain a <i>scanset</i>, which is like a regular expression. This scanset uses the circumflex (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>) to exclude <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> characters. Put together, <samp class="SANS_TheSansMonoCd_W5Regular_11">%99[^\n]</samp> reads all the characters until it reaches a <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>) and stores them in the fifth argument referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">rec.sigdesc</samp>. C programmers commonly use this syntax to read an entire line. This conversion specifier also includes a maximum string length of 99 characters to avoid buffer overflows.</p>
<p class="TX">We can now revisit the third conversion specifier: <samp class="SANS_TheSansMonoCd_W5Regular_11">%*[\t]</samp>. As we have just seen, the fourth conversion specifier reads all the characters, starting from the end of the signal ID. Unfortunately, this includes any whitespace characters between the signal ID and the start of the description. The purpose of the <samp class="SANS_TheSansMonoCd_W5Regular_11">%*[\t]</samp> conversion specifier is to consume any space or horizontal tab characters between these two fields and suppress them by using the assignment-suppressing specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>. It’s also possible to include other whitespace characters in the scanset for this conversion specifier.</p>
<p class="TX">Finally, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">fclose</samp> function <span aria-label="annotation4" class="CodeAnnotation">❹</span> to close the file.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">

<h2 class="H1" id="sec19"><span id="h1-76"/><samp class="SANS_Futura_Std_Bold_B_11">Reading from and Writing to Binary Streams</samp></h2>
<p class="TNI">The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp> functions can operate on both text and binary streams. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp> function has the following signature:</p>

<pre><code>size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,
  FILE * restrict stream);</code></pre>
<p class="TX">This function writes up to <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp> elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> bytes from the array pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">stream</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp> function behaves as if it converts each object to an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> (every object can be converted to an array of this type) and then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">fputc</samp> function to write the value of each character in the array in order. The file position indicator for the stream is advanced by the number of characters successfully written.</p>
<p class="TX">POSIX defines similar <samp class="SANS_TheSansMonoCd_W5Regular_11">read</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">write</samp> functions that operate on file descriptors instead of streams (IEEE Std 1003.1:2018).</p>
<p class="TX"><span aria-label="189" epub:type="pagebreak" id="pg_189" role="doc-pagebreak"/><a href="chapter8.xhtml#Lis8-6">Listing 8-6</a> demonstrates the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp> function to write signal records to the <i>signals.bin</i> file.</p>
<span id="Lis8-6"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct sigrecord {
  int signum;
  char signame[10];
  char sigdesc[100];
} rec;

int main() {
  int status = EXIT_SUCCESS;
  FILE *fp;

<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> if ((fp = fopen("signals.bin", "wb")) == nullptr) {
    fputs("Cannot open signals.bin file\n", stderr);
    return EXIT_FAILURE;
  }

<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> rec sigrec30 = {30, "USR1", "user-defined signal 1"};
  rec sigrec31 = {
    .signum = 31, .signame = "USR2", .sigdesc = "user-defined signal 2"
  };

  size_t size = sizeof(rec);

<span aria-label="annotation3" class="code_CodeAnnotation">❸</span> if (fwrite(&amp;sigrec30, size, 1, fp) != 1) {
    fputs("Cannot write sigrec30 to signals.bin file\n", stderr);
    status = EXIT_FAILURE;
    goto close_files;
  }

  if (fwrite(&amp;sigrec31, size, 1, fp) != 1) {
    fputs("Cannot write sigrec31 to signals.bin file\n", stderr);
    status = EXIT_FAILURE;
  }

close_files:
  if (fclose(fp) == EOF) {
    fputs("Failed to close file\n", stderr);
    status = EXIT_FAILURE;
  }

  return status;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Writing to a binary file using direct I/O</samp></p>
<p class="TX">We open the <i>signals.bin</i> file in <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp> mode <span aria-label="annotation1" class="CodeAnnotation">❶</span> to create a binary file for writing. We declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">rec</samp> structures <span aria-label="annotation2" class="CodeAnnotation">❷</span> and initialize them with the signal values we want to write to the file. For comparison, the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigrec30</samp> structure is initialized with positional initializers, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sigrec31</samp> is initialized using <span aria-label="190" epub:type="pagebreak" id="pg_190" role="doc-pagebreak"/>designated initializers. Both initialization styles have the same behavior; designated initializers make the declaration less terse but clearer. The actual writing begins at <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We check the return values from each call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp> function to ensure that it wrote the correct number of elements.</p>
<p class="TX"><a href="chapter8.xhtml#Lis8-7">Listing 8-7</a> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp> function to read the data we just wrote from the <i>signals.bin</i> file.</p>
<span id="Lis8-7"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct rec {
  int signum;
  char signame[10];
  char sigdesc[100];
} rec;

int main() {
  int status = EXIT_SUCCESS;
  FILE *fp;
  rec sigrec;

<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> if ((fp = fopen("signals.bin", "rb")) == nullptr) {
    fputs("Cannot open signals.bin file\n", stderr);
    return EXIT_FAILURE;
  }

  // read the second signal
<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> if (fseek(fp, sizeof(rec), SEEK_SET)  != 0) {
    fputs("fseek in signals.bin file failed\n", stderr);
    status = EXIT_FAILURE;
    goto close_files;
  }

<span aria-label="annotation3" class="code_CodeAnnotation">❸</span> if (fread(&amp;sigrec, sizeof(rec), 1, fp) != 1) {
    fputs("Cannot read from signals.bin file\n", stderr);
    status = EXIT_FAILURE;
    goto close_files;
  }

  printf(
    "Signal\n  number = %d\n  name = %s\n  description = %s\n\n",
    sigrec.signum, sigrec.signame, sigrec.sigdesc
  );

close_files:
  if (fclose(fp) == EOF) {
    fputs("Failed to close file\n", stderr);
    status = EXIT_FAILURE;
  }

  return status;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Reading from a binary file using direct I/O</samp></p>
<p class="TX"><span aria-label="191" epub:type="pagebreak" id="pg_191" role="doc-pagebreak"/>We open the binary file by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">rb</samp> mode <span aria-label="annotation1" class="CodeAnnotation">❶</span> for reading. Next, to make this example a bit more interesting, the program reads and prints the information for a specific signal, rather than reading the entire file. We could indicate which signal to read by using an argument to the program, but for this example, we hardcoded it as the second signal. To accomplish this, the program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">fseek</samp> function <span aria-label="annotation2" class="CodeAnnotation">❷</span> to set the file position indicator for the stream referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">fp</samp>. As mentioned earlier in this chapter, the file position indicator determines the file position for the subsequent I/O operation. For a binary stream, we set the new position by adding the offset (measured in bytes) to the position specified by the final argument (the beginning of the file, as indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">SEEK_SET</samp>). The first signal is at position 0 in the file, and each subsequent signal is at an integer multiple of the size of the structure from the beginning of the file.</p>
<p class="TX">After the file position indicator is positioned at the start of the second signal, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp> function <span aria-label="annotation3" class="CodeAnnotation">❸</span> to read the data from the binary file into the structure referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;sigrec</samp>. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp> reads a single element whose size is specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(rec)</samp> from the stream pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">fp</samp>. In most cases, this object has the size and type of the corresponding call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fwrite</samp>. The file position indicator for the stream is advanced by the number of characters successfully read. We check the return value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">fread</samp> function to ensure the correct number of elements, here one, was read.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">

<h2 class="H1" id="sec20"><span id="h1-77"/><samp class="SANS_Futura_Std_Bold_B_11">Endian</samp></h2>
<p class="TNI">Object types other than character types can include padding as well as value representation bits. Different target platforms can pack bytes into multiple-byte words in different ways, called <i>endianness</i>.</p>
<blockquote>
<p class="Note"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>The term</i> <span class="note">endianness</span> <i>is drawn from Jonathan Swift’s 1726 satire,</i> <span class="note">Gulliver’s Travels</span><i>, in which civil war erupts over whether the big end or the little end of a boiled egg is the proper end to crack open.</i></p>
<p class="TX">A <i>big-endian ordering</i> places the most significant byte first and the least significant byte last, while a <i>little-endian ordering</i> does the opposite. For example, consider the unsigned hexadecimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1234</samp>, which requires at least two bytes to represent. In a big-endian ordering, these two bytes are <samp class="SANS_TheSansMonoCd_W5Regular_11">0x12</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x34</samp>, while in a little-endian ordering, the bytes are arranged as <samp class="SANS_TheSansMonoCd_W5Regular_11">0x34</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x12</samp>. Intel and AMD processors use the little-endian format, while the ARM and POWER series of processors can switch between the little- and big-endian formats. However, big-endian is the dominant ordering in network protocols such as Internet Protocol (IP), Transmission Control Protocol (TCP), and User Datagram Protocol (UDP). Endianness can cause problems when a binary file is created on one computer and is read on another computer with different endianness.</p>
<p class="TX">C23 has added a mechanism to determine your implementation’s byte ordering at runtime using three macros that expand to integer constant expressions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_LITTLE__</samp> macro represents a byte order <span aria-label="192" epub:type="pagebreak" id="pg_192" role="doc-pagebreak"/>storage in which the least significant byte is placed first and the rest are in ascending order. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_BIG__</samp> macro represents a byte order storage in which the most significant byte is placed first and the rest are in descending order.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_NATIVE__</samp> macro describes the endianness of the execution environment with respect to bit-precise integer types, standard integer types, and most extended integer types. The short program in <a href="chapter8.xhtml#Lis8-8">Listing 8-8</a> determines the byte ordering for the execution environment by testing the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_NATIVE__</samp> macro. If the execution environment is neither little-endian nor big-endian and has some other implementation-defined byte order, the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ENDIAN_NATIVE__</samp> will have a different value.</p>
<span id="Lis8-8"/>
<pre><code>#include &lt;stdbit.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char* argv[]) {
  if (__STDC_ENDIAN_NATIVE__ == __STDC_ENDIAN_LITTLE__) {
    puts("little endian");
  }
  else if (__STDC_ENDIAN_NATIVE__ == __STDC_ENDIAN_BIG__) {
    puts("big endian");
  }
  else {
    puts("other byte ordering");
  }
  return 0;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Determining the byte ordering</samp></p>
<p class="TX">All this variation between platforms implies that, for interhost communication, you should adopt a standard for the external format and use format conversion functions to <i>marshal</i> arrays of external data to and from multiple-byte native objects (using exact width types). POSIX has some suitable functions for this purpose, including <samp class="SANS_TheSansMonoCd_W5Regular_11">htonl</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">htons</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntohl</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ntohs</samp>, that convert values between host and network byte order.</p>
<p class="TX">Endianness independence in binary data formats can be achieved by always storing the data in one fixed endianness or including a field in the binary file to indicate the endianness of the data.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">

<h2 class="H1" id="sec21"><span id="h1-78"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about streams, including stream buffering, the predefined streams, stream orientation, and the difference between text and binary streams.</p>
<p class="TX">You then learned how to create, open, and close files by using the C standard library and POSIX APIs. You also learned how to read and write characters and lines, read and write formatted text, and read and write <span aria-label="193" epub:type="pagebreak" id="pg_193" role="doc-pagebreak"/>from binary streams. You looked at how to flush a stream, set the position in a file, remove files, and rename files. Without I/O, communication with the user would be limited to the program’s return value. Finally, you learned about temporary files and how to avoid using them.</p>
<p class="TX">In the next chapter, you’ll learn about the compilation process and the preprocessor, including file inclusion, conditional inclusion, and macros.</p>
</section>
</section>
</body></html>