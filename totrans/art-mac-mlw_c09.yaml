- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Anti-Analysis
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the previous chapters, we leveraged both static and dynamic analysis methods
    to uncover malware’s persistence mechanisms, core capabilities, and most closely
    held secrets. Of course, malware authors are not happy about their creations being
    laid bare for the world to see. Thus, they often seek to complicate analysis by
    writing anti-analysis logic or other protection schemes. In order to successfully
    analyze such malware, we must first identify these protections and then circumvent
    them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们利用了静态和动态分析方法来揭示恶意软件的持久化机制、核心功能以及最为隐秘的秘密。当然，恶意软件作者并不希望他们的创作被公之于众。因此，他们经常通过编写反分析逻辑或其他保护方案来复杂化分析。为了成功分析这类恶意软件，我们必须首先识别这些保护措施，然后绕过它们。
- en: 'In this chapter we’ll discuss anti-analysis approaches common among macOS malware
    authors. Generally speaking, there are two kinds of anti-analysis measures: those
    that aim to thwart static analysis and those that seek to thwart dynamic analysis.
    Let’s take a look at both.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论在macOS恶意软件作者中常见的反分析方法。一般来说，反分析措施分为两类：旨在阻止静态分析的措施和旨在阻止动态分析的措施。让我们看看这两种措施。
- en: Anti-Static-Analysis Approaches
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反静态分析方法
- en: 'Malware authors use several common approaches to complicate static analysis
    efforts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用几种常见的方法来复杂化静态分析工作：
- en: '**String-based obfuscation/encryption**: During analysis, malware analysts
    are often trying to answer questions such as “How does the malware persist?” or
    “What is the address of its command and control server?” Malware that contains
    plaintext strings related to its persistence, like filepaths or the URL of its
    command and control server, makes analysis almost too easy. As such, malware authors
    often obfuscate or encrypt these sensitive strings.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于字符串的混淆/加密**：在分析过程中，恶意软件分析师通常试图回答诸如“恶意软件如何持久化？”或“它的命令与控制服务器的地址是什么？”之类的问题。如果恶意软件包含与其持久化相关的明文字符串，如文件路径或命令与控制服务器的URL，分析几乎变得太容易了。因此，恶意软件作者通常会对这些敏感字符串进行混淆或加密。'
- en: '**Code obfuscation**: In order to complicate the static analysis of their code
    (and sometimes dynamic analysis as well), malware authors can obfuscate the code
    itself. Various obfuscator tools are available for nonbinary malware specimens
    like scripts. For Mach-O binaries, malware authors can use executable packers
    or encryptors to protect the binary’s code.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码混淆**：为了复杂化代码的静态分析（有时也包括动态分析），恶意软件作者可以对代码本身进行混淆。对于像脚本这样的非二进制恶意软件样本，有各种混淆工具可以使用。对于Mach-O二进制文件，恶意软件作者可以使用可执行打包器或加密器来保护二进制文件的代码。'
- en: Let’s look at a few examples of anti-static-analysis methods and then discuss
    how to bypass them. As you’ll see, it’s often easier to overcome anti-static-analysis
    approaches with dynamic analysis techniques. In some cases, the opposite holds
    as well; static analysis techniques can reveal anti-dynamic-analysis tactics.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些反静态分析方法的例子，然后讨论如何绕过它们。正如你所看到的，通常使用动态分析技术比反静态分析方法更容易克服。在某些情况下，反过来也成立；静态分析技术可以揭示反动态分析策略。
- en: Sensitive Strings Disguised as Constants
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏感字符串伪装为常量
- en: 'One of the most basic string-based obfuscations involves splitting sensitive
    strings into chunks so that they are inlined directly into assembly instructions
    as constants. Depending on the chunk size, the `strings` command may miss these
    strings, while a disassembler, by default, will rather unhelpfully display the
    chunks as hexadecimal numbers. We find an example of this string obfuscation in
    Dacls ([Listing 9-1](#listing9-1)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的基于字符串的混淆技术之一是将敏感字符串拆分为多个部分，然后将它们作为常量直接内联到汇编指令中。根据每个部分的大小，`strings`命令可能会错过这些字符串，而反汇编器默认情况下则会以十六进制数字形式显示这些部分，这并不特别有用。我们在Dacls中发现了这种字符串混淆的例子（[列表9-1](#listing9-1)）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Basic string obfuscation (Dacls)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-1：基本的字符串混淆（Dacls）
- en: 'As you can see, six 64-bit values are moved first into the `RCX` register,
    then into adjacent stack-based variables. The astute reader will notice that each
    byte of these values falls within the range of printable ASCII characters. We
    can overcome this basic obfuscation using a disassembler. Simply instruct the
    disassembler to decode the constants as characters instead of the default, hexadecimal.
    In the Hopper disassembler, you can simply CTRL-click the constant and select
    **Characters** to use the shift-r keyboard shortcut ([Listing 9-2](#listing9-2)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，六个64位的值首先被移动到`RCX`寄存器，然后移动到相邻的基于栈的变量。敏锐的读者会注意到，这些值的每个字节都落在可打印的ASCII字符范围内。我们可以使用反汇编工具克服这种基本的混淆。只需指示反汇编工具将常量解码为字符，而不是默认的十六进制格式。在Hopper反汇编工具中，你可以简单地CTRL点击常量，然后选择**字符**来使用shift-r快捷键（[清单9-2](#listing9-2)）：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: Deobfuscated strings (Dacls)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-2：去混淆的字符串（Dacls）
- en: 'If we reconstitute the split string (noting the slight overlap of the first
    two string components), this deobfuscated disassembly now reveals the path of
    the malware’s persistent launch item: */Library/LaunchAgents/com.aex-loop.agent.plist*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新组合被拆分的字符串（注意前两个字符串组件的轻微重叠），这个去混淆后的反汇编现在揭示了恶意软件持久启动项的路径：*/Library/LaunchAgents/com.aex-loop.agent.plist*。
- en: Encrypted Strings
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密字符串
- en: In previous chapters, we looked at several more complex examples of string-based
    obfuscations. For example, in Chapter 7 we noted that WindTail contains various
    embedded base64-encoded and AES-encrypted strings, including the address of its
    command and control server. The encryption key needed to decrypt the string is
    hardcoded within the malware, meaning it would be possible to manually decode
    and decrypt the server’s address. However, this would involve some legwork, such
    as finding (or scripting up) an AES decryptor. Moreover, if the malware used a
    custom (or nonstandard) algorithm to encrypt the strings, even more work would
    be involved. Of course, at some point the malware will have to decode and decrypt
    the protected strings so that it can use them, such as to connect to a command
    and control server for tasking. As such, it’s often far more efficient to simply
    allow the malware to run, which should trigger the decryption of its strings.
    If you’re monitoring the execution of the malware, the decrypted strings can be
    easily recovered.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们查看了几个更复杂的基于字符串的混淆示例。例如，在第7章中我们提到，WindTail包含了各种嵌入的base64编码和AES加密的字符串，其中包括它的命令和控制服务器的地址。解密这些字符串所需的密钥被硬编码在恶意软件中，这意味着我们可以手动解码并解密服务器的地址。然而，这将涉及一些工作，例如找到（或编写）一个AES解密器。此外，如果恶意软件使用了自定义（或非标准的）算法来加密字符串，还需要做更多的工作。当然，在某个时刻，恶意软件必须解码并解密受保护的字符串，以便使用它们，例如连接到命令和控制服务器执行任务。因此，通常更高效的做法是直接让恶意软件运行，这样它会触发字符串的解密。如果你正在监控恶意软件的执行，解密后的字符串就可以轻松恢复。
- en: 'In Chapter 7, I showed one technique for doing this: using a network monitor,
    which allowed us to passively recover the (previously encrypted) address of the
    malware’s command and control server as the malware beaconed out for tasking.
    We can accomplish the same thing using a debugger, as you’ll see here. First,
    we locate WindTail’s decryption logic, a method named `yoop:`. (In a subsequent
    section, I’ll describe how to locate such methods.) Looking at cross-references
    to this method, we can see it’s invoked any time the malware needs to decrypt
    one of its strings prior to use. For example, [Listing 9-3](#listing9-3) shows
    a snippet of disassembly that invokes the `yoop:` method 1 to decrypt the malware’s
    primary command and control server.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章，我展示了一个实现方法：使用网络监控工具，这使我们能够被动地恢复（之前加密的）恶意软件命令和控制服务器的地址，因为恶意软件在进行任务指派时会发送信号。我们也可以使用调试器完成相同的操作，正如你将在这里看到的那样。首先，我们定位到WindTail的解密逻辑，一个名为`yoop:`的方法。（在后续的章节中，我会描述如何定位这类方法。）通过查看该方法的交叉引用，我们可以看到每当恶意软件需要在使用之前解密其字符串时，都会调用这个方法。例如，[清单9-3](#listing9-3)展示了一段反汇编代码，调用`yoop:`方法1来解密恶意软件的主要命令和控制服务器。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: Decryption of a command and control server (WindTail)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-3：命令和控制服务器的解密（WindTail）
- en: 'We can set a debugger breakpoint at `0x100002048`, which is the address of
    the instruction immediately after the call to `yoop:` 2. Because the `yoop:` method
    returns a plaintext string, we can print this string when we hit this breakpoint.
    (Recall that a method’s return value can be found in the `RAX` register.) This
    reveals the malware’s primary command and control server, *flux2key.com*, as shown
    in [Listing 9-4](#listing9-4):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `0x100002048` 处设置调试器断点，这是调用 `yoop:` 后立即执行的指令地址。因为 `yoop:` 方法返回明文字符串，所以当我们命中这个断点时，我们可以打印出这个字符串。
    （请记住，方法的返回值可以在 `RAX` 寄存器中找到。）这将显示恶意软件的主要命令和控制服务器 *flux2key.com*，如 [列表 9-4](#listing9-4)
    所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-4: A decrypted command and control address (WindTail)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：一个解密的命令和控制地址（WindTail）
- en: It’s worth noting that you could also set a breakpoint on the return instruction
    (`retn`) within the decryption function. When the breakpoint is hit, you’ll once
    again find the decrypted string in the `RAX` register. A benefit of this approach
    is that you only have to set a single breakpoint, instead of several at the locations
    from which the decryption method is invoked. This means that any time the malware
    decrypts, not just its command and control server but any string, you’ll be able
    to recover the plaintext of that as well. However, it would become rather tedious
    to manually manage this breakpoint, as it will be invoked many times to decrypt
    each of the malware’s strings. A more efficient approach would be to add additional
    debugger commands (via `breakpoint command add`) to the breakpoint. Then, once
    the breakpoint is hit, your breakpoint commands will be automatically executed
    and could just print out the register holding the decrypted string and then allow
    the process to automatically continue. If you’re interested in the caller, perhaps
    to locate where a specific decrypted string is used, consider printing out the
    stack backtrace as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您还可以在解密函数中的返回指令（`retn`）上设置断点。当断点命中时，您将再次在 `RAX` 寄存器中找到解密后的字符串。这种方法的好处是您只需要设置一个断点，而不是在调用解密方法的多个位置设置多个断点。这意味着每当恶意软件解密时，不仅能恢复其命令和控制服务器而且任何字符串的明文。然而，手动管理这个断点将变得非常乏味，因为它将被多次调用以解密恶意软件的每个字符串。更有效的方法是通过
    `breakpoint command add` 添加附加的调试器命令到断点。然后，一旦断点命中，您的断点命令将自动执行，并且可以只需打印出保存解密字符串的寄存器，然后允许进程继续自动执行。如果您对调用者感兴趣，也许是为了定位特定解密字符串使用的位置，则考虑打印出堆栈回溯。
- en: Note that this breakpoint-based approach can be applied to most string obfuscation
    or encryption methods, as it is agnostic to the algorithm used. That is to say,
    it generally does not matter what technique the malware is using to protect strings
    or data. If you’re able to locate the deobfuscation or decryption routine during
    static analysis, all you’ll need in order to read the string is a well-placed
    debugger breakpoint.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种基于断点的方法适用于大多数字符串混淆或加密方法，因为它对使用的算法不加区分。换句话说，通常不重要恶意软件使用何种技术来保护字符串或数据。如果您能够在静态分析期间找到去混淆或解密例程，则在阅读字符串时，您只需要一个适当放置的调试器断点。
- en: Locating Obfuscated Strings
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位混淆字符串
- en: 'Of course, this begs the question: How can you determine that malware has obfuscated
    sensitive strings and data? And how can you locate the routines within the malware
    responsible for returning their plaintext values?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这引出了一个问题：您如何确定恶意软件是否混淆了敏感字符串和数据？以及如何定位恶意软件内负责返回其明文值的例程？
- en: 'While there are no foolproof methods for the latter, it’s generally straightforward
    to ascertain if a malicious specimen has something to hide. Take, for example,
    the output of the `strings` command, which usually produces a significant number
    of extracted strings. If its output is rather limited or contains a large number
    of nonsensical strings (especially of significant length), this is a good indication
    that some type of string obfuscation is in play. For example, if we run `strings`
    on WindTail, we’ll find various plaintext strings alongside what appear to be
    obfuscated strings ([Listing 9-5](#listing9-5)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然后者没有绝对可靠的方法，但通常很容易确定恶意标本是否有所隐瞒。例如，`strings` 命令的输出通常会产生大量提取出的字符串。如果其输出相对有限或包含大量毫无意义的字符串（尤其是长度显著的字符串），则这表明某种类型的字符串混淆正在发挥作用。例如，如果我们在
    WindTail 上运行 `strings`，我们将找到各种明文字符串以及看似混淆的字符串（[列表 9-5](#listing9-5)）：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-5: Obfuscated strings (WindTail)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-5：混淆字符串（WindTail）
- en: Of course, this method is not foolproof. For example, if the obfuscation method,
    such as an encryption algorithm, produces non-ASCII characters, the obfuscated
    content may not show up in the `strings` output.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: However, poking around in a disassembler may reveal many or large chunks of
    obfuscated or high entropy data that are cross-referenced elsewhere in the binary
    code. For example, malware called NetWire (which installs a malicious application
    named *Finder.app*) contains what appears to be a blob of encrypted data near
    the start of the `__data` section ([Figure 9-1](#figure9-1)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![NetWire contains a giant section of obfuscated data](image_fi/501942c09/f09001.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Embedded obfuscated data (NetWire)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'A continued triage of the malware’s `main` function reveals multiple calls
    to a function at `0x00009502`. Each call to this function passes in an address
    that falls within the block of encrypted data, which starts around `0x0000e2f0`
    in memory:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It seems reasonable to assume that this function is responsible for decrypting
    the contents of the blob of encrypted data. As noted previously, you can usually
    set a breakpoint after code that references the encrypted data and then dump the
    decrypted data. In the case of NetWire, we can set a breakpoint immediately after
    the final call to the decryption function, and then we can examine the decrypted
    data in memory. As it decrypts to a sequence of printable strings, we can display
    it via the `x/s` debugger command, as in [Listing 9-6](#listing9-6):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-6: Dumping now-decrypted configuration parameters (NetWire)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The contents turn out to be configuration parameters that include the address
    of the malware’s command and control server 1, as well as its installation path
    2. Recovering these configuration parameters greatly expedites our analysis.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Deobfuscation Code
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we encounter obfuscated or encrypted data in a malicious sample, it’s important
    to locate the code that deobfuscates or decrypts this data. Once we’ve done so,
    we can set a debugging breakpoint and recover the plaintext. This raises the question
    of how we can locate that code within the malware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the best approach is to use a disassembler or decompiler to identify
    code that references the encrypted data. These references generally indicate either
    the code responsible for decryption or code that later references the data in
    a decrypted state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the case of WindTail, we noted various strings that appeared
    to be obfuscated. If we select one such string (`"BouCfWujdfbAUfCos/iIOg=="`),
    we find it is referenced in the following disassembly ([Listing 9-7](#listing9-7)):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-7: Possible string deobfuscation (WindTail)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the `objc_msgSend` function is used to invoke Objective-C methods,
    that the `RSI` register will hold the name of the method being invoked, and that
    the `RDI` register will hold its first parameter. From the disassembly that references
    the obfuscated string, we can see that the malware is invoking the `yoop:` method
    with the obfuscated string as its parameter. Enumerating cross-references to the
    `yoop:` selector (found at `0x100015448`) reveals that the method is invoked once
    for each string that needs to be decoded and decrypted ([Figure 9-2](#figure9-2)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`objc_msgSend`函数用于调用Objective-C方法，`RSI`寄存器将保存被调用方法的名称，而`RDI`寄存器将保存其第一个参数。从引用混淆字符串的反汇编中，我们可以看到恶意软件正在调用`yoop:`方法，并将混淆字符串作为其参数。枚举对`yoop:`选择器（位于`0x100015448`）的交叉引用表明，该方法会为每个需要解码和解密的字符串调用一次（[图
    9-2](#figure9-2)）。
- en: '![The cross-references to 0x100015448 contain multiple addresses, all of which
    have the Value “mov rsi, qword [0x100015448].”](image_fi/501942c09/f09002.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![0x100015448的交叉引用包含多个地址，所有这些地址的值为“mov rsi, qword [0x100015448]。”](image_fi/501942c09/f09002.png)'
- en: 'Figure 9-2: Cross-references to `@``selector(``yoop:)` (WindTail)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：`@``selector(``yoop:)`（WindTail）的交叉引用
- en: Taking a closer look at the actual `yoop:` method reveals calls to methods named
    `decode:` and `AESDecryptWithPassphrase:`, confirming it is indeed a decoding
    and decryption routine ([Listing 9-8](#listing9-8)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看实际的`yoop:`方法，发现调用了名为`decode:`和`AESDecryptWithPassphrase:`的方法，这证明它确实是一个解码和解密例程（[列表
    9-8](#listing9-8)）。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-8: The `yoop:` method (WindTail)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-8：`yoop:`方法（WindTail）
- en: Another approach to locating decryption routines is to peruse the disassembly
    for calls into system crypto routines (like `CCCrypt`) and well-known crypto constants
    (such as AES’s `s-boxes`). In certain disassemblers, third-party plug-ins such
    as FindCrypt^([1](#c09-endnote-1)) can automate this crypto discovery process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种定位解密例程的方法是浏览反汇编代码，查找系统加密例程（如`CCCrypt`）和著名的加密常量（如AES的`s-boxes`）的调用。在某些反汇编器中，第三方插件如FindCrypt^([1](#c09-endnote-1))可以自动化这一加密发现过程。
- en: String Deobfuscation via a Hopper Script
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Hopper脚本进行字符串去混淆
- en: The downside to the breakpoint-based approach is that it only allows you to
    recover specific decrypted strings. If an encrypted string is exclusively referenced
    in a block of code that isn’t executed, you’ll never encounter its decrypted value.
    A more comprehensive approach is to re-implement the malware’s decryption routine
    and then pass in all the malware’s encrypted strings to recover their plaintext
    values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于断点的方法的缺点是，它仅允许你恢复特定的解密字符串。如果一个加密字符串仅在一个未执行的代码块中被引用，你将永远无法遇到它的解密值。一种更全面的方法是重新实现恶意软件的解密例程，然后传入所有恶意软件的加密字符串以恢复它们的明文值。
- en: In Chapter 6, we introduced disassemblers, highlighting how they can be leveraged
    to statically analyze compiled binaries. Such disassemblers also generally support
    external third-party scripts or plug-ins that can directly interact with a binary’s
    disassembly. This capability is extremely useful and can extend the functionality
    of a disassembler, especially in the context of overcoming malware’s anti-static-analysis
    efforts. As an example of this, we’ll create a Python-based Hopper script capable
    of decrypting all the embedded strings in a sophisticated malware sample.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六章中，我们介绍了反汇编器，并强调了如何利用它们对已编译的二进制文件进行静态分析。这些反汇编器通常还支持外部第三方脚本或插件，可以直接与二进制文件的反汇编进行交互。这个功能非常有用，能够扩展反汇编器的功能，特别是在克服恶意软件的反静态分析措施时。作为一个例子，我们将创建一个基于Python的Hopper脚本，能够解密复杂恶意软件样本中所有嵌入的字符串。
- en: DoubleFantasy is the notorious Equation APT Group’s first-stage implant, capable
    of surveying an infected host and installing a persistent second-stage implant
    on systems of interest. The majority of its strings are encrypted, and many remain
    encrypted even while the malware is executed unless certain prerequisites, such
    as specific tasking, are met. However, as the embedded string decryption algorithm
    is fairly simple, we can re-implement it in a Hopper Python script to decrypt
    all of the malware’s strings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleFantasy是臭名昭著的Equation APT集团的第一阶段植入物，能够对感染的主机进行调查，并在目标系统上安装一个持久的第二阶段植入物。其大部分字符串都是加密的，许多字符串在恶意软件执行时仍然保持加密状态，除非满足某些前提条件，例如特定的任务。然而，由于嵌入的字符串解密算法相当简单，我们可以在Hopper
    Python脚本中重新实现它，以解密所有恶意软件的字符串。
- en: 'Looking at the disassembly of the DoubleFantasy malware, we can see what appears
    to be an encrypted string and its length (`0x38`) being stored to the stack prior
    to a call into an unnamed subroutine ([Listing 9-9](#listing9-9)):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察 DoubleFantasy 恶意软件的反汇编时，我们看到似乎是一个加密字符串及其长度（`0x38`）被存储到栈中，然后调用一个未命名的子程序（[列表
    9-9](#listing9-9)）：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-9: An encrypted string, and a call to a possible string-decryption
    function (DoubleFantasy)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-9：一个加密字符串，以及对可能的字符串解密函数（DoubleFantasy）的调用
- en: 'An examination of this subroutine reveals it decrypts a passed-in string by
    running it through a simple XOR algorithm. As shown in the following snippet of
    disassembly ([Listing 9-10](#listing9-10)), the algorithm uses two keys:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个子程序的检查表明，它通过运行一个简单的 XOR 算法来解密传入的字符串。如以下反汇编片段所示（[列表 9-10](#listing9-10)），该算法使用两个密钥：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-10: A simple string-decryption algorithm (DoubleFantasy)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-10：一个简单的字符串解密算法（DoubleFantasy）
- en: 'The first key is based on the values of the encrypted string itself 1, while
    the second is hardcoded to `0x47` 2. With this understanding of the malware’s
    string decryption algorithm, we can trivially re-implement it in Python ([Listing
    9-11](#listing9-11)):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个密钥基于加密字符串本身的值1，而第二个密钥硬编码为`0x47`2。了解了恶意软件的字符串解密算法后，我们可以轻松地在 Python 中重新实现它（[列表
    9-11](#listing9-11)）：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 9-11: A re-implementation of DoubleFantasy’s string decryption algorithm
    in Python'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-11：用 Python 重新实现 DoubleFantasy 的字符串解密算法
- en: In our Python re-implementation of the malware’s decryption routine, we first
    initialize both XOR keys 1. Then we simply iterate over each byte of the encrypted
    string, de-XORing each with both keys 2. The decrypted string is then returned
    3.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用 Python 重新实现恶意软件解密例程时，我们首先初始化两个 XOR 密钥1。然后我们简单地遍历每个加密字符串的字节，使用两个密钥对其进行解
    XOR 操作2。最后，解密后的字符串被返回3。
- en: With the malware’s decryption algorithm re-implemented, we now need to invoke
    it on all of the malware’s embedded encrypted strings. Luckily, Hopper makes this
    fairly straightforward. DoubleFantasy’s encrypted strings are all stored in its
    `_cstring` segment. Using the Hopper APIs made available to any Hopper script,
    we programmatically iterate through this segment, invoking the re-implemented
    decryption algorithm on each string. We add the logic in [Listing 9-12](#listing9-12)
    to our Python code to accomplish this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新实现恶意软件的解密算法后，我们现在需要在所有恶意软件嵌入的加密字符串上调用它。幸运的是，Hopper 使这项工作相对简单。DoubleFantasy
    的加密字符串都存储在其`_cstring`段中。通过 Hopper 提供给任何 Hopper 脚本的 API，我们可以通过编程方式遍历该段，并对每个字符串调用重新实现的解密算法。我们将[列表
    9-12](#listing9-12)中的逻辑添加到 Python 代码中来完成此任务。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 9-12: Leveraging the Hopper API to decrypt embedded strings (DoubleFantasy)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-12：利用 Hopper API 解密嵌入字符串（DoubleFantasy）
- en: In this listing, we iterate through the `_cstring` segment and find any null-terminated
    items, which includes the malware’s embedded encrypted strings 1. For each of
    these items, we invoke our decryption function on it 2. Finally, we check if the
    item decrypted to a printable ASCII string 3. This check ensures we ignore other
    items found within the `_cstring` segment that are not encrypted strings. The
    decrypted string is then added as an inline comment directly into the disassembly,
    both at the location of the encrypted string and at any location where it is referenced
    in code to facilitate continuing analysis 4.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们遍历`_cstring`段并找到任何以空字符结尾的项，这些项包括恶意软件嵌入的加密字符串1。对于这些项，我们调用解密函数对其进行解密2。最后，我们检查该项是否解密为可打印的
    ASCII 字符串3。此检查确保我们忽略`_cstring`段中其他非加密字符串的项。解密后的字符串随后作为内联注释直接添加到反汇编中，既添加到加密字符串的位置，也添加到代码中任何引用它的地方，以便于继续分析4。
- en: After executing our decryption script in Hopper’s Script menu, the strings are
    decrypted and the disassembly is annotated. For example, as you can see in [Listing
    9-13](#listing9-13), the string `"\xDA\xB3\...\x14"` decrypts to */Library/Caches/com.apple.LaunchServices-02300.csstore*,
    which turns out to be the hardcoded path of the malware’s configuration file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hopper 的脚本菜单中执行我们的解密脚本后，字符串被解密，并且反汇编结果被注释。例如，如你在[列表 9-13](#listing9-13)中看到的，字符串`"\xDA\xB3\...\x14"`解密为*/Library/Caches/com.apple.LaunchServices-02300.csstore*，这实际上是恶意软件配置文件的硬编码路径。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-13: Disassembly, now annotated with the decrypted string (DoubleFantasy)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-13：反汇编，现在已注释解密字符串（DoubleFantasy）
- en: Forcing the Malware to Execute Its Decryption Routine
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制恶意软件执行其解密例程
- en: Creating disassembly scripts to facilitate analysis is a powerful approach.
    However, in the context of string decryptions, it requires that you both fully
    understand the decryption algorithm and are capable of re-implementing it. This
    can often be a time-consuming endeavor. In this section we’ll look at a potentially
    more efficient approach, especially for samples that implement complex decryption
    algorithms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建反汇编脚本以促进分析是一种强有力的方法。然而，在字符串解密的上下文中，这要求你不仅要完全理解解密算法，还要能够重新实现它。这通常是一项耗时的工作。在本节中，我们将讨论一种可能更高效的方法，尤其适用于那些实现了复杂解密算法的样本。
- en: A malware specimen is almost certainly designed to decrypt all its strings;
    we just need a way to convince the malware to do so. Turns out this isn’t too
    hard. In fact, if we create a dynamic library and inject it into the malware,
    this library can then directly invoke the malware’s string decryption routine
    for all encrypted strings, all without having to understand the internals of the
    decryption algorithm. Let’s walk through this process using the EvilQuest malware
    as our target.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件样本几乎肯定被设计为解密其所有字符串；我们只需要找到一种方法来说服恶意软件执行此操作。事实证明，这并不难。实际上，如果我们创建一个动态库并将其注入到恶意软件中，这个库就可以直接调用恶意软件的字符串解密例程来解密所有加密的字符串，而无需理解解密算法的内部实现。让我们通过以
    EvilQuest 恶意软件为目标，来演示这个过程。
- en: 'First, we note that EvilQuest’s binary, named *patch*, appears to contain many
    obfuscated strings ([Listing 9-14](#listing9-14)):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们注意到 EvilQuest 的二进制文件名为 *patch*，似乎包含了许多混淆的字符串（[清单 9-14](#listing9-14)）：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 9-14: Obfuscated strings (EvilQuest)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-14：混淆的字符串（EvilQuest）
- en: 'Statically analyzing EvilQuest for a function that takes the obfuscated strings
    as input quickly reveals the malware’s deobfuscation (decryption) logic, found
    in a function named `ei_str` ([Listing 9-15](#listing9-15)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析 EvilQuest 中一个接受混淆字符串作为输入的函数，很容易揭示出恶意软件的去混淆（解密）逻辑，该逻辑位于名为 `ei_str` 的函数中（[清单
    9-15](#listing9-15)）：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9-15: Invocation of a deobfuscation function, `ei_str` (EvilQuest)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-15：调用去混淆函数 `ei_str`（EvilQuest）
- en: The `ei_str` function is rather long and complicated, so instead of trying to
    decrypt the strings solely via a static analysis approach, we’ll opt for a dynamic
    approach. Moreover, as many of the strings are only deobfuscated at runtime under
    certain circumstances, such as when a specific command is received, we’ll inject
    a custom library into the code instead of leveraging a debugger.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ei_str` 函数相当长且复杂，因此我们不会仅通过静态分析方法来尝试解密这些字符串，而是选择动态方法。此外，由于许多字符串只有在运行时在特定情况下才会被去混淆，例如接收到特定命令时，我们将注入一个自定义库，而不是利用调试器。'
- en: Our custom injectable library will perform two tasks. First, within a running
    instance of the malware, it will resolve the address of the deobfuscation function,
    `ei_str`. Then it will invoke the `ei_str` function for all encrypted strings
    found embedded within the malware’s binary. Because we place this logic in the
    constructor of the dynamic library, it will be executed when the library is loaded,
    well before the malware’s own code is run.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的可注入库将执行两个任务。首先，在运行中的恶意软件实例内，它将解析去混淆函数 `ei_str` 的地址。然后，它将调用 `ei_str` 函数来解密恶意软件二进制中嵌入的所有加密字符串。由于我们将此逻辑放在动态库的构造函数中，它将在库加载时执行，远早于恶意软件自身的代码运行。
- en: '[Listing 9-16](#listing9-16) shows the code we’ll write for the constructor
    of the injectable dynamic decryptor library:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-16](#listing9-16)展示了我们为注入的动态解密库的构造函数编写的代码：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9-16: Our dynamic string deobfuscator library (EvilQuest)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-16：我们的动态字符串去混淆库（EvilQuest）
- en: 'The library code scans over the malware’s entire `__cstring` segment, which
    contains all the obfuscated strings. For each string, it invokes the malware’s
    own `ei_str` function to deobfuscate the string. Once it’s compiled (`% clang
    decryptor.m -dynamiclib -framework Foundation -o decryptor.dylib`), we can coerce
    the malware to load our decryptor library via the `DYLD_INSERT_LIBRARIES` environment
    variable. In the terminal of a virtual machine, we can execute the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该库代码扫描恶意软件的整个 `__cstring` 段，其中包含了所有混淆的字符串。对于每个字符串，它调用恶意软件自己的 `ei_str` 函数来去混淆该字符串。编译后（`%
    clang decryptor.m -dynamiclib -framework Foundation -o decryptor.dylib`），我们可以通过
    `DYLD_INSERT_LIBRARIES` 环境变量强制恶意软件加载我们的解密库。在虚拟机的终端中，我们可以执行以下命令：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once loaded, the library’s code is automatically invoked and coerces the malware
    to decrypt all its strings ([Listing 9-17](#listing9-17)):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，库的代码会自动被调用并强迫恶意软件解密其所有字符串（[清单 9-17](#listing9-17)）：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 9-17: Deobfuscated strings (EvilQuest)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-17：去混淆的字符串（EvilQuest）
- en: The decrypted output (abridged) reveals informative strings that appear to show
    a potential command and control server, files of interest, and a template for
    launch item persistence.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的输出（简化版）揭示了信息性字符串，似乎显示了一个潜在的命令和控制服务器、感兴趣的文件以及启动项持久化的模板。
- en: 'If the malware is compiled with a hardened runtime, the dynamic loader will
    ignore the `DYLD_INSERT_LIBRARIES` variable and fail to load our deobfuscator.
    To bypass this protection, you can first disable System Integrity Protection (SIP)
    and then execute the following command to set the `amfi_get_out_of_my_way` boot
    argument and then reboot your analysis system (or virtual machine):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件使用加固的运行时进行编译，动态加载器将忽略 `DYLD_INSERT_LIBRARIES` 变量，无法加载我们的去混淆器。为了绕过这个保护，您可以首先禁用系统完整性保护（SIP），然后执行以下命令设置
    `amfi_get_out_of_my_way` 启动参数，并重新启动您的分析系统（或虚拟机）：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For more information on this topic, see “How to Inject Code into Mach-O Apps,
    Part II.”^([2](#c09-endnote-2))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参见“如何将代码注入 Mach-O 应用程序，第二部分。”^([2](#c09-endnote-2))
- en: Code-Level Obfuscations
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码级混淆
- en: To further protect their creations from analysis, malware authors may also turn
    toward broader code-level obfuscations. For malicious scripts, which are otherwise
    easy to analyze, as they are not compiled into binary code, this sort of obfuscation
    is quite common. As we discussed in Chapter 4, we can often leverage tools such
    as beautifiers to improve the readability of obfuscated scripts. Obfuscated Mach-O
    binaries are somewhat less common, but we’ll look at several examples of this
    technique.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步保护其创作不被分析，恶意软件作者还可能采用更广泛的代码级混淆技术。对于那些容易分析的恶意脚本（因为它们并未被编译成二进制代码），这种混淆技术相当常见。正如我们在第
    4 章中讨论的那样，我们通常可以利用诸如美化工具之类的工具来提高混淆脚本的可读性。混淆的 Mach-O 二进制文件虽然稍微少见，但我们会看看这种技术的几个例子。
- en: 'One such obfuscation method involves adding *spurious*, or *garbage*, instructions
    at compile time. These instructions are essentially non-operations (NOPs) and
    have no impact on the core functionality of the malware. However, when spread
    effectively throughout the binary, they can mask the malware’s real instructions.
    The prolific Pirrit malware provides an example of such binary obfuscation. To
    hinder static analysis and hide other logic aimed at preventing dynamic analysis,
    its authors added large amounts of garbage instructions. In the case of Pirrit,
    these instructions make up either calls into system APIs (whose results are ignored),
    bogus control flow blocks, or inconsequential modifications to unused memory.
    The following is an example of the former, in which we see the `dlsym` API being
    invoked. This API is normally invoked to dynamically resolve the address of a
    function by name. In [Listing 9-18](#listing9-18), the decompiler has determined
    the results are unused:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一种混淆方法是在编译时添加*虚假*或*垃圾*指令。这些指令本质上是空操作（NOPs），对恶意软件的核心功能没有任何影响。然而，当它们有效地分布在二进制文件中时，可以掩盖恶意软件的真实指令。盛行的
    Pirrit 恶意软件就是这种二进制混淆的一个例子。为了阻碍静态分析并隐藏其他旨在防止动态分析的逻辑，它的作者添加了大量垃圾指令。以 Pirrit 为例，这些指令包括调用系统
    API（其结果被忽略）、虚假的控制流块，或对未使用的内存做出无关紧要的修改。以下是前者的一个例子，我们看到 `dlsym` API 被调用。这个 API 通常用于通过名称动态解析函数的地址。在
    [清单 9-18](#listing9-18) 中，反编译器已经确定结果没有被使用：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-18: Spurious function calls (Pirrit)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-18：虚假的函数调用（Pirrit）
- en: 'Elsewhere in Pirrit’s decompilation, we find spurious code control blocks whose
    logic is not relevant to the core functionality of the malware. Take, for instance,
    [Listing 9-19](#listing9-19), which contains several pointless comparisons of
    the `RAX` register. (The final check can only evaluate to true if `RAX` is equal
    to `0x6b1464f0`, so the first two checks are entirely unnecessary.) Following
    this is a large sequence of instructions that modify a section of the binary’s
    memory, which is otherwise unused:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pirrit 的反编译过程中，我们发现了虚假的代码控制块，其逻辑与恶意软件的核心功能无关。例如，参见 [清单 9-19](#listing9-19)，其中包含了对
    `RAX` 寄存器的几次毫无意义的比较。（最后的检查只有当 `RAX` 等于 `0x6b1464f0` 时才会为真，因此前两个检查完全没有必要。）接下来是一大段指令，它们修改了二进制文件中的一块内存区域，而这块内存本来并未被使用：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-19: Spurious instructions (Pirrit)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-19：虚假的指令（Pirrit）
- en: In almost every subroutine in Pirrit’s disassembly, we find massive amounts
    of such garbage instructions. Though they do slow down our analysis and initially
    mask the malware’s true logic, once we understand their purpose, we can simply
    ignore them and scroll past. For more information on this and other similar obfuscation
    schemes, you can read “Using LLVM to Obfuscate Your Code During Compilation.”^([3](#c09-endnote-3))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Packed Binary Code
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common way to obfuscate binary code is with a packer. In a nutshell,
    a *packer* compresses binary code to prevent its static analysis while also inserting
    a small unpacker stub at the entry point of the binary. As the unpacker stub is
    automatically executed when the packed program is launched, the original code
    is restored in memory and then executed, retaining the binary’s original functionality.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Packers are payload-agnostic and thus can generally pack any binary. This means
    that legitimate software can also be packed, as software developers occasionally
    seek to thwart analysis of their proprietary code. Thus, we can’t assume any packed
    binary is malicious without further analysis.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The well-known UPX packer is a favorite among both Windows and macOS malware
    authors.^([4](#c09-endnote-4)) Luckily, unpacking UPX-packed files is easy. You
    can simply execute UPX with the `-d` command line flag ([Listing 9-20](#listing9-20)).
    If you’d like to write the unpacked binary to a new file, use the `-o` flag as
    well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-20: Unpacking via UPX (ColdRoot)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we’ve unpacked a UPX-packed variant: the malware known as ColdRoot.
    Once it’s unpacked and decompressed, we can commence static and dynamic analysis.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a valid question: How did we know the sample was packed? And how did
    we know it was packed with UPX specifically? One semiformal approach to figuring
    out which binaries are packed is to calculate the *entropy* (amount of randomness)
    of the binary to detect the packed segments, which will have a much higher level
    of randomness than normal binary instructions. I’ve added code to the Objective-See
    TaskExplorer utility to generically detect packed binaries in this manner.^([5](#c09-endnote-5))'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'A less formal approach is to leverage the `strings` command or load the binary
    in your disassembler of choice and peruse the code. With experience, you’ll be
    able to infer that a binary is packed if you observe the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Unusual section names
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A majority of strings obfuscated
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large chunks of executable code that cannot be disassembled
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A low number of imports (references to external APIs)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unusual section names are an especially good indicator, as they can also help
    identify the packer used to compress the binary. For example, UPX adds a section
    named `__XHDR`, which you can see in the output of the `strings` command or in
    a Mach-O viewer ([Figure 9-3](#figure9-3)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![In com.apple.audio.driver, Executable (x86) contains Mach Header, Load Commands,
    Section (_XHDR,_xhdr), and Section (_TEXT,_text).](image_fi/501942c09/f09003.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: UPX section header (ColdRoot)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that UPX is an exception among packers in the sense that
    it can unpack any UPX-packed binary. More sophisticated malware may leverage custom
    packers, which may mean that you have no unpacking utility available. Not to worry:
    if you encounter a packed binary and have no utility to unpack it, a debugger
    may be your best bet. The idea is simple: run the packed sample under the watchful
    eye of a debugger, and once the unpacker stub has executed, dump the unprotected
    binary from memory with the `memory read` LLDB command.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: For another thorough discussion of both analyzing other packers (such as MPRESS)
    and the process of dumping a packed binary from memory, see Pedro Vilaça’s informative
    2014 talk, “F*ck You HackingTeam.”^([6](#c09-endnote-6))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting Encrypted Binaries
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to packers are *binary encryptors*, which encrypt the original malware
    code at the binary level. To automatically decrypt the malware at runtime, the
    encryptor will often insert a decryptor stub and keying information at the start
    of the binary unless the operating system natively supports encrypted binaries,
    which macOS does. As noted, the infamous HackingTeam is fond of packers and encryptors.
    In the blog post “HackingTeam Reborn . . .” I noted that the installer for the
    HackingTeam’s macOS implant, RCS, leveraged Apple’s proprietary and undocumented
    Mach-O encryption scheme in an attempt to thwart static analysis.^([7](#c09-endnote-7))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at how to decrypt binaries, such as HackingTeam’s installer,
    that have been protected via this method. In macOS’s open source Mach-O loader,
    we find an `LC_SEGMENT` flag value named `SG_PROTECTED_VERSION_1` whose value
    is `0x8`:^([8](#c09-endnote-8))
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Comments show that this flag specifies that a Mach-O segment is encrypted (or
    “protected,” in Apple parlance). Via `otool`, we can parse the embedded Mach-O
    loader commands in HackingTeam’s installer and note that, indeed, the flag’s value
    within the `__TEXT` segment (the segment that contains the binary’s executable
    instructions) is set to the value of `SG_PROTECTED_VERSION_1` ([Listing 9-21](#listing9-21)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-21: An encrypted installer; note that the `flags` field is set to
    `0x8`, `SG_PROTECTED_VERSION_1` (HackingTeam)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'From the macOS loader’s source code, we can see that the `load_segment` function
    checks the value of this flag.^([9](#c09-endnote-9)) If the flag is set, the loader
    will invoke a function named `unprotect_dsmos_segment` to decrypt the segment,
    as in [Listing 9-22](#listing9-22):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 9-22: macOS’s support of encrypted Mach-O binaries'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Continued analysis reveals that the encryption scheme is symmetric (either Blowfish
    or AES) and uses a static key that is stored within the Mac’s System Management
    Controller. As such, we can write a utility to decrypt any binary protected in
    this manner. For more discussion of this macOS encryption scheme, see Erik Pistelli’s
    blog post “Creating undetected malware for OS X.”^([10](#c09-endnote-10))
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option for recovering the malware’s unencrypted instructions is to
    dump the unprotected binary code from memory once the decryption code has executed.
    For this specific malware specimen, its unencrypted code can be found from address
    `0x7000` to `0xbffff`. The following debugger command will save its unencrypted
    code to disk for static analysis:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that due to the large memory range, the `--force` flag must be specified
    as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shown that dynamic analysis environments and tools are generally quite
    successful against anti-static-analysis approaches. As a result, malware authors
    also seek to detect and thwart dynamic analysis.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Anti-Dynamic-Analysis Approaches
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Malware authors are well aware that analysts often turn to dynamic analysis
    as an effective means to bypass anti-analysis logic. Thus, malware often contains
    code that attempts to detect whether it is executing in a dynamic analysis environment
    like a virtual machine or within a dynamic analysis tool like a debugger.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware may leverage several common approaches to detecting dynamic analysis
    environments and tools:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual machine detection**: Often, malware analysts will execute the suspected
    malicious code within an isolated virtual machine in order to monitor it or perform
    dynamic analysis. Malware, therefore, is probably right to assume that if it finds
    itself executing within a virtual machine, it is likely being closely watched
    or dynamically analyzed. Thus, malware often seeks to detect if it’s running in
    a virtualized environment. Generally, if it detects such an environment, it simply
    exits.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis tool detection/prevention**: Malware may query its execution environment
    in an attempt to detect dynamic analysis tools, such as a debugger. If a malware
    specimen detects itself running in a debugging session, it can conclude with a
    high likelihood that it is being closely analyzed by a malware analyst. In an
    attempt to prevent analysis, it will likely prematurely exit. Alternatively, it
    might attempt to prevent debugging in the first place.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we figure out whether a malicious specimen contains anti-analysis logic
    to thwart dynamic analysis? Well, if you’re attempting to dynamically analyze
    a malicious sample in a virtual machine or debugger, and the sample prematurely
    exits, this may be a sign that it implements anti-analysis logic. (Of course,
    there are other reasons malware might exit; for example, it might detect that
    its command and control server is offline.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: If you suspect that the malware contains such logic, the first goal should be
    to uncover the specific code that is responsible for this behavior. Once you’ve
    identified it, you can bypass this code by patching it out or simply skipping
    it in a debugger session. One effective way to uncover a sample’s anti-analysis
    code is using static analysis, which means you have to know what this anti-analysis
    logic might look like. The following sections describe various programmatic methods
    that malware can leverage to detect if it is executing within a virtual machine
    or a debugger. Recognizing these approaches is important, as many are widespread
    and found within unrelated Mac malware specimens.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Checking the System Model Name
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Malware may check if it’s running within a virtual machine by querying the
    machine’s name. The macOS ransomware named MacRansom performs such a check. Take
    a look at the following snippet of decompiled code, which corresponds to the malware’s
    anti-virtual-machine check. Here, after decoding a command, the malware invokes
    the `system` API to execute it. If the API returns a nonzero value, the malware
    will prematurely exit ([Listing 9-23](#listing9-23)):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-23: Obfuscated anti-VM logic (MacRansom)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'To uncover the command executed by the malware, we can leverage a debugger.
    Specifically, by setting a breakpoint on the `system` API function, we can dump
    the decoded command. As it is passed as an argument to `system`, as shown in the
    debugger output in [Listing 9-24](#listing9-24), this command can be found in
    the `RDI` register:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 9-24: Deobfuscated anti-VM command (MacRansom)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Turns out the command 1 first retrieves the system’s model name from `hw.model`
    and then checks to see if it contains the string `Mac`. In a virtual machine,
    this command will return a nonzero value, as the value for `hw.model` will not
    contain `Mac` but rather something similar to `VMware7,1` ([Listing 9-25](#listing9-25)):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-25: System’s hardware model (in a virtual machine)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'On native hardware (outside of a virtual machine), the `sysctl hw.model` command
    will return a string containing `Mac` and the malware will not exit ([Listing
    9-26](#listing9-26)):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-26: System’s hardware model (on native hardware)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Counting the System’s Logical and Physical CPUs
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MacRansom contains another check to see if it is running in a virtual machine.
    Again, the malware decodes a command, executes it via the `system` API, and prematurely
    exits if the return value is nonzero. Here is the command it executes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command checks the number of logical CPUs divided by the number of physical
    CPUs on the system where the malware is executing. On a virtual machine, this
    value is often just `1`. If it isn’t `2`, the malware will exit. On native hardware,
    dividing the number of logical CPUs by the number of physical CPUs will often
    (but not always!) result in a value of 2, in which case the malware will happily
    continue executing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Checking the System’s MAC Address
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another Mac malware sample that contains code to detect if it is running in
    a virtual machine is Mughthesec, which masquerades as an Adobe Flash installer.
    If it detects that it is running within a virtual machine, the installer doesn’t
    do anything malicious; it merely installs a legitimate copy of Flash. Security
    researcher Thomas Reed noted that this virtual machine detection is done by examining
    the system’s MAC address.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'If we disassemble the malicious installer, we find the snippet of code responsible
    for retrieving the system’s MAC address via the I/O registry ([Listing 9-27](#listing9-27)):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 9-27: Retrieving the primary MAC address (Mughthesec)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The malware first creates an iterator containing the primary Ethernet interface
    by invoking APIs such as `IOServiceMatching` with the string `"IOEthernetInterface"`
    1. Using this iterator, it then retrieves the MAC address 2. Note that this code
    is rather similar to Apple’s “GetPrimaryMACAddress” sample code, which demonstrates
    how to programmatically retrieve the device’s primary MAC address.^([11](#c09-endnote-11))
    This is not surprising, as malware authors often consult (or even copy and paste)
    Apple’s sample code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'MAC addresses contain an *organizationally unique identifier (OUI)* that maps
    to a specific vendor. If malware detects a MAC address with an OUI matching a
    virtual machine vendor such as VMware, it knows it is running within a virtual
    machine. Vendors’ OUIs can be found online, such as on company websites. For example,
    online documentation found at [https://docs.vmware.com/](https://docs.vmware.com/)
    notes that VMware’s OUI ranges include `00:50:56` and `00:0C:29`, meaning that
    for the former, VMware VMs will contain MAC addresses in the following format:
    `00:50:56:XX:YY:ZZ`.^([12](#c09-endnote-12))'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are a myriad of other ways for malware to programmatically
    detect if it is executing within a virtual machine. For a fairly comprehensive
    list of such methods, see “Evasions: macOS.”^([13](#c09-endnote-13))'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Checking System Integrity Protection Status
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, not all analysis is done within virtual machines. Many malware analysts
    leverage dedicated analysis machines to dynamically analyze malicious code. In
    this scenario, as the analysis is performed on native hardware, anti-analysis
    logic that is based on detecting virtual machines is useless. Instead, malware
    must look for other indicators to determine if it’s running within an analysis
    environment. One such approach is to check the status of *System Integrity Protection
    (SIP)*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'SIP is a built-in macOS protection mechanism that, among other things, may
    prevent the debugging of processes. Malware analysts, who often require the ability
    to debug any and all processes, will often disable SIP on their analysis machines.
    The prolific Pirrit malware leverages this fact to check whether it’s likely running
    on an analysis system. Specifically, it will execute macOS’s `csrutil` command
    to determine the status of SIP. We can observe this passively via a process monitor,
    or more directly in a debugger. In the case of the latter, we can break on a call
    to the `NSConcreteTask`’s `launch` method and dump the launch path and arguments
    of the task object (found in the `RDI` register), as shown in [Listing 9-28](#listing9-28):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 9-28: Retrieving the System Integrity Protection status (Pirrit)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: From the debugger output, we can confirm that indeed the malware is executing
    the `csrutil` command (via the shell, `/bin/sh`) with the `status` flag. The output
    of this command is passed to `grep` to check if SIP is still enabled. If SIP has
    been disabled, the malware will prematurely exit in an attempt to prevent continued
    dynamic analysis.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Detecting or Killing Specific Tools
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Malware might also contain anti-analysis code to detect and thwart dynamic analysis
    tools. As you’ll see, this code usually focuses on debugger detection, but some
    malware specimens will also take into account other analysis or security tools
    that might detect the malware and alert the user, which is something malware often
    seeks to avoid at all costs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'A variant of the malware known as Proton looks for specific security tools.
    When executed, the Proton installer will query the system to see if any third-party
    firewall products are installed. If any are found, the malware chooses not to
    infect the system and simply exits. This is illustrated in the following snippet
    of decompiled code extracted from the installer ([Listing 9-29](#listing9-29)):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 9-29: Basic firewall detection (Proton)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The installer first extracts a filepath from a decrypted array 1. Dynamic analysis
    reveals that this extracted path points to the kernel extension of Little Snitch,
    a popular third-party firewall: */Library/Extensions/LittleSnitch.kext*. If this
    file is found on the system the malware is about to infect, installation is aborted
    2.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The Proton installer has other tricks up its sleeve. For example, in an attempt
    to thwart dynamic analysis, it will terminate tools such as the macOS’s log message
    collector (the Console application) and the popular network monitor Wireshark.
    To terminate these applications, it simply invokes the built-in macOS utility,
    `killall`. Though rather primitive and quite noticeable, this technique will prevent
    the analysis tools from running alongside the malware. (Of course, the tools can
    simply be restarted, or even just renamed.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a Debugger
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The debugger is arguably the most powerful tool in the malware analyst’s arsenal,
    so most malware that contains anti-analysis code seeks to detect whether it is
    running in a debugger session. The most common way for a program to determine
    if it is being debugged is to simply ask the system. As described in Apple’s developer
    documentation, a process should first invoke the `sysctl` API with `CTL_KERN`,
    `KERN_PROC`, `KERN_PROC_PID`, and its process identifier (`pid`), as parameters.
    Also, a `kinfo_proc` structure should be provided.^([14](#c09-endnote-14)) The
    `sysctl` function will then populate the structure with information about the
    process, including a `P_TRACED` flag. If set, this flag means the process is currently
    being debugged. [Listing 9-30](#listing9-30), taken directly from Apple’s documentation,
    checks for the presence of a debugger in this manner:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 9-30: Debugger detection (via the `P_TRACED` flag)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware will often use this same technique, in some cases copying Apple’s code
    verbatim. This was the case with the Russian malware known as Komplex. Looking
    at a decompilation of Komplex’s main function, you can see that it invokes a function
    named `AmIBeingDebugged` ([Listing 9-31](#listing9-31)):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 9-31: Debugger detection (Komplex)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: If the `AmIBeingDebugged` function returns a nonzero value, the malware will
    execute the logic in the `else` block, which causes the malware to delete itself
    in an attempt to prevent continued analysis. And as expected, if we examine the
    code of the malware’s `AmIBeingDebugged` function, it is logically equivalent
    to Apple’s debugger detection function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Debugging with ptrace
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another anti-debugging approach is attempting to prevent debugging altogether.
    Malware can accomplish this by invoking the `ptrace` system call with the `PT_DENY_ATTACH`
    flag. This Apple-specific flag prevents a debugger from attaching and tracing
    the malware. Attempting to debug a process that invokes `ptrace` with the `PT_DENY_ATTACH`
    flag will fail ([Listing 9-32](#listing9-32)):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 9-32: A premature exit due to `ptrace` with the `PT_DENY_ATTACH` flag
    (Proton)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: You can tell the malware has the `PT_DENY_ATTACH` flag set because it prematurely
    exits with a status of `45`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Calls to the `ptrace` function with the `PT_DENY_ATTACH` flag are fairly easy
    to spot (for example, by examining the binary’s imports). Thus, malware may attempt
    to obfuscate the `ptrace` call. For example, Proton dynamically resolves the `ptrace`
    function by name, preventing it from showing up as an import, as you can see in
    the following snippet ([Listing 9-33](#listing9-33)):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 9-33: Obfuscated anti-debugger logic via `ptrace`, `PT_DENY_ATTACH`
    (Proton)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: After invoking the `dlopen` function 1, the malware calls `dlsym` 2 to dynamically
    resolve the address of the `ptrace` function. As the `dlsym` function takes a
    pointer to the string of the function to resolve, such as `[ptrace]`, that function
    won’t show up as a dependency of the binary. The return value from `dlsym`, stored
    in the `RAX` register, is the address of `ptrace`. Once the address is resolved,
    the malware promptly invokes it, passing in `0x1F`, which is the hexadecimal value
    of `PT_DENY_ATTACH` 3. If the malware is being debugged, the call to `ptrace`
    will cause the debugging session to forcefully terminate and the malware to exit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Anti-Dynamic-Analysis Logic
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Luckily, the anti-dynamic-analysis methods covered thus far are all fairly
    trivial to bypass. Overcoming most of these tactics involves two steps: identifying
    the location of the anti-analysis logic and then preventing its execution. Of
    these two steps, the first is usually the most challenging, but it becomes far
    easier once you’re familiar with the anti-analysis methods discussed in this chapter.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: It’s wise to first statically triage a binary before diving into a full-blown
    debugging session. During this triage, keep an eye out for telltale signs that
    may reveal dynamic-analysis-thwarting logic. For example, if a binary imports
    the `ptrace` API, there is a good chance it will attempt to prevent debugging
    with the `PT_DENY_ATTACH` flag.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings or function and method names may also reveal a malware’s distaste for
    analysis. For example, running the `nm` command, used to dump symbols, against
    EvilQuest reveals functions named `is_debugging` and `is_virtual_mchn` ([Listing
    9-34](#listing9-34)):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 9-34: Anti-analysis functions? (EvilQuest)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsurprisingly, continued analysis reveals that both functions are related
    to the malware’s anti-analysis logic. For example, examining the code that invokes
    the `is_debugging` function reveals that EvilQuest will prematurely exit if the
    function returns a nonzero value; that is, if a debugger is detected ([Listing
    9-35](#listing9-35)):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 9-35: Anti-debugging logic (EvilQuest)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: However, if the malware also implements anti-static-analysis logic, such as
    string or code obfuscation, locating logic that seeks to detect a virtual machine
    or a debugger may be difficult to accomplish with static analysis methods. In
    this case, you can use a methodical debugging session, starting at the entry point
    of the malware (or any initialization routines). Specifically, you can single-step
    through to the code, observing API and system calls that may be related to the
    anti-analysis logic. If you step over a function and the malware immediately exits,
    it’s likely that some anti-analysis logic was triggered. If this occurs, simply
    restart the debugging session and step into the function to examine the code more
    closely.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'This trial and error approach could be conducted in the following manner:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Start a debugger session that executes the malicious sample. It is important
    to start the debugging session at the very beginning rather than attaching it
    to the already running process. This ensures that the malware has not had a chance
    to execute any of its anti-analysis logic.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set breakpoints on APIs that may be invoked by the malware to detect a virtual
    machine or debugging session. Examples include `sysctl` and `ptrace`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of allowing the malware to run uninhibited, manually step through its
    code, perhaps stepping over any function calls. If any of the breakpoints are
    hit, examine their arguments to ascertain if they are being invoked for anti-analysis
    reasons. For example, check for `ptrace` invoked with the `PT_DENY_ATTACH` flag,
    or perhaps `sysctl` attempting to retrieve the number of CPUs or setting the `P_TRACED`
    flag. A backtrace should reveal the address of the code within the malware that
    invoked these APIs.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If stepping over a function call causes the malware to exit (a sign it likely
    detected either the virtual machine or the debugger), restart the debugging session
    and, this time, step into this function. Repeat this process until you’ve identified
    the location of the anti-analysis logic.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Armed with the locations of the anti-analysis logic, you can now bypass it by
    modifying the execution environment, patching the on-disk binary image, modifying
    program control flow in a debugger, or modifying the register or variable value
    in a debugger. Let’s briefly look at each of these methods.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Execution Environment
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may be possible to modify the execution environment such that the anti-analysis
    logic no longer triggers. Recall that Mughthesec contains logic to detect if it’s
    running within a virtual machine by examining the system’s MAC address. If the
    malware detects a MAC address with an OUI matching a virtual machine vendor such
    as VMware, it won’t execute. Luckily, we can modify our MAC address in the virtual
    machine’s settings, choosing an address that falls outside the range of any virtual
    machine provider’s OUI. For example, set it to the OUI of your base macOS machine,
    like `F0:18:98`, which belongs to Apple. Once the MAC address has been changed,
    Mughthesec will no longer detect the environment as a virtual machine and so will
    happily execute its malicious logic, allowing our dynamic analysis to continue.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Patching the Binary Image
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another more permanent approach to bypassing anti-analysis logic involves patching
    the malware’s on-disk binary image. The Mac ransomware KeRanger is a good candidate
    for this approach, as it may sleep for several days before executing its malicious
    payload, perhaps in an effort to impede automated or dynamic analysis.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Though the malware is packed, it leverages the UPX packer, which we can fully
    unpack using the `upx -d` command. Next, static analysis can identify the function
    aptly named `waitOrExit` that is responsible for implementing the wait delay.
    It is invoked by the `startEncrypt` function, which begins the process of ransoming
    users’ files:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To bypass the delay logic so that the malware will immediately continue execution,
    we can modify the malware’s binary code to skip the call to the `waitOrExit` function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'In a hex editor, we change the bytes of the malware’s executable instructions
    from a `call` to a `nop`. Short for “no operation,” a `nop` is an instruction
    (`0x90` on Intel platforms) that instructs the CPU to do, well, nothing. It is
    useful when patching out anti-analysis logic in malware, overwriting the problematic
    instructions with benign ones. We also `nop`-out the instructions that would cause
    the malware to terminate if the overwritten call failed ([Listing 9-36](#listing9-36)):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 9-36: Anti-analysis logic, now `nop`’d out (KeRanger)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Now whenever this modified version of KeRanger is executed, the `nop` instructions
    will do nothing and the malware will happily continue executing, allowing our
    dynamic analysis session to progress.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Though patching the malware’s on-disk binary image is a permanent solution,
    it may not always be the best approach. First, if the malware is packed with a
    non-UPX packer that is difficult to unpack, it may not be possible to patch the
    target instructions, as they are only unpacked or decrypted in memory. Moreover,
    on-disk patches involve more work than less permanent methods, such as modifications
    to the malware’s in-memory code during a debugging session. Finally, any modification
    to a binary will invalidate any of its cryptographic signatures. This could prevent
    the malware from executing successfully. Thus, it’s more common for malware analysts
    to use a debugger or other runtime method, such as injecting a custom library,
    to circumvent anti-dynamic-analysis logic.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Malware’s Instruction Pointer
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the more powerful capabilities of a debugger is its ability to directly
    modify the entire state of the malware. This capability proves especially useful
    when you need to bypass dynamic-analysis-thwarting logic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the simplest way to do so involves manipulating the program’s instruction
    pointer, which points to the next instruction that the CPU will execute. This
    value is stored in the program counter register, which on 64-bit Intel systems
    is the `RIP` register. You can set a breakpoint on the anti-analysis logic, and
    when the breakpoint is hit, modify the instruction pointer to, for example, skip
    over problematic logic. If done correctly, the malware will be none the wiser.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to KeRanger. After setting a breakpoint on the call instruction
    that invokes the function that sleeps for three days, we can allow the malware
    to continue until that breakpoint is hit. At this point, we can simply modify
    the instruction pointer to point to the instructions after the call. As the function
    call is never made, the malware never sleeps, and our dynamic analysis session
    can continue.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in a debugger session, you can change the value of any register
    via the `reg write` debugger command. To specifically modify the value of the
    instruction pointer, execute this command on the `RIP` register.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s walk through another example. The EvilQuest malware contains a function
    named `prevent_trace` that invokes the `ptrace` API with the `PT_DENY_ATTACH`
    flag. Code at address `0x000000010000b8b2` invokes this function. If we allow
    this function to execute during a debugging session, the system will detect the
    debugger and immediately terminate the session. To bypass this logic, we can avoid
    the call to `prevent_trace` altogether by setting a breakpoint at `0x000000010000b8b2`.
    Once the breakpoint is hit, we modify the value of the instruction pointer to
    skip the call, as in [Listing 9-37](#listing9-37):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 9-37: Skipping anti-debugger logic (EvilQuest)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Now the `prevent_trace` function is never invoked, and our debugging session
    can continue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note that manipulating the instruction pointer of a program can have serious
    side effects if not done correctly. For example, if a manipulation causes an unbalanced
    or misaligned stack, that program may crash. Sometimes, a simpler approach can
    be taken to avoid manipulating the instruction pointer and modify other registers
    instead.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a Register Value
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that EvilQuest contains a function named `is_debugging`. Recall that the
    function returns a nonzero value if it detects a debugging session, which will
    cause the malware to abruptly terminate. Of course, if no debugging session is
    detected because `is_debugging` returns zero, the malware will happily continue.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of manipulating the instruction pointer, we can set a breakpoint on
    the instruction that performs the check of the value returned by the `is_debugging`
    function. Once this breakpoint is hit, the `EAX` register will contain a nonzero
    value, as the malware will have detected our debugger. However, via the debugger,
    we can surreptitiously toggle the value in `EAX` to 0 ([Listing 9-38](#listing9-38)):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 9-38: Modifying register values to bypass anti-debugging logic'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Changing the value of the `EAX` register to 0 (via `reg write $eax 0`) ensures
    the comparison instruction will now result in the zero flag being set. Thus, the
    `je` instruction will take the branch to address `0x10000b8b2`, avoiding the call
    to `exit` at `0x10000b8ad`. Note that we only needed to modify the lower 32 bits
    of the `RAX` register (`EAX`), as this is all that is checked by the compare instruction
    (`cmp`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'A Remaining Challenge: Environmentally Generated Keys'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, it may seem that malware analysts have the upper hand; after
    all, no anti-analysis measures can stop us, right? Not so fast. Sophisticated
    malware authors employ protection encryption schemes that use *environmentally
    generated keys*. These keys are generated on the victim’s system and are thus
    unique to a specific instance of an infection.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The implications of this are rather profound. If the malware finds itself outside
    the environment for which it was keyed, it will be unable to decrypt itself. This
    also means that attempts to analyze the malware will likely fail, as it will remain
    encrypted. If this environmental protection mechanism is implemented correctly
    and the keying information is not externally recoverable, the only way to analyze
    the malware is either by performing the analysis directly on the infected system
    or by performing it on a memory dump of the malware captured on the infected system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen this protection mechanism in Windows malware written by the infamous
    Equation Group, as well as more recently on macOS by the Lazarus Group.^([15](#c09-endnote-15))
    The latter encrypted all second-stage payloads with the serial number of the infected
    systems. For more on the intriguing topic of environmental key generation, see
    my 2015 Black Hat talk “Writing Bad @$$ Malware for OS X.”^([16](#c09-endnote-16))
    Also check out James Riordan and Bruce Schneier’s seminal paper on the topic,
    “Environmental Key Generation Towards Clueless Agents.”^([17](#c09-endnote-17))
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Up Next
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discussed common anti-analysis approaches that malware may
    leverage in an attempt to thwart our analysis efforts. After discussing how to
    identify this logic, I illustrated how to use static and dynamic approaches in
    order to bypass it. Armed with the knowledge presented in this book thus far,
    you’re now ready to analyze a sophisticated piece of Mac malware. In the next
    chapter we’ll uncover the malware’s viral infection capabilities, persistence
    mechanism, and goals.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Endnotes
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
