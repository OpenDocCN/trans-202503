- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 1 HELLO, WORLD OF ASSEMBLY LANGUAGE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This “quick-start” chapter gets you writing basic assembly language programs
    as rapidly as possible, giving you the skills you need to learn new assembly language
    features in the following chapters. You’ll learn the foundations of 64-bit ARM
    architecture and the basic syntax of the GNU assembler (Gas) program, a compiler
    for assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn to set aside memory for variables, control the CPU by using
    machine instructions, and link a Gas program with C/C++ code so that you can call
    routines in the C standard library (C stdlib). Gas running under Linux and macOS
    is by far the most common assembler for writing real-world ARM assembly language
    programs. Vendors (especially Apple) have produced variants of Gas with slightly
    different syntax; for instance, under macOS, Gas is known as the *Clang* or *Mach-O*
    assembler. To make the source code in this book portable between macOS and Linux,
    this chapter also introduces a header file, *aoaa.inc*, that eliminates the differences
    between Gas and the Clang assembler.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 What You’ll Need
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn assembly language programming with Gas, you’ll need a version of the
    assembler for your platform, plus a text editor for creating and modifying Gas
    source files, a linker, various library files, and a C++ compiler. You’ll learn
    to set up the Gas assembler and text editor in this section, and the other tools
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.1 Setting Up Gas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The GNU Compiler Collection (GCC) emits Gas source code as its output (which
    Gas then converts to object code). Therefore, if you have the compiler suite running
    on your system, you also have Gas. Apple macOS uses a compiler based on the LLVM
    compiler suite rather than GCC, so if you have a macOS, you’ll need to install
    its Xcode integrated development environment (IDE) to gain access to the assembler
    (see [Appendix C](appendix-C.xhtml)). Otherwise, if you don’t have the GCC compiler,
    install it with the instructions in your operating system (OS) documentation.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The GNU assembler and the Clang assembler’s executable name is actually* as
    *(assembler). The examples in this book rarely invoke the assembler directly,
    so you won’t use the* as *program often. Therefore, this book refers to the assembler
    by using the name* Gas *rather than* as *(or Clang assembler).*'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.2 Setting Up a Text Editor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write ARM assembly language programs, you will need some sort of programmer’s
    text editor to create assembly language source files. The choice of editor is
    dictated by personal tastes and editor availability for your OS or development
    suite.
  prefs: []
  type: TYPE_NORMAL
- en: The standard suffix for assembly language source files is *.s*, since GCC emits
    this suffix when it converts a C/C++ file into assembly language during compilation.
    For handwritten assembly language source files, the *.S* suffix is a better choice,
    since it tells the assembler to route the source file through the C preprocessor
    (CPP) before assembly. Since this allows the use of CPP macros (#define statements),
    conditional compilation, and other facilities, all example files in this book
    use *.S*.
  prefs: []
  type: TYPE_NORMAL
- en: GCC always produces assembly language output files, which are then processed
    by Gas. GCC automatically invokes the assembler and then deletes the assembly
    source file after the assembly is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.3 Understanding C/C++ Examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Today’s software engineers drop into assembly language only when their C/C++,
    C#, Java, Swift, or Python code is running too slowly and they need to improve
    the performance of certain modules or functions. The examples in this book use
    C/C++ because you’ll typically interface assembly language with C/C++ or other
    high-level language (HLL) code in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: The C/C++ standard library is another good reason to use this language. To make
    the C stdlib immediately accessible to Gas programs, I present examples with a
    short C++ main function that calls a single external function written in assembly
    language using Gas. Compiling the C++ main program along with the Gas source file
    produces a single executable file that you can run and test.
  prefs: []
  type: TYPE_NORMAL
- en: This book spoon-feeds you the C++ you’ll need to run the example HLL programs,
    so you’ll be able to follow even if you’re not fluent in the language. However,
    you’ll have an easier time if you have a little prior familiarity with C/C++.
    At minimum, this book assumes that you have some experience in a language such
    as Pascal (or Delphi), Java, Swift, Rust, BASIC, Python, or any other imperative
    or object-oriented programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 The Anatomy of an Assembly Language Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical (stand-alone) Gas program takes the form shown in Listing 1-1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assembly language programs are broken into *sections*. Some sections contain
    data, some contain constants, some contain machine instruction (executable statements),
    and so on. Listing 1-1 contains a single code section, called *text* in macOS
    and Linux. The .text statement ❶ tells the assembler that the following statements
    are associated with the code section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In assembly language source files, symbols are usually local or private to
    a source file. When creating an executable source file, you must pass one or more
    symbols to the system linker—at least the name of the main program. You can accomplish
    this by using the .global statement, specifying the global name as an operand:
    _main in the macOS case, main in the Linux case. Leaving out this statement gives
    you an error when you try to compile the source file.'
  prefs: []
  type: TYPE_NORMAL
- en: The ARM instruction set requires all machine instructions to begin on a 32-bit
    (4-byte) boundary in memory. Therefore, before the first machine instruction in
    a .text section, tell the assembler to align the addresses on a 4-byte boundary.
    The .align statement ❷ raises 2 to the power specified by its operand and aligns
    the next instruction on that boundary. Since 2² is equal to 4, this statement
    aligns the next instruction on a 4-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'A procedure, or function, in ARM assembly simply consists of the name of that
    function (_main or main in this case) followed by a colon. The machine instructions
    follow. The main program in this example consists of a single machine instruction:
    ret (return). This instruction immediately returns control to whatever called
    the main program—that is, the OS.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers in Gas are similar to identifiers in most HLLs. Gas identifiers
    may begin with a dollar sign ($), an underscore (_), or an alphabetic character
    and may be followed by zero or more alphanumeric, dollar sign, or underscore characters.
    Symbols are case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: While the program in Listing 1-1 doesn’t really *do* anything, you can use it
    to learn how to use the assembler, linker, and other tools necessary for writing
    ARM assembly language programs, as we’ll do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Running Your First Assembly Language Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have an assembly source file, you can compile and run that program.
    In theory, you could run the assembler (as) and then the linker (ld, supplying
    appropriate library files needed by the OS). Here’s how that would look for macOS
    (where the $ appearing at the beginning of each line is the OS’s shell prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the command lines differ depending on your OS, and producing an executable
    in this way takes a lot of typing. An easier way to compile the program and produce
    an executable is to use the GCC compiler (g++) by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command line even works on macOS, which uses the Clang compiler rather
    than GCC; macOS has an alias for Clang named g++. On macOS, you could also use
    the clang -o Listing1-1 Listing1-1.S command line. This book, however, will stick
    to the g++ command line, as that works on macOS and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The g++ command is smart enough to note that this is an assembly language source
    file and run Gas on it to produce an object file. GCC will then run the linker
    (ld) and supply all the default libraries the OS requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the resulting executable file from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This program immediately returns without any output, since that’s all Listing
    1-1 does; it’s simply intended to demonstrate how to compile and run ARM assembly
    language programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to reducing the amount of typing required, using g++ to assemble
    your assembly language source files provides another advantage: it’s the easiest
    way to run the CPP, which many of the example files in this book require. You
    can invoke the CPP (by itself) on an assembly source file by using a command like
    the following, to see the modifications the CPP makes to your assembly source
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even pipe the output from the CPP to Gas, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, at that point, you may as well have typed
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: as it’s shorter and easier to input.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Running Your First Gas/C++ Hybrid Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book commonly combines an assembly language module containing one or more
    functions written in assembly language with a C/C++ main program that calls those
    functions. Because the compilation and execution process is slightly different
    from a stand-alone Gas program, this section demonstrates how to create, compile,
    and run a hybrid assembly/C++ program. Listing 1-2 provides the main C++ program
    that calls the assembly language module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Listing 1-3, a slight modification of the stand-alone Gas program, contains
    the asmMain() function that the C++ program calls. The main difference between
    Listing 1-3 and Listing 1-1 is that the function’s name changes from _main to
    _asmMain. The C++ compiler and linker would get confused if we continued to use
    the name _main, as that’s also the name of the C++ main function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to compile and run these source files, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Granted, this assembly language example doesn’t accomplish much other than demonstrate
    how to compile and run some assembly code. To write real assembly code, you’re
    going to need a lot of support code. The next section describes the *aoaa.inc*
    header file that provides some of this support.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 The aoaa.inc Include File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example code in this book was written to be as portable between macOS and
    Linux assemblers as possible, a difficult task requiring considerable advanced
    behind-the-scenes trickery. Many of those tricks are a bit too advanced to easily
    explain to beginning ARM programmers, so I’ve incorporated all this magic code
    in a special header file, *aoaa.inc*, that I use in most of the example programs
    from this point forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'This human-readable include file is little more than a typical advanced C/C++
    header file; it just contains a bunch of macros (for example, C/C++ #define statements)
    that help smooth out some of the differences between the macOS and Linux versions
    of the assembler. By the time you get to the end of this book (especially by the
    time you read [Chapter 13](chapter13.xhtml)), most of the material in the header
    file will make perfect sense. For now, I won’t distract you with advanced macros
    and conditional assembly information.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find *aoaa.inc* along with all the other example code at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
    If you’re curious about this file’s content and don’t want to wait for [Chapter
    13](chapter13.xhtml), load it into a text editor and take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include this file in an assembly, use the following CPP statement in your
    assembly language source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as in C/C++, this statement will automatically insert the content of this
    file into the current source file during assembly (at the point of the #include
    statement).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gas has its own include statement, used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, don’t use this statement to include *aoaa.inc* in your source files.
    The Gas .include directive executes after the CPP runs, but *aoaa.inc* contains
    CPP macros, conditional compilation statements, and other code that must be processed
    by the CPP. If you use the .include directive rather than #include, the CPP will
    never see the contents of the *aoaa.inc* file, and Gas will generate errors when
    it processes the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *aoaa.inc* file must be present in the same directory as your assembly
    source file during the assembly process (or you must supply an appropriate path
    to the file in the #include "aoaa.inc" statement). If the header file isn’t in
    the current directory, Gas will complain that it can’t find the file and terminate
    the assembly. Also remember to use the *.S* suffix with your assembly source files
    when using #include "aoaa.inc", or GCC won’t run the CPP on those files.'
  prefs: []
  type: TYPE_NORMAL
- en: '### 1.6 The ARM64 CPU Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, you’ve seen a pair of Gas programs that compile and run. However,
    the statements appearing in those programs do nothing more at this point than
    return control to the OS. Before you learn some real assembly language, you’ll
    need to understand the basic structure of the ARM CPU family so you can follow
    the machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM CPU family is generally classified as a Von Neumann architecture machine.
    Von Neumann computer systems contain three main building blocks: the *central
    processing unit (CPU)*, *memory*, and *input/output (I/0) devices*. These three
    components are interconnected via the *system bus* (consisting of the address,
    data, and control buses). [Figure 1-1](chapter1.xhtml#fig1-1) shows this relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: A Von Neumann computer system block diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU communicates with memory and I/O devices by placing a numeric value
    on the address bus to select one of the memory or I/O device port locations, each
    of which has a unique binary numeric *address*. Then the CPU, memory, and I/O
    devices pass data among themselves by placing the data on the data bus. The control
    bus contains signals that determine the direction of the data transfer (to/from
    memory and to/from an I/O device).
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.1 ARM CPU Registers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two categories of ARM CPU registers: *general-purpose registers*
    and *special-purpose kernel-mode registers*. The special-purpose registers are
    intended for writing OSes, debuggers, and other system-level tools. Such software
    construction is well beyond the scope of this text.'
  prefs: []
  type: TYPE_NORMAL
- en: The ARM64 supports 32 general-purpose 64-bit registers (named X0 through X31)
    and 32 general-purpose 32-bit registers (named W0 through W31). This doesn’t imply
    there are 64 registers total; instead, the 32-bit registers overlay the low-order
    (LO) 32 bits of each of the 64-bit registers. ([Chapter 2](chapter2.xhtml) discusses
    LO components in more depth.) Modifying one of the 32-bit registers also modifies
    the corresponding 64-bit register, and vice versa, as outlined in [Figure 1-2](chapter1.xhtml#fig1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: The 32- and 64-bit registers on the ARM'
  prefs: []
  type: TYPE_NORMAL
- en: Those new to assembly language are often surprised that all calculations on
    the ARM64 involve a register. For example, to add two variables together, storing
    the sum into a third variable, you must load one of the variables into a register,
    add the second operand to the value in the register, and then store the register
    away in the destination variable. Registers are a middleman in nearly every calculation,
    so they’re important in ARM64 assembly language programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these registers are known as *general-purpose* registers, a few of
    them have special purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: X31, usually referred to as *SP* in code, is called the *stack pointer*, since
    it’s used to maintain a *hardware stack* on the ARM (another non-RISC, or reduced
    instruction set computer, feature), always as a 64-bit register. Because it’s
    used as the stack pointer, SP cannot be used for other purposes in most code.
    This register is accessible only by a few instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The XZR/WZR register (also treated as X31/W31 by the hardware) is called the
    *zero* register. It always returns 0 when read and is a convenient way to obtain
    the constant 0 in a program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register X30 is the *link register*, referred to by the name *LR* rather than
    X30\. The ARM CPU uses this register to hold *return addresses* when the code
    makes a function call. ([Chapter 5](chapter5.xhtml) discusses the LR in greater
    detail.) This register is also always accessed in 64-bit mode. While you could
    theoretically use X30/W30 as a general-purpose register, you should avoid doing
    so, because function calls will wipe out the value in this register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this special purpose isn’t enforced by the hardware, most software
    uses X29 as a 64-bit *frame pointer (FP)*. Software generally uses this register
    to provide access to function parameters and local variables. Technically, you
    could use any of the general-purpose registers for this purpose, but using X29/FP
    is conventional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple reserves X18 for its own internal purposes. Programs written for macOS,
    iOS, iPadOS, and so on must not use this register. Since 29 other registers are
    available, the examples in this book don’t use X18, even for Linux examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the 32 general-purpose registers, the ARM64 CPUs have two additional
    special-purpose registers accessible to user programs: the 32-bit *processor state
    (PSTATE)* register and the 64-bit *program counter (PC)* register. The PC register
    always contains the address of the machine instruction being executed. Because
    instructions are always 32 bits long, the CPU will increment this register by
    4 whenever it finishes the execution of one instruction and moves on to the next
    (more on this activity in [Chapter 2](chapter2.xhtml)).'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*32-bit ARM CPUs refer to the PSTATE register as the* CPSR *or* PSR*. You may
    see references to those names in various documents.*'
  prefs: []
  type: TYPE_NORMAL
- en: The PSTATE register is 32 bits wide (of which only 16 bits are used at the time
    of this writing) and is really just a collection of individual Boolean flags.
    Its layout appears in [Figure 1-3](chapter1.xhtml#fig1-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: The PSTATE register layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most user applications use only the N, Z, C, and V bits in the PSTATE register.
    These bits, also known as the *condition codes*, have the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**N**    Negative (sign) flag, set when an instruction produces a negative
    result'
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**    Zero flag, set when an instruction produces a zero result'
  prefs: []
  type: TYPE_NORMAL
- en: '**C**    Carry flag, set when an unsigned arithmetic overflow occurs'
  prefs: []
  type: TYPE_NORMAL
- en: '**V**    Overflow flag, set when a signed arithmetic overflow occurs'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the remaining flags are inaccessible or of little use in user programs.
    UAO and PAN control CPU access features, allowing user programs to access kernel
    memory. SS is the single-step control bit for debugging. IL is the illegal instruction
    flag, set when the CPU executes an illegal instruction. D, A, I, and F are interrupt
    flags. cEL selects an exception level, usually 00 for user mode. SPS selects a
    stack pointer to use (kernel versus user mode).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the 32 general-purpose registers, the ARM64 provides 32 floating-point
    and vector registers to handle nonintegral arithmetic. [Chapters 6](chapter6.xhtml)
    and [11](chapter11.xhtml) discuss these registers in greater detail when covering
    floating-point arithmetic and single-instruction/multiple data (SIMD) operations.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.2 The Memory Subsystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A typical ARM64 processor running a modern 64-bit OS can access a maximum of
    2^(48) memory locations, or just over 256TB—probably far more than any of your
    programs will ever need. Since the ARM64 supports byte-addressable memory, the
    basic memory unit is a byte, which is sufficient to hold a single character or
    a very small integer value (discussed further in [Chapter 2](chapter2.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Because 2^(48) is a frightfully large number, the following discussion uses
    the 4GB address space of 32-bit ARM processors. Scaled up, the same discussion
    applies to 64-bit ARM processors.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*While the ARM64 supports 64 address bits in software, the hardware supports
    only 48 to 52 address bits for virtual memory operations. Most OSes limit this
    to 48 bits.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of memory as a linear array of bytes. The address of the first byte is
    0, and the address of the last byte is 2^(32) – 1\. For an ARM processor, the
    following pseudo-Pascal array declaration is a good approximation of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'C/C++ and Java users might prefer the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To execute the equivalent of the Pascal statement Memory [125] := 0;, the CPU
    places the value 0 on the data bus, places the address 125 on the address bus,
    and asserts the write line (which generally involves setting that line to 0),
    as shown in [Figure 1-4](chapter1.xhtml#fig1-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: The memory write operation'
  prefs: []
  type: TYPE_NORMAL
- en: To execute the equivalent of CPU := Memory [125];, the CPU places the address
    125 on the address bus, asserts the read line (because the CPU is reading data
    from memory), and reads the resulting data from the data bus (see [Figure 1-5](chapter1.xhtml#fig1-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: The memory read operation'
  prefs: []
  type: TYPE_NORMAL
- en: This discussion applies only when accessing a single byte in memory. To store
    values larger than a single byte, like *half words* (2 bytes) and *words* (4 bytes),
    the ARM uses a sequence of consecutive memory locations, as shown in [Figure 1-6](chapter1.xhtml#fig1-6).
    The memory address is the address of each object’s first byte (that is, the lowest
    address).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: Byte, half-word, and word storage in memory'
  prefs: []
  type: TYPE_NORMAL
- en: The ARM64 generally supports *unaligned memory access*, meaning the CPU can
    read or write an object of any size—byte, half word, word, or double word (dword)—at
    any address in memory. Certain instructions, however, require that memory access
    be aligned on the natural size of the transfer. Generally, this means that 16-,
    32-, and 64-bit memory accesses must take place on addresses that are a multiple
    of 2, 4, or 8; otherwise, the CPU may raise an exception. Regardless of exceptions,
    the CPU can usually access memory locations aligned on a natural boundary faster.
  prefs: []
  type: TYPE_NORMAL
- en: Modern ARM processors don’t connect directly to memory. Instead, a special memory
    buffer on the CPU known as the *cache* (pronounced “cash”) acts as a high-speed
    intermediary between the CPU and main memory. You’ll learn to set the alignment
    of memory objects and the effects of the cache on data alignment in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Declaring Memory Variables in Gas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Referencing memory by using numeric addresses in assembly language is possible,
    but painful and error-prone. Rather than having your program state, “Give me the
    32-bit value held in memory location 192 and the 16-bit value held in memory location
    188,” it’s much nicer to state, “Give me the contents of elementCount and portNumber.”
    Using variable names, rather than memory addresses, makes your program much easier
    to write, read, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: To create (writable) data variables, you have to put them in a data section
    of the Gas source file, defined using the .data directive. The .data directive
    tells Gas that all following statements (up to the next .text or other section-defining
    directive) will define data declarations to be grouped into a read/write section
    of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Within a .data section, Gas allows you to declare variable objects by using
    a set of data declaration directives. The basic form of a data declaration directive
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'where label is a legal Gas identifier and directive is one of the directives
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: .byte    Byte (8-bit) values. One or more comma-separated 8-bit expressions
    appear in the operand field (values).
  prefs: []
  type: TYPE_NORMAL
- en: .hword**,** .short**,** .2byte    Half-word (16-bit) values. One or more comma-separated
    16-bit expressions appear in the operand field.
  prefs: []
  type: TYPE_NORMAL
- en: .word**,** .4byte    Word (32-bit) values. One or more comma-separated 32-bit
    expressions appear in the operand field.
  prefs: []
  type: TYPE_NORMAL
- en: .quad**,** .8byte    Dword (64-bit) values. One or more comma-separated 64-bit
    expressions appear in the operand field. .quad is an unfortunate misnomer for
    ARM64, since a 64-bit value is actually a double word, not a quad word (on the
    ARM, a quad word is 128 bits). The term predates the ARM assembler, coming from
    “quad word” in the x86 and 68000 assembly language days. To avoid confusion, this
    book uses the .dword directive in place of .quad.
  prefs: []
  type: TYPE_NORMAL
- en: .dword    The .dword macro appearing in the *aoaa.inc* include file is a synonym
    for the .quad directive that emits 8 bytes (64 bits) for each operand. Using .dword
    is preferable to .quad. You must include the *aoaa.inc* file in order to use this
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: .octa    Octaword (oword, 128-bit/16-byte) values. One or more comma-separated
    128-bit expressions appear in the operand field. .octa is an unfortunate misnomer
    for ARM64, since a 128-bit value is actually a quad word, not an “octa” word (on
    the ARM, an octaword is 256 bits). To avoid confusion, this book avoids the .octa
    directive and uses .qword instead.
  prefs: []
  type: TYPE_NORMAL
- en: .qword    This is a macro appearing the *aoaa.inc* include file. It is a synonym
    for the .octa directive and emits 16 bytes for each operand. You must include
    the *aoaa.inc* file in order to use this directive.
  prefs: []
  type: TYPE_NORMAL
- en: .ascii    String values. A single string constant (surrounded by quotation marks)
    appears in the operand field. Note that Gas does not terminate this string with
    a 0 byte.
  prefs: []
  type: TYPE_NORMAL
- en: .asciz    Zero-terminated string values. A single string constant (surrounded
    by quotation marks) appears in the operand field. Gas will emit a 0 after the
    last character in the string operand.
  prefs: []
  type: TYPE_NORMAL
- en: .float    Single-precision floating-point values. One or more comma-separated
    32-bit single-precision floating-point expressions appear in the operand field.
  prefs: []
  type: TYPE_NORMAL
- en: .double    Double-precision floating-point values. One or more comma-separated
    64-bit double-precision floating-point expressions appear in the operand field.
  prefs: []
  type: TYPE_NORMAL
- en: Gas provides additional synonyms for some of the directives in this list; see
    the link to the Gas documentation in section 1.12, “For More Information,” on
    [page 43](chapter1.xhtml#pg_43).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of valid Gas data declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you declare a variable in this manner, Gas will associate the current
    location in the output object-code file with the label at the beginning of the
    line. It will then emit the appropriate-sized data value into memory at that location,
    adjusting the assembler’s *location counter* (which tracks the current location)
    by the size of each operand it emits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The label field in these data declaration directives is optional. If you do
    not include the label, Gas simply emits the data in the operand field, starting
    at the current location counter and incrementing the location counter afterward.
    This is useful, for example, when you want to insert a control character or special
    Unicode character into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Gas allows C-style escape sequences within quoted strings. Although Gas doesn’t
    support the full set of escape characters, it does support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: \b        Backspace character (0x08)
  prefs: []
  type: TYPE_NORMAL
- en: \n        Newline character/line feed (0x0A)
  prefs: []
  type: TYPE_NORMAL
- en: \r        Carriage return (0x0D)
  prefs: []
  type: TYPE_NORMAL
- en: \t         Tab (0x09)
  prefs: []
  type: TYPE_NORMAL
- en: \f        Form feed character (0x0C)
  prefs: []
  type: TYPE_NORMAL
- en: \\         Backslash character
  prefs: []
  type: TYPE_NORMAL
- en: \nnn    Where nnn is a three-digit octal value; emit the value to the code stream
  prefs: []
  type: TYPE_NORMAL
- en: \xhh    Where hh is a two-digit hexadecimal value; emit the value to the code
    stream
  prefs: []
  type: TYPE_NORMAL
- en: Gas does not support \a, \e, \f, \v, \', \", \?, \uhhhh, or \Uhhhh escape sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 1.7.1 Associating Memory Addresses with Variables'
  prefs: []
  type: TYPE_NORMAL
- en: 'With an assembler like Gas, you don’t have to worry about numeric memory addresses.
    Once you declare a variable in Gas, the assembler associates that variable with
    a unique set of memory addresses. For example, say you have the following declaration
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Gas will find an unused 8-bit byte in memory and associate it with the i8 variable;
    it will likewise associate a pair of consecutive unused bytes with i16, 4 consecutive
    unused bytes with i32, and 8 consecutive unused bytes with i64. You’ll always
    refer to these variables by their names and generally don’t have to concern yourself
    with their numeric addresses. Still, be aware that Gas is doing this for you.
  prefs: []
  type: TYPE_NORMAL
- en: When Gas is processing declarations in a .data section, it assigns consecutive
    memory locations to each variable. Assuming i8 (in the previous declarations)
    as a memory address of 101, Gas will assign the addresses appearing in [Table
    1-1](chapter1.xhtml#tab1-1) to i8, i16, i32, and i64.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-1: Variable Address Assignments'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Memory address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | 101 |'
  prefs: []
  type: TYPE_TB
- en: '| i16 | 102 (address of i8 plus 1) |'
  prefs: []
  type: TYPE_TB
- en: '| i32 | 104 (address of i16 plus 2) |'
  prefs: []
  type: TYPE_TB
- en: '| i64 | 108 (address of i32 plus 4) |'
  prefs: []
  type: TYPE_TB
- en: Technically, Gas assigns offsets into the .data section to variables. Linux/macOS
    converts these offsets to physical memory addresses when it loads the program
    into memory at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have multiple operands in a data declaration statement, Gas will
    emit the values to sequential memory locations in the order in which they appear
    in the operand field. The label associated with the data declaration (if one is
    present) is associated with the address of the first (leftmost) operand’s value.
    See [Chapter 4](chapter4.xhtml) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.2 Aligning Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted already, your programs may run faster if your variables are aligned
    on a *natural boundary* (alignment to the size of the object). Alignment is accomplished
    with the .align directive, which you saw in Listing 1-1.
  prefs: []
  type: TYPE_NORMAL
- en: Byte variables don’t require any alignment. Use the .align 1 directive to put
    half words at an even address (2-byte boundary); remember, Gas will align the
    next statement on a boundary that is equal to 2*^n*, where *n* is the .align statement’s
    operand. For words, use the .align 2 directive. For double words (.dword), use
    the .align 3 directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s return to the declaration given earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Sticking .align directives in front of every declaration (except i8) will start
    to clutter up your code and make it harder to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If your variables don’t have to be declared in a particular order, you can
    clean this up by declaring the largest variables first and the remaining variables
    sorted by decreasing size. If you do this, you have to align only the first variable
    in your declaration list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because the i64 declaration appears immediately after the .align 3 statement
    in this code, the i64 address will be aligned on an 8-byte boundary. As i32 immediately
    follows i64 in memory, it will also be aligned on an 8-byte boundary (which, of
    course, is also a 4-byte boundary). This is because i64 is aligned on an 8-byte
    boundary and consumes 8 bytes; therefore, the address following i64 (the address
    of i32) will also be 8-byte aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, because i16 immediately follows i32 in memory, it will be aligned
    on a 4-byte boundary (which is also an even address). The alignment of i8 doesn’t
    matter, but it happens to be at an even address, as it follows i16, which was
    aligned on a 4-byte boundary and consumes 2 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Gas also provides a* .balign *directive whose operand must be a power of 2
    (1, 2, 4, 8, 16, ...) to specify the alignment value directly, rather than as
    a power of 2\. While this book uses* .align *because it’s the original directive,
    feel free to use* .balign *if you prefer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Strings are sequences of bytes, so their alignment usually doesn’t matter. However,
    it is possible to write very high-performance string functions in assembly language
    that process strings eight or more characters at a time. If you have access to
    such library code, it might run faster if your strings are aligned on an 8-byte
    boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, floats and doubles should be aligned on 4-byte and 8-byte boundaries
    for the highest performance. In fact, as you’ll see in [Chapter 11](chapter11.xhtml),
    16-byte alignment is also sometimes better.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.3 Declaring Named Constants in Gas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gas allows you to declare manifest constants by using the .equ directive. A
    *manifest constant* is a symbolic name (identifier) that Gas associates with a
    value. Everywhere the symbol appears in the program, Gas will directly substitute
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A manifest constant declaration takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, label is a legal Gas identifier, and expression is a constant arithmetic
    expression (typically a single literal constant value). The following example
    defines the symbol dataSize to be equal to 256:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Constant declarations, or *equates* in Gas terminology, may appear anywhere
    in your Gas source file prior to their first use: in a .data section, in a .text
    section, or even outside any sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you define a constant symbol with .equ, it cannot be further modified
    in the source file during assembly. If you need to reassign the value associated
    with a label during assembly (see [Chapter 13](chapter13.xhtml) for reasons you’d
    want to do this), use the .set directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Equates can specify textual arguments as well as numeric constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Gas will run your source files through the CPP if the filename suffix
    is *.S*, you can also use the CPP #define macro definition to create named constants.
    Although the .equ directive is probably the better choice, the C macro form offers
    a few advantages, like allowing arbitrary textual substitution, not just numeric
    expression substitution. For more on this, see [Chapter 13](chapter13.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.4 Creating Register Aliases in Gas and Substituting Text
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you begin to write more complex ARM assembly language programs, you’ll discover
    that the 32 general-purpose register names (X0 to X30 and SP) obscure the meaning
    of their values in the program. It’s been decades since BASIC supported only variable
    names like A0, A1, B2, and Z3\. To avoid returning to those days by using meaningless
    two-character names, Gas provides a way to create more meaningful aliases of register
    names in your programs: the .req directive.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the .req directive is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: where symbolicName is any valid Gas identifier and register is one of the 32-
    or 64-bit register names. After this statement in the source file, if you use
    symbolicName in place of register, Gas will automatically substitute that register
    for the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, the .req directive works only for creating register aliases; you can’t
    use it as a general-purpose text-substitution facility. However, if you name your
    assembly language source files with *.S*, Gas/GCC will first run your source file
    through the CPP. This allows you to embed C/C++ #define statements in your assembly
    source file, and the CPP will happily expand any symbols you define in such statements
    throughout your source file. The following example demonstrates using #define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, you’ll use .req for register aliases and #define for any other textual
    substitutions in the source file, though my personal preference is to use the
    #define statement for both purposes in this book. Since #define also accepts parameters,
    it’s flexible. Gas also supports textual substitution via *macros*; see [Chapter
    13](chapter13.xhtml) for more on this.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Basic ARM Assembly Language Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, the programming examples in this chapter have consisted of functions
    that use only the ret instruction. This section describes a few more instructions
    to get you started writing more meaningful assembly language programs.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 1.8.1 ldr, str, adr, and adrp'
  prefs: []
  type: TYPE_NORMAL
- en: One solidly RISC feature of ARM is its use of *load/store architecture*. All
    computational activity takes place in the ARM’s registers; the only instructions
    that access main memory are those that load a value from memory or store a value
    into memory.
  prefs: []
  type: TYPE_NORMAL
- en: Although the ARM64 has many general-purpose registers for holding variable values
    (and thus can avoid using memory), most applications use more variable data than
    can fit in all the registers. This is especially true for larger objects like
    arrays, structs, and strings. Furthermore, programming conventions—known as the
    *application binary interface (ABI)*, discussed later in this chapter—often reserve
    many of ARM’s registers so they cannot be used to hold application variables for
    any length of time. So variables must be placed in main memory and accessed via
    these ldr (load) and str (store) instructions.
  prefs: []
  type: TYPE_NORMAL
- en: This is the generic syntax for the load and store instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: where size is either absent or one of the character sequences b, h, sb, sh,
    or sw; reg is one of the ARM’s 32- or 64-bit registers; and mem is a memory addressing
    mode that specifies where to fetch the data from in memory. The ldr instruction
    loads the register specified by reg from the memory location specified by mem.
    The str instruction stores the value held in the register operand into the memory
    location.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](chapter2.xhtml) discusses the size operand in greater depth, but
    this chapter largely ignores the size suffixes on the ldr and str instructions.
    Without a size prefix, the reg operand determines the operation’s size. If reg
    is X*n*, the instruction transfers 64 bits; if it’s W*n*, then the instruction
    transfers 32 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: The mem operand is either the name of a variable in your program, typically
    in the .data section (Linux only), or a register name surrounded by square brackets
    ([]). In this latter case, the register holds the numeric memory address of the
    memory location to access. See [Chapter 3](chapter3.xhtml) for more on mem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because macOS requires that your applications be written in a position-independent
    fashion (as we just discussed in “Linux vs. macOS: Position-Independent Executables”),
    you will not be able to use an ldr instruction of this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the i64 variable, you must first load its address into a 64-bit register,
    then access that data by using the *register-indirect addressing mode*, or X*n*.
    To do so, place the address of the variable you want to access in the register
    by using the adr and adrp instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, reg64 is the name of a 64-bit general-purpose register, and mem is a memory
    addressing mode, like the name of a global variable. The adr instruction loads
    reg with the address of the memory variable, which must be ±1MB from the adr instruction
    if the operand is just the name of a variable (like i64 from the previous example).
    The adrp instruction loads the 64-bit destination register with the page (4,096-byte
    boundary) containing the memory object. That value will have the LO 12 bits containing
    all 0s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of macOS’s PIE requirements, it doesn’t take kindly to instructions
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: On the Mac, you must use the register-indirect addressing mode to access a global
    variable. Unfortunately
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'fails for the same reason: you’re not allowed to specify the name of a global
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, to get the address of a global variable into a register under
    macOS, we’ll use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The lea (load effective address) macro, included in *aoaa.inc*, will expand
    into two instructions (different ones depending on your OS). These instructions
    will load the address of the second operand (mem) into the 64-bit register specified
    by the first operand (reg). You can use lea in any projects where you’ve included
    *aoaa.inc* at the beginning of your source file.
  prefs: []
  type: TYPE_NORMAL
- en: As noted, the *aoaa.inc* macros make the code in this book portable between
    OSes. However, you can choose to go with the appropriate OS-specific code, which
    can sometimes be more efficient, once you master basic ARM assembly language programming.
    See [Chapter 7](chapter7.xhtml) for more details on lea.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this discussion of taking the address of a variable, let’s recap
    how to load and store values by using ldr and str:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When loading X0 with a variable’s value, you can first load X0 with the address
    of the variable and then load X0 indirectly from the location held in X0\. This
    winds up using only a single register. However, when storing data to memory, you
    need a second register to hold the address (X1 in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are referencing a particular variable several times within a small section
    of code, it’s more efficient to load its address into a register just once and
    reuse that register value multiple times, rather than constantly reloading the
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this means you can’t use the register for any other purpose while
    it holds i64’s address. Fortunately, for just this reason, the ARM64 has lots
    of registers.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.2 mov
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Beyond the ldr and str instructions, the mov instruction handles two additional
    data movement operations: moving data between a pair of registers and copying
    a constant into a register. The generic syntax for mov is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first mov instruction copies the data in the source register (regsrc) into
    the destination register (regdest). This instruction is equivalent to the C/C++
    statement regdest = regsrc;. The source and destination registers can be any of
    the general-purpose registers but must be the same size (32 or 64 bits).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second mov instruction moves a small integer constant into the destination
    register. Constants encoded as part of the instruction are known as *immediate
    constants* and are generally preceded by a # character (though Gas often allows
    you to drop the # when specifying literal numeric constants). [Chapter 2](chapter2.xhtml)
    discusses limitations on constants, but for now, assume any constant less than
    ±2,047 will work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of the mov instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many additional variants of mov, covered in depth in later chapters.
    For example, if you encounter a constant you cannot load into a register with
    a single mov instruction, other variants of mov let you load any arbitrary 32-
    or 64-bit constant by using two to three instructions. In the meantime, this variant
    of the ldr instruction will load any constant into a register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The assembler will simply store veryLargeConstant in a memory location somewhere
    and then load the contents of that memory location to the specified register.
    Use this handy pseudo-instruction when you need to load a large constant into
    a register with a single instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 1.8.3 add and sub'
  prefs: []
  type: TYPE_NORMAL
- en: 'The add and sub instructions handle simple arithmetic on the ARM CPU. These
    instructions take many forms covered more thoroughly in the next couple of chapters.
    Their basic forms are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, regdest, reglsrc, and regrsrc are 32- or 64-bit registers (which must
    all be the same size for a given instruction), and const is an immediate constant
    in the range 0 to 4,095\. You’ll learn to specify larger constants later, but
    these forms are sufficient for the example programs in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some assemblers allow a range of –4,095 to +4,095 and swap the* add *and*
    sub *instructions if the immediate constant is negative.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The instructions with the s suffix affect the condition code flags. They set
    the flags according to the conditions specified in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**N**    Set if the arithmetic operation produces a negative result (high-order,
    or HO, bit is set); clear if it produces a nonnegative result (HO bit is clear).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**    Set if the arithmetic operation produces a 0 result; clear if it produces
    a nonzero result.'
  prefs: []
  type: TYPE_NORMAL
- en: '**C**    Set if the addition operation produces an unsigned overflow (carry
    out of the HO bit). Clear if a subtraction operation produces a borrow (unsigned
    underflow), and set otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**V**    Set if the arithmetic operation produces a signed overflow (carry
    out of the next-to-HO bit).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions negate their source operands, because they subtract
    the source register from 0 (remember that WZR and XZR are the zero registers and
    return 0 when read):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Gas provides synonyms for these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: These forms are a little easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.4 bl, blr, and ret
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calling procedures and functions is handled by the bl (branch and link) and
    blr (branch and link through register) instructions. Here’s their syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: where label is a statement label preceding code in the .text section, and Xn
    represents one of the 64-bit registers. These two instructions copy the address
    of the next instruction (following the bl or blr instruction) into the link register
    (LR/X30), then transfer control either to the target label or to the address specified
    by the contents of X*n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bl instruction does have a minor limitation: it can transfer control only
    to a statement label within ±128MB of the current instruction. This is generally
    far more than enough for any function you’ll write. In theory, if the OS loads
    code into another section (besides .text), it could be placed sufficiently far
    away that it would exceed this range. The OS linker will probably complain if
    this occurs. This book generally places all code within the .text section, as
    it would be rare for such programs to exceed this limitation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The blr instruction copies the full 64-bit address from X*n* into the PC (after
    copying the address of the next instruction into LR). Therefore, blr does not
    have the range limitation of the bl instruction. If you ever do encounter the
    range limitation when using bl, overcome it by using the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will load the address of farAwayProcedure into X0 (no matter where it appears
    in memory), then transfer control to that procedure via blr.
  prefs: []
  type: TYPE_NORMAL
- en: The ret instruction has appeared in several examples up to this point. It copies
    the contents of the LR (X30) register into the PC. Assuming that LR was loaded
    with a value as a result of executing the bl or blr instruction, this returns
    control to the instruction following the bl/blr.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bl, blr, and ret instructions have one issue: the ARM architecture tracks
    only a single subroutine call with the LR register. Consider the following code
    fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When the OS calls the main program, it loads the LR register with the return
    address back to the OS. Normally, when the main program completes execution, its
    ret instruction transfers control to this location. However, that’s not the case
    in this example: when the main program begins execution, it immediately calls
    someFunc with the bl instruction. This instruction copies its return address (the
    address of the main program’s ret instruction) into the LR register, wiping out
    the OS’s return address currently residing there. When someFunc executes the return
    instruction, it returns control back to the main program.'
  prefs: []
  type: TYPE_NORMAL
- en: Upon return from someFunc, the main program executes the ret instruction. However,
    the LR register now contains the return address of the someFunc call, which is
    the address of the ret instruction in the main program, so control transfers there,
    re-executing ret. The LR register’s value hasn’t changed; it still points at that
    ret instruction, meaning this code enters an infinite loop continuously executing
    the return and transferring control back to the return (where LR continues to
    point).
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](chapter3.xhtml) discusses the high-level solution to this problem.
    For the time being, we must save the LR register value in the main program before
    calling someFunc. One quick-and-dirty way to do this is to copy it into another
    (unused by main) register and restore LR before the final return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This code saves the return address (in LR) in the X1 register and restores it
    after returning from someFunc (the call to someFunc overwrote the value in LR).
  prefs: []
  type: TYPE_NORMAL
- en: In general, saving the return address in the X1 register is a bad idea, because
    the ARM’s designers reserve X1 for passing parameters. (Using X1 worked in this
    example because someFunc doesn’t have any parameters, as it just returns to its
    caller.) The next section covers in greater depth which registers are reserved
    for various purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9 The ARM64 Application Binary Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A CPU’s *application binary interface (ABI)* describes how programs should use
    registers, pass parameters between functions, represent data, and many other conventions.
    Its primary purpose is to provide interoperability among programming languages
    and systems. The ARM64’s ABI, for example, describes the conventions that allow
    C/C++ programs to call functions written in Swift, Pascal, and other languages.
    Since the GCC (and Clang) compilers follow these rules, you must also follow them
    to pass information between your assembly language code and code written in an
    HLL such as C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: An ABI is a *convention*, not an absolute rule. It is a contract between the
    code being called and the code making the call. When writing your own assembly
    language functions to be called by your own assembly language code, you are under
    no obligation to use the ABI and can use whatever inter-code communication scheme
    you like. However, if you call C/C++ code from your assembly functions, or if
    your assembly code is being called from C/C++, you must follow the ARM64 ABI.
    Since this book uses a considerable mixture of C/C++ and assembly code, understanding
    the ARM64 ABI is critical for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.1 Register Usage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM64 ABI reserves some of its 32 general-purpose registers for specific
    uses and defines whether registers are *volatile* (meaning you don’t have to preserve
    their values) or *nonvolatile* (meaning that you must preserve their values within
    a function). [Table 1-2](chapter1.xhtml#tab1-2) describes the special purposes
    and volatility of the 32 ARM registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-2: ARM64 ABI Register Conventions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Register | Volatile | Special meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| X0/W0 | Yes | Pass parameter 1 here, return function results here. Registers
    X0 through X7 can also be used as a scratchpad/temporary/ local variable if not
    used as a parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| X1/W1 | Yes | Pass parameter 2 here, return function results here. |'
  prefs: []
  type: TYPE_TB
- en: '| X2/W2 | Yes | Pass parameter 3 here, return function results here. |'
  prefs: []
  type: TYPE_TB
- en: '| X3/W3 | Yes | Pass parameter 4 here, return function results here. |'
  prefs: []
  type: TYPE_TB
- en: '| X4/W4 | Yes | Pass parameter 5 here, return function results here. |'
  prefs: []
  type: TYPE_TB
- en: '| X5/W5 | Yes | Pass parameter 6 here, return function results here. |'
  prefs: []
  type: TYPE_TB
- en: '| X6/W6 | Yes | Pass parameter 7 here, return function results here. |'
  prefs: []
  type: TYPE_TB
- en: '| X7/W7 | Yes | Pass parameter 8 here, return function results here. |'
  prefs: []
  type: TYPE_TB
- en: '| X8/W8 | Yes | Pointer to large function return results (for example, a large
    C structure returned by value). |'
  prefs: []
  type: TYPE_TB
- en: '| X9/W9 X10/W10'
  prefs: []
  type: TYPE_NORMAL
- en: X11/W11
  prefs: []
  type: TYPE_NORMAL
- en: X12/W12
  prefs: []
  type: TYPE_NORMAL
- en: X13/W13
  prefs: []
  type: TYPE_NORMAL
- en: X14/W14
  prefs: []
  type: TYPE_NORMAL
- en: X15/W15 | Yes Yes
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Yes | Can be used as a scratchpad/temporary/local variable. |
  prefs: []
  type: TYPE_NORMAL
- en: '| X16/W16/IP0 | Yes, but ... | You can use this register as a temporary variable,
    but its value may change across the execution of a control-transfer instruction;
    the system linker/loader may use this register to create a veneer, also known
    as a trampoline (more on this in [Chapter 7](chapter7.xhtml)). |'
  prefs: []
  type: TYPE_TB
- en: '| X17/W17/IP1 | Yes, but ... | You can use this register as a temporary variable,
    but its value may change across the execution of a control-transfer instruction;
    the system linker/loader may use this register to create a veneer, also known
    as a trampoline (more on this in [Chapter 7](chapter7.xhtml)). |'
  prefs: []
  type: TYPE_TB
- en: '| X18/W18/Plat | No access | This register is reserved for use by the OS, and
    application programs must not modify its value. Under macOS, you definitely must
    not modify this register; under Linux, you may get away with using this register
    if you preserve its value, but the safe choice is to avoid using this register.
    |'
  prefs: []
  type: TYPE_TB
- en: '| X19/W19 X20/W20'
  prefs: []
  type: TYPE_NORMAL
- en: X21/W21
  prefs: []
  type: TYPE_NORMAL
- en: X22/W22
  prefs: []
  type: TYPE_NORMAL
- en: X23/W23
  prefs: []
  type: TYPE_NORMAL
- en: X24/W24
  prefs: []
  type: TYPE_NORMAL
- en: X25/W25
  prefs: []
  type: TYPE_NORMAL
- en: X26/W26
  prefs: []
  type: TYPE_NORMAL
- en: X27/W27
  prefs: []
  type: TYPE_NORMAL
- en: X28/W28 | No No
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: No | A function using this register must save and restore the register’s value
    so that it contains its original value when the function returns. |
  prefs: []
  type: TYPE_NORMAL
- en: '| X29/W29/FP | N/A | Reserved for use as the system frame pointer. |'
  prefs: []
  type: TYPE_TB
- en: '| X30/W30/LR | N/A | Reserved for holding function return addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| SP /X31/W31 | N/A | Reserved for use as the system stack pointer. |'
  prefs: []
  type: TYPE_TB
- en: Conveniently, when using volatile registers in a function, you don’t have to
    preserve (save and restore) their values within the function. However, this means
    that you also cannot expect them to maintain their values across any functions
    you call via bl or blr. Nonvolatile registers will maintain their values across
    function calls you make, but you must explicitly preserve their values if you
    modify them within your functions.
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.2 Parameter Passing and Function Result Conventions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 5](chapter5.xhtml) provides a complete discussion of parameter passing
    and function results in assembly language. However, when calling functions written
    in a different languages (particularly HLLs), you must adhere to the conventions
    that language uses. Most HLLs use the ARM ABI as the convention for passing parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: The ARM ABI uses registers X0 through X7 to pass up to eight integer parameters
    to a function. These parameters can be 8-, 16-, 32-, or 64-bit entities. You pass
    the first parameter in X0, the second in X1, and so on. To pass fewer than eight
    parameters, simply ignore the additional registers in this set. [Chapter 5](chapter5.xhtml)
    discusses how to pass more than eight parameters and how to pass data types larger
    than 64 bits, including arrays and structs. [Chapter 6](chapter6.xhtml) covers
    how to pass floating-point values to a function.
  prefs: []
  type: TYPE_NORMAL
- en: You can also return function results in these registers. Most functions return
    integer results in X0\. If you’re returning a large object by value, like a structure,
    array, or string, you typically use X8 to return a pointer to that data object.
    [Chapter 6](chapter6.xhtml) discusses returning floating-point function results.
  prefs: []
  type: TYPE_NORMAL
- en: Registers X0 through X7 are volatile, meaning you can’t expect a called function
    to preserve the original register values on return. This is true even if you don’t
    use all eight registers to pass parameter values. If you want to preserve a value
    across function calls, use a nonvolatile register.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 Calling C Library Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the coding examples in this book so far have immediately returned to the
    OS, apparently without accomplishing anything. While it is theoretically possible
    for a pure assembly language program to produce its own output, it takes a lot
    of work and is largely beyond the scope of this book. Instead, this book calls
    prewritten C/C++ library code to do the I/O. This section discusses how this is
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Most other books on assembly language that use libraries in this way call the
    OS by using available *application programming interfaces (APIs)*. This is a reasonable
    approach, but such code is tied to the particular OS for which the calls are made
    (see [Chapter 16](chapter16.xhtml) for examples). This book instead relies on
    library functions written in the C stdlib, since it’s available on many OSes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most introductory programming books, the first programming example provided
    is the venerable “Hello, world!” program. Here’s that program written in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Except for an actual printf() statement, the assembly language source files
    given thus far have fulfilled the purpose of the “Hello, world!” example: learning
    how to edit, compile, and run a simple program.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of this book uses the C printf() function to handle program output to the
    console. This function requires one or more arguments—that is, a *variable-length*
    parameter list. The first argument is the address of a *format string*. If that
    string requires it, additional parameters provide data to convert to string form.
    For the “Hello, world!” program, the format string ("Hello, world!\n") is the
    only argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C stdlib—and all C functions, for that matter—adheres to the ARM ABI. Therefore,
    printf() expects its first argument, the format string, in the X0 register. Instead
    of trying to pass a string (with 14 characters, including the newline) in a 64-bit
    register, we pass the address of that string in memory. If we put the string "Hello,
    world!\n" in the .text section along with the program (out of the way, so the
    CPU doesn’t try to execute it as code), then we can compute the address of that
    string by using the lea macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have this string address in X0, calling printf() prints that string
    to the standard output device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To run, this program must be linked against the C stdlib and a small C/C++ program
    like the one in Listing 1-2\. Rather than grabbing that program, I’ll create a
    slightly better version in Listing 1-4 to use with almost every example program
    in the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This program contains a few additional features over Listing 1-2\. First, the
    name of the assembly language function has changed to asmMain() ❶, the assembly
    language main program. This code also requires a second assembly function, getTitle()
    ❷. This function, provided by the assembly language source code, returns a pointer
    to a zero-terminated string containing the program’s title. The program displays
    this title before and after calling asmMain().
  prefs: []
  type: TYPE_NORMAL
- en: The readLine() function appears in the C program that reads a line of text from
    the user and stores that text into a buffer specified by the caller ❸. You can
    call this function from the example assembly code, sparing you from having to
    write the function in assembly (it’s grunt work better done in C). You’ll see
    examples of this function call in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: This file (appearing as *Listing1-4.cpp* or *c.cpp* in the online code) requires
    the assembly code to provide a getTitle() function that returns the address of
    a string so the C program can display the name. This string is embedded in the
    assembly language source file, since most of the programs in this book use only
    one version of *c.cpp*. The getTitle() function is the same in every program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'where title is a zero-terminated string appearing elsewhere in your program
    (usually in the .data section). That declaration will usually take this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The getTitle function returns the address of this string to the *c.cpp* program.
    The string following the .asciz directive will typically be the name of the assembly
    language source file (I used *Listing1-5* in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.1 Assembling Programs Under Multiple OSes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We could easily bang out a “Hello, world!” program for Linux or macOS at this
    point, but the programs would be slightly different for each OS. So that we don’t
    need to use a different include file for each OS, I’ve modified *aoaa.inc* to
    look for a couple of symbol definitions: isMacOS and isLinux. Both symbols must
    be defined with the CPP #define declaration, and one must be true (1) while the
    other is false (0). The *aoaa.inc* file uses these symbols to adjust the definitions
    present in the file for the appropriate OS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, we could use code like the following to define these symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this would force every example program to have two versions, one for
    macOS (the example just given) and one for Linux, containing the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'GCC has a preferable command line option that lets you define a preprocessor
    symbol and give it a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the following commands will automatically define the symbol prior
    to assembling the *source.S* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We can specify the OS from the command line in this way so that the source files
    (*source.S* and *aoaa.inc*) don’t require any changes under either macOS or Linux.
    To avoid any extra typing required to assemble the program, we’ll use a command
    line program known as a *shell script*.
  prefs: []
  type: TYPE_NORMAL
- en: While writing a shell script for this purpose, I also further automated the
    build process. The script, named *build*, accepts the base name of an example
    file without a suffix and automatically deletes any existing object or executable
    files with that base name (a *clean* operation, in Unix terminology). It then
    determines which OS *build* is running on and then automatically generates the
    appropriate GCC command line to build the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to build a file named *example.S*, you’d execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Under Linux, this would generate the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Under macOS, it would generate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The *build* script also supports a couple of command line options: -c and -pie.
    The -c (compile-only) option generates the following command line, which only
    assembles the assembly file to an object file; it does not compile *c.cpp*, nor
    does it produce an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This executes the following command as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The -pie option applies only to Linux. It issues the appropriate commands to
    tell Linux to produce a position-independent executable file (by default, Linux
    produces a non-position-independent executable). Because macOS’s assembler always
    produces PIE code, this option is ignored under macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious, I’ve provided the text for this shell script in the file *build*
    without further comment, as writing shell scripts is beyond the scope of this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Check out a book on GNU’s bash shell interpreter if you want to learn how this
    works (see section 1.12, “For More Information,” on [page 43](chapter1.xhtml#pg_43)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The *build* shell script is available in electronic form at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
    Execute the following command to make this file executable from the bash command
    line on your Linux or macOS system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This makes the *build* script executable. See [Appendix D](appendix-D.xhtml)
    for more information about the chmod command.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.2 Writing a “Hello, World!” Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You finally have the pieces in place to write a complete “Hello, world!” program,
    as shown in Listing 1-5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The title string ❶ holds the program’s title ("Listing 1-5" in this example).
    The hwStr variable holds the Hello, world! string that the main program will pass
    to the printf() function. The getTitle() function ❷ returns the address of the
    title string to the *c.cpp* program. As per the ARM ABI, this function returns
    the function result in the X0 register.
  prefs: []
  type: TYPE_NORMAL
- en: Upon entry into the asmMain() function (the assembly language main program),
    the code must preserve the contents of the LR register because the call to printf()
    will overwrite its value. This code saves the LR register (which holds the return
    address to the *c.cpp* main function) in the saveLR global variable in the .data
    section ❶.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Saving the LR register value in this fashion is not good practice. In [Chapter
    3](chapter3.xhtml) you’ll learn about the ARM stack and discover a much better
    place to save return addresses held in LR.*'
  prefs: []
  type: TYPE_NORMAL
- en: The code that actually prints Hello, world! ❸ loads X0 with the printf() format
    string as per the ARM ABI, then calls printf() by using the bl instruction. Before
    returning to *c.cpp*, the assembly code must reload LR with the returned address
    held in saveLR ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the commands to build and run the program in Listing 1-5, along with
    the program’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You now have a functioning “Hello, world!” program in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter equipped you with the prerequisites to start learning new assembly
    language features in the chapters that follow. You learned the basic syntax of
    a Gas program and the basic 64-bit ARM architecture, and how to use the *aoaa.inc*
    header file to make source files portable between macOS and Linux. You also learned
    how to declare some simple global variables, use a few machine instructions, and
    assemble a Gas program with C/C++ code so you can call routines in the C stdlib
    (using the *build* script file). Finally, you ran that program from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces you to *data representation*, one of the main reasons
    for learning assembly language in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the bash shell interpreter, visit the reference manual
    at *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/bash<wbr>/manual<wbr>/bash<wbr>.html](https://www.gnu.org/software/bash/manual/bash.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about the GNU assembler, visit the reference manual at
    *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find an online guide to 64-bit ARM assembly language at *[https://<wbr>modexp<wbr>.wordpress<wbr>.com<wbr>/2018<wbr>/10<wbr>/30<wbr>/arm64<wbr>-assembly<wbr>/](https://modexp.wordpress.com/2018/10/30/arm64-assembly/)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re interested in programming ARM assembly language on Apple platforms,
    see *[https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/xcode<wbr>/writing<wbr>-arm64<wbr>-code<wbr>-for<wbr>-apple<wbr>-platforms](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM developer portal at *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*
    provides generic information about ARM CPUs and ARM assembly language programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
